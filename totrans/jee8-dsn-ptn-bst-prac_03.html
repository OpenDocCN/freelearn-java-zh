<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Business Patterns</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we will cover definitions of the Business Delegate pattern, the Session Façade pattern, and the business-object pattern. We will show the reasons to use these design patterns, common approaches to each of them, their interaction with other patterns, their evolution, and how they behave in the real world. We will also demonstrate some examples of these patterns' implementations.</p>
<p class="mce-root">At the end of the chapter, you will be able to identify the correct scenarios to apply business patterns and choose the best methods for implementing them. The following topics will be covered:</p>
<ul class="calibre15">
<li class="calibre16">Understanding the business tier</li>
<li class="calibre16">Explaining the Business Delegate pattern</li>
<li class="calibre16">Explaining the Session Façade pattern</li>
<li class="calibre16">Implementing the Session Façade pattern</li>
<li class="calibre16">Explaining the business-object pattern</li>
<li class="calibre16">Implementing the business-object pattern</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding the business tier</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before talking about the business patterns and the use of these patterns from the perspective of JEE8 and its technologies, we must identify where the business logic of an application will be<span class="calibre10"> within the JEE </span><span class="calibre10">framework</span><span class="calibre10">. As we have already seen, JEE</span><span class="calibre10"> </span><span class="calibre10">architecture </span><span class="calibre10">basically</span><span class="calibre10"> </span><span class="calibre10">has three tiers. Most JEE technologies, such as <strong class="calibre8">Enterprise Java Beans </strong>(<strong class="calibre8">EJB</strong>) and <strong class="calibre8">Java Persistence API</strong> (<strong class="calibre8">JPA</strong>), are related to the business tier. The EJB container is located in the business tier, but there are a few other technologies that navigate the entire JEE framework, such as CDI and Bean Validation. However, the most important thing to know is that the core business-logic application is executed in the business tier.</span></p>
<p class="mce-root"/>
<p class="mce-root">We will see three important patterns in the<span class="calibre10"> </span><span class="calibre10">business tier</span>. We will briefly explain the definition and goal of each pattern:</p>
<ul class="calibre15">
<li class="calibre16">
<p class="calibre17"><strong class="calibre8">Business Delegate pattern</strong>: It is a proxy for the business service, hiding the service lookup and the remote invocation. </p>
</li>
<li class="calibre16">
<p class="calibre17"><strong class="calibre8">Session Façade </strong><span class="calibre10"><strong class="calibre8">pattern</strong>: Encapsulates business rules and exposes coarse-grained services to clients.</span></p>
</li>
<li class="calibre16">
<p class="calibre17"><strong class="calibre8">Business-object </strong><span class="calibre10"><strong class="calibre8">pattern</strong></span>: These are real-world objects with properties and methods for applications with a high level of complexity which help to separate business logic from the rest of the application, promoting a decoupling between business logic and the <span class="calibre10">rest of the application.</span></p>
</li>
</ul>
<p class="mce-root"><span class="calibre10">Let's look at the following diagram:</span></p>
<p class="cdpaligncenter2"><img src="Images/e328af9d-10e6-424c-80c5-e4116fba3328.png" class="calibre34"/></p>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">We will see later in this chapter that, although the Business Delegate is a business-tier component, its physical location is on the web tier.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the Business Delegate pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To explain the Business Delegate pattern, we need to understand some points that show the reason and evidence for the real goals of this pattern. Thus, we will show these points and explain the Business Delegate pattern in detail.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Client tier, presentation tier, and business tier</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Before we go on, here is a brief explanation of the concept of tiers and layers.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Layers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A layer is merely a logical division that has a responsibility within the architecture of the application. It is a logical way to organize the application code. Martin Fowler's book <em class="calibre12">Patterns of Enterprise Application Architecture</em> describes the three main layers and their responsibilities:</p>
<table border="1" class="calibre35">
<tbody class="calibre36">
<tr class="calibre37">
<td class="cdpaligncenter3"><strong class="calibre3">Layer</strong></td>
<td class="cdpaligncenter3"><strong class="calibre3">Responsibility</strong></td>
</tr>
<tr class="calibre38">
<td class="calibre39">Presentation</td>
<td class="calibre39">User interaction, validation of input fields, formatting display data</td>
</tr>
<tr class="calibre37">
<td class="calibre39">Business</td>
<td class="calibre39">Application logic</td>
</tr>
<tr class="calibre40">
<td class="calibre39">Data</td>
<td class="calibre39">Database communication, messaging-system communication</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">Thus, the classes of an application are logically separated according to their responsibilities. There are classes that are used in the data-access layer, while other classes prepare the data to be displayed as part of the presentation layer. This division is purely logical. A good architecture practice is to have a layered chain where a layer interacts with its adjacent layer, providing and consuming services. This leads to more cohesion (the same responsibilities are contained in the same layer) and low-coupling.</p>
<p class="mce-root">Let's look at the following diagram:</p>
<p class="cdpaligncenter2"><img src="Images/46bcf26c-96ea-4295-b37d-a63d6b04a013.png" width="691" height="481" class="calibre41"/></p>
<p class="mce-root">We can see that the JSF, JSP, and HTML pages, the bean-backing class, and even a servlet belong logically to the presentation layer group, since they have the same basic responsibility, which is to send information to the user and receive requests from a user. An EJB, a servlet (part of it), and a <strong class="calibre8">Business Object</strong> belong to the business layer. The DAO classes and the JPA entities belong to the data layer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Tiers</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">A tier is a physical unit, and it is related to hardware and software components. It is the infrastructure in which the layer components are deployed and executed. Examples of tiers are web browsers, application servers, and database servers. A typical <em class="calibre12">n</em>-tier application is defined with the following tiers:</p>
<table border="1" class="calibre35">
<tbody class="calibre36">
<tr class="calibre37">
<td class="cdpaligncenter3"><strong class="calibre3">Tier</strong></td>
<td class="cdpaligncenter3"><strong class="calibre3">Infrastructure</strong></td>
</tr>
<tr class="calibre38">
<td class="calibre39">Client </td>
<td class="calibre39">Web browsers, a mobile device</td>
</tr>
<tr class="calibre37">
<td class="calibre39">Presentation </td>
<td class="calibre39">Web server (container), HTTP protocol</td>
</tr>
<tr class="calibre38">
<td class="calibre39">Business</td>
<td class="calibre39">Application server (such as Java EE server)</td>
</tr>
<tr class="calibre42">
<td class="calibre39">Data/Integration</td>
<td class="calibre39">Database servers, messaging service, web services</td>
</tr>
</tbody>
</table>
<p class="mce-root"> </p>
<p class="mce-root">Let's look at the following diagram:</p>
<p class="cdpaligncenter2"><img src="Images/126719f2-c50e-4c1c-8f5a-e62737e33a1a.png" class="calibre43"/></p>
<p class="mce-root">Here, it is very important to note the difference between the client tier and the presentation tier. The client tier is where a client application is executed (through platforms such as a browser or a mobile application). Generally, the client tier is the client machine or device, and the presentation tier is represented by the web server. The presentation tier receives a data request from the client tier, prepares the data (with some format defined previously, if necessary), and sends it to the business tier. This is the classic mechanism of how data is processed in a JEE scenario. We can identify some technologies in the presentation tier, such as Servlets, JSP, JSF, WebSockets, JAX‐RS and JAX‐WS, Java API for JSON processing, JSON-B, CDI, and bean validation.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">Let's look at the following diagram:</p>
<p class="cdpaligncenter2"><img src="Images/2559f07b-01a4-48a9-87e0-4effbec201e9.png" class="calibre44"/></p>
<p class="mce-root">As previously discussed, it is in the business tier that all business logic is executed. The presentation tier is the client of the business tier because it requires operations of the business tier and receives the result that comes from the business tier. At this point, we can see an additional responsibility for the presentation tier, which is to locate the service and make the request. It would be interesting if we had a mechanism that delegated the request to the real service. <span class="calibre10">This is the role of the Business Delegate pattern, which prevents details of the business tier services from being exposed to the presentation tier. The coupling between the presentation and business tiers is reduced, and therefore modifications in the business tier have a minimal impact in the presentation tier.</span> </p>
<p class="mce-root">The Business Delegate pattern acts as an input door for the client. It is responsible for receiving the request, identifying or locating the real business service, and calling the service sending the request. After that, the delegate receives the service response and then sends the response back to the client.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The classic Business Delegate pattern scenario</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In a classic <span class="calibre10">Business Delegate pattern</span> scenario, the implementation of the Business Delegate pattern receives a request from a Java client and sends the response back to it. In addition, to minimize the coupling between the presentation tier and the business tier, it was the responsibility of a delegate to locate remote services (in most cases, a remote EJB service) and provide a caching mechanism for accessing business services to reduce the network traffic.</p>
<p class="mce-root"/>
<p class="mce-root">So, when EJB was used as a remote service in the past, <span class="calibre10">Business Delegate pattern</span>s were used with another pattern, the Service Locator Pattern, which is responsible for locating the remote (and local) EJB. Also, the stub (a kind of EJB reference based on the <strong class="calibre8">RMI</strong> (<strong class="calibre8">Remote Method Invocation</strong>) protocol) of the remote EJB is cached by the delegate.</p>
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">The following diagram shows the class diagram for the Business Delegate pattern. This represents the basic structure of this pattern. The client sends requests to the</span></span></span> <strong class="calibre8">Business Delegate</strong><span class="calibre10"><span class="calibre10"><span class="calibre10">, which in turn accesses the correct business service. The</span></span></span> <strong class="calibre8">Business Delegate</strong> <span class="calibre10"><span class="calibre10"><span class="calibre10">can use a service locator in the case of a remote service lookup:</span></span></span></p>
<div class="cdpaligncenter"><img src="Images/460cf5b5-4878-40d4-a4ad-a4c8e8becdb6.png" class="calibre45"/></div>
<p class="mce-root">As the <strong class="calibre8">Business Delegate</strong> re-passes the business request to the <strong class="calibre8">Business Service</strong>, one natural approach in code development is to make both classes (<strong class="calibre8">Business Delegate</strong> and <strong class="calibre8">Business Service</strong>) implement the same business interface.</p>
<p class="mce-root"/>
<p class="mce-root">This is shown in the following diagram:</p>
<div class="cdpaligncenter"><img src="Images/b33e8b74-438a-4b44-adc3-4dbd551678dc.png" width="932" height="633" class="calibre46"/></div>
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">In the following diagram, we show the sequence diagram for the Business Delegate pattern:</span></span></span></p>
<div class="cdpaligncenter"><img src="Images/1db85698-a1ad-44ee-9d45-263217219320.png" width="975" height="452" class="calibre47"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The benefits of the Business Delegate pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">According to the old J2EE architecture, the benefits of a Business Delegate included:</span></span></span></p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5"><span class="calibre5"><span class="calibre5"><span class="calibre5">Hiding the details of the underlying business service. In the case of remote services, using the </span></span></span></span><span class="calibre5"><span class="calibre5"><span class="calibre5"><span class="calibre5">Business Delegate</span></span></span></span> <span class="calibre5"><span class="calibre5"><span class="calibre5"><span class="calibre5">makes</span></span></span></span><span class="calibre5"><span class="calibre5"><span class="calibre5"><span class="calibre5"> naming and looking up services transparent to the presentation tier.</span></span></span></span></li>
<li class="calibre16"><span class="calibre5"><span class="calibre5"><span class="calibre5"><span class="calibre5">Handling business-service exceptions. The Business Delegate can catch service exceptions that have a technical meaning and translate them into a more friendly exception, generating application exception level to the client. For instance, Business Delegate could translate the eventual remote exceptions generated by a business service into a specific application exception.</span></span></span></span></li>
<li class="calibre16"><span class="calibre5">A Business Delegate can transparently carry out a new retry of a failed service execution and hide the problem from the client.</span></li>
<li class="calibre16">In addition, a Business Delegate can cache references to remote business services in order to improve performance. Calling a remote service is a costly operation, and the repetition of remote service calls can greatly increase network traffic.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">However, as new scenarios have arisen, things have evolved in the world of distributed application development. The JEE architecture has been changing in accordance with this. As modern mobile applications and web clients developed, n</span><span class="calibre10">ew client applications, </span><span class="calibre10">with rich JavaScript frameworks, have been emerging. As a consequence, the Business Delegate is seen as a bridge or door between the presentation tier (where technologies such as Servlet, JSP, and the JSF mechanism reside) and the business tier (where technologies such as EJB reside).</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Business Delegate – obsolete or not</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">In the old J2EE architecture, both remote and local business services, such as EJB, use a service locator mechanism. However, dependency injection is now used to access local EJBs (and the option for local services is increasingly being used). In many cases, using a Business Delegate to look for local services has become somewhat obsolete for this reason. </span></span></span><span class="calibre10"><span class="calibre10"><span class="calibre10">Consequently, someone could question the use of a pattern, such as Business Delegate, only to handle remote communications. This is because, since JEE5, we have begun to use DI annotations to reference local EJB with ease. However, if we think of a Business Delegate as a bridge for Session Bean EJBs, for example, then we can change these EJBs (when necessary) without having to worry about whether or not the presentation tier will be broken. If something changes in the session EJB, it is the Business Delegate's job to handle this change and keep the presentation tier intact.</span></span></span></p>
<p class="mce-root"><span class="calibre10">The following diagram shows the classic architecture of an application:</span></p>
<div class="cdpaligncenter"><img src="Images/38a77928-6931-4aa1-8b50-e65896a7c33d.png" class="calibre48"/></div>
<p class="cdpalignleft1">In some situations, this architecture was replaced by others, as shown in the following diagrams:</p>
<p class="cdpaligncenter2"><img src="Images/5670e52a-7936-4664-937f-6b46d7607ba3.png" class="calibre49"/></p>
<div class="cdpaligncenter"><img src="Images/100aa4e6-665d-46fe-b1e4-4851991e037f.png" class="calibre50"/></div>
<p class="mce-root"/>
<p class="mce-root">Looking at the two previous alternatives, we can see the way in which Business Delegate can be used when there is a need to change the business service layer. This can be done without impacting the presentation layer. In addition, when we need to handle business-service exceptions and we have a client other than a web browser, we can use a Business Delegate with a lookup mechanism (JNDI) for the business services (EJBs).</p>
<p class="mce-root"><span class="calibre10">There are several other architectures that can be used in application building. We will see that the use of the Business Delegate pattern occurs along with some other patterns, especially the Session Façade pattern, as shown in the diagrams. Another common pattern is the business-object pattern, which represents a real-world business object with properties and methods,</span> <span class="calibre10">not necessarily getter and setter methods.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the Session Façade pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">Before we introduce the Session Façade pattern, it is important to cover the façade patterns, which are one of the structural design patterns mentioned in the <strong class="calibre8">Gang of Four</strong> (<strong class="calibre8">GoF</strong>) book.</span></span></span></p>
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">The main goal is to encapsulate the complexity of business logic in a business interface. Broadly speaking, this interface only exposes a small number of coarse-grained methods to the client. Each of these interface methods is responsible for controlling the underlying complexity of business logic. In this way, the internal services of finer granularity can be combined into a set of services that are exposed by the interface method.</span></span></span></p>
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">The benefits of using a façade pattern are as follows:</span></span></span></p>
<ul class="calibre15">
<li class="calibre16"><span class="calibre5">It provides coarse‐grained methods for available services.</span></li>
<li class="calibre16"><span class="calibre5">It reduces remote calls. A remote client does not need to call many fine-grained business objects. Instead, it executes a remote call to the exposed interface method, which </span><span class="calibre5">is responsible for making local calls to the fine-grained objects.</span></li>
<li class="calibre16"><span class="calibre5">It can create a single channel to a legacy backend system.</span></li>
<li class="calibre16">It decreases the coupling between the client and the fine‐grained <span class="calibre5">objects.</span></li>
</ul>
<p class="mce-root">Let's say, for example, that there is a system for checking vacancies in hotels in a city. The hotels offer web services to be consulted about the vacancies. A client application that wants to know how many vacancies are available will have to make a call to each web service. But if we make a call to a façade layer, this façade could take responsibility for searching the web services. In addition to reducing calls, the façade removes the high coupling that would exist between the client and web services.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">By understanding the problem for which the GoF façade pattern is the solution, we can then see a similar problem with</span></span></span><span class="calibre10"><span class="calibre10"><span class="calibre10"> JEE. In this case, server-side components are implemented as <strong class="calibre8">Business Objects</strong> (<strong class="calibre8">BOs</strong>) or POJOs. Almost every request coming from the client needs a BO interaction, a</span></span></span><span class="calibre10"><span class="calibre10"><span class="calibre10">nd each BO involved in the request process may have a relationship with other BOs. In addition, the BO might have accessed an integration tier using a DAO pattern. </span></span></span><span class="calibre10"><span class="calibre10"><span class="calibre10">We do not want to expose the complexity of the business components and their internal relationships to clients—especially to remote clients. We then have a Session Façade pattern as a solution to this problem.</span></span></span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Benefits of Session Façade</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">It is important not </span></span></span><span class="calibre10">to</span><span class="calibre10"> </span><span class="calibre10">expose the client to the complexity of using these fine-grained BOs. Frequent access to a large set of fine‐grained components greatly increases the complexity of BOs control. Transaction-control, security-management, and service-lookup are all examples of this complexity.</span></p>
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">Like the GoF façade pattern, the use of a coarse-grained layer </span></span></span><span class="calibre10">in JEE </span><span class="calibre10">decreases the coupling between the client and the business components represented by BOs of fine granularity (and we can think of a Session Façade as an extension of the GoF façade pattern in JEE). The Session Façade pattern represents this coarse-grained layer. An architecture built with the Session Façade provides a facade of more generic (or coarse-grained) methods for clients. The two biggest benefits of using the Session Façade pattern are as follows:</span></p>
<ul class="calibre15">
<li class="calibre16">It does not expose the high complexity of the business objects (BOs) and their relationships. </li>
<li class="calibre16">It decreases network traffic. This occurs because remote calls are limited to coarse-grained methods exposed by Session Façade instead of the fine-grained business objects.</li>
</ul>
<p class="mce-root">Of course, EJB remote calling was used much more in the old JEE scenario in comparison to current architectures. It is important that this is taken into consideration. </p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the Session Façade pattern in JEE</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10"><span class="calibre10"><span class="calibre10">In the JEE architecture, Session Façade is implemented by a stateless or stateful EJB. An EJB object can use or combine other POJOs, business objects, and EJBs. At this point, we must be careful not to accumulate too many unnecessary layers, as we run</span></span></span> <span class="calibre10"><span class="calibre10"><span class="calibre10">the risk of having a chain of EJBs where one EJB calls another more internal EJB, and so on. </span></span></span><span class="calibre10"><span class="calibre10"><span class="calibre10">The services must be mapped and designed </span></span></span><span class="calibre10">well</span><span class="calibre10">.</span></p>
<p class="mce-root">Because the Session Façade is <span class="calibre10">primarily</span><span class="calibre10"> implemented by EJBs, services such as transaction-control and security-management come naturally to this technology. It is in this layer that we </span>usually have <span class="calibre10">the transaction-control of most internal objects, such as the POJOs,</span> which represent entities within the JPA technology. <span class="calibre10">For an EJB, JPA entity transaction control is native, meaning that it is supplied by the JEE container. This provides a large increase in</span> productivity<span class="calibre10"> during development.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The classic Session Façade pattern scenario</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Session Façade pattern can be used in several architectures. The following diagram shows a classic model of <strong class="calibre8">Session Façade</strong> usage:</p>
<div class="cdpaligncenter"><img src="Images/2d1ecf38-09bd-48e3-88b7-7938a01ec71a.png" class="calibre51"/></div>
<p class="mce-root">Looking at the preceding diagram, we can see that a client (typically a web component or a <span class="calibre10">Business Delegate</span> implementation) accesses the facade layer. In this architecture, we find some options that depict the use of the <strong class="calibre8">Session Façade</strong>.</p>
<p class="mce-root">The Façade can handle different business objects (BO). Later in this chapter, we will see a better description of a BO and the business-object pattern. A business object is the representation of a conceptual model, which is a real-world object. A BO may have methods that describe its behavior. In this case, we will say that this BO reflects a non-anemic model (an anemic domain object contains a few business methods, such as validation and calculation). Here, the BO can use a <strong class="calibre8">Data-Access Object</strong> (<strong class="calibre8">DAO</strong>) pattern as a strategy for executing CRUD operations.</p>
<p class="mce-root"><span class="calibre10">The Façade can directly access a POJO JPA (Java Persistence API) entity. If the conceptual model of the business object is very close to the data model, we can fully represent this business object (an actor of a use case of the application) as a persistence entity. Most of the time, a Session Façade is implemented as an EJB session. Although a JPA entity does not require an EJB container to run because it runs in both JSE and JEE environments, the EJB and JPA technologies make a very successful combination. Since the JEE 5.0 platform, JPA has been the default specification for </span>object-relational <span class="calibre10">mapping (OR mapping) and persistence-management. JPA version 1.0 is part of the JSR 220 specification (EJB 3.0). The final result of the EJB 3.0 specification is that three separate documents were produced, the third being the Java Persistence API. This described the persistence model for the JSE and JEE environments. More internal services are offered naturally by the implementation of the EJB technology, such as transaction and security cont</span>rol:</p>
<ul class="calibre15">
<li class="calibre16">In most applications, the Session Façade uses a DAO implementation to perform the crud operations with the persistence layer. We will see later that the DAO pattern encapsulates the details related to <span class="calibre5">crud</span>, and can directly use a JDBC implementation or a JPA implementation to perform the crud work.</li>
</ul>
<p class="mce-root">The following is an activity diagram with the component tiers involved in the <strong class="calibre8">Session</strong> <strong class="calibre8">Façade</strong> pattern:</p>
<div class="cdpaligncenter"><img src="Images/9a5ee493-d9b5-40ce-9aef-80e85316d155.png" width="1241" height="873" class="calibre52"/><br class="calibre2"/></div>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The following shows the <strong class="calibre8">Session Façade</strong> pattern-sequence diagram:</p>
<div class="cdpaligncenter"><img src="Images/04597fcd-fb3b-41e8-b8d3-ba0ae4de29e4.png" class="calibre53"/></div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the Session Façade pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's make a small application related to the academic world. We will make two façades—one façade to manage the financial part of the application, and one to manage the academic part of the application. We will also construct some other classes, such as DAO classes and classes of the domain model. There is no database; all the data is kept in memory through the DAO classes. Consequently, the methods designed for finding information are built into the DAO classes. Let's create the following domain model classes: <kbd class="calibre18">Discipline</kbd>, <kbd class="calibre18">Course</kbd>, <kbd class="calibre18">Member</kbd> (<kbd class="calibre18">Member</kbd> is an abstract class that represents a member of a college), <kbd class="calibre18">Professor</kbd>, and <kbd class="calibre18">Student</kbd>:<kbd class="calibre18"><br class="calibre2"/></kbd></p>
<pre class="calibre23">import java.io.Serializable;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">Discipline</strong> implements Serializable{<br class="calibre2"/>  private String name;<br class="calibre2"/>  private String code;<br class="calibre2"/><br class="calibre2"/>  @Override<br class="calibre2"/>  public int hashCode() {<br class="calibre2"/>    final int prime = 31;<br class="calibre2"/>    int result = 1;<br class="calibre2"/>    result = prime * result + ((code == null) ? 0 : code.hashCode());<br class="calibre2"/>    return result;<br class="calibre2"/>  }<br class="calibre2"/>  @Override<br class="calibre2"/>  public boolean equals(Object obj) {<br class="calibre2"/>    if (this == obj)<br class="calibre2"/>      return true;<br class="calibre2"/>    if (obj == null)<br class="calibre2"/>      return false;<br class="calibre2"/>    if (getClass() != obj.getClass())<br class="calibre2"/>      return false;<br class="calibre2"/>    Discipline other = (Discipline) obj;<br class="calibre2"/>    if (code == null) {<br class="calibre2"/>      if (other.code != null)<br class="calibre2"/>        return false;<br class="calibre2"/>    } else if (!code.equals(other.code))<br class="calibre2"/>      return false;<br class="calibre2"/>    return true;<br class="calibre2"/>  }<br class="calibre2"/>  public Discipline() {<br class="calibre2"/>  }<br class="calibre2"/>  public Discipline(String code, String name) {<br class="calibre2"/>    this.setCode(code);<br class="calibre2"/>    this.setName(name);<br class="calibre2"/>  }<br class="calibre2"/>  public String getName() {<br class="calibre2"/>    return name;<br class="calibre2"/>  }<br class="calibre2"/>  public void setName(String name) {<br class="calibre2"/>    this.name = name;<br class="calibre2"/>  }<br class="calibre2"/>  public String getCode() {<br class="calibre2"/>    return code;<br class="calibre2"/>  }<br class="calibre2"/>  public void setCode(String code) {<br class="calibre2"/>    this.code = code;<br class="calibre2"/>  }<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/></pre>
<p class="mce-root3">This is the <kbd class="calibre18">Course</kbd> class:</p>
<pre class="mce-root2"> import java.io.Serializable;<br class="calibre2"/><br class="calibre2"/> public class <strong class="calibre3">Course</strong> implements Serializable {<br class="calibre2"/> private String code;<br class="calibre2"/> private String name;<br class="calibre2"/> public Course() {<br class="calibre2"/> }<br class="calibre2"/> public Course (String code, String name) {<br class="calibre2"/>     this.setCode(code);<br class="calibre2"/>     this.setName(name);<br class="calibre2"/> }<br class="calibre2"/> public String getCode() {<br class="calibre2"/>     return code;<br class="calibre2"/> }<br class="calibre2"/> public void setCode(String code) {<br class="calibre2"/>     this.code = code;<br class="calibre2"/> }<br class="calibre2"/> public String getName() {<br class="calibre2"/>     return name;<br class="calibre2"/> }<br class="calibre2"/> public void setName(String name) {<br class="calibre2"/>     this.name = name;<br class="calibre2"/> }<br class="calibre2"/>}<br class="calibre2"/><br class="calibre2"/></pre>
<p class="mce-root">Here is the <kbd class="calibre18">Member</kbd> class which like the previous classes, implements the <kbd class="calibre18">Serializable</kbd> package:</p>
<pre class="mce-root2">import java.io.Serializable;<br class="calibre2"/>import java.time.LocalDate;<br class="calibre2"/><br class="calibre2"/>public abstract class <strong class="calibre3">Member</strong> implements Serializable {<br class="calibre2"/>  <br class="calibre2"/>  @Override<br class="calibre2"/>  public int hashCode() {<br class="calibre2"/>    final int prime = 31;<br class="calibre2"/>    int result = 1;<br class="calibre2"/>    result = prime * result + ((name == null) ? 0 : name.hashCode());<br class="calibre2"/>    return result;<br class="calibre2"/>  }<br class="calibre2"/>  @Override<br class="calibre2"/>  public boolean equals(Object obj) {<br class="calibre2"/>    if (this == obj)<br class="calibre2"/>      return true;<br class="calibre2"/>    if (obj == null)<br class="calibre2"/>      return false;<br class="calibre2"/>    if (getClass() != obj.getClass())<br class="calibre2"/>      return false;<br class="calibre2"/>    Member other = (Member) obj;<br class="calibre2"/>    if (name == null) {<br class="calibre2"/>      if (other.name != null)<br class="calibre2"/>        return false;<br class="calibre2"/>    } else if (!name.equals(other.name))<br class="calibre2"/>      return false;<br class="calibre2"/>    return true;<br class="calibre2"/>  }<br class="calibre2"/>  private String name;<br class="calibre2"/>  private LocalDate initDate;<br class="calibre2"/>  private String email;<br class="calibre2"/>  <br class="calibre2"/>  public String getEmail() {<br class="calibre2"/>    return email;<br class="calibre2"/>  }<br class="calibre2"/>  public void setEmail(String email) {<br class="calibre2"/>    this.email = email;<br class="calibre2"/>  }<br class="calibre2"/>  public String getName() {<br class="calibre2"/>    return name;<br class="calibre2"/>  }<br class="calibre2"/>  public void setName(String name) {<br class="calibre2"/>    this.name = name;<br class="calibre2"/>  }<br class="calibre2"/>  public LocalDate getInitDate() {<br class="calibre2"/>    return initDate;<br class="calibre2"/>  }<br class="calibre2"/>  public void setInitDate(LocalDate initDate) {<br class="calibre2"/>    this.initDate = initDate;<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root">Now, the <kbd class="calibre18">Professor</kbd> class inherits the <kbd class="calibre18"><span class="calibre5">Member</span></kbd> class:</p>
<pre class="mce-root2">import java.util.Date;<br class="calibre2"/>import java.time.LocalDate;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">Professor</strong> extends Member {<br class="calibre2"/>  private LocalDate initTeachDate;<br class="calibre2"/>  public Professor() {<br class="calibre2"/>  }<br class="calibre2"/>  public Professor(String name, LocalDate initDate) {<br class="calibre2"/>    this.setName(name);<br class="calibre2"/>    this.setInitDate(initDate);<br class="calibre2"/>  }<br class="calibre2"/>  public Professor(String name) {<br class="calibre2"/>    this.setName(name);<br class="calibre2"/>  }<br class="calibre2"/>  public LocalDate getInitTeachDate() {<br class="calibre2"/>    return initTeachDate;<br class="calibre2"/>  }<br class="calibre2"/>  public void setInitTeachDate(LocalDate initTeachDate) {<br class="calibre2"/>    this.initTeachDate = initTeachDate;<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The following is the <kbd class="calibre18">Student</kbd> class, which inherits the <kbd class="calibre18">Member</kbd> class:</p>
<pre class="mce-root2">public class <strong class="calibre3">Student</strong> extends Member {<br class="calibre2"/>  private String enrollment;<br class="calibre2"/>  public Student() {<br class="calibre2"/>  }<br class="calibre2"/>  public Student(String enrollment) {<br class="calibre2"/>    this.setEnrollment(enrollment);<br class="calibre2"/>  }<br class="calibre2"/>  public Student(String enrollment, String name) {<br class="calibre2"/>    this.setEnrollment(enrollment);<br class="calibre2"/>    this.setName(name);<br class="calibre2"/>  }<br class="calibre2"/>  public String getEnrollment() {<br class="calibre2"/>    return enrollment;<br class="calibre2"/>  }<br class="calibre2"/>  public void setEnrollment(String enrollment) {<br class="calibre2"/>    this.enrollment = enrollment;<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root">We could make these application entities with an <kbd class="calibre18">id</kbd> integer type property that would represent a unique entity. I<span class="calibre10">t is common to extend an abstract entity class that contains this ID. </span>However, for the college members, we simplified it and used the <kbd class="calibre18">name</kbd> property for the identification job. In the <span class="calibre10"><kbd class="calibre18">Discipline</kbd> and <kbd class="calibre18">Member</kbd> classes, we implemented the equals method to check for equal objects within a collection. </span></p>
<p class="mce-root"><span class="calibre10">Let's make some DAO classes. There is no POJO JPA entity in these examples. The relationships between the model objects are inserted in the DAO classes:</span></p>
<pre class="mce-root2">import java.util.Arrays;<br class="calibre2"/>import java.util.HashMap;<br class="calibre2"/>import java.util.List;<br class="calibre2"/>import java.util.Map;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">CourseDAO</strong> {<br class="calibre2"/>  private static Map&lt;Course, List&lt;Discipline&gt;&gt; courseXDisciplines;<br class="calibre2"/>  static {<br class="calibre2"/>    Discipline d1 = new Discipline("D1", "discipline 1");<br class="calibre2"/>    Discipline d2 = new Discipline("D2", "discipline 2");<br class="calibre2"/>    Discipline d3 = new Discipline("D3", "discipline 3");<br class="calibre2"/>    Discipline d4 = new Discipline("D4", "discipline 4");<br class="calibre2"/>    <br class="calibre2"/>    courseXDisciplines = new HashMap&lt;&gt;();<br class="calibre2"/>    courseXDisciplines.put (new Course ("C1", "Course 1"), Arrays.asList (d1,  d2, d4));<br class="calibre2"/>    courseXDisciplines.put (new Course ("C2", "Course 2"), Arrays.asList (d1, d3));<br class="calibre2"/>    courseXDisciplines.put (new Course ("C3", "Course 3"), Arrays.asList (d2, d3, d4));<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public List&lt;Discipline&gt; getDisciplinesByCourse(Course course) {<br class="calibre2"/>    return courseXDisciplines.get(course);<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root">This is the <kbd class="calibre18">DisciplineDAO</kbd> class:</p>
<pre class="mce-root2">import java.util.Arrays;<br class="calibre2"/>import java.util.HashMap;<br class="calibre2"/>import java.util.List;<br class="calibre2"/>import java.util.Map;<br class="calibre2"/>import java.util.stream.Collectors;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">DisciplineDAO </strong>{<br class="calibre2"/>  private static Map&lt;Discipline, List&lt;Discipline&gt;&gt; disciplineXPreReqDisciplines = new HashMap&lt;&gt;();<br class="calibre2"/>  private static Map&lt;Professor, List&lt;Discipline&gt;&gt; professorXDisciplines = new HashMap&lt;&gt;();<br class="calibre2"/>  private static Map&lt;Discipline, List&lt;String&gt;&gt; disciplineXBooks = new HashMap&lt;&gt;();<br class="calibre2"/>  private static List&lt;Discipline&gt; disciplines;<br class="calibre2"/>  <br class="calibre2"/>  static {<br class="calibre2"/>    Discipline d1 = new Discipline("D1", "discipline 1");<br class="calibre2"/>    Discipline d2 = new Discipline("D2", "discipline 2");<br class="calibre2"/>    Discipline d3 = new Discipline("D3", "discipline 3");<br class="calibre2"/>    Discipline d4 = new Discipline("D4", "discipline 4");<br class="calibre2"/>    disciplines = Arrays.asList(d1, d2, d3, d4);<br class="calibre2"/>    <br class="calibre2"/>    disciplineXPreReqDisciplines.put (d3, Arrays.asList (d1, d2));<br class="calibre2"/>    disciplineXPreReqDisciplines.put (d4, Arrays.asList (d2));<br class="calibre2"/>    <br class="calibre2"/>    professorXDisciplines.put (new Professor ("professor a"), Arrays.asList (d1, d2));<br class="calibre2"/>        professorXDisciplines.put (new Professor ("professor b"), Arrays.asList (d3));<br class="calibre2"/>        professorXDisciplines.put (new Professor ("professor cv"), Arrays.asList (d1, d3, d4));<br class="calibre2"/>        <br class="calibre2"/>        disciplineXBooks.put (d1, Arrays.asList ("book x", "book y"));<br class="calibre2"/>        disciplineXBooks.put (d2, Arrays.asList ("book x", "book a", "book w"));<br class="calibre2"/>        disciplineXBooks.put (d3, Arrays.asList ("book x", "book b"));<br class="calibre2"/>        disciplineXBooks.put (d4, Arrays.asList ("book z"));<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public List&lt;Discipline&gt; getPreRequisiteDisciplines (Discipline discipline) {<br class="calibre2"/>    return disciplineXPreReqDisciplines.get (discipline);<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public List&lt;Discipline&gt; getDisciplinesByProfessor(Professor professor) {<br class="calibre2"/>    return professorXDisciplines.get (professor);<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>  public List&lt;String&gt; getBooksByDiscipline(Discipline discipline) {<br class="calibre2"/>    return disciplineXBooks.get (discipline);<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public List&lt;Professor&gt; getProfessorByDiscipline (Discipline discipline) {<br class="calibre2"/>    return professorXDisciplines.keySet()<br class="calibre2"/>         .stream()<br class="calibre2"/>         .filter (p-&gt;professorXDisciplines.get(p).contains(discipline))<br class="calibre2"/>         //.collect(ArrayList::new, ArrayList::add, ArrayList::addAll);<br class="calibre2"/>         .collect(Collectors.toList());<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public Discipline getDisciplineByCode (String code) {<br class="calibre2"/>    return disciplines<br class="calibre2"/>    .stream()<br class="calibre2"/>    .filter(s-&gt;s.getCode().equals(code))<br class="calibre2"/>    .findAny()<br class="calibre2"/>    .get();<br class="calibre2"/>  } <br class="calibre2"/>}</pre>
<p class="mce-root">Now, you will make the <kbd class="calibre18">StudentDAO</kbd> class:</p>
<pre class="mce-root2">import java.util.Arrays;<br class="calibre2"/>import java.util.HashMap;<br class="calibre2"/>import java.util.List;<br class="calibre2"/>import java.util.Map;<br class="calibre2"/>import java.util.stream.Collectors;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">StudentDAO</strong> {<br class="calibre2"/>  <br class="calibre2"/>  public static enum FINANCIAL_STATUS {<br class="calibre2"/>    OK (true, "OK"), PENDING (false, "Payment pending"), DOC_PENDING (true, "Document pending");<br class="calibre2"/>    <br class="calibre2"/>    private boolean status;<br class="calibre2"/>    private String description;<br class="calibre2"/>    public boolean isStatus() {<br class="calibre2"/>      return status;<br class="calibre2"/>    }<br class="calibre2"/>    public String getDescription() {<br class="calibre2"/>      return description;<br class="calibre2"/>    }<br class="calibre2"/>    FINANCIAL_STATUS (boolean status, String description){<br class="calibre2"/>      this.status = status;<br class="calibre2"/>      this.description = description;<br class="calibre2"/>    }<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public static enum ACADEMIC_STATUS {<br class="calibre2"/>    APPROVED , FAILED;<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  private static List&lt;Student&gt; students;<br class="calibre2"/>  private static Map&lt;String, FINANCIAL_STATUS&gt; studentStatusPayment = new HashMap&lt;&gt;();<br class="calibre2"/>  private static Map&lt;Student, List&lt;String&gt;&gt; studentXCourseName = new HashMap&lt;&gt;();<br class="calibre2"/>  <br class="calibre2"/>  static {<br class="calibre2"/>    Student s1 = new Student ("20010001", "student 1");<br class="calibre2"/>    Student s2 = new Student ("20010002", "student 2");<br class="calibre2"/>    Student s3 = new Student ("20010003", "student 3");<br class="calibre2"/>    Student s4 = new Student ("20010004", "student 4");<br class="calibre2"/>    students = Arrays.asList(s1, s2, s3, s4); <br class="calibre2"/>  <br class="calibre2"/>    studentStatusPayment.put ("20010001", FINANCIAL_STATUS.OK);<br class="calibre2"/>    studentStatusPayment.put ("20010002", FINANCIAL_STATUS.OK);<br class="calibre2"/>    studentStatusPayment.put ("20010003", FINANCIAL_STATUS.PENDING);<br class="calibre2"/>    studentStatusPayment.put ("20010004", FINANCIAL_STATUS.OK);<br class="calibre2"/>  <br class="calibre2"/>    studentXCourseName.put (s1, Arrays.asList ("C01", "C02"));<br class="calibre2"/>    studentXCourseName.put (s2, Arrays.asList ("C03"));<br class="calibre2"/>    studentXCourseName.put (s3, Arrays.asList ("C04"));<br class="calibre2"/>    studentXCourseName.put (s4, Arrays.asList ("C03", "C04"));<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public static Map&lt;String, FINANCIAL_STATUS&gt; getStudentStatusPayment() {<br class="calibre2"/>    return studentStatusPayment;<br class="calibre2"/>  }<br class="calibre2"/>  public List&lt;Student&gt; getEnrolledStudentByCourse(Course course) {<br class="calibre2"/>    return studentXCourseName.keySet()<br class="calibre2"/>        .stream()<br class="calibre2"/>        .filter(s-&gt;studentXCourseName.get(s).contains(course.getCode()))<br class="calibre2"/>        .collect(Collectors.toList());<br class="calibre2"/>  }<br class="calibre2"/>  public Student getStudentByEnrollment (String enrollment) {<br class="calibre2"/>    return students<br class="calibre2"/>    .stream()<br class="calibre2"/>    .filter(s-&gt;s.getEnrollment().equals(enrollment))<br class="calibre2"/>    .findAny()<br class="calibre2"/>    .get();<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root">Let's look at the <kbd class="calibre18">ProfessorDAO</kbd> class:</p>
<pre class="mce-root2">import java.time.LocalDate;<br class="calibre2"/>import java.util.Arrays;<br class="calibre2"/>import java.util.Set;<br class="calibre2"/>import java.util.stream.Collectors;<br class="calibre2"/>public class <strong class="calibre3">ProfessorDAO</strong> {<br class="calibre2"/>  private static Set&lt;Professor&gt; professors;<br class="calibre2"/>  static {<br class="calibre2"/>    Professor p1 = new Professor ("professor a", LocalDate.of (2001, 03, 22)),<br class="calibre2"/>          p2 = new Professor ("professor b", LocalDate.of (1994, 07, 05)),<br class="calibre2"/>              p3 = new Professor ("professor c", LocalDate.of (1985, 10, 12)),<br class="calibre2"/>              p4 = new Professor ("professor cv", LocalDate.of (2005, 07, 17));<br class="calibre2"/>    <br class="calibre2"/>    professors = Arrays<br class="calibre2"/>          .stream (new Professor[]{p1, p2, p3, p4})<br class="calibre2"/>            .collect (Collectors.toSet());<br class="calibre2"/>    <br class="calibre2"/>  }<br class="calibre2"/>  public Professor findByName (String name) {<br class="calibre2"/>    return professors<br class="calibre2"/>        .stream()<br class="calibre2"/>        .filter(p-&gt;p.getName().equals(name))<br class="calibre2"/>        .findAny()<br class="calibre2"/>        .get();<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root">We put a lot of responsibility in <kbd class="calibre18">DisciplineDAO</kbd> for simplicity. We could have increased the scope of the <kbd class="calibre18">CourseDAO</kbd> or <kbd class="calibre18">ProfessorDAO</kbd> class <span class="calibre10">for access to data related to the <kbd class="calibre18">Professor</kbd> entity.</span> </p>
<p class="mce-root">Now, the following classes are the two Session Façade implementations: <kbd class="calibre18">AcademicFacadeImpl</kbd> and <kbd class="calibre18">FinancialFacadeImpl</kbd>. It is important to note that this is only one of several ways to build this kind of application. The next part of this chapter will cover the business-object pattern, and here we will create a business object that centralizes the application's business rules instead of the Session Façade:</p>
<pre class="mce-root2">import java.time.DayOfWeek;<br class="calibre2"/>import java.time.LocalDate;<br class="calibre2"/>import java.time.LocalDateTime;<br class="calibre2"/>import java.time.format.DateTimeFormatter;<br class="calibre2"/>import java.util.List;<br class="calibre2"/>import java.util.Set;<br class="calibre2"/>import javax.ejb.Asynchronous;<br class="calibre2"/>import javax.ejb.LocalBean;<br class="calibre2"/>import javax.ejb.Stateless;<br class="calibre2"/>import javax.enterprise.event.Observes;<br class="calibre2"/>import javax.inject.Inject;<br class="calibre2"/>/**<br class="calibre2"/> * Session Bean implementation class AcademicFacadeImpl<br class="calibre2"/> */<br class="calibre2"/>@Stateless<br class="calibre2"/>@LocalBean <br class="calibre2"/>public class <strong class="calibre3">AcademicFacadeImpl</strong> {<br class="calibre2"/>  <br class="calibre2"/>  @Inject<br class="calibre2"/>  private CourseDAO courseDAO;<br class="calibre2"/>  @Inject<br class="calibre2"/>  private DisciplineDAO disciplineDAO;<br class="calibre2"/>  @Inject<br class="calibre2"/>  private StudentDAO studentDAO;<br class="calibre2"/>  @Inject<br class="calibre2"/>  private ProfessorDAO professorDAO; <br class="calibre2"/>  <br class="calibre2"/>  public List&lt;Discipline&gt; getDisciplinesByCourse(Course course) {<br class="calibre2"/>    return courseDAO.getDisciplinesByCourse (course);<br class="calibre2"/>  }<br class="calibre2"/>  public List&lt;Discipline&gt; getPreRequisiteDisciplines (Discipline discipline) {<br class="calibre2"/>    return disciplineDAO.getPreRequisiteDisciplines(discipline);<br class="calibre2"/>  }<br class="calibre2"/>  public List&lt;Discipline&gt; getDisciplinesByProfessor(Professor professor) {<br class="calibre2"/>    return disciplineDAO.getDisciplinesByProfessor(professor);<br class="calibre2"/>  }<br class="calibre2"/>  public List&lt;String&gt; getBooksByDiscipline(Discipline discipline) {<br class="calibre2"/>    return disciplineDAO.getBooksByDiscipline(discipline);<br class="calibre2"/>  }<br class="calibre2"/>  public List&lt;Student&gt; getEnrolledStudentByCourse(Course course) {<br class="calibre2"/>    return studentDAO.getEnrolledStudentByCourse (course);<br class="calibre2"/>  }<br class="calibre2"/>  public void requestTestReview (Student student, Discipline discipline, LocalDate testDate) {<br class="calibre2"/>    // TODO<br class="calibre2"/>  }<br class="calibre2"/> <br class="calibre2"/>  private LocalDateTime scheduleTestReview (TestRevisionTO testRevisionTO)<br class="calibre2"/>  {<br class="calibre2"/>    LocalDateTime dateTime = null;<br class="calibre2"/>    try {<br class="calibre2"/>      Thread.sleep(10000); <br class="calibre2"/>      // get some code to calculate the schedule date for the test review<br class="calibre2"/>      Thread.sleep (5000); // simulate some delay during calculation<br class="calibre2"/>      dateTime = LocalDateTime.now().plusDays(10);<br class="calibre2"/>      if (dateTime.getDayOfWeek().equals(DayOfWeek.SUNDAY)) {<br class="calibre2"/>        dateTime = dateTime.plusDays(1);<br class="calibre2"/>      }<br class="calibre2"/>    } catch (InterruptedException e) {<br class="calibre2"/>      e.printStackTrace();<br class="calibre2"/>    }<br class="calibre2"/>    return dateTime;<br class="calibre2"/>  }<br class="calibre2"/>  private void sendEmail (TestRevisionTO testRevisionTO, LocalDateTime dateTime) {<br class="calibre2"/>    Student student = studentDAO.getStudentByEnrollment (testRevisionTO.getEnrollment());<br class="calibre2"/>    String enrollment = student.getEnrollment(); <br class="calibre2"/>    String studentName = student.getName();<br class="calibre2"/>    String email = student.getEmail();<br class="calibre2"/>    Discipline discipline = disciplineDAO.getDisciplineByCode (testRevisionTO.getDisciplineCode());<br class="calibre2"/>    String disciplineName = discipline.getName(); <br class="calibre2"/>    String disciplineCode = discipline.getCode(); // testRevisionTO.getDisciplineCode()<br class="calibre2"/>    String date = dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE);<br class="calibre2"/>    String time = dateTime.format(DateTimeFormatter.ofPattern("HH:mm"));<br class="calibre2"/>    // sending an email using the above information ...<br class="calibre2"/>    System.out.println("sending an email to : " + studentName + " ...");<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public void requestTestReview (@ObservesAsync TestRevisionTO testRevisionTO) {<br class="calibre2"/>    System.out.println("matricula " + testRevisionTO.getEnrollment());<br class="calibre2"/>    LocalDateTime dateTime = scheduleTestReview (testRevisionTO);<br class="calibre2"/>    sendEmail (testRevisionTO, dateTime); // send an email with the schedule date for the test review:<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>  public List&lt;Professor&gt; getProfessorsByDiscipline(Discipline discipline) {<br class="calibre2"/>    return disciplineDAO.getProfessorByDiscipline(discipline);<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>  public boolean canProfessorTeachDiscipline (Professor professor, Discipline discipline) {<br class="calibre2"/>    return disciplineDAO.getDisciplinesByProfessor(professor)  .contains(discipline);<br class="calibre2"/> }<br class="calibre2"/>}</pre>
<p class="mce-root">Now, let's look at the <kbd class="calibre18">FinancialFacadeImpl</kbd> class:</p>
<pre class="mce-root2">import javax.ejb.LocalBean;<br class="calibre2"/>import javax.ejb.Stateless;<br class="calibre2"/>import javax.inject.Inject;<br class="calibre2"/><br class="calibre2"/>/**<br class="calibre2"/> * Session Bean implementation class FinancialFacadeImpl<br class="calibre2"/> */<br class="calibre2"/>@Stateless<br class="calibre2"/>@LocalBean<br class="calibre2"/>public class <strong class="calibre3">FinancialFacadeImpl</strong> {<br class="calibre2"/>  <br class="calibre2"/>  @Inject<br class="calibre2"/>  private StudentDAO studentDAO; <br class="calibre2"/><br class="calibre2"/>  public FinancialFacadeImpl() {<br class="calibre2"/>  }<br class="calibre2"/>    <br class="calibre2"/>  public boolean canStudentEnroll (Student student) {<br class="calibre2"/>      return studentDAO.getStudentStatusPayment().get (student.getEnrollment()).isStatus();<br class="calibre2"/>  }<br class="calibre2"/>    <br class="calibre2"/>  public boolean isStudentPending (Student student) {<br class="calibre2"/>      FINANCIAL_STATUS status = studentDAO.getStudentStatusPayment().get (student.getEnrollment());<br class="calibre2"/>      return (status.equals (FINANCIAL_STATUS.PENDING)) || (status.equals (FINANCIAL_STATUS.DOC_PENDING)); <br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root">We can observe the <kbd class="calibre18">@LocalBean</kbd> <span class="calibre10">annotation</span><span class="calibre10"> </span><span class="calibre10">in the EJB Session Façade. This means that the bean</span> <span class="calibre10">has a no-interface view</span><span class="calibre10">. This is just a simplification because there is no need to apply local or remote interfaces for the explanation of the Session Façade. Just remember,</span><span class="calibre10"> the requirement for local interfaces has been dropped </span><span class="calibre10">since </span><span class="calibre10">EJB 3.1</span><span class="calibre10">.</span></p>
<p class="mce-root">The <kbd class="calibre18">AcademicFacadeImpl</kbd> <span class="calibre10">Session Façade </span><span class="calibre10">has an asynchronous method with an event listener parameter. This method is responsible for providing the date and time for a test revision when requested by a student. For example:</span></p>
<pre class="mce-root2">  public void <strong class="calibre3">requestTestReview</strong> (<strong class="calibre3">@ObservesAsync</strong> <strong class="calibre3">TestRevisionTO</strong> testRevisionTO) {<br class="calibre2"/>    System.out.println("Enrollment : " + testRevisionTO.getEnrollment());<br class="calibre2"/>    LocalDateTime dateTime = scheduleTestReview (testRevisionTO);<br class="calibre2"/>    sendEmail (testRevisionTO, dateTime); // send an email with the schedule date for the test review:<br class="calibre2"/>  }</pre>
<p class="mce-root">This event can be fired from a façade client, typically a delegate or a web component (a servlet or a JSF-managed bean, for example). The event is injected into the client and fired according to the request. It is then fired together with a <kbd class="calibre18">TestRevisionTO</kbd> object:</p>
<pre class="mce-root2">// Event Injection :<br class="calibre2"/>@Inject <br class="calibre2"/>  Event&lt;TestRevisionTO&gt; event;<br class="calibre2"/>...<br class="calibre2"/>...<br class="calibre2"/><br class="calibre2"/>    // get the schedule date for a test revision:<br class="calibre2"/>    TestRevisionTO testRevisionTO = new TestRevisionTO();<br class="calibre2"/>    testRevisionTO.setEnrollment ("20010003");<br class="calibre2"/>    testRevisionTO.setDisciplineCode("D3");<br class="calibre2"/>    LocalDate date = LocalDate.of(2017, 11, 21);<br class="calibre2"/>    LocalTime time = LocalTime.of (8, 30);<br class="calibre2"/>    LocalDateTime dateTime = LocalDateTime.of(date, time); <br class="calibre2"/>    testRevisionTO.setTestDateTime (dateTime);<br class="calibre2"/>    <strong class="calibre3">event.fire (testRevisionTO);</strong></pre>
<p class="mce-root"><span class="calibre10"><span class="calibre10">The </span></span><kbd class="calibre18">TestRevisionTO</kbd> class is fired as follows:</p>
<pre class="mce-root2">import java.io.Serializable;<br class="calibre2"/>import java.time.LocalDateTime;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">TestRevisionTO</strong> implements Serializable {<br class="calibre2"/>  <br class="calibre2"/>  private String enrollment;<br class="calibre2"/>  private String disciplineCode;<br class="calibre2"/>  private LocalDateTime testDateTime;<br class="calibre2"/>  public String getEnrollment() {<br class="calibre2"/>    return enrollment;<br class="calibre2"/>  }<br class="calibre2"/>  public void setEnrollment(String enrollment) {<br class="calibre2"/>    this.enrollment = enrollment;<br class="calibre2"/>  }<br class="calibre2"/>  public String getDisciplineCode() {<br class="calibre2"/>    return disciplineCode;<br class="calibre2"/>  }<br class="calibre2"/>  public void setDisciplineCode(String disciplineCode) {<br class="calibre2"/>    this.disciplineCode = disciplineCode;<br class="calibre2"/>  }<br class="calibre2"/>  public LocalDateTime getTestDateTime() {<br class="calibre2"/>    return testDateTime;<br class="calibre2"/>  }<br class="calibre2"/>  public void setTestDateTime(LocalDateTime testDateTime) {<br class="calibre2"/>    this.testDateTime = testDateTime;<br class="calibre2"/>  }<br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Explaining the business-object pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">As the name suggests, a business object represents something in the real world and something associated with the business of the application. A business object is like an actor in an application use case. Examples of business objects include bank accounts, car insurance, college professors, students, employees, purchase orders, and payable or receivable accounts<span class="calibre10">.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">When it comes to simple applications with very little business complexity, that is, with few (or no) business rules, there may not be a need for a BO in the system. Better yet, a POJO entity that represents a database entity can be considered a BO. It is important to see the difference <span class="calibre10">here</span><span class="calibre10">. An entity or a</span> <span class="calibre10">POJO </span><span class="calibre10">representative of an entity (such as a JPA</span> <span class="calibre10">POJO </span>)<span class="calibre10"> is closer to the technology and structure than to a business-model object. So, for this example, a</span><span class="calibre10">n entity such as a college student can also be considered a BO or an actor of a <em class="calibre12">college student</em> use case.</span> <span class="calibre10">In fact, in these simpler cases where the data model is sufficient for the business, there is no need to define a business object. </span></p>
<p class="mce-root">In this case, we say that the data model related to the college student closely represents the conceptual domain model related to the student.</p>
<p class="mce-root">The application is often so simple that <span class="calibre10">business-tier</span> clients, such as a <span class="calibre10">Session Façade</span> (or even presentation-tier clients), can directly access the data model through DAO. There is no need for a model object to handle greater complexity for the application business.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Applications with complex business rules</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's say that we want to increase the complexity of the system (let's say the system needs to contain more functions, for example). Let's also imagine that a college has members that consist of professors, employees, and students. Suppose there is a <kbd class="calibre18">member</kbd> entity that almost matches the <kbd class="calibre18">member</kbd> table in <span class="calibre10">the related database</span><span class="calibre10">. In addition, we know that professors, students, and employees are members of the college, and for that reason, they have common characteristics that every member should have. However, the </span>professor, <span class="calibre10">student, and employee also have their own characteristics. A</span> <span class="calibre10">professor's main characteristics </span><span class="calibre10">are that they are a member who teaches and has a Masters or PhD qualification</span><span class="calibre10">.</span></p>
<p class="mce-root">Similarly, a student has their own characteristics, such as enrollment in college and the number of courses they are enrolled in. Professors and students will both <span class="calibre10">also</span><span class="calibre10"> </span><span class="calibre10">have relationships with other entities. For this, we can architect the application in terms of the database and create four tables—<kbd class="calibre18">Member</kbd>, <kbd class="calibre18">Student</kbd>, <kbd class="calibre18">Employee</kbd>, and <kbd class="calibre18">Professor</kbd>. We can establish a one-to-one relationship between <kbd class="calibre18">Student</kbd> and <kbd class="calibre18">Member</kbd>, <kbd class="calibre18">Professor</kbd> and <kbd class="calibre18">Member</kbd>, and also <kbd class="calibre18">Employee</kbd> and <kbd class="calibre18">Member</kbd>. In any implementation, we can have four JPA entities related to these tables.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"><span class="calibre10">However, a professor is an actor of the </span><span class="calibre10"><em class="calibre12">teaches discipline</em></span><span class="calibre10"> use case with some business rules. This more complex <kbd class="calibre18">professor</kbd> object combines the <kbd class="calibre18">Member</kbd> and <kbd class="calibre18">Professor</kbd> entities. We can then define a <kbd class="calibre18">ProfessorBO</kbd> (business object) object, which is the combination of the <kbd class="calibre18">Member</kbd> with <kbd class="calibre18">Professor</kbd></span>. <span class="calibre10">In addition, <kbd class="calibre18">ProfessorBO</kbd> may have methods that provide a richer behavioral value for the object because these methods are used in the use case. Without such methods, the object becomes an anemic object. However, it could be said that this is still a relatively low complexity. Consequently, we can think of a use case that shows all the disciplines taught by a professor, or a professor's skills that are necessary to teach particular disciplines. Here, we have another table and entity: <kbd class="calibre18">Discipline</kbd>.</span></p>
<p class="mce-root"><span class="calibre10">In addition, a student is related to a particular course. This is another use case with one more entity: <kbd class="calibre18">Course</kbd>. The possibilities conceived for an academic system are innumerable and are far from being a simple data-model system. Business objects can be used for complex use cases. </span></p>
<p class="mce-root">The following diagram shows the <strong class="calibre8">Professor</strong>, <strong class="calibre8">Student</strong>, and <strong class="calibre8">Employee</strong> as more complex objects:</p>
<div class="cdpaligncenter"><img src="Images/ab30f7bb-1fe2-4e90-809e-3b72e9b34786.png" class="calibre54"/></div>
<p class="mce-root">This scenario is just one of several possible implementations. In our small example, we consider the existence of an object called <kbd class="calibre18">ProfessorBO</kbd>, which uses three entities (<strong class="calibre8">Professor</strong>, <strong class="calibre8">Member</strong>, and <strong class="calibre8">Discipline</strong>) and has associated business methods.</p>
<p class="mce-root">One could argue that there would be no need to have <kbd class="calibre18">ProfessorBO</kbd>. We could have a Professor Facade that could implement the <span class="calibre10">Session Façade</span> pattern with business methods and would also manipulate the different combined entities using a DAO (for the execution of CRUD operations).</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">We can agree with this architecture and, depending on the complexity of the system, it may even be the best alternative. However, we chose this architecture, which clearly illustrates the definition and use of the BO pattern, so let's continue with our example.</p>
<p class="mce-root">Therefore, a <kbd class="calibre18">ProfessorBO</kbd> object represents a professor who is an actor for one or more use cases related to the conceptual professor model.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Motivation for using the business-object pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Whenever the conceptual model involves a greater complexity, we use the business-object pattern. This high complexity may be because the BO uses a <span class="calibre10">combination of other objects and has complex business logic, </span>such as validation rules. So, separating this business logic from the rest of the application is required (data persistence would be an example of this).</p>
<p class="mce-root">Not implementing this pattern can lead to problems, such as reducing code reusability. As a consequence of this, there are several possible solutions that make code maintenance time-consuming, as it would lose the uniformity that comes with using design patterns.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Benefits of business-object pattern usage</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Here is a summary of the benefits of the business-object pattern:</p>
<ul class="calibre15">
<li class="calibre16">BOs are responsible for managing their business rules and persistence. This leads to a more reusable code. Clients access BOs that are fully responsible for the behavior of the application. In our example, <kbd class="calibre18">ProfessorBO</kbd> can be called from several points. As well as being reusable, there is a uniformity of behavior. As a consequence, another benefit is faster and more efficient maintenance.</li>
<li class="calibre16">BOs are responsible for separating the business logic from the rest of the application, which increases the cohesion of the code (separation of responsibilities).</li>
<li class="calibre16">BOs help separate business logic from data persistence.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root">The following is the class diagram for the business-object pattern:</p>
<div class="cdpaligncenter"><img src="Images/04bf7e64-db2a-4c58-963f-5f34010a467e.png" width="630" height="418" class="calibre55"/></div>
<p class="mce-root">For more complex applications, we typically have a Session Façade that represents a set of related use cases. As we have already seen, the Session Façade offers high-level methods for clients. For its part, the Session Façade can manage and combine BOs that act as real agents or representatives of real-world objects.</p>
<p class="mce-root">The following is the <strong class="calibre8">Business Object</strong> sequence diagram:</p>
<div class="cdpaligncenter"><img src="Images/26873cb7-12a5-45dc-8bca-7244e8cbe5db.png" width="1127" height="477" class="calibre56"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Implementing the business-object pattern</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We are now going to input some code in order to illustrate the business-object pattern. However, we must again pay attention to the fact that there is <span class="calibre10">likely</span><span class="calibre10"> </span><span class="calibre10">another approach to getting the results. For instance, we could use an O-R Mapping (JPA or Hibernate technology) to map the entities.</span></p>
<p class="mce-root">As an example, the <kbd class="calibre18">Professor</kbd> entity has an <em class="calibre12">n</em>-to-<em class="calibre12"><span class="underline">n</span></em> relationship with the <kbd class="calibre18">Discipline</kbd> entity, which is done with a JPA annotation. However, we know that there are many more use cases here than simply mapping <span class="calibre10">entities</span><span class="calibre10">. </span></p>
<p class="mce-root">We will use <kbd class="calibre18">ProfessorBO</kbd>, <kbd class="calibre18">Professor</kbd>, <kbd class="calibre18">Discipline</kbd>, <kbd class="calibre18">ProfessorDAO</kbd>, and <kbd class="calibre18">DisciplineDAO</kbd>. Let's take advantage of the classes shown in the Session Façade example. We made a small change in the <kbd class="calibre18">AcademicFacadeImpl</kbd> class. Now, this Session Façade uses a BO called <kbd class="calibre18">ProfessorBO</kbd> to handle the business related to <kbd class="calibre18">Professor</kbd>.</p>
<p class="mce-root">Let's review the <kbd class="calibre18">ProfessorBO</kbd> class:</p>
<pre class="mce-root2">import java.time.LocalDate;<br class="calibre2"/>import java.util.List;<br class="calibre2"/>import javax.inject.Inject;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">ProfessorBO</strong> {<br class="calibre2"/>  private Professor professor; <br class="calibre2"/>  private List&lt;Discipline&gt; disciplines;<br class="calibre2"/>  <br class="calibre2"/>  @Inject <br class="calibre2"/>  private ProfessorDAO professorDAO;<br class="calibre2"/>  <br class="calibre2"/>  @Inject<br class="calibre2"/>  private DisciplineDAO disciplineDAO;<br class="calibre2"/>  <br class="calibre2"/>  public void setProfessor (Professor professor ) {<br class="calibre2"/>    this.professor = professorDAO.findByName (professor.getName());<br class="calibre2"/>  }<br class="calibre2"/>  public boolean <strong class="calibre3">canTeachDiscipline</strong> (Discipline discipline) {<br class="calibre2"/>    if (disciplines == null) {<br class="calibre2"/>      disciplines = disciplineDAO.getDisciplinesByProfessor (professor);<br class="calibre2"/>    }<br class="calibre2"/>    return disciplines.stream().anyMatch(d-&gt;d.equals(discipline));<br class="calibre2"/>    //return disciplines.contains(discipline);<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public LocalDate getInitDate () {<br class="calibre2"/>    return professor.getInitDate();<br class="calibre2"/>  }<br class="calibre2"/>  public String getName () {<br class="calibre2"/>    return professor.getName();<br class="calibre2"/>  }<br class="calibre2"/>}</pre>
<p class="mce-root">Let's also have a look at the <kbd class="calibre18">AcademicFacadeImpl</kbd> <span class="calibre10">class:</span></p>
<pre class="mce-root2">@Stateless<br class="calibre2"/>@LocalBean <br class="calibre2"/>public class AcademicFacadeImpl implements AcademicFacadeRemote, AcademicFacadeLocal {<br class="calibre2"/>  <br class="calibre2"/> ...<br class="calibre2"/> ... <br class="calibre2"/>  <br class="calibre2"/>  @Inject <br class="calibre2"/>  private ProfessorBO professorBO;<br class="calibre2"/><br class="calibre2"/>  <br class="calibre2"/>  @Override<br class="calibre2"/>  public List&lt;Professor&gt; getProfessorsByDiscipline(Discipline discipline) {<br class="calibre2"/>    return disciplineDAO.getProfessorByDiscipline(discipline);<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>    public boolean <strong class="calibre3">canProfessorTeachDiscipline</strong> (Professor professor, Discipline discipline) {<br class="calibre2"/>    /*return disciplineDAO.getDisciplinesByProfessor (professor).contains(discipline);*/<br class="calibre2"/>    professorBO.setProfessor (professor);<br class="calibre2"/>    return <strong class="calibre3">professorBO.canTeachDiscipline</strong>(discipline);<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">As we can see in the preceding code block, the <kbd class="calibre18">AcademicFacadeImpl</kbd> <span class="calibre10">Session Façade </span><span class="calibre10">calls the</span> <kbd class="calibre18">canTeachDiscipline</kbd> <span class="calibre10">method from the</span><span class="calibre10"> </span><kbd class="calibre18">ProfessorBO</kbd><span class="calibre10"> injected bean. </span><kbd class="calibre18">ProfessorBO</kbd> <span class="calibre10">then uses </span><kbd class="calibre18">ProfessorDAO</kbd> <span class="calibre10">and</span> <kbd class="calibre18">DisciplineDAO</kbd><span class="calibre10">. Next, we will see the part of the</span> <kbd class="calibre18">DisciplineDAO</kbd> <span class="calibre10">code that is used by the</span> <span class="calibre10"><kbd class="calibre18">ProfessorBO</kbd> bean:</span></p>
<pre class="mce-root2">import java.util.Arrays;<br class="calibre2"/>import java.util.HashMap;<br class="calibre2"/>import java.util.List;<br class="calibre2"/>import java.util.Map;<br class="calibre2"/><br class="calibre2"/>public class <strong class="calibre3">DisciplineDAO</strong> {<br class="calibre2"/>static {<br class="calibre2"/>    Discipline d1 = new Discipline("D1", "discipline 1");<br class="calibre2"/>    Discipline d2 = new Discipline("D2", "discipline 2");<br class="calibre2"/>    Discipline d3 = new Discipline("D3", "discipline 3");<br class="calibre2"/>    Discipline d4 = new Discipline("D4", "discipline 4");<br class="calibre2"/>    disciplines = Arrays.asList(d1, d2, d3, d4);<br class="calibre2"/>    ...    <br class="calibre2"/>    professorXDisciplines.put (new Professor ("professor a"), Arrays.asList (d1, d2));<br class="calibre2"/>        professorXDisciplines.put (new Professor ("professor b"), Arrays.asList (d3));<br class="calibre2"/>        professorXDisciplines.put (new Professor ("professor cv"), Arrays.asList (d1, d3, d4));<br class="calibre2"/>}  <br class="calibre2"/><br class="calibre2"/>...<br class="calibre2"/><br class="calibre2"/>public List&lt;Discipline&gt; <strong class="calibre3">getDisciplinesByProfessor</strong>(Professor professor) {<br class="calibre2"/>    return professorXDisciplines.get (professor);<br class="calibre2"/>  }<br class="calibre2"/>...<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">Let's see the code used by the <kbd class="calibre18">ProfessorDAO</kbd> class:</p>
<pre class="calibre23">public class <strong class="calibre3">ProfessorDAO</strong> {<br class="calibre2"/>  private static Set&lt;Professor&gt; professors;<br class="calibre2"/>  static {<br class="calibre2"/>   Professor p1 = new Professor ("professor a", LocalDate.of (2001, 03, <br class="calibre2"/>   22)),<br class="calibre2"/>      p2 = new Professor ("professor b", LocalDate.of (1994, 07, 05)),<br class="calibre2"/>      p3 = new Professor ("professor c", LocalDate.of (1985, 10, 12)),<br class="calibre2"/>      p4 = new Professor ("professor cv", LocalDate.of (2005, 07, 17));<br class="calibre2"/>    <br class="calibre2"/>    professors = Arrays<br class="calibre2"/>          .stream (new Professor[]{p1, p2, p3, p4})<br class="calibre2"/>            .collect (Collectors.toSet());<br class="calibre2"/>    <br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public Professor <strong class="calibre3">findByName</strong> (String name) {<br class="calibre2"/>    return professors<br class="calibre2"/>        .stream()<br class="calibre2"/>        .filter(p-&gt;p.getName().equals(name))<br class="calibre2"/>        .findAny()<br class="calibre2"/>        .get();<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>}</pre>
<p class="mce-root">Finally, let's see the <kbd class="calibre18">ProfessorBO</kbd> class:</p>
<pre class="calibre23">import java.time.LocalDate;<br class="calibre2"/>import java.util.List;<br class="calibre2"/>import javax.inject.Inject;<br class="calibre2"/><br class="calibre2"/>public class ProfessorBO {<br class="calibre2"/>  private Professor professor; <br class="calibre2"/>  private List&lt;Discipline&gt; disciplines;<br class="calibre2"/>  <br class="calibre2"/>  @Inject <br class="calibre2"/>  private ProfessorDAO professorDAO;<br class="calibre2"/>  <br class="calibre2"/>  @Inject<br class="calibre2"/>  private DisciplineDAO disciplineDAO;<br class="calibre2"/>  <br class="calibre2"/>  public void setProfessor (Professor professor ) {<br class="calibre2"/>    this.professor = professorDAO.findByName (professor.getName());<br class="calibre2"/>  }<br class="calibre2"/><br class="calibre2"/>  public boolean canTeachDiscipline (Discipline discipline) {<br class="calibre2"/>    if (disciplines == null) {<br class="calibre2"/>      disciplines = disciplineDAO.getDisciplinesByProfessor <br class="calibre2"/>      (professor);<br class="calibre2"/>    }<br class="calibre2"/>    return disciplines.stream().anyMatch(d-&gt;d.equals(discipline));<br class="calibre2"/>    //return disciplines.contains(discipline);<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>  public LocalDate getInitDate () {<br class="calibre2"/>    return professor.getInitDate();<br class="calibre2"/>  }<br class="calibre2"/>  public String getName () {<br class="calibre2"/>    return professor.getName();<br class="calibre2"/>  }<br class="calibre2"/>  <br class="calibre2"/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre10">In this chapter, we explored the fact that the main objective of the Business Delegate is to hide the details of service implementations from the presentation tier. We have also seen that, in some situations, its use has been replaced by CDI technology (this technology is responsible for injecting components into a typesafe way application, such as injecting an EJB component), but we believe that this is not enough. The Business Delegate is still widely used in the treatment of more technical exceptions—for example, when it has remote EJB calls. In addition, the delegate protects the presentation tier from possible changes in the service layer, and conversely, when there are types of clients other than a web browser, using a delegate makes it easier for these new clients to access services.</span></p>
<p class="mce-root"><span class="calibre10">Session Façade centralizes business logic without exposing complex interactions that involve business objects to the client side. In addition, Session Façade encapsulates business-tier components and exposes coarse-grained services to both local and remote clients. </span><span class="calibre10">Consequently, the clients access a Session Façade instead of </span><span class="calibre10">directly accessing the </span><span class="calibre10">business components. </span><span class="calibre10">Some services, such as transaction-control or security-management, are addressed using Session Façade implementations, such as EJBs.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root">The business-object pattern must be used whenever an application presents a high level of complexity. This may include when the representation of real-world objects cannot be translated merely as a data-model object, and there is, therefore, a need for reusability and uniformity in business solutions. Aside from reusability, the immediate benefit of this includes efficient code maintenance and a rich cohesion between layers caused by the separation of responsibilities. This is because the business objects separate business logic and persistence from the rest of the application.</p>


            </article>

            
        </section>
    </div>



  </body></html>