- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Using RESTEasy Reactive to Implement Input Adapters
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RESTEasy Reactive实现输入适配器
- en: An **input adapter** is like a front door that exposes all the features provided
    by a hexagonal system. Whenever a user or other application wants to communicate
    with a hexagonal system, they reach one of the available input adapters. With
    such adapters, we can provide different ways to access the same functionality
    within the hexagonal system. If a client does not support HTTP communication,
    we can implement an adapter using a different protocol. The significant advantage
    here is that removing or adding new adapters does not influence the domain logic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入适配器**就像一扇前门，它展示了六角系统提供的所有功能。每当用户或其他应用程序想要与六角系统通信时，它们都会接触到可用的输入适配器之一。通过这样的适配器，我们可以在六角系统中提供不同的方式来访问相同的功能。如果客户端不支持HTTP通信，我们可以使用不同的协议实现适配器。这里的显著优势是，移除或添加新的适配器不会影响域逻辑。'
- en: Due to the hexagonal architecture’s decoupling and well-encapsulating nature,
    we can change technologies without any or major changes occurring in the system
    domain logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于六角架构的解耦和良好封装特性，我们可以在不改变系统域逻辑的情况下更改技术。
- en: In this chapter, we’ll continue our journey in exploring the exciting features
    of Quarkus. One feature that fits quite well with implementing input adapters
    is the **RESTEasy Reactive JAX-RS implementation**, which is a part of the Quarkus
    framework. RESTEasy Reactive proposes an asynchronous and event-driven way to
    expose HTTP endpoints. So, we’ll learn how to integrate such Reactive capabilities
    with input adapters from a hexagonal system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续探索Quarkus的激动人心特性。与实现输入适配器非常契合的一个特性是**RESTEasy Reactive JAX-RS实现**，它是Quarkus框架的一部分。RESTEasy
    Reactive提出了一种异步和事件驱动的HTTP端点暴露方式。因此，我们将学习如何将这种反应能力与六角系统的输入适配器集成。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Exploring the approaches to handling server requests
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索处理服务器请求的方法
- en: Implementing input adapters with RESTEasy Reactive
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RESTEasy Reactive实现输入适配器
- en: Adding OpenAPI and Swagger UI
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加OpenAPI和Swagger UI
- en: Testing Reactive input adapters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试反应式输入适配器
- en: By the end of this chapter, you’ll know how to implement and test input adapters
    with reactive behavior. You’ll also know how to publish the API for these input
    adapters using OpenAPI and Swagger UI.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何实现和测试具有反应行为的输入适配器。你还将了解如何使用OpenAPI和Swagger UI发布这些输入适配器的API。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are available for the Linux, Mac, and Windows operating systems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，你需要在计算机上安装最新的**Java SE开发工具包**和**Maven 3.8**。它们适用于Linux、Mac和Windows操作系统。
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter12).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub上找到本章的代码文件，地址为[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter12)。
- en: Exploring the approaches to handling server’s requests
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索处理服务器请求的方法
- en: In client-server communication, we have a process flow where a client sends
    a request, the server receives it, and it starts to do some work. Once the server
    finishes its work, it replies to the client with a result. From the client’s perspective,
    this flow does not change. It’s always about sending a request and receiving a
    response. What can change, though, is how the server can internally handle how
    a request is processed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器通信中，我们有一个流程，其中客户端发送请求，服务器接收它并开始工作。一旦服务器完成工作，它就会向客户端发送一个结果。从客户端的角度来看，这个流程不会改变。它始终是发送请求和接收响应。不过，可以改变的是服务器如何内部处理请求。
- en: 'There are two approaches to handling the server’s request processing: **reactive**
    and **imperative**. So, let’s see how a server can handle requests imperatively.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 处理服务器请求处理有两种方法：**反应式**和**命令式**。那么，让我们看看服务器如何以命令式处理请求。
- en: Imperative
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式
- en: 'In a traditional web application running on **Tomcat**, every request that’s
    received by the server triggers the creation of a worker thread on something called
    a **thread pool**. In Tomcat, a thread pool is a mechanism that controls the life
    cycle and availability of worker threads that serve application requests. So,
    when you make a server request, Tomcat pulls a dedicated thread from the thread
    pool to serve your request. This worker thread relies on blocking I/O to access
    databases and other systems. The following diagram illustrates how the imperative
    approach works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行于**Tomcat**的传统Web应用程序中，服务器接收到的每个请求都会在所谓的**线程池**上触发创建一个工作线程。在Tomcat中，线程池是一种控制服务应用程序请求的工作线程的生命周期和可用性的机制。因此，当你发起一个服务器请求时，Tomcat会从线程池中拉取一个专用线程来服务你的请求。这个工作线程依赖于阻塞I/O来访问数据库和其他系统。以下图表说明了命令式方法的工作原理：
- en: '![Figure 12.1 – The imperative approach](img/B19777_12_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 命令式方法](img/B19777_12_01.jpg)'
- en: Figure 12.1 – The imperative approach
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 命令式方法
- en: As shown in the preceding diagram, **Server** needs to create a new I/O blocking
    worker thread for each request.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，**服务器**需要为每个请求创建一个新的I/O阻塞工作线程。
- en: Once a worker thread has been created and allocated to serve a request, it is
    blocked until the request is fulfilled. The server has a limited number of threads.
    If you have lots of long-running requests and continue to send such requests before
    the server can finish them, the server will run out of threads, which will lead
    to system failures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建并分配一个工作线程来服务一个请求，它就会在请求得到满足之前被阻塞。服务器有有限数量的线程。如果你有很多长时间运行的请求，并且在服务器完成它们之前继续发送这样的请求，服务器将耗尽线程，这会导致系统故障。
- en: Thread creation and management is also expensive. The server expends valuable
    resources in creating and switching between threads to serve client requests.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 线程创建和管理也是昂贵的。服务器在创建和切换线程以服务客户端请求时消耗了宝贵的资源。
- en: So, the bottom line of the imperative approach is that a worker thread is blocked
    to serve one – and only one – request at a time. To serve more requests concurrently,
    you need to provide more worker threads. Also, the imperative approach influences
    how the code is written. Imperative code is somewhat more straightforward to understand
    because things are treated sequentially.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，命令式方法的底线是，工作线程一次只被阻塞来服务一个——并且只有一个——请求。为了并发服务更多的请求，你需要提供更多的工人线程。此外，命令式方法影响了代码的编写方式。命令式代码相对更容易理解，因为事物是按顺序处理的。
- en: Now, let’s see how the reactive approach contrasts with the imperative one.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看反应式方法与命令式方法是如何对比的。
- en: Reactive
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反应式
- en: 'As you may imagine, the idea behind the reactive approach is that you don’t
    need to block a thread to fulfill a request. Instead, the system can use the same
    thread to process different requests simultaneously. In the imperative approach,
    we have worker threads that handle only one request at a time, while in the reactive
    approach, we have I/O non-blocking threads that handle multiple requests concurrently.
    Here, we can see how the reactive approach works:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，反应式方法背后的理念是，你不需要阻塞一个线程来满足请求。相反，系统可以使用相同的线程同时处理不同的请求。在命令式方法中，我们有只处理一个请求的工作线程，而在反应式方法中，我们有I/O非阻塞线程可以并发处理多个请求。在这里，我们可以看到反应式方法是如何工作的：
- en: '![Figure 12.2 – The reactive approach](img/B19777_12_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 反应式方法](img/B19777_12_02.jpg)'
- en: Figure 12.2 – The reactive approach
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 反应式方法
- en: As shown in the preceding diagram, a single non-blocking thread can handle multiple
    requests.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，一个非阻塞线程可以处理多个请求。
- en: In the reactive approach, we have a sense of continuation. Instead of the sequential
    nature of the imperative approach, with Reactive, we can see that things have
    continuity. By continuation, we mean that whenever a Reactive-ready server receives
    a request, such a request is dispatched as an I/O operation with an attached continuation.
    This continuation works like a callback that is triggered and continues to execute
    the request once the server returns with a response. If this request needs to
    fetch a database or any remote system, the server won’t block the I/O thread while
    waiting for a response. Instead, the I/O thread will trigger an I/O operation
    with an attached continuation and will release the I/O thread to accept other
    requests.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式方法中，我们有持续性的感觉。与命令式方法的顺序性不同，在响应式方法中，我们可以看到事物具有连续性。通过持续性，我们指的是每当一个响应式服务器接收到一个请求时，这样的请求会被作为一个带有持续性的I/O操作分发。这个持续性就像一个回调，一旦服务器返回响应，就会被触发并继续执行请求。如果这个请求需要获取数据库或任何远程系统，服务器在等待响应时不会阻塞I/O线程。相反，I/O线程将触发一个带有持续性的I/O操作，并释放I/O线程以接受其他请求。
- en: 'The following diagram illustrates how I/O threads trigger I/O operations:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示说明了I/O线程如何触发I/O操作：
- en: '![Figure 12.3 – I/O thread flow](img/B19777_12_03.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – I/O线程流程](img/B19777_12_03.jpg)'
- en: Figure 12.3 – I/O thread flow
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – I/O线程流程
- en: As we can see, an I/O thread calls a non-blocking task that triggers an I/O
    operation and returns immediately. This happens because the I/O thread does not
    need to wait for the first I/O operation to finish to call a second one. While
    the first I/O operation is still executing, the same I/O thread calls for another
    non-blocking task. Once the I/O operation has concluded, the I/O thread resumes
    execution by finishing the non-blocking tasks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，I/O线程调用一个非阻塞任务，该任务触发一个I/O操作并立即返回。这是因为I/O线程不需要等待第一个I/O操作完成就可以调用第二个操作。当第一个I/O操作仍在执行时，同一个I/O线程会调用另一个非阻塞任务。一旦I/O操作完成，I/O线程通过完成非阻塞任务来继续执行。
- en: By avoiding wasting any time and resources that exist in the imperative approach,
    the reactive approach makes makes optimized use of threads as they don’t while
    waiting for an I/O operation to be finished.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通过避免在命令式方法中浪费任何时间和资源，响应式方法使得线程在等待I/O操作完成时得到优化利用。
- en: Next, we’ll learn how to implement reactive input adapters using the RESTEasy
    Reactive JAX-RS implementation provided by Quarkus.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何使用Quarkus提供的RESTEasy Reactive JAX-RS实现来实施响应式输入适配器。
- en: Implementing input adapters with RESTEasy Reactive
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用RESTEasy Reactive实现输入适配器
- en: '**RESTEasy Reactive** is a JAX-RS implementation that supports both imperative
    and reactive HTTP endpoints. Such an implementation integrates with **Vert.x**,
    which is a toolkit that we can use to build distributed Reactive systems. RESTEasy
    Reactive and Vert.x work together in Quarkus to provide Reactive capabilities.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**RESTEasy Reactive**是一个支持命令式和响应式HTTP端点的JAX-RS实现。这种实现与**Vert.x**集成，Vert.x是一个我们可以用来构建分布式响应式系统的工具包。RESTEasy
    Reactive和Vert.x在Quarkus中协同工作，以提供响应式功能。'
- en: To understand what a Reactive endpoint looks like, we will integrate RESTEasy
    Reactive with the input adapters of the topology and inventory system.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解一个响应式端点是什么样的，我们将把RESTEasy Reactive与拓扑和库存系统的输入适配器集成。
- en: 'Let’s start by configuring the required Maven dependencies:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先配置所需的Maven依赖项：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With `quarkus-resteasy-reactive`, we bring the Reactive libraries, including
    Reactive RESTEasy and the `Mutiny` library, which we’ll use to create code in
    a reactive fashion. We will use `quarkus-resteasy-reactive-jackson` for deserialization
    tasks involving the Reactive responses.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`quarkus-resteasy-reactive`，我们引入了响应式库，包括响应式RESTEasy和`Mutiny`库，我们将使用这些库以响应式的方式编写代码。我们将使用`quarkus-resteasy-reactive-jackson`来处理涉及响应式响应的反序列化任务。
- en: Once we have the dependencies configured, we can start implementing the Reactive
    input adapter for router management in the topology and inventory system.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置了依赖项，我们就可以开始实现拓扑和库存系统中的路由管理响应式输入适配器。
- en: Implementing the Reactive input adapter for router management
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用于路由管理的响应式输入适配器
- en: 'We’ll work on top of the existing input adapters that we created in [*Chapter
    8*](B19777_08.xhtml#_idTextAnchor174), *Building the Framework Hexagon*. We’ll
    change those input adapters to enable JAX-RS and Reactive capabilities. We’ll
    execute the following steps to do so:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在我们创建的现有输入适配器上工作，这些适配器在 [*第 8 章*](B19777_08.xhtml#_idTextAnchor174)，*构建框架六边形*
    中创建。我们将更改这些输入适配器以启用 JAX-RS 和响应式功能。我们将执行以下步骤来完成此操作：
- en: 'Let’s start by defining the top-level path for requests related to router management
    on the `RouterManagementAdapter` class:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `RouterManagementAdapter` 类上定义与路由管理相关的请求的最高级路径开始：
- en: '[PRE1]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We use the `@Path` annotation to map a URL path to a resource in the system.
    We can use this annotation on top of a class or a method.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `@Path` 注解将 URL 路径映射到系统中的资源。我们可以在类或方法上使用此注解。
- en: The only field of this class is `RouterManagementUseCase`, which is injected
    using the `@Inject` annotation. By utilizing this use case reference, we gain
    access to system features related to router management.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类的唯一字段是 `RouterManagementUseCase`，它使用 `@Inject` 注解注入。通过利用这个用例引用，我们可以访问与路由管理相关的系统功能。
- en: 'Next, let’s define a Reactive endpoint to retrieve a router:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个响应式端点来检索一个路由：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `@GET` annotation says that only `HTTP GET` requests are allowed. The `@Path("/{id}")`
    annotation from the method level is concatenated with the `@Path("/router")` annotation
    from the class level. So, to reach this `retrieveRouter` method, we have to send
    a request to `/router/{id}`.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@GET` 注解表示只允许 `HTTP GET` 请求。方法级别的 `@Path("/{id}")` 注解与类级别的 `@Path("/router")`
    注解连接。因此，要到达这个 `retrieveRouter` 方法，我们必须向 `/router/{id}` 发送请求。'
- en: Also, note the `@PathParam("id")` annotation, which we use to capture a parameter
    from the URL.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，请注意 `@PathParam("id")` 注解，我们使用它来从 URL 中捕获一个参数。
- en: What makes this endpoint a Reactive one is its `Uni<Response>` response type.
    `Uni` is one of the two types provided by the `Mutiny` library. In addition to
    `Uni`, there is also the `Multi` type.
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使这个端点成为响应式的是它的 `Uni<Response>` 响应类型。`Uni` 是 `Mutiny` 库提供的两种类型之一。除了 `Uni`，还有一个
    `Multi` 类型。
- en: We use the `Uni` and `Multi` types to represent what kind of data we’re dealing
    with. For example, if your response returns just one item, you should use `Uni`.
    Otherwise, if your response is like a stream of data, such as those that come
    from a messaging server, then `Multi` may be more suited for your purpose.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用 `Uni` 和 `Multi` 类型来表示我们正在处理的数据类型。例如，如果你的响应只返回一个项目，你应该使用 `Uni`。否则，如果你的响应类似于来自消息服务器的数据流，那么
    `Multi` 可能更适合你的目的。
- en: 'By calling `Uni.createFrom().item(routerManagementUseCase.retrieveRouter(id))`,
    we’re creating a pipeline that executes `routerManagementUseCase.retrieveRouter(id)`.
    The result is captured on `transform(f -> f != null ? Response.ok(f) : Response.ok(null))`.
    If the request is successful, we get `Response.ok(f)`; otherwise, we get `Response.ok(null)`.
    Finally, we call `transform(Response.ResponseBuilder::build)` to transform the
    result into a `Uni<Response>` object.'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '通过调用 `Uni.createFrom().item(routerManagementUseCase.retrieveRouter(id))`，我们创建了一个执行
    `routerManagementUseCase.retrieveRouter(id)` 的管道。结果被捕获在 `transform(f -> f != null
    ? Response.ok(f) : Response.ok(null))` 上。如果请求成功，我们得到 `Response.ok(f)`；否则，我们得到
    `Response.ok(null)`。最后，我们调用 `transform(Response.ResponseBuilder::build)` 将结果转换为
    `Uni<Response>` 对象。'
- en: '`Response.ResponseBuilder::build` is a method reference that could be written
    as the following lambda expression: (`Response.ResponseBuilder responseBuilder)
    -> responseBuilder.build()`. `responseBuilder` represents the object parameter
    we receive, followed by the `build` method call to create a new `Response` object.
    We favor the method reference approach because we write less code to accomplish
    the same thing.'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Response.ResponseBuilder::build` 是一个方法引用，可以写成以下 lambda 表达式：（`Response.ResponseBuilder
    responseBuilder) -> responseBuilder.build()`）。`responseBuilder` 代表我们接收的对象参数，然后调用
    `build` 方法来创建一个新的 `Response` 对象。我们倾向于使用方法引用方法，因为我们用更少的代码完成同样的事情。'
- en: The remaining endpoints we are about to implement all follow a similar approach
    to the one described previously.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们即将实现的其余端点都遵循之前描述的类似方法。
- en: 'After implementing an endpoint to retrieve a router, we can implement an endpoint
    to remove a router from the system:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实现检索路由的端点之后，我们可以实现从系统中删除路由的端点：
- en: '[PRE3]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `@DELETE` annotation corresponds to the `HTTP DELETE` method. Again, we
    are defining a `Path` parameter on the `@Path("/{id}")` annotation. The method
    body has a `Uni` pipeline that executes `routerManagementUseCase.removeRouter(id)`
    and returns `Uni<Response>`.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`@DELETE`注解对应于`HTTP DELETE`方法。同样，我们正在在`@Path("/{id}")`注解上定义一个`Path`参数。方法体中有一个`Uni`管道，它执行`routerManagementUseCase.removeRouter(id)`并返回`Uni<Response>`。'
- en: 'Let’s implement the endpoint to create a new router:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们实现创建新路由器的端点：
- en: '[PRE4]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use the `@POST` annotation because we’re creating a new resource. The `@Path("/")`
    annotation at the method level, when concatenated with the `@Path("/router")`
    annotation at the class level, generates the `/router/` path. We have the Reactive
    code in the method body to handle the request and return `Uni<Response>`.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`@POST`注解，因为我们正在创建一个新的资源。在方法级别上，`@Path("/")`注解与类级别上的`@Path("/router")`注解连接，生成`/router/`路径。我们在方法体中有响应式代码来处理请求并返回`Uni<Response>`。
- en: 'Next, we will implement the endpoint so that a router can be added to a core
    router:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现一个端点，以便可以将路由器添加到核心路由器：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Again, we use the `@POST` annotation here. The `@Path("/add")` annotation at
    the method level, when concatenated with `@Path("/router")` at the class level,
    generates the `/router/add` path. The Reactive code creates a pipeline to execute
    `routerManagementUseCase.addRouterToCoreRouter(router, coreRouter)` and return
    `Uni<Response>`.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，我们在这里使用`@POST`注解。在方法级别上，`@Path("/add")`注解与类级别上的`@Path("/router")`注解连接，生成`/router/add`路径。响应式代码创建了一个管道来执行`routerManagementUseCase.addRouterToCoreRouter(router,
    coreRouter)`并返回`Uni<Response>`。
- en: 'Finally, we must implement the endpoint to remove a router from a core router:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须实现一个端点来从核心路由器中移除一个路由器：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we use the `@DELETE` annotation to handle `HTTP DELETE` requests. In the
    `@Path` annotation, we have two path parameters – `routerId` and `coreRouterId`.
    We use these two parameters to obtain the `Router` and `CoreRouter` objects when
    we call `routerManagementUseCase. removeRouterFromCoreRouter(router, coreRouter)`
    inside the pipeline provided by `Uni`.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`@DELETE`注解来处理`HTTP DELETE`请求。在`@Path`注解中，我们有两个路径参数 - `routerId`和`coreRouterId`。当我们通过`Uni`提供的管道调用`routerManagementUseCase.removeRouterFromCoreRouter(router,
    coreRouter)`时，我们使用这两个参数来获取`Router`和`CoreRouter`对象。
- en: As we can see, when using Quarkus, it does not take too much to shift from an
    imperative to a Reactive way of implementing REST endpoints. Much of the work
    is done behind the scenes by the framework and its libraries.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，当使用Quarkus时，从命令式转换为响应式实现REST端点并不需要太多工作。大部分工作都是在框架及其库的幕后完成的。
- en: Now, let’s move on and implement Reactive input adapters for switch management.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进并实现用于开关管理的响应式输入适配器。
- en: Implementing the Reactive input adapter for switch management
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现用于开关管理的响应式输入适配器
- en: 'Following a similar approach to the one we followed in the previous section,
    we can implement the Reactive input adapters for switch management by executing
    the following steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 按照与上一节中类似的方法，我们可以通过执行以下步骤来实现用于开关管理的响应式输入适配器：
- en: 'We will start by enabling JAX-RS on the `SwitchManagementAdapter` class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先在`SwitchManagementAdapter`类上启用JAX-RS：
- en: '[PRE7]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This class is annotated with `@Path("/switch")`, so all the switch management-related
    requests will be directed to it. Following this, we inject both `SwitchManagementUseCase`
    and `RouterManagementUseCase` to execute operations on the Application hexagon.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类被注解为`@Path("/switch")`，因此所有与开关管理相关的请求都将被导向它。随后，我们注入了`SwitchManagementUseCase`和`RouterManagementUseCase`以在应用程序六边形上执行操作。
- en: 'To enable switch retrieval in the topology and inventory system, we need to
    implement the Reactive behavior on the `retrieveSwitch` method:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在拓扑和库存系统中启用开关检索，我们需要在`retrieveSwitch`方法上实现响应式行为：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: By adding the `@GET` and `@Path` annotations, we activate JAX-RS on the `retrieveSwitch`
    method. We place `switchManagementUseCase.retrieveSwitch(switchId)` so that it’s
    executed inside a `Mutiny` pipeline that returns `Uni<Response>`.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过添加`@GET`和`@Path`注解，我们激活了`retrieveSwitch`方法的JAX-RS。我们将`switchManagementUseCase.retrieveSwitch(switchId)`放置在返回`Uni<Response>`的`Mutiny`管道中执行。
- en: The call on `item` returns immediately. It triggers the operation that’s executed
    by the `retrieveSwitch` method and allows the thread to continue serving other
    requests. The result is obtained when we call `onItem`, which represents the continuation
    of the operation that’s triggered when we call `item`.
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对`item`的调用立即返回。它触发了由`retrieveSwitch`方法执行的操作，并允许线程继续服务其他请求。结果是在我们调用`onItem`时获得的，它代表了当我们调用`item`时触发的操作继续。
- en: 'Next, we must add Reactive behavior to the `createAndAddSwitchToEdgeRouter`
    method:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须向`createAndAddSwitchToEdgeRouter`方法添加响应式行为：
- en: '[PRE9]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding method handles the `HTTP POST` requests to create a switch object
    and add it to an edge router. We call the `routerManagementUseCase.persistRouter(router)`
    method here, which is wrapped inside a `Mutiny` pipeline, to return `Uni<Response>`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的方法处理了创建开关对象并将其添加到边缘路由器的`HTTP POST`请求。在这里，我们调用`routerManagementUseCase.persistRouter(router)`方法，该方法被封装在一个`Mutiny`管道中，以返回`Uni<Response>`。
- en: 'Finally, we must define the Reactive endpoint to remove a switch from an edge
    router:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个响应式端点来从一个边缘路由器中移除一个开关：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we did with our previous removal operation, where we removed a router from
    a core router, we use the `@DELETE` annotation to make the `removeSwitchFromEdgeRouter`
    method only accept the `HTTP DELETE` requests. We pass the `Path` parameters,
    `switchId` and `edgeRouterId`, to obtain the switch and edge router objects required
    for the operation.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的移除操作中所做的那样，我们从核心路由器中移除了一个路由器，我们使用`@DELETE`注解来使`removeSwitchFromEdgeRouter`方法只接受`HTTP
    DELETE`请求。我们传递`Path`参数`switchId`和`edgeRouterId`，以获取操作所需的开关和边缘路由器对象。
- en: After defining the Reactive endpoints for `retrieveSwitch`, `createAndAddSwitchToEdgeRouter`,
    and `removeSwitchFromEdgeRouter`, we can start implementing the Reactive input
    adapter for network management.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了`retrieveSwitch`、`createAndAddSwitchToEdgeRouter`和`removeSwitchFromEdgeRouter`的响应式端点之后，我们可以开始实现网络管理的响应式输入适配器。
- en: Implementing the Reactive input adapter for network management
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现网络管理的响应式输入适配器
- en: 'As you may imagine, the `network` Reactive input adapter follows the same standard
    that’s used by the router and switch Reactive adapters. In the following steps,
    we will enable Reactive behavior for endpoints related to network management:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，`network`响应式输入适配器遵循与路由器和开关响应式适配器相同的标准。在以下步骤中，我们将为与网络管理相关的端点启用响应式行为：
- en: 'Let’s start by enabling JAX-RS on the `NetworkManagementAdapter` input adapter:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从启用`NetworkManagementAdapter`输入适配器的JAX-RS开始：
- en: '[PRE11]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: At this point, you may be familiar with the `@Path` annotation at the class
    level. We inject the `SwitchManagementUseCase` and `NetworkManagementUseCase`
    uses cases to assist in the operations that are executed by this input adapter.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能已经熟悉了类级别的`@Path`注解。我们注入`SwitchManagementUseCase`和`NetworkManagementUseCase`用例，以协助执行此输入适配器所执行的操作。
- en: 'Next, we must define a Reactive endpoint so that networks can be added to a
    switch:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须定义一个响应式端点，以便可以将网络添加到开关中：
- en: '[PRE12]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The idea we apply here is the same one we applied to the previous implementations.
    Inside the `addNetworkToSwitch` method, we add some Reactive code that will use
    a `Mutiny` pipeline to call `networkManagementUseCase.addNetworkToSwitch( network,
    networkSwitch)` and return `Uni<Response>`.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里应用的想法与之前的应用相同。在`addNetworkToSwitch`方法内部，我们添加了一些将使用`Mutiny`管道调用`networkManagementUseCase.addNetworkToSwitch(network,
    networkSwitch)`并返回`Uni<Response>`的响应式代码。
- en: 'Finally, we must define the Reactive endpoint to remove a network from a switch:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须定义一个响应式端点来从一个开关中移除一个网络：
- en: '[PRE13]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we use the `@DELETE` annotation and two path parameters, `networkName`
    and `switchId`, to remove a network from a switch. Inside the `Mutiny` pipeline,
    we call `networkManagementUseCase.removeNetworkFromSwitch(networkName, networkSwitch)`.
    The pipeline result is `Uni<Response>`.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用`@DELETE`注解和两个路径参数`networkName`和`switchId`来从一个开关中移除一个网络。在`Mutiny`管道内部，我们调用`networkManagementUseCase.removeNetworkFromSwitch(networkName,
    networkSwitch)`。管道结果是`Uni<Response>`。
- en: With that, we have finished implementing the Reactive input adapter for network
    management. Now, the `RouterManagementAdapter`, `SwitchManagementAdapter`, and
    `NetworkManagementAdapter` input adapters are ready to serve HTTP requests in
    a Reactive way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们已经完成了网络管理响应式输入适配器的实现。现在，`RouterManagementAdapter`、`SwitchManagementAdapter`和`NetworkManagementAdapter`输入适配器已准备好以响应式方式处理HTTP请求。
- en: These three input adapters and their endpoints form the hexagonal system API.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个输入适配器和它们的端点构成了六边形系统API。
- en: In this section, we not only learned how to create ordinary REST endpoints,
    but we also went the extra mile by using RESTEasy Reactive to enable Reactive
    behavior on the input adapter’s endpoints. That’s a fundamental step to tap into
    the advantages that a Reactive approach can provide. With the Reactive approach,
    we no longer need to depend on I/O blocking threads, which may consume more computing
    resources than I/O non-blocking threads. I/O blocking threads need to wait for
    I/O operations to finish. I/O non-blocking threads are more efficient because
    the same thread can handle several I/O operations at the same time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们不仅学习了如何创建普通的REST端点，而且还通过使用RESTEasy Reactive在输入适配器的端点上启用响应式行为而更进一步。这是利用响应式方法优势的基本步骤。采用响应式方法后，我们不再需要依赖于I/O阻塞线程，这些线程可能比I/O非阻塞线程消耗更多的计算资源。I/O阻塞线程需要等待I/O操作完成。I/O非阻塞线程更高效，因为同一个线程可以同时处理多个I/O操作。
- en: The next section will cover how to use OpenAPI and Swagger UI to publish the
    system API.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍如何使用OpenAPI和Swagger UI发布系统API。
- en: Adding OpenAPI and Swagger UI
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加OpenAPI和Swagger UI
- en: Understanding and interacting with third-party systems is sometimes a non-trivial
    undertaking. In the best scenario, we may have the system documentation, an organized
    code base, and a set of APIs that, together, help us understand what the system
    does. In the worst scenario, we have none of these things. This challenging situation
    requires courage, patience, and persistence to venture into trying to understand
    a tangled code base with intricate complexities.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 理解和与第三方系统交互有时是一项非同寻常的任务。在最佳情况下，我们可能拥有系统文档、一个有组织的代码库和一组API，这些API共同帮助我们了解系统的作用。在最坏的情况下，我们可能没有这些。这种具有挑战性的情况需要勇气、耐心和毅力，去尝试理解一个错综复杂的代码库。
- en: OpenAPI represents an honorable effort to increase our capacity to express and
    understand what a system does. Originally based on the Swagger specification,
    the OpenAPI specification standardizes how APIs are documented and described so
    that anyone can grasp the capabilities offered by a system without much effort.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI代表了提高我们表达和理解系统作用能力的一项值得尊敬的努力。最初基于Swagger规范，OpenAPI规范标准化了API的文档和描述方式，以便任何人都可以不费吹灰之力地掌握系统提供的功能。
- en: We spent the previous section implementing the Reactive input adapters that
    form the API of our hexagonal system. To make this system more understandable
    to other people and systems, we’ll use OpenAPI to describe the functionalities
    provided by the input adapters and their endpoints. Also, we’ll enable **Swagger
    UI**, a web application that presents a clear and organized view of the system’s
    APIs.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中实现了构成我们六边形系统API的响应式输入适配器。为了使这个系统对其他人或系统更易于理解，我们将使用OpenAPI来描述输入适配器及其端点提供的功能。此外，我们还将启用**Swagger
    UI**，这是一个展示系统API清晰和组织视图的Web应用程序。
- en: 'Quarkus comes with built-in support for the **OpenAPI v3** specification. To
    enable it, we need the following Maven dependency:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus自带对**OpenAPI v3**规范的支持。要启用它，我们需要以下Maven依赖项：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `quarkus-smallrye-openapi` dependency provides the libraries that contain
    the OpenAPI annotations we can use to describe the Reactive endpoint methods on
    the input adapter classes. This dependency lets us configure Swagger UI, too.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`quarkus-smallrye-openapi`依赖项提供了包含我们可以用来描述输入适配器类上响应式端点方法的OpenAPI注解的库。此依赖项还允许我们配置Swagger
    UI。'
- en: 'Remember that we configured four Java modules: `domain`, `application`, `framework`,
    and `bootstrap`. To activate and configure Swagger UI, we need to create the `resource/application.properties`
    file inside the `bootstrap` module. Here is how we can configure this file:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们配置了四个Java模块：`domain`、`application`、`framework`和`bootstrap`。为了激活和配置Swagger
    UI，我们需要在`bootstrap`模块内部创建`resource/application.properties`文件。以下是配置此文件的方法：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We set `quarkus.swagger-ui.always-include` to `true` to ensure that Swagger
    UI will also be available when the application is started using the `prod` (production)
    profile – one of the built-in Quarkus profiles. With `quarkus.swagger-ui.theme`,
    we can configure the interface theme. We will use the remaining properties to
    provide a high-level description of the API.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`quarkus.swagger-ui.always-include`设置为`true`，以确保当应用程序使用`prod`（生产）配置文件启动时，Swagger
    UI也将可用——这是Quarkus内置配置文件之一。通过`quarkus.swagger-ui.theme`，我们可以配置界面主题。我们将使用剩余的属性来提供API的高级描述。
- en: 'Let’s learn how to use the OpenAPI annotations to expose and describe the hexagonal
    system’s endpoints. Look at the following example from the `RouterManagementAdapter`
    class:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何使用OpenAPI注解来暴露和描述六边形系统的端点。看看以下来自`RouterManagementAdapter`类的示例：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `@Tag` annotation, which is used at the class level, lets us define the
    metadata information that’s applied for all the endpoints defined in the `RouterManagementAdapter`
    class. This means that the method endpoints, such as the `retrieveRouter` method
    in the `RouterManagementAdapter` class, will inherit that class-level `@``Tag`
    annotation.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在类级别使用的`@Tag`注解使我们能够定义应用于`RouterManagementAdapter`类中定义的所有端点的元数据信息。这意味着方法端点，如`RouterManagementAdapter`类中的`retrieveRouter`方法，将继承该类级别的`@Tag`注解。
- en: We use the `@Operation` annotation to provide details of an operation. In the
    preceding code, we’re describing the operation that’s performed at the `/retrieve/{id}`
    path. We have the `operationId` parameter here, which is used to uniquely identify
    the endpoint, and the `description` parameter, which is used to provide a meaningful
    operation description.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`@Operation`注解来提供操作的详细信息。在上面的代码中，我们描述了在`/retrieve/{id}`路径上执行的操作。这里我们有`operationId`参数，它用于唯一标识端点，以及`description`参数，它用于提供有意义的操作描述。
- en: To make Quarkus and Swagger UI display a fancy UI of our hexagonal system’s
    API, we just need to add these OpenAPI annotations to the classes and methods
    (properly configured with JAX-RS) that we want to expose on Swagger UI.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Quarkus和Swagger UI显示我们六边形系统API的华丽UI，我们只需将这些OpenAPI注解添加到我们想要在Swagger UI上公开的类和方法（正确配置了JAX-RS）中。
- en: 'You can compile and run the application using the code from this book’s GitHub
    repository. Make sure that you execute the following commands in the `chapter12`
    directory:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用本书GitHub仓库中的代码编译和运行应用程序。确保在`chapter12`目录中执行以下命令：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will open the following URL on your browser:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在您的浏览器上打开以下URL：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Also, you’ll see something similar to the following screenshot:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您将看到类似于以下截图的内容：
- en: '![Figure 12.4 – Swagger UI from topology and inventory system](img/B19777_12_04.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 来自拓扑和库存系统的Swagger UI](img/B19777_12_04.jpg)'
- en: Figure 12.4 – Swagger UI from topology and inventory system
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 来自拓扑和库存系统的Swagger UI
- en: In the preceding screenshot, the operations are grouped into `@Tag` annotation
    we inserted for each of the input adapter classes. Each endpoint inherited its
    respective `@Tag` metadata information.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，操作被分组到我们为每个输入适配器类插入的`@Tag`注解中。每个端点都继承了自己的`@Tag`元数据信息。
- en: So far, we have our hexagonal system properly configured with Reactive endpoints
    that are well documented with OpenAPI and Swagger UI. Now, let’s learn how to
    test these endpoints to ensure they are working as expected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经正确配置了我们的六边形系统，其中包含用OpenAPI和Swagger UI良好记录的反应式端点。现在，让我们学习如何测试这些端点以确保它们按预期工作。
- en: Testing Reactive input adapters
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试反应式输入适配器
- en: Our testing efforts started on the Domain hexagon by unit testing the core system
    components. Then, we moved on to the Application hexagon, where we could test
    the use cases using **behavior-driven design** techniques. Now that we have implemented
    Reactive REST endpoints on the Framework hexagon, we need to find a way to test
    them.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试工作从领域六边形开始，通过单元测试核心系统组件。然后，我们转向应用六边形，在那里我们可以使用**行为驱动设计**技术测试用例。现在，我们在框架六边形上实现了反应式REST端点，我们需要找到一种方法来测试它们。
- en: 'Fortunately, Quarkus comes well equipped when it comes to endpoint testing.
    To get started, we need the following dependency:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Quarkus在端点测试方面装备齐全。要开始，我们需要以下依赖项：
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `rest-assured` dependency allows us to test HTTP endpoints. It provides
    an intuitive library that’s very useful for making requests and extracting responses
    from HTTP calls.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`rest-assured`依赖项使我们能够测试HTTP端点。它提供了一个直观的库，对于进行请求和从HTTP调用中提取响应非常有用。'
- en: 'To see how it works, let’s implement a test for the `/``router/retrieve/{routerId}`
    endpoint:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它是如何工作的，让我们为`/router/retrieve/{routerId}`端点实现一个测试：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To create a request, we can use the static `io.restassured.RestAssured.given`
    method. We can specify the content type, parameters, HTTP method, and body of
    a request with the `given` method. After sending the request, we can check its
    status with `statusCode`. To obtain the response, we call `extract`. In the following
    example, we’re getting the response in the form of a string. This is because the
    return type of the Reactive endpoint is `Uni<Response>`. So, the result is a JSON
    string.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个请求，我们可以使用静态的`io.restassured.RestAssured.given`方法。我们可以使用`given`方法指定请求的内容类型、参数、HTTP方法和正文。发送请求后，我们可以使用`statusCode`检查其状态。为了获取响应，我们调用`extract`。在下面的示例中，我们以字符串的形式获取响应。这是因为反应式端点的返回类型是`Uni<Response>`。因此，结果是JSON字符串。
- en: 'We need to deserialize the JSON string into a `Router` object before running
    assertions. The deserialization work is accomplished by the `getRouterDeserialized`
    method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行断言之前，我们需要将JSON字符串反序列化为`Router`对象。反序列化工作由`getRouterDeserialized`方法完成：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This method receives a JSON string as a parameter. This JSON string is passed
    to an `ObjectMapper` mapper when we call `mapper.readValue(jsonStr, Router.class)`.
    In addition to providing a mapper, we also need to extend and implement the `deserialize`
    method from the `com.fasterxml.jackson.databind.deser.std.StdDeserializer` class.
    In the preceding example, this implementation is provided by `RouterDeserializer`.
    This deserializer will transform the JSON string into a `Router` object, as shown
    in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接收一个JSON字符串作为参数。当我们调用`mapper.readValue(jsonStr, Router.class)`时，这个JSON字符串会被传递给一个`ObjectMapper`映射器。除了提供映射器外，我们还需要扩展并实现`com.fasterxml.jackson.databind.deser.std.StdDeserializer`类中的`deserialize`方法。在先前的示例中，这个实现由`RouterDeserializer`提供。这个反序列化器将JSON字符串转换为`Router`对象，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `deserialize` method intends to map every relevant JSON attribute to a
    domain type. We perform this mapping by retrieving the values we want from a `JsonNode`
    object. After mapping the values that we want, we can create a `router` object,
    as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`deserialize`方法的目的是将每个相关的JSON属性映射到领域类型。我们通过从`JsonNode`对象中检索我们想要的值来完成这个映射。在映射我们想要的值之后，我们可以创建一个`router`对象，如下面的代码所示：'
- en: '[PRE23]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once all the values have been retrieved, we call `RouterFactory.getRouter`
    to produce a `Router` object. Because a router may have child routers and switches,
    we call `fetchChildRouters` and `fetchChildSwitches` so that they also have `StdDeserializer`
    implementations:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有值都被检索，我们调用`RouterFactory.getRouter`来生成一个`Router`对象。因为一个路由器可能有子路由器和开关，所以我们调用`fetchChildRouters`和`fetchChildSwitches`，以便它们也有`StdDeserializer`实现：
- en: '[PRE24]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We call the `fetchChildRouters` and `fetchChildSwitches` methods because a router
    may have child routers and switches that need to be deserialized. These methods
    will perform the required deserialization.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用`fetchChildRouters`和`fetchChildSwitches`方法，因为一个路由器可能有子路由器和开关需要反序列化。这些方法将执行所需的反序列化。
- en: 'After deserializing the JSON string response, we can run the assertion on a
    `Router` object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在反序列化JSON字符串响应之后，我们可以在`Router`对象上运行断言：
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: To test the `/router/retrieve/{routerId}` endpoint, we are checking whether
    the ID of the router that’s been retrieved by the Reactive endpoint is equal to
    the one we passed in the request.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`/router/retrieve/{routerId}`端点，我们正在检查通过反应式端点检索的路由器的ID是否与我们请求中传递的ID相等。
- en: 'You can run this and other tests that are available in this book’s GitHub repository
    by executing the following command inside the `Chapter12` directory:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`Chapter12`目录内执行以下命令来运行此测试和其他本书GitHub仓库中可用的测试：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of the preceding code will be similar to the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的输出将类似于以下内容：
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding output describes the execution of the Reactive endpoint tests
    for the `RouterManagementAdapter`, `SwitchManagementAdapter`, and `NetworkManagementAdapter`
    input adapters.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出描述了针对`RouterManagementAdapter`、`SwitchManagementAdapter`和`NetworkManagementAdapter`输入适配器的反应式端点测试的执行。
- en: One benefit of executing these endpoint tests is that we are not only testing
    the endpoint functionality on the Framework hexagon but also performing comprehensive
    tests that check the behavior of all the hexagons of the system.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这些端点测试的一个好处是，我们不仅测试了框架六边形上的端点功能，而且还进行了全面的测试，检查了系统所有六边形的行怍。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we had the opportunity to dive into more Quarkus features,
    especially RESTEasy Reactive. We started by reviewing what imperative and reactive
    mean in the context of client-server communication.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们有幸深入了解更多 Quarkus 功能，特别是 RESTEasy Reactive。我们首先回顾了在客户端-服务器通信的上下文中，命令式和响应式分别意味着什么。
- en: Then, we learned that Quarkus provides RESTEasy Reactive as its JAX-RS implementation,
    enabling us to implement Reactive endpoints on input adapters. After that, we
    exposed the hexagonal system’s API using OpenAPI and Swagger UI. To ensure we
    implemented the Reactive endpoints correctly, we wrote the endpoint tests using
    the `rest-assured` library.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们了解到 Quarkus 提供了 RESTEasy Reactive 作为其 JAX-RS 实现，使我们能够在输入适配器上实现响应式端点。之后，我们使用
    OpenAPI 和 Swagger UI 暴露了六边形系统的 API。为了确保我们正确实现了响应式端点，我们使用 `rest-assured` 库编写了端点测试。
- en: In the next chapter, we’ll continue exploring the Reactive capabilities offered
    by Quarkus and emphasize the data persistence aspects with Hibernate Reactive.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探索 Quarkus 提供的响应式功能，并强调使用 Hibernate Reactive 的数据持久性方面。
- en: Questions
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between imperative and reactive requests?
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令式请求和响应式请求之间的区别是什么？
- en: What is the name of the JAX-RS implementation provided by Quarkus?
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quarkus 提供的 JAX-RS 实现的名称是什么？
- en: What is the purpose of OpenAPI?
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenAPI 的目的是什么？
- en: Which library should we use in Quarkus to test HTTP endpoints?
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Quarkus 中，我们应该使用哪个库来测试 HTTP 端点？
- en: Answers
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Imperative can only handle one request at a time using an I/O blocking worker
    thread. Reactive can handle multiple requests using I/O non-blocking threads.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命令式只能通过一个 I/O 阻塞工作线程一次处理一个请求。响应式可以通过 I/O 非阻塞线程处理多个请求。
- en: RESTEasy Reactive.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RESTEasy Reactive。
- en: It’s used to standardize the way APIs are described and documented.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它用于标准化描述和记录 API 的方式。
- en: We should use the `rest-assured` library.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应该使用 `rest-assured` 库。
