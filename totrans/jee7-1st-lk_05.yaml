- en: Chapter 5. The Business Layer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：业务层
- en: 'Here we will begin with a presentation of improvements in the business layer
    and then, in a small project, we will try to put together some of the specifications
    seen previously. The topics to be covered include:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将从业务层的改进开始介绍，然后在一个小型项目中尝试将之前看到的某些规范组合起来。将要涉及的主题包括：
- en: Enterprise JavaBeans 3.2
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业 JavaBeans 3.2
- en: Putting all Java EE 7 specifications together
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有 Java EE 7 规范合并在一起
- en: Enterprise JavaBeans 3.2
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 企业 JavaBeans 3.2
- en: The Enterprise JavaBeans 3.2 Specification was developed under JSR 345\. This
    section just gives you an overview of improvements in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 企业 JavaBeans 3.2 规范是在 JSR 345 下开发的。本节仅为您概述 API 的改进。完整的文档规范（更多信息）可以从 [http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html)
    下载。
- en: The business layer of an application is the part of the application that is
    located between the presentation layer and data access layer. The following diagram
    presents a simplified Java EE architecture. As you can see, the business layer
    acts as a bridge between the data access and the presentation layer.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的业务层位于表示层和数据访问层之间。以下图展示了简化的 Java EE 架构。正如您所看到的，业务层充当数据访问和表示层之间的桥梁。
- en: '![Enterprise JavaBeans 3.2](img/9235OT_05_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![企业 JavaBeans 3.2](img/9235OT_05_01.jpg)'
- en: It implements business logic of the application. To do so, it can use some specifications
    such as Bean Validation for data validation, CDI for context and dependency injection,
    interceptors to intercept processing, and so on. As this layer can be located
    anywhere in the network and is expected to serve more than one user, it needs
    a minimum of non functional services such as security, transaction, concurrency,
    and remote access management. With EJBs, the Java EE platform provides to developers
    the possibility to implement this layer without worrying about different non functional
    services that are necessarily required.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 它实现了应用程序的业务逻辑。为此，它可以使用一些规范，如 Bean Validation 用于数据验证，CDI 用于上下文和依赖注入，拦截器用于拦截处理等。由于此层可以位于网络中的任何位置，并且预期为多个用户服务，因此它需要最小限度的非功能性服务，如安全、事务、并发和远程访问管理。通过
    EJB，Java EE 平台为开发者提供了在不担心不同必需的非功能性服务的情况下实现此层的机会。
- en: In general, this specification does not initiate any new major feature. It continues
    the work started by the last version, making optional the implementation of certain
    features that became obsolete and adds slight modification to others.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，本规范不会引入任何新的主要功能。它继续上一版本开始的工作，将某些已过时的功能的实现变为可选，并对其他功能进行轻微修改。
- en: Pruning some features
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修剪一些功能
- en: 'After the pruning process introduced by Java EE 6 from the perspective of removing
    obsolete features, support for some features has been made optional in Java EE
    7 platform, and their description was moved to another document called *EJB 3.2
    Optional Features for Evaluation*. The features involved in this movement are:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java EE 6 引入的移除过时功能的修剪过程之后，Java EE 7 平台对某些功能的支持已变为可选，其描述已移至另一份名为 *EJB 3.2
    可选功能评估* 的文档中。涉及此迁移的功能包括：
- en: EJB 2.1 and earlier Entity Bean Component Contract for Container-Managed Persistence
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB 2.1 及更早版本实体 Bean 组件合约，用于容器管理持久性
- en: EJB 2.1 and earlier Entity Bean Component Contract for Bean-Managed Persistence
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB 2.1 及更早版本实体 Bean 组件合约，用于 Bean 管理持久性
- en: Client View of EJB 2.1 and earlier Entity Bean
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB 2.1 及更早版本实体 Bean 的客户端视图
- en: 'EJB QL: Query Language for Container-Managed Persistence Query Methods'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EJB QL：容器管理持久性查询方法的查询语言
- en: JAX-RPC-based Web Service Endpoints
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 JAX-RPC 的 Web 服务端点
- en: JAX-RPC Web Service Client View
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JAX-RPC Web 服务客户端视图
- en: The latest improvements in EJB 3.2
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EJB 3.2 的最新改进
- en: For those who have had to use EJB 3.0 and EJB 3.1, you will notice that EJB
    3.2 has brought, in fact, only minor changes to the specification. However, some
    improvements cannot be overlooked since they improve the testability of applications,
    simplify the development of session beans or Message-Driven Beans, and improve
    control over the management of the transaction and passivation of stateful beans.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些必须使用EJB 3.0和EJB 3.1的人来说，你会注意到EJB 3.2实际上只对规范进行了微小的修改。然而，一些改进不容忽视，因为它们提高了应用程序的可测试性，简化了会话bean或消息驱动bean的开发，并提高了对事务和有状态bean钝化管理控制的改进。
- en: Session bean enhancement
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话bean增强
- en: 'A session bean is a type of EJB that allows us to implement business logic
    accessible to local, remote, or Web Service Client View. There are three types
    of session beans: **stateless** for processing without states, **stateful** for
    processes that require the preservation of states between different calls of methods,
    and **singleton** for sharing a single instance of an object between different
    clients.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 会话bean是一种EJB类型，允许我们实现可被本地、远程或Web服务客户端视图访问的业务逻辑。会话bean有三种类型：**无状态**用于无状态处理，**有状态**用于需要在不同方法调用之间保持状态的过程，以及**单例**用于在不同客户端之间共享一个对象的单个实例。
- en: 'The following code shows an example of a stateless session bean to save an
    entity in the database:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了保存实体到数据库的无状态会话bean的示例：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Talking about improvements of session beans, we first note two changes in stateful
    session beans: the ability to execute life-cycle callback interceptor methods
    in a user-defined transaction context and the ability to manually disable passivation
    of stateful session beans.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论会话bean的改进时，我们首先注意到有状态会话bean中的两个变化：在用户定义的事务上下文中执行生命周期回调拦截器方法的能力，以及手动禁用有状态会话bean钝化的能力。
- en: 'It is possible to define a process that must be executed according to the lifecycle
    of an EJB bean (post-construct, pre-destroy). Due to the `@TransactionAttribute`
    annotation, you can perform processes related to the database during these phases
    and control how they impact your system. The following code retrieves an entity
    after being initialized and ensures that all changes made to the persistence context
    are sent to the database at the time of destruction of the bean. As you can see
    in the following code, `TransactionAttributeType` of `init()` method is `NOT_SUPPORTED`;
    this means that the retrieved entity will not be included in the persistence context
    and any changes made to it will not be saved in the database:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义一个必须根据EJB bean的生命周期（构造后、销毁前）执行的过程。由于`@TransactionAttribute`注解，你可以在这些阶段执行与数据库相关的过程，并控制它们对系统的影响。以下代码在初始化后检索一个实体，并确保在bean销毁时将持久上下文中所做的所有更改发送到数据库。正如你在以下代码中所看到的，`init()`方法的`TransactionAttributeType`是`NOT_SUPPORTED`；这意味着检索到的实体将不会包含在持久上下文中，对其所做的任何更改也不会保存到数据库中：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The following code demonstrates how to control passivation of the stateful bean.
    Usually, the session beans are removed from memory to be stored on the disk after
    a certain time of inactivity. This process requires data to be serialized, but
    during serialization all transient variables are skipped and restored to the default
    value of their data type, which is `null` for object, zero for `int`, and so on.
    To prevent the loss of this type of data, you can simply disable the passivation
    of stateful session beans by passing the `false` value to the `passivationCapable`
    attribute of the `@Stateful` annotation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何控制有状态bean的钝化。通常，在一段时间的不活跃后，会话bean会被从内存中移除并存储到磁盘上。这个过程需要数据序列化，但在序列化过程中，所有瞬态变量都会被跳过并恢复到其数据类型的默认值，对于对象来说是`null`，对于`int`来说是零等等。为了防止这种类型的数据丢失，你可以通过将`false`值传递给`@Stateful`注解的`passivationCapable`属性来简单地禁用有状态会话bean的钝化。
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For the sake of simplicity, EJB 3.2 has relaxed the rules to define the default
    local or remote business interface of a session bean. The following code shows
    how a simple interface can be considered as local or remote depending on the case:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，EJB 3.2放宽了定义会话bean默认本地或远程业务接口的规则。以下代码展示了如何根据情况将一个简单的接口视为本地或远程：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: EJB Lite improvements
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: EJB Lite改进
- en: Before EJB 3.1, the implementation of a Java EE application required the use
    of a full Java EE server with more than twenty specifications. This could be heavy
    enough for applications that only need some specification (as if you were asked
    to take a hammer to kill a fly). To adapt Java EE to this situation, JCP (Java
    Community Process) introduced the concept of profile and EJB Lite. Specifically,
    EJB Lite is a subset of EJBs, grouping essential capabilities for local transactional
    and secured processing. With this concept, it has become possible to make unit
    tests of an EJB application without using the Java EE server and it is also possible
    to use EJBs in web applications or Java SE effectively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在EJB 3.1之前，实现一个Java EE应用程序需要使用一个包含超过二十个规范的完整Java EE服务器。这对于只需要某些规范的应用程序来说可能过于沉重（就像有人要求你用锤子打死一只苍蝇一样）。为了适应这种情况，JCP（Java社区进程）引入了配置文件和EJB
    Lite的概念。具体来说，EJB Lite是EJB的一个子集，它将本地事务性和安全处理的基本功能分组在一起。有了这个概念，现在可以在不使用Java EE服务器的情况下对EJB应用程序进行单元测试，同时也使得在Web应用程序或Java
    SE中有效地使用EJB成为可能。
- en: 'In addition to the features already present in EJB 3.1, the EJB 3.2 Specification
    has added support for local asynchronous session bean invocations and non persistent
    EJB Timer Service. This enriches the embeddable `EJBContainer`, web profiles,
    and augments the number of testable features in an embeddable `EJBContainer`.
    The following code shows an EJB packaged in a WAR archive that contains two methods.
    The `asynchronousMethod()` is an asynchronous method that allows you to compare
    the time gap between the end of a method call on the client side and the end of
    execution of the method on the server side. The `nonPersistentEJBTimerService()`
    method demonstrates how to define a non persistent EJB Timer Service that will
    be executed every minute while the hour is one o''clock:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 除了EJB 3.1中已有的特性之外，EJB 3.2规范增加了对本地异步会话bean调用和非持久EJB定时服务的支持。这丰富了可嵌入的`EJBContainer`、Web配置文件，并增加了可测试的特性的数量。以下代码展示了包含两个方法的EJB打包在WAR存档中。`asynchronousMethod()`是一个异步方法，允许你比较客户端方法调用结束和服务器端方法执行结束之间的时间差。`nonPersistentEJBTimerService()`方法演示了如何定义一个每分钟执行一次的非持久EJB定时服务：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Changes made to the TimerService API
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对TimerService API所做的更改
- en: 'The EJB 3.2 Specification enhanced the `TimerService` API with a new method
    called `getAllTimers()`. This method gives you the ability to access all active
    timers in an EJB module. The following code demonstrates how to create different
    types of timers, access their information, and cancel them; it makes use of the
    `getAllTimers()` method:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: EJB 3.2规范通过一个名为`getAllTimers()`的新方法增强了`TimerService` API。此方法使你能够访问EJB模块中的所有活动定时器。以下代码演示了如何创建不同类型的定时器、访问它们的信息以及取消它们；它使用了`getAllTimers()`方法：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In addition to this method, the specification has removed the restrictions that
    required the use of `javax.ejb.Timer` and `javax.ejb.TimerHandlereferences` only
    inside a bean.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种方法之外，规范还移除了仅允许在bean内部使用`javax.ejb.Timer`和`javax.ejb.TimerHandlereferences`的限制。
- en: Harmonizing with JMS's novelties
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与JMS的新特性相协调
- en: 'A **Message-Driven Bean** (**MDB**) is a kind of a JMS Message listener allowing
    Java EE applications to process messages asynchronously. To define such a bean,
    simply decorate a simple POJO class with `@MessageDriven` annotation and make
    it implement the `javax.jms.MessageListener` interface. This interface makes available
    to the MDB the `onMessage` method that will be called each time a new message
    is posted in the queue associated with the bean. That''s why you have to put inside
    this method the business logic for the processing of incoming messages. The following
    code gives an example of an MDB that notifies you when a new message arrives by
    writing in the console:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息驱动Bean**（**MDB**）是一种JMS消息监听器，允许Java EE应用程序异步处理消息。要定义这样的bean，只需用`@MessageDriven`注解装饰一个简单的POJO类，并使其实现`javax.jms.MessageListener`接口。该接口使MDB可用`onMessage`方法，该方法将在与bean关联的队列中发布新消息时被调用。这就是为什么你必须在其中放置处理传入消息的业务逻辑。以下代码给出了一个MDB的示例，该示例通过在控制台写入来通知你新消息的到达：'
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Given the changes in JMS 2.0 Specification, the EJB 3.2 Specification has a
    revised list of JMS MDB activation properties to conform to the list of standard
    properties. These properties are: `destinationLookup`, `connectionFactoryLookup`,
    `clientId`, `subscriptionName`, and `shareSubscriptions`. In addition, it has
    added the ability in MDB to implement a no-method message listener, resulting
    in the exposure of all public methods of the bean as message listener methods.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JMS 2.0规范的变化，EJB 3.2规范对JMS MDB激活属性进行了修订，以符合标准属性的列表。这些属性包括：`destinationLookup`、`connectionFactoryLookup`、`clientId`、`subscriptionName`和`shareSubscriptions`。此外，它还在MDB中添加了实现无方法消息监听器的功能，从而将bean的所有公共方法暴露为消息监听器方法。
- en: Other improvements
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他改进
- en: 'As we said earlier, the EJB 3.1 Specification has given developers the opportunity
    to test EJB applications outside a full Java EE server. This was made possible
    through an embeddable `EJBContainer`. The following example demonstrates how to
    test an EJB using an embeddable `EJBContainer`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，EJB 3.1规范给了开发者机会在完整的Java EE服务器之外测试EJB应用程序。这是通过一个可嵌入的`EJBContainer`实现的。以下示例演示了如何使用可嵌入的`EJBContainer`测试EJB：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Since the embeddable `EJBContainer` reference by maven was not up-to-date while
    writing this book (which caused the error "`No EJBContainer provider available`"),
    I directly addressed the `glassfish-embedded-static-shell.jar` file in the following
    way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在编写本书时（这导致了错误“`没有可用的EJBContainer提供程序`”），maven引用的可嵌入`EJBContainer`没有更新，所以我直接以以下方式处理了`glassfish-embedded-static-shell.jar`文件：
- en: 'Maven variable declaration:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven变量声明：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Declaration of dependence:'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖声明：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'During operation, the embeddable `EJBContainer` acquires resources that would
    normally be released at the end of the process to allow other applications to
    take advantage of the maximum power of the machine. In the previous version of
    the specification, a developer used the `EJBContainer.close()` method in a `finally`
    block to perform this task. But, with the `try-with-resources` statement introduced
    in Java SE 7, EJB 3.2 added the implementation of the `java.lang.AutoCloseable`
    interface in the `EJBContainer` class to free the developer from a task that could
    easily be forgotten and have negative repercussions on the performance of a machine.
    Now, the embeddable `EJBContainer` will be automatically closed at the end of
    a statement, provided that it is declared as a resource in a `try-with-resources`
    statement. Thus, we no longer need a `finally` block like in the earlier example,
    which simplifies the code. The following example demonstrates how to take advantage
    of the `try-with-resources` statement while testing EJB with an embeddable `EJBContainer`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行过程中，可嵌入的`EJBContainer`会获取通常在进程结束时释放的资源，以便其他应用程序能够利用机器的最大功率。在规范的前一个版本中，开发者使用`EJBContainer.close()`方法在一个`finally`块中执行这个任务。但是，随着Java
    SE 7中引入的`try-with-resources`语句，EJB 3.2在`EJBContainer`类中添加了对`java.lang.AutoCloseable`接口的实现，以使开发者摆脱一个容易忘记的任务，并可能对机器的性能产生负面影响。现在，只要在`try-with-resources`语句中将可嵌入的`EJBContainer`声明为资源，它将在语句结束时自动关闭。因此，我们不再需要像早期示例中那样的`finally`块，这简化了代码。以下示例演示了如何在测试使用可嵌入的`EJBContainer`的EJB时利用`try-with-resources`语句：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The final improvement of this specification concerns removal of the restriction
    on obtaining the current class loader when you want to access files or directories
    in the file system from a bean.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 本规范的最终改进涉及取消当你想要从bean中访问文件系统中的文件或目录时获取当前类加载器的限制。
- en: Putting it all together
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: The example that will allow us to put together most of the APIs already studied
    since the first chapter, is an online preregistration site. In this example, we
    will not write any code. We limit ourselves to the presentation of an analysis
    of a problem that will help you understand how to use each of the pieces of code
    that are used to illustrate points in this book, in order to make a quality application
    based on the latest functionality of Java EE 7.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 将使我们能够将自第一章以来已经学习的大多数API整合在一起的例子是一个在线预注册网站。在这个例子中，我们不会编写任何代码。我们限制自己只对分析一个问题的展示，这个问题将帮助你理解如何使用本书中用于说明各点的每一块代码，以便基于Java
    EE 7的最新功能制作一个高质量的应用程序。
- en: Presenting the project
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 展示项目
- en: The virtual enterprise software technology has received from a private university
    the order for creating an application to manage the preregistration of students
    online (candidate registration, validation of applications, and notifications
    of different candidates) and provide a real-time chat room for connected students.
    Furthermore, for statistical purposes, the system will allow the ministry of education
    access to certain information from a heterogeneous application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟企业软件技术从一所私立大学获得了创建一个应用程序的订单，用于管理学生在线预注册（候选人注册、申请验证和不同候选人的通知），并为连接的学生提供一个实时聊天室。此外，出于统计目的，系统将允许教育部访问来自异构应用程序的某些信息。
- en: The system called `ONPRINS` must be robust, efficient, and available 24 x 7
    during periods of registration.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为 `ONPRINS` 的系统必须在注册期间稳健、高效，并且全天候可用。
- en: 'The business domain model in the following diagram represents the main objects
    of our system (the required application will be built based on these objects):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的业务领域模型表示了我们系统的主对象（所需的应用程序将基于这些对象构建）：
- en: '![Presenting the project](img/9235OT_05_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![展示项目](img/9235OT_05_02.jpg)'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Disclaimer**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**免责声明**'
- en: These diagrams have been designed and built in Enterprise Architect, by Sparx
    Systems.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图是由 Sparx Systems 在 Enterprise Architect 中设计和构建的。
- en: Use Case Diagram (UCD)
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例图 (UCD)
- en: 'The following diagram represents all the features that will be supported by
    our system. We have three actors as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表示了我们系统将支持的所有功能。我们有以下三个参与者：
- en: A Candidate is any user wishing to preregister for a department. To this end,
    it has the ability to view the list of departments, select a department, and complete
    and submit the application form. Through a chat room, he/she can share his/her
    ideas with all candidates connected with respect to a given theme.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 候选人是指任何希望为某个系进行预注册的用户。为此，它具有查看系列表、选择系以及完成和提交申请表的能力。通过聊天室，他/她可以与所有与给定主题相关的候选人分享他的/她的想法。
- en: An Administrator is a special user who has the right to run the validation process
    of preregistration. It is this process that creates the students and sends e-mails
    to different candidates to let them know whether they have been selected or not.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理员是一个特殊用户，他有权运行预注册的验证过程。正是这个过程创建了学生并向不同候选人发送电子邮件，让他们知道他们是否被选中。
- en: The Ministry of Education is a secondary actor of the system; it seeks access
    to the number of preregistered students and the list of students during an academic
    year.![Use Case Diagram (UCD)](img/9235OT_05_03.jpg)
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 教育部是系统的次要参与者；它寻求访问一个学年内预注册学生的数量和学生名单。![用例图 (UCD)](img/9235OT_05_03.jpg)
- en: Class diagram
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类图
- en: The following class diagram shows all the main classes used for the realization
    of our online preregistration. This diagram also highlights the relationships
    that exist between different classes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的类图显示了用于实现我们在线预注册的所有主要类。此图还突出了不同类之间存在的关系。
- en: The `CandidateSessionBean` class is a bean that records the preregistration
    of candidates through `registerCandidate` method. It also provides methods for
    accessing all the registered candidates (`listOfCandidates`) and preregistered
    students (`listOfStudents`).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`CandidateSessionBean` 类是一个通过 `registerCandidate` 方法记录候选人预注册的 bean。它还提供了访问所有已注册候选人（`listOfCandidates`）和预注册学生（`listOfStudents`）的方法。'
- en: The `InscriptionValidationBean` class contains the `startValidationBatchJob`
    method which, as its name suggests, launches batch processing to validate the
    preregistration and notify different candidates. Batch processing presented here
    is the chunk type in which the `ValidationReader` class is used to read the data
    useful for validation, the `ValidationProcessor` class is used to validate the
    preregistration, and the `ValidationWriter` class is used to notify the candidate.
    This class also serves to create a student when the candidate is selected. As
    you can see, in order to send an e-mail, the `ValidationWriter` class firstly
    sends a JMS message through `MsgSenderSessionBean` to the component responsible
    for sending the e-mail. This allows us to avoid blockages in `ValidationWriter`
    when there is a connection breakdown. Also, in the batch process, we have the
    listener `ValidationJobListener`, which enables us to record a certain amount
    of information in the validation table at the end of batch processing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`InscriptionValidationBean`类包含`startValidationBatchJob`方法，正如其名所示，它启动批量处理以验证预注册并通知不同候选人。这里展示的批量处理是块类型，其中`ValidationReader`类用于读取验证有用的数据，`ValidationProcessor`类用于验证预注册，`ValidationWriter`类用于通知候选人。此类还用于在候选人被选中时创建学生。正如你所见，为了发送电子邮件，`ValidationWriter`类首先通过`MsgSenderSessionBean`将JMS消息发送到负责发送电子邮件的组件。这使我们能够在连接中断时避免`ValidationWriter`中的阻塞。此外，在批量处理中，我们还有`ValidationJobListener`监听器，它使我们能够在批量处理结束时在验证表中记录一定量的信息。'
- en: For the sake of simplicity and reusability, navigation between web pages during
    the preregistration of a candidate (`departmentList.xhtml`, `acceptanceConditions.xhtml`,
    `identificationInformation.xhtml`, `contactInformation.xhtml`, `medicalInformation.xhtml`,
    `schoolInformation.xhtml`, and `InformationValidation.xhtml`) will be made using
    the Faces Flow. On the other hand, the content of various pages will be structured
    with the Resource Library Contracts and communication in the chat room will be
    managed using WebSocket; it is for this reason that you have the `ChatServerEndPoint`
    class, which is the server endpoint for this communication.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化重用性，候选人在预注册期间（`departmentList.xhtml`、`acceptanceConditions.xhtml`、`identificationInformation.xhtml`、`contactInformation.xhtml`、`medicalInformation.xhtml`、`schoolInformation.xhtml`和`InformationValidation.xhtml`）在网页间的导航将使用Faces
    Flow。另一方面，各个页面的内容将以资源库合同进行结构化，聊天室中的通信将通过WebSocket进行管理；这就是为什么你有`ChatServerEndPoint`类，它是这种通信的服务器端点。
- en: The execution of the validation process of preregistration is made from the
    `inscriptionValidation.xhtml` facelet. In order to give the administrator a feedback
    on the progress of the validation process, the facelet will contain a progress
    bar updated in real time, which leads us once again to use the WebSocket protocol.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 预注册验证过程的执行是从`inscriptionValidation.xhtml`面页进行的。为了给管理员提供验证过程进度的反馈，面页将包含实时更新的进度条，这又使我们再次使用WebSocket协议。
- en: '![Class diagram](img/9235OT_05_04.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![类图](img/9235OT_05_04.jpg)'
- en: Component diagram
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件图
- en: The following diagram shows the various components that constitute our system.
    As you can see, the exchange of data between the application of the ministry and
    `ONPRINS` will be through web services, which aims to make both systems completely
    independent from one another, while our system uses a connector to have access
    to user information stored on the ERP system of the university.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了构成我们系统的各种组件。正如你所见，部应用与`ONPRINS`之间的数据交换将通过Web服务进行，目的是使两个系统完全独立，而我们的系统使用连接器来访问存储在大学ERP系统上的用户信息。
- en: '![Component diagram](img/9235OT_05_05.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![组件图](img/9235OT_05_05.jpg)'
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'As promised, in this chapter we presented the innovations introduced by EJBs,
    and then focused on the analysis and design of an application for online preregistration.
    In this exercise, we were able to look at practical cases allowing us to use almost
    all of the concepts already discussed (WebSocket and Faces Flow) and discover
    new concepts (web service, connector, and Java e-mail). In the next chapter, we
    will focus on these new concepts in order to try to answer the following question:
    when and how should we implement these concepts?'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如承诺的那样，在本章中，我们介绍了 EJBs 引入的创新，然后专注于在线预注册应用程序的分析和设计。在这个练习中，我们能够查看实际案例，使我们能够使用已经讨论过的几乎所有概念（WebSocket
    和 Faces Flow）并发现新的概念（Web 服务、连接器和 Java 邮件）。在下一章中，我们将专注于这些新概念，以便尝试回答以下问题：何时以及如何实现这些概念？
