- en: Chapter 5. The Business Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here we will begin with a presentation of improvements in the business layer
    and then, in a small project, we will try to put together some of the specifications
    seen previously. The topics to be covered include:'
  prefs: []
  type: TYPE_NORMAL
- en: Enterprise JavaBeans 3.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting all Java EE 7 specifications together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise JavaBeans 3.2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Enterprise JavaBeans 3.2 Specification was developed under JSR 345\. This
    section just gives you an overview of improvements in the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr345/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: The business layer of an application is the part of the application that is
    located between the presentation layer and data access layer. The following diagram
    presents a simplified Java EE architecture. As you can see, the business layer
    acts as a bridge between the data access and the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: '![Enterprise JavaBeans 3.2](img/9235OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It implements business logic of the application. To do so, it can use some specifications
    such as Bean Validation for data validation, CDI for context and dependency injection,
    interceptors to intercept processing, and so on. As this layer can be located
    anywhere in the network and is expected to serve more than one user, it needs
    a minimum of non functional services such as security, transaction, concurrency,
    and remote access management. With EJBs, the Java EE platform provides to developers
    the possibility to implement this layer without worrying about different non functional
    services that are necessarily required.
  prefs: []
  type: TYPE_NORMAL
- en: In general, this specification does not initiate any new major feature. It continues
    the work started by the last version, making optional the implementation of certain
    features that became obsolete and adds slight modification to others.
  prefs: []
  type: TYPE_NORMAL
- en: Pruning some features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the pruning process introduced by Java EE 6 from the perspective of removing
    obsolete features, support for some features has been made optional in Java EE
    7 platform, and their description was moved to another document called *EJB 3.2
    Optional Features for Evaluation*. The features involved in this movement are:'
  prefs: []
  type: TYPE_NORMAL
- en: EJB 2.1 and earlier Entity Bean Component Contract for Container-Managed Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EJB 2.1 and earlier Entity Bean Component Contract for Bean-Managed Persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client View of EJB 2.1 and earlier Entity Bean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EJB QL: Query Language for Container-Managed Persistence Query Methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RPC-based Web Service Endpoints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JAX-RPC Web Service Client View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest improvements in EJB 3.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For those who have had to use EJB 3.0 and EJB 3.1, you will notice that EJB
    3.2 has brought, in fact, only minor changes to the specification. However, some
    improvements cannot be overlooked since they improve the testability of applications,
    simplify the development of session beans or Message-Driven Beans, and improve
    control over the management of the transaction and passivation of stateful beans.
  prefs: []
  type: TYPE_NORMAL
- en: Session bean enhancement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A session bean is a type of EJB that allows us to implement business logic
    accessible to local, remote, or Web Service Client View. There are three types
    of session beans: **stateless** for processing without states, **stateful** for
    processes that require the preservation of states between different calls of methods,
    and **singleton** for sharing a single instance of an object between different
    clients.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows an example of a stateless session bean to save an
    entity in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Talking about improvements of session beans, we first note two changes in stateful
    session beans: the ability to execute life-cycle callback interceptor methods
    in a user-defined transaction context and the ability to manually disable passivation
    of stateful session beans.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to define a process that must be executed according to the lifecycle
    of an EJB bean (post-construct, pre-destroy). Due to the `@TransactionAttribute`
    annotation, you can perform processes related to the database during these phases
    and control how they impact your system. The following code retrieves an entity
    after being initialized and ensures that all changes made to the persistence context
    are sent to the database at the time of destruction of the bean. As you can see
    in the following code, `TransactionAttributeType` of `init()` method is `NOT_SUPPORTED`;
    this means that the retrieved entity will not be included in the persistence context
    and any changes made to it will not be saved in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following code demonstrates how to control passivation of the stateful bean.
    Usually, the session beans are removed from memory to be stored on the disk after
    a certain time of inactivity. This process requires data to be serialized, but
    during serialization all transient variables are skipped and restored to the default
    value of their data type, which is `null` for object, zero for `int`, and so on.
    To prevent the loss of this type of data, you can simply disable the passivation
    of stateful session beans by passing the `false` value to the `passivationCapable`
    attribute of the `@Stateful` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'For the sake of simplicity, EJB 3.2 has relaxed the rules to define the default
    local or remote business interface of a session bean. The following code shows
    how a simple interface can be considered as local or remote depending on the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: EJB Lite improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before EJB 3.1, the implementation of a Java EE application required the use
    of a full Java EE server with more than twenty specifications. This could be heavy
    enough for applications that only need some specification (as if you were asked
    to take a hammer to kill a fly). To adapt Java EE to this situation, JCP (Java
    Community Process) introduced the concept of profile and EJB Lite. Specifically,
    EJB Lite is a subset of EJBs, grouping essential capabilities for local transactional
    and secured processing. With this concept, it has become possible to make unit
    tests of an EJB application without using the Java EE server and it is also possible
    to use EJBs in web applications or Java SE effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the features already present in EJB 3.1, the EJB 3.2 Specification
    has added support for local asynchronous session bean invocations and non persistent
    EJB Timer Service. This enriches the embeddable `EJBContainer`, web profiles,
    and augments the number of testable features in an embeddable `EJBContainer`.
    The following code shows an EJB packaged in a WAR archive that contains two methods.
    The `asynchronousMethod()` is an asynchronous method that allows you to compare
    the time gap between the end of a method call on the client side and the end of
    execution of the method on the server side. The `nonPersistentEJBTimerService()`
    method demonstrates how to define a non persistent EJB Timer Service that will
    be executed every minute while the hour is one o''clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Changes made to the TimerService API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The EJB 3.2 Specification enhanced the `TimerService` API with a new method
    called `getAllTimers()`. This method gives you the ability to access all active
    timers in an EJB module. The following code demonstrates how to create different
    types of timers, access their information, and cancel them; it makes use of the
    `getAllTimers()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this method, the specification has removed the restrictions that
    required the use of `javax.ejb.Timer` and `javax.ejb.TimerHandlereferences` only
    inside a bean.
  prefs: []
  type: TYPE_NORMAL
- en: Harmonizing with JMS's novelties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **Message-Driven Bean** (**MDB**) is a kind of a JMS Message listener allowing
    Java EE applications to process messages asynchronously. To define such a bean,
    simply decorate a simple POJO class with `@MessageDriven` annotation and make
    it implement the `javax.jms.MessageListener` interface. This interface makes available
    to the MDB the `onMessage` method that will be called each time a new message
    is posted in the queue associated with the bean. That''s why you have to put inside
    this method the business logic for the processing of incoming messages. The following
    code gives an example of an MDB that notifies you when a new message arrives by
    writing in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Given the changes in JMS 2.0 Specification, the EJB 3.2 Specification has a
    revised list of JMS MDB activation properties to conform to the list of standard
    properties. These properties are: `destinationLookup`, `connectionFactoryLookup`,
    `clientId`, `subscriptionName`, and `shareSubscriptions`. In addition, it has
    added the ability in MDB to implement a no-method message listener, resulting
    in the exposure of all public methods of the bean as message listener methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Other improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we said earlier, the EJB 3.1 Specification has given developers the opportunity
    to test EJB applications outside a full Java EE server. This was made possible
    through an embeddable `EJBContainer`. The following example demonstrates how to
    test an EJB using an embeddable `EJBContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the embeddable `EJBContainer` reference by maven was not up-to-date while
    writing this book (which caused the error "`No EJBContainer provider available`"),
    I directly addressed the `glassfish-embedded-static-shell.jar` file in the following
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Maven variable declaration:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declaration of dependence:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'During operation, the embeddable `EJBContainer` acquires resources that would
    normally be released at the end of the process to allow other applications to
    take advantage of the maximum power of the machine. In the previous version of
    the specification, a developer used the `EJBContainer.close()` method in a `finally`
    block to perform this task. But, with the `try-with-resources` statement introduced
    in Java SE 7, EJB 3.2 added the implementation of the `java.lang.AutoCloseable`
    interface in the `EJBContainer` class to free the developer from a task that could
    easily be forgotten and have negative repercussions on the performance of a machine.
    Now, the embeddable `EJBContainer` will be automatically closed at the end of
    a statement, provided that it is declared as a resource in a `try-with-resources`
    statement. Thus, we no longer need a `finally` block like in the earlier example,
    which simplifies the code. The following example demonstrates how to take advantage
    of the `try-with-resources` statement while testing EJB with an embeddable `EJBContainer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The final improvement of this specification concerns removal of the restriction
    on obtaining the current class loader when you want to access files or directories
    in the file system from a bean.
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example that will allow us to put together most of the APIs already studied
    since the first chapter, is an online preregistration site. In this example, we
    will not write any code. We limit ourselves to the presentation of an analysis
    of a problem that will help you understand how to use each of the pieces of code
    that are used to illustrate points in this book, in order to make a quality application
    based on the latest functionality of Java EE 7.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting the project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The virtual enterprise software technology has received from a private university
    the order for creating an application to manage the preregistration of students
    online (candidate registration, validation of applications, and notifications
    of different candidates) and provide a real-time chat room for connected students.
    Furthermore, for statistical purposes, the system will allow the ministry of education
    access to certain information from a heterogeneous application.
  prefs: []
  type: TYPE_NORMAL
- en: The system called `ONPRINS` must be robust, efficient, and available 24 x 7
    during periods of registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The business domain model in the following diagram represents the main objects
    of our system (the required application will be built based on these objects):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the project](img/9235OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Disclaimer**'
  prefs: []
  type: TYPE_NORMAL
- en: These diagrams have been designed and built in Enterprise Architect, by Sparx
    Systems.
  prefs: []
  type: TYPE_NORMAL
- en: Use Case Diagram (UCD)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram represents all the features that will be supported by
    our system. We have three actors as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A Candidate is any user wishing to preregister for a department. To this end,
    it has the ability to view the list of departments, select a department, and complete
    and submit the application form. Through a chat room, he/she can share his/her
    ideas with all candidates connected with respect to a given theme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Administrator is a special user who has the right to run the validation process
    of preregistration. It is this process that creates the students and sends e-mails
    to different candidates to let them know whether they have been selected or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ministry of Education is a secondary actor of the system; it seeks access
    to the number of preregistered students and the list of students during an academic
    year.![Use Case Diagram (UCD)](img/9235OT_05_03.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following class diagram shows all the main classes used for the realization
    of our online preregistration. This diagram also highlights the relationships
    that exist between different classes.
  prefs: []
  type: TYPE_NORMAL
- en: The `CandidateSessionBean` class is a bean that records the preregistration
    of candidates through `registerCandidate` method. It also provides methods for
    accessing all the registered candidates (`listOfCandidates`) and preregistered
    students (`listOfStudents`).
  prefs: []
  type: TYPE_NORMAL
- en: The `InscriptionValidationBean` class contains the `startValidationBatchJob`
    method which, as its name suggests, launches batch processing to validate the
    preregistration and notify different candidates. Batch processing presented here
    is the chunk type in which the `ValidationReader` class is used to read the data
    useful for validation, the `ValidationProcessor` class is used to validate the
    preregistration, and the `ValidationWriter` class is used to notify the candidate.
    This class also serves to create a student when the candidate is selected. As
    you can see, in order to send an e-mail, the `ValidationWriter` class firstly
    sends a JMS message through `MsgSenderSessionBean` to the component responsible
    for sending the e-mail. This allows us to avoid blockages in `ValidationWriter`
    when there is a connection breakdown. Also, in the batch process, we have the
    listener `ValidationJobListener`, which enables us to record a certain amount
    of information in the validation table at the end of batch processing.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity and reusability, navigation between web pages during
    the preregistration of a candidate (`departmentList.xhtml`, `acceptanceConditions.xhtml`,
    `identificationInformation.xhtml`, `contactInformation.xhtml`, `medicalInformation.xhtml`,
    `schoolInformation.xhtml`, and `InformationValidation.xhtml`) will be made using
    the Faces Flow. On the other hand, the content of various pages will be structured
    with the Resource Library Contracts and communication in the chat room will be
    managed using WebSocket; it is for this reason that you have the `ChatServerEndPoint`
    class, which is the server endpoint for this communication.
  prefs: []
  type: TYPE_NORMAL
- en: The execution of the validation process of preregistration is made from the
    `inscriptionValidation.xhtml` facelet. In order to give the administrator a feedback
    on the progress of the validation process, the facelet will contain a progress
    bar updated in real time, which leads us once again to use the WebSocket protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '![Class diagram](img/9235OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Component diagram
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following diagram shows the various components that constitute our system.
    As you can see, the exchange of data between the application of the ministry and
    `ONPRINS` will be through web services, which aims to make both systems completely
    independent from one another, while our system uses a connector to have access
    to user information stored on the ERP system of the university.
  prefs: []
  type: TYPE_NORMAL
- en: '![Component diagram](img/9235OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As promised, in this chapter we presented the innovations introduced by EJBs,
    and then focused on the analysis and design of an application for online preregistration.
    In this exercise, we were able to look at practical cases allowing us to use almost
    all of the concepts already discussed (WebSocket and Faces Flow) and discover
    new concepts (web service, connector, and Java e-mail). In the next chapter, we
    will focus on these new concepts in order to try to answer the following question:
    when and how should we implement these concepts?'
  prefs: []
  type: TYPE_NORMAL
