<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer230">
<h1 class="chapter-number" id="_idParaDest-156"><a id="_idTextAnchor157"/>10</h1>
<h1 id="_idParaDest-157"><a id="_idTextAnchor158"/>Federated and Scalable DaaS with GraphQL</h1>
<p>In the previous chapter, we discussed how to publish ingested data in a format that is platform- and language-agnostic using the REST API. We also learned how to design and develop a <strong class="bold">Data as a Service</strong> (<strong class="bold">DaaS</strong>) layer using the REST API, as well as how to containerize and deploy the application on AWS ECS. Then, we learned what an API management system is and how it can help monitor and manage APIs more efficiently. Finally, we learned how to create an API management layer on top of our REST DaaS application using Amazon API Gateway.</p>
<p>In this chapter, we will learn how to implement DaaS using GraphQL instead of REST. To do so, we will learn what GraphQL is, and why and when it should be used. We will explore the benefits and shortcomings that GraphQL has concerning REST while discussing the various architectural patterns available for GraphQL-based solutions. Finally, we will learn about the power of federation in the GraphQL layer. By the end of this chapter, you should know about the basic concepts surrounding GraphQL and when to use this tool in data engineering solutions. You will also know how to design, implement, and test a GraphQL solution.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Introducing GraphQL – what, when, and why</li>
<li>Core architectural patterns of GraphQL </li>
<li>A practical use case – exposing federated data models using GraphQL</li>
</ul>
<h1 id="_idParaDest-158"><a id="_idTextAnchor159"/>Technical requirements</h1>
<p>For this chapter, you will need the following:</p>
<ul>
<li>Prior knowledge of Java</li>
<li>OpenJDK-1.11 installed on your local system</li>
<li>Maven installed on your local system</li>
<li>GraphQL Playground installed on your local system</li>
<li>IntelliJ Idea community or ultimate edition installed on your local system</li>
</ul>
<p>The code for this chapter can be downloaded from this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10">https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter10</a>.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor160"/>Introducing GraphQL – what, when, and why </h1>
<p>In this section, we <a id="_idIndexMarker1072"/>will explore what GraphQL is. According to <a href="http://graphql.org">graphql.org</a>, the <a id="_idIndexMarker1073"/>official definition of GraphQL is that “<em class="italic">GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data.</em>” Let’s dive a bit deeper to understand GraphQL. </p>
<p><strong class="bold">Representational State Transfer</strong> (<strong class="bold">REST</strong>) has been the standard way of publishing data across <a id="_idIndexMarker1074"/>systems, which is platform, device, and tool/language-agnostic. However, there are two major bottlenecks with REST:</p>
<ul>
<li>For fetching different related entities, we need multiple REST requests. We must also be mindful of different versions of the API. Having different endpoints and their versions for each entity of functionality is a maintenance headache.</li>
<li>The request and response parameters are always fixed in REST. For example, there is a REST API that returns 100 fields. Suppose there is a consumer who only needs 10 fields. However, since responses are fixed, a REST request will always calculate and send all 100 fields. This, in turn, affects performance as it takes more time to form the response, as well as consumes more bandwidth to transfer a bigger payload.</li>
</ul>
<p>GraphQL is the answer to overcome these challenges. GraphQL is an open standard or specification created by Facebook. It is a query language for APIs, where the client can query multiple entities and the desired fields from those entities while making the GraphQL request. The following diagram describes how GraphQL operates:</p>
<div>
<div class="IMG---Figure" id="_idContainer215">
<img alt="Figure 10.1 – How GraphQL operates " height="424" src="image/B17084_10_001.jpg" width="1260"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – How GraphQL operates</p>
<p>As shown in the preceding diagram, in GraphQL, it is the GraphQL client that defines what data it needs, while the GraphQL server publishes what data is available. So, essentially, GraphQL is a declarative way of fetching and updating data over APIs. </p>
<p>Let’s try to understand this with an example. Since GraphQL was created by Facebook, we will take an example from a social networking use case. Let’s suppose that we want to fetch users, their posts, and the comments related to that post. The following diagram shows <a id="_idIndexMarker1075"/>how this can be designed using REST:</p>
<div>
<div class="IMG---Figure" id="_idContainer216">
<img alt="Figure 10.2 – A REST-based design requires three separate endpoints " height="207" src="image/B17084_10_002.jpg" width="541"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.2 – A REST-based design requires three separate endpoints</p>
<p>As we can see, REST will have three endpoints – one for users, one for posts, and one for comments. To fetch a user’s posts and comments on those posts, REST will require one call for users, one call for the posts, and one call per post for the comments. This is shown in the following<a id="_idIndexMarker1076"/> diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer217">
<img alt="Figure 10.3 – Three separate calls are needed when using REST " height="843" src="image/B17084_10_003.jpg" width="791"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.3 – Three separate calls are needed when using REST</p>
<p>As we can see, there are at least three REST calls (provided that the user has only one post) required for this use case to fetch data. Think of the number of calls required for a real user on a social platform. If the user has posted <em class="italic">n</em> number of posts, then the number of calls required to fetch this information will be <em class="italic">n+2</em>. That would seriously affect the UI experience and the performance of the website. However, in GraphQL, it only takes one call to fetch this information. The following diagram shows what a GraphQL request would look like:</p>
<div>
<div class="IMG---Figure" id="_idContainer218">
<img alt="Figure 10.4 – A single GraphQL call can fetch all the required data " height="618" src="image/B17084_10_004.jpg" width="1336"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.4 – A single GraphQL call can fetch all the required data</p>
<p>As you can see, the<a id="_idIndexMarker1077"/> request payload of GraphQL declares the entities and fields that it needs to fetch. Therefore, the GraphQL client determines what data it needs.</p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>Operation types</h2>
<p>Now that we<a id="_idIndexMarker1078"/> understand what GraphQL is, let’s try to understand the various types of operations that GraphQL supports, as follows:</p>
<ul>
<li><strong class="bold">Queries</strong>: These help query the API and only support data read operations. A sample query is as follows:<p class="source-code">query myquery{</p><p class="source-code">  byApplicationId(applicationId:"CT20210809"){</p><p class="source-code">    applicationId</p><p class="source-code">    id</p><p class="source-code">    riskScore</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ul>
<p>As shown in the preceding payload, you can optionally use a keyword query followed by the name that you want to assign to the query (here, it is <strong class="source-inline">myquery</strong>). <strong class="source-inline">byApplicationId</strong> is a query in GraphQL (like an endpoint in REST) that takes request arguments as parameters. Here, the <strong class="source-inline">byApplicationId</strong> query takes an argument called <strong class="source-inline">applicationId</strong>. Also, as you can see, the request contains the names of the fields that it wants to have returned, such as <strong class="source-inline">applicationId</strong>, <strong class="source-inline">id</strong>, and <strong class="source-inline">riskscore</strong>.</p>
<ul>
<li><strong class="bold">Mutations</strong>: Mutations<a id="_idIndexMarker1079"/> support both read and write operations. A sample query is as follows:<p class="source-code">  mutation updateApplicationMutation { updateApplication(status:"closed") { </p><p class="source-code">applicationId</p><p class="source-code">custId</p><p class="source-code">status</p><p class="source-code">} </p><p class="source-code">} </p></li>
</ul>
<p>As shown in the preceding code, a mutation can be labeled with a mutation name using the <strong class="source-inline">mutation</strong> keyword. Here, it updates the application status in the database. So, it is used to write data.</p>
<ul>
<li><strong class="bold">Subscriptions</strong>: In addition to queries and mutations, GraphQL also supports subscriptions. Like queries, they are used to fetch data, but they use long-lasting connections, which can change their result over time. This enables an event notification pattern, by which the server can push changes to the client. The following code shows what a subscription query looks like:<p class="source-code"> type subscription{</p><p class="source-code">   commentsforPost(postId: "123ty4567"){</p><p class="source-code">   commentId</p><p class="source-code">   text</p><p class="source-code">  ...</p><p class="source-code">  }</p><p class="source-code">}</p></li>
</ul>
<p>Here, we are subscribing to the comments written for the post with a <strong class="source-inline">postId</strong>. Hence, a long-lasting connection is established between the client and the GraphQL server. The GraphQL server pushes any changes that are made on the comments to the client automatically.</p>
<p>Now, let’s discuss the GraphQL schema. A GraphQL schema is a contract between the client and the server. It declares what operations and fields are available in GraphQL. It is strongly typed and is written using a standard <strong class="bold">Schema Definition Language</strong> (<strong class="bold">SDL</strong>). The<a id="_idIndexMarker1080"/> following<a id="_idIndexMarker1081"/> code block shows an example of a GraphQL schema:</p>
<pre class="source-code">type Application {
  applicationId: ID!
  id: String!
  genderCode: String
  cars: [String]
 ...
}</pre>
<p>In the preceding code block, the <strong class="source-inline">applicationId</strong> field is of the <strong class="source-inline">ID</strong> data type, <strong class="source-inline">genderCode</strong> is of the <strong class="source-inline">String</strong> data type. and so on. In SDL, data types of GraphQL schemas are also known as scalars; the inbuilt data types are denoted as inbuilt scalars and customized data types are referred to as custom scalars. The exclamation mark after <strong class="source-inline">ID</strong> while defining <strong class="source-inline">applicationId</strong> denotes that it is a mandatory field. Similarly, <strong class="source-inline">cars</strong> is defined as a list since its data type is wrapped with <strong class="source-inline">[]</strong> (square brackets).</p>
<p>Now that we have internalized the basic concepts of GraphQL, we will explore why and when to use<a id="_idIndexMarker1082"/> GraphQL.</p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor162"/>Why use GraphQL?</h2>
<p>In this section, we will <a id="_idIndexMarker1083"/>explore the various benefits of GraphQL that make it a great solution. The advantages of GraphQL are as follows:</p>
<ul>
<li><strong class="bold">Strongly typed schema for a platform-independent API</strong>: Usually, in the SOAP and REST APIs, our<a id="_idIndexMarker1084"/> response is a platform-independent structure such as XML or JSON. However, neither of these formats is strongly typed. In GraphQL, each field in a schema must have a scalar type (it can either be an inbuilt scalar type or a customized one). This ensures GraphQL is less error-prone, more validated, and provides easy auto-completion capabilities for editors such as GraphQL Playground. The following screenshot shows the auto-completion suggestion provided by GraphQL Playground:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer219">
<img alt="Figure 10.5 – Auto-completion feature in GraphQL Playground " height="719" src="image/B17084_10_005.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.5 – Auto-completion feature in GraphQL Playground</p>
<ul>
<li><strong class="bold">No over-fetching or under-fetching</strong>: In GraphQL, the client can only fetch the data that it requires. For example, if a GraphQL API supports hundreds of fields in its API response, the client doesn’t need to fetch all those fields. If a client only needs 10 fields, the client can request the GraphQL API to send only those fields. However, if the same API is written in REST, even though the client requires only 10 fields, the response will return all the fields. </li>
</ul>
<p>Over-fetching is a common problem in REST, where, irrespective of the number of fields a client requires, it always fetches all the fields defined in the response body. For example, for a social networking site such as LinkedIn, a person’s profile contains a huge number of columns, including demographic columns, skill set columns, awards and certification columns, and so on. A REST-based solution to solve this problem can be designed in two ways:</p>
<ul>
<li><strong class="bold">Create a single API with all columns</strong>: If we use this approach, a client requiring only demographic information will encounter an over-fetching problem.</li>
<li><strong class="bold">Create separate APIs for demographics, skill sets, awards and certifications, and so on</strong>: Let’s look at a scenario where the client needs all the<a id="_idIndexMarker1085"/> information available. Multiple calls are required to fetch the data if we use this approach. This leads to under-fetching.</li>
</ul>
<p>So, we need a single solution that can solve these issues for both types of client requests. GraphQL solves this problem by allowing the client to choose which fields it wants to fetch.</p>
<ul>
<li><strong class="bold">Saves time and bandwidth</strong>: GraphQL allows you to make multiple resource requests in a single GraphQL call, which saves a lot of time and bandwidth by reducing the number of network round trips to the GraphQL server. This is especially useful for improving the user experience and speed of fetching data on a client application.</li>
<li><strong class="bold">No need for versioning</strong>: In REST, when adding a new field or deleting an old field, this needs to be published as a new version to support consumer compatibility. With GraphQL, versioning is no longer required – one, because GraphQL supports partial data fetching from the response structure, and two, it supports publishing depreciation warnings to a depreciated field for the GraphQL client.</li>
<li><strong class="bold">Schema stitching or combining multiple GraphQL schema</strong>: GraphQL provides multiple ways to combine different GraphQL schemas and APIs into a single endpoint without much coding or implementation hassle. This feature helps develop a single, centralized GraphQL gateway. A GraphQL gateway enables multiple GraphQL APIs to be consumed from a single endpoint. It also enables the dynamic addition of newer GraphQL APIs in the future seamlessly. This makes GraphQL <a id="_idIndexMarker1086"/>federated and scalable. Combining schemas can be achieved by technologies such as Apollo GraphQL Federation and Atlassian GraphQL Braids.</li>
</ul>
<p>Now, let’s see when we should use GraphQL.</p>
<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>When to use GraphQL</h2>
<p>The following are a<a id="_idIndexMarker1087"/> few scenarios where the GraphQL API is a better solution than the REST API:</p>
<ul>
<li>Apps where bandwidth usage matters, such as mobile apps or IoT device apps.</li>
<li>Applications where there is a need for nested data to be fetched. GraphQL saves a lot of time and bandwidth, thus enabling better performance for GraphQL clients.</li>
<li>Applications that publish DaaS. Here, this DaaS is consumed by multiple downstream teams with different data fetch requirements.</li>
<li>When enabling GraphQL capabilities such as partial data fetching of the response and exposing a single endpoint by composing multiple APIs to improve the consumer experience for legacy REST-based applications.</li>
</ul>
<p>In this section, we learned what GraphQL is and looked at typical use cases when GraphQL is used. In the next section, we will discuss the most popular GraphQL patterns that are used in<a id="_idIndexMarker1088"/> the industry.</p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor164"/>Core architectural patterns of GraphQL</h1>
<p>In this section, we<a id="_idIndexMarker1089"/> will discuss the various architectural patterns that are used for GraphQL. These patterns are independent of the technology used to implement it or the platform where it is deployed and executed. There are five different GraphQL patterns, as follows:</p>
<ul>
<li><strong class="bold">DaaS pattern</strong>: Here, GraphQL <a id="_idIndexMarker1090"/>server is used to expose the<a id="_idIndexMarker1091"/> database layer. It can expose three operations – queries, mutations, and subscriptions (please refer to the <em class="italic">Operation types</em> section of this chapter). Using these operations, it can<a id="_idIndexMarker1092"/> achieve <strong class="bold">Create, Read, Update and Delete</strong> (<strong class="bold">CRUD</strong>) operations like REST but also supports subscriptions on top of it. The following diagram shows this pattern:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer220">
<img alt="Figure 10.6 – DaaS pattern " height="481" src="image/B17084_10_006.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.6 – DaaS pattern</p>
<p>As we can see, GraphQL exposes its queries and operations using the HTTP protocol. GraphQL provides server libraries in multiple languages, using which teams can build and run GraphQL Server applications. Also, GraphQL supports a variety of GraphQL<a id="_idIndexMarker1093"/> client libraries in different languages. A list<a id="_idIndexMarker1094"/> of supported languages is available at <a href="https://graphql.org/code/">https://graphql.org/code/</a>.</p>
<ul>
<li><strong class="bold">Integration layer pattern</strong>: Here, GraphQL<a id="_idIndexMarker1095"/> Server <a id="_idIndexMarker1096"/>caters to data to provide access to multiple data sources in one go. This enables GraphQL to act like a data integration hub. The following diagram depicts how the integration layer pattern works:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer221">
<img alt="Figure 10.7 – Integration layer pattern " height="494" src="image/B17084_10_007.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.7 – Integration layer pattern</p>
<p>As we can see, GraphQL<a id="_idIndexMarker1097"/> server is acting as an integration hub. It enables clients to make a single call, but the GraphQL server is fetching that data from different ecosystems such as microservices, legacy apps, and cloud APIs and sending a unified response to the client. This automatically reduces the complexity and number of calls that a GraphQL client must make.</p>
<ul>
<li><strong class="bold">Hybrid pattern</strong>: The third <a id="_idIndexMarker1098"/>GraphQL pattern is called the<a id="_idIndexMarker1099"/> hybrid pattern because it explores a hybrid approach to the first two patterns. Here, GraphQL Server not only needs to be connected to microservices legacy systems, but also databases. The following diagram shows this pattern:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer222">
<img alt="Figure 10.8 – Hybrid pattern " height="719" src="image/B17084_10_008.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.8 – Hybrid pattern</p>
<p>As we can see, GraphQL Server has its own database apart from the connections to different apps such<a id="_idIndexMarker1100"/> as microservices and <a id="_idIndexMarker1101"/>legacy<a id="_idIndexMarker1102"/> systems. Therefore, GraphQL provides unified access to its client for different kinds of data sources when this pattern is used.</p>
<ul>
<li><strong class="bold">GraphQL with managed API</strong>: To expose GraphQL APIs in an enterprise, it is necessary<a id="_idIndexMarker1103"/> to have security and monitoring enabled. In this pattern, API Gateway provides monitoring, security, and throttling on GraphQL Server. The following diagram shows this pattern:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer223">
<img alt="Figure 10.9 – GraphQL with managed API " height="676" src="image/B17084_10_009.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.9 – GraphQL with managed API</p>
<ul>
<li><strong class="bold">Federated GraphQL pattern</strong>: Here, a<a id="_idIndexMarker1104"/> centralized<a id="_idIndexMarker1105"/> GraphQL braid or federated GraphQL server<a id="_idIndexMarker1106"/> is created. Other GraphQL nodes are connected to this GraphQL braid. Each of these nodes, in turn, fetches data from either a database, micro-service, or legacy app. The following diagram shows the federated GraphQL pattern:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer224">
<img alt="Figure 10.10 – Federated GraphQL pattern " height="1503" src="image/B17084_10_010.jpg" width="1538"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.10 – Federated GraphQL pattern</p>
<p>The real<a id="_idIndexMarker1107"/> power<a id="_idIndexMarker1108"/> of<a id="_idIndexMarker1109"/> this pattern is its amazing scalability and data federation. Newer nodes can be seamlessly added at any time to the GraphQL braid, without any application downtime.</p>
<p>In this section, we learned about the various core GraphQL patterns, how they operate, and when they are<a id="_idIndexMarker1110"/> useful. In the next section, we will learn how to develop a GraphQL server application.</p>
<h1 id="_idParaDest-164"><a id="_idTextAnchor165"/>A practical use case – exposing federated data models using GraphQL</h1>
<p>In this <a id="_idIndexMarker1111"/>section, we will learn how to develop DaaS <a id="_idIndexMarker1112"/>using GraphQL in Java. To implement the solution, we will publish the same set of APIs that we published earlier using REST, but this time, we will implement the solution using GraphQL.</p>
<p>Before we start implementing GraphQL, it is important to design the GraphQL schema for our use case. In our use case, we need to read credit card applications from MongoDB using either the application ID or consumer ID. This was why we needed two separate endpoints in the REST-based solution (please refer to <a href="B17084_09.xhtml#_idTextAnchor144"><em class="italic">Chapter 9</em></a>, <em class="italic">Exposing MongoDB Data as a Service</em>, for the REST-based DaaS solution). </p>
<p>Let’s analyze the requirements from a different perspective – that is, while considering the GraphQL-based solution. The biggest difference that GraphQL makes is that it reduces the number of endpoints, as well as the number of calls. So, for our use case, we will have a single endpoint. Also, according to our use case, we are only interested in fetching data. Hence, we will only be using the <strong class="source-inline">Query</strong> type of operation. To support multiple functionalities in GraphQL, we must have multiple such fields in the query that can take arguments such as the following:</p>
<pre class="source-code">type Query{
    customerById(id: String):Customer
    customerByName(firstname: String, lastName: String): [Customers]
}</pre>
<p>In our case, we need two such fields – <strong class="source-inline">byApplicationId</strong> and <strong class="source-inline">byCustomerId</strong> – both of which should return a custom type called <strong class="source-inline">Application</strong>. The following code snippet shows part of our GraphQL schema:</p>
<pre class="source-code">type Query{
    byApplicationId(applicationId: ID):Application
    byCustomerId(custId: String):[Application]
}</pre>
<p>As shown in the preceding code block, <strong class="source-inline">byApplicationId</strong> always returns only one <strong class="source-inline">Application</strong>, as <strong class="source-inline">applicationId</strong> is a primary key. Therefore, <strong class="source-inline">byApplicationId</strong> is of the <strong class="source-inline">Application</strong> type. However, since there can be multiple applications for the same customer, <strong class="source-inline">byCustomerId</strong> is of the <strong class="source-inline">[Application]</strong> type, which denotes a list of <strong class="source-inline">Application</strong>. Now, let’s define the type – <strong class="source-inline">Application</strong> – in the<a id="_idIndexMarker1113"/> GraphQL schema. The<a id="_idIndexMarker1114"/> following code block shows the SDL for the <strong class="source-inline">Application</strong> type:</p>
<pre class="source-code">type Application {
    applicationId: ID!
    id: String!
    genderCode: String
    flagOwnCar: String
    flagOwnRealty: String
    cntChildren: Int
    amtIncomeTotal: Float
    nameIncomeType: String
    nameEducationType: String
    nameFamilyStatus: String
    nameHousingType: String
...
}</pre>
<p>Here, in the SDL for the <strong class="source-inline">Application</strong> type, <strong class="source-inline">applicationId</strong> is of the <strong class="source-inline">ID</strong> type, which denotes that it is the unique key for the <strong class="source-inline">Application</strong> type. Also, the exclamation mark (<strong class="source-inline">!</strong>) seen in the <strong class="source-inline">applicationId</strong> and <strong class="source-inline">id</strong> fields denotes that those fields are non-nullable. The complete schema is available at <a href="https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls">https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/blob/main/Chapter10/sourcecode/GraphQLDaas/src/main/resources/schema.graphqls</a>.</p>
<p>To create a Spring Boot Maven project and add the required Maven dependencies, the following <a id="_idIndexMarker1115"/>Maven<a id="_idIndexMarker1116"/> dependencies should be added in the <strong class="source-inline">pom.xml</strong> file:</p>
<pre class="source-code">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
<p>Apart from this, the following dependencies should be added to support MongoDB-related dependencies, as well as QueryDSL-related dependencies, in the Spring Boot application:</p>
<pre class="source-code">&lt;!-- mongoDB dependencies --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- Add support for Mongo Query DSL --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.querydsl&lt;/groupId&gt;
    &lt;artifactId&gt;querydsl-mongodb&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.querydsl&lt;/groupId&gt;
    &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
<p>Apart from these dependencies, we need to add build-plugins in the <strong class="source-inline">pom.xml</strong> file. These plugins help generate Q classes dynamically, which are required for QueryDSL to work properly. The<a id="_idIndexMarker1117"/> following plugins need to be<a id="_idIndexMarker1118"/> added:</p>
<pre class="source-code">&lt;plugin&gt;
    &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;
    &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;1.1.3&lt;/version&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.querydsl&lt;/groupId&gt;
            &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;
            &lt;version&gt;5.0.0&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;phase&gt;generate-sources&lt;/phase&gt;
            &lt;goals&gt;
                &lt;goal&gt;process&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;configuration&gt;
                &lt;outputDirectory&gt;target/generated-sources/apt&lt;/outputDirectory&gt;
                &lt;processor&gt;org.springframework.data.mongodb.repository.support.MongoAnnotationProcessor&lt;/processor&gt;
                &lt;logOnlyOnError&gt;false&lt;/logOnlyOnError&gt;
            &lt;/configuration&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
&lt;/plugin&gt;</pre>
<p>GraphQL-related dependencies also need to be added to the POM file of the project. The following GraphQL dependencies need to be added:</p>
<pre class="source-code">&lt;!-- GraphQL dependencies --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;
    &lt;artifactId&gt;graphql-java&lt;/artifactId&gt;
    &lt;version&gt;11.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.graphql-java&lt;/groupId&gt;
    &lt;artifactId&gt;graphql-java-spring-boot-starter-webmvc&lt;/artifactId&gt;
    &lt;version&gt;1.0&lt;/version&gt;
&lt;/dependency&gt;</pre>
<p>As shown in the<a id="_idIndexMarker1119"/> preceding<a id="_idIndexMarker1120"/> code block, to implement GraphQL server in Java, we need to import the <strong class="source-inline">graphql-java</strong> dependencies and the Spring Boot starter for GraphQL JAR file called <strong class="source-inline">graphql-java-spring-boot-starter-webmvc</strong>.</p>
<p>Now that we have added all the necessary dependencies, we will create the entry point, or the <strong class="source-inline">Main</strong> class, of our Spring Boot application, as follows:</p>
<pre class="source-code">@SpringBootApplication
public class GraphqlDaaSApp {
    public static void main(String[] args) {
        SpringApplication.run(GraphqlDaaSApp.class,args);
    }
}</pre>
<p>First, we will create <a id="_idIndexMarker1121"/>the <strong class="bold">Data Access Object</strong> (<strong class="bold">DAO</strong>) layer. The DAO layer is the same as it is for the REST application, as described in <a href="B17084_09.xhtml#_idTextAnchor144"><em class="italic">Chapter 9</em></a>, <em class="italic">Exposing MongoDB Data as a Service</em>. In the DAO layer, we will create the <strong class="source-inline">MongoConfig</strong> class, which creates two Mongo Spring<a id="_idIndexMarker1122"/> beans<a id="_idIndexMarker1123"/> of the <strong class="source-inline">MongoClient</strong> and <strong class="source-inline">MongoTemplate</strong> type, as shown in the following code block:</p>
<pre class="source-code">@Bean
public MongoClient mongo() throws Exception {
    final ConnectionString connectionString = new ConnectionString(mongoUrl);
    final MongoClientSettings mongoClientSettings = MongoClientSettings.builder().applyConnectionString(connectionString).serverApi(ServerApi.builder()
            .version(ServerApiVersion.V1)
            .build()).build();
    return MongoClients.create(mongoClientSettings);
}
@Bean
public MongoTemplate mongoTemplate() throws Exception {
    return new MongoTemplate(mongo(), mongoDb);
}</pre>
<p>Now, we will create a POJO class called <strong class="source-inline">Application</strong>, which represents the data model. It should be annotated by <strong class="source-inline">org.springframework.data.mongodb.core.mapping.Document annotation</strong> and <strong class="source-inline">com.querydsl.core.annotations.QueryEntity annotation</strong>. The following code denotes the <strong class="source-inline">Application</strong> bean:</p>
<pre class="source-code">@QueryEntity
@Document(collection = "newloanrequest")
public class Application {
    @Id
    private String _id;
    private String applicationId;</pre>
<p>Here, <strong class="source-inline">@Document</strong> denotes<a id="_idIndexMarker1124"/> that the POJO is a bean that <a id="_idIndexMarker1125"/>is mapped to a document in MongoDB, while <strong class="source-inline">@QueryEntity</strong> is required to enable QueryDSL’s querying capabilities over the <strong class="source-inline">Application</strong> bean.</p>
<p>Now, just like the REST-based solution discussed in <a href="B17084_09.xhtml#_idTextAnchor144"><em class="italic">Chapter 9</em></a>, <em class="italic">Exposing MongoDB Data as a Service</em>, we must create an <strong class="source-inline">ApplicationRepository</strong> interface that extends the <strong class="source-inline">MongoRepository</strong> and <strong class="source-inline">QuerydslPredicateExecutor</strong> interfaces. Using this class, we will define two methods to fetch application data from MongoDB using QueryDSL. The following code snippet is for the <strong class="source-inline">ApplicationRepository</strong> class:</p>
<pre class="source-code">public interface ApplicationRepository extends MongoRepository&lt;Application, String&gt;, QuerydslPredicateExecutor&lt;Application&gt; {
    @Query(value = "{ 'applicationId' : ?0 }")
    Application findApplicationsById(String applicationId);
    @Query(value = "{ 'id' : ?0 }")
    List&lt;Application&gt; findApplicationsByCustomerId(String id);
}</pre>
<p>We will skip explaining this repository interface as it is identical to the interface we created in the previous chapter.</p>
<p>Now that we have finished developing the DAO layer, let’s create a package called <strong class="source-inline">helper</strong>. In a GraphQL Java application, we need two kinds of classes – one should be the GraphQL provider and the other should be the GraphQL data fetcher. Here, we will start by writing the provider class under the <strong class="source-inline">helper</strong> package. In the <strong class="source-inline">GraphQLProvider</strong> class, first, we will define a property of the <strong class="source-inline">graphql.GraphQL</strong> type and initialize it as soon as the <strong class="source-inline">GraphQLProvider</strong> bean is initialized by Spring Boot. The code<a id="_idIndexMarker1126"/> snippet <a id="_idIndexMarker1127"/>for this is as follows:</p>
<pre class="source-code">...
import graphql.GraphQL;
...
@Component
public class GraphQLProvider {
...
private GraphQL graphQL;
@PostConstruct
public void init() throws IOException {
    URL url = Resources.getResource("schema.graphqls");
    String sdl = Resources.toString(url, Charsets.UTF_8);
    GraphQLSchema graphQLSchema = buildSchema(sdl);
    this.graphQL = GraphQL.newGraphQL(graphQLSchema).build();
}
private GraphQLSchema buildSchema(String sdl) {
    TypeDefinitionRegistry typeRegistry = new SchemaParser().parse(sdl);
    RuntimeWiring runtimeWiring = buildWiring();
    SchemaGenerator schemaGenerator = new SchemaGenerator();
    return schemaGenerator.makeExecutableSchema(typeRegistry, runtimeWiring);
}
private RuntimeWiring buildWiring() {
    return RuntimeWiring.newRuntimeWiring()
            .type(newTypeWiring("Query")
                    .dataFetcher("byApplicationId", graphQLDataFetchers.getApplicationbyApplicationIdDataFetcher())
                    .dataFetcher("byCustomerId",graphQLDataFetchers.getApplicationsbyCustomerIdDataFetcher()))
            .build();
}</pre>
<p>A GraphQL server<a id="_idIndexMarker1128"/> should <a id="_idIndexMarker1129"/>have a strongly typed well-defined schema (please refer to the earlier discussion about the GraphQL schema). Here, in the <strong class="source-inline">init</strong> method, we load the GraphQL schema from the resources. The GraphQL schema definition is read and stored in the string <strong class="source-inline">object named sdl </strong>using the utility methods of <strong class="source-inline">com.google.common.io.Resources</strong>. Then, the <strong class="source-inline">GraphQLSchema</strong> object is derived from the <strong class="source-inline">sdl</strong> object, which is built using the <strong class="source-inline">buildSchema</strong> method. </p>
<p>In the <strong class="source-inline">buildSchema</strong> method, the <strong class="source-inline">sdl</strong> object is parsed using <strong class="source-inline">SchemaParser</strong> and converted into the <strong class="source-inline">TypeDefinitionRegistry</strong> object. Runtime wiring is the process of attaching data fetchers, type resolvers, and custom scalars. First, we build the wiring required to complete the GraphQL schema using the <strong class="source-inline">buildWiring</strong> method. Then, using <strong class="source-inline">SchemaGenerator.makeExecutableSchema</strong>, we create a <strong class="source-inline">GraphQLSchema</strong> object with the required <strong class="source-inline">runtimeWiring</strong>.</p>
<p class="callout-heading">Necessary reference</p>
<p class="callout">Usually, to completely create an executable GraphQL schema, three kinds of bindings might be required. They are as follows:</p>
<p class="callout">- <strong class="bold">Data fetchers</strong>, which <a id="_idIndexMarker1130"/>are interfaces that help fetch data for a GraphQL schema.</p>
<p class="callout">- Type resolvers, which are custom methods that resolve the value of a GraphQL field.</p>
<p class="callout">- Custom scalars, which refer <a id="_idIndexMarker1131"/>to any customized data types. Data types in GraphQL are known as <strong class="bold">scalars</strong>.</p>
<p>Now, let’s discuss <a id="_idIndexMarker1132"/>the<a id="_idIndexMarker1133"/> implementation of the <strong class="source-inline">buildWiring</strong> method. This method creates a new <strong class="source-inline">Runtimewiring</strong> by attaching GraphQL data fetchers to the two different fields (<strong class="source-inline">byApplicationId</strong> and <strong class="source-inline">byCustomerId</strong>) in the GraphQL schema (the GraphQL schema for this use case was discussed earlier in this chapter).</p>
<p>Finally, using this <strong class="source-inline">GraphQLSchema</strong>, we build and instantiate the GraphQL property. Now, we can expose a bean called <strong class="source-inline">GraphQL</strong> by returning this GraphQL object, as shown here:</p>
<pre class="source-code">@Bean
public GraphQL graphQL() {
    return graphQL;
}</pre>
<p>While implementing the <strong class="source-inline">buildWiring</strong> method, two methods from the <strong class="source-inline">GraphQLDataFetcher</strong> class called <strong class="source-inline">getApplicationbyApplicationIdDataFetcher</strong> and <strong class="source-inline">getApplicationsbyCustomerIdDataFetcher</strong> are called. So, let’s discuss how the <strong class="source-inline">GraphQLDatafetcher</strong> class is implemented. All the data fetcher methods must return an object of the <strong class="source-inline">graphql.schema.DataFetcher</strong> type. The definition of the <strong class="source-inline">DataFetcher</strong> interface looks as follows:</p>
<pre class="source-code">@PublicSpi
public interface DataFetcher&lt;T&gt; {
    T get(DataFetchingEnvironment var1) throws Exception;
}</pre>
<p>As shown in the preceding code block, the <strong class="source-inline">DataFetcher</strong> interface has only one method, which takes an argument of the <strong class="source-inline">graphql.schema.DataFetchingEnvironment</strong> type. So, we can implement this interface as a Lambda function in Java. In our case, we call the <strong class="source-inline">applicationRepository</strong> class<a id="_idIndexMarker1134"/> to<a id="_idIndexMarker1135"/> fetch the data required for populating the <strong class="source-inline">Application</strong> object(s) we are publishing. The following code shows the implementation of <strong class="source-inline">getApplicationbyApplicationIdDataFetcher</strong>:</p>
<pre class="source-code">public DataFetcher getApplicationbyApplicationIdDataFetcher() {
    return dataFetchingEnvironment -&gt; {
        String applicationId = dataFetchingEnvironment.getArgument("applicationId");
        return applicationRepository.findApplicationsById(applicationId);
    };
}</pre>
<p>While implementing the <strong class="source-inline">getApplicationbyApplicationIdDataFetcher</strong> method, we are returning the Lambda function, which takes the <strong class="source-inline">dataFetchingEnvironment</strong> argument. All the arguments of the field that a data fetcher is written for can be accessed by the <strong class="source-inline">getArgument</strong> method of the <strong class="source-inline">DataFetchingEnvironment</strong> class. In this scenario, it is fetching the <strong class="source-inline">applicationId</strong> argument. Finally, as evident from the code snippet, we use <strong class="source-inline">applicationRepository</strong> to fetch data from MongoDB. Similar logic is used for writing the <strong class="source-inline">getApplicationsbyCustomerIdDataFetcher</strong> method.</p>
<p>Now, we need to keep the <strong class="source-inline">schema.graphqls</strong> file, which contains the GraphQL schema, in the <strong class="source-inline">resource</strong> folder.</p>
<p>Finally, we need to define the <strong class="source-inline">application.yaml</strong> file to run the Spring Boot application. The <strong class="source-inline">application.yaml</strong> file looks as follows:</p>
<pre class="source-code">grahqldaas:
  mongoUrl: mongodb+srv://&lt;mongodburl&gt;/CRRD?retryWrites=true&amp;w=majority
  mongoDb: CRRD</pre>
<p>Now that we <a id="_idIndexMarker1136"/>have<a id="_idIndexMarker1137"/> developed the GraphQL Server application, let’s explore how can we test it.</p>
<p>First, run the application by running the <strong class="source-inline">Main</strong> class, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer225">
<img alt="Figure 10.11 – Running the GraphQL server application " height="1081" src="image/B17084_10_011.jpg" width="900"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.11 – Running the GraphQL server application</p>
<p>Now, to test <a id="_idIndexMarker1138"/>the <a id="_idIndexMarker1139"/>application, open GraphQL Playground and enter the DaaS endpoint. The DaaS endpoint should look as follows:</p>
<pre class="source-code">http://&lt;host_name&gt;:8080/graphql</pre>
<p>Once you hit this URL on GraphQL Playground and enter a proper <strong class="source-inline">graphql</strong> request payload, you will get the result in GraphQL Playground, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer226">
<img alt="Figure 10.12 – Testing the GraphQL DaaS using GraphQL Playground " height="409" src="image/B17084_10_012.jpg" width="1324"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.12 – Testing the GraphQL DaaS using GraphQL Playground</p>
<p>As we can see, while calling the GraphQL Service application, the client sends the list of fields it wants to fetch. As shown in the request payload, although the GraphQL Server application supports <a id="_idIndexMarker1140"/>many <a id="_idIndexMarker1141"/>more fields, in this example, the client has only requested four fields – that is, <strong class="source-inline">applicationId</strong>, <strong class="source-inline">genderCode</strong>, <strong class="source-inline">id</strong>, and <strong class="source-inline">riskScore</strong>. Hence, GraphQL resolves and sends only those four fields back to the consumer. This feature of GraphQL helps overcome the problem of over-fetching or under-fetching (typically seen in REST-based DaaS).</p>
<p>Also, GraphQL supports multiple functionalities in a single call. In our use case, we have two functions – fetch application by <strong class="source-inline">applicationId</strong> and fetch all the applications for a customer using <strong class="source-inline">customerid</strong>. Both can be achieved in a single call using GraphQL. The following screenshot shows an example of this:</p>
<div>
<div class="IMG---Figure" id="_idContainer227">
<img alt="Figure 10.13 – Supporting multiple business operations in a single GraphQL call " height="728" src="image/B17084_10_013.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.13 – Supporting multiple business operations in a single GraphQL call</p>
<p>As we can see, both fields – <strong class="source-inline">byApplicationId</strong> and <strong class="source-inline">byCustomerId</strong> – can be requested in a <a id="_idIndexMarker1142"/>single<a id="_idIndexMarker1143"/> GraphQL call that fetches data for both fields in a single GraphQL response. This reduces the number of hits to the GraphQL service and clients can improve their application performance by making fewer calls to the GraphQL Server application.</p>
<p>Apart from these two advantages, GraphQL also enables easy schema and document sharing. As shown in the preceding screenshot, there are two sidewise tabs called <strong class="bold">DOCS</strong> and <strong class="bold">SCHEMA</strong> to the extreme right. <strong class="bold">SCHEMA</strong> can show us the supported GraphQL schema from the server. It tells us what data points are available as a part of this GraphQL API. The following screenshot shows how a client can see the schema of a GraphQL service:</p>
<div>
<div class="IMG---Figure" id="_idContainer228">
<img alt="Figure 10.14 – Checking the GraphQL schema from GraphQL Playground " height="860" src="image/B17084_10_014.jpg" width="1233"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.14 – Checking the GraphQL schema from GraphQL Playground</p>
<p>Apart from this, documentation is another cool feature that GraphQL provides. In the world of REST, sharing<a id="_idIndexMarker1144"/> the<a id="_idIndexMarker1145"/> API with the client is not sufficient. Therefore, we need to build and maintain the documentation separately (either using Swagger or otherwise) and share it. However, GraphQL allows you to easily maintain and publish documents, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer229">
<img alt="Figure 10.15 – Easily sharing GraphQL documentation " height="899" src="image/B17084_10_015.jpg" width="1560"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.15 – Easily sharing GraphQL documentation</p>
<p>What’s more interesting about GraphQL documentation is that it is very easy to configure and maintain. All we need to do is add a documentation comment above each field and query it to support the documentation. For example, the documentation of the <strong class="source-inline">applicationId</strong> field <a id="_idIndexMarker1146"/>can<a id="_idIndexMarker1147"/> easily be incorporated into the GraphQL Schema SDL, as shown in the following code block:</p>
<pre class="source-code">...
"""
Type Application represents the entity/schema of the response payload for both byApplicationId and byCustomerId fields
"""
type Application {
    """
    Application Id which uniquely identifies each credit card application
    """
    applicationId: ID!
...</pre>
<p>As we can see, all the documentation is written inside a documentation comment, which starts with three double quotes (<strong class="source-inline">""</strong>) and ends with three double quotes (<strong class="source-inline">""</strong>). GraphQL automatically uses the schema SDL to publish the documentation, hence making maintenance and publishing documentation super simple and easy.</p>
<p>In this section, we learned how to develop a GraphQL server application using Java. We also learned about GraphQL DSL for developing GraphQL schemas. Finally, we learned how to <a id="_idIndexMarker1148"/>effectively<a id="_idIndexMarker1149"/> test and verify the GraphQL DaaS API using GraphQL Playground. Now, let’s summarize what we learned in this chapter.</p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor166"/>Summary</h1>
<p>In this chapter, we learned about the basic concepts of GraphQL. First, we learned how GraphQL can overcome the pitfalls of REST-based DaaS and the benefits it provides. Then, we discussed when to choose GraphQL as a preferred solution. Finally, we learned how to develop a GraphQL server application using Java and how to test that application using GraphQL Playground.</p>
<p>Now that we have learned how to design and develop data engineering solutions for both data ingestion scenarios and data publication scenarios, in the next chapter, we will discuss performance engineering and learn how to use a data-driven approach to make architectural decisions.</p>
</div>
</div>


<div id="sbo-rt-content"><div class="Content" id="_idContainer231">
<h1 id="_idParaDest-166"><a id="_idTextAnchor167"/>Section 4 – Choosing Suitable Data Architecture</h1>
<p>In the final section of the book, you will learn how to measure a solution and determine the efficiency of a solution. You will also learn how to communicate and present their solution to leadership/clients who may not be very technical.</p>
<p>This section comprises the following chapters:</p>
<ul>
<li><a href="B17084_11.xhtml#_idTextAnchor168"><em class="italic">Chapter 11</em></a><em class="italic">, Measuring Performance and Benchmarking Your Applications</em></li>
<li><a href="B17084_12.xhtml#_idTextAnchor180"><em class="italic">Chapter 12</em></a><em class="italic">, Evaluating, Recommending, and Presenting Your Solutions</em></li>
</ul>
</div>
<div>
<div id="_idContainer232">
</div>
</div>
</div>
</body></html>