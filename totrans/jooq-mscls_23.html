<html><head></head><body>
		<div id="_idContainer116">
			<h1 id="_idParaDest-339"><em class="italic"><a id="_idTextAnchor338"/>Chapter 18</em>: jOOQ SPI (Providers and Listeners)</h1>
			<p>jOOQ provides a lot of hooks that allow us to alter its default behavior at different levels. Among these hooks, we have lightweight settings and configurations, and the heavy-duty, extremely stable <strong class="bold">Service Provider Interface</strong> (<strong class="bold">SPI</strong>) made of generators, providers, listeners, parsers, and so on. So, like any robust and mature technology, jOOQ comes with an impressive SPI dedicated to those corner cases where the core technology cannot help.</p>
			<p>In this chapter, we scratch the surface of each of these hooks in order to expose the usage steps and some examples that will help you to understand how to develop your own implementations. Our agenda includes the following:</p>
			<ul>
				<li>jOOQ settings</li>
				<li>jOOQ configuration</li>
				<li>jOOQ providers</li>
				<li>jOOQ listeners</li>
				<li>Altering the jOOQ code generation process</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-340"><a id="_idTextAnchor339"/>Technical requirements</h1>
			<p>The code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18">https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter18</a>.</p>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor340"/>jOOQ settings</h1>
			<p>jOOQ comes with <a id="_idIndexMarker1735"/>a comprehensive list of settings (<strong class="source-inline">org.jooq.conf.Settings</strong>) that attempts to cover the most popular use cases related to rendering the SQL code. These settings are available declaratively (via <strong class="source-inline">jooq-settings.xml</strong> in the classpath) or programmatically via methods such as <strong class="source-inline">setFooSetting()</strong> or <strong class="source-inline">withFooSetting()</strong>, which can be chained in a fluent style. To take effect, <strong class="source-inline">Settings</strong> must be part of <strong class="source-inline">org.jooq.Configuration</strong>, and this can be done in multiple ways, as you can read in the jOOQ manual at <a href="https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/">https://www.jooq.org/doc/latest/manual/sql-building/dsl-context/custom-settings/</a>. But most probably, in a Spring Boot application, you'll prefer one of the following approaches:</p>
			<p>Pass global <strong class="source-inline">Settings</strong> to the default <strong class="source-inline">Configuration</strong> via <strong class="source-inline">jooq-settings.xml</strong> in the classpath (the <strong class="source-inline">DSLContext</strong> prepared by Spring Boot will take advantage of these<a id="_idIndexMarker1736"/> settings):</p>
			<pre class="source-code">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</pre>
			<pre class="source-code">&lt;settings&gt;</pre>
			<pre class="source-code">  &lt;renderCatalog&gt;false&lt;/renderCatalog&gt;</pre>
			<pre class="source-code">  &lt;renderSchema&gt;false&lt;/renderSchema&gt;</pre>
			<pre class="source-code">  &lt;!-- more settings added here --&gt;</pre>
			<pre class="source-code">&lt;/settings&gt;</pre>
			<p>Pass global <strong class="source-inline">Settings</strong> to the default <strong class="source-inline">Configuration</strong> via an <strong class="source-inline">@Bean</strong> (the <strong class="source-inline">DSLContext</strong> prepared by Spring Boot will take advantage of these settings):</p>
			<pre class="source-code">@org.springframework.context.annotation.Configuration</pre>
			<pre class="source-code">public class JooqConfig {</pre>
			<pre class="source-code">  @Bean</pre>
			<pre class="source-code">  public Settings jooqSettings() {</pre>
			<pre class="source-code">    return new Settings()</pre>
			<pre class="source-code">      .withRenderSchema(Boolean.FALSE) // this is a setting</pre>
			<pre class="source-code">      ... // more settings added here</pre>
			<pre class="source-code">   }  </pre>
			<pre class="source-code">  ...</pre>
			<pre class="source-code">}</pre>
			<p>At some point, set a new global <strong class="source-inline">Settings</strong> that will be applied from this point onward (this is a global <strong class="source-inline">Settings</strong> because we use <strong class="source-inline">Configuration#set()</strong>):</p>
			<pre class="source-code">ctx.configuration().set(new Settings()</pre>
			<pre class="source-code">   .withMaxRows(5)</pre>
			<pre class="source-code">   ... // more settings added here</pre>
			<pre class="source-code">   ).dsl()</pre>
			<pre class="source-code">   . // some query</pre>
			<p>Append new global settings to the current global <strong class="source-inline">Settings</strong>:</p>
			<pre class="source-code">ctx.configuration().settings()</pre>
			<pre class="source-code">   .withRenderKeywordCase(RenderKeywordCase.UPPER); </pre>
			<pre class="source-code">ctx. // some query</pre>
			<p>You can <a id="_idIndexMarker1737"/>practice these examples in <em class="italic">GlobalSettings</em> for MySQL.</p>
			<p>At some point, set a new local <strong class="source-inline">Settings</strong> that will be applied only to the current query (this is a local <strong class="source-inline">Settings</strong> because we use <strong class="source-inline">Configuration#derive()</strong>):</p>
			<pre class="source-code">ctx.configuration().derive(new Settings()</pre>
			<pre class="source-code">   .withMaxRows(5)</pre>
			<pre class="source-code">   ... // more settings added here</pre>
			<pre class="source-code">   ).dsl()</pre>
			<pre class="source-code">   . // some query</pre>
			<p>Or, setting a global/local setting and appends to it more local settings:</p>
			<pre class="source-code">ctx.configuration().settings()</pre>
			<pre class="source-code">   .withRenderMapping(new RenderMapping()</pre>
			<pre class="source-code">      .withSchemata(</pre>
			<pre class="source-code">         new MappedSchema()</pre>
			<pre class="source-code">            .withInput("classicmodels")</pre>
			<pre class="source-code">            .withOutput("classicmodels_test")));                </pre>
			<pre class="source-code">// 'derivedCtx' inherits settings of 'ctx'</pre>
			<pre class="source-code">DSLContext derivedCtx = ctx.configuration().derive(</pre>
			<pre class="source-code">    ctx.settings() // using here new Settings() will NOT </pre>
			<pre class="source-code">                   // inherit 'ctx' settings</pre>
			<pre class="source-code">       .withRenderKeywordCase(RenderKeywordCase.UPPER)).dsl();</pre>
			<p>You can practice this example in <em class="italic">LocalSettings</em> for MySQL. It is highly recommended to reserve<a id="_idIndexMarker1738"/> some time and at least to briefly scroll the entire list of jOOQ-supported settings at <a href="https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html">https://www.jooq.org/javadoc/latest/org.jooq/org/jooq/conf/Settings.html</a>. Next, let's talk about jOOQ <strong class="source-inline">Configuration</strong>.</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor341"/>jOOQ Configuration</h1>
			<p><strong class="source-inline">org.jooq.Configuration</strong> represents <a id="_idIndexMarker1739"/>the spine of <strong class="source-inline">DSLContext</strong>. <strong class="source-inline">DSLContext</strong> needs the precious information provided by <strong class="source-inline">Configuration</strong> for query rendering and execution. While <strong class="source-inline">Configuration</strong> takes advantage of <strong class="source-inline">Settings</strong> (as you just saw), it also has a lot more other configurations that can be specified as in the examples from this section.</p>
			<p>By default, Spring Boot gives us a <strong class="source-inline">DSLContext</strong> built on the default <strong class="source-inline">Configuration</strong> (the <strong class="source-inline">Configuration</strong> accessible via <strong class="source-inline">ctx.configuration()</strong>), and as you know, while providing custom settings and configurations, we can alter this <strong class="source-inline">Configuration</strong> globally via <strong class="source-inline">set()</strong> or locally by creating a derived one via <strong class="source-inline">derive()</strong>.</p>
			<p>But, in some scenarios, for instance, when you build custom providers or listeners, you'll prefer to build the <strong class="source-inline">Configuration</strong> to be aware of your artifacts right from the start instead of extracting it from <strong class="source-inline">DSLContext</strong>. In other words, when <strong class="source-inline">DSLContext</strong> is built, it should use the ready-to-go <strong class="source-inline">Configuration</strong>.</p>
			<p>Before Spring Boot 2.5.0, this step required a little bit of effort, as you can see here:</p>
			<pre class="source-code">@org.springframework.context.annotation.Configuration</pre>
			<pre class="source-code">public class JooqConfig {       </pre>
			<pre class="source-code">  @Bean</pre>
			<pre class="source-code">  @ConditionalOnMissingBean(org.jooq.Configuration.class)</pre>
			<pre class="source-code">  public DefaultConfiguration jooqConfiguration(</pre>
			<pre class="source-code">       JooqProperties properties, DataSource ds, </pre>
			<pre class="source-code">       ConnectionProvider cp, TransactionProvider tp) {</pre>
			<pre class="source-code">    final DefaultConfiguration defaultConfig = </pre>
			<pre class="source-code">      new DefaultConfiguration();</pre>
			<pre class="source-code">    defaultConfig               </pre>
			<pre class="source-code">     <strong class="bold">.set(cp)                                  // must have</strong></pre>
			<pre class="source-code"><strong class="bold">     .set(properties.determineSqlDialect(ds))  // must have</strong></pre>
			<pre class="source-code">     .set(tp) // for using SpringTransactionProvider</pre>
			<pre class="source-code">     .set(new Settings().withRenderKeywordCase(</pre>
			<pre class="source-code">          RenderKeywordCase.UPPER)); // optional</pre>
			<pre class="source-code">       // more configs ...</pre>
			<pre class="source-code">    return defaultConfig;</pre>
			<pre class="source-code">}</pre>
			<p>This is a <strong class="source-inline">Configuration</strong> created<a id="_idIndexMarker1740"/> from scratch (actually from the jOOQ built-in <strong class="source-inline">DefaultConfiguration</strong>) that will be used by Spring Boot to create the <strong class="source-inline">DSLContext</strong>. At a minimum, we need to specify a <strong class="source-inline">ConnectionProvider</strong> and the SQL dialect. Optionally, if we want to use <strong class="source-inline">SpringTransactionProvider</strong> as the default provider for jOOQ transactions, then we need to set it as in this code. After this minimum configuration, you can continue adding your settings, providers, listeners, and so on. You can practice this example in <em class="italic">Before250Config</em> for MySQL.</p>
			<p>Starting with version 2.5.0, Spring Boot facilitates easier customization of jOOQ's <strong class="source-inline">DefaultConfiguration</strong> via a bean that implements a functional interface named <strong class="source-inline">DefaultConfigurationCustomizer</strong>. This acts as a callback and can be used as in the following<a id="_idIndexMarker1741"/> example:</p>
			<pre class="source-code">@org.springframework.context.annotation.Configuration</pre>
			<pre class="source-code">public class JooqConfig </pre>
			<pre class="source-code">     implements DefaultConfigurationCustomizer {</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public void customize(DefaultConfiguration configuration) {</pre>
			<pre class="source-code">     configuration.set(new Settings()</pre>
			<pre class="source-code">       .withRenderKeywordCase(RenderKeywordCase.UPPER)); </pre>
			<pre class="source-code">       ... // more configs</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This is more<a id="_idIndexMarker1742"/> practical because we can add only what we need. You can check out this example in <em class="italic">After250Config</em> for MySQL. Next, let's talk about jOOQ providers.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor342"/>jOOQ providers</h1>
			<p>The jOOQ SPI exposes a<a id="_idIndexMarker1743"/> suite of providers such as <strong class="source-inline">TransactionProvider</strong>, <strong class="source-inline">RecordMapperProvider</strong>, <strong class="source-inline">ConverterProvider</strong>, and so on. Their overall goal is simple—to provide some feature that is not provided by the jOOQ default providers. For instance, let's check out <strong class="source-inline">TransactionProvider</strong>.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor343"/>TransactionProvider</h2>
			<p>For instance, we<a id="_idIndexMarker1744"/> know that jOOQ transactions <a id="_idIndexMarker1745"/>are backed in Spring Boot by a transaction provider named <strong class="source-inline">SpringTransactionProvider</strong> (the Spring Boot built-in implementation of jOOQ's <strong class="source-inline">TransactionProvider</strong>) that exposes by default a read-write transaction with no name (<strong class="source-inline">null</strong>), having the propagation set to <strong class="source-inline">PROPAGATION_NESTED</strong> and the isolation level to the default isolation level of the underlying database, <strong class="source-inline">ISOLATION_DEFAULT</strong>.</p>
			<p>Now, let's assume that we implement a module of our application that serves only reports via jOOQ transactions (so we don't use <strong class="source-inline">@Transactional</strong>). In such a module, we don't want to allow writing, we want to run each query in a separate/new transaction with a timeout of 1 second, and we want to <a id="_idIndexMarker1746"/>avoid the <strong class="bold">dirty reads</strong> phenomenon (a transaction reads the uncommitted modifications of another concurrent transaction that rolls back in the end). In other words, we need to provide a read-only transaction having the propagation set to <strong class="source-inline">PROPAGATION_REQUIRES_NEW</strong>, the isolation level set to <strong class="source-inline">ISOLATION_READ_COMMITTED</strong>, and the timeout set to 1 second.  </p>
			<p>To obtain such a transaction, we can implement a <strong class="source-inline">TransactionProvider</strong> and override the <strong class="source-inline">begin()</strong> method as in the following code:</p>
			<pre class="source-code">public class MyTransactionProvider </pre>
			<pre class="source-code">        implements TransactionProvider {</pre>
			<pre class="source-code">  private final PlatformTransactionManager transactionManager;</pre>
			<pre class="source-code">  public MyTransactionProvider(</pre>
			<pre class="source-code">       PlatformTransactionManager transactionManager) {</pre>
			<pre class="source-code">   this.transactionManager = transactionManager;</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void begin(TransactionContext context) {</pre>
			<pre class="source-code">  DefaultTransactionDefinition definition = </pre>
			<pre class="source-code">   new DefaultTransactionDefinition(</pre>
			<pre class="source-code">    TransactionDefinition.PROPAGATION_REQUIRES_NEW);</pre>
			<pre class="source-code">  definition.setIsolationLevel(</pre>
			<pre class="source-code">   TransactionDefinition.ISOLATION_READ_COMMITTED);</pre>
			<pre class="source-code">  definition.setName("TRANSACTION_" + Math.round(1000));</pre>
			<pre class="source-code">  definition.setReadOnly(true);</pre>
			<pre class="source-code">  definition.setTimeout(1);</pre>
			<pre class="source-code">  TransactionStatus status =    </pre>
			<pre class="source-code">   this.transactionManager.getTransaction(definition);</pre>
			<pre class="source-code">  context.transaction(new SpringTransaction(status));</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code"> ...</pre>
			<pre class="source-code">}</pre>
			<p>Once we have <a id="_idIndexMarker1747"/>the <a id="_idIndexMarker1748"/>transaction provider, we have to configure it in jOOQ. Assuming that we are using Spring Boot 2.5.0+, and based on the previous section, this can be done as follows:</p>
			<pre class="source-code">@org.springframework.context.annotation.Configuration</pre>
			<pre class="source-code">public class JooqConfig </pre>
			<pre class="source-code">       implements DefaultConfigurationCustomizer {</pre>
			<pre class="source-code">  private final PlatformTransactionManager txManager;</pre>
			<pre class="source-code">  public JooqConfig(PlatformTransactionManager txManager) {</pre>
			<pre class="source-code">   this.txManager = txManager;</pre>
			<pre class="source-code">  }        </pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public void customize(DefaultConfiguration configuration) {</pre>
			<pre class="source-code">   configuration.set(newMyTransactionProvider(txManager));</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>You can <a id="_idIndexMarker1749"/>practice<a id="_idIndexMarker1750"/> this example in <em class="italic">A250MyTransactionProvider</em> for MySQL. When you run the application, you'll notice at the console that the created transaction has these coordinates: <em class="italic">Creating new transaction with name [TRANSACTION_1000]: PROPAGATION_REQUIRES_NEW, ISOLATION_READ_COMMITTED, timeout_1, readOnly</em>.</p>
			<p>If you are using a Spring Boot version prior to 2.5.0, then check out the application named <em class="italic">B250MyTransactionProvider</em> for MySQL.</p>
			<p>And, of course, you can configure the provider via <strong class="source-inline">DSLContext</strong> as well:</p>
			<pre class="source-code">ctx.configuration().set(</pre>
			<pre class="source-code">   new MyTransactionProvider(txManager)).dsl() ...;</pre>
			<p>Or, you can use the following:</p>
			<pre class="source-code">ctx.configuration().derive(</pre>
			<pre class="source-code">  new MyTransactionProvider(txManager)).dsl() ...;</pre>
			<p>Now, let's consider another scenario solved via <strong class="source-inline">ConverterProvider</strong>. </p>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor344"/>ConverterProvider</h2>
			<p>We have to <a id="_idIndexMarker1751"/>project <a id="_idIndexMarker1752"/>some JSON functions and map them hierarchically. We already know that this is no issue in a Spring Boot + jOOQ combo since jOOQ can fetch the JSON and can call Jackson (the default in Spring Boot) to map it accordingly. But, we don't want to use Jackson; we want to use <a id="_idIndexMarker1753"/>Flexjson (<a href="http://flexjson.sourceforge.net/">http://flexjson.sourceforge.net/</a>). jOOQ is not aware of this library (jOOQ can detect only the presence of Jackson and Gson), so we need to provide a converter such as <strong class="source-inline">org.jooq.ConverterProvider</strong> that uses Flexjson to accomplish this task. Take your time to check the source in <em class="italic">{A,B}250ConverterProvider</em> for MySQL. Finally, let's focus on this scenario solved via <strong class="source-inline">RecordMapperProvider</strong>.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor345"/>RecordMapperProvider</h2>
			<p>We have a <a id="_idIndexMarker1754"/>ton of<a id="_idIndexMarker1755"/> legacy POJOs implemented via the <strong class="source-inline">Builder</strong> pattern and we decide to write a bunch of jOOQ <strong class="source-inline">RecordMapper</strong> for mapping queries to these POJOs. In order to streamline the process of using these <strong class="source-inline">RecordMapper</strong>, we also decide to write a <strong class="source-inline">RecordMapperProvider</strong>. Basically, this will be responsible for using the proper <strong class="source-inline">RecordMapper</strong> without our explicit intervention. Are you curious about how to do it? Then check out the <em class="italic">{A,B}250RecordMapperProvider</em> and <em class="italic">RecordMapperProvider</em> applications for MySQL. Mainly, these applications are the same, but they use different approaches to configure <strong class="source-inline">RecordMapperProvider</strong>.</p>
			<p>With <strong class="source-inline">ConverterProvider</strong> and <strong class="source-inline">RecordMapperProvider</strong>, I think it's important to mention that these <em class="italic">replace</em> out-of-the-box behavior, they don't <em class="italic">enhance</em> it. So, custom providers have to make sure to fall back to the default implementations if they can't handle a conversion/mapping.</p>
			<h1 id="_idParaDest-347"><a id="_idTextAnchor346"/>jOOQ listeners</h1>
			<p>jOOQ comes <a id="_idIndexMarker1756"/>with a significant number of listeners that are quite versatile and useful in hooking us into jOOQ life cycle management for solving a wide range of tasks. Let's "arbitrarily" pick up the mighty <strong class="source-inline">ExecuteListener</strong>.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor347"/>ExecuteListener</h2>
			<p>For instance, one <a id="_idIndexMarker1757"/>of the <a id="_idIndexMarker1758"/>listeners that you'll love is <strong class="source-inline">org.jooq.ExecuteListener</strong>. This listener comes with a bunch of methods that can hook in the life cycle of a <strong class="source-inline">Query</strong>, <strong class="source-inline">Routine</strong>, or <strong class="source-inline">ResultSet</strong> to alter the default rendering, preparing, binding, executing, and fetching stage. The most convenient approach to implement your own listener is to extend the jOOQ default implementation, <strong class="source-inline">DefaultExecuteListener</strong>. This way, you can override only the methods that you want and you keep up with the SPI evolution (however, by the time you read this book, it is possible that this default listener will have been removed, and all methods are now default methods on the interface). Consider applying this technique to any other jOOQ listener, since jOOQ provides a default implementation for all (mainly, for <strong class="source-inline">FooListener</strong>, there is a <strong class="source-inline">DefaultFooListener</strong>).</p>
			<p>For now, let's write an <strong class="source-inline">ExecuteListener</strong> that alters the rendered SQL that is about to be executed. Basically, all we want is to alter every MySQL <strong class="source-inline">SELECT</strong> by adding the <strong class="source-inline">/*+ MAX_EXECUTION_TIME(n) */</strong> hint, which allows us to specify a query timeout in milliseconds. The jOOQ DSL allows for adding MySQL/Oracle-style hints. :) Use <strong class="source-inline">ctx.select(...).hint("/*+ ... */").from(...)</strong>. But only <strong class="source-inline">ExecuteListener</strong> can patch multiple queries without modifying the queries themselves. So, <strong class="source-inline">ExecuteListener</strong> exposes callbacks such as <strong class="source-inline">renderStart(ExecuteContext)</strong> and <strong class="source-inline">renderEnd(ExecuteContext)</strong>, which are called before rendering SQL from <strong class="source-inline">QueryPart</strong> and after rendering SQL from <strong class="source-inline">QueryPart</strong>, respectively. Once we are in control, we can rely on <strong class="source-inline">ExecuteContext</strong>, which gives us access to the underlying connection (<strong class="source-inline">ExecuteContext.connection()</strong>), query (<strong class="source-inline">ExecuteContext.query()</strong>), rendered SQL (<strong class="source-inline">ExecuteContext.sql()</strong>), and so on. In this specific case, we are interested in accessing the rendered SQL and modifying it, so we override <strong class="source-inline">renderEnd(ExecuteContext)</strong> and call <strong class="source-inline">ExecuteContext.sql()</strong> as follows:</p>
			<pre class="source-code">public class MyExecuteListener extends </pre>
			<pre class="source-code">    DefaultExecuteListener{</pre>
			<pre class="source-code">  private static final Logger logger = </pre>
			<pre class="source-code">    Logger.getLogger(MyExecuteListener.class.getName());</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public void renderEnd(ExecuteContext ecx) {</pre>
			<pre class="source-code">    if (ecx.configuration().data()</pre>
			<pre class="source-code">        .containsKey("timeout_hint_select") &amp;&amp;</pre>
			<pre class="source-code">                 ecx.query() instanceof Select) {</pre>
			<pre class="source-code">      String sql = ecx.sql();</pre>
			<pre class="source-code">      if (sql != null) {</pre>
			<pre class="source-code">        ecx.sql(sql.replace(</pre>
			<pre class="source-code">         "select",</pre>
			<pre class="source-code">         "select " + ecx.configuration().data()</pre>
			<pre class="source-code">            .get("timeout_hint_select")</pre>
			<pre class="source-code">      ));</pre>
			<pre class="source-code">      logger.info(() -&gt; {</pre>
			<pre class="source-code">        return "Executing modified query : " + ecx.sql();</pre>
			<pre class="source-code">      });</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>The code from inside the decisional block is quite simple: we just capture the rendered SQL (the SQL that is about to be executed shortly) and modify it accordingly by adding the MySQL hint. But, what is <strong class="source-inline">...data().containsKey("timeout_hint_select")</strong>? Mainly, <strong class="source-inline">Configuration</strong> comes with three methods that work together to pass custom data through <strong class="source-inline">Configuration</strong>. These methods are <strong class="source-inline">data(Object key, Object value)</strong>, which allows us to set some custom data; <strong class="source-inline">data(Object key)</strong>, which allows us to get some custom data based on a key; and <strong class="source-inline">data()</strong>, which returns the entire <strong class="source-inline">Map</strong> of custom data. So, in our code, we check whether the custom data of the current <strong class="source-inline">Configuration</strong> contains a key named <strong class="source-inline">timeout_hint_select</strong> (this is a name we have chosen). If such a key exists, it means that we want to add the MySQL hint (which was set as the value corresponding to this key) to the current <strong class="source-inline">SELECT</strong>, otherwise, we take no action. This piece of custom information was set as follows:</p>
			<pre class="source-code">Configuration derived = ctx.configuration().derive();</pre>
			<pre class="source-code">derived.data("timeout_hint_select", </pre>
			<pre class="source-code">             "/*+ MAX_EXECUTION_TIME(5) */");</pre>
			<p>Once this <a id="_idIndexMarker1759"/>custom<a id="_idIndexMarker1760"/> data is set, we can execute a <strong class="source-inline">SELECT</strong> that will be enriched with the MySQL hint by our custom <strong class="source-inline">ExecuteListener</strong>:</p>
			<pre class="source-code">derived.dsl().select(...).fetch();</pre>
			<p>You can practice this example in <em class="italic">A250ExecuteListener</em> for MySQL. If you are using a Spring Boot version prior to 2.5.0, then go for <em class="italic">B250ExecuteListener</em> for MySQL. There is also an application named <em class="italic">ExecuteListener</em> for MySQL that does the same thing but it "inlines" <strong class="source-inline">ExecuteListener</strong> via <strong class="source-inline">CallbackExecuteListener</strong> (this represents <strong class="source-inline">ExecuteListener</strong> – useful if you prefer functional composition):</p>
			<pre class="source-code">ctx.configuration().derive(new CallbackExecuteListener()</pre>
			<pre class="source-code">                   .onRenderEnd(ecx -&gt; {</pre>
			<pre class="source-code">   ...}))</pre>
			<pre class="source-code">   .dsl()</pre>
			<pre class="source-code">   .select(...).fetch();</pre>
			<p>Most listeners have a functional composition approach as well that can be used as in the previous <a id="_idIndexMarker1761"/>snippet <a id="_idIndexMarker1762"/>of code. Next, let's talk about a listener named <strong class="source-inline">ParseListener</strong>.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor348"/>jOOQ SQL parser and ParseListener</h2>
			<p><strong class="source-inline">ParseListener</strong> (SQL Parser Listener) was introduced in jOOQ 3.15, but before discussing it, we <a id="_idIndexMarker1763"/>should discuss the SQL <strong class="source-inline">Parser</strong> (<strong class="source-inline">org.jooq.Parser</strong>).</p>
			<h3>SQL Parser</h3>
			<p>jOOQ comes with a<a id="_idIndexMarker1764"/> powerful and mature <strong class="source-inline">Parser</strong> API that is capable of parsing an arbitrary SQL string (or a fragment of it) into different jOOQ API elements. For instance, we have <strong class="source-inline">Parser.parseQuery(String sql)</strong>, which returns the <strong class="source-inline">org.jooq.Query</strong> type containing a single query that corresponds to the passed <strong class="source-inline">sql</strong>.</p>
			<p>One of the main functionalities of the <strong class="source-inline">Parser</strong> API is that it can act as a translator between two dialects. In other words, we have SQL in dialect <em class="italic">X</em>, and we can programmatically pass it through the SQL <strong class="source-inline">Parser</strong> to obtain the SQL translated/emulated for dialect <em class="italic">Y</em>. For instance, consider a Spring Data JPA application that contains a significant number of native queries written for the MySQL dialect like this one:</p>
			<pre class="source-code">@Query(value = "SELECT c.customer_name as customerName, "</pre>
			<pre class="source-code">  + "d.address_line_first as addressLineFirst, </pre>
			<pre class="source-code">     d.address_line_second as addressLineSecond "</pre>
			<pre class="source-code">  + "FROM customer c JOIN customerdetail d "</pre>
			<pre class="source-code">  + "ON c.customer_number = d.customer_number "</pre>
			<pre class="source-code">  + "WHERE (NOT d.address_line_first &lt;=&gt;</pre>
			<pre class="source-code">    d.address_line_second)", nativeQuery=true)</pre>
			<pre class="source-code">    List&lt;SimpleCustomer&gt; fetchCustomerNotSameAddress();</pre>
			<p>The idea is that management took the decision to switch to PostgreSQL, so you should migrate all these queries to the PostgreSQL dialect and you should do it with insignificant downtime. Even if you are familiar with the differences between these two dialects and you don't have a problem expressing both, you are still under time pressure. This is a scenario where jOOQ can save you because all you have to do is to pass to the jOOQ <strong class="source-inline">Parser</strong> your native queries and jOOQ will translate/emulate them for PostgreSQL. Assuming that you are using Spring Data JPA backed by Hibernate, then all you need to do is to add a Hibernate interceptor that exposes the SQL string that is about <a id="_idIndexMarker1765"/>to <a id="_idIndexMarker1766"/>execute:</p>
			<pre class="source-code">@Configuration</pre>
			<pre class="source-code">public class SqlInspector implements StatementInspector {</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public String inspect(String sql) {</pre>
			<pre class="source-code">    Query query = DSL.using(SQLDialect.POSTGRES)</pre>
			<pre class="source-code">      .parser()</pre>
			<pre class="source-code">      .parseQuery(sql);</pre>
			<pre class="source-code">    if (query != null) {</pre>
			<pre class="source-code">        return query.getSQL();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    return null; // interpreted as the default SQL string</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Done in 5 minutes! How cool is that?! Obviously, your colleagues will ask you what sorcery this was, so you have a good opportunity to introduce them to jOOQ. :)</p>
			<p>If you check out the console output, you'll see that Hibernate reports the following SQL string to be executed against the PostgreSQL database:</p>
			<pre class="source-code">SELECT c.customer_name AS customername,</pre>
			<pre class="source-code">       d.address_line_first AS addresslinefirst,</pre>
			<pre class="source-code">       d.address_line_second AS addresslinesecond</pre>
			<pre class="source-code">FROM customer AS c</pre>
			<pre class="source-code">JOIN customerdetail AS d </pre>
			<pre class="source-code">  ON c.customer_number = d.customer_number</pre>
			<pre class="source-code">WHERE NOT (d.address_line_first IS NOT DISTINCT</pre>
			<pre class="source-code">           FROM d.address_line_second)</pre>
			<p>Of course, you can change the dialect and obtain the SQL for any of the jOOQ-supported dialects. Now, you have time to copy the jOOQ output and replace your native queries accordingly since the application continues to run as usual. At the end, simply decouple this interceptor. You can practice this application in <em class="italic">JPAParser</em>.</p>
			<p>Besides <strong class="source-inline">parseQuery()</strong>, we have <strong class="source-inline">parseName(String sql)</strong>, which parses the given <strong class="source-inline">sql</strong> into <strong class="source-inline">org.jooq.Name</strong>; <strong class="source-inline">parseField(String sql)</strong>, which parses the<a id="_idIndexMarker1767"/> given <strong class="source-inline">sql</strong> into<a id="_idIndexMarker1768"/> <strong class="source-inline">org.jooq.Field</strong>; <strong class="source-inline">parseCondition(String sql)</strong>, which parses the given <strong class="source-inline">sql</strong> into <strong class="source-inline">org.jooq.Condition</strong>; and so on. Please check out the jOOQ documentation to see all the methods and their flavors.</p>
			<p>But jOOQ can do even more via the so-called <em class="italic">parsing connection</em> feature (available for R2DBC as well). Basically, this means that the SQL string is passed through the jOOQ <strong class="source-inline">Parser</strong> and the output SQL can become the source of a <strong class="source-inline">java.sql.PreparedStatement</strong> or <strong class="source-inline">java.sql.Statement</strong>, which can be executed via these JDBC APIs (<strong class="source-inline">executeQuery(String sql)</strong>). This happens as long as the SQL string comes through a JDBC connection (<strong class="source-inline">java.sql.Connection</strong>) that is obtained as in this example:</p>
			<p>There's no way from syntax alone to decide which input semantics it could be:</p>
			<pre class="source-code">try (Connection c = DSL.using(url, user, pass)</pre>
			<pre class="source-code">      .configuration()</pre>
			<pre class="source-code">      .set(new Settings()</pre>
			<pre class="source-code">          .withParseDialect(SQLDialect.MYSQL)) </pre>
			<pre class="source-code">      .dsl()</pre>
			<pre class="source-code">      .parsingConnection();  // this does the trick  </pre>
			<pre class="source-code">      PreparedStatement ps = c.prepareStatement(sql);</pre>
			<pre class="source-code">    ) {</pre>
			<pre class="source-code">     ...</pre>
			<pre class="source-code">}</pre>
			<p>The <strong class="source-inline">sql</strong> passed to the <strong class="source-inline">PreparedStatement</strong> represents any SQL string. For instance, it can be produced by <strong class="source-inline">JdbcTemplate</strong>, the Criteria API, <strong class="source-inline">EntityManager</strong>, and so on. Gathering the SQL string from the Criteria API and <strong class="source-inline">EntityManager</strong> can be a little bit tricky (since it requires a Hibernate <strong class="source-inline">AbstractProducedQuery</strong> action) but you can find the complete solution in <em class="italic">JPAParsingConnection</em> for MySQL.</p>
			<p>Besides the <strong class="source-inline">Parser</strong> API, jOOQ also exposes a translator between dialects via the <strong class="source-inline">Parser</strong> CLI (<a href="https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/">https://www.jooq.org/doc/latest/manual/sql-building/sql-parser/sql-parser-cli/</a>) and<a id="_idIndexMarker1769"/> via<a id="_idIndexMarker1770"/> this website: . Now, we can talk about <strong class="source-inline">ParseListener</strong>.</p>
			<h3>SQL Parser Listener</h3>
			<p>It is quite easy<a id="_idIndexMarker1771"/> to intuit that the SQL Parser Listener (<strong class="source-inline">org.jooq.ParseListener</strong> introduced in jOOQ 3.15) is responsible for providing hooks that allow altering the default<a id="_idIndexMarker1772"/> behavior of the jOOQ parser.</p>
			<p>For instance, let's consider the following <strong class="source-inline">SELECT</strong>, which uses the SQL <strong class="source-inline">CONCAT_WS(separator, str1, str2, ...)</strong> function:</p>
			<pre class="source-code">SELECT concat_ws('|', city, address_line_first, </pre>
			<pre class="source-code">  address_line_second, country, territory) AS address </pre>
			<pre class="source-code">FROM office</pre>
			<p>This variadic function that ignores <strong class="source-inline">NULL</strong> values and uses a string separator/delimiter to separate all arguments concatenated in the resulting string is natively supported by MySQL, PostgreSQL, and SQL Server but is not supported by Oracle. Moreover, jOOQ (at least until version 3.16.4) doesn't support it either. One way to use it in our queries is via plain SQL as follows:</p>
			<pre class="source-code">ctx.resultQuery("SELECT concat_ws('|', city, </pre>
			<pre class="source-code">  address_line_first, address_line_second, country, territory) </pre>
			<pre class="source-code">AS address FROM office").fetch();</pre>
			<p>But, if we try to execute this query against Oracle, it will not work since Oracle doesn't support it and jOOQ doesn't emulate it in Oracle syntax. A solution consists of implementing our own <strong class="source-inline">ParseListener</strong> that can emulate the <strong class="source-inline">CONCAT_WS()</strong> effect. For instance, the following <strong class="source-inline">ParseListener</strong> accomplishes this via the <strong class="source-inline">NVL2()</strong> function (please<a id="_idIndexMarker1773"/> read all comments in the code in order to <a id="_idIndexMarker1774"/>get you familiar with this API):</p>
			<pre class="source-code">public class MyParseListener extends DefaultParseListener {</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public Field parseField(ParseContext pcx) {</pre>
			<pre class="source-code">  if (pcx.parseFunctionNameIf("CONCAT_WS")) {</pre>
			<pre class="source-code">   pcx.parse('(');</pre>
			<pre class="source-code">   String separator = pcx.parseStringLiteral();            </pre>
			<pre class="source-code">   pcx.parse(',');</pre>
			<pre class="source-code">   // extract the variadic list of fields</pre>
			<pre class="source-code">   List&lt;Field&lt;?&gt;&gt; fields = pcx.parseList(",", </pre>
			<pre class="source-code">       c -&gt; c.parseField()); </pre>
			<pre class="source-code">   pcx.parse(')'); // the function CONCAT_WS() was parsed      </pre>
			<pre class="source-code">   ...</pre>
			<p>After <a id="_idIndexMarker1775"/>parsing, we<a id="_idIndexMarker1776"/> prepare the Oracle emulation:</p>
			<pre class="source-code">   ...</pre>
			<pre class="source-code">   // prepare the Oracle emulation</pre>
			<pre class="source-code">   return CustomField.of("", SQLDataType.VARCHAR, f -&gt; {</pre>
			<pre class="source-code">    switch (f.family()) {</pre>
			<pre class="source-code">     case ORACLE -&gt; {</pre>
			<pre class="source-code">      Field result = inline("");</pre>
			<pre class="source-code">      for (Field&lt;?&gt; field : fields) {</pre>
			<pre class="source-code">       result = result.concat(DSL.nvl2(field,</pre>
			<pre class="source-code">                  inline(separator).concat(</pre>
			<pre class="source-code">                    field.coerce(String.class)), field));</pre>
			<pre class="source-code">      }</pre>
			<pre class="source-code">      f.visit(result); // visit this QueryPart</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">     // case other dialect ...    </pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">   });</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  // pass control to jOOQ</pre>
			<pre class="source-code">  return null;</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>To keep the code simple and short, we have considered some assumptions. Mainly, the separator and string literals should be enclosed in single quotes, the separator itself is a single character, and it should be at least one argument after the separator.</p>
			<p>This time, when we do this:</p>
			<pre class="source-code">String sql = ctx.configuration().derive(SQLDialect.ORACLE)</pre>
			<pre class="source-code">  .dsl()</pre>
			<pre class="source-code">  .render(ctx.parser().parseQuery("""</pre>
			<pre class="source-code">   SELECT concat_ws('|', city, address_line_first,  </pre>
			<pre class="source-code">     address_line_second, country, territory) AS address </pre>
			<pre class="source-code">   FROM office"""));</pre>
			<pre class="source-code">ctx.resultQuery(sql).fetch();</pre>
			<p>Our parser (followed <a id="_idIndexMarker1777"/>by the jOOQ parser) produces this SQL<a id="_idIndexMarker1778"/> compatible with Oracle syntax:</p>
			<pre class="source-code">SELECT ((((('' || nvl2(CITY, ('|' || CITY), CITY)) || </pre>
			<pre class="source-code">  nvl2(ADDRESS_LINE_FIRST, ('|' || ADDRESS_LINE_FIRST),   </pre>
			<pre class="source-code">       ADDRESS_LINE_FIRST)) || </pre>
			<pre class="source-code">  nvl2(ADDRESS_LINE_SECOND, ('|' || ADDRESS_LINE_SECOND), </pre>
			<pre class="source-code">       ADDRESS_LINE_SECOND)) || </pre>
			<pre class="source-code">  nvl2(COUNTRY, ('|' || COUNTRY), COUNTRY)) || </pre>
			<pre class="source-code">  nvl2(TERRITORY, ('|' || TERRITORY), TERRITORY)) ADDRESS</pre>
			<pre class="source-code">FROM OFFICE</pre>
			<p>You can practice this example in <em class="italic">A250ParseListener</em> for Oracle (for Spring Boot 2.5.0+), and in <em class="italic">B250ParseListener</em> for Oracle (for Spring Boot prior 2.5.0). Besides parsing fields (<strong class="source-inline">Field</strong>), <strong class="source-inline">ParseListener</strong> can also parse tables (<strong class="source-inline">org.jooq.Table</strong> via <strong class="source-inline">parseTable()</strong>) and conditions (<strong class="source-inline">org.jooq.Condition</strong> via <strong class="source-inline">parseCondition()</strong>).</p>
			<p>If you prefer<a id="_idIndexMarker1779"/> functional <a id="_idIndexMarker1780"/>composition, then check out <strong class="source-inline">CallbackParseListener</strong>. Next, let's quickly cover other jOOQ listeners.</p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor349"/>RecordListener</h2>
			<p>Via the<a id="_idIndexMarker1781"/> jOOQ <strong class="source-inline">RecordListener</strong> implementations, we<a id="_idIndexMarker1782"/> can add custom behavior during <strong class="source-inline">UpdatableRecord</strong> events such as insert, update, delete, store, and refresh (if you are not familiar with <strong class="source-inline">UpdatableRecord</strong>, then consider <a href="B16833_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">jOOQ Core Concepts</em>).</p>
			<p>For each <em class="italic">event</em> listen by <strong class="source-inline">RecordListener</strong> we have an <strong class="source-inline">eventStart()</strong> and <strong class="source-inline">eventEnd()</strong> method. <strong class="source-inline">eventStart()</strong> is a callback invoked before the <em class="italic">event</em> takes place, while the <strong class="source-inline">eventEnd()</strong> callback is invoked after the <em class="italic">event</em> has happened.</p>
			<p>For instance, let's consider that every time an <strong class="source-inline">EmployeeRecord</strong> is inserted, we have an algorithm that generates the primary key, <strong class="source-inline">EMPLOYEE_NUMBER</strong>. Next, the <strong class="source-inline">EXTENSION</strong> field is always of type <em class="italic">xEmployee_number</em> (for instance, if <strong class="source-inline">EMPLOYEE_NUMBER</strong> is <em class="italic">9887</em> then <strong class="source-inline">EXTENSION</strong> is <em class="italic">x9887</em>). Since we don't want to let people do this task manually, we can easily automate this process via <strong class="source-inline">RecordListener</strong> as follows:</p>
			<pre class="source-code">public class MyRecordListener extends DefaultRecordListener {</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void insertStart(RecordContext rcx) {</pre>
			<pre class="source-code">  if (rcx.record() instanceof EmployeeRecord employee) {</pre>
			<pre class="source-code">   // call the secret algorithm that produces the PK</pre>
			<pre class="source-code">   long secretNumber = (long) (10000 * Math.random());</pre>
			<pre class="source-code">   employee.setEmployeeNumber(secretNumber);</pre>
			<pre class="source-code">   employee.setExtension("x" + secretNumber);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">} </pre>
			<p>Probably worth mentioning, <strong class="source-inline">RecordListener</strong> doesn't apply to ordinary DML statements (let alone plain SQL templates). People often think they can add some security stuff in there, which is then bypassed. It really only works on <strong class="source-inline">TableRecord</strong>/<strong class="source-inline">UpdatableRecord</strong> types. Starting from jOOQ 3.16, a lot of tasks that are currently solved with <strong class="source-inline">RecordListener</strong> are probably better solved with <strong class="source-inline">VisitListener</strong>, which will become *much* more powerful once the new query object model is in place (<a href="https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/">https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/</a>). In jOOQ 3.16, it won't be ready for this task yet, but it might be in jOOQ 3.17.</p>
			<p>You can <a id="_idIndexMarker1783"/>practice <a id="_idIndexMarker1784"/>this application in <em class="italic">{A,B}250RecordListener1</em> for MySQL. Moreover, you can find the <em class="italic">{A,B}250RecordListener2</em> application for MySQL, which extends this one by overriding <strong class="source-inline">insertEnd()</strong> to automatically insert a row in <strong class="source-inline">EMPLOYEE_STATUS</strong> based on the inserted <strong class="source-inline">EmployeeRecord</strong>:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void insertEnd(RecordContext rcx) {</pre>
			<pre class="source-code">  if (rcx.record() instanceof EmployeeRecord employee) {</pre>
			<pre class="source-code">   EmployeeStatusRecord status = </pre>
			<pre class="source-code">      rcx.dsl().newRecord(EMPLOYEE_STATUS);</pre>
			<pre class="source-code">   status.setEmployeeNumber(employee.getEmployeeNumber());</pre>
			<pre class="source-code">   status.setStatus("REGULAR");</pre>
			<pre class="source-code">   status.setAcquiredDate(LocalDate.now());</pre>
			<pre class="source-code">   status.insert();</pre>
			<pre class="source-code"> }        </pre>
			<pre class="source-code">}        </pre>
			<p>If you prefer<a id="_idIndexMarker1785"/> functional <a id="_idIndexMarker1786"/>composition, then check out <strong class="source-inline">CallbackRecordListener</strong>.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor350"/>DiagnosticsListener</h2>
			<p><strong class="source-inline">DiagnosticsListener</strong> is<a id="_idIndexMarker1787"/> available from jOOQ 3.11 and <a id="_idIndexMarker1788"/>it fits perfectly in scenarios where you want to detect inefficiencies in your database interaction. This listener can act at different levels, such as jOOQ, JDBC, and SQL levels.</p>
			<p>Mainly, this listener exposes a suite of callbacks (one callback per problem it detects). For instance, we have <strong class="source-inline">repeatedStatements()</strong> for detecting N+1 problems, <strong class="source-inline">tooManyColumnsFetched()</strong> for detecting whether <strong class="source-inline">ResultSet</strong> fetches more columns than necessary, <strong class="source-inline">tooManyRowsFetched()</strong> for detecting whether <strong class="source-inline">ResultSet</strong> fetches more rows than necessary, and so on (you can find all of them in the documentation).</p>
			<p>Let's assume a Spring Data JPA application that runs the following classical N+1 scenario (the <strong class="source-inline">Productline</strong> and <strong class="source-inline">Product</strong> entities are involved in a lazy bidirectional <strong class="source-inline">@OneToMany</strong> relationship):</p>
			<pre class="source-code">@Transactional(readOnly = true)</pre>
			<pre class="source-code">public void fetchProductlinesAndProducts() {</pre>
			<pre class="source-code">  List&lt;Productline&gt; productlines </pre>
			<pre class="source-code">   = productlineRepository.findAll();</pre>
			<pre class="source-code">  for (Productline : productlines) {</pre>
			<pre class="source-code">   List&lt;Product&gt; products = productline.getProducts();</pre>
			<pre class="source-code">   System.out.println("Productline: " </pre>
			<pre class="source-code">    + productline.getProductLine()</pre>
			<pre class="source-code">    + " Products: " + products);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>So, there is a <strong class="source-inline">SELECT</strong> triggered for fetching the product lines, and for each product line, there <a id="_idIndexMarker1789"/>is a <strong class="source-inline">SELECT</strong> for fetching its products. Obviously, in <a id="_idIndexMarker1790"/>performance terms, this is not efficient, and jOOQ can signal this via a custom <strong class="source-inline">DiagnosticsListener</strong> as shown next:</p>
			<pre class="source-code">public class MyDiagnosticsListener </pre>
			<pre class="source-code">         extends DefaultDiagnosticsListener {    </pre>
			<pre class="source-code"> private static final Logger = ...;   </pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void repeatedStatements(DiagnosticsContext dcx) {</pre>
			<pre class="source-code">  log.warning(() -&gt;</pre>
			<pre class="source-code">   "These queries are prone to be a N+1 case: \n" </pre>
			<pre class="source-code">     + dcx.repeatedStatements());        </pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>Now, the previous N+1 case will be logged, so you have been warned!</p>
			<p>jOOQ can diagnose over a <strong class="source-inline">java.sql.Connection</strong> (<strong class="source-inline">diagnosticsConnection()</strong>) or a <strong class="source-inline">javax.sql.DataSource</strong> (<strong class="source-inline">diagnosticsDataSource()</strong> wraps a <strong class="source-inline">java.sql.Connection</strong> in a <strong class="source-inline">DataSource</strong>). Exactly as in the case of a <em class="italic">parsing connection</em>, this JDBC connection proxies the underlying connection, therefore you have to pass your SQL through this proxy. In a Spring Data JPA application, you can quickly improvise a diagnose profile that relies on a <strong class="source-inline">SingleConnectionDataSource</strong>, as you can see in <em class="italic">JPADiagnosticsListener</em> for MySQL. The same case is available in <em class="italic">SDJDBCDiagnosticsListener</em> for MySQL, which wraps a Spring Data JDBC application. Also, the<a id="_idIndexMarker1791"/> jOOQ <a id="_idIndexMarker1792"/>manual has some cool JDBC examples that you should check (<a href="https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/">https://www.jooq.org/doc/latest/manual/sql-execution/diagnostics/</a>).</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor351"/>TransactionListener</h2>
			<p>As its <a id="_idIndexMarker1793"/>name <a id="_idIndexMarker1794"/>suggests, <strong class="source-inline">TransactionListener</strong> provides hooks for interfering with transaction events such as begin, commit, and rollback. For each such <em class="italic">event</em>, there is an <strong class="source-inline">eventBegin()</strong>, called before the <em class="italic">event</em>, and an <strong class="source-inline">eventEnd()</strong>, called after the <em class="italic">event</em>. Moreover, for functional composition purposes, there is <strong class="source-inline">CallbackTransactionListener</strong>.</p>
			<p>Let's consider a scenario that requires us to back up the data after each update of <strong class="source-inline">EmployeeRecord</strong>. By "back up," we understand that we need to save an <strong class="source-inline">INSERT</strong> containing the data before this update in the file corresponding to the employee to be updated.</p>
			<p><strong class="source-inline">TransactionListener</strong> doesn't expose information about the underlying SQL, therefore we cannot determine whether <strong class="source-inline">EmployeeRecord</strong> is updated or not from inside of this listener. But, we can do it from <strong class="source-inline">RecordListener</strong> and the <strong class="source-inline">updateStart()</strong> callback. When an <strong class="source-inline">UPDATE</strong> occurs, <strong class="source-inline">updateStart()</strong> is called and we can inspect the record type. If it is an <strong class="source-inline">EmployeeRecord</strong>, we can store its original (<strong class="source-inline">original()</strong>) state via <strong class="source-inline">data()</strong> as follows:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public void updateStart(RecordContext rcx) {</pre>
			<pre class="source-code">  if (rcx.record() instanceof EmployeeRecord) {</pre>
			<pre class="source-code">   EmployeeRecord employee = </pre>
			<pre class="source-code">    (EmployeeRecord) rcx.record().original();</pre>
			<pre class="source-code">  rcx.configuration().data("employee", employee);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Now, you may think that, at the update end (<strong class="source-inline">updateEnd()</strong>), we can write the <strong class="source-inline">EmployeeRecord</strong> original state in the proper file. But a transaction can be rolled back, and<a id="_idIndexMarker1795"/> in <a id="_idIndexMarker1796"/>such a case, we should roll back the entry from the file as well. Obviously, this is cumbersome. It will be much easier to alter the file only after the transaction commits, so when we are sure that the update succeeded. Here is where <strong class="source-inline">TransactionListener</strong> and <strong class="source-inline">commitEnd()</strong> become useful:</p>
			<pre class="source-code">public class MyTransactionListener </pre>
			<pre class="source-code">      extends DefaultTransactionListener {</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void commitEnd(TransactionContext tcx) {</pre>
			<pre class="source-code">  EmployeeRecord employee = </pre>
			<pre class="source-code">    (EmployeeRecord) tcx.configuration().data("employee");</pre>
			<pre class="source-code">  if (employee != null) {</pre>
			<pre class="source-code">    // write to file corresponding to this employee</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>Cool, right!? You<a id="_idIndexMarker1797"/> just saw how to combine two listeners to <a id="_idIndexMarker1798"/>accomplish a common task. Check the source in <em class="italic">{A,B}250RecordTransactionListener</em> for MySQL.</p>
			<h2 id="_idParaDest-353"><a id="_idTextAnchor352"/>VisitListener</h2>
			<p>The last listener<a id="_idIndexMarker1799"/> that we'll briefly cover is probably the most <a id="_idIndexMarker1800"/>complex one, <strong class="source-inline">VisitListener</strong>. Mainly, <strong class="source-inline">VisitListener</strong> is a listener that allows us to manipulate the jOOQ <strong class="bold">Abstract Syntax Tree</strong> (<strong class="bold">AST</strong>), which<a id="_idIndexMarker1801"/> contains query parts (<strong class="source-inline">QueryPart</strong>) and clauses (<strong class="source-inline">Clause</strong>). So, we can visit <strong class="source-inline">QueryPart</strong> (via <strong class="source-inline">visitStart()</strong> and <strong class="source-inline">visitEnd()</strong>) and <strong class="source-inline">Clause</strong> (via <strong class="source-inline">clauseStart()</strong> and <strong class="source-inline">clauseEnd()</strong>).</p>
			<p>A very simple example could be like this: we want to create some views via the jOOQ DSL (<strong class="source-inline">ctx.createOrReplaceView("product_view").as(...).execute()</strong>) and we also want to add them to the <strong class="source-inline">WITH CHECK OPTION</strong> clause. Since the jOOQ DSL doesn't support this clause, we can do it via <strong class="source-inline">VisitListener</strong> as follows:</p>
			<pre class="source-code">public class MyVisitListener extends DefaultVisitListener {</pre>
			<pre class="source-code"> @Override</pre>
			<pre class="source-code"> public void clauseEnd(VisitContext vcx) {</pre>
			<pre class="source-code">  if (vcx.clause().equals(CREATE_VIEW_AS)) {</pre>
			<pre class="source-code">    vcx.context().formatSeparator()</pre>
			<pre class="source-code">       .sql("WITH CHECK OPTION");</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code"> }</pre>
			<pre class="source-code">}</pre>
			<p>While you can practice this trivial example in<em class="italic"> {A,B}250VisitListener</em> for MySQL, I strongly recommend you read these two awesome articles from the jOOQ blog as well: <a href="https://blog.jooq.org/implementing-client-side-row-level-security-with-jooq/">https://blog.jooq.org/implementing-client-side-row-level-security-with-jooq/</a> and <a href="https://blog.jooq.org/jooq-internals-pushing-up-sql-fragments/">https://blog.jooq.org/jooq-internals-pushing-up-sql-fragments/</a>. You'll have the chance to learn a lot about the <strong class="source-inline">VisitListener</strong> API. You never know when you'll need it! For instance, you may want to implement your <em class="italic">soft deletes</em> mechanism, add a condition for each query, and so on. In such scenarios, <strong class="source-inline">VisitListener</strong> is exactly what are you looking for! Moreover, when this book was written, jOOQ started to add a new <a id="_idIndexMarker1802"/>player, called <strong class="bold">Query Object Model</strong> (<strong class="bold">QOM</strong>), as a public API. This API facilitates an easy, intuitive, and<a id="_idIndexMarker1803"/> powerful traversal of the jOOQ AST. You don't <a id="_idIndexMarker1804"/>want to miss this article: <a href="https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/">https://blog.jooq.org/traversing-jooq-expression-trees-with-the-new-traverser-api/</a>.</p>
			<p>Next, let's talk about altering the jOOQ code generation process.</p>
			<h1 id="_idParaDest-354"><a id="_idTextAnchor353"/>Altering the jOOQ code generation process</h1>
			<p>We already<a id="_idIndexMarker1805"/> know that jOOQ comes with three Code Generators (for Java, Scala, and Kotlin). For Java, we use <strong class="source-inline">org.jooq.codegen.JavaGenerator</strong>, which can be shaped/customized declaratively (or, programmatically) via a comprehensive set of configurations grouped under <strong class="source-inline">&lt;configuration&gt;</strong> (Maven), <strong class="source-inline">configurations</strong> (Gradle), or <strong class="source-inline">org.jooq.meta.jaxb.Configuration</strong>. But, sometimes, we need more control, or in other words, we need a custom generator implementation.</p>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor354"/>Implementing a custom generator</h2>
			<p>Imagine a <a id="_idIndexMarker1806"/>scenario where<a id="_idIndexMarker1807"/> we need a query method and it would be very handy if it was provided by the built-in jOOQ DAO. Obviously, the jOOQ goal is to maintain a thin DAO layer that avoids a large number of methods caused by different types of query combinations (don't expect to see in the default DAO a query method such as <strong class="source-inline">fetchByField1AndField2()</strong> since trying to cover all combinations of fields (even for only two fields) leads to a heavy DAO layer that most probably will not be fully exploited).</p>
			<p>But, we can enrich the generated DAOs via a custom generator. An important aspect is the fact that a custom generator requires a separate project (or module) that will work as a dependency for the project that is going to use it. This is needed because the generator must run at compilation time, so the way to achieve this is by adding it as a dependency. Since we use a multi-module Spring Boot application, we can easily achieve this by adding the custom generator as a separate module of the project. This is very handy since most Spring Boot production apps are developed in multi-module style.</p>
			<p>Speaking about the effective implementation of a custom generator, we have to extend the Java generator, <strong class="source-inline">org.jooq.codegen.JavaGenerator</strong>, and override the default-empty method, <strong class="source-inline">generateDaoClassFooter(TableDefinition table, JavaWriter out)</strong>. The stub code is listed next:</p>
			<pre class="source-code">public class CustomJavaGenerator extends JavaGenerator {</pre>
			<pre class="source-code">   @Override</pre>
			<pre class="source-code">   protected void generateDaoClassFooter(</pre>
			<pre class="source-code">         TableDefinition table, JavaWriter out) {</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Based on this stub code, let's generate additional DAO query methods. </p>
			<h3>Adding a query method to all DAOs</h3>
			<p>Let's <a id="_idIndexMarker1808"/>assume that we want to add a query method to all the generated DAOs, for instance, a method that limits the number of fetched POJOs (records), such as <strong class="source-inline">List&lt;POJO&gt; findLimitedTo(Integer value)</strong>, where <strong class="source-inline">value</strong> represents the number of POJOs to fetch in the <strong class="source-inline">List</strong>. Check out the code:</p>
			<pre class="source-code">01:@Override</pre>
			<pre class="source-code">02:protected void generateDaoClassFooter(</pre>
			<pre class="source-code">03:            TableDefinition table, JavaWriter out) {</pre>
			<pre class="source-code">04:</pre>
			<pre class="source-code">05:   final String pType = </pre>
			<pre class="source-code">06:    getStrategy().getFullJavaClassName(table, Mode.POJO);</pre>
			<pre class="source-code">07:</pre>
			<pre class="source-code">08:   // add a method common to all DAOs</pre>
			<pre class="source-code">09:   out.tab(1).javadoc("Fetch the number of records </pre>
			<pre class="source-code">10:                limited by &lt;code&gt;value&lt;/code&gt;");</pre>
			<pre class="source-code">11:   out.tab(1).println("public %s&lt;%s&gt; findLimitedTo(</pre>
			<pre class="source-code">12:         %s value) {", List.class, pType, Integer.class);</pre>
			<pre class="source-code">13:   out.tab(2).println("return ctx().selectFrom(%s)",  </pre>
			<pre class="source-code">14:              getStrategy().getFullJavaIdentifier(table));</pre>
			<pre class="source-code">15:   out.tab(3).println(".limit(value)");</pre>
			<pre class="source-code">16:   out.tab(3).println(".fetch(mapper());");</pre>
			<pre class="source-code">17:   out.tab(1).println("}");</pre>
			<pre class="source-code">18:}</pre>
			<p>Let's quickly see what is happening here:</p>
			<ul>
				<li>In line 5, we ask jOOQ to give the name of the generated POJO that corresponds to the current <strong class="source-inline">table</strong> and that is used in our query method to return a <strong class="source-inline">List&lt;POJO&gt;</strong>. For instance, for the <strong class="source-inline">ORDER</strong> table, <strong class="source-inline">getFullJavaClassName()</strong> returns <strong class="source-inline">jooq.generated.tables.pojos.Order</strong>. </li>
				<li>In line 9, we generate some Javadoc.</li>
				<li>In lines 11-17, we generate the method signature and its body. The <strong class="source-inline">getFullJavaIdentifier()</strong> used at line 14 gives us the fully qualified name of the current table (for example, <strong class="source-inline">jooq.generated.tables.Order.ORDER</strong>).</li>
				<li>The <strong class="source-inline">ctx()</strong> method used on line 13 and <strong class="source-inline">mapper()</strong> used in line 16 are defined in the <strong class="source-inline">org.jooq.impl.DAOImpl</strong> class. Each generated DAO extends <strong class="source-inline">DAOImpl</strong>, and therefore has access to these methods.</li>
			</ul>
			<p>Based on this code, the jOOQ generator adds at the end of each generated DAO a method as<a id="_idIndexMarker1809"/> follows (this method is added in <strong class="source-inline">OrderRepository</strong>):</p>
			<pre class="source-code">/**</pre>
			<pre class="source-code"> * Fetch the number of records limited by &lt;code&gt;value&lt;/code&gt;</pre>
			<pre class="source-code"> */</pre>
			<pre class="source-code">public List&lt;jooq.generated.tables.pojos.Order&gt;</pre>
			<pre class="source-code">                    findLimitedTo(Integer value) {</pre>
			<pre class="source-code">   return ctx().selectFrom(jooq.generated.tables.Order.ORDER)</pre>
			<pre class="source-code">               .limit(value)</pre>
			<pre class="source-code">               .fetch(mapper());</pre>
			<pre class="source-code">}</pre>
			<p>How about adding methods only in certain DAOs? </p>
			<h3>Adding a query method in certain DAOs</h3>
			<p>Let's add a <a id="_idIndexMarker1810"/>query method named <strong class="source-inline">findOrderByStatusAndOrderDate()</strong> only in the <strong class="source-inline">OrderRepository</strong> DAO. A simple and quick solution consists of checking the table name via the <strong class="source-inline">TableDefinition</strong> argument of the <strong class="source-inline">generateDaoClassFooter()</strong> method. For instance, the following code adds the <strong class="source-inline">findOrderByStatusAndOrderDate()</strong> method only in the DAO that corresponds to the <strong class="source-inline">ORDER</strong> table:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">protected void generateDaoClassFooter(</pre>
			<pre class="source-code">           TableDefinition table, JavaWriter out) {</pre>
			<pre class="source-code">   final String pType </pre>
			<pre class="source-code">      = getStrategy().getFullJavaClassName(table, Mode.POJO);</pre>
			<pre class="source-code">   // add a method specific to Order DAO</pre>
			<pre class="source-code"><strong class="bold">   if (table.getName().equals("order")) {</strong></pre>
			<pre class="source-code">      out.println("public %s&lt;%s&gt;</pre>
			<pre class="source-code">         findOrderByStatusAndOrderDate(</pre>
			<pre class="source-code">            %s statusVal, %s orderDateVal) {",</pre>
			<pre class="source-code">               List.class, pType, </pre>
			<pre class="source-code">                    String.class, LocalDate.class);</pre>
			<pre class="source-code">      ...</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>This code generates <strong class="source-inline">findOrderByStatusAndOrderDate()</strong> only in <strong class="source-inline">jooq.generated.tables.daos.OrderRepository</strong>:</p>
			<pre class="source-code">/**</pre>
			<pre class="source-code"> * Fetch orders having status &lt;code&gt;statusVal&lt;/code&gt;</pre>
			<pre class="source-code"> *  and order date after &lt;code&gt;orderDateVal&lt;/code&gt;</pre>
			<pre class="source-code"> */</pre>
			<pre class="source-code">public List&lt;jooq.generated.tables.pojos.Order&gt;</pre>
			<pre class="source-code">      findOrderByStatusAndOrderDate(String statusVal,    </pre>
			<pre class="source-code">         LocalDate orderDateVal) {</pre>
			<pre class="source-code">   return ctx().selectFrom(jooq.generated.tables.Order.ORDER)</pre>
			<pre class="source-code">      .where(jooq.generated.tables.Order.ORDER.STATUS</pre>
			<pre class="source-code">         .eq(statusVal))</pre>
			<pre class="source-code">         .and(jooq.generated.tables.Order.ORDER.ORDER_DATE</pre>
			<pre class="source-code">            .ge(orderDateVal))</pre>
			<pre class="source-code">      .fetch(mapper());</pre>
			<pre class="source-code">}</pre>
			<p>Besides <strong class="source-inline">table.getName()</strong>, you can<a id="_idIndexMarker1811"/> enforce the previous condition for more control via <strong class="source-inline">table.getCatalog()</strong>, <strong class="source-inline">table.getQualifiedName()</strong>,<strong class="source-inline">table.getSchema()</strong>, and so on. </p>
			<p>The complete example is available in <em class="italic">AddDAOMethods</em> for MySQL and Oracle.</p>
			<p>As a bonus, if you need to enrich the jOOQ-generated DAOs with the corresponding interfaces, then you need a custom generator as in the application named <em class="italic">InterfacesDao</em> for MySQL and Oracle. If you check out this code, you'll see a so-called <em class="italic">custom generator strategy</em>. Next, let's detail this aspect.</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor355"/>Writing a custom generator strategy</h2>
			<p>You already<a id="_idIndexMarker1812"/> know<a id="_idIndexMarker1813"/> how to use <strong class="source-inline">&lt;strategy&gt;</strong> (Maven), <strong class="source-inline">strategy {}</strong> (Gradle), or <strong class="source-inline">withStrategy()</strong> (programmatic) to inject custom behavior for naming classes, methods, members, and so on during the jOOQ code generation process. For instance, we have used this technique for renaming our DAO classes in Spring Data JPA style.</p>
			<p>But, overriding naming schemes during code generation can be accomplished via a custom generator strategy as well. For instance, this is useful when we want to generate certain method names as in our scenario that starts from the following query:</p>
			<pre class="source-code">ctx.select(concat(EMPLOYEE.FIRST_NAME, inline(" "),        </pre>
			<pre class="source-code">        EMPLOYEE.LAST_NAME).as("employee"),</pre>
			<pre class="source-code">        concat(EMPLOYEE.employee().FIRST_NAME, inline(" "), </pre>
			<pre class="source-code">               EMPLOYEE.employee().LAST_NAME).as("reports_to"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.JOB_TITLE.eq(</pre>
			<pre class="source-code">          EMPLOYEE.employee().JOB_TITLE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>This is a self-join that relies on the <strong class="source-inline">employee()</strong> navigation method. Conforming to the default generator strategy, writing a self-join is done via a navigation method having the same name as the table itself (for the <strong class="source-inline">EMPLOYEE</strong> table, we have the <strong class="source-inline">employee()</strong> method).</p>
			<p>But, if you find <strong class="source-inline">EMPLOYEE.employee()</strong> a little bit confusing, and you prefer something more meaningful, such as <strong class="source-inline">EMPLOYEE.reportsTo()</strong> (or something else), then you need a custom generator strategy. This can be accomplished by extending the jOOQ <strong class="source-inline">DefaultGeneratorStrategy</strong> and overriding the proper methods described in the jOOQ manual: <a href="https://www.jooq.org/doc/latest/manual/code-generation/codegen-generatorstrategy/">https://www.jooq.org/doc/latest/manual/code-generation/codegen-generatorstrategy/</a>.</p>
			<p>So, in our case, we need to override <strong class="source-inline">getJavaMethodName()</strong> as follows:</p>
			<pre class="source-code">public class MyGeneratorStrategy </pre>
			<pre class="source-code">        extends DefaultGeneratorStrategy {</pre>
			<pre class="source-code">  @Override</pre>
			<pre class="source-code">  public String getJavaMethodName(</pre>
			<pre class="source-code">        Definition, Mode mode) {</pre>
			<pre class="source-code">   if (definition.getQualifiedName()</pre>
			<pre class="source-code">         .equals("classicmodels.employee") </pre>
			<pre class="source-code">            &amp;&amp; mode.equals(Mode.DEFAULT)) {</pre>
			<pre class="source-code">       return "reportsTo";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   return super.getJavaMethodName(definition, mode);</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>Finally, we <a id="_idIndexMarker1814"/>have to set <a id="_idIndexMarker1815"/>this custom generator strategy as follows (here, for Maven, but you can easily intuit how to do it for Gradle or programmatically):</p>
			<pre class="source-code">&lt;generator&gt;</pre>
			<pre class="source-code"> &lt;strategy&gt;</pre>
			<pre class="source-code">  &lt;name&gt;</pre>
			<pre class="source-code">   com.classicmodels.strategy.MyGeneratorStrategy</pre>
			<pre class="source-code">  &lt;/name&gt;</pre>
			<pre class="source-code"> &lt;/strategy&gt;</pre>
			<pre class="source-code">&lt;/generator&gt;</pre>
			<p>Done! Now, after code generation, you can re-write the previous query as follows (notice the <strong class="source-inline">reportsTo()</strong> method instead of <strong class="source-inline">employee()</strong>):</p>
			<pre class="source-code">ctx.select(concat(EMPLOYEE.FIRST_NAME, inline(" "), </pre>
			<pre class="source-code">         EMPLOYEE.LAST_NAME).as("employee"),</pre>
			<pre class="source-code">         concat(EMPLOYEE.reportsTo().FIRST_NAME, inline(" "), </pre>
			<pre class="source-code">            EMPLOYEE.reportsTo().LAST_NAME).as("reports_to"))</pre>
			<pre class="source-code">   .from(EMPLOYEE)</pre>
			<pre class="source-code">   .where(EMPLOYEE.JOB_TITLE.eq(gma</pre>
			<pre class="source-code">          EMPLOYEE.reportsTo().JOB_TITLE))</pre>
			<pre class="source-code">   .fetch();</pre>
			<p>The jOOQ Java default generator strategy <a id="_idIndexMarker1816"/>follows the <em class="italic">Pascal</em> naming strategy, which is the most popular in the Java language. But, besides the <em class="italic">Pascal</em> naming strategy, jOOQ also comes with a <strong class="source-inline">KeepNamesGeneratorStrategy</strong> custom generator strategy that simply<a id="_idIndexMarker1817"/> holds <a id="_idIndexMarker1818"/>names in place. Moreover, you may like to study <strong class="source-inline">JPrefixGeneratorStrategy</strong>, respectively the <strong class="source-inline">JVMArgsGeneratorStrategy</strong>. These are just some examples (they are not part of the jOOQ Code Generator) that can be found on GitHub at <a href="https://github.com/jOOQ/jOOQ/tree/main/jOOQ-codegen/src/main/java/org/jooq/codegen/example">https://github.com/jOOQ/jOOQ/tree/main/jOOQ-codegen/src/main/java/org/jooq/codegen/example</a>.</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor356"/>Summary</h1>
			<p>In this chapter, we have briefly covered the jOOQ SPI. Obviously, the tasks solved via an SPI are not daily tasks and require overall solid knowledge about the underlying technology. But, since you have read earlier chapters in this book, you should have no problems assimilating the knowledge in this chapter as well. But, of course, using this SPI to solve real problems requires more study of the documentation and more practice. </p>
			<p>In the next chapter, we tackle logging and testing jOOQ applications.</p>
		</div>
	</body></html>