["```java\npackage packt.java9.by.example.mybusiness.bulkorder.controllers; \n\nimport ... \n\n@RestController \npublic class OrderController { \n    private Logger log = \n                LoggerFactory.getLogger(OrderController.class); \n    private final Checker checker; \n\n    public OrderController(@Autowired Checker checker) { \n        this.checker = checker; \n    } \n\n    @RequestMapping(\"/order\") \n    public Confirmation getProductInformation(@RequestBody Order order) { \n        if (checker.isConsistent(order)) { \n            return Confirmation.accepted(order); \n        } else { \n            return Confirmation.refused(order); \n        } \n    } \n}\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.dtos; \nimport ...; \npublic class Order { \n    private String orderId; \n    private List<OrderItem> items; \n    private String customerId; \n\n... setters and getters ... \n}\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.dtos; \n\npublic class OrderItem { \n    private double amount; \n    private String unit; \n    private String productId; \n\n... setters and getters ... \n}\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.dtos; \n\npublic class Confirmation { \n    private final Order order; \n    private final boolean accepted; \n\n    private Confirmation(Order order, boolean accepted) { \n        this.order = order; \n        this.accepted = accepted; \n    } \n\n    public static Confirmation accepted(Order order) { \n        return new Confirmation(order, true); \n    } \n\n    public static Confirmation refused(Order order) { \n        return new Confirmation(order, false); \n    } \n\n    public Order getOrder() { \n        return order; \n    } \n\n    public boolean isAccepted() { \n        return accepted; \n    } \n}\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder; \n\nimport ... \npublic interface ConsistencyChecker { \n    boolean isInconsistent(Order order); \n}\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.checkers; \n\nimport java.lang.annotation.Retention; \nimport java.lang.annotation.RetentionPolicy; \n\n@Retention(RetentionPolicy.RUNTIME) \npublic @interface PoweredDevice { \n}\n\n```", "```java\npublic @interface ParameteredPoweredDevice { \n    String myParameter(); \n}\n\n```", "```java\n@Component \n@ParameteredPoweredDevice(myParameter = \"1966\") \npublic class NeedPowercord implements ConsistencyChecker { \n...\n\n```", "```java\npublic @interface ParameteredPoweredDevice{ \n    String value(); \n} \n... \n@Component \n@ParameteredPoweredDevice(\"1966\") \npublic class NeedPowercord implements ConsistencyChecker { \n...\n\n```", "```java\npublic @interface ParameteredPoweredDevice { \n    String value() default \"\"; \n}\n\n```", "```java\nString[] value();\n\n```", "```java\n@ParameteredPoweredDevice({\"1966\",\"1967\",\"1991\"})\n\n```", "```java\n@ParameteredPoweredDevice(\"1966\")\n\n```", "```java\n@Retention(RetentionPolicy.RUNTIME) \npublic @interface PoweredDevices { \nParameteredPoweredDevice[] value() default {}; \n}\n\n```", "```java\n@PoweredDevices( \n        {@ParameteredPoweredDevice(\"1956\"), @ParameteredPoweredDevice({\"1968\", \"2018\"})} \n)\n\n```", "```java\n... \n@Repeatable(PoweredDevices.class) \npublic @interface ParameteredPoweredDevice { \n...\n\n```", "```java\n... \n@ParameteredPoweredDevice(\"1956\") \n@ParameteredPoweredDevice({\"1968\", \"2018\"}) \npublic class NeedPowercord implements ConsistencyChecker { \n... \n\n@PoweredDevices( \n        {@ParameteredPoweredDevice(\"1956\"), @ParameteredPoweredDevice({\"1968\", \"2018\"})} \n) \npublic class NeedPowercord implements ConsistencyChecker { \n...\n\n```", "```java\nprivate List<Class<? extends Annotation>> check;\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.services; \n\nimport ... \n\n@Service \npublic class ResourceBasedProductLookup implements ProductLookup { \n    private static final Logger log = LoggerFactory.getLogger(ResourceBasedProductLookup.class); \n\n    private ProductInformation fromJSON(InputStream jsonStream) \n                                              throws IOException { \n        ObjectMapper mapper = new ObjectMapper(); \n        return mapper.readValue(jsonStream, \n                                   ProductInformation.class); \n    } \n\n... \n    private void loadProducts() { \n        if (productsAreNotLoaded) { \n            try { \n                Resource[] resources =  \n                     new PathMatchingResourcePatternResolver(). \n                        getResources(\"classpath:products/*.json\"); \n                for (Resource resource : resources) { \n                    loadResource(resource); \n                } \n                productsAreNotLoaded = false; \n            } catch (IOException ex) { \n                log.error(\"Test resources can not be read\", ex); \n            } \n        } \n    } \n\n    private void loadResource(Resource resource) \n                                       throws IOException { \n        final int dotPos = \n                      resource.getFilename().lastIndexOf('.'); \n        final String id = \n                      resource.getFilename().substring(0, dotPos); \n        final ProductInformation pi = \n                      fromJSON(resource.getInputStream()); \n        pi.setId(id); \n        products.put(id, pi); \n    } \n...\n\n```", "```java\n{ \n  \"id\" : \"124\", \n  \"title\": \"Desk Lamp\", \n  \"check\": [ \n    \"packt.java9.by.example.mybusiness.bulkorder.checkers.PoweredDevice\" \n  ], \n  \"description\": \"this is a lamp that stands on my desk\", \n  \"weight\": \"600\", \n  \"size\": [ \"300\", \"20\", \"2\" ] \n}\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.services; \n\nimport ... \n\n@Component() \n@RequestScope \npublic class Checker { \n    private static final Logger log = \n                        LoggerFactory.getLogger(Checker.class); \n\n    private final Collection<ConsistencyChecker> checkers; \n    private final ProductInformationCollector piCollector; \n    private final ProductsCheckerCollector pcCollector; \n\n    public Checker( \n              @Autowired Collection<ConsistencyChecker> checkers, \n              @Autowired ProductInformationCollector piCollector, \n              @Autowired ProductsCheckerCollector pcCollector) { \n        this.checkers = checkers; \n        this.piCollector = piCollector; \n        this.pcCollector = pcCollector; \n    } \n\n    public boolean isConsistent(Order order) { \n        Map<OrderItem, ProductInformation> map = \n                piCollector.collectProductInformation(order); \n        if (map == null) { \n            return false; \n        } \n        Set<Class<? extends Annotation>> annotations =  \n                pcCollector.getProductAnnotations(order); \n        for (ConsistencyChecker checker :  \n                checkers) { \n            for (Annotation annotation :  \n                    checker.getClass().getAnnotations()) { \n                if (annotations.contains( \n                                 annotation.annotationType())) { \n                    if (checker.isInconsistent(order)) { \n                        return false; \n                    } \n                    break; \n                } \n            } \n        } \n        return true; \n    } \n}\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.checkers; \n\nimport ... \n@Component \n@PoweredDevice \npublic class NeedPowercord implements ConsistencyChecker { \n    private static final Logger log = \n               LoggerFactory.getLogger(NeedPowercord.class); \n\n    @Override \n    public boolean isInconsistent(Order order) { \n        log.info(\"checking order {}\", order); \n        CheckHelper helper = new CheckHelper(order); \n        return !helper.containsOneOf(\"126\", \"127\", \"128\"); \n    } \n}\n\n```", "```java\npublic boolean containsOneOf(String... ids) { \n    for (final OrderItem item : order.getItems()) { \n        for (final String id : ids) { \n            if (item.getProductId().equals(id)) { \n                return true; \n            } \n        } \n    } \n    return false; \n}\n\n```", "```java\nprivate boolean isInconsistent(ConsistencyChecker checker, Order order) { \n    Method[] methods = checker.getClass().getDeclaredMethods(); \n    if (methods.length != 1) { \n        log.error( \n                \"The checker {} has zero or more than one methods\", \n                checker.getClass()); \n        return false; \n    } \n    final Method method = methods[0]; \n    final boolean inconsistent; \n    try { \n        inconsistent = (boolean) method.invoke(checker, order); \n    } catch (InvocationTargetException | \n            IllegalAccessException | \n            ClassCastException e) { \n        log.error(\"Calling the method {} on class {} threw exception\", \n                method, checker.getClass()); \n        log.error(\"The exception is \", e); \n        return false; \n    } \n    return inconsistent; \n}\n\n```", "```java\nMethod[] methods = checker.getClass().getDeclaredMethods(); \nif (methods.length != 1) { \n... \n} \nfinal Method method = methods[0];\n\n```", "```java\nfinal Method method = getSingleDeclaredPublicMethod(checker); \nif (method == null) { \n    log.error( \n            \"The checker {} has zero or more than one methods\", \n            checker.getClass()); \n    return false; \n\n}\n\n```", "```java\nprivate Method getSingleDeclaredPublicMethod( \n                           ConsistencyChecker checker) { \n    final Method[] methods = \n        checker.getClass().getDeclaredMethods(); \n    Method singleMethod = null; \n    for (Method method : methods) { \n        if (Modifier.isPublic(method.getModifiers())) { \n            if (singleMethod != null) { \n                return null; \n            } \n            singleMethod = method; \n        } \n    } \n    return singleMethod; \n}\n\n```", "```java\nmethod.setAccessible(true);\n\n```", "```java\n@Component \n@PoweredDevice \npublic class SettableChecker implements ConsistencyChecker { \n    private static final Logger log = LoggerFactory.getLogger(SettableChecker.class); \n\n    private boolean setValue = false; \n\n    public boolean isInconsistent(Order order) { \n        return setValue; \n    } \n}\n\n```", "```java\nprivate void setValueInChecker(ConsistencyChecker checker) { \n    Field[] fields = checker.getClass().getDeclaredFields(); \n    for( final Field field : fields ){ \n        if( field.getName().equals(\"setValue\") && \n            field.getType().equals(boolean.class)){ \n            field.setAccessible(true); \n            try { \n                log.info(\"Setting field to true\"); \n                field.set(checker,true); \n            } catch (IllegalAccessException e) { \n                log.error(\"SNAFU\",e); \n            } \n        } \n    } \n}\n\n```", "```java\nsort.setComparator((String a, String b) -> { \n        throw new RuntimeException(); \n    });\n\n```", "```java\npublic class ExceptionThrowingComparator implements Comparator { \n  public int compare(T o1, T o2){ \n    throw new RuntimeException(); \n  } \n}\n\n```", "```java\nsort.setComparator(new ExceptionThrowingComparator());\n\n```", "```java\nparameters -> body\n\n```", "```java\nsort.setComparator((a, b) -> { \n    throw new RuntimeException(); \n});\n\n```", "```java\nIntStream.iterate( 0, (s) -> s+1 )\n\n```", "```java\nfor (ConsistencyChecker checker :checkers) { \n  for (Annotation annotation : \nchecker.getClass().getAnnotations()) { \nArrays.stream(annotation.getClass().getInterfaces()) \n.forEach( \nt ->log.info(\"annotation implemented interfaces {}\",t) \n); \n...\n\n```", "```java\npublic class ProductsCheckerCollector { \n\n    private final ProductInformationCollector pic; \n    public ProductsCheckerCollector(@Autowired \n      ProductInformationCollector pic) { this.pic = pic; } \n\n    public Set<Class<? extends Annotation>> \n                       getProductAnnotations(Order order) { \n        Map<OrderItem, ProductInformation> piMap = \n                          pic.collectProductInformation(order); \n        final Set<Class<? extends Annotation>> \n                            annotations = new HashSet<>(); \n        for (OrderItem item : order.getItems()) { \n            final ProductInformation pi = piMap.get(item); \n            if (pi != null && pi.getCheck() != null) { \n                for (Class<? extends Annotation> check : \n                                              pi.getCheck()) { \n                    annotations.addAll(pi.getCheck()); \n                } \n        } \n        return annotations; \n    } \n}\n\n```", "```java\npublic Set<Class<? extends Annotation>> \n                getProductAnnotations(Order order) { \n    Map<OrderItem, ProductInformation> piMap = \n                      pic.collectProductInformation(order); \n\n    return order.getItems().stream() \n            .map(piMap::get) \n            .filter(Objects::nonNull) \n            .peek(pi -> { \n                if (pi.getCheck() == null) { \n                    log.info(\"Product {} has no annotation\", \n                                                  pi.getId()); \n                } \n            }) \n            .filter(pi -> pi.getCheck() != null) \n            .peek(pi -> log.info(\"Product {} is annotated with class {}\", pi.getId(), pi.getCheck())) \n            .flatMap(pi -> pi.getCheck().stream()) \n            .collect(Collectors.toSet()); \n}\n\n```", "```java\nreturnorder.getItems().stream()\n\n```", "```java\n.map(piMap::get)\n\n```", "```java\n.map( orderItem ->piMap.get(orderItem))\n\n```", "```java\n.filter(Objects::nonNull)\n\n```", "```java\n.peek(pi -> { \n    if (pi.getCheck() == null) { \n        log.info(\"Product {} has no annotation\", pi.getId()); \n    } \n})\n\n```", "```java\n.filter(pi ->pi.getCheck() != null)\n\n```", "```java\n.filter(ProductInformation::hasCheck)\n\n```", "```java\n.peek(pi -> log.info( \n     \"Product {} is annotated with class {}\", pi.getId(), \n                                            pi.getCheck()))\n\n```", "```java\n.flatMap(pi ->pi.getCheck().stream())\n\n```", "```java\n.collect(Collectors.toSet());\n\n```", "```java\nprivate Map<OrderItem, ProductInformation> map = null; \n\npublic Map<OrderItem, ProductInformation>  \n                  collectProductInformation(Order order) { \n    if (map == null) { \n        map = new HashMap<>(); \n        for (OrderItem item : order.getItems()) { \n            final ProductInformation pi = \n                     lookup.byId(item.getProductId()); \n            if (!pi.isValid()) { \n                map = null; \n                return null; \n            } \n            map.put(item, pi); \n        } \n    } \n    return map; \n}\n\n```", "```java\npublic Map<OrderItem, ProductInformation> collectProductInformation(Order order) { \n    if (map == null) { \n        map = \n        order.getItems() \n                .stream() \n                .map(item -> tuple(item, item.getProductId())) \n                .map(t -> tuple(t.r, lookup.byId((String) t.s))) \n                .filter(t -> ((ProductInformation)t.s).isValid()) \n                .collect( \n                    Collectors.toMap( t -> (OrderItem)t.r, \n                                      t -> (ProductInformation)t.s \n                                    ) \n                ); \n        if (map.keySet().size() != order.getItems().size()) { \n            log.error(\"Some of the products in the order do not have product information, {} != {} \",map.keySet().size(),order.getItems().size()); \n            map = null; \n        } \n    } \n    return map; \n}\n\n```", "```java\npublic class Tuple<R, S> { \n    final public R r; \n    final public S s; \n\n    private Tuple(R r, S s) { \n        this.r = r; \n        this.s = s; \n    } \n\n    public static <R, S> Tuple tuple(R r, S s) { \n        return new Tuple<>(r, s); \n    } \n}\n\n```", "```java\npublic boolean isConsistent(Order order) { \n    Map<OrderItem, ProductInformation> map = \n                  piCollector.collectProductInformation(order); \n    if (map == null) { return false; } \n    final Set<Class<? extends Annotation>> annotations = \n                       pcCollector.getProductAnnotations(order); \n    return !checkers.stream().anyMatch( \n                 checker -> Arrays.stream( \n                              checker.getClass().getAnnotations() \n                            ).filter( \n                              annotation -> \n                                annotations.contains( \n                                      annotation.annotationType()) \n                            ).anyMatch( \n                              x ->  \n                                checker.isInconsistent(order) \n                            )); \n}\n\n```", "```java\npublic boolean containsOneOf(String... ids) { \n    return order.getItems().stream() \n            .map(OrderItem::getProductId) \n            .flatMap(itemId -> Arrays.stream(ids) \n                    .map(id -> tuple(itemId, id))) \n            .filter(t -> Objects.equals(t.s, t.r)) \n            .collect(Collectors.counting()) > 0; \n}\n\n```", "```java\n    private String checkScript; \n    public String getCheckScript() { \n        return checkScript; \n    } \n    public void setCheckScript(String checkScript) { \n        this.checkScript = checkScript; \n    }\n\n```", "```java\nprivate final CheckerScriptExecutor executor; \n\n    public Checker( \n        @Autowired Collection<ConsistencyChecker> checkers, \n        @Autowired ProductInformationCollector piCollector, \n        @Autowired ProductsCheckerCollector pcCollector, \n        @Autowired CheckerScriptExecutor executor ) { \n        this.checkers = checkers; \n        this.piCollector = piCollector; \n        this.pcCollector = pcCollector; \n        this.executor = executor; \n    }\n\n```", "```java\npublic boolean isConsistent(Order order) { \n        final Map<OrderItem, ProductInformation> map = \n                piCollector.collectProductInformation(order); \n        if (map == null) { \n            return false; \n        } \n        final Set<Class<? extends Annotation>> annotations = \n                pcCollector.getProductAnnotations(order); \n        Predicate<Annotation> annotationIsNeeded = annotation -> \n                annotations.contains(annotation.annotationType()); \n        Predicate<ConsistencyChecker> productIsConsistent = \n                checker -> \n                Arrays.stream(checker.getClass().getAnnotations()) \n                        .parallel().unordered() \n                        .filter(annotationIsNeeded) \n                        .anyMatch( \n                             x -> checker.isInconsistent(order)); \n        final boolean checkersSayConsistent = !checkers.stream(). \n                anyMatch(productIsConsistent); \n        final boolean scriptsSayConsistent = \n                !map.values(). \n                        parallelStream(). \n                        map(ProductInformation::getCheckScript). \n                        filter(Objects::nonNull). \n                        anyMatch(s -> \n                           executor.notConsistent(s,order)); \n        return checkersSayConsistent && scriptsSayConsistent; \n    }\n\n```", "```java\n{ \n  \"id\" : \"124\", \n  \"title\": \"Desk Lamp\", \n  \"checkScript\" : \"powered_device\", \n  \"description\": \"this is a lamp that stands on my desk\", \n  \"weight\": \"600\", \n  \"size\": [ \"300\", \"20\", \"2\" ] \n}\n\n```", "```java\nfunction isInconsistent(order){ \n    isConsistent = false \n    items = order.getItems() \n    for( i in items ){ \n    item = items[i] \n    print( item ) \n        if( item.getProductId() == \"126\" || \n            item.getProductId() == \"127\" || \n            item.getProductId() == \"128\"  ){ \n            isConsistent = true \n            } \n    } \n    return ! isConsistent \n}\n\n```", "```java\nmyBindings.put(\"globalVariable\",myObject)\n\n```", "```java\npackage packt.java9.by.example.mybusiness.bulkorder.services; \n\nimport ... \n\n@Component \npublic class CheckerScriptExecutor { \n    private static final Logger log = ... \n\n    private final ScriptEngineManager manager = \n                             new ScriptEngineManager(); \n\n    public boolean notConsistent(String script, Order order) { \n\n        try { \n            final Reader scriptReader = getScriptReader(script); \n            final Object result =  \n                         evalScript(script, order, scriptReader); \n            assertResultIsBoolean(script, result); \n            log.info(\"Script {} was executed and returned {}\", \n                                                 script, result); \n            return (boolean) result; \n\n        } catch (Exception wasAlreadyHandled) { \n            return true; \n        } \n    }\n\n```", "```java\n\n        private Reader getScriptReader(String script) \n                                throws IOException { \n        final Reader scriptReader; \n        try { \n            final InputStream scriptIS = new ClassPathResource( \n                    \"scripts/\" + script + \".js\").getInputStream(); \n            scriptReader = new InputStreamReader(scriptIS); \n        } catch (IOException ioe) { \n            log.error(\"The script {} is not readable\", script); \n            log.error(\"Script opening exception\", ioe); \n            throw ioe; \n        } \n        return scriptReader; \n    }\n\n```", "```java\n        private Object evalScript(String script, \n                              Order order, \n                              Reader scriptReader)  \n            throws ScriptException, NoSuchMethodException { \n        final Object result; \n        final ScriptEngine engine = \n                          manager.getEngineByName(\"JavaScript\"); \n        try { \n            engine.eval(scriptReader); \n            Invocable inv = (Invocable) engine; \n            result = inv.invokeFunction(\"isInconsistent\", order); \n        } catch (ScriptException | NoSuchMethodException se) { \n            log.error(\"The script {} thruw up\", script); \n            log.error(\"Script executing exception\", se); \n            throw se; \n        } \n        return result; \n    }\n\n```", "```java\n\nprivate void assertResultIsBoolean(String script, \n                                       Object result) { \n        if (!(result instanceof Boolean)) { \n            log.error(\"The script {} returned non boolean\", \n                                                    script); \n            if (result == null) { \n                log.error(\"returned value is null\"); \n            } else { \n                log.error(\"returned type is {}\", \n                                 result.getClass()); \n            } \n            throw new IllegalArgumentException(); \n        } \n    } \n}\n\n```"]