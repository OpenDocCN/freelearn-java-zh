<html><head></head><body>
<div id="_idContainer039" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor136" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-101" class="calibre6"><a id="_idTextAnchor137" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">The JVM Ecosystem and Alternative JVMs</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">The JVM is the cornerstone of Java’s </span><em class="italic"><span class="kobospan" id="kobo.4.1">write once, run anywhere</span></em><span class="kobospan" id="kobo.5.1"> philosophy, enabling the execution of Java bytecode on diverse platforms. </span><span class="kobospan" id="kobo.5.2">While the HotSpot JVM has long been the stalwart choice, the expansive JVM ecosystem extends far beyond, offering alternative implementations that cater to specific needs and performance considerations. </span><span class="kobospan" id="kobo.5.3">In this chapter, we’ll explore the JVM landscape comprehensively, delving into alternative JVMs such as OpenJ9 and Correto. </span><span class="kobospan" id="kobo.5.4">As we unravel their nuances, you will gain valuable insights into the diverse options available, each with unique features, optimizations, </span><span><span class="kobospan" id="kobo.6.1">and trade-offs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">Our journey commences with an in-depth overview of these alternative JVMs, shedding light on their architectures and critical differentiators. </span><span class="kobospan" id="kobo.7.2">Subsequent sections delve into the performance characteristics and benchmarks that distinguish these implementations, providing a nuanced understanding of how alternative JVMs stack up against the conventional HotSpot. </span><span class="kobospan" id="kobo.7.3">Through real-world performance metrics, we aim to empower you with the knowledge to make informed decisions tailored to your specific use cases. </span><span class="kobospan" id="kobo.7.4">Additionally, we’ll explore practical scenarios and use points where alternative JVMs shine, showcasing their strengths in various application domains. </span><span class="kobospan" id="kobo.7.5">This chapter will also discuss the seamless integration of these JVMs with Java applications, offering insights into compatibility, tooling support, and interoperability. </span><span class="kobospan" id="kobo.7.6">Finally, we’ll wrap up with essential considerations that guide the judicious selection of a JVM, ensuring that you are equipped to navigate the complexities of the JVM ecosystem with confidence </span><span><span class="kobospan" id="kobo.8.1">and precision.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">In this chapter, we’ll explore </span><span><span class="kobospan" id="kobo.10.1">the topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.11.1">The diversity of </span><span><span class="kobospan" id="kobo.12.1">the JVM</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.13.1">Eclipse J9</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.14.1">Amazon Corretto</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.15.1">Azul Zulu</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.16.1">IBM Semeru</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.17.1">Eclipse Temurin</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.18.1">Even more JVM vendors </span><span><span class="kobospan" id="kobo.19.1">and SDKMan</span></span></li>
</ul>
<h1 id="_idParaDest-102" class="calibre6"><a id="_idTextAnchor138" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.20.1">The diversity of the JVM</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">A</span><a id="_idIndexMarker465" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.22.1"> captivating exploration of the JVM and its remarkable tapestry is interwoven within the programming world. </span><span class="kobospan" id="kobo.22.2">While Java often takes center stage, the JVM’s true prowess lies in its versatility, extending far beyond a mere executor of Java bytecode. </span><span class="kobospan" id="kobo.22.3">Contrary to popular belief, the JVM is not a monolithic entity but a testament to diversity, accommodating a rich ecosystem of alternative implementations and vendors. </span><span class="kobospan" id="kobo.22.4">Let’s embark on a journey to uncover the manifold facets of the JVM that make it an unparalleled force in </span><span><span class="kobospan" id="kobo.23.1">software development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">Despite being the bedrock of Java, the JVM is not confined to a single language. </span><span class="kobospan" id="kobo.24.2">Its extensibility has paved the way for many programming languages to flourish under its aegis. </span><span class="kobospan" id="kobo.24.3">From Kotlin and Scala to Groovy and Clojure, the JVM acts as a unifying platform that fosters an environment where developers can seamlessly harness the power of different languages. </span><span class="kobospan" id="kobo.24.4">Moreover, the landscape of JVM distributors is a testament to the ecosystem’s robustness. </span><span class="kobospan" id="kobo.24.5">Beyond Oracle’s HotSpot JVM, there’s a tapestry of alternatives, each bringing its unique blend of optimizations, features, and licensing models. </span><span class="kobospan" id="kobo.24.6">In fact, over the JVM’s storied history, more than 20 implementations have emerged, catering to diverse needs </span><span><span class="kobospan" id="kobo.25.1">and preferences.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.26.1">One of the most remarkable aspects of the JVM is its ability to transcend the boundaries of languages and vendors. </span><span class="kobospan" id="kobo.26.2">Thanks to meticulously crafted specifications, developers can write code in one JVM implementation and confidently execute it in another, regardless of vendor disparities. </span><span class="kobospan" id="kobo.26.3">This interoperability fosters code reuse and promotes an ecosystem where innovation can thrive. </span><span class="kobospan" id="kobo.26.4">As we navigate this section, we’ll explore how the JVM’s universal bridge enables developers to compile code on one JVM and seamlessly run it on another, underscoring the platform’s adaptability </span><span><span class="kobospan" id="kobo.27.1">and resilience.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.28.1">The question of why there are multiple JVM implementations when code can seamlessly run across them is a multifaceted exploration of software development’s diverse needs and specialized contexts. </span><span class="kobospan" id="kobo.28.2">While the ability to run code across different JVMs promotes interoperability, multiple implementations stem from the desire to cater to specific use cases, optimize performance, and adapt to varying hardware and software environments. </span><span class="kobospan" id="kobo.28.3">It’s important to note that most distributions are not different JVM implementations but builds of the OpenJDK project, sometimes with slight modifications. </span><span class="kobospan" id="kobo.28.4">Additionally, all distributions must succeed in the Java </span><strong class="bold"><span class="kobospan" id="kobo.29.1">Technology Compatibility Kit</span></strong><span class="kobospan" id="kobo.30.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.31.1">TCK</span></strong><span class="kobospan" id="kobo.32.1">) (</span><a href="https://foojay.io/pedia/tck/" class="calibre4 pcalibre pcalibre1"><span class="kobospan" id="kobo.33.1">https://foojay.io/pedia/tck/</span></a><span class="kobospan" id="kobo.34.1">), ensuring they adhere to Java standards </span><a id="_idIndexMarker466" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.35.1">and maintain compatibility across the Java ecosystem. </span><span class="kobospan" id="kobo.35.2">The sources of OpenJDK are available at </span><a href="https://github.com/openjdk/jdk/" class="calibre4 pcalibre pcalibre1"><span class="kobospan" id="kobo.36.1">https://github.com/openjdk/jdk/</span></a><span class="kobospan" id="kobo.37.1">, and you can even build the runtime yourself by following the instructions in the “building” file. </span><span class="kobospan" id="kobo.37.2">This stringent requirement ensures developers can rely on consistent behavior and functionality, regardless of the distribution chosen when running their </span><span><span class="kobospan" id="kobo.38.1">Java applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">Each JVM </span><a id="_idIndexMarker467" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.40.1">possesses unique strengths that can be harnessed in specific contexts, making them powerful tools for developers. </span><span class="kobospan" id="kobo.40.2">Consider, for instance, the OpenJ9 JVM. </span><span class="kobospan" id="kobo.40.3">Its emphasis on resource efficiency and swift startup times makes it a compelling choice for cloud-based applications, where responsiveness and resource utilization are critical factors. </span><span class="kobospan" id="kobo.40.4">On the other hand, Amazon Corretto, with its focus on </span><strong class="bold"><span class="kobospan" id="kobo.41.1">long-term support</span></strong><span class="kobospan" id="kobo.42.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.43.1">LTS</span></strong><span class="kobospan" id="kobo.44.1">) and </span><a id="_idIndexMarker468" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.45.1">seamless integration with </span><strong class="bold"><span class="kobospan" id="kobo.46.1">Amazon Web Services</span></strong><span class="kobospan" id="kobo.47.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.48.1">AWS</span></strong><span class="kobospan" id="kobo.49.1">), is</span><a id="_idIndexMarker469" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.50.1"> well-suited for enterprises deeply entrenched in the </span><span><span class="kobospan" id="kobo.51.1">AWS ecosystem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.52.1">Moreover, the JVM’s adaptability extends to the hardware level. </span><span class="kobospan" id="kobo.52.2">The ability to run the same code on diverse platforms, whether on Lego Mindstorms or specific hardware such as OpenSolaris, exemplifies the JVM’s portability. </span><span class="kobospan" id="kobo.52.3">It simplifies the development process and empowers developers to create applications seamlessly transitioning between different environments without </span><span><span class="kobospan" id="kobo.53.1">compromising functionality.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">The power of each JVM lies in its ability to execute code and in the optimizations and features it brings to the table. </span><span class="kobospan" id="kobo.54.2">For instance, GraalVM, known</span><a id="_idIndexMarker470" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.55.1"> for its </span><strong class="bold"><span class="kobospan" id="kobo.56.1">just-in-time</span></strong><span class="kobospan" id="kobo.57.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.58.1">JIT</span></strong><span class="kobospan" id="kobo.59.1">) compiler and polyglot capabilities, opens the door to language interoperability, allowing developers to seamlessly integrate languages such as JavaScript, Python, and Ruby into their Java applications. </span><span class="kobospan" id="kobo.59.2">This versatility is invaluable in scenarios where diverse languages must coexist within a single </span><span><span class="kobospan" id="kobo.60.1">code base.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.61.1">In essence, the existence of multiple JVMs is a testament to the adaptability and diversity of the Java ecosystem. </span><span class="kobospan" id="kobo.61.2">Developers can leverage these implementations to tailor their choices based on performance requirements, integration needs, and the specific characteristics of the target environment. </span><span class="kobospan" id="kobo.61.3">This variety fosters innovation and ensures that the JVM remains a robust and dynamic platform that can evolve alongside the ever-changing software </span><span><span class="kobospan" id="kobo.62.1">development landscape.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">As we conclude this section on the diverse and influential landscape of the JVM, we’ve unveiled the intricacies that make it a unifying force across programming languages and hardware platforms. </span><span class="kobospan" id="kobo.63.2">The ability to seamlessly run code across multiple JVMs while maintaining compatibility underscores the flexibility and robustness of this foundational technology. </span><span class="kobospan" id="kobo.63.3">Yet, the question lingers: with such compatibility, why do we have a multitude of </span><span><span class="kobospan" id="kobo.64.1">JVM implementations?</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">The answer lies</span><a id="_idIndexMarker471" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.66.1"> in the nuanced strengths and optimizations each JVM brings to the table, catering to specific use cases, performance demands, and integration scenarios. </span><span class="kobospan" id="kobo.66.2">In the next section, we will embark on a hands-on exploration of selected JVM implementations that exemplify this diversity. </span><span class="kobospan" id="kobo.66.3">Join us as we delve into Eclipse J9, Amazon Corretto, Azul, and Eclipse Temurin and dissect their unique features, performance characteristics, and real-world applications. </span><span class="kobospan" id="kobo.66.4">Through this deep dive, we aim to equip you with the knowledge to navigate the rich tapestry of JVM choices, ensuring you can make informed decisions aligned with your </span><span><span class="kobospan" id="kobo.67.1">development </span><a id="_idTextAnchor139" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.68.1">goals.</span></span></p>
<h1 id="_idParaDest-103" class="calibre6"><a id="_idTextAnchor140" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.69.1">Eclipse J9</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.70.1">In this dedicated</span><a id="_idIndexMarker472" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.71.1"> section, we’ll delve into the capabilities of Eclipse J9, a JVM implementation that stands out for its emphasis on efficiency, scalability, and resource optimization. </span><span class="kobospan" id="kobo.71.2">As we navigate the intricacies of Eclipse J9, we’ll uncover the unique features that set it apart in the vast landscape of JVM implementations and explore why developers should consider this powerhouse for their </span><span><span class="kobospan" id="kobo.72.1">Java applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.73.1">Eclipse J9, developed by the Eclipse Foundation, represents a cutting-edge JVM implementation that’s designed to maximize efficiency and minimize resource footprint. </span><span class="kobospan" id="kobo.73.2">Known for its compact size and swift startup times, Eclipse J9 excels in critical resource utilization scenarios, making it a prime candidate for cloud-based applications, microservices, and other environments where responsiveness is paramount. </span><span class="kobospan" id="kobo.73.3">Its architecture incorporates advanced JIT compilation techniques and aggressive memory management, contributing to a nimble and </span><span><span class="kobospan" id="kobo.74.1">responsive runtime.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.75.1">Eclipse J9, as a distinguished JVM implementation, unfolds many advantages that position it as a compelling choice for discerning developers. </span><span class="kobospan" id="kobo.75.2">At the forefront is its commendable commitment to resource efficiency. </span><span class="kobospan" id="kobo.75.3">Eclipse J9’s compact footprint optimizes system resources, making it an optimal solution for applications where minimizing overhead is pivotal. </span><span class="kobospan" id="kobo.75.4">This efficiency extends to memory utilization and processor engagement, a crucial feature for applications operating in resource-constrained environments. </span><span class="kobospan" id="kobo.75.5">Swift startup times further amplify its appeal, enhancing user experience</span><a id="_idIndexMarker473" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.76.1"> and responsiveness, especially in scenarios where time-to-operation is of the essence. </span><span class="kobospan" id="kobo.76.2">Eclipse J9’s scalability is another noteworthy benefit, accommodating the dynamic demands of diverse environments, from small-scale applications to expansive enterprise systems. </span><span class="kobospan" id="kobo.76.3">As we explore the landscape of Eclipse J9, these benefits emerge as critical pillars, underlining its capacity to empower developers to create </span><a id="_idIndexMarker474" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.77.1">applications that seamlessly balance performance and </span><span><span class="kobospan" id="kobo.78.1">resource consumption:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.79.1">Resource efficiency</span></strong><span class="kobospan" id="kobo.80.1">: Eclipse J9’s compact footprint ensures efficient utilization of system resources, making it an ideal choice for applications where minimizing overhead is crucial. </span><span class="kobospan" id="kobo.80.2">This efficiency extends to both memory usage and processor utilization, allowing for optimal performance in </span><span><span class="kobospan" id="kobo.81.1">resource-constrained environments.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.82.1">Swift startup times</span></strong><span class="kobospan" id="kobo.83.1">: The JVM’s startup time is pivotal in particular application domains, and Eclipse J9 shines in this regard. </span><span class="kobospan" id="kobo.83.2">Its rapid startup ensures that applications become operational swiftly, enhancing user experience </span><span><span class="kobospan" id="kobo.84.1">and responsiveness.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.85.1">Scalability</span></strong><span class="kobospan" id="kobo.86.1">: Eclipse J9 is designed to scale seamlessly across various environments, adapting to the demands of both small-scale applications and large-scale enterprise systems. </span><span class="kobospan" id="kobo.86.2">Its scalability makes it well-suited for dynamic workloads and applications that may experience </span><span><span class="kobospan" id="kobo.87.1">fluctuating markets.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.88.1">Considering Eclipse J9 for your Java applications becomes imperative when efficiency, rapid responsiveness, and optimal resource utilization are paramount. </span><span class="kobospan" id="kobo.88.2">Whether you’re developing cloud-native applications or microservices or deploying in resource-constrained environments, Eclipse J9 provides a compelling solution. </span><span class="kobospan" id="kobo.88.3">The benefits of Eclipse J9 translate into tangible advantages, offering developers the flexibility to balance performance and resource consumption according to their application’s </span><span><span class="kobospan" id="kobo.89.1">unique requirements.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.90.1">As we conclude our exploration into the efficiency and scalability offered by Eclipse J9, we’ve witnessed how this JVM implementation can be a strategic choice for developers seeking optimal resource utilization and rapid responsiveness in their Java applications. </span><span class="kobospan" id="kobo.90.2">The benefits of Eclipse J9, from its compact footprint to swift startup times and scalable architecture, underscore its versatility across various application landscapes. </span><span class="kobospan" id="kobo.90.3">In the next section, we will </span><a id="_idIndexMarker475" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.91.1">seamlessly transition into an in-depth examination of another notable JVM implementation: Amazon Corretto. </span><span class="kobospan" id="kobo.91.2">We’ll uncover the distinctive features and advantages that Amazon Corretto brings to the table, further expanding our understanding of the diverse and dynamic world of JVM. </span><span class="kobospan" id="kobo.91.3">The journey continues, and the exploration of JVM implementations remains the key to unlocking the full potential of </span><span><span class="kobospan" id="kobo.92.1">Java d</span><a id="_idTextAnchor141" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.93.1">e</span><a id="_idTextAnchor142" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.94.1">velopment.</span></span></p>
<h1 id="_idParaDest-104" class="calibre6"><a id="_idTextAnchor143" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.95.1">Amazon Corretto</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.96.1">In this </span><a id="_idIndexMarker476" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.97.1">section, we’ll embark on an insightful journey into Amazon Corretto, a JVM implementation crafted by Amazon that combines reliability, performance, and LTS. </span><span class="kobospan" id="kobo.97.2">As we navigate the nuances of Amazon Corretto, we’ll explore its unique features, performance optimizations, and compelling reasons developers should consider integrating this JVM implementation into their </span><span><span class="kobospan" id="kobo.98.1">Java applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.99.1">Amazon Corretto represents Amazon’s commitment to delivering a high-quality, open source JVM that meets the demands of modern Java development. </span><span class="kobospan" id="kobo.99.2">Built on the solid foundation of OpenJDK (Java Development Kit), Corretto is designed to provide a reliable and secure Java runtime environment. </span><span class="kobospan" id="kobo.99.3">Amazon Corretto is free to use and comes with LTS, making it an attractive choice for enterprises looking for a stable and </span><span><span class="kobospan" id="kobo.100.1">dependable JVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.101.1">In navigating the intricacies of JVM implementations, Amazon Corretto emerges as a beacon of reliability, performance, and sustained support. </span><span class="kobospan" id="kobo.101.2">This segment delves into the distinct advantages that make Amazon Corretto a compelling choice for Java developers across diverse landscapes. </span><span class="kobospan" id="kobo.101.3">From its commitment to LTS to performance optimizations and a steadfast focus on security, Amazon Corretto offers a comprehensive suite of benefits that elevate the development experience and ensure the longevity and stability of Java applications. </span><span class="kobospan" id="kobo.101.4">Join us as we unravel the layers of Amazon Corretto’s advantages, providing a nuanced understanding of why this JVM implementation deserves a prominent place in </span><span><span class="kobospan" id="kobo.102.1">your toolkit:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.103.1">LTS</span></strong><span class="kobospan" id="kobo.104.1">: One</span><a id="_idIndexMarker477" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.105.1"> of the standout features of Amazon Corretto is its LTS. </span><span class="kobospan" id="kobo.105.2">Enterprises can benefit from extended support and updates, ensuring the stability and security of their Java applications over an </span><span><span class="kobospan" id="kobo.106.1">extended period.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.107.1">Performance optimizations</span></strong><span class="kobospan" id="kobo.108.1">: Amazon Corretto is equipped with performance enhancements that optimize the execution of Java applications. </span><span class="kobospan" id="kobo.108.2">These </span><a id="_idIndexMarker478" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.109.1">optimizations improve responsiveness and throughput, making it well-suited for a wide range of </span><span><span class="kobospan" id="kobo.110.1">use cases.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.111.1">Security and stability</span></strong><span class="kobospan" id="kobo.112.1">: Built with a focus on security and stability, Amazon Corretto undergoes rigorous testing and quality assurance processes. </span><span class="kobospan" id="kobo.112.2">It ensures developers can rely on a robust, secure runtime environment for their </span><span><span class="kobospan" id="kobo.113.1">Java applications.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.114.1">Compatibility with OpenJDK</span></strong><span class="kobospan" id="kobo.115.1">: Amazon Corretto maintains compatibility with OpenJDK, allowing developers to transition from other OpenJDK-based JVMs seamlessly. </span><span class="kobospan" id="kobo.115.2">This compatibility simplifies the migration process while providing the benefits of Amazon’s additional optimizations </span><span><span class="kobospan" id="kobo.116.1">and support.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.117.1">Considering Amazon Corretto for your Java applications is a strategic decision, especially when LTS, performance optimizations, and a commitment to security are paramount. </span><span class="kobospan" id="kobo.117.2">Whether you are developing cloud-native applications, serverless functions, or traditional enterprise systems, Amazon Corretto offers a compelling JVM solution backed by the reliability and scale </span><span><span class="kobospan" id="kobo.118.1">of AWS.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.119.1">As we conclude our exploration of the robust world of Amazon Corretto, we’ve witnessed the confluence of reliability, performance, and LTS that defines this JVM implementation. </span><span class="kobospan" id="kobo.119.2">The benefits of Amazon Corretto, from its unwavering commitment to security to the optimization of Java applications, resonate as compelling reasons for developers to consider integrating it into their projects. </span><span class="kobospan" id="kobo.119.3">Our journey into the diverse landscape of JVM implementations continues, and in the next section, we will unravel the intricacies of another noteworthy player: Azul. </span><span class="kobospan" id="kobo.119.4">Join us as we explore Azul’s distinctive features and advantages to Java development, expanding our understanding of the myriad possibilities that JVM implementations offer. </span><span class="kobospan" id="kobo.119.5">The path to Java excellence unfolds, and the exploration of Azul awaits in the </span><a id="_idTextAnchor144" class="calibre4 pcalibre pcalibre1"/><span><span class="kobospan" id="kobo.120.1">next section.</span></span></p>
<h1 id="_idParaDest-105" class="calibre6"><a id="_idTextAnchor145" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.121.1">Azul Zulu and Zing</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.122.1">In this </span><a id="_idIndexMarker479" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.123.1">section, we’ll delve into the dynamic realm of </span><strong class="bold"><span class="kobospan" id="kobo.124.1">Azul Zulu Builds of OpenJDK</span></strong><span class="kobospan" id="kobo.125.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.126.1">Azul Zulu</span></strong><span class="kobospan" id="kobo.127.1">), a JVM implementation that is a pivotal part of Azul’s comprehensive offerings in the Java runtime space. </span><span class="kobospan" id="kobo.127.2">Azul, renowned for its commitment to providing JVM runtimes and additional tools to enhance Java performance while reducing costs, brings Azul Zulu to the forefront. </span><span class="kobospan" id="kobo.127.3">As a TCK-certified build of OpenJDK, Azul Zulu aligns with the performance standards of most distributors as they all base their builds on the OpenJDK project. </span><span class="kobospan" id="kobo.127.4">Azul’s active participation in monitoring and resolving CVE security issues sets it apart, allowing it to adhere to a 3-month release cycle. </span><span class="kobospan" id="kobo.127.5">It enables Azul to provide free and commercial builds of all supported versions with timely security fixes, ensuring the safe operation of Java applications in </span><span><span class="kobospan" id="kobo.128.1">production environments.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.129.1">Furthermore, Azul Zulu’s distinction lies in its groundbreaking contributions to the OpenJDK ecosystem. </span><span class="kobospan" id="kobo.129.2">Azul initiated the OpenJDK project known as </span><strong class="bold"><span class="kobospan" id="kobo.130.1">Coordinated Restore at Checkpoint</span></strong><span class="kobospan" id="kobo.131.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.132.1">CraC</span></strong><span class="kobospan" id="kobo.133.1">) (</span><a href="https://openjdk.org/projects/crac/" class="calibre4 pcalibre pcalibre1"><span class="kobospan" id="kobo.134.1">https://openjdk.org/projects/crac/</span></a><span class="kobospan" id="kobo.135.1">), making Zulu the first JVM runtime</span><a id="_idIndexMarker480" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.136.1"> to incorporate this feature, enabling ultrafast startup of Java applications. </span><span class="kobospan" id="kobo.136.2">Zulu’s versatility extends to JavaFX integrations, catering to various </span><span><span class="kobospan" id="kobo.137.1">use cases.</span></span></p>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.138.1">Azul Zing Builds of OpenJDK</span></strong><span class="kobospan" id="kobo.139.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.140.1">Azul Zing</span></strong><span class="kobospan" id="kobo.141.1">) emerges </span><a id="_idIndexMarker481" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.142.1">as a stalwart in the JVM landscape, offering a tapestry of benefits that elevate Java development to new heights. </span><span class="kobospan" id="kobo.142.2">Azul Zing introduces the</span><a id="_idIndexMarker482" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.143.1"> innovative </span><strong class="bold"><span class="kobospan" id="kobo.144.1">Continuously Concurrent Compacting Collector</span></strong><span class="kobospan" id="kobo.145.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.146.1">C4</span></strong><span class="kobospan" id="kobo.147.1">) Garbage Collector at its core, setting a benchmark for low-latency and pauseless garbage collection. </span><span class="kobospan" id="kobo.147.2">This key feature ensures that Java applications remain responsive, even in the face of intensive workloads. </span><span class="kobospan" id="kobo.147.3">Beyond its cutting-edge garbage collection, Azul Zing is distinguished by its unwavering commitment to enhanced runtime performance. </span><span class="kobospan" id="kobo.147.4">It is a formidable choice for applications demanding high throughput and minimal latency. </span><span class="kobospan" id="kobo.147.5">Its scalability and elasticity further position Azul Zing as a versatile solution, seamlessly adapting to the dynamic requirements of both small-scale applications and large enterprise systems. </span><span class="kobospan" id="kobo.147.6">With a foundation rooted in LTS and stability, Azul Zing becomes a strategic choice for projects with extended life cycles, promising developers a robust platform for crafting Java applications that excel in performance, responsiveness, and reliability. </span><span class="kobospan" id="kobo.147.7">Join us in exploring the manifold benefits of Azul Zing as we uncover how this </span><a id="_idIndexMarker483" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.148.1">JVM implementation stands as a beacon of innovation and efficiency in the ever-evolving landscape of </span><span><span class="kobospan" id="kobo.149.1">Java development:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.150.1">C4 Garbage Collector</span></strong><span class="kobospan" id="kobo.151.1">: Azul Zing incorporates the innovative C4 Garbage Collector. </span><span class="kobospan" id="kobo.151.2">This collector distinguishes itself by providing low-latency and pauseless garbage collection, ensuring that Java applications maintain consistent responsiveness even under </span><span><span class="kobospan" id="kobo.152.1">heavy workloads.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.153.1">Enhanced runtime performance</span></strong><span class="kobospan" id="kobo.154.1">: Azul Zing is engineered to deliver enhanced runtime performance, making it well-suited for high-throughput and low-latency </span><a id="_idIndexMarker484" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.155.1">applications. </span><span class="kobospan" id="kobo.155.2">Its optimizations contribute to improved application responsiveness and reduced </span><span><span class="kobospan" id="kobo.156.1">execution times.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.157.1">Scalability and elasticity</span></strong><span class="kobospan" id="kobo.158.1">: Azul Zing is designed to scale seamlessly across diverse workloads, adapting to the demands of both small-scale applications and large, enterprise-level systems. </span><span class="kobospan" id="kobo.158.2">Its elasticity ensures optimal performance in dynamic and </span><span><span class="kobospan" id="kobo.159.1">fluctuating environments.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.160.1">LTS and stability</span></strong><span class="kobospan" id="kobo.161.1">: Azul Zing offers LTS and stability, providing enterprises with a reliable foundation for their Java applications. </span><span class="kobospan" id="kobo.161.2">This commitment to stability is crucial for projects with extended life cycles and stringent </span><span><span class="kobospan" id="kobo.162.1">reliability requirements.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.163.1">Azul Zing for </span><a id="_idIndexMarker485" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.164.1">Java development is a strategic choice when performance, scalability, and low latency are non-negotiable. </span><span class="kobospan" id="kobo.164.2">The advanced features, including the C4 Garbage Collector, position Azul Zing as an ideal solution for applications where consistent responsiveness and optimal resource utilization are paramount. </span><span class="kobospan" id="kobo.164.3">Let’s unravel the capabilities of Azul Zing and discover how this JVM implementation can be a catalyst for achieving unprecedented levels of performance in your Java applications. </span><span class="kobospan" id="kobo.164.4">This section aims to equip you with insights to make informed decisions and leverage the advantages of Azul Zing across a diverse range of </span><span><span class="kobospan" id="kobo.165.1">use cases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.166.1">In navigating the intricacies of </span><a id="_idIndexMarker486" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.167.1">Azul Zulu and Zing, we’ve unraveled a tapestry of benefits that positions these JVM implementations as a beacon of innovation and efficiency. </span><span class="kobospan" id="kobo.167.2">Azul Zulu is a build of OpenJDK with additional integrations such as CRaC and JavaFX. </span><span class="kobospan" id="kobo.167.3">Azul Zing is a powerful catalyst for achieving peak Java application performance, from the groundbreaking C4 Garbage Collector to its commitment to enhanced runtime performance and scalability. </span><span class="kobospan" id="kobo.167.4">As our journey through diverse JVM implementations continues, our next destination beckons us toward IBM Semeru. </span><span class="kobospan" id="kobo.167.5">In the upcoming section, we’ll delve into the distinctive features and advantages that IBM Semeru brings to the forefront, further expanding our understanding of the multifaceted landscape of Java development. </span><span class="kobospan" id="kobo.167.6">Our exploration of IBM Semeru awaits, promising new insights and perspectives in our quest</span><a id="_idTextAnchor146" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.168.1"> for </span><span><span class="kobospan" id="kobo.169.1">Java excellence.</span></span></p>
<h1 id="_idParaDest-106" class="calibre6"><a id="_idTextAnchor147" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.170.1">IBM Semeru</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.171.1">In this section, we’ll </span><a id="_idIndexMarker487" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.172.1">explore IBM Semeru, a JVM implementation that encapsulates the expertise and innovation of IBM in the realm of Java development. </span><span class="kobospan" id="kobo.172.2">As we navigate the intricacies of IBM Semeru, we will unravel its distinctive features, optimizations, and compelling reasons developers should consider integrating this JVM implementation into their </span><span><span class="kobospan" id="kobo.173.1">Java applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">IBM Semeru, based on the OpenJ9 JVM, represents IBM’s commitment to delivering a high-performance, scalable, and efficient Java runtime environment. </span><span class="kobospan" id="kobo.174.2">With a focus on resource efficiency, rapid startup times, and advanced optimizations, IBM Semeru is designed to cater to various </span><span><span class="kobospan" id="kobo.175.1">application scenarios.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.176.1">IBM Semeru emerges as a beacon of innovation in Java development, encapsulating a spectrum of benefits that redefine the possibilities of efficient and scalable runtime environments. </span><span class="kobospan" id="kobo.176.2">Anchored by the robust OpenJ9 virtual machine, Semeru introduces a harmonious blend of resource efficiency and rapid startup times, making it an ideal choice for contemporary cloud-native applications and microservices. </span><span class="kobospan" id="kobo.176.3">Integrating </span><strong class="bold"><span class="kobospan" id="kobo.177.1">ahead-of-time</span></strong><span class="kobospan" id="kobo.178.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.179.1">AOT</span></strong><span class="kobospan" id="kobo.180.1">) compilation</span><a id="_idIndexMarker488" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.181.1"> further distinguishes IBM Semeru, translating Java bytecode into machine code before runtime to enhance startup performance and reduce the memory footprint. </span><span class="kobospan" id="kobo.181.2">With a container-friendly architecture optimized for cloud deployments, IBM Semeru caters to the evolving needs of modern application deployment, ensuring adaptability, scalability, and efficiency. </span><span class="kobospan" id="kobo.181.3">For developers seeking a comprehensive solution that aligns with the demands of dynamic cloud environments, IBM Semeru is a compelling choice, promising a sophisticated and optimized Java runtime experience. </span><span class="kobospan" id="kobo.181.4">Join us in exploring the benefits that IBM Semeru brings </span><a id="_idIndexMarker489" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.182.1">to the forefront as we delve into a new era of Java </span><span><span class="kobospan" id="kobo.183.1">development excellence:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.184.1">OpenJ9 virtual machine</span></strong><span class="kobospan" id="kobo.185.1">: IBM Semeru leverages the OpenJ9 virtual machine, known for its efficient memory usage and fast startup times. </span><span class="kobospan" id="kobo.185.2">This optimization is particularly beneficial for cloud-native applications and microservices where resource efficiency </span><span><span class="kobospan" id="kobo.186.1">is paramount.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.187.1">AOT compilation</span></strong><span class="kobospan" id="kobo.188.1">: IBM Semeru incorporates AOT compilation, a feature that translates Java bytecode into machine code before runtime. </span><span class="kobospan" id="kobo.188.2">This approach enhances startup</span><a id="_idIndexMarker490" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.189.1"> performance, reduces the memory footprint, and contributes to consistent and predictable </span><span><span class="kobospan" id="kobo.190.1">application behavior.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.191.1">Container-friendly architecture</span></strong><span class="kobospan" id="kobo.192.1">: With a container-friendly architecture, IBM Semeru is well-suited for deployment in containerized environments. </span><span class="kobospan" id="kobo.192.2">Its efficient resource utilization and compatibility with container orchestration platforms make it ideal for modern, </span><span><span class="kobospan" id="kobo.193.1">scalable infrastructures.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.194.1">Optimized for cloud deployments</span></strong><span class="kobospan" id="kobo.195.1">: IBM Semeru is optimized for cloud deployments, aligning with the demands of cloud-native applications. </span><span class="kobospan" id="kobo.195.2">Its adaptability to dynamic and scalable cloud environments positions it as a strategic choice for developers building applications in </span><span><span class="kobospan" id="kobo.196.1">cloud ecosystems.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.197.1">Consideration of IBM Semeru becomes imperative when resource efficiency, rapid startup times, and compatibility with modern deployment paradigms are critical for your Java applications. </span><span class="kobospan" id="kobo.197.2">Whether you are developing cloud-native applications microservices or deploying in containerized environments, IBM Semeru offers a robust JVM implementation with the backing of IBM’s expertise and commitment to innovation. </span><span class="kobospan" id="kobo.197.3">Join us as we uncover the capabilities of IBM Semeru, providing you with insights to make informed decisions and harness the advantages of this feature-rich JVM implementation for your Java </span><span><span class="kobospan" id="kobo.198.1">development endeavors.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.199.1">Our exploration into the world of JVM implementations reaches a crescendo with the comprehensive insights gained from IBM Semeru. </span><span class="kobospan" id="kobo.199.2">The distinctive benefits, from resource efficiency to cloud optimization, underscore its significance in the ever-evolving landscape of Java development. </span><span class="kobospan" id="kobo.199.3">As our journey continues, the spotlight now shifts toward Eclipse Temurin. </span><span class="kobospan" id="kobo.199.4">In the forthcoming section, we will unravel the unique features and advantages that Eclipse Temurin brings to the table, enriching our understanding of JVM implementations. </span><span class="kobospan" id="kobo.199.5">This exploration of Eclipse Temurin promises new perspectives and innovations as we strive toward Java excellence. </span><span class="kobospan" id="kobo.199.6">Join us in continuing our journey through the diverse tapestry of JVM implementations as we uncover Eclipse Temurin’s capabilities in the dynamic w</span><a id="_idTextAnchor148" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.200.1">orld of </span><span><span class="kobospan" id="kobo.201.1">Java development.</span></span></p>
<h1 id="_idParaDest-107" class="calibre6"><a id="_idTextAnchor149" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.202.1">Eclipse Temurin</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">In this section, we’ll explore</span><a id="_idIndexMarker491" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.204.1"> Eclipse Temurin, a robust and versatile JVM implementation that stands as a testament to the collaborative efforts within the Eclipse community. </span><span class="kobospan" id="kobo.204.2">As we navigate the intricacies of Eclipse Temurin, we will uncover its distinctive features, optimizations, and compelling reasons why developers should consider embracing this JVM implementation for their </span><span><span class="kobospan" id="kobo.205.1">Java applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">Eclipse Temurin, formerly AdoptOpenJDK, is a community-driven, open source project that provides free, high-quality, and production-ready builds of the OpenJDK. </span><span class="kobospan" id="kobo.206.2">Fueled by a commitment to transparency and collaboration, Eclipse Temurin ensures that developers can access a reliable and well-supported Java </span><span><span class="kobospan" id="kobo.207.1">runtime environment.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">Eclipse Temurin emerges as a beacon of reliability and versatility in the Java development landscape, offering a rich tapestry of benefits that resonate with the needs of modern developers. </span><span class="kobospan" id="kobo.208.2">With a commitment to timely updates and security patches for OpenJDK, Eclipse Temurin ensures developers have access to the latest enhancements, contributing to the security and stability of Java applications. </span><span class="kobospan" id="kobo.208.3">Its platform independence provides the flexibility to deploy Java applications seamlessly across diverse operating systems and architectures, catering to the demands of projects targeting multiple environments. </span><span class="kobospan" id="kobo.208.4">What sets Eclipse Temurin apart is its transparent and open community collaboration within the Eclipse ecosystem. </span><span class="kobospan" id="kobo.208.5">Developers can actively contribute, fostering a sense of community-driven development and ensuring the JVM evolves in sync with the diverse needs of its users. </span><span class="kobospan" id="kobo.208.6">The ease of adoption, coupled with a commitment to providing hassle-free builds of OpenJDK, positions Eclipse Temurin as an essential component in the toolkit of developers seeking a reliable, well-supported, and community-driven Java runtime environment. </span><span class="kobospan" id="kobo.208.7">Join us as we unravel the benefits Eclipse Temurin brings to </span><a id="_idIndexMarker492" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.209.1">Java development, fostering a new era of collaboration and innovation within the </span><span><span class="kobospan" id="kobo.210.1">Eclipse community:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.211.1">Timely updates and security patches</span></strong><span class="kobospan" id="kobo.212.1">: Eclipse Temurin offers timely updates and security patches for OpenJDK, ensuring developers can access the latest enhancements and fixes. </span><span class="kobospan" id="kobo.212.2">This commitment to regular updates contributes to the security and stability of </span><span><span class="kobospan" id="kobo.213.1">Java applications.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.214.1">Platform independence</span></strong><span class="kobospan" id="kobo.215.1">: Eclipse Temurin supports various platforms, allowing developers to deploy Java applications seamlessly across diverse operating systems and architectures. </span><span class="kobospan" id="kobo.215.2">This platform independence is crucial for projects targeting </span><span><span class="kobospan" id="kobo.216.1">multiple environments.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.217.1">Transparent and open community collaboration</span></strong><span class="kobospan" id="kobo.218.1">: Being part of the Eclipse community, Eclipse Temurin benefits from transparent and open collaboration. </span><span class="kobospan" id="kobo.218.2">Developers can actively contribute to the project, fostering a sense of community-driven development and ensuring that the JVM evolves in tandem with the diverse needs of </span><span><span class="kobospan" id="kobo.219.1">its users.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.220.1">Ease of adoption</span></strong><span class="kobospan" id="kobo.221.1">: Eclipse</span><a id="_idIndexMarker493" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.222.1"> Temurin’s commitment to providing easy-to-adopt OpenJDK builds simplifies incorporating the latest Java features into projects. </span><span class="kobospan" id="kobo.222.2">This ease of adoption is precious for developers seeking a hassle-free integration of new </span><span><span class="kobospan" id="kobo.223.1">Java capabilities.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.224.1">Considering Eclipse, Temurin becomes imperative for developers prioritizing access to up-to-date OpenJDK builds, a collaborative community-driven approach, and seamless platform independence. </span><span class="kobospan" id="kobo.224.2">Whether you are developing applications for deployment across various operating systems or contributing to an open source ecosystem, Eclipse Temurin provides a reliable and </span><span><span class="kobospan" id="kobo.225.1">well-supported foundation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.226.1">Our journey through the diverse landscape of JVM implementations has been a rich tapestry of innovation and optimization, from Eclipse Temurin’s community-driven excellence to the unique strengths of IBM Semeru, Azul Zulu’s performance prowess, Amazon Corretto’s reliability, and the efficiency of Eclipse J9. </span><span class="kobospan" id="kobo.226.2">As we conclude these individual explorations, the next section promises a holistic view, showcasing the remarkable diversity that defines the world of JVM implementations. </span><span class="kobospan" id="kobo.226.3">Join us in the upcoming section, where we will navigate multiple JVM implementations in a single section, highlighting the dynamic choices available to developers. </span><span class="kobospan" id="kobo.226.4">From Eclipse Temurin to other notable players, witness how the JVM ecosystem thrives on versatility, offering developers many options to tailor their choices based on specific needs and preferences. </span><span class="kobospan" id="kobo.226.5">The exploration continues, unveiling the depth and breadth of t</span><a id="_idTextAnchor150" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.227.1">he JVM </span><span><span class="kobospan" id="kobo.228.1">implementation world.</span></span></p>
<h1 id="_idParaDest-108" class="calibre6"><a id="_idTextAnchor151" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.229.1">Even more JVM vendors and SDKMan</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.230.1">In this section, we’ll embark on a fascinating exploration of the expansive diversity within the JVM ecosystem. </span><span class="kobospan" id="kobo.230.2">Our focus will extend beyond individual JVM implementations, encompassing a spectrum of specialized builds tailored for distinct use cases and environments. </span><span class="kobospan" id="kobo.230.3">Join us as we delve into the nuances of Dragonwell, Tencent Kona, Liberica, Mandrel, the Microsoft Build of OpenJDK, and SapMachine – each representing a unique facet of JVM diversity, optimized to cater to specific demands </span><span><span class="kobospan" id="kobo.231.1">and scenarios.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.232.1">We’ll be embarking on a captivating journey into the multifaceted world of JVM diversity, where a kaleidoscope of specialized builds awaits exploration. </span><span class="kobospan" id="kobo.232.2">Each JVM implementation represents a distinctive approach to addressing unique challenges in application development. </span><span class="kobospan" id="kobo.232.3">From extreme scaling demands to cloud computing, big data, and SAP-supported ecosystems, each JVM is meticulously crafted to meet specific use cases. </span><span class="kobospan" id="kobo.232.4">Join us as we unravel the intricacies of these implementations, gaining insights into how they cater to diverse scenarios, thus offering developers a rich palette of options to align with the unique requirements of their projects. </span><span class="kobospan" id="kobo.232.5">This exploration promises a deeper understanding of the adaptability and versatility ingrained in the diverse world </span><span><span class="kobospan" id="kobo.233.1">of JVMs:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.234.1">Dragonwell (Alibaba)</span></strong><span class="kobospan" id="kobo.235.1">: Engineered</span><a id="_idIndexMarker494" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.236.1"> as the in-house OpenJDK implementation at Alibaba, Dragonwell is optimized for the extreme scaling demands of online eCommerce and financial and logistics applications. </span><span class="kobospan" id="kobo.236.2">Dive into how Dragonwell powers the intricate web of Java applications across Alibaba’s massive </span><span><span class="kobospan" id="kobo.237.1">server infrastructure.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.238.1">Tencent Kona</span></strong><span class="kobospan" id="kobo.239.1">: Serving as</span><a id="_idIndexMarker495" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.240.1"> Tencent’s default JDK for cloud computing, big data, and various Java applications, Kona is a production-ready distribution of OpenJDK with LTS. </span><span class="kobospan" id="kobo.240.2">Uncover the features that make Tencent Kona a robust choice for diverse computing needs within </span><span><span class="kobospan" id="kobo.241.1">Tencent’s ecosystem.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.242.1">Liberica (BellSoft)</span></strong><span class="kobospan" id="kobo.243.1">: As a 100% open</span><a id="_idIndexMarker496" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.244.1"> source Java implementation built from OpenJDK, Liberica is thoroughly tested, including passing the </span><strong class="bold"><span class="kobospan" id="kobo.245.1">Java Compatibility Kit</span></strong><span class="kobospan" id="kobo.246.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.247.1">JCK</span></strong><span class="kobospan" id="kobo.248.1">). </span><span class="kobospan" id="kobo.248.2">Explore</span><a id="_idIndexMarker497" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.249.1"> how Liberica’s commitment to openness ensures JavaFX support across all </span><span><span class="kobospan" id="kobo.250.1">its versions.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.251.1">Mandrel (Red Hat)</span></strong><span class="kobospan" id="kobo.252.1">: Focused on </span><a id="_idIndexMarker498" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.253.1">GraalVM’s native-image component, Mandrel facilitates the generation of native images for Quarkus applications. </span><span class="kobospan" id="kobo.253.2">Delve into how Mandrel simplifies the journey from Java source code to </span><a id="_idIndexMarker499" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.254.1">efficient, native applications, a crucial capability for cloud-native </span><span><span class="kobospan" id="kobo.255.1">application development.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.256.1">Microsoft Build of OpenJDK</span></strong><span class="kobospan" id="kobo.257.1">: Microsoft’s </span><a id="_idIndexMarker500" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.258.1">contribution to JVM diversity comes from a no-cost distribution of OpenJDK. </span><span class="kobospan" id="kobo.258.2">With LTS binaries for Java 11 and Java 16 across multiple operating systems and architectures, understand how Microsoft’s build provides a versatile option </span><span><span class="kobospan" id="kobo.259.1">for developers.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.260.1">SapMachine (SAP)</span></strong><span class="kobospan" id="kobo.261.1">: As a</span><a id="_idIndexMarker501" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.262.1"> downstream version of the OpenJDK project, SapMachine is meticulously crafted to support SAP customers and partners. </span><span class="kobospan" id="kobo.262.2">Discover how SAP’s commitment ensures the success of Java applications within the </span><span><span class="kobospan" id="kobo.263.1">SAP ecosystem.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.264.1">Exploring this rich tapestry of JVM implementations is paramount for developers seeking solutions tailored to specific use cases, from extreme scaling in eCommerce to cloud computing, big data, </span><span><span class="kobospan" id="kobo.265.1">and beyond.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.266.1">As we explore the plethora of JVM implementations discussed earlier SDKMAN (</span><a href="https://sdkman.io/" class="calibre4 pcalibre pcalibre1"><span class="kobospan" id="kobo.267.1">https://sdkman.io/</span></a><span class="kobospan" id="kobo.268.1">) emerges as a </span><a id="_idIndexMarker502" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.269.1">versatile companion, simplifying the management of</span><a id="_idIndexMarker503" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.270.1"> various vendors and versions. </span><span class="kobospan" id="kobo.270.2">The need for different JVM versions is common in real-world production scenarios, whether for stability, optimization, or during migration phases. </span><span class="kobospan" id="kobo.270.3">Join us as we delve into how SDKMAN streamlines the process of managing JVM implementations, providing developers with a seamless experience in experimenting with, switching between, and maintaining diverse </span><span><span class="kobospan" id="kobo.271.1">JVM versions.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.272.1">In this pivotal segment, we’ll embark on a journey to unravel the potent capabilities of SDKMAN. </span><span class="kobospan" id="kobo.272.2">This tool is a linchpin in simplifying the intricate landscape of JVM diversity. </span><span class="kobospan" id="kobo.272.3">As we explore the vast array of JVM implementations and versions, SDKMAN emerges as a versatile ally, streamlining the management process with finesse. </span><span class="kobospan" id="kobo.272.4">It extends the gift of vendor agnosticism, allowing developers to seamlessly navigate between JVM vendors such as Alibaba, Tencent, BellSoft, Red Hat, Microsoft, and SAP. </span><span class="kobospan" id="kobo.272.5">Let’s dive into the intricacies of version management, where SDKMAN empowers developers to effortlessly install, switch, and utilize diverse JVM versions, addressing the nuanced needs of projects in real-world production scenarios. </span><span class="kobospan" id="kobo.272.6">With seamless integration into popular build tools and a commitment to community-driven updates, SDKMAN becomes the linchpin in ensuring a smooth and agile development experience, freeing developers to focus on their code in the dynamic and diverse landscape of Java development. </span><span class="kobospan" id="kobo.272.7">Join us as we unlock the power of SDKMAN, demystifying the complexities and enhancing the agility of JVM management for </span><span><span class="kobospan" id="kobo.273.1">developers worldwide:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.274.1">Vendor agnosticism</span></strong><span class="kobospan" id="kobo.275.1">: SDKMAN </span><a id="_idIndexMarker504" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.276.1">embraces vendor agnosticism, allowing developers to switch between JVM vendors such as Alibaba, Tencent, BellSoft, Red Hat, Microsoft, and SAP. </span><span class="kobospan" id="kobo.276.2">Experience the freedom to choose the most suitable JVM for your specific use case without the hassle of </span><span><span class="kobospan" id="kobo.277.1">manual installations.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.278.1">Version management</span></strong><span class="kobospan" id="kobo.279.1">: Managing</span><a id="_idIndexMarker505" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.280.1"> multiple JVM versions is essential in the dynamic landscape of Java development. </span><span class="kobospan" id="kobo.280.2">SDKMAN simplifies version management, enabling developers to quickly install, switch, and use different versions based on project requirements or </span><span><span class="kobospan" id="kobo.281.1">migration needs.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.282.1">Seamless integration of and integration with build tools</span></strong><span class="kobospan" id="kobo.283.1">: SDKMAN integrates </span><a id="_idIndexMarker506" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.284.1">with popular build tools such as Maven and Gradle, facilitating a smooth transition between different JVM versions within your build and deployment processes. </span><span class="kobospan" id="kobo.284.2">It ensures that your projects stay aligned with the chosen JVM </span><span><span class="kobospan" id="kobo.285.1">without disruptions.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.286.1">Community-driven updates</span></strong><span class="kobospan" id="kobo.287.1">: SDKMAN is a community-driven initiative that ensures </span><a id="_idIndexMarker507" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.288.1">continuous updates and support for the latest JVM releases. </span><span class="kobospan" id="kobo.288.2">Stay in sync with the vibrant Java ecosystem (</span><a href="https://foojay.io/today/disco-api-helping-you-to-find-any-openjdk-distribution" class="calibre4 pcalibre pcalibre1"><span class="kobospan" id="kobo.289.1">https://foojay.io/today/disco-api-helping-you-to-find-any-openjdk-distribution</span></a><span class="kobospan" id="kobo.290.1">) and access the latest features and optimizations as soon as they </span><span><span class="kobospan" id="kobo.291.1">become available.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.292.1">In the ever-evolving landscape of Java development, SDKMAN emerges as a valuable ally for developers seeking agility and flexibility in managing JVM implementations. </span><span class="kobospan" id="kobo.292.2">Whether you are exploring diverse JVM vendors, experimenting with versions, or navigating migration phases, SDKMAN streamlines the process, empowering </span><a id="_idTextAnchor152" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.293.1">developers to stay focused on </span><span><span class="kobospan" id="kobo.294.1">their code.</span></span></p>
<h1 id="_idParaDest-109" class="calibre6"><a id="_idTextAnchor153" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.295.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.296.1">As we conclude our exploration of the intricate world of JVM diversity and the instrumental role of SDKMAN, you have gained a profound understanding of alternative JVMs, including Alibaba’s Dragonwell, Tencent Kona, Liberica, Mandrel, the Microsoft Build of OpenJDK, and SapMachine. </span><span class="kobospan" id="kobo.296.2">This chapter not only shed light on the unique characteristics of these implementations, catering to diverse use cases, but also emphasized the pivotal role of SDKMAN in simplifying JVM management. </span><span class="kobospan" id="kobo.296.3">The insights garnered set the stage for the upcoming chapter, where you will delve into the fundamental principles shaping Java frameworks. </span><span class="kobospan" id="kobo.296.4">From design patterns to modularity, these principles are essential for creating robust, scalable, and maintainable applications. </span><span class="kobospan" id="kobo.296.5">The practical utility of the information provided in this chapter will become evident, equipping you with the knowledge needed to navigate the dynamic Java development landscape. </span><span class="kobospan" id="kobo.296.6">As we transition into Java framework principles, the comprehensive understanding you’ve gained here promises to be invaluable, guiding you on a seamless journey t</span><a id="_idTextAnchor154" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.297.1">oward excellence in your </span><span><span class="kobospan" id="kobo.298.1">coding endeavors.</span></span></p>
<h1 id="_idParaDest-110" class="calibre6"><a id="_idTextAnchor155" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.299.1">Questions</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.300.1">Answer the following questions to test your knowledge of </span><span><span class="kobospan" id="kobo.301.1">this chapter:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.302.1">What is the primary focus of Alibaba’s Dragonwell </span><span><span class="kobospan" id="kobo.303.1">JVM implementation?</span></span><ol class="calibre17"><li class="alphabets"><span><span class="kobospan" id="kobo.304.1">Cloud computing</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.305.1">Online eCommerce and financial and </span><span><span class="kobospan" id="kobo.306.1">logistics applications</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.307.1">Big data</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.308.1">Microservices</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.309.1">Which JVM implementation is Tencent’s default JDK for cloud computing and </span><span><span class="kobospan" id="kobo.310.1">big data?</span></span><ol class="calibre17"><li class="alphabets"><span><span class="kobospan" id="kobo.311.1">Amazon Corretto</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.312.1">Tencent Kona</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.313.1">Eclipse Temurin</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.314.1">Azul Zulu</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.315.1">What is the primary focus of the Mandrel </span><span><span class="kobospan" id="kobo.316.1">JVM implementation?</span></span><ol class="calibre17"><li class="alphabets"><span><span class="kobospan" id="kobo.317.1">High-performance computing</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.318.1">Running applications </span><span><span class="kobospan" id="kobo.319.1">on containers</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.320.1">Native image generation for </span><span><span class="kobospan" id="kobo.321.1">Quarkus applications</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.322.1">Cloud-native </span><span><span class="kobospan" id="kobo.323.1">application development</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.324.1">What is one of the key benefits of Eclipse Temurin (</span><span><span class="kobospan" id="kobo.325.1">formerly AdoptOpenJDK)?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.326.1">Closed </span><span><span class="kobospan" id="kobo.327.1">source development</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.328.1">Timely updates and </span><span><span class="kobospan" id="kobo.329.1">security patches</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.330.1">Limited </span><span><span class="kobospan" id="kobo.331.1">platform support</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.332.1">Exclusive focus on </span><span><span class="kobospan" id="kobo.333.1">cloud environments</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.334.1">How does SDKMAN simplify JVM management </span><span><span class="kobospan" id="kobo.335.1">for developers?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.336.1">By limiting the number of JVM </span><span><span class="kobospan" id="kobo.337.1">vendors available</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.338.1">By restricting the use of different </span><span><span class="kobospan" id="kobo.339.1">JVM versions</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.340.1">By seamlessly integrating with </span><span><span class="kobospan" id="kobo.341.1">build tools</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.342.1">By supporting only proprietary </span><span><span class="kobospan" id="kobo.343.1">JVM implementations</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.344.1">What differentiates Azul Zulu from </span><span><span class="kobospan" id="kobo.345.1">Azul Zing?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.346.1">Azul Zulu is </span><span><span class="kobospan" id="kobo.347.1">not TCK-certified</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.348.1">Azul Zing is based </span><span><span class="kobospan" id="kobo.349.1">on OpenJDK</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.350.1">Azul Zulu incorporates the G1 </span><span><span class="kobospan" id="kobo.351.1">Garbage Collector</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.352.1">Azul Zing focuses on </span><span><span class="kobospan" id="kobo.353.1">small-scale applications</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.354.1">What key feature of Azul Zulu ensures that Java applications remain responsive even under </span><span><span class="kobospan" id="kobo.355.1">heavy workloads?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.356.1">C4 </span><span><span class="kobospan" id="kobo.357.1">Garbage Collector</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.358.1">Falcon compiler</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.359.1">Elasticity</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.360.1">JavaFX integration</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-111" class="calibre6"><a id="_idTextAnchor156" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.361.1">Answers</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.362.1">Here are the answers to this </span><span><span class="kobospan" id="kobo.363.1">chapter’s questions:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.364.1">B. </span><span class="kobospan" id="kobo.364.2">Online eCommerce and financial and </span><span><span class="kobospan" id="kobo.365.1">logistics applications</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.366.1">B. </span><span><span class="kobospan" id="kobo.367.1">Tencent Kona</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.368.1">C. </span><span class="kobospan" id="kobo.368.2">Native image generation for </span><span><span class="kobospan" id="kobo.369.1">Quarkus applications</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.370.1">B. </span><span class="kobospan" id="kobo.370.2">Timely updates and </span><span><span class="kobospan" id="kobo.371.1">security patches</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.372.1">C. </span><span class="kobospan" id="kobo.372.2">By seamlessly integrating with </span><span><span class="kobospan" id="kobo.373.1">build tools</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.374.1">B. </span><span class="kobospan" id="kobo.374.2">Azul Zing is based </span><span><span class="kobospan" id="kobo.375.1">on OpenJDK</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.376.1">A. </span><span class="kobospan" id="kobo.376.2">C4 </span><span><span class="kobospan" id="kobo.377.1">Garbage Collector</span></span></li>
</ol>
</div>
</body></html>