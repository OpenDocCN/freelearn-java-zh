<html><head></head><body>
  <div id="_idContainer282" class="Basic-Text-Frame">
    <h1 class="chapterNumber">11</h1>
    <h1 id="_idParaDest-484" class="chapterTitle">Concurrency ‒ Virtual Threads and Structured Concurrency: Diving Deeper</h1>
    <p class="normal">This chapter includes 18 problems meant to dive deep into how <em class="italic">virtual threads</em> and <em class="italic">structured concurrency</em> work and how they should be used in your applications.</p>
    <p class="normal">If you don’t have a background in concurrency in Java then I strongly recommend postponing this chapter until you read some good introductory coverage on this topic. For instance, you could try out <em class="italic">Chapter 10</em> and <em class="italic">Chapter 11</em> from <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>.</p>
    <p class="normal">We start this chapter by explaining how virtual threads work internally. This will be helpful to help you better understand the subsequent problems about extending and assembling <code class="inlineCode">StructuredTaskScope</code>, hooking <code class="inlineCode">ThreadLocal</code> and virtual threads, avoiding <em class="italic">pinning</em>, solving <em class="italic">producer-consumer</em> problems, implementing an HTTP web server, and so on.</p>
    <p class="normal">By the end of this chapter, you’ll have comprehensive and crystal-clear knowledge about working with <em class="italic">virtual threads</em> and <em class="italic">structured concurrency</em>.</p>
    <h1 id="_idParaDest-485" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your advanced programming prowess in virtual threads and structured concurrency in Java. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="225"><strong class="keyWord">Tackling continuations</strong>: Provide a detailed explanation of what <em class="italic">continuations </em>are and how they work in the context of virtual threads.</li>
      <li class="numberedList"><strong class="keyWord">Tracing virtual thread states and transitions</strong>: Build a meaningful diagram of virtual thread states and transitions and explain it.</li>
      <li class="numberedList"><strong class="keyWord">Extending StructuredTaskScope</strong>: Explain and demonstrate the steps for extending the <code class="inlineCode">StructuredTaskScope</code>. Explain why we cannot extend <code class="inlineCode">ShutdownOnSuccess</code> and <code class="inlineCode">ShutdownOnFailure</code>.</li>
      <li class="numberedList"><strong class="keyWord">Assembling StructuredTaskScope</strong>: Write a Java application that assembles (nests) multiple <code class="inlineCode">StructuredTaskScope</code> instances.</li>
      <li class="numberedList"><strong class="keyWord">Assembling StructuredTaskScope with timeout</strong>: Modify the application developed in <em class="italic">Problem 228</em> to add a timeout/deadline to the forked tasks.</li>
      <li class="numberedList"><strong class="keyWord">Hooking ThreadLocal and virtual threads</strong>: Demonstrate the use of <code class="inlineCode">ThreadLocal</code> and virtual threads.</li>
      <li class="numberedList"><strong class="keyWord">Hooking ScopedValue and virtual threads</strong>: Provide a comprehensive introduction with examples of the <code class="inlineCode">ScopedValue</code> API.</li>
      <li class="numberedList"><strong class="keyWord">Using ScopedValue and executor services</strong>: Write a snippet of code that emphasizes the usage of the <code class="inlineCode">ScopedValue</code> API in the context of executor services.</li>
      <li class="numberedList"><strong class="keyWord">Chaining and rebinding scoped values</strong>: Provide a few snippets of code that show how scoped values can be chained and rebound.</li>
      <li class="numberedList"><strong class="keyWord">Using ScopedValue and StructuredTaskScope</strong>: Write a Java application that highlights the usage of <code class="inlineCode">ScopedValue</code> and <code class="inlineCode">StructuredTaskScope</code>. Explain in your code where every <code class="inlineCode">ScopedValue</code> is bound and not bound.</li>
      <li class="numberedList"><strong class="keyWord">Using Semaphore instead of Executor</strong>: In the context of virtual threads, explain the benefits and exemplify the usage of <code class="inlineCode">Semaphore</code> instead of an executor (for instance, instead of <code class="inlineCode">newFixedThreadPool()</code>).</li>
      <li class="numberedList"><strong class="keyWord">Avoiding pinning via locking</strong>: Explain and exemplify how we can avoid pinned virtual threads by refactoring <code class="inlineCode">synchronized</code> code via <code class="inlineCode">ReentrantLock</code>.</li>
      <li class="numberedList"><strong class="keyWord">Solving the producer-consumer problem via virtual threads</strong>: Write a program that simulates, via the producer-consumer pattern, an assembly line for checking and packing up bulbs using multiple workers (virtual threads). </li>
      <li class="numberedList"><strong class="keyWord">Solving the producer-consumer problem via virtual threads (fixed via Semaphore)</strong>: Adapt the application developed in <em class="italic">Problem 237</em> to use <code class="inlineCode">Semaphore</code> instead of executor services.</li>
      <li class="numberedList"><strong class="keyWord">Solving the producer-consumer problem via virtual threads (increase/decrease consumers)</strong>: Write a program that simulates an assembly line for checking and packing up bulbs using workers as needed (e.g., adapt the number of packers (increase or decrease them) to ingest the incoming flux produced by the checker). Use virtual threads and <code class="inlineCode">Semaphore</code>.</li>
      <li class="numberedList"><strong class="keyWord">Implementing an HTTP web server on top of virtual threads</strong>: Rely on Java <code class="inlineCode">HttpServer</code> to write a simple HTTP web server implementation capable of supporting platform threads, virtual threads, and locking (for simulating a database connection pool).</li>
      <li class="numberedList"><strong class="keyWord">Hooking CompletableFuture and virtual threads</strong>: Demonstrate the usage of <code class="inlineCode">CompletableFuture</code> and virtual threads to solve asynchronous tasks.</li>
      <li class="numberedList"><strong class="keyWord">Signaling virtual threads via wait() and notify()</strong>: Write several examples that use <code class="inlineCode">wait()</code> and <code class="inlineCode">notify()</code> to coordinate access to resources (objects) via virtual threads. Demonstrate the good signal and missed signal scenarios.</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter11"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter11</span></a>.</p>
    <h1 id="_idParaDest-486" class="heading-1">225. Tackling continuations</h1>
    <p class="normal">The concept that sits behind <a id="_idIndexMarker1228"/>virtual threads is known as <em class="italic">delimited continuations</em> or simply <em class="italic">continuations</em>. This concept is used internally <a id="_idIndexMarker1229"/>by the JVM in the following piece of code:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Thread&gt; vtThreads = IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
  .mapToObj(i -&gt; Thread.ofVirtual().unstarted(() -&gt; {
    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) { 
      logger.info(Thread.currentThread().toString()); 
    }
    <span class="hljs-keyword">try</span> { Thread.sleep(<span class="hljs-number">1000</span>); } 
      <span class="hljs-keyword">catch</span> (InterruptedException ex) {}
   <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) { 
      logger.info(Thread.currentThread().toString()); 
   }
 })).toList();
 vtThreads.forEach(Thread::start);
 vtThreads.forEach(thread -&gt; {
   <span class="hljs-keyword">try</span> { thread.join(); } <span class="hljs-keyword">catch</span> (InterruptedException ex) {}
 }); 
</code></pre>
    <p class="normal">In this code, we create and start five virtual threads but we only log information about one thread (thread #22 – of course, the id value may vary among executions). So, the output will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
VirtualThread[#22]/runnable@ForkJoinPool-1-worker-4
</code></pre>
    <p class="normal">Thread #22 has started running on <em class="italic">worker-1</em>, but after the blocking operation (<code class="inlineCode">sleep(1000)</code>), it continues to run on <em class="italic">worker-4</em>. Behind this <em class="italic">thread context switching</em>, we have the so-called <em class="italic">continuations</em>.</p>
    <p class="normal">Basically, the behavior of <em class="italic">continuations</em> can easily be explained via a popular debugger use case. When we debug the code, we set a breakpoint and run the code. When the flow hits this breakpoint, the execution freezes and we can inspect the current status of the application. Later on, when we’ve done the inspection, we continue running the code from this breakpoint forward. The<a id="_idIndexMarker1230"/> debugger knows how to resume the execution from where it was left off (frozen). So, the execution continues until it hits the end of the application or until another breakpoint is encountered.</p>
    <p class="normal">Briefly, virtual threads follow the same behavior. A virtual thread is mounted on a platform thread (<em class="italic">worker-x</em>) and starts running. When the execution hits a blocking operation (for instance, a <code class="inlineCode">sleep()</code> call), then the virtual thread is unmounted from its worker. Later on, after the blocking operation ends, the thread execution is resumed by scheduling and mounting it on a platform thread (same worker, <em class="italic">worker-x</em>, or another <em class="italic">worker-y</em>).</p>
    <h2 id="_idParaDest-487" class="heading-2">Introducing continuations </h2>
    <p class="normal">Going deeper, we have to introduce <em class="italic">subroutines</em> and <em class="italic">coroutines</em>. Subroutines are functions that can be called and get back a response, while coroutines are <em class="italic">cooperating subroutines</em> that run at the same time and talk to each other like in a <a id="_idIndexMarker1231"/>human conversation. Exactly like how two people talk to each other, coroutines set up a conversational state via two subroutines that are talking to each other. Via this paradigm, an application can perform some tasks, do nothing for a while, and then perform more tasks later.</p>
    <p class="normal">But, how can coroutines remember the data involved in the conversations? The short answer is <em class="italic">continuations</em>. Continuations are data structures capable of carrying data (the conversational state) between coroutines. They can resume processing from where it was left off.</p>
    <p class="normal">Virtual threads take advantage of continuations by being capable of doing some work, then unmounting, and, later on, resuming from where they left off.</p>
    <p class="normal">Project Loom provides the API for working with continuations as an internal API, so it is not meant to be used directly in applications (we shouldn’t try to use this low-level API unless our goal is to write some higher-level API (libraries) on top of it). However, this API relies on two main classes and three methods. As classes, we have the <code class="inlineCode">ContinuationScope</code>, which is the scope for handling nested <code class="inlineCode">Continuation</code> instances. As methods, we have:</p>
    <ul>
      <li class="bulletList"><code class="inlineCode">run()</code> – run a continuation from where it was left off</li>
      <li class="bulletList"><code class="inlineCode">yield()</code> – freeze (suspend) the continuation at this point and give control to the continuation’s caller (<code class="inlineCode">run()</code> will be able to resume the execution from here)</li>
      <li class="bulletList"><code class="inlineCode">isDone()</code> – test if the current continuation is complete</li>
    </ul>
    <p class="normal">So, under a <code class="inlineCode">ContinuationScope</code> umbrella, we can have multiple nested continuations that set up a conversational state via <code class="inlineCode">run()</code>, <code class="inlineCode">yield()</code>, and <code class="inlineCode">isDone()</code>. For virtual threads, there is a single <code class="inlineCode">ContinuationScope</code> named <code class="inlineCode">VTHREAD_SCOPE</code>.</p>
    <p class="normal">Here is a snippet of code that <a id="_idIndexMarker1232"/>explains this statement:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">ContinuationScope</span> <span class="hljs-variable">cscope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ContinuationScope</span>(<span class="hljs-string">"cscope"</span>);
<span class="hljs-type">Continuation</span> <span class="hljs-variable">continuation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Continuation</span>(cscope, () -&gt;
    logger.info(<span class="hljs-string">"Continuation is running ..."</span>);
});
continuation.run();
</code></pre>
    <p class="normal">Since we call <code class="inlineCode">continuation.run()</code>, this code will output:</p>
    <pre class="programlisting con"><code class="hljs-con">Continuation is running ...
</code></pre>
    <p class="normal">This is quite straightforward. Next, let’s suspend the continuation via <code class="inlineCode">yield()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Continuation</span> <span class="hljs-variable">continuation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Continuation</span>(cscope, () -&gt;
   logger.info(<span class="hljs-string">"</span><span class="hljs-string">Continuation is running ..."</span>);
   <span class="code-highlight"><strong class="hljs-slc">Continuation.yield(cscope);</strong></span>
   logger.info(<span class="hljs-string">"Continuation keeps running ..."</span>);
});
continuation.run();
</code></pre>
    <p class="normal">At the moment, the output is the same:</p>
    <pre class="programlisting con"><code class="hljs-con">Continuation is running ...
</code></pre>
    <p class="normal">Practically, when we call the <code class="inlineCode">yield()</code> method, the continuation is suspended and control is given to the caller. We can easily see this by adding some logs after calling the <code class="inlineCode">run()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">continuation.run();
logger.info(<span class="hljs-string">"The continuation was suspended ..."</span>);
</code></pre>
    <p class="normal">Now, the output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">Continuation is running ...
The continuation was suspended ...
</code></pre>
    <p class="normal">As you can see, the <code class="inlineCode">logger.info("Continuation keeps running ...");</code> code line was not executed. The <code class="inlineCode">yield()</code> method has frozen the execution before this line and returned the control to the caller. In order to<a id="_idIndexMarker1233"/> resume the continuation from where it was left off, we have to call <code class="inlineCode">run()</code> again:</p>
    <pre class="programlisting code"><code class="hljs-code">continuation.run();
logger.info(<span class="hljs-string">"The continuation was suspended ..."</span>);
continuation.run();
logger.info(<span class="hljs-string">"The continuation is done ..."</span>);
</code></pre>
    <p class="normal">This time, the output will be as follows (you can check if the continuation is done via <code class="inlineCode">isDone()</code>):</p>
    <pre class="programlisting con"><code class="hljs-con">Continuation is running ...
The continuation was suspended ...
Continuation keeps running ...
The continuation is done ...
</code></pre>
    <p class="normal">As you can see, when we call <code class="inlineCode">run()</code> again, the execution is resumed from where it was left off, not from the beginning. This is how continuations work.</p>
    <h2 id="_idParaDest-488" class="heading-2">Continuations and virtual threads</h2>
    <p class="normal">Now, let’s see how virtual threads and <code class="inlineCode">sleep()</code> work via continuations in our example. Our virtual thread (#22) starts its journey by logging a<a id="_idIndexMarker1234"/> simple<a id="_idIndexMarker1235"/> message. Afterward, it hits the <code class="inlineCode">Thread.sleep(1000);</code> code line, as in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_01.png" alt="Figure 11.1.png"/></figure>
    <p class="packt_figref">Figure 11.1: The virtual thread #22 running on worker-1</p>
    <p class="normal">If we check the JDK 21 source code, we can easily highlight the following snippet of code from the <code class="inlineCode">sleep()</code> method in the <code class="inlineCode">Thread</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this is the JDK 21 code</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sleep</span><span class="hljs-params">(</span><span class="hljs-type">long</span><span class="hljs-params"> millis)</span> 
    <span class="hljs-keyword">throws</span> InterruptedException {
  ...
  <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> MILLISECONDS.toNanos(millis);
  ...
  <span class="hljs-keyword">if</span> (currentThread() instanceofVirtualThread vthread) {
    <span class="code-highlight"><strong class="hljs-slc">vthread.sleepNanos(nanos);</strong></span>
  }
...
}
</code></pre>
    <p class="normal">So, if the thread that has called <code class="inlineCode">sleep()</code> is a virtual thread, then the code simply calls the internal <code class="inlineCode">sleepNanos()</code> method<a id="_idIndexMarker1236"/> from the <code class="inlineCode">VirtualThread</code> class. The relevant <a id="_idIndexMarker1237"/>code that we are interested in is the following:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this is the JDK 21 code</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">sleepNanos</span><span class="hljs-params">(</span><span class="hljs-type">long</span><span class="hljs-params"> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException {  
  ...
  <span class="hljs-keyword">if</span> (nanos == <span class="hljs-number">0</span>) {
    <span class="code-highlight"><strong class="hljs-slc">tryYield();</strong></span>
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// park for the sleep time</span>
    <span class="hljs-keyword">try</span> {
      ...
      <span class="code-highlight"><strong class="hljs-slc">parkNanos(remainingNanos);</strong></span>
      ...
    } <span class="hljs-keyword">finally</span> {
      <span class="hljs-comment">// may have been unparked while sleeping</span>
      setParkPermit(<span class="hljs-literal">true</span>);
    }
  }
}
</code></pre>
    <p class="normal">So, here the code can call the <code class="inlineCode">tryYield()</code> method (if <code class="inlineCode">nanos</code> is 0) or the <code class="inlineCode">parkNanos()</code> method. If <code class="inlineCode">tryYield()</code> is called, then the thread state is set as <code class="inlineCode">YIELDING</code>. On the other hand, if <code class="inlineCode">parkNanos()</code> is called, then the thread state is set as <code class="inlineCode">PARKING</code>. In both cases (via <code class="inlineCode">tryYield()</code> or <code class="inlineCode">parkNanos()</code>), the execution hits the <code class="inlineCode">yieldContinuation()</code>, which is the climax of our journey:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this is the JDK 21 code </span>
<span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title">yieldContinuation</span><span class="hljs-params">()</span> {
  <span class="hljs-comment">// unmount</span>
  notifyJvmtiUnmount(<span class="hljs-comment">/*hide*/</span><span class="hljs-literal">true</span>);
  unmount();
  <span class="hljs-keyword">try</span> {
    <span class="code-highlight"><strong class="hljs-keyword-slc">return</strong><strong class="hljs-slc"> Continuation.yield(VTHREAD_SCOPE);</strong></span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-comment">// re-mount</span>
    mount();
    notifyJvmtiMount(<span class="hljs-comment">/*hide*/</span><span class="hljs-literal">false</span>);
  }
}
</code></pre>
    <p class="normal">As you can see, here the virtual thread is unmounted, and <code class="inlineCode">yield()</code> is called. So, the virtual thread stack is copied into the <a id="_idIndexMarker1238"/>heap and the thread is unmounted from the carrier<a id="_idIndexMarker1239"/> thread (it becomes <code class="inlineCode">PARKED</code>). We can see this via the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_02.png" alt="Figure 11.2.png"/></figure>
    <p class="packt_figref">Figure 11.2: The virtual thread #22 is unmounted and moved to the heap</p>
    <p class="normal">This scenario takes place for any blocking operation, not just for <code class="inlineCode">sleep()</code>. Once virtual thread #22 is uncounted, <em class="italic">worker-1</em> is ready to serve another virtual thread or do some other processing.</p>
    <p class="normal">After the blocking operation finishes (here, <code class="inlineCode">sleep(1000)</code>), the <code class="inlineCode">private</code> method <code class="inlineCode">runContinuation()</code> from the <code class="inlineCode">VirtualThread</code> class is called and the execution of #22 is resumed. As you can see in the following diagram, #22 is mounted now on <em class="italic">worker-4</em> since <em class="italic">worker-1</em> is not available (it has to execute some hypothetical virtual thread, #41).</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_03.png" alt="Figure 11.3.png"/></figure>
    <p class="packt_figref">Figure 11.3: The execution of virtual thread #22 is resumed on worker-4</p>
    <p class="normal">The execution continues <a id="_idIndexMarker1240"/>with the second logging instruction and terminates. This is how continuations and virtual threads<a id="_idIndexMarker1241"/> work internally to sustain a massive throughput.</p>
    <h1 id="_idParaDest-489" class="heading-1">226. Tracing virtual thread states and transitions</h1>
    <p class="normal">As you know, a thread can be in one <a id="_idIndexMarker1242"/>of the following states: <code class="inlineCode">NEW</code>, <code class="inlineCode">RUNNABLE</code>, <code class="inlineCode">BLOCKED</code>, <code class="inlineCode">WAITING</code>, <code class="inlineCode">TIMED_WAITING</code>, or <code class="inlineCode">TERMINATED</code>. These states are elements of the <code class="inlineCode">State</code> enum and are exposed via the <code class="inlineCode">Thread.currentThread().getState()</code> call. These states are valid for platform threads and for virtual threads as well and we can use them in our applications. (If you’re unfamiliar with this, you can find more details about it in <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 10</em>, <em class="italic">Problem 199.</em>)</p>
    <p class="normal">However, internally speaking, a virtual thread works on a state transition model, as shown in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_04.png" alt="" role="presentation"/></figure>
    <p class="packt_figref">Figure 11.4: Virtual thread state transitions</p>
    <p class="normal">These states are declared in the <code class="inlineCode">VirtualThread</code> class as <code class="inlineCode">private static final int</code>. So, they are not public. However, they <a id="_idIndexMarker1243"/>are essential for understanding the lifecycle of a virtual thread, so let’s briefly attempt to trace a virtual thread’s states during its lifetime.</p>
    <h2 id="_idParaDest-490" class="heading-2">NEW</h2>
    <p class="normal">When a virtual thread is<a id="_idIndexMarker1244"/> created (for instance, via the <code class="inlineCode">unstarted()</code> method), it is in the <code class="inlineCode">NEW</code> state. In this state, the thread is not mounted and not even started. However, at that moment, JVM calls the constructor of the <code class="inlineCode">VirtualThread</code> listed here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this is the JDK 21 code</span>
VirtualThread(Executor scheduler, String name, 
    <span class="hljs-type">int</span> characteristics, Runnable task) {
  <span class="hljs-built_in">super</span>(name, characteristics, <span class="hljs-comment">/*bound*/</span> <span class="hljs-literal">false</span>);
  Objects.requireNonNull(task);
  <span class="hljs-comment">// choose scheduler if not specified</span>
  <span class="hljs-keyword">if</span> (scheduler == <span class="hljs-literal">null</span>) {
    <span class="hljs-type">Thread</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> Thread.currentThread();
    <span class="hljs-keyword">if</span> (parent instanceofVirtualThread vparent) {
      scheduler = vparent.scheduler;
    } <span class="hljs-keyword">else</span> {
      scheduler = DEFAULT_SCHEDULER;
    }
  }
  <span class="code-highlight"><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.scheduler = scheduler;</strong></span>
  <span class="code-highlight"><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.cont = </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">VThreadContinuation</strong><strong class="hljs-slc">(</strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">, task);</strong></span>
  <span class="code-highlight"><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">.runContinuation = </strong><strong class="hljs-built_in-slc">this</strong><strong class="hljs-slc">::runContinuation;</strong></span>
}
</code></pre>
    <p class="normal">So, this constructor is responsible for choosing the scheduler to create a <code class="inlineCode">Continuation</code> (which is a <code class="inlineCode">VThreadContinuation</code> object that stores the information of what has to be run as a <code class="inlineCode">task</code>) and prepare the <code class="inlineCode">runContinuation private</code> field, which is a <code class="inlineCode">Runnable</code> used to run the <code class="inlineCode">Continuation</code> when the<a id="_idIndexMarker1245"/> virtual thread is started.</p>
    <h2 id="_idParaDest-491" class="heading-2">STARTED</h2>
    <p class="normal">A virtual thread passes <a id="_idIndexMarker1246"/>from <code class="inlineCode">NEW</code> to <code class="inlineCode">STARTED</code> when we call the <code class="inlineCode">start()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this is the JDK 21 code </span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">(ThreadContainer container)</span> {
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (!compareAndSetState(NEW, STARTED)) {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-keyword-slc">throw</strong><strong class="hljs-slc"> </strong><strong class="hljs-keyword-slc">new</strong><strong class="hljs-slc"> </strong><strong class="hljs-title-slc">IllegalThreadStateException</strong><strong class="hljs-slc">(</strong><strong class="hljs-string-slc">"Already started"</strong><strong class="hljs-slc">);</strong></span>
<span class="code-highlight"><strong class="hljs-slc">  }</strong></span>
  ...
  <span class="hljs-comment">// start thread</span>
  <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;
  ...
  <span class="hljs-keyword">try</span> {
    ...
    <span class="hljs-comment">// submit task to run thread</span>
<span class="code-highlight"><strong class="hljs-slc">    submitRunContinuation();</strong></span>
    started = <span class="hljs-literal">true</span>;
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">if</span> (!started) {
      setState(TERMINATED);
      ...
    }
  }
}
</code></pre>
    <p class="normal">Moreover, at the moment, the <code class="inlineCode">runContinuation</code> runnable is scheduled on the virtual thread scheduler via <code class="inlineCode">submitRunContinuation()</code>.</p>
    <h2 id="_idParaDest-492" class="heading-2">RUNNING</h2>
    <p class="normal">The <code class="inlineCode">runContinuation</code> runnable moves the<a id="_idIndexMarker1247"/> virtual thread state from <code class="inlineCode">STARTED</code> to <code class="inlineCode">RUNNING</code> and calls <code class="inlineCode">cont.run()</code>. The virtual thread is mounted (it could be for the first time or just a subsequent mounting that resumes the execution from where it was left off) on a platform thread and starts running:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this is the JDK 21 code</span>
<span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runContinuation</span><span class="hljs-params">()</span> {
  ...
  <span class="hljs-comment">// set state to RUNNING</span>
  <span class="hljs-type">int</span> <span class="hljs-variable">initialState</span> <span class="hljs-operator">=</span> state();
<span class="code-highlight"><strong class="hljs-slc">  </strong><strong class="hljs-keyword-slc">if</strong><strong class="hljs-slc"> (initialState == STARTED </strong></span>
<span class="code-highlight"><strong class="hljs-slc">        &amp;&amp; compareAndSetState(STARTED, RUNNING)) {</strong></span>
<span class="code-highlight"><strong class="hljs-slc">    </strong><strong class="hljs-comment-slc">// first run</strong></span>
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialState == RUNNABLE 
        &amp;&amp; compareAndSetState(RUNNABLE, RUNNING)) {
    <span class="hljs-comment">// consume parking permit</span>
    setParkPermit(<span class="hljs-literal">false</span>);
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">// not runnable</span>
    <span class="hljs-keyword">return</span>;
  }
  <span class="hljs-comment">// notify JVMTI before mount</span>
  notifyJvmtiMount(<span class="hljs-comment">/*hide*/</span><span class="hljs-literal">true</span>);
  <span class="hljs-keyword">try</span> {
    <span class="code-highlight"><strong class="hljs-slc">cont.run();</strong></span>
  } <span class="hljs-keyword">finally</span> {
    <span class="hljs-keyword">if</span> (cont.isDone()) {
      afterTerminate();
    } <span class="hljs-keyword">else</span> {
      afterYield();
    }
  }
}
</code></pre>
    <p class="normal">From this point forward, the virtual<a id="_idIndexMarker1248"/> thread state can be moved to <code class="inlineCode">TERMINATED</code> (the execution is done), <code class="inlineCode">PARKING</code> (a blocking operation has been encountered), or <code class="inlineCode">YIELDING</code> (the effect of calling <code class="inlineCode">Thread.yield()</code>).</p>
    <h2 id="_idParaDest-493" class="heading-2">PARKING</h2>
    <p class="normal">The virtual thread is running until its job is <a id="_idIndexMarker1249"/>done or it reaches a blocking operation. At this moment, the virtual thread should be unmounted from the platform thread (should be parked). In order to accomplish this, the JVM moves the virtual thread state from <code class="inlineCode">RUNNING</code> to <code class="inlineCode">PARKING</code> via the <code class="inlineCode">park()</code> method. This is a transitional state to <code class="inlineCode">PARKED</code> (park on the heap) or <code class="inlineCode">PINNED</code> (park on its carrier thread).</p>
    <h2 id="_idParaDest-494" class="heading-2">PARKED/PINNED</h2>
    <p class="normal">Further, the <code class="inlineCode">yieldContinuation()</code> is called from <code class="inlineCode">park()</code> and the result of unmounting the virtual thread is signaled via the flag returned<a id="_idIndexMarker1250"/> by <code class="inlineCode">Continuation.yield(VTHREAD_SCOPE)</code>. In other words, if the unmounting operation is a success, then the virtual thread state is moved from <code class="inlineCode">PARKING</code> to <code class="inlineCode">PARKED</code> (the virtual thread was successfully parked on the heap). Otherwise, if the unmounting operation fails, then the <code class="inlineCode">parkOnCarrierThread()</code> method is called and the virtual thread state is moved to <code class="inlineCode">PINNED</code> (the virtual thread is parked on the carrier thread). A <code class="inlineCode">PINNED</code> virtual thread is moved to the <code class="inlineCode">RUNNING</code> state when the execution can be resumed (since it was parked on its carrier thread). On the other hand, a <code class="inlineCode">PARKED</code> virtual thread is moved to the <code class="inlineCode">RUNNABLE</code> state when it is unparked (or interrupted). In this case, the virtual thread (which is not mounted) is mounted and the execution continues from where it was left by moving the state from <code class="inlineCode">RUNNABLE</code> to <code class="inlineCode">RUNNING</code>.</p>
    <h2 id="_idParaDest-495" class="heading-2">YIELDING</h2>
    <p class="normal">A virtual thread state is moved from <code class="inlineCode">RUNNING</code> to <code class="inlineCode">YIELDING</code> when a <code class="inlineCode">Thread.yield()</code> call is encountered (for instance, this <a id="_idIndexMarker1251"/>happens when we call <code class="inlineCode">Thread.yield()</code> or <code class="inlineCode">Thread.sleep(0)</code>). If the yield fails, then the virtual thread state is moved back to <code class="inlineCode">RUNNING</code>. Otherwise, it is moved to <code class="inlineCode">RUNNABLE</code>.</p>
    <h2 id="_idParaDest-496" class="heading-2">RUNNABLE</h2>
    <p class="normal">A virtual thread is in the <code class="inlineCode">RUNNABLE</code> state when it is not mounted but it wants to resume its execution. It comes into this state from<a id="_idIndexMarker1252"/> the <code class="inlineCode">PARKED</code> or <code class="inlineCode">YIELDING</code> states. At this moment, the virtual thread state is moved from <code class="inlineCode">RUNNABLE</code> to <code class="inlineCode">RUNNING</code> and the execution continues from where it was left off (this happens in <code class="inlineCode">runContinuation()</code>).</p>
    <h2 id="_idParaDest-497" class="heading-2">TERMINATED</h2>
    <p class="normal">Now, the circle is closed. The virtual thread<a id="_idIndexMarker1253"/> finishes its execution and gets into the <code class="inlineCode">TERMINATED</code> state. Moreover, a virtual thread that couldn’t be started is also moved to this state.</p>
    <h1 id="_idParaDest-498" class="heading-1">227. Extending StructuredTaskScope</h1>
    <p class="normal">We cannot extend <code class="inlineCode">StructuredTaskScope.ShutdownOnSuccess</code> (<em class="italic">Chapter 10</em>, <em class="italic">Problem 221</em>) or <code class="inlineCode">ShutdownOnFailure</code> (<em class="italic">Chapter 10</em>, <em class="italic">Problem 222</em>) since these are <code class="inlineCode">final</code> classes. But, we can extend <code class="inlineCode">StructuredTaskScope</code> and provide <a id="_idIndexMarker1254"/>a custom behavior via its <code class="inlineCode">handleComplete()</code> method.</p>
    <p class="normal">Let’s assume that we want to travel from our current location to a certain destination in our town:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">String</span> <span class="hljs-variable">loc</span> <span class="hljs-operator">=</span> <span class="hljs-string">"</span><span class="hljs-string">124 NW Bobcat L, St. Robert"</span>; <span class="hljs-comment">// from user</span>
<span class="hljs-type">String</span> <span class="hljs-variable">dest</span> <span class="hljs-operator">=</span> <span class="hljs-string">"129 West 81st Street"</span>;       <span class="hljs-comment">// from user</span>
</code></pre>
    <p class="normal">On our phone, we have an application that can query a ridesharing service and the public transport service. The ridesharing service can simultaneously query multiple ridesharing servers to find the cheapest offer. On the other hand, the public transport service can simultaneously query the public transport servers to find the offer that leaves the earliest, no matter whether it is by bus, train, tram, or subway. In a diagram, we can represent these statements as follows:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_05.png" alt="Figure 11.5.png"/></figure>
    <p class="packt_figref">Figure 11.5: Querying ridesharing and public transport services</p>
    <p class="normal">Both services are implemented via a <code class="inlineCode">StructuredTaskScope</code>, but the one that queries the public transport servers uses a custom <code class="inlineCode">StructuredTaskScope</code>, while the one that queries the ridesharing servers uses a classical <code class="inlineCode">StructuredTaskScope</code>.</p>
    <p class="normal">Since we are already familiar with the classical <code class="inlineCode">StructuredTaskScope</code>, let’s quickly cover the ridesharing service. An offer received from this service is shaped as a record:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">RidesharingOffer</span><span class="hljs-params">(String company, Duration </span>
<span class="hljs-params">  minutesToYou, Duration minutesToDest, </span><span class="hljs-type">double</span><span class="hljs-params"> price)</span> {}
</code></pre>
    <p class="normal">The core of our code starts by forking a task for each of the three ridesharing servers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RidesharingOffer
<span class="hljs-title">    fetchRidesharingOffers</span><span class="hljs-params">(String loc, String dest)</span> 
        <span class="hljs-keyword">throws</span> InterruptedException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">StructuredTaskScope</span> <span class="hljs-variable">scope</span> 
    <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>&lt;RidesharingOffer&gt;()) {
    Subtask&lt;RidesharingOffer&gt; carOneOffer
     = scope.fork(() -&gt; Ridesharing.carOneServer(loc, dest));
    Subtask&lt;RidesharingOffer&gt; starCarOffer
     = scope.fork(() -&gt; Ridesharing.starCarServer(loc, dest));
    Subtask&lt;RidesharingOffer&gt; topCarOffer
     = scope.fork(() -&gt; Ridesharing.topCarServer(loc, dest));
    scope.join();
    ...
</code></pre>
    <p class="normal">After <code class="inlineCode">scope.join()</code> finishes, we know that all subtasks have been finished successfully or exceptionally. We filter the results to<a id="_idIndexMarker1255"/> extract the cheapest offer. If no offer is available, then we collect all exceptions and wrap them in a custom <code class="inlineCode">RidesharingException</code>. Writing this as a functional programming snippet of code can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    <span class="hljs-type">RidesharingOffer</span> <span class="hljs-variable">offer</span>
     <span class="hljs-operator">=</span> Stream.of(carOneOffer, starCarOffer, topCarOffer)
     .filter(s -&gt; s.state() == Subtask.State.SUCCESS)
     .&lt;RidesharingOffer&gt;mapMulti((s, c) -&gt; {
        c.accept((RidesharingOffer) s.get());
     })
     .min(Comparator.comparingDouble(RidesharingOffer::price))
     .orElseThrow(() -&gt; {
       <span class="hljs-type">RidesharingException</span> <span class="hljs-variable">exceptionWrapper</span>
        <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RidesharingException</span>(<span class="hljs-string">"Ridesharing exception"</span>);
       Stream.of(carOneOffer, starCarOffer, topCarOffer)
             .filter(s -&gt; s.state() == Subtask.State.FAILED)
             .&lt;Throwable&gt;mapMulti((s, c) -&gt; {
                c.accept(s.exception());
             }).forEach(exceptionWrapper::addSuppressed);
      <span class="hljs-keyword">throw</span> exceptionWrapper;
      });  
     ...
</code></pre>
    <p class="normal">Finally, we return the offer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">    return</span> offer;
}
</code></pre>
    <p class="normal">A possible output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">RidesharingOffer[company=TopCar, minutesToYou=PT9M, minutesToDest=PT16M, price=7.62]
</code></pre>
    <p class="normal">Next, let’s focus on the public transport service. This service queries the public transport servers via a custom <code class="inlineCode">StructuredTaskScope</code>. A public transport offer is wrapped in the following record:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">PublicTransportOffer</span><span class="hljs-params">(String transport, </span>
<span class="hljs-params">  String station, LocalTime goTime)</span> {}
</code></pre>
    <p class="normal">The custom <code class="inlineCode">StructuredTaskScope</code> is named <code class="inlineCode">PublicTransportScope</code> and its goal is to analyze each subtask (<code class="inlineCode">Subtask</code>) and<a id="_idIndexMarker1256"/> to fetch the best offer. Extending the <code class="inlineCode">StructuredTaskScope</code> is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PublicTransportScope</span>
<span class="hljs-keyword">    extends</span> <span class="hljs-title">StructuredTaskScope</span>&lt;List&lt;PublicTransportOffer&gt;&gt; {
  ...
</code></pre>
    <p class="normal">A public transport server returns a <code class="inlineCode">List&lt;PublicTransportOffer&gt;</code>. For instance, there can be three trains, or five buses in a day that cover our route. We will get them all on a separate list.</p>
    <p class="normal">When we extend <code class="inlineCode">StructuredTaskScope</code>, we have to override a single method named <code class="inlineCode">handleComplete()</code>. This method is automatically invoked for each <code class="inlineCode">Subtask</code> that completes successfully or exceptionally. It is our job to collect and store the results for analysis later. To collect the results, we need a collection for valid results and a collection for exceptional results. These should be thread-safe collections since multiple <code class="inlineCode">Subtask</code> instances may complete (almost) at the same time, which leads to race conditions. For instance, we can use <code class="inlineCode">CopyOnWriteArrayList</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;List&lt;PublicTransportOffer&gt;&gt; results 
    = <span class="hljs-keyword">new</span> <span class="hljs-title">CopyOnWriteArrayList</span>&lt;&gt;();
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Throwable&gt; exceptions 
    = <span class="hljs-keyword">new</span> <span class="hljs-title">CopyOnWriteArrayList</span>&lt;&gt;();
  ...
</code></pre>
    <p class="normal">Next, we override <code class="inlineCode">handleComplete()</code>, and based on the <code class="inlineCode">Subtask</code> state, we collect the results accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Override</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleComplete</span><span class="hljs-params">(</span>
<span class="hljs-params">    Subtask&lt;? extends List&lt;PublicTransportOffer&gt;&gt; subtask)</span> {
<span class="hljs-keyword">    switch</span> (subtask.state()) {
      <span class="hljs-keyword">case</span> SUCCESS -&gt;
        results.add(subtask.get());
      <span class="hljs-keyword">case</span> FAILED -&gt;
        exceptions.add(subtask.exception());
      <span class="hljs-keyword">case</span> UNAVAILABLE -&gt;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalStateException</span>(
          <span class="hljs-string">"Subtask may still running ..."</span>);
    }
  }
  ...
</code></pre>
    <p class="normal">When we reach this point, we have collected all successful and exceptional results. It is time to analyze this data and recommend the best offer. We consider that the best offer is the offer that leaves the earliest no <a id="_idIndexMarker1257"/>matter whether it is by bus, train, tram, or subway. So, we just have to find the best <code class="inlineCode">goTime</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">public</span> PublicTransportOffer <span class="hljs-title">recommendedPublicTransport</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">super</span>.ensureOwnerAndJoined();
    <span class="hljs-keyword">return</span> results.stream()
      .flatMap(t -&gt; t.stream())
      .min(Comparator.comparing(PublicTransportOffer::goTime))
      .orElseThrow(<span class="hljs-built_in">this</span>::wrappingExceptions);
  }
  ...
</code></pre>
    <p class="normal">If we cannot find any valid offer, then we collect the exceptions and wrap them in a custom <code class="inlineCode">PublicTransportException</code> via the following helper:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">private</span> PublicTransportException <span class="hljs-title">wrappingExceptions</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">super</span>.ensureOwnerAndJoined();
    <span class="hljs-type">PublicTransportException</span> <span class="hljs-variable">exceptionWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> 
      <span class="hljs-title">PublicTransportException</span>(<span class="hljs-string">"Public transport exception"</span>);
    exceptions.forEach(exceptionWrapper::addSuppressed);
    <span class="hljs-keyword">return</span> exceptionWrapper;
  }
}
</code></pre>
    <p class="normal">Notice that both of these methods are calling the <code class="inlineCode">ensureOwnerAndJoined()</code> method. This built-in method guarantees that the current thread is the owner of this task scope (otherwise, it throws <code class="inlineCode">WrongThreadException</code>) and that it joined after forking subtasks via <code class="inlineCode">join()</code>/<code class="inlineCode">joinUntil()</code> (otherwise, it throws an <code class="inlineCode">IllegalStateException</code>).</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">As a rule of thumb it is good practice to rely on the <code class="inlineCode">ensureOwnerAndJoined()</code> check on every <code class="inlineCode">StructuredTaskScope</code> that needs to be called by the main task.</p>
    </div>
    <p class="normal">Done! Our custom <code class="inlineCode">StructuredTaskScope</code> is ready. Next, we <a id="_idIndexMarker1258"/>can use it by forking our tasks and calling the <code class="inlineCode">recommendedPublicTransport()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PublicTransportOffer
    <span class="hljs-title">fetchPublicTransportOffers</span><span class="hljs-params">(String loc, String dest)</span> 
        <span class="hljs-keyword">throws</span> InterruptedException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">PublicTransportScope</span> <span class="hljs-variable">scope</span> 
                <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">PublicTransportScope</span>()) {
    scope.fork(() -&gt; PublicTransport
      .busTransportServer(loc, dest));
    scope.fork(() -&gt; PublicTransport
      .subwayTransportServer(loc, dest));
    scope.fork(() -&gt; PublicTransport
      .trainTransportServer(loc, dest));
    scope.fork(() -&gt; PublicTransport
      .tramTransportServer(loc, dest));
    scope.join();
    <span class="hljs-type">PublicTransportOffer</span> <span class="hljs-variable">offer</span>
      <span class="hljs-operator">=</span> scope.recommendedPublicTransport();
    logger.info(offer.toString());
    <span class="hljs-keyword">return</span> offer;
  }
}
</code></pre>
    <p class="normal">A possible output looks like this:</p>
    <pre class="programlisting con"><code class="hljs-con">PublicTransportOffer[transport=Tram, station=Tram_station_0, goTime=10:26:39]
</code></pre>
    <p class="normal">Finally, we can call both services (ridesharing and public transport) as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">RidesharingOffer</span> <span class="hljs-variable">roffer</span>
  <span class="hljs-operator">=</span> fetchRidesharingOffers(loc, dest);
<span class="hljs-type">PublicTransportOffer</span> <span class="hljs-variable">ptoffer</span>
  <span class="hljs-operator">=</span> fetchPublicTransportOffers(loc, dest);
</code></pre>
    <p class="normal">So far, these two services run sequentially. In the next problem, we will run these two services concurrently by introducing another custom <code class="inlineCode">StructuredTaskScope</code>. Until then, you can challenge yourself to write a <a id="_idIndexMarker1259"/>custom <code class="inlineCode">StructuredTaskScope</code> for the ridesharing service as well.</p>
    <h1 id="_idParaDest-499" class="heading-1">228. Assembling StructuredTaskScope</h1>
    <p class="normal">In the previous problem (<em class="italic">Problem 227</em>), we developed an application containing a ridesharing service and a public transport service. In both services, we used <code class="inlineCode">StructuredTaskScope</code> to concurrently query the proper servers. However, only the servers were called concurrently while these two <a id="_idIndexMarker1260"/>services were executed sequentially – first, we run the ridesharing service (which queries concurrently three servers), and after we have a result from this service, we run the public transport service (which queries concurrently four servers).</p>
    <p class="normal">Going further, we want to assemble these two services into a third service capable of running them concurrently as in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_06.png" alt="Figure 11.6.png"/></figure>
    <p class="packt_figref">Figure 11.6: Running the ridesharing and public transport services concurrently</p>
    <p class="normal">We start by assembling the <code class="inlineCode">RidesharingOffer</code> and <code class="inlineCode">PublicTransportOffer</code> into a record named <code class="inlineCode">TravelOffer</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">TravelOffer</span><span class="hljs-params">(RidesharingOffer ridesharingOffer, </span>
<span class="hljs-params">  PublicTransportOffer publicTransportOffer)</span> {}
</code></pre>
    <p class="normal">Next, we write a custom <code class="inlineCode">StructuredTaskScope</code> that forks the two <code class="inlineCode">Callable</code> objects created in <em class="italic">Problem 227</em>. One <code class="inlineCode">Callable</code> represents the ridesharing services (already implemented in <em class="italic">Problem 227</em> via a classic <code class="inlineCode">StructuredTaskScope</code>), and the second <code class="inlineCode">Callable</code> represents the public transport services (already implemented in <em class="italic">Problem 227</em> via the custom <code class="inlineCode">PublicTransportScope</code>). We can name this <code class="inlineCode">StructuredTaskScope</code> as <code class="inlineCode">TravelScope</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TravelScope</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StructuredTaskScope</span>&lt;Travel&gt; {
  ...
</code></pre>
    <p class="normal">The <code class="inlineCode">StructuredTaskScope</code> is parametrized – notice the <code class="inlineCode">StructuredTaskScope&lt;Travel&gt;</code>. Since we have to fork different types of <code class="inlineCode">Callable</code> instances, it would be handy to rely on <code class="inlineCode">Object</code> and write <code class="inlineCode">StructuredTaskScope&lt;Object&gt;</code>. But this will not be very expressive and neat. We better define an interface<a id="_idIndexMarker1261"/> that narrows down the <code class="inlineCode">Object</code> domain and that is implemented by our <code class="inlineCode">Callable</code> instance’s results as follows (<em class="italic">sealed interfaces</em> were covered in detail in <em class="italic">Chapter 8</em>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Travel</span> 
  permits RidesharingOffer, PublicTransportOffer {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">RidesharingOffer</span><span class="hljs-params">(String company, </span>
<span class="hljs-params">  Duration minutesToYou, Duration minutesToDest, </span><span class="hljs-type">double</span><span class="hljs-params"> price)</span> 
    <span class="hljs-keyword">implements</span> <span class="hljs-title">Travel</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">PublicTransportOffer</span><span class="hljs-params">(String transport, </span>
<span class="hljs-params">  String station, LocalTime goTime)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Travel</span> {}
</code></pre>
    <p class="normal">Getting back to <code class="inlineCode">TravelScope</code>, we have to override the <code class="inlineCode">handleComplete()</code> method to handle each completed <code class="inlineCode">Subtask</code>. We know that the ridesharing service can return a valid result as a <code class="inlineCode">RidesharingOffer</code> or an exceptional result as a <code class="inlineCode">RidesharingException</code>. Moreover, the public transport service can return a valid result as <code class="inlineCode">PublicTransportOffer</code> or an exceptional result as a <code class="inlineCode">PublicTransportException</code>. We have to store these results in order to analyze them later when we create the <code class="inlineCode">TravelOffer</code> answer. So, we define the following variables to cover all possible cases:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RidesharingOffer ridesharingOffer;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> PublicTransportOffer publicTransportOffer;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RidesharingException ridesharingException;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> PublicTransportException
    publicTransportException;
  ...
</code></pre>
    <p class="normal">Next, we override the <code class="inlineCode">handleComplete()</code> and, exactly as in the case of <code class="inlineCode">PublicTransportScope</code>, we rely on a simple <code class="inlineCode">switch</code> to collect the results (for the <code class="inlineCode">SUCCESS</code> and <code class="inlineCode">FAILED</code> states, we need a nested <code class="inlineCode">switch</code> to distinguish between the offer/exception received from the ridesharing service and the offer/exception received from the public transport service):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">  @Override</span>
<span class="hljs-keyword">  protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleComplete</span><span class="hljs-params">(</span>
<span class="hljs-params">      Subtask&lt;? extends Travel&gt; subtask)</span> {
    <span class="hljs-keyword">switch</span> (subtask.state()) {
      <span class="hljs-keyword">case</span> SUCCESS -&gt; {
        <span class="hljs-keyword">switch</span> (subtask.get()) {
          <span class="hljs-keyword">case</span> RidesharingOffer ro -&gt;
            <span class="hljs-built_in">this</span>.ridesharingOffer = ro;
            <span class="hljs-keyword">case</span> PublicTransportOffer pto -&gt;
            <span class="hljs-built_in">this</span>.publicTransportOffer = pto;
        }
      }
      <span class="hljs-keyword">case</span> FAILED -&gt; {
        <span class="hljs-keyword">switch</span> (subtask.exception()) {
          <span class="hljs-keyword">case</span> RidesharingException re -&gt;
            <span class="hljs-built_in">this</span>.ridesharingException = re;
          <span class="hljs-keyword">case</span> PublicTransportException pte -&gt;
            <span class="hljs-built_in">this</span>.publicTransportException = pte;
          <span class="hljs-keyword">case</span> Throwable t -&gt;
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(t);
        }
      }
      <span class="hljs-keyword">case</span> UNAVAILABLE -&gt;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalStateException</span>(
          <span class="hljs-string">"Subtask may still running ..."</span>);
    }
  }
  ...
</code></pre>
    <p class="normal">Finally, we analyze these results <a id="_idIndexMarker1262"/>and create the proper <code class="inlineCode">TravelOffer</code>. One way to accomplish this is as follows (feel free to think of a cooler/smarter implementation):</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">public</span> TravelOffer <span class="hljs-title">recommendedTravelOffer</span><span class="hljs-params">()</span> {
    <span class="hljs-built_in">super</span>.ensureOwnerAndJoined();
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TravelOffer</span>(
      ridesharingOffer, publicTransportOffer);
  }
}
</code></pre>
    <p class="normal">Our <code class="inlineCode">TravelScope</code> is ready to be used. All we need to do is to fork our two services to be executed concurrently and call the <code class="inlineCode">recommendedTravelOffer()</code> method to get the best offer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TravelOffer <span class="hljs-title">fetchTravelOffers</span><span class="hljs-params">(</span>
<span class="hljs-params">    String loc, String dest)</span>
        <span class="hljs-keyword">throws</span> InterruptedException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">TravelScope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TravelScope</span>()) {
    scope.fork(() -&gt; fetchRidesharingOffers(loc, dest));
    scope.fork(() -&gt; fetchPublicTransportOffers(loc, dest));
    scope.join();
    <span class="hljs-keyword">return</span> scope.recommendedTravelOffer();
  }
}
</code></pre>
    <p class="normal">Now, instead of sequentially calling <code class="inlineCode">fetchRidesharingOffers()</code> and <code class="inlineCode">fetchPublicTransportOffers()</code>, we simply call <code class="inlineCode">fetchTravelOffers()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">TravelOffer</span> <span class="hljs-variable">toffer</span> <span class="hljs-operator">=</span> fetchTravelOffers(loc, dest);
</code></pre>
    <p class="normal">A possible output would be:</p>
    <pre class="programlisting con"><code class="hljs-con">TravelOffer[
  ridesharingOffer=RidesharingOffer[company=CarOne, 
  minutesToYou=PT5M, minutesToDest=PT5M, price=3.0], 
  publicTransportOffer=PublicTransportOffer[transport=Train, 
  station=Train_station_0, goTime=11:59:10]
]
</code></pre>
    <p class="normal">Mission accomplished! Now <a id="_idIndexMarker1263"/>you know how to write custom <code class="inlineCode">StructuredTaskScope</code> instances and how to assemble/nest them to shape complex concurrent models.</p>
    <h1 id="_idParaDest-500" class="heading-1">229. Assembling StructuredTaskScope instances with timeout</h1>
    <p class="normal">Let’s continue our journey from <em class="italic">Problem 228</em> by assuming that the ridesharing service should be implemented <a id="_idIndexMarker1264"/>with a timeout/deadline. In other words, if any of the ridesharing servers don’t answer in 10 milliseconds, then we abort the request and report the thrown <code class="inlineCode">TimeoutException</code> via a meaningful message to the user.</p>
    <p class="normal">This means that instead of <code class="inlineCode">scope.join()</code>, which waits indefinitely, we should use <code class="inlineCode">joinUntil(Instant deadline)</code>, which waits only for the given <code class="inlineCode">deadline</code> before throwing a <code class="inlineCode">TimeoutException</code>. So, the <code class="inlineCode">fetchRidesharingOffers()</code> method should be modified as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">RidesharingOffer fetchRidesharingOffers</span><span class="hljs-params">(</span>
<span class="hljs-params">    String loc, String dest)</span> 
      <span class="hljs-keyword">throws</span> InterruptedException, TimeoutException {
  <span class="hljs-keyword">try</span> (<span class="hljs-type">StructuredTaskScope</span> <span class="hljs-variable">scope</span> 
    <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StructuredTaskScope</span>&lt;RidesharingOffer&gt;()) {
    ...
    scope.joinUntil(Instant.now().plusMillis(<span class="hljs-number">10</span>));
    ...
  }
}
</code></pre>
    <p class="normal">By simply simulating a delay bigger <a id="_idIndexMarker1265"/>than 10 milliseconds in any of the ridesharing servers, we help this <code class="inlineCode">joinUntil()</code> to fail with a <code class="inlineCode">TimeoutException</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Ridesharing</span> { 
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RidesharingOffer <span class="hljs-title">carOneServer</span><span class="hljs-params">(</span>
<span class="hljs-params">    String loc, String dest)</span> <span class="hljs-keyword">throws</span> InterruptedException {
    ...
    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// simulating a delay</span>
    ...
  }
  ...
}
</code></pre>
    <p class="normal">In order to capture this <code class="inlineCode">TimeoutException</code> and replace it with a friendly message for the end user, we have to adapt the <code class="inlineCode">TravelScope</code> class. First, we define a variable to store the potential <code class="inlineCode">TimeoutException</code>. Second, we adapt the <code class="inlineCode">case FAILED</code> to populate this variable accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">TravelScope</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">StructuredTaskScope</span>&lt;Travel&gt; {
  ...
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> TimeoutException timeoutException;
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends Travel&gt; subtask)</span> {
    <span class="hljs-keyword">switch</span> (subtask.state()) {
      ...
      <span class="hljs-keyword">case</span> FAILED -&gt; {
        <span class="hljs-keyword">switch</span> (subtask.exception()) {
          ...
          <span class="hljs-keyword">case</span> TimeoutException te -&gt;
               <span class="hljs-built_in">this</span>.timeoutException = te;
          ...
        }
      }
      ...
    }
  }
  ... <span class="hljs-comment">// the recommendedTravelOffer() method from below</span>
}
</code></pre>
    <p class="normal">Third, we modify the <code class="inlineCode">recommendedTravelOffer()</code> method to return a friendly message if <code class="inlineCode">timeoutException</code> is not <code class="inlineCode">null</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> TravelOffer <span class="hljs-title">recommendedTravelOffer</span><span class="hljs-params">()</span> {
  <span class="hljs-built_in">super</span>.ensureOwnerAndJoined();
  <span class="hljs-keyword">if</span> (timeoutException != <span class="hljs-literal">null</span>) {
    logger.warning(<span class="hljs-string">"Some of the called services </span>
<span class="hljs-string">                    did not respond in time"</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TravelOffer</span>(
    ridesharingOffer, publicTransportOffer);
}
</code></pre>
    <p class="normal">If the ridesharing service <a id="_idIndexMarker1266"/>timeouts and the public transport service provides an offer, then the output should be something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">[14:53:34] [WARNING] Some of the called services
                     did not respond in time
[14:53:35] [INFO] TravelOffer[ridesharingOffer=null, publicTransportOffer=PublicTransportOffer[transport=Bus, station=Bus_station_2, goTime=15:02:34]]
</code></pre>
    <p class="normal">Done! Check out the bundled code to practice this example. Challenge yourself to add a timeout/deadline for the public transport service as well.</p>
    <h1 id="_idParaDest-501" class="heading-1">230. Hooking ThreadLocal and virtual threads</h1>
    <p class="normal">In a nutshell, <code class="inlineCode">ThreadLocal</code> was introduced in<a id="_idIndexMarker1267"/> JDK 1.2 (in 1998) as a solution to provide dedicated memory for each thread in order to share information with untrusted code (maybe some of your code has been written externally as third-party components) or<a id="_idIndexMarker1268"/> between different components (that may run in multiple threads) of your application. Basically, if you are in such a scenario, then you don’t want to (or you cannot) share information via method arguments. If you need a more in-depth introduction to the <code class="inlineCode">ThreadLocal</code> API, then consider <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 11</em>, <em class="italic">Problem 220</em>. </p>
    <p class="normal">A thread-local variable is of type <code class="inlineCode">ThreadLocal</code> and relies on <code class="inlineCode">set()</code> to set a value and on <code class="inlineCode">get()</code> to get a value. In <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition, </em>it was said that: “<em class="italic">If thread </em><code class="inlineCode">A</code><em class="italic"> stores the </em><code class="inlineCode">x</code><em class="italic"> value and thread </em><code class="inlineCode">B</code><em class="italic"> stores the </em><code class="inlineCode">y</code><em class="italic"> value in the same instance of </em><code class="inlineCode">ThreadLocal</code><em class="italic">, then later on, thread </em><code class="inlineCode">A</code><em class="italic"> retrieves the </em><code class="inlineCode">x</code><em class="italic"> value and thread </em><code class="inlineCode">B</code><em class="italic"> retrieves the </em><code class="inlineCode">y</code><em class="italic"> value. So, we can say that the </em><code class="inlineCode">x</code><em class="italic"> value is local to thread </em><code class="inlineCode">A</code><em class="italic">, while the </em><code class="inlineCode">y</code><em class="italic"> value is local to thread </em><code class="inlineCode">B</code><em class="italic">.”</em> Each thread that calls <code class="inlineCode">get()</code> or <code class="inlineCode">set()</code> has its own copy <a id="_idIndexMarker1269"/>of the <code class="inlineCode">ThreadLocal</code> variable.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Internally, <code class="inlineCode">ThreadLocal</code> manages a map (<code class="inlineCode">ThreadLocalMap</code>). The keys of the map are the threads, and the values are those values given via the <code class="inlineCode">set()</code> method. <code class="inlineCode">ThreadLocal</code> variables fit well for implementing the <em class="italic">one thread per request</em> model (for instance, one thread per HTTP request) since they allow us to easily manage the lifecycle of a request.</p>
    </div>
    <p class="normal">Typically, a thread-local variable is <a id="_idIndexMarker1270"/>global and static and it can be declared and initialized as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;StringBuilder&gt; threadLocal
  = ThreadLocal.&lt;StringBuilder&gt;withInitial(() -&gt; {
     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>(<span class="hljs-string">"Nothing here ..."</span>);
});
</code></pre>
    <p class="normal">A thread-local variable should be reachable in the code from where it is needed (sometimes from everywhere in the code). Basically, the current thread and all the threads spawned by this thread should have access to the thread-local variables. In our case, it is reachable from everywhere in the current class. Next, let’s consider the following <code class="inlineCode">Runnable</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; { 
  threadLocal.set(
    <span class="hljs-keyword">new</span> <span class="hljs-title">StringBuilder</span>(Thread.currentThread().toString()));
  logger.info(() -&gt; <span class="hljs-string">" before sleep -&gt; "</span> 
    + Thread.currentThread().toString()
       + <span class="hljs-string">" ["</span> + threadLocal.get() + <span class="hljs-string">"]"</span>);
  <span class="hljs-keyword">try</span> {
    Thread.sleep(Duration.ofSeconds(<span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>().nextInt(<span class="hljs-number">5</span>)));
  } <span class="hljs-keyword">catch</span> (InterruptedException ex) {} 
  logger.info(() -&gt; <span class="hljs-string">" after sleep -&gt; "</span> 
    + Thread.currentThread().toString()
        + <span class="hljs-string">" ["</span> + threadLocal.get() + <span class="hljs-string">"]"</span>);
  threadLocal.remove();
};
</code></pre>
    <p class="normal">Here, we set a thread-local value representing information about the current thread, we get and log that value, we sleep for a random number of seconds (between 0 and 5), and we log that value again. </p>
    <p class="normal">Next, let’s execute 10 tasks via <a id="_idIndexMarker1271"/>a classical fixed thread pool (platform threads):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
      <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>)) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    executor.submit(task);
  }
}
</code></pre>
    <p class="normal">A snippet of the output may<a id="_idIndexMarker1272"/> look as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[16:14:05] before sleep -&gt; Thread[#24,pool-1-thread-3,5,main] [Thread[#24,pool-1-thread-3,5,main]] 
[16:14:05] before sleep -&gt; Thread[#31,pool-1-thread-10,5,main] [Thread[#31,pool-1-thread-10,5,main]] 
[16:14:05] before sleep -&gt; Thread[#22,pool-1-thread-1,5,main] [Thread[#22,pool-1-thread-1,5,main]]
...
[16:14:06] after sleep -&gt; Thread[#24,pool-1-thread-3,5,main] [Thread[#24,pool-1-thread-3,5,main]] 
[16:14:07] after sleep -&gt; Thread[#31,pool-1-thread-10,5,main] [Thread[#31,pool-1-thread-10,5,main]] 
[16:14:09] after sleep -&gt; Thread[#22,pool-1-thread-1,5,main] [Thread[#22,pool-1-thread-1,5,main]]
...
</code></pre>
    <p class="normal">We can easily see that each of threads #24, #31, and #22 sets information about themselves, and this information is available after sleeping. For instance, thread #22 sets the value <code class="inlineCode">[Thread[#22,pool-1-thread-1,5,main]]</code>, and this value is exactly what it gets after sleeping for 4 seconds.</p>
    <p class="normal">Now, let’s switch to virtual threads:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
    <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    executor.submit(task);
  }
}
</code></pre>
    <p class="normal">The output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">[16:24:24] before sleep -&gt;VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 [VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3] 
[16:24:24] before sleep -&gt;VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 [VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5] 
[16:24:24] before sleep -&gt;VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 [VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6]
...
[16:24:24] after sleep -&gt;VirtualThread[#28]/runnable@ForkJoinPool-1-worker-3 [VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6]
[16:24:27] after sleep -&gt;VirtualThread[#25]/runnable@ForkJoinPool-1-worker-4 [VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3] 
[16:24:27] after sleep -&gt;VirtualThread[#27]/runnable@ForkJoinPool-1-worker-8 [VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5]
...
</code></pre>
    <p class="normal">We can easily see that each of threads #25, #27, and #28 sets information about themselves and this information is available <a id="_idIndexMarker1273"/>after the sleeping period. For instance, thread #25 sets the value <code class="inlineCode">[VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3]</code>, and this value is exactly what it gets after sleeping for 3 seconds.</p>
    <p class="normal">However, when we get this<a id="_idIndexMarker1274"/> information, thread #25 is executed on <em class="italic">worker-4</em>, not on <em class="italic">worker-3</em>, as the information reveals. Practically, thread #25 has been executed on <em class="italic">worker-3</em> when the information was set, and it has been executed on <em class="italic">worker-4</em> when the information (which remains unchanged) was get.</p>
    <p class="normal">This is perfectly normal since the thread was unmounted from <em class="italic">worker-3</em> when the execution hit the <code class="inlineCode">Thread.sleep()</code> blocking operation. After sleeping, it was mounted on <em class="italic">worker-4</em>. However, the information was not altered, so virtual threads and <code class="inlineCode">ThreadLocal</code> work together as expected. In other words, the mounting-unmounting cycles of a virtual thread don’t affect how <code class="inlineCode">ThreadLocal</code> works. <code class="inlineCode">ThreadLocal</code> variables are fully supported by virtual threads.</p>
    <h1 id="_idParaDest-502" class="heading-1">231. Hooking ScopedValue and virtual threads</h1>
    <p class="normal">The <code class="inlineCode">ScopedValue</code> API <a id="_idIndexMarker1275"/>was added to<a id="_idIndexMarker1276"/> handle the shortcomings of <code class="inlineCode">ThreadLocal</code>. But what are the shortcomings of <code class="inlineCode">ThreadLocal</code>? </p>
    <h2 id="_idParaDest-503" class="heading-2">Thread-local variables’ shortcomings</h2>
    <p class="normal">First of all, it is hard to say and track who’s mutating a thread-local variable. This is a shortcoming of the API design. Basically, a <code class="inlineCode">ThreadLocal</code> variable is globally available (at the application level or at a lower level), so it is hard to say from where it is mutated. Imagine that it is your responsibility to read, understand, and debug an application that uses several thread-local variables. How will you manage<a id="_idIndexMarker1277"/> to follow the code logic and how will you know, at any given time, what values are stored by these thread-local variables? It would be a nightmare to track these variables from class to class and to signal when they mutated.</p>
    <p class="normal">Second, thread-local variables may live forever or longer than they should. How is this possible? Thread-local variables will live as long as the platform threads that use them will live, or even longer. It is true that we can remove a thread-local variable from the internal map by explicitly calling <code class="inlineCode">remove()</code>. But, if we forget to call <code class="inlineCode">remove()</code>, then we just open the gate for memory leaks (we just hope that the garbage collector will collect this data at some point). Never forget to call <code class="inlineCode">remove()</code> when you are done with a thread-local variable used by a platform thread! On the other hand, if you are using thread-local variables with virtual threads, then there is no need to call <code class="inlineCode">remove()</code> because the thread-local variable is removed once the virtual thread dies.</p>
    <p class="normal">Third, thread-local variables are prone to being duplicated. When we create a new thread (child thread) from the current thread (parent thread), the child thread copies all thread-local variables of the parent thread. So, if we spawn multiple threads from the current thread that has a significant number of thread-local variables, then we will duplicate a significant number of these variables. This is true for platform threads and for virtual threads. Since thread-local variables are not immutable, we cannot simply share the reference between threads. We have to copy them. Of course, this cannot be good for the application since it will negatively impact the memory footprint of these variables (imagine a million virtual threads having copies of thread-local variables).</p>
    <h2 id="_idParaDest-504" class="heading-2">Introducing scoped values</h2>
    <p class="normal">Starting with JDK 20 (JEP 429) we have an alternative to thread-local variables called <em class="italic">scoped values</em>. This is meant to work with virtual threads and to overcome the shortcomings of thread-local variables. In JDK 20, this feature is<a id="_idIndexMarker1278"/> in the incubator phase, and in JDK 21 (JEP 446) it is in the preview phase, so don’t forget to run the code using the <code class="inlineCode">–code-preview</code> VM option.</p>
    <p class="normal">Scoped values allow us to share immutable information (no need to copy) across the application’s components and have a limited lifetime (no risk of memory leaks).</p>
    <p class="normal">As you’ll see, the <code class="inlineCode">ScopedValue</code> API is very neat and easy to use. To create a <code class="inlineCode">ScopedValue</code>, we just call a factory method named <code class="inlineCode">newInstance()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">ScopedValue&lt;String&gt; SCOPED_VALUE = ScopedValue.newInstance();
</code></pre>
    <p class="normal">Here, we’ve created a <code class="inlineCode">ScopedValue</code> (not bound) that is capable of carrying a value of type <code class="inlineCode">String</code> (of course, it could be anything else). You can declare it locally, globally, or however you need it to be declared depending on the place(s) that it should be accessible from. However, the value mapped to a <code class="inlineCode">ScopedValue</code> is available for the current thread and all threads spawned by the<a id="_idIndexMarker1279"/> current thread (so far, this is like <code class="inlineCode">ThreadLocal</code>) but it is restricted to a method call. We will clarify this shortly.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">A <code class="inlineCode">ScopedValue</code> is considered bound if a value is mapped to it. Otherwise, the <code class="inlineCode">ScopedValue</code> is considered not bound. We can check if a <code class="inlineCode">ScopedValue</code> is bound via the <code class="inlineCode">isBound()</code> flag method. This is an important check because if we attempt to get a value of a <code class="inlineCode">ScopedValue</code> that is not bound, then we will get back <code class="inlineCode">NoSuchElementException</code>. Besides <code class="inlineCode">isBound()</code>, we also have <code class="inlineCode">orElse()</code> and <code class="inlineCode">orElseThrow()</code>. Using <code class="inlineCode">orElse()</code>, we can set a default value for a <code class="inlineCode">ScopedValue</code> that is not bound, while via <code class="inlineCode">orElseThrow()</code>, we can throw a default exception.</p>
    </div>
    <p class="normal">A value can be mapped to a <code class="inlineCode">ScopedValue</code> (so, the <code class="inlineCode">ScopedValue</code> becomes bound to a value) via the <code class="inlineCode">where()</code> method. The syntax of this method is listed here:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Carrier <span class="hljs-title">where</span><span class="hljs-params">(ScopedValue&lt;T&gt; key, T value)</span>
</code></pre>
    <p class="normal">Or, via the <code class="inlineCode">runWhere()</code> and <code class="inlineCode">callWhere()</code> methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-keyword">void</span> <span class="hljs-title">runWhere</span><span class="hljs-params">(</span>
<span class="hljs-params">  ScopedValue&lt;T&gt; key, T value, Runnable op)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,R&gt; R <span class="hljs-title">callWhere</span><span class="hljs-params">(</span>
<span class="hljs-params">  ScopedValue&lt;T&gt; key, T value, Callable&lt;? extends R&gt; op)</span> 
    <span class="hljs-keyword">throws</span> Exception
</code></pre>
    <p class="normal">These three methods have in common the <code class="inlineCode">key</code> and <code class="inlineCode">value</code> parameters. The <code class="inlineCode">key</code> represents the <code class="inlineCode">ScopedValue</code> key (for instance, <code class="inlineCode">SCOPED_VALUE</code>), while the <code class="inlineCode">value</code> is the value mapped to this key. Whereas the <code class="inlineCode">where()</code> method just creates a <code class="inlineCode">ScopedValue</code> bound to a value, the <code class="inlineCode">runWhere()</code> method can create a <code class="inlineCode">ScopedValue</code> bound to a value and calls a <code class="inlineCode">Runnable</code> operation (<code class="inlineCode">op</code>) in the current thread, while <code class="inlineCode">callWhere()</code> calls a <code class="inlineCode">Callable</code> operation (<code class="inlineCode">op</code>) in the current thread. If you prefer to rely only on the <code class="inlineCode">where()</code> method, then simply rely on the following syntaxes:</p>
    <pre class="programlisting code"><code class="hljs-code">ScopedValue.where(key, value).run(op);  <span class="hljs-comment">// like runWhere()</span>
ScopedValue.where(key, value).call(op); <span class="hljs-comment">// like callWhere()</span>
</code></pre>
    <p class="normal">So, chaining <code class="inlineCode">where().run()</code> acts as <code class="inlineCode">runWhere()</code>, while <code class="inlineCode">where().call()</code> acts as <code class="inlineCode">callWhere()</code>. The advantage of using <code class="inlineCode">where()</code> suffixed with <code class="inlineCode">run()</code>/<code class="inlineCode">call()</code> consists of the fact that we can write <code class="inlineCode">ScopedValue.where(key1, value1).where(key2, value2),</code> …<code class="inlineCode">.run()/call()</code> to obtain multiple <code class="inlineCode">ScopedValue</code> instances<a id="_idIndexMarker1280"/> bound to their values. </p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">A <code class="inlineCode">ScopedValue</code> has no <code class="inlineCode">set()</code> method. Once we map a value to a <code class="inlineCode">ScopedValue</code>, we cannot change it (it is immutable). This means that the JVM doesn’t need to copy values around (remember that this is a shortcoming specific to <code class="inlineCode">ThreadLocal</code>).</p>
    </div>
    <p class="normal">The value is mapped to this key only for a method (<code class="inlineCode">Runnable</code> or <code class="inlineCode">Callable</code>) call. For instance, let’s assume the following <code class="inlineCode">Runnable</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">taskr</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE.isBound() ? 
    SCOPED_VALUE.get() : <span class="hljs-string">"Not bound"</span>);
};
</code></pre>
    <p class="normal">Via the <code class="inlineCode">isBound()</code> method, we can check if a <code class="inlineCode">ScopedValue</code> is bound (if it has a value). If a value is present, then we can successfully access it via the <code class="inlineCode">get()</code> method. Calling <code class="inlineCode">get()</code> for a <code class="inlineCode">ScopedValue</code> that is not bound will result in a <code class="inlineCode">NoSuchElementException</code> exception. For instance, if we run this task now:</p>
    <pre class="programlisting code"><code class="hljs-code">taskr.run();
</code></pre>
    <p class="normal">Then, the output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">Thread[#1,main,5,main] 
Not bound
</code></pre>
    <p class="normal">This is normal since we didn’t map any values to <code class="inlineCode">SCOPED_VALUE</code>.</p>
    <p class="normal">Next, we can use the <code class="inlineCode">where()</code> method to map a value to <code class="inlineCode">SCOPED_VALUE</code> and share this value with the previous <code class="inlineCode">Runnable</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Carrier</span> <span class="hljs-variable">cr</span> <span class="hljs-operator">=</span> ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom!"</span>);
cr.run(taskr);
</code></pre>
    <p class="normal">The <code class="inlineCode">Carrier</code> object is an immutable and thread-safe accumulator of key-value mappings that can be shared with a <code class="inlineCode">Runnable</code>/<code class="inlineCode">Callable</code>. By calling <code class="inlineCode">cr.run(taskr)</code>, we share the value <code class="inlineCode">Kaboooom!</code> with the <code class="inlineCode">Runnable</code>, so the output will be:</p>
    <pre class="programlisting con"><code class="hljs-con">Thread[#1,main,5,main] 
Kaboooom!
</code></pre>
    <p class="normal">But we can write this example more compactly as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom!"</span>).run(taskr);
</code></pre>
    <p class="normal">Or, by using <code class="inlineCode">runWhere()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">ScopedValue.runWhere(SCOPED_VALUE, <span class="hljs-string">"Kaboooom!"</span>, taskr);
</code></pre>
    <p class="normal">Calling <code class="inlineCode">taskr.run()</code> will output <code class="inlineCode">Not bound</code> again. This is happening because the <code class="inlineCode">ScopedValue</code> is bound only for a<a id="_idIndexMarker1281"/> method call. <em class="italic">Figure 11.7</em> highlights this via a more expressive example.</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_07.png" alt="Figure 11.7.png"/></figure>
    <p class="packt_figref">Figure 11.7: ThreadLocal vs. ScopedValue</p>
    <p class="normal">As you can see from this figure (left-hand side), once the thread local sets the value, <code class="inlineCode">Mike</code>, this value is available in <code class="inlineCode">sayHelloTL()</code> and in <code class="inlineCode">sayGoodByeTL()</code>. The value is bound to this thread. On the other hand (right-hand side), the value <code class="inlineCode">Mike</code> is mapped to a <code class="inlineCode">ScopedValue</code>, but this value is available only in <code class="inlineCode">sayHelloSV()</code>. This is happening because we bound the <code class="inlineCode">SCOPED_VALUE</code> only to the <code class="inlineCode">sayHelloSV()</code> method call. When the execution leaves the <code class="inlineCode">sayHelloSV()</code>, the <code class="inlineCode">SCOPED_VALUE</code> is not bound, and the value <code class="inlineCode">Mike</code> is not available anymore. If <code class="inlineCode">sayGoodByeSV()</code> was called from <code class="inlineCode">sayHelloSV()</code>, then the value <code class="inlineCode">Mike</code> would have been available. Or, if we call <code class="inlineCode">sayGoodByeSV()</code> as follows, then the value <code class="inlineCode">Mike</code> is available:</p>
    <pre class="programlisting code"><code class="hljs-code">ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Mike"</span>).run(
  () -&gt; sayGoodByeSV());
</code></pre>
    <p class="normal"><code class="inlineCode">ScopedValue</code> works with <code class="inlineCode">Callable</code> as well, but we have to replace <code class="inlineCode">run()</code> with <code class="inlineCode">call()</code>. For instance, let’s assume the following pretty dummy <code class="inlineCode">Callable</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">Callable&lt;Boolean&gt; taskc = () -&gt; {
  logger.info(Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE.isBound() ? 
    SCOPED_VALUE.get() : <span class="hljs-string">"Not bound"</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
};
</code></pre>
    <p class="normal">And the following sequence of calls:</p>
    <pre class="programlisting code"><code class="hljs-code">taskc.call();
ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-1!"</span>).call(taskc);
ScopedValue.callWhere(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-2!"</span>, taskc);
<span class="hljs-type">Carrier</span> <span class="hljs-variable">cc</span> <span class="hljs-operator">=</span> ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-3!"</span>);
cc.call(taskc);
taskc.call();
</code></pre>
    <p class="normal">Can you intuit the output? It <a id="_idIndexMarker1282"/>should be <code class="inlineCode">Not bound</code>, <code class="inlineCode">Kaboooom-1!</code>, <code class="inlineCode">Kaboooom-2!</code>, <code class="inlineCode">Kaboooom-3!</code>, and <code class="inlineCode">Not bound</code> again:</p>
    <pre class="programlisting con"><code class="hljs-con">Thread[#1,main,5,main] 
Not bound 
Thread[#1,main,5,main] 
Kaboooom-1! 
Thread[#1,main,5,main] 
Kaboooom-2! 
Thread[#1,main,5,main] 
Kaboooom-3! 
Thread[#1,main,5,main] 
Not bound
</code></pre>
    <p class="normal">So, let me emphasize this once again. A <code class="inlineCode">ScopedValue</code> is bound (it has a value) during a method call’s lifetime. The <code class="inlineCode">isBound()</code> will return <code class="inlineCode">false</code> outside this method.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">As you can see in this example, a <code class="inlineCode">ScopedValue</code> can have different values in the same thread. Here, the same <code class="inlineCode">Callable</code> was executed five times in the same thread.</p>
    </div>
    <p class="normal">Setting a <code class="inlineCode">ScopedValue</code> from a certain thread (other than the main thread) can be done quite easily. For instance, we can set a <code class="inlineCode">ScopedValue</code> from a platform thread as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">tpr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(() -&gt;
  ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-r!"</span>).run(taskr));
<span class="hljs-type">Thread</span> <span class="hljs-variable">tpc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(() -&gt; {
 <span class="hljs-keyword">try</span> {
  ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-c!"</span>).call(taskc);
 } <span class="hljs-keyword">catch</span> (Exception ex) { <span class="hljs-comment">/* handle exception */</span> }
});
</code></pre>
    <p class="normal">Or, via the <code class="inlineCode">ofPlatform()</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">tpr</span> <span class="hljs-operator">=</span> Thread.ofPlatform().unstarted(
 () -&gt; ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-r!"</span>)
  .run(taskr));
<span class="hljs-type">Thread</span> <span class="hljs-variable">tpc</span> <span class="hljs-operator">=</span> Thread.ofPlatform().unstarted(()-&gt; {
 <span class="hljs-keyword">try</span> {
  ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-c!"</span>).call(taskc);
 } <span class="hljs-keyword">catch</span> (Exception ex) { <span class="hljs-comment">/* handle exception */</span> }
});
</code></pre>
    <p class="normal">Mapping a <code class="inlineCode">ScopedValue</code> from a<a id="_idIndexMarker1283"/> certain virtual thread can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">tvr</span> <span class="hljs-operator">=</span> Thread.ofVirtual().unstarted(
 () -&gt; ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-r!"</span>)
  .run(taskr));
<span class="hljs-type">Thread</span> <span class="hljs-variable">tvc</span> <span class="hljs-operator">=</span> Thread.ofVirtual().unstarted(() -&gt; {
 <span class="hljs-keyword">try</span> {
  ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-c!"</span>).call(taskc);
 } <span class="hljs-keyword">catch</span> (Exception ex) { <span class="hljs-comment">/* handle exception */</span> }
});
</code></pre>
    <p class="normal">Here, we have two threads, and each of them maps a different value to <code class="inlineCode">SCOPED_VALUE</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">tpcx</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(() -&gt;
  ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-tpcx!"</span>)
    .run(taskr)); 
<span class="hljs-type">Thread</span> <span class="hljs-variable">tpcy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(() -&gt;
  ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-tpcy!"</span>)
    .run(taskr));
</code></pre>
    <p class="normal">So, the first thread (<code class="inlineCode">tpcx</code>) maps the value <code class="inlineCode">Kaboooom-tpcx!</code>, while the second thread (<code class="inlineCode">tpcy</code>) maps the value <code class="inlineCode">Kaboooom-tpcy!</code>. When <code class="inlineCode">taskr</code> is executed by <code class="inlineCode">tpcx</code>, the mapped value will be <code class="inlineCode">Kaboooom-tpcx!</code>, while when <code class="inlineCode">taskr</code> is executed by <code class="inlineCode">tpcy</code>, the mapped value will be <code class="inlineCode">Kaboooom-tpcy!</code>.</p>
    <p class="normal">Here is an example where <code class="inlineCode">tpca</code> maps the value <code class="inlineCode">Kaboooom-tpca!</code>, and <code class="inlineCode">tpcb</code> doesn’t map any value:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">tpca</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(() -&gt;
  ScopedValue.where(SCOPED_VALUE, <span class="hljs-string">"Kaboooom-tpca!"</span>)
    .run(taskr)); 
<span class="hljs-type">Thread</span> <span class="hljs-variable">tpcb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Thread</span>(taskr);
</code></pre>
    <p class="normal">Make sure to not conclude from this that a <code class="inlineCode">ScopedValue</code> is bound to a particular thread. The following note should clarify<a id="_idIndexMarker1284"/> this aspect.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">A <code class="inlineCode">ScopedValue</code> is bound to a particular method call not to a particular thread (as in the case of <code class="inlineCode">ThreadLocal</code>). In other words, a method can get a value of a <code class="inlineCode">ScopedValue</code> if the code that calls it has mapped it. Data/values are passed in one way only: from <em class="italic">caller</em> to <em class="italic">callee</em>. Otherwise, <code class="inlineCode">ScopedValue</code> is not bound and cannot be bounded and used in the current context of the method. As in the case of <code class="inlineCode">ThreadLocal</code>, a <code class="inlineCode">ScopedValue</code> is passed (and available) to all threads spawned by the task executed in the context of the current <code class="inlineCode">ScopedValue</code>.</p>
    </div>
    <p class="normal">Besides the <code class="inlineCode">isBound()</code> method, a <code class="inlineCode">ScopedValue</code> also has <code class="inlineCode">orElse()</code> and <code class="inlineCode">orElseThrow()</code>. Via <code class="inlineCode">orElse()</code>, we can specify an alternative/default value when the <code class="inlineCode">ScopedValue</code> is not bound, while via <code class="inlineCode">orElseThrow()</code>, we can throw a default exception. Here is an example of two <code class="inlineCode">Runnable</code> objects that use these methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">taskr1</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE.orElse(<span class="hljs-string">"Not bound"</span>));
};
<span class="hljs-type">Runnable</span> <span class="hljs-variable">taskr2</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE.orElseThrow(() -&gt;
    <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(<span class="hljs-string">"Not bound"</span>)));
};
</code></pre>
    <p class="normal">Of course, we can use these methods outside of <code class="inlineCode">Runnable</code>/<code class="inlineCode">Callable</code> as well. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">taskr</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE.get());
};
Thread.ofVirtual().start(() -&gt; ScopedValue.runWhere(
  SCOPED_VALUE, SCOPED_VALUE.orElse(<span class="hljs-string">"Kaboooom"</span>), taskr))
    .join();
Thread.ofVirtual().start(() -&gt; ScopedValue.runWhere(
  SCOPED_VALUE, SCOPED_VALUE.orElseThrow(() -&gt;
    <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(<span class="hljs-string">"Not bound"</span>)), taskr)).join();
</code></pre>
    <p class="normal">In the first virtual thread, we rely on <code class="inlineCode">orElse()</code> to map the value of <code class="inlineCode">SCOPED_VALUE</code>, so the <code class="inlineCode">SCOPED_VALUE.get()</code> from <code class="inlineCode">taskr</code> will return the <code class="inlineCode">Kaboooom</code> value. In the second virtual thread, we rely on <code class="inlineCode">orElseThrow()</code>, so <code class="inlineCode">taskr</code> will not be executed since the <code class="inlineCode">RuntimeException</code> will be<a id="_idIndexMarker1285"/> thrown. </p>
    <p class="normal">In the next problems, we will tackle more aspects of scoped values.</p>
    <h1 id="_idParaDest-505" class="heading-1">232. Using ScopedValue and executor services</h1>
    <p class="normal">In <em class="italic">Problem 230</em>, we wrote an application that combines <code class="inlineCode">ThreadLocal</code> and executor services (we have used <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> and <code class="inlineCode">newFixedThreadPool()</code>).</p>
    <p class="normal">In this problem, we re-write <a id="_idIndexMarker1286"/>the code from <em class="italic">Problem 230 </em>in order to use <code class="inlineCode">ScopedValue</code>. First, we have the following <code class="inlineCode">Runnable</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; { 
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | before sleep | "</span> + (SCOPED_VALUE.isBound() 
    ? SCOPED_VALUE.get() : <span class="hljs-string">"Not bound"</span>));
  <span class="hljs-keyword">try</span> {
    Thread.sleep(Duration.ofSeconds(<span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>().nextInt(<span class="hljs-number">5</span>)));
  } <span class="hljs-keyword">catch</span> (InterruptedException ex) {} 
  logger.info(() -&gt; Thread.currentThread().toString() 
    + <span class="hljs-string">" | after sleep | "</span> + (SCOPED_VALUE.isBound() 
    ? SCOPED_VALUE.get() : <span class="hljs-string">"Not bound"</span>));
};
</code></pre>
    <p class="normal">This code is straightforward. We retrieve the value mapped to <code class="inlineCode">SCOPED_VALUE</code>, we sleep from a random number of seconds (between 0 and 5), and we retrieve the value mapped to <code class="inlineCode">SCOPED_VALUE</code> again. Next, let’s run this code via <code class="inlineCode">newFixedThreadPool()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
    <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>)) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
    <span class="hljs-type">int</span> <span class="hljs-variable">copy_i</span> <span class="hljs-operator">=</span> i;
    executor.submit(() -&gt; ScopedValue.where(
      SCOPED_VALUE, <span class="hljs-string">"Kaboooom-"</span> + copy_i).run(task));
  }
}
</code></pre>
    <p class="normal">So, we have 10 platform threads and 10 tasks. Each thread maps the value <code class="inlineCode">Kaboooom-I</code> to <code class="inlineCode">SCOPED_VALUE</code> and calls the <code class="inlineCode">Runnable</code>. A possible output would be:</p>
    <pre class="programlisting con"><code class="hljs-con">Thread[#30,pool-1-thread-9,5,main] | before sleep | Kaboooom-8 
Thread[#24,pool-1-thread-3,5,main] | before sleep | Kaboooom-2 
Thread[#27,pool-1-thread-6,5,main] | before sleep | Kaboooom-5
...
Thread[#30,pool-1-thread-9,5,main] | after sleep | Kaboooom-8
Thread[#27,pool-1-thread-6,5,main] | after sleep | Kaboooom-5
Thread[#24,pool-1-thread-3,5,main] | after sleep | Kaboooom-2
...
</code></pre>
    <p class="normal">Let’s arbitrarily check out thread #27. Before sleeping, this thread sees the scoped value, <code class="inlineCode">Kabooom-2</code>. After sleeping, thread #27 sees the same value, <code class="inlineCode">Kabooom-2</code>. Each platform thread sees the scoped <a id="_idIndexMarker1287"/>value that was mapped when the thread was created and the task was submitted. So, we have the same behavior as in the case of using <code class="inlineCode">ThreadLocal</code>.</p>
    <p class="normal">Next, let’s switch to <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
<span class="hljs-operator">    =</span> Executors.newVirtualThreadPerTaskExecutor()) {
  ...
}
</code></pre>
    <p class="normal">Now, a possible output would be:</p>
    <pre class="programlisting con"><code class="hljs-con">VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
 | before sleep | Kaboooom-0 
VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 
 | before sleep | Kaboooom-2 
VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 
 | before sleep | Kaboooom-4
...
VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
| after sleep | Kaboooom-0
VirtualThread[#25]/runnable@ForkJoinPool-1-worker-1 
 | after sleep | Kaboooom-2 
VirtualThread[#27]/runnable@ForkJoinPool-1-worker-7 
 | after sleep | Kaboooom-4
...
</code></pre>
    <p class="normal">Again, we can conclude that each virtual thread sees the scoped value that was mapped when the thread was created and the task was submitted. The only difference is that virtual threads are running on different workers before and after sleeping.</p>
    <p class="normal">So, we can rely on <code class="inlineCode">ScopedValue</code> instead of <code class="inlineCode">ThreadLocal</code> and take advantage of all the goodies (see <em class="italic">Problem 231</em>) brought by this API in comparison to <code class="inlineCode">ThreadLocal</code>.</p>
    <h1 id="_idParaDest-506" class="heading-1">233. Chaining and rebinding scoped values</h1>
    <p class="normal">In this problem, you’ll see how to <em class="italic">chain</em> and <em class="italic">rebind</em> scoped values. These are very handy operations that you’ll love to use.</p>
    <h2 id="_idParaDest-507" class="heading-2">Changing scoped values</h2>
    <p class="normal">Let’s assume that we<a id="_idIndexMarker1288"/> have three <code class="inlineCode">ScopedValue</code> instances, as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; SCOPED_VALUE_1 
 = ScopedValue.newInstance();
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; SCOPED_VALUE_2 
 = ScopedValue.newInstance();
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; SCOPED_VALUE_3 
 = ScopedValue.newInstance();
</code></pre>
    <p class="normal">We also have a <code class="inlineCode">Runnable</code> that uses all three <code class="inlineCode">ScopedValue</code> instances:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE_1.isBound() 
    ? SCOPED_VALUE_1.get() : <span class="hljs-string">"Not bound"</span>);
  logger.info(() -&gt; SCOPED_VALUE_2.isBound() 
    ? SCOPED_VALUE_2.get() : <span class="hljs-string">"Not bound"</span>);
  logger.info(() -&gt; SCOPED_VALUE_3.isBound() 
    ? SCOPED_VALUE_3.get() : <span class="hljs-string">"Not bound"</span>);
};
</code></pre>
    <p class="normal">We can map the values to these three <code class="inlineCode">ScopedValue</code> instances by simply chaining the <code class="inlineCode">where()</code> calls. This is a very convenient way to set up multiple scoped values:</p>
    <pre class="programlisting code"><code class="hljs-code">ScopedValue.where(SCOPED_VALUE_1, <span class="hljs-string">"Kaboooom - 1"</span>)
           .where(SCOPED_VALUE_2, <span class="hljs-string">"Kaboooom - 2"</span>)
           .where(SCOPED_VALUE_3, <span class="hljs-string">"</span><span class="hljs-string">Kaboooom - 3"</span>)
           .run(task);
</code></pre>
    <p class="normal">That’s all! Quite simple!</p>
    <h2 id="_idParaDest-508" class="heading-2">Rebinding scoped values</h2>
    <p class="normal">Let’s imagine that we <a id="_idIndexMarker1289"/>have two <code class="inlineCode">Runnable</code> objects, <code class="inlineCode">taskA</code>, and <code class="inlineCode">taskB</code>. We start with <code class="inlineCode">taskB</code>, which is straightforward:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">taskB</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(() -&gt; <span class="hljs-string">"taskB:"</span> 
    + Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE_1.isBound() 
    ? SCOPED_VALUE_1.get() : <span class="hljs-string">"Not bound"</span>);
  logger.info(() -&gt; SCOPED_VALUE_2.isBound() 
    ? SCOPED_VALUE_2.get() : <span class="hljs-string">"Not bound"</span>);
  logger.info(() -&gt; SCOPED_VALUE_3.isBound() 
    ? SCOPED_VALUE_3.get() : <span class="hljs-string">"Not bound"</span>);
};
</code></pre>
    <p class="normal">So, <code class="inlineCode">taskB</code> simply logs three <code class="inlineCode">ScopedValue</code> instances. Next, <code class="inlineCode">taskA</code> needs only <code class="inlineCode">SCOPED_VALUE_1</code>, but it also has to call <code class="inlineCode">taskB</code>. So, <code class="inlineCode">taskA</code> should <a id="_idIndexMarker1290"/>map the proper values for <code class="inlineCode">SCOPED_VALUE_2</code> and <code class="inlineCode">SCOPED_VALUE_3</code>. How about <code class="inlineCode">SCOPED_VALUE_1</code>? Well, <code class="inlineCode">taskA</code> doesn’t want to pass the current value of <code class="inlineCode">SCOPED_VALUE_1</code> to <code class="inlineCode">taskB</code>, so it must rebind this scoped value as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">taskA</span> <span class="hljs-operator">=</span> () -&gt; {
  logger.info(() -&gt; <span class="hljs-string">"taskA: "</span> 
    + Thread.currentThread().toString());
  logger.info(() -&gt; SCOPED_VALUE_1.isBound() 
    ? SCOPED_VALUE_1.get() : <span class="hljs-string">"</span><span class="hljs-string">Not bound"</span>);
  ScopedValue.where(SCOPED_VALUE_1, <span class="hljs-string">"No kaboooom"</span>) <span class="hljs-comment">// rebind</span>
             .where(SCOPED_VALUE_2, <span class="hljs-string">"Kaboooom - 2"</span>)
             .where(SCOPED_VALUE_3, <span class="hljs-string">"Kaboooom - 3"</span>)
             .run(taskB);
  logger.info(() -&gt; SCOPED_VALUE_1.isBound() 
    ? SCOPED_VALUE_1.get() : <span class="hljs-string">"Not bound"</span>);
  logger.info(() -&gt; SCOPED_VALUE_2.isBound() 
    ? SCOPED_VALUE_2.get() : <span class="hljs-string">"Not bound"</span>);
  logger.info(() -&gt; SCOPED_VALUE_3.isBound() 
    ? SCOPED_VALUE_3.get() : <span class="hljs-string">"Not bound"</span>);
};
</code></pre>
    <p class="normal">Calling <code class="inlineCode">taskA</code> maps a value only to <code class="inlineCode">SCOPED_VALUE_1</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">ScopedValue.where(SCOPED_VALUE_1, <span class="hljs-string">"Kaboooom - 1"</span>).run(taskA);
</code></pre>
    <p class="normal">The output will be as follows (the comments have been manually added; they are not part of the output):</p>
    <pre class="programlisting con"><code class="hljs-con">taskA: Thread[#1,main,5,main] 
Kaboooom - 1 
taskB: Thread[#1,main,5,main] 
No kaboooom                   // this is the rebinded value
Kaboooom - 2 
Kaboooom - 3 
Kaboooom– 1                   // back in taskA
Not bound
Not bound
</code></pre>
    <p class="normal">So, <code class="inlineCode">taskA</code> sees the value <code class="inlineCode">Kabooom-1</code> for <code class="inlineCode">SCOPED_VALUE_1</code>, but it doesn’t pass this value to <code class="inlineCode">taskB</code>. It rebinds this scoped value to <code class="inlineCode">No kaboooom</code>. This is the value that lands in <code class="inlineCode">taskB</code> next to <code class="inlineCode">Kaboooom -2</code> and <code class="inlineCode">Kaboooom -3</code>, which has been mapped for <code class="inlineCode">SCOPED_VALUE_2</code> and <code class="inlineCode">SCOPED_VALUE_3</code>. This technique is useful if you don’t want to allow a certain scoped value to go beyond your goals <a id="_idIndexMarker1291"/>or if you just need another value. Once the execution gets back in <code class="inlineCode">taskA</code>, the <code class="inlineCode">SCOPED_VALUE_1</code> is restored to <code class="inlineCode">Kaboooom - 1</code>, so the initial value is not lost and is available in <code class="inlineCode">taskA</code>. On the other hand, <code class="inlineCode">SCOPED_VALUE_2</code> and <code class="inlineCode">SCOPED_VALUE_3</code> are not bound. They have been bound only for the execution of <code class="inlineCode">taskB</code>. How cool is that?!</p>
    <h1 id="_idParaDest-509" class="heading-1">234. Using ScopedValue and StructuredTaskScope</h1>
    <p class="normal">In this problem, we will reiterate the <a id="_idIndexMarker1292"/>application developed in <em class="italic">Problems 227 </em>and <em class="italic">228</em>, and we will enrich it with a few <code class="inlineCode">ScopedValue</code> variables for implementing new features. I’ll consider that you are already familiar with that application.</p>
    <p class="normal">The <code class="inlineCode">ScopedValue</code> that we plan to add are listed here (these are added in the main class because we want them to be accessible at the application level):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; USER 
  = ScopedValue.newInstance();
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; LOC 
  = ScopedValue.newInstance();
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; DEST 
  = ScopedValue.newInstance();
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;Double&gt; CAR_ONE_DISCOUNT 
  = ScopedValue.newInstance();
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;Boolean&gt;
  PUBLIC_TRANSPORT_TICKET = ScopedValue.newInstance();
</code></pre>
    <p class="normal">First, let’s focus on the <code class="inlineCode">fetchTravelOffers()</code> method, which is the point from where we fork our two tasks, <code class="inlineCode">fetchRidesharingOffers()</code> and <code class="inlineCode">fetchPublicTransportOffers()</code>. The code that calls <code class="inlineCode">fetchTravelOffers() </code>gets modified as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">TravelOffer offer;
<span class="hljs-keyword">if</span> (user != <span class="hljs-literal">null</span> &amp;&amp; !user.isBlank()) { <span class="hljs-comment">// is user logged in ?</span>
  offer = ScopedValue.where(USER, user)
    .call(() -&gt; fetchTravelOffers(loc, dest));
} <span class="hljs-keyword">else</span> {
  offer = fetchTravelOffers(loc, dest);
}
</code></pre>
    <p class="normal">So, our travel page needs the user credentials (for simplicity, only the username). If the user is logged in, then we should have a valid username and we can share it with <code class="inlineCode">fetchTravelOffers()</code> via the <code class="inlineCode">USER</code> scoped value. If the user is not logged in, then <code class="inlineCode">USER</code> remains unbound. The <code class="inlineCode">fetchTravelOffers()</code> gets modified as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TravelOffer <span class="hljs-title">fetchTravelOffers</span><span class="hljs-params">(</span>
<span class="hljs-params">    String loc, String dest)</span> <span class="hljs-keyword">throws</span> Exception {
  <span class="hljs-keyword">return</span> ScopedValue
    .where(LOC, loc)
    .where(DEST, dest)
    .call(() -&gt; {
      <span class="hljs-keyword">try</span> (<span class="hljs-type">TravelScope</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TravelScope</span>()) {
        <span class="hljs-keyword">if</span> (USER.isBound()) {
          scope.fork(() -&gt; fetchRidesharingOffers());
        } <span class="hljs-keyword">else</span> {
          logger.warning(<span class="hljs-string">"Ridesharing services can be </span>
<span class="hljs-string">                          accessed only by login users"</span>);
        }
        scope.fork(() -&gt;
          ScopedValue.where(PUBLIC_TRANSPORT_TICKET, <span class="hljs-literal">true</span>)
            .call(Main::fetchPublicTransportOffers));
        scope.join();
        <span class="hljs-keyword">return</span> scope.recommendedTravelOffer();
      }
    });
}
</code></pre>
    <p class="normal">There are a lot of things happening in this code, so let’s take it one by one.</p>
    <p class="normal">The ridesharing<a id="_idIndexMarker1293"/> service is accessible only for logged-in users, so we call it only if <code class="inlineCode">USER</code> is bound. Otherwise, we log a message for the user:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (USER.isBound()) {
  scope.fork(() -&gt; fetchRidesharingOffers());
} <span class="hljs-keyword">else</span> {
  logger.warning(<span class="hljs-string">"Ridesharing services can be </span>
<span class="hljs-string">                  accessed only by login users"</span>);
</code></pre>
    <p class="normal">On the other hand, the public transport service doesn’t require the user to be logged in. However, in order to use public transport we need a special ticket. We have such a ticket and we share it with the public transport service via the <code class="inlineCode">PUBLIC_TRANSPORT_TICKET</code> scoped value:</p>
    <pre class="programlisting code"><code class="hljs-code">scope.fork(() -&gt;
  ScopedValue.where(PUBLIC_TRANSPORT_TICKET, <span class="hljs-literal">true</span>)
    .call(Main::fetchPublicTransportOffers));
</code></pre>
    <p class="normal">The <code class="inlineCode">PUBLIC_TRANSPORT_TICKET</code> scoped value will be accessible only from the public transport service (only from <code class="inlineCode">fetchPublicTransportOffers()</code> and other methods called from this one).</p>
    <p class="normal">Next, the ridesharing and public transport services need our location and destination. This information is collected from the user/client and passed as arguments in <code class="inlineCode">fetchTravelOffers()</code>. Thereafter, we <a id="_idIndexMarker1294"/>map this information to <code class="inlineCode">LOC</code> and <code class="inlineCode">DEST</code> scoped values:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">return</span> ScopedValue
    .where(LOC, loc)
    .where(DEST, dest)
    .call(() -&gt; {
       ...
    });
</code></pre>
    <p class="normal">Now, <code class="inlineCode">LOC</code> and <code class="inlineCode">DEST</code> are bound and are accessible only from ridesharing and public transport services. They will be shared with all threads forked from these services.</p>
    <p class="normal">Next, let’s check out the ridesharing service, <code class="inlineCode">fetchRidesharingOffers()</code>. This service checks if the user is logged in and logs a meaningful message:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RidesharingOffer <span class="hljs-title">fetchRidesharingOffers</span><span class="hljs-params">()</span> 
    <span class="hljs-keyword">throws</span> InterruptedException, Exception {
  logger.info(() -&gt; <span class="hljs-string">"Ridesharing: Processing request for "</span>
   + USER.orElseThrow(() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(
     <span class="hljs-string">"Ridesharing: User not login"</span>)));
  ...
}
</code></pre>
    <p class="normal">One of the ridesharing companies (<code class="inlineCode">CarOne</code>) provides a random discount to its clients. We have a discount of 0.5 that we can map to <code class="inlineCode">CAR_ONE_DISCOUNT</code> scoped value:</p>
    <pre class="programlisting code"><code class="hljs-code">Subtask&lt;RidesharingOffer&gt; carOneOffer
  = scope.fork(() -&gt; ScopedValue.where(CAR_ONE_DISCOUNT, <span class="hljs-number">0.5</span>)
    .call(Ridesharing::carOneServer)); 
</code></pre>
    <p class="normal">If we visit the scoped values status in the context of <code class="inlineCode">fetchRidesharingOffers()</code>, then we can say that the <code class="inlineCode">USER</code> scoped value was bound at the application level, so it should be available everywhere in the application. The <code class="inlineCode">LOC</code> and <code class="inlineCode">DEST</code> scoped values have been bound in <code class="inlineCode">fetchTravelOffers()</code>, so they are also available in <code class="inlineCode">fetchRidesharingOffers()</code>. On the other hand, <code class="inlineCode">PUBLIC_TRANSPORT_TICKET</code> is not available (not bound) in <code class="inlineCode">fetchRidesharingOffers()</code>.</p>
    <p class="normal">Next, let’s focus on the public transport service, <code class="inlineCode">fetchPublicTransportOffers()</code>. This service doesn’t require the user to be logged in, but it can use this information to log a friendly message as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> PublicTransportOffer
    <span class="hljs-title">fetchPublicTransportOffers</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
  logger.info(() -&gt; <span class="hljs-string">"Public Transport: Processing </span>
<span class="hljs-string">    request for "</span> + USER.orElse(<span class="hljs-string">"anonymous"</span>));
  ...
}
</code></pre>
    <p class="normal">If we briefly review the current status of the scoped values in the context of <code class="inlineCode">fetchPublicTransportOffers()</code>, then we can say that the <code class="inlineCode">USER</code> scoped value was bound at the application level, so it should be available everywhere in the application. The <code class="inlineCode">LOC</code> and <code class="inlineCode">DEST</code> scoped values have been bound in <code class="inlineCode">fetchTravelOffers()</code>, so they are also available in <code class="inlineCode">fetchPublicTransportOffers()</code>. On the other hand, <code class="inlineCode">PUBLIC_TRANSPORT_TICKET</code> and <code class="inlineCode">CAR_ONE_DISCOUNT</code> are <a id="_idIndexMarker1295"/>not available (not bound) in <code class="inlineCode">fetchPublicTransportOffers()</code>.</p>
    <p class="normal">At this point, we have used all five scoped values. We continue to track them in the <code class="inlineCode">Ridesharing</code> class, which simulates the ridesharing servers. In this class, we have access to <code class="inlineCode">USER</code>, <code class="inlineCode">DEST</code>, and <code class="inlineCode">LOC</code> scoped values. Moreover, only in <code class="inlineCode">carOneServer()</code> do we have access to <code class="inlineCode">CAR_ONE_DISCOUNT</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> RidesharingOffer <span class="hljs-title">carOneServer</span><span class="hljs-params">()</span> {
  ...
  <span class="hljs-keyword">if</span> (CAR_ONE_DISCOUNT.isBound()) {
    logger.info(() -&gt; <span class="hljs-string">"Congrats "</span> + USER.get()
      + <span class="hljs-string">"! You have a discount of "</span>
      + CAR_ONE_DISCOUNT.orElse(<span class="hljs-number">0.0</span>));
    price = price - CAR_ONE_DISCOUNT.orElse(<span class="hljs-number">0.0</span>);
  }
  ...
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RidesharingException</span>(
    <span class="hljs-string">"No drivers are available at CarOne for route: "</span>
      + LOC.get() + <span class="hljs-string">" -&gt; "</span> + DEST.get());
}
</code></pre>
    <p class="normal">So, if we have a discount (and we have one), the server of <code class="inlineCode">CarOne</code> will apply it. If no drivers are available for our route, then the server will throw a meaningful exception. This exception is thrown from <code class="inlineCode">topCarServer()</code> and <code class="inlineCode">starCarServer()</code> as well. These are the servers of <code class="inlineCode">TopCar</code> company and the <code class="inlineCode">StarCar</code> company respectively.</p>
    <p class="normal">Ok, so far so good! Next, let’s check out the <code class="inlineCode">PublicTransport</code> class, which simulates the public transport servers. In this class, we have access to <code class="inlineCode">USER</code>, <code class="inlineCode">DEST</code>, <code class="inlineCode">LOC</code>, and <code class="inlineCode">PUBLIC_TRANSPORT_TICKET</code> scoped values. We arbitrarily choose one of the servers (all of them use the same core code) and list <a id="_idIndexMarker1296"/>here the code that we are interested in:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;PublicTransportOffer&gt;
      <span class="hljs-title">tramTransportServer</span><span class="hljs-params">()</span> {
  List&lt;PublicTransportOffer&gt; listOfOffers = <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;();
  <span class="hljs-type">Random</span> <span class="hljs-variable">rnd</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Random</span>();
  <span class="hljs-type">boolean</span> <span class="hljs-variable">makeAnOffer</span> <span class="hljs-operator">=</span> rnd.nextBoolean();
  <span class="hljs-keyword">if</span> (makeAnOffer &amp;&amp; PUBLIC_TRANSPORT_TICKET.isBound() 
    &amp;&amp; PUBLIC_TRANSPORT_TICKET.get()) {
    ...
  }
  <span class="hljs-keyword">if</span> (listOfOffers.isEmpty()) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RidesharingException</span>(
      <span class="hljs-string">"No public tram-transport is available for route: "</span>
        + LOC.get() + <span class="hljs-string">" -&gt; "</span> + DEST.get());
  }
  <span class="hljs-keyword">return</span> listOfOffers;
}
</code></pre>
    <p class="normal">As you can see, the public transport services can make an offer only if we have a special ticket that is verified via the <code class="inlineCode">PUBLIC_TRANSPORT_TICKET</code> scoped value. If no public tram transport is available for our route, then the server throws an exception that uses the <code class="inlineCode">LOC</code> and <code class="inlineCode">DEST</code> scoped values to build a meaningful message.</p>
    <p class="normal">Done! Using <code class="inlineCode">ScopedValue</code> with <code class="inlineCode">StructuredTaskScope</code> allows us to design complex concurrent models. </p>
    <h1 id="_idParaDest-510" class="heading-1">235. Using Semaphore instead of Executor</h1>
    <p class="normal">Let’s say that we have <a id="_idIndexMarker1297"/>the following task (<code class="inlineCode">Runnable</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; {
  <span class="hljs-keyword">try</span> {
    Thread.sleep(<span class="hljs-number">5000</span>);
  } <span class="hljs-keyword">catch</span> (InterruptedException ex) { <span class="hljs-comment">/* handle exception */</span> }
  logger.info(Thread.currentThread().toString());
};
</code></pre>
    <p class="normal">And we plan to execute this task 15 times by 3 threads:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER_OF_TASKS</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER_OF_THREADS</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
</code></pre>
    <p class="normal">We can easily solve this<a id="_idIndexMarker1298"/> problem via <code class="inlineCode">Executors.newFixedThreadPool()</code> and platform threads:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// using cached platform threads</span>
<span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> 
  Executors.newFixedThreadPool(NUMBER_OF_THREADS)) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NUMBER_OF_TASKS; i++) {
    executor.submit(task);
  }
}
</code></pre>
    <p class="normal">A snippet of the possible output:</p>
    <pre class="programlisting con"><code class="hljs-con">Thread[#24,pool-1-thread-3,5,main] 
Thread[#22,pool-1-thread-1,5,main] 
Thread[#23,pool-1-thread-2,5,main] 
Thread[#22,pool-1-thread-1,5,main] 
Thread[#24,pool-1-thread-3,5,main] 
Thread[#23,pool-1-thread-2,5,main]
...
</code></pre>
    <p class="normal">As you can see, the application has only three platform threads (#22, #23, and #24).</p>
    <p class="normal">But, we already know that platform threads are expensive and it will be better to rely on virtual threads. The problem is that we cannot simply replace this fixed thread pool with <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> because we can’t control the number of threads. While we want to use only 3 threads, the virtual thread executor will allocate a virtual thread per task, so we will end up with 15 threads. </p>
    <p class="normal">In order to control the number of virtual threads, we can rely on <code class="inlineCode">Semaphore</code> (if you want more details about this topic you can check out <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 10</em>, <em class="italic">Problem 211</em>). First, we declare a <code class="inlineCode">Semaphore</code> with <code class="inlineCode">NUMBER_OF_THREADS</code> permits:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Semaphore</span>(NUMBER_OF_THREADS);
</code></pre>
    <p class="normal">Next, we rely on <code class="inlineCode">semaphore.acquire()</code> and <code class="inlineCode">semaphore.release()</code> to control the access to these permits and execute <code class="inlineCode">NUMBER_OF_TASKS</code> tasks as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">vt</span> <span class="hljs-operator">=</span> Thread.currentThread();
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NUMBER_OF_TASKS; i++) {
  vt = Thread.ofVirtual().start(() -&gt; {
    <span class="hljs-keyword">try</span> {
      semaphore.acquire();
    } <span class="hljs-keyword">catch</span> (InterruptedException ex) { <span class="hljs-comment">/* handle it */</span> }
      <span class="hljs-keyword">try</span> {
        task.run();
      } <span class="hljs-keyword">finally</span> {
        semaphore.release();
      }
  });
}
vt.join();
</code></pre>
    <p class="normal">A snippet of the possible <a id="_idIndexMarker1299"/>output:</p>
    <pre class="programlisting con"><code class="hljs-con">VirtualThread[#27]/runnable@ForkJoinPool-1-worker-2 
VirtualThread[#33]/runnable@ForkJoinPool-1-worker-8 
VirtualThread[#28]/runnable@ForkJoinPool-1-worker-3 
VirtualThread[#30]/runnable@ForkJoinPool-1-worker-3 
VirtualThread[#25]/runnable@ForkJoinPool-1-worker-8 
VirtualThread[#31]/runnable@ForkJoinPool-1-worker-4
...
</code></pre>
    <p class="normal">Here, we have six virtual threads (#27, #33, #28, #30, #25, and #31), not three. The idea is that the <code class="inlineCode">Semaphore</code> allows only three virtual threads to be created and to run concurrently at a time. You can probe this statement by running the code by yourself. After the first three virtual threads are created, they will sleep for 5 seconds. But because virtual threads are cheap, they do not go back into a thread pool, so they are not reused. It is much cheaper to create another three to use and throw. The idea is that there will not be more than three at a time.</p>
    <h1 id="_idParaDest-511" class="heading-1">236. Avoiding pinning via locking</h1>
    <p class="normal">Remember from <em class="italic">Chapter 10</em>, <em class="italic">Problem 213</em>, that a virtual thread is pinned (not unmounted from its carrier thread) when the execution goes<a id="_idIndexMarker1300"/> through a <code class="inlineCode">synchronized</code> block of code. For instance, the following <code class="inlineCode">Runnable</code> will cause virtual threads to be pinned:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Runnable</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> () -&gt; {
  <span class="hljs-keyword">synchronized</span> (Main.class) {
    <span class="hljs-keyword">try</span> {
      Thread.sleep(<span class="hljs-number">1000</span>);
    } <span class="hljs-keyword">catch</span> (InterruptedException ex) { <span class="hljs-comment">/* handle it */</span> }
    logger.info(() -&gt; <span class="hljs-string">"Task-1 | "</span> 
      + Thread.currentThread().toString());
  }
};
</code></pre>
    <p class="normal">The <code class="inlineCode">synchronized</code> block contains a blocking operation (<code class="inlineCode">sleep()</code>), but the virtual thread that hits this point of execution is not unmounted. It is pinned on its carrier thread. Let’s try to capture this behavior via the <a id="_idIndexMarker1301"/>following executor:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NUMBER_OF_TASKS</span> <span class="hljs-operator">=</span> <span class="hljs-number">25</span>;
<span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
<span class="hljs-operator">     =</span> Executors.newVirtualThreadPerTaskExecutor()) {
  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; NUMBER_OF_TASKS; i++) {
    executor.submit(task1);
  }
}
</code></pre>
    <p class="normal">A possible output would look as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">Task-1 | VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
Task-1 | VirtualThread[#30]/runnable@ForkJoinPool-1-worker-8 
Task-1 | VirtualThread[#29]/runnable@ForkJoinPool-1-worker-7 
Task-1 | VirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 
Task-1 | VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 
Task-1 | VirtualThread[#26]/runnable@ForkJoinPool-1-worker-4 
Task-1 | VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 
Task-1 | VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 
Task-1 | VirtualThread[#37]/runnable@ForkJoinPool-1-worker-3 
Task-1 | VirtualThread[#36]/runnable@ForkJoinPool-1-worker-4 
Task-1 | VirtualThread[#35]/runnable@ForkJoinPool-1-worker-5 
Task-1 | VirtualThread[#34]/runnable@ForkJoinPool-1-worker-6
...
</code></pre>
    <p class="normal">Check out the workers! Because the virtual threads are pinned on their carriers, the application uses all the available workers (eight on my machine). The workers are not accessible during that <code class="inlineCode">sleep(1000)</code>, so they are not available to execute other tasks. In other words, a carrier thread is available only after the virtual thread finishes its execution.</p>
    <p class="normal">But, we can avoid this situation by re-writing the application via <code class="inlineCode">ReentrantLock</code> instead of <code class="inlineCode">synchronized</code>. If you want more details about <code class="inlineCode">ReentrantLock</code>, then you can check out <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 11</em>, <em class="italic">Problems 222</em> and <em class="italic">223</em>. So, considering that you are familiar with <code class="inlineCode">ReentrantLock</code>, we can come up with the following non-pinned solution:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ReentrantLock</span>();
<span class="hljs-type">Runnable</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> () -&gt; {
  lock.lock();
  <span class="hljs-keyword">try</span> {
    Thread.sleep(<span class="hljs-number">1000</span>);
    logger.info(() -&gt; <span class="hljs-string">"Task-2 | "</span> 
      + Thread.currentThread().toString());
  } <span class="hljs-keyword">catch</span> (InterruptedException ex) { <span class="hljs-comment">/* handle it */</span>
  } <span class="hljs-keyword">finally</span> {
    lock.unlock();
  }
};
</code></pre>
    <p class="normal">We execute this code via the same <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">executor.submit(task2);
</code></pre>
    <p class="normal">Let’s analyze a snippet of a possible output:</p>
    <pre class="programlisting con"><code class="hljs-con">Task-2 | VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
Task-2 | VirtualThread[#24]/runnable@ForkJoinPool-1-worker-1 
Task-2 | VirtualThread[#25]/runnable@ForkJoinPool-1-worker-5 
Task-2 | VirtualThread[#26]/runnable@ForkJoinPool-1-worker-1 
Task-2 | VirtualThread[#27]/runnable@ForkJoinPool-1-worker-3 
Task-2 | VirtualThread[#28]/runnable@ForkJoinPool-1-worker-1 
Task-2 | VirtualThread[#29]/runnable@ForkJoinPool-1-worker-3 
Task-2 | VirtualThread[#30]/runnable@ForkJoinPool-1-worker-1 
Task-2 | VirtualThread[#31]/runnable@ForkJoinPool-1-worker-3 
Task-2 | VirtualThread[#33]/runnable@ForkJoinPool-1-worker-1 
Task-2 | VirtualThread[#32]/runnable@ForkJoinPool-1-worker-5 
Task-2 | VirtualThread[#34]/runnable@ForkJoinPool-1-worker-1
...
</code></pre>
    <p class="normal">This time, we can see that only three workers are used, <em class="italic">worker-1</em>, <em class="italic">3</em>, and <em class="italic">5</em>. Because the virtual threads are not pinned, they can free up their carrier threads. This way, the platform threads can be reused and we<a id="_idIndexMarker1302"/> save the rest of the resources for other tasks. If pinning is intensive, then it will affect the scalability of the application, so it is recommended to revisit your <code class="inlineCode">synchronized</code> code and, whenever achievable, replace it with <code class="inlineCode">ReentrantLock</code>.</p>
    <h1 id="_idParaDest-512" class="heading-1">237. Solving the producer-consumer problem via virtual threads</h1>
    <p class="normal">Let’s assume that we want to write a<a id="_idIndexMarker1303"/> program simulating an assembly line (or a conveyor) for checking and packing bulbs using two workers. By checking, we mean that the worker tests if the bulb lights up or not. By packing, we mean that the worker takes the verified build and puts it in a box.</p>
    <p class="normal">Next, let’s assume a fixed number of producers (3), and a fixed number of consumers (2); let’s represent it via the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_08.png" alt="Figure 11.8.png"/></figure>
    <p class="packt_figref">Figure 11.8: The producer-consumer problem with a fixed number of workers</p>
    <p class="normal">We can implement this scenario via the well-known <code class="inlineCode">Executors.newFixedThreadPool(PRODUCERS)</code>, <code class="inlineCode">Executors.newFixedThreadPool(CONSUMERS)</code>, and <code class="inlineCode">ConcurrentLinkedQueue</code> as the temporary storage for checked bulbs, as you can see at <a href="https://github.com/PacktPublishing/Java-Coding-Problems/tree/master/Chapter10/P203_ThreadPoolFixed_ConcurrentLinkedQueue"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems/tree/master/Chapter10/P203_ThreadPoolFixed_ConcurrentLinkedQueue</span></a>. </p>
    <p class="normal">Let’s consider this code as legacy<a id="_idIndexMarker1304"/> and let’s refactor it via virtual threads. All we have to do is to replace <code class="inlineCode">Executors.newFixedThreadPool()</code> (executor used for producers and consumers) with <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService producerService;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService consumerService;
...
producerService = Executors.newVirtualThreadPerTaskExecutor();
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; PRODUCERS; i++) {
  producerService.execute(producer);
}
consumerService = Executors.newVirtualThreadPerTaskExecutor();
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; CONSUMERS; i++) {
  consumerService.execute(consumer);
}
</code></pre>
    <p class="normal">That’s all! Isn’t it astonishing how easily we refactor this code to move from platform threads to virtual threads? The possible output is listed here:</p>
    <pre class="programlisting con"><code class="hljs-con">Checked: bulb-106 by producer: VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 
Checked: bulb-58 by producer: VirtualThread[#25]/runnable@ForkJoinPool-1-worker-2 
Packed: bulb-106 by consumer: VirtualThread[#26]/runnable@ForkJoinPool-1-worker-2 
Packed: bulb-58 by consumer: VirtualThread[#27]/runnable@ForkJoinPool-1-worker-5
...
</code></pre>
    <p class="normal">Of course, you’ll find the complete <a id="_idIndexMarker1305"/>code on GitHub. Take your time to get familiar with it especially if you didn’t read the first edition of this book. We will rely on this code in the following two problems as well.</p>
    <h1 id="_idParaDest-513" class="heading-1">238. Solving the producer-consumer problem via virtual threads (fixed via Semaphore)</h1>
    <p class="normal">In the previous problem, we implemented<a id="_idIndexMarker1306"/> the producer-consumer problem via a fixed number of producers (three virtual threads) and consumers (two virtual threads). Moreover, since our application works as an assembly line, we can say that the number of tasks is boundless. Practically, the producers and consumers work without breaks until the assembly line is stopped. This means the virtual threads assigned by the executor as producers and consumers remain exactly the same between a start-stop lifecycle of the assembly line.</p>
    <p class="normal">Next, let’s assume that we want to use <code class="inlineCode">Semaphore</code> objects instead of <code class="inlineCode">newVirtualThreadPerTaskExecutor()</code> to obtain the exact same behavior.</p>
    <p class="normal">Based on <em class="italic">Problem 235</em>, we can implement the fixed number of producers as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">producerService</span>
<span class="hljs-operator">    =</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Semaphore</span>(PRODUCERS);
...
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; PRODUCERS; i++) {
  Thread.ofVirtual().start(() -&gt; {
    <span class="hljs-keyword">try</span> {
      producerService.acquire();
    } <span class="hljs-keyword">catch</span> (InterruptedException ex) {  <span class="hljs-comment">/* handle it */</span> }
    <span class="hljs-keyword">try</span> {
      producer.run();
    } <span class="hljs-keyword">finally</span> {
      producerService.release();
    }
  });
}
</code></pre>
    <p class="normal">And the fixed number of consumers is shaped as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">consumerService</span>
<span class="hljs-operator">    =</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Semaphore</span>(CONSUMERS);
...
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; CONSUMERS; i++) {
  Thread.ofVirtual().start(() -&gt; {
    <span class="hljs-keyword">try</span> {
      consumerService.acquire();
    } <span class="hljs-keyword">catch</span> (InterruptedException ex) { <span class="hljs-comment">/* handle it */</span> }
    <span class="hljs-keyword">try</span> {
      consumer.run();
    } <span class="hljs-keyword">finally</span> {
      consumerService.release();
    }
  });
}
</code></pre>
    <p class="normal">In the next problem, we will<a id="_idIndexMarker1307"/> complicate things a little bit.</p>
    <h1 id="_idParaDest-514" class="heading-1">239. Solving the producer-consumer problem via virtual threads (increase/decrease consumers)</h1>
    <p class="normal">Let’s continue our producer-consumer problem<a id="_idIndexMarker1308"/> with another scenario that starts with three producers and two consumers:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PRODUCERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONSUMERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;
</code></pre>
    <p class="normal">Let’s assume that each producer checks a bulb in no more than one second. However, a consumer (packer) needs a maximum of 10 seconds to pack a bulb. The producer and consumer times can be shaped as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_PROD_TIME_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> * <span class="hljs-number">1000</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_CONS_TIME_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span> * <span class="hljs-number">1000</span>;
</code></pre>
    <p class="normal">Obviously, in these conditions, the consumers cannot face the incoming flux. The queue (here, <code class="inlineCode">LinkedBlockingQueue</code>) used for storing bulbs until they are packed will continuously increase. The producers will push into this queue much faster than the consumers can poll. </p>
    <p class="normal">Since we have only two consumers, we have to increase their number to be able to handle and stabilize the queue’s load. But, after a while, the producers will get tired and will need more time to check each bulb. If the producers slow down the production rate, the number of consumers should be decreased as well since many of them will just sit there. Later on, the producers may speed up again, and so on.</p>
    <p class="normal">This kind of problem can be solved via <code class="inlineCode">newCachedThreadPool()</code> and platform threads. If you are not familiar with this topic then you can find more details in <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 10</em>, <em class="italic">Problem 204</em>.</p>
    <p class="normal">How about solving it via virtual threads? We can start the producers and consumers via two <code class="inlineCode">Semaphore</code> objects exactly as we did in <em class="italic">Problem 238</em>. Next, we need to monitor the queue size and act accordingly. Let’s assume that we should take action only if the queue size is greater than five bulbs:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_QUEUE_SIZE_ALLOWED</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;
</code></pre>
    <p class="normal">Moreover, let’s assume that we can increase the number of consumers up to 50:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_NUMBER_OF_CONSUMERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;
</code></pre>
    <p class="normal">We want to monitor the queue <a id="_idIndexMarker1309"/>every 3 seconds with an initial delay of 5 seconds, so we can rely on a <code class="inlineCode">ScheduledExecutorService</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ScheduledExecutorService monitorService;
</code></pre>
    <p class="normal">The <code class="inlineCode">monitorQueueSize()</code> method is responsible for initializing the <code class="inlineCode">monitorService</code> and calling <code class="inlineCode">addNewConsumer()</code>, <code class="inlineCode">removeConsumer()</code>, and log the status as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> 
  <span class="hljs-variable">MONITOR_QUEUE_INITIAL_DELAY_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MONITOR_QUEUE_RATE_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">3000</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nrOfConsumers</span>
  <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AtomicInteger</span>(CONSUMERS);
...
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">monitorQueueSize</span><span class="hljs-params">()</span> {
  monitorService = Executors
    .newSingleThreadScheduledExecutor();
  monitorService.scheduleAtFixedRate(() -&gt; {
    <span class="hljs-keyword">if</span> (queue.size() &gt; MAX_QUEUE_SIZE_ALLOWED
      &amp;&amp; nrOfConsumers.get() &lt; MAX_NUMBER_OF_CONSUMERS) {
      addNewConsumer();
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (nrOfConsumers.get() &gt; CONSUMERS) {
      removeConsumer();
    }
  }
  logger.warning(() -&gt; <span class="hljs-string">"### Bulbs in queue: "</span> + queue.size()
    + <span class="hljs-string">" | Consumers waiting: "</span> 
      + consumerService.getQueueLength()
    + <span class="hljs-string">" | Consumer available permits: "</span> 
      + consumerService.availablePermits()
    + <span class="hljs-string">"</span><span class="hljs-string"> | Running consumers: "</span> + nrOfConsumers.get());
  }, MONITOR_QUEUE_INITIAL_DELAY_MS, 
     MONITOR_QUEUE_RATE_MS, TimeUnit.MILLISECONDS);
}
</code></pre>
    <p class="normal">So, if the queue size is above <code class="inlineCode">MAX_QUEUE_SIZE_ALLOWED</code> and the number of consumers is under <code class="inlineCode">MAX_NUMBER_OF_CONSUMERS</code>, then we should add a new consumer. This can be done by releasing a new permit for the <code class="inlineCode">Semaphore</code> that handles the consumers. Releasing a permit when the number of current <a id="_idIndexMarker1310"/>permits is zero will simply add a new permit, so a new virtual thread can acquire this permit and become a new consumer:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNewConsumer</span><span class="hljs-params">()</span> {
  logger.warning(<span class="hljs-string">"### Adding a new consumer ..."</span>);
  <span class="hljs-keyword">if</span> (consumerService.availablePermits() == <span class="hljs-number">0</span>) {
    consumerService.release();
  }
  Thread.ofVirtual().start(() -&gt; {
    <span class="hljs-keyword">try</span> {
      consumerService.acquire();
    } <span class="hljs-keyword">catch</span> (InterruptedException ex) { <span class="hljs-comment">/* handle it */</span> }
    <span class="hljs-keyword">try</span> {
      consumer.run();
    } <span class="hljs-keyword">finally</span> {
      consumerService.release();
    }
  });
  nrOfConsumers.incrementAndGet();
}
</code></pre>
    <p class="normal">Most likely, when the producers slow down the production rate, there will be too many consumers that just hand on. In such cases, we have to interrupt virtual threads until we manage to balance the work between producers and consumers. The <code class="inlineCode">removeConsumer()</code> method is responsible for signaling that a consumer must be interrupted, and for this, it sets an <code class="inlineCode">AtomicBoolean</code> to <code class="inlineCode">true</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span>
    <span class="hljs-variable">removeConsumer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AtomicBoolean</span>();
...
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeConsumer</span><span class="hljs-params">()</span> {
  logger.warning(<span class="hljs-string">"### Removing a consumer ..."</span>);
  removeConsumer.set(<span class="hljs-literal">true</span>);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">Consumer</code> checks this flag at each run and when it is <code class="inlineCode">true</code>, it will simply interrupt the currently running virtual<a id="_idIndexMarker1311"/> thread:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">while</span> (runningConsumer) {
      ...
      <span class="hljs-keyword">if</span> (removeConsumer.get()) {
        nrOfConsumers.decrementAndGet();
        removeConsumer.set(<span class="hljs-literal">false</span>);
        Thread.currentThread().interrupt();
      }
    }
  }
}
</code></pre>
    <p class="normal">In order to simulate the decrease in the production rate for producers, we can rely on <code class="inlineCode">ScheduledExecutorService</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> extraProdTime;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXTRA_TIME_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span> * <span class="hljs-number">1000</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SLOW_DOWN_PRODUCER_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">150</span> * <span class="hljs-number">1000</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ScheduledExecutorService slowdownerService;
...
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">slowdownProducer</span><span class="hljs-params">()</span> {
  slowdownerService = Executors
    .newSingleThreadScheduledExecutor();
  slowdownerService.schedule(() -&gt; {
    logger.warning(<span class="hljs-string">"### Slow down the producers ..."</span>);
    extraProdTime = EXTRA_TIME_MS;
  }, SLOW_DOWN_PRODUCER_MS, TimeUnit.MILLISECONDS);
}
</code></pre>
    <p class="normal">So, we start the assembly line and the producers will check bulbs at a very high rate. After 2.5 minutes, we decrease this rate by adding an extra time of 4 seconds for each producer via the <code class="inlineCode">extraProdTime</code> variable. Initially, this is 0, but after 2.5 minutes it becomes 4000. Since it is part of the production time it will slow down the producer by 4 seconds:</p>
    <pre class="programlisting code"><code class="hljs-code">Thread.sleep(rnd.nextInt(MAX_PROD_TIME_MS) + extraProdTime);
</code></pre>
    <p class="normal">Let’s try to trace a run of our assembly line to see how it works. So, we start the assembly line and, pretty soon, we <a id="_idIndexMarker1312"/>notice that the number of bulbs in the queue (27) is greater than 5 and the application started to add consumers:</p>
    <pre class="programlisting con"><code class="hljs-con">...
[14:20:41] [INFO] Checked: bulb-304 by producer: VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
[14:20:42] [INFO] Checked: bulb-814 by producer: VirtualThread[#24]/runnable@ForkJoinPool-1-worker-1 
[14:20:42] [INFO] Checked: bulb-155 by producer: VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
<span class="code-highlight"><strong class="hljs-con-slc">[14:20:42] [WARNING] ### Adding a new consumer ... </strong></span>
[14:20:42] [INFO] Checked: bulb-893 by producer: <span class="code-highlight"><strong class="hljs-con-slc">VirtualThread[#25]/runnable@ForkJoinPool-1-worker-1 </strong></span>
<span class="code-highlight"><strong class="hljs-con-slc">[14:20:42] [WARNING] ### Bulbs in queue: 27 | Consumers waiting: 0 | Consumer available permits: 0 | Running consumers: 3</strong></span>
...
</code></pre>
    <p class="normal">The application continues to add consumers while the number of unprocessed bulbs keeps growing (here we have 237 bulbs in the queue and 32 consumers):</p>
    <pre class="programlisting con"><code class="hljs-con">...
[14:22:09] [INFO] Checked: bulb-388 by producer: VirtualThread[#25]/runnable@ForkJoinPool-1-worker-1 
[14:22:09] [INFO] Packed: bulb-501 by consumer: VirtualThread[#43]/runnable@ForkJoinPool-1-worker-1 
[14:22:09] [INFO] Packed: bulb-768 by consumer: VirtualThread[#27]/runnable@ForkJoinPool-1-worker-3 
<span class="code-highlight"><strong class="hljs-con-slc">[14:22:09] [WARNING] ### Adding a new consumer ... </strong></span>
<span class="code-highlight"><strong class="hljs-con-slc">[14:22:09] [WARNING] ### Bulbs in queue: 237 | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: 32</strong></span>
...
</code></pre>
    <p class="normal">When the application reaches around 37 consumers, the queue size enters a descending trend. Here you can see two consecutive logs of queue status (meanwhile, the application is still adding more consumers – it does this until the <code class="inlineCode">queue.size()</code> is less than 5):</p>
    <pre class="programlisting con"><code class="hljs-con">...
[14:22:24] [WARNING] ### Adding a new consumer ... 
[14:22:24] [WARNING] ### Bulbs in queue: <span class="code-highlight"><strong class="hljs-con-slc">214</strong></span> | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: <span class="code-highlight"><strong class="hljs-con-slc">37</strong></span>
...
[14:22:27] [WARNING] ### Adding a new consumer ... 
[14:22:27] [WARNING] ### Bulbs in queue: <span class="code-highlight"><strong class="hljs-con-slc">203</strong></span> | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: <span class="code-highlight"><strong class="hljs-con-slc">38</strong></span>
...
</code></pre>
    <p class="normal">The queue size continues to decrease and the number of consumers reaches the maximum of 50. At some point, the queue is <a id="_idIndexMarker1313"/>depleted. The number of customers is much higher than needed so they are removed one by one. Here is the moment when the last consumer (consumer #50 was removed):</p>
    <pre class="programlisting con"><code class="hljs-con">...
[14:23:15] [INFO] Packed: bulb-180 by consumer: VirtualThread[#46]/runnable@ForkJoinPool-1-worker-3 
[14:23:15] [INFO] Packed: bulb-261 by consumer: VirtualThread[#67]/runnable@ForkJoinPool-1-worker-3 
<span class="code-highlight"><strong class="hljs-con-slc">[14:23:15] [WARNING] ### Removing a consumer ... </strong></span>
<span class="code-highlight"><strong class="hljs-con-slc">[14:23:15] [WARNING] ### Bulbs in queue: 0 | Consumers waiting: 0 | Consumer available permits: 1 | Running consumers: 49</strong></span>
...
</code></pre>
    <p class="normal">While the application continues to calibrate itself by removing consumers, the producers slow down:</p>
    <pre class="programlisting con"><code class="hljs-con">...
[14:23:07] [WARNING] ### Slow down the producers ...
...
</code></pre>
    <p class="normal">Since the producers have slowed down, the number of consumers continues to decrease and the queue load can be processed by two consumers:</p>
    <pre class="programlisting con"><code class="hljs-con">...
<span class="code-highlight"><strong class="hljs-con-slc">[14:28:24] [WARNING] ### Bulbs in queue: 3 | Consumers waiting: 0 | Consumer available permits: 48 | Running consumers: 2</strong></span>
[14:28:26] [INFO] Checked: bulb-812 by producer: VirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 
[14:28:26] [INFO] Packed: bulb-207 by consumer: VirtualThread[#102]/runnable@ForkJoinPool-1-worker-3 
...
<span class="code-highlight"><strong class="hljs-con-slc">[14:28:27] [WARNING] ### Bulbs in queue: 4 | Consumers waiting: 0 | Consumer available permits: 48 | Running consumers: 2</strong></span>
[14:28:28] [INFO] Checked: bulb-259 by producer: VirtualThread[#24]/runnable@ForkJoinPool-1-worker-3 
...
<span class="code-highlight"><strong class="hljs-con-slc">[14:28:30] [WARNING] ### Bulbs in queue: 3 | Consumers waiting: 0 | Consumer available permits: 48 | Running consumers: 2</strong></span>
...
</code></pre>
    <p class="normal">At this point, the assembly line is calibrated. If the producers increase their production rate again then the application is ready to respond. As you can see, the consumer’s <code class="inlineCode">Semaphore</code> has 48 permits available, so we<a id="_idIndexMarker1314"/> shouldn’t create them again. If you want to remove the permit corresponding to an interrupted consumer then you have to extend the <code class="inlineCode">Semaphore</code> class and override the <code class="inlineCode">protected</code> method <code class="inlineCode">reducePermits()</code>. The number of permits is just a counter; so, in this scenario, removing permits is not really necessary.</p>
    <h1 id="_idParaDest-515" class="heading-1">240. Implementing an HTTP web server on top of virtual threads</h1>
    <p class="normal">Implementing a simple HTTP web server in Java is quite easy since we already have an API ready to guide and serve our goals. We start from the <code class="inlineCode">HttpServer</code> class (this class is present in the <code class="inlineCode">com.sun.net.httpserver</code> package), which allows us to achieve our goal straightforwardly in a few steps.</p>
    <p class="normal">Before jumping into the code, let’s<a id="_idIndexMarker1315"/> quickly mention that our web server will allow us to choose between platform and virtual threads and between non-locking or locking (for instance, to simulate access to a database). We will make these choices via two boolean parameters of our <code class="inlineCode">startWebServer(boolean virtual, boolean withLock)</code> method, named <code class="inlineCode">virtual</code> and <code class="inlineCode">withLock</code>, respectively. So, we will have four possible configurations.</p>
    <p class="normal">First, we create an <code class="inlineCode">HttpServer</code> via the <code class="inlineCode">create()</code> method. At this point, we also set up the port of our web server: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_NR_OF_THREADS</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WEBSERVER_PORT</span> <span class="hljs-operator">=</span> <span class="hljs-number">8001</span>;
<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startWebServer</span><span class="hljs-params">(</span>
<span class="hljs-type">    boolean</span><span class="hljs-params"> virtual, </span><span class="hljs-type">boolean</span><span class="hljs-params"> withLock)</span> <span class="hljs-keyword">throws</span> IOException {
  <span class="hljs-type">HttpServer</span> <span class="hljs-variable">httpServer</span> = HttpServer
    .create(<span class="hljs-keyword">new</span> <span class="hljs-title">InetSocketAddress</span>(WEBSERVER_PORT), <span class="hljs-number">0</span>);
  ...
</code></pre>
    <p class="normal">Next, we create the web server context by specifying the access page and the handler that will deal with the HTTP requests (the <code class="inlineCode">WebServerHandler</code> is implemented later):</p>
    <pre class="programlisting code"><code class="hljs-code">  httpServer.createContext(<span class="hljs-string">"/webserver"</span>, 
    <span class="hljs-keyword">new</span> <span class="hljs-title">WebServerHandler</span>(withLock));
  ...
</code></pre>
    <p class="normal">Next, we can choose the executor service (override the default one) that will orchestrate the threads of our web server. This can be done via the <code class="inlineCode">setExecutor()</code> method. Since we can choose between platform threads (we arbitrarily chose to have 200 such threads) and virtual threads, we have to cover both cases as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">if</span> (virtual) {
    httpServer.setExecutor(
      Executors.newVirtualThreadPerTaskExecutor());
  } <span class="hljs-keyword">else</span> {
    httpServer.setExecutor(
      Executors.newFixedThreadPool(MAX_NR_OF_THREADS));
  }
  ...
</code></pre>
    <p class="normal">Finally, we call the <code class="inlineCode">start()</code> method to start the web server, and we log this accordingly:</p>
    <pre class="programlisting code"><code class="hljs-code">  httpServer.start();
  logger.info(() -&gt; <span class="hljs-string">" Server started on port "</span> 
    + WEBSERVER_PORT);
}
</code></pre>
    <p class="normal">Next, we focus on the <code class="inlineCode">WebServerHandler</code> class, which implements the <code class="inlineCode">com.sun.net.httpserver.HttpHandler</code> interface and is responsible for handling the incoming HTTP requests. We<a id="_idIndexMarker1316"/> simulate an HTTP request processing by sleeping 200 milliseconds and create a simple <code class="inlineCode">String</code> response via a <code class="inlineCode">Callable</code> named <code class="inlineCode">task</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">WebServerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpHandler</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span>
    <span class="hljs-operator">=</span> Logger.getLogger(WebServerHandler.class.getName());
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">PERMITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span>
    <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Semaphore</span>(PERMITS);
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">AtomicLong</span>
    <span class="hljs-variable">requestId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">AtomicLong</span>();
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Callable&lt;String&gt; task = () -&gt; {
    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">try</span> {
      Thread.sleep(<span class="hljs-number">200</span>);
      response = <span class="hljs-string">"Request id_"</span> + requestId.incrementAndGet();
    } <span class="hljs-keyword">catch</span> (InterruptedException e) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(e);
    }
    <span class="hljs-keyword">return</span> response;
  };
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> boolean withLock;
  <span class="hljs-keyword">public</span> <span class="hljs-title">WebServerHandler</span><span class="hljs-params">(boolean withLock)</span> {
<span class="hljs-built_in">    this</span>.withLock = withLock;
  }
  ...
</code></pre>
    <p class="normal">When the <code class="inlineCode">WebServerHandler</code> is initiated, we also set up the <code class="inlineCode">withLock</code> value. If this value is <code class="inlineCode">true</code>, then our implementation will rely on a <code class="inlineCode">Semaphore</code> with 20 permits to limit the access of the platform threads (200) or <a id="_idIndexMarker1317"/>of the unbounded number of virtual threads. This <code class="inlineCode">Semaphore</code> simulates an external resource, such as a database that relies on a connection pool of 20 connections.</p>
    <p class="normal">The HTTP requests (we focus only on <code class="inlineCode">GET</code>) are handled in the overridden <code class="inlineCode">handle(HttpExchange exchange)</code> method as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(HttpExchange exchange)</span> 
    <span class="hljs-keyword">throws</span> IOException {
    <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
    <span class="hljs-keyword">if</span> (withLock) {
      <span class="hljs-keyword">try</span> {
        semaphore.acquire();
      } <span class="hljs-keyword">catch</span> (InterruptedException e) { 
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(e); }
      <span class="hljs-keyword">try</span> {
        response = task.call();
      } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(e);
      } <span class="hljs-keyword">finally</span> {
        semaphore.release();
      }
    } <span class="hljs-keyword">else</span> {
       <span class="hljs-keyword">try</span> {
         response = task.call();
       } <span class="hljs-keyword">catch</span> (Exception e) { 
         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">RuntimeException</span>(e); }
        }
        logger.log(Level.INFO, <span class="hljs-string">"{0} | {1}"</span>, 
          <span class="hljs-keyword">new</span> <span class="hljs-title">Object</span>[]{response, Thread.currentThread()
    });
    ...
</code></pre>
    <p class="normal">Once the HTTP <code class="inlineCode">GET</code> request is processed, we have to prepare the response for our client and send it. This job is done via the <code class="inlineCode">HttpExchange</code> object as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">    exchange.sendResponseHeaders(
      <span class="hljs-number">200</span>, response == <span class="hljs-literal">null</span> ? <span class="hljs-number">0</span> : response.length());
    <span class="hljs-keyword">try</span> (OutputStream os = exchange.getResponseBody()) {
      os.write(response == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">new</span> <span class="hljs-title">byte</span>[<span class="hljs-number">0</span>] 
        : response.getBytes());
    }
  }
}
</code></pre>
    <p class="normal">Done! Our HTTP web server is ready to rock and roll.</p>
    <p class="normal">If we start the web server<a id="_idIndexMarker1318"/> via <code class="inlineCode">startWebServer(false, false)</code>, then we will get a web server that has 200 platform threads ready to serve in a non-locking context. If we set the first argument to <code class="inlineCode">true</code>, then we switch to an unbounded number of virtual threads. In the following figure, you can see the heap usage in these two scenarios for 400 requests ramped up in 2 seconds via a JMeter test:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_09.png" alt="Figure 11.9.png"/></figure>
    <p class="packt_figref">Figure 11.9: Memory usage (lock free)</p>
    <p class="normal">As you can see, virtual threads used less heap memory than platform threads being more efficient.</p>
    <p class="normal">If we add locking into the equation (we set the second argument of <code class="inlineCode">startWebServer()</code> to <code class="inlineCode">true</code>), then a possible profile <a id="_idIndexMarker1319"/>of heap memory looks as in the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_11_10.png" alt="Figure 11.10.png"/></figure>
    <p class="packt_figref">Figure 11.10: Memory usage (using locking)</p>
    <p class="normal">As you can see, even with locking, the virtual threads are still using less memory than platform threads. In <em class="italic">Chapter 13</em>, we will dive deeper into creating web servers via the JDK API, including the new features brought by JDK 18.</p>
    <h1 id="_idParaDest-516" class="heading-1">241. Hooking CompletableFuture and virtual threads</h1>
    <p class="normal"><code class="inlineCode">CompletableFuture</code> is one of the main<a id="_idIndexMarker1320"/> asynchronous programming APIs in Java (if you need deep coverage of this topic, then you could consider<a id="_idIndexMarker1321"/> checking out <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 11</em>). </p>
    <p class="normal">In order to use <code class="inlineCode">CompletableFuture</code> with virtual threads, we just have to use the proper executor for virtual threads:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> 
<span class="hljs-operator">  =</span> Executors.newVirtualThreadPerTaskExecutor();
</code></pre>
    <p class="normal">Next, we use this executor to fetch three application testers in asynchronous mode via <code class="inlineCode">CompletableFuture</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;String&gt; <span class="hljs-title">fetchTester1</span><span class="hljs-params">()</span> {
  <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; {
  <span class="hljs-type">String</span> <span class="hljs-variable">tester1</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;
  <span class="hljs-keyword">try</span> {
    logger.info(Thread.currentThread().toString());
    tester1 = fetchTester(<span class="hljs-number">1</span>);
  } <span class="hljs-keyword">catch</span> (IOException | InterruptedException ex) 
    { <span class="hljs-comment">/* handle exceptions */</span> }
  <span class="hljs-keyword">return</span> tester1;
  }<span class="code-highlight"><strong class="hljs-slc">, executor);</strong></span>
}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;String&gt; <span class="hljs-title">fetchTester2</span><span class="hljs-params">()</span> { … }
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CompletableFuture&lt;String&gt; <span class="hljs-title">fetchTester3</span><span class="hljs-params">()</span> { … }
</code></pre>
    <p class="normal">Next, we are interested in <a id="_idIndexMarker1322"/>returning a <code class="inlineCode">TestingTeam</code> only after all three of these <code class="inlineCode">CompletableFuture</code> instances have completed. For this, we rely<a id="_idIndexMarker1323"/> on <code class="inlineCode">allOf()</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> TestingTeam <span class="hljs-title">buildTestingTeam</span><span class="hljs-params">()</span> 
       <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException {
  CompletableFuture&lt;String&gt; cfTester1 = fetchTester1();
  CompletableFuture&lt;String&gt; cfTester2 = fetchTester2();
  CompletableFuture&lt;String&gt; cfTester3 = fetchTester3();
  CompletableFuture&lt;Void&gt; fetchTesters
    = CompletableFuture.allOf(
      cfTester1, cfTester2, cfTester3);
  fetchTesters.get();
  <span class="hljs-type">TestingTeam</span> <span class="hljs-variable">team</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">TestingTeam</span>(cfTester1.resultNow(), 
    cfTester2.resultNow(), cfTester3.resultNow());
  <span class="hljs-keyword">return</span> team;
}
</code></pre>
    <p class="normal">If we run this code, then the output reveals the usage of three virtual threads in asynchronous mode:</p>
    <pre class="programlisting con"><code class="hljs-con">[12:04:32] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
[12:04:32] VirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 
[12:04:32] VirtualThread[#26]/runnable@ForkJoinPool-1-worker-3
</code></pre>
    <p class="normal">Done! Employing virtual<a id="_idIndexMarker1324"/> threads for <code class="inlineCode">CompletableFuture</code> is<a id="_idIndexMarker1325"/> quite easy.</p>
    <h1 id="_idParaDest-517" class="heading-1">242. Signaling virtual threads via wait() and notify()</h1>
    <p class="normal">The <code class="inlineCode">wait()</code>, <code class="inlineCode">notify()</code>, and <code class="inlineCode">notifyAll()</code> are three methods defined in the <code class="inlineCode">Object</code> class that allow multiple threads to communicate <a id="_idIndexMarker1326"/>with each other and coordinate their access to resources without issues.</p>
    <p class="normal">The <code class="inlineCode">wait()</code> method must be called only by the thread that owns the object’s <em class="italic">monitor</em> to force this thread to wait indefinitely <a id="_idIndexMarker1327"/>until another thread calls <code class="inlineCode">notify()</code> or <code class="inlineCode">notifyAll()</code> on the same object. In other words, the <code class="inlineCode">wait()</code> method must be<a id="_idIndexMarker1328"/> called in a <code class="inlineCode">synchronized</code> context (instance, block, or static method).</p>
    <p class="normal">Here is a virtual thread calling the <code class="inlineCode">wait()</code> method:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Object</span>();
<span class="hljs-type">Thread</span> <span class="hljs-variable">wThread</span> <span class="hljs-operator">=</span> Thread.ofVirtual().unstarted(() -&gt; {
  <span class="hljs-keyword">synchronized</span> (object) {
    <span class="hljs-keyword">try</span> {
      logger.info(<span class="hljs-string">"Before calling wait()"</span>);
      logger.info(() -&gt; Thread.currentThread() + <span class="hljs-string">" | "</span> 
        + Thread.currentThread().getState());
      object.wait();
      logger.info(<span class="hljs-string">"After calling notify()"</span>);
      logger.info(() -&gt; Thread.currentThread() + <span class="hljs-string">" | "</span> 
        + Thread.currentThread().getState());
    } <span class="hljs-keyword">catch</span> (InterruptedException e) {}
  }
});
</code></pre>
    <p class="normal">And here is another virtual thread that wakes up the previous one via the <code class="inlineCode">notify()</code> call:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Thread</span> <span class="hljs-variable">nThread</span> <span class="hljs-operator">=</span> Thread.ofVirtual().unstarted(() -&gt; {
  <span class="hljs-keyword">synchronized</span> (object) {
    logger.info(() -&gt; Thread.currentThread() 
      + <span class="hljs-string">" calls notify()"</span>);
    object.notify();
  }
});
</code></pre>
    <p class="normal">At this point, nothing has happened, since <code class="inlineCode">wThread</code> and <code class="inlineCode">nThread</code> are not started. We start <code class="inlineCode">wThread</code> and we give it 1 second to do it:</p>
    <pre class="programlisting code"><code class="hljs-code">wThread.start();
Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// give time to 'wThread' to start</span>
logger.info(<span class="hljs-string">"'wThread' current status"</span>);
logger.info(() -&gt; wThread + <span class="hljs-string">"</span><span class="hljs-string"> | "</span> + wThread.getState());
</code></pre>
    <p class="normal">Next, we start <code class="inlineCode">nThread</code> and <a id="_idIndexMarker1329"/>give it 1 second to do it:</p>
    <pre class="programlisting code"><code class="hljs-code">nThread.start();
Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// give time to 'nThread' to start</span>
</code></pre>
    <p class="normal">Finally, we log the<a id="_idIndexMarker1330"/> state of <code class="inlineCode">wThread</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">logger.info(<span class="hljs-string">"After executing 'wThread'"</span>);
logger.info(() -&gt; wThread + <span class="hljs-string">" | "</span> + wThread.getState());
</code></pre>
    <p class="normal">Running this code reveals <a id="_idIndexMarker1331"/>the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">[14:25:06] Before calling wait() 
[14:25:06] VirtualThread[#22]
           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE 
[14:25:07] 'wThread' current status
[14:25:07] VirtualThread[#22]
           /waiting@ForkJoinPool-1-worker-1 | WAITING 
[14:25:07] VirtualThread[#23]
           /runnable@ForkJoinPool-1-worker-3 calls notify() 
[14:25:07] After calling notify() 
[14:25:07] VirtualThread[#22]
           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE 
[14:25:08] After executing 'wThread'
[14:25:08] VirtualThread[#22]/terminated | TERMINATED
</code></pre>
    <p class="normal">The virtual thread #22 is our <code class="inlineCode">wThread</code>. Initially (before calling <code class="inlineCode">wait()</code>), it is in the <code class="inlineCode">RUNNABLE</code> state, so the thread is in execution on the JVM. After <code class="inlineCode">wait()</code> is called, the state of this thread is set to <code class="inlineCode">WAITING</code>, so thread #22 is waiting indefinitely for another thread to wake it up. This is the moment when the virtual thread #23 (<code class="inlineCode">nThread</code>) calls the <code class="inlineCode">notify()</code> method on the same object. After calling the <code class="inlineCode">notify()</code> method, thread #22 wakes up, and its state is <code class="inlineCode">RUNNABLE</code> again. After finishing its execution, the <code class="inlineCode">wThread</code> state is <code class="inlineCode">TERMINATED</code>.</p>
    <p class="normal">Well, this scenario is the happy path or a <em class="italic">good signal</em>. Let’s check out the following scenario based on the same <code class="inlineCode">wThread</code> and <code class="inlineCode">nThread</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">nThread.start();
Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// give time to 'nThread' to start</span>
wThread.start();
Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// give time to 'wThread' to start</span>
logger.info(<span class="hljs-string">"'wThread' current status"</span>);
logger.info(() -&gt; wThread + <span class="hljs-string">"</span><span class="hljs-string"> | "</span> + wThread.getState()); 
wThread.join(); <span class="hljs-comment">// waits indefinitely - notify() was missed</span>
</code></pre>
    <p class="normal">The output will<a id="_idIndexMarker1332"/> be (#22 is <code class="inlineCode">wThread</code> and #23 is <code class="inlineCode">nThread</code>):</p>
    <pre class="programlisting con"><code class="hljs-con">[14:38:25] VirtualThread[#23]
           /runnable@ForkJoinPool-1-worker-1 calls notify() 
[14:38:26] Before calling wait() 
[14:38:26] VirtualThread[#22]
           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE 
[14:38:27] 'wThread' current status
[14:38:27] VirtualThread[#22]
           /waiting@ForkJoinPool-1-worker-1 | WAITING
</code></pre>
    <p class="normal">This time, <code class="inlineCode">nThread</code> starts first and calls <code class="inlineCode">notify()</code>. This is just a shot in the dark since <code class="inlineCode">wThread</code> is not in the <code class="inlineCode">WAITING</code> state. Later on, <code class="inlineCode">wThread</code> calls <code class="inlineCode">wait()</code> and waits indefinitely to be woken up by <code class="inlineCode">nThread</code>. But this<a id="_idIndexMarker1333"/> will never happen since <code class="inlineCode">notify()</code> was already triggered, so <code class="inlineCode">wThread</code> is blocked forever. In short, this is called a <em class="italic">missed signal</em>.</p>
    <p class="normal">When we develop <a id="_idIndexMarker1334"/>concurrent applications that involve <code class="inlineCode">wait()</code>, <code class="inlineCode">notify()</code>, and <code class="inlineCode">notifyAll()</code>, we have to ensure that the application complexity will not hide such <em class="italic">missed signals</em>. We can avoid <em class="italic">missed signals</em> by simply counting the number of <code class="inlineCode">wait()</code> and <code class="inlineCode">notify()</code> calls and acting accordingly. For instance, let’s move this logic in the object that should be signaled, and let’s call it <code class="inlineCode">SignaledObject</code>. First, we have the <code class="inlineCode">callWait()</code> method, which uses the <code class="inlineCode">counter</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">SignaledObject</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span>
    <span class="hljs-operator">=</span> Logger.getLogger(SignaledObject.class.getName());
  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> counter;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callWait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException {
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
      counter = counter - <span class="hljs-number">1</span>;
      <span class="hljs-keyword">if</span> (counter &gt;= <span class="hljs-number">0</span>) {
        logger.info(() -&gt; Thread.currentThread() 
          + <span class="hljs-string">" | Missed signals: "</span> + counter
          + <span class="hljs-string">" | 'wait() will not be called'"</span>);
        <span class="hljs-keyword">return</span>;
      }
      logger.info(<span class="hljs-string">"Before calling wait()"</span>);
      logger.info(() -&gt; Thread.currentThread() + <span class="hljs-string">"</span><span class="hljs-string"> | "</span> 
        + Thread.currentThread().getState());
      wait();
      logger.info(<span class="hljs-string">"After calling notify()"</span>);
      logger.info(() -&gt; Thread.currentThread() + <span class="hljs-string">" | "</span> 
        + Thread.currentThread().getState());
    }
  }
  ...
</code></pre>
    <p class="normal">If no signal was missed, then the <code class="inlineCode">counter</code> variable <a id="_idIndexMarker1335"/>should be 0. Otherwise, we have at least one <em class="italic">missed signal</em> (<code class="inlineCode">notify()</code> call) so there<a id="_idIndexMarker1336"/> is no reason to wait. We return immediately, without calling <code class="inlineCode">wait()</code>, since this may<a id="_idIndexMarker1337"/> lead to a deadly trap.</p>
    <p class="normal">On the other hand, <code class="inlineCode">callNotify()</code> increases the <code class="inlineCode">counter</code> at each call as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">callNotify</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) {
      counter = counter + <span class="hljs-number">1</span>;
      logger.info(() -&gt; <span class="hljs-string">"Signal counter: "</span> + counter);
      notify();
    }
  }
}
</code></pre>
    <p class="normal">If we run the happy path (<em class="italic">good signal</em>) scenario, then the output will be as follows:</p>
    <pre class="programlisting con"><code class="hljs-con">[14:50:32] Before calling wait() 
[14:50:32] VirtualThread[#22]
           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE 
[14:50:33] 'wThread' current status
[14:50:33] VirtualThread[#22]
           /waiting@ForkJoinPool-1-worker-1 | WAITING 
<span class="code-highlight"><strong class="hljs-con-slc">[14:50:33] Signal counter: 0 </strong></span>
[14:50:33] After calling notify() 
[14:50:33] VirtualThread[#22]
           /runnable@ForkJoinPool-1-worker-1 | RUNNABLE 
[14:50:34] After executing 'wThread'
[14:50:34] VirtualThread[#22]/terminated | TERMINATED
</code></pre>
    <p class="normal">Everything works as expected <a id="_idIndexMarker1338"/>since <code class="inlineCode">counter</code> is 0. If we try out the missed signal scenario, then we have the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">[14:52:24] Signal counter: 1 
[14:52:25] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 
           | Missed signals: 0 | 'wait() will not be called' 
[14:52:26] 'wThread' current status
[14:52:26] VirtualThread[#22]/terminated | TERMINATED
</code></pre>
    <p class="normal">As you can see, we <a id="_idIndexMarker1339"/>avoided the indefinite blocking by not<a id="_idIndexMarker1340"/> calling <code class="inlineCode">wait()</code>. We managed to elegantly handle the <em class="italic">missed signal</em>. Cool, right!?</p>
    <h1 id="_idParaDest-518" class="heading-1">Summary</h1>
    <p class="normal">This chapter covered 18 advanced problems about virtual threads and structured concurrency. You can see this chapter as a masterclass designed to help you speed up your learning and get ready for production with strong confidence in your knowledge. With that covered, you have now finished the chapter and the book.</p>
    <h1 class="heading-1">Join our community on Discord</h1>
    <p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
    <p class="normal"><a href="https://discord.gg/8mgytp5DGQ "><span class="url">https://discord.gg/8mgytp5DGQ</span></a></p>
    <p class="normal"><img src="../Images/QR_Code1139613064111216156.png" alt="" role="presentation"/></p>
  </div>
</body></html>