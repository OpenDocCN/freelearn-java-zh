["```java\ntrait Monoid[T] {\n  def op(l: T, r: T): T\n  def zero: T\n}\n```", "```java\npackage object monoids {\n  val intAddition: Monoid[Int] = new Monoid[Int] {\n    val zero: Int = 0\n\n    override def op(l: Int, r: Int): Int = l + r\n  }\n\n  val intMultiplication: Monoid[Int] = new Monoid[Int] {\n    val zero: Int = 1\n\n    override def op(l: Int, r: Int): Int = l * r\n  }\n\n  val stringConcatenation: Monoid[String] = new Monoid[String] {\n    val zero: String = \"\"\n\n    override def op(l: String, r: String): String = l + r\n  }\n}\n```", "```java\ndef foldLeft[B](z: B)(f: (B, A) => B): B\n\ndef foldRight[B](z: B)(f: (A, B) => B): B\n```", "```java\ndef foldLeft[A](z: A)(f: (A, A) => A): A\n\ndef foldRight[A](z: A)(f: (A, A) => A): A\n```", "```java\nobject MonoidFolding {\n  def main(args: Array[String]): Unit = {\n    val strings = List(\"This is\\n\", \"a list of\\n\", \"strings!\")\n    val numbers = List(1, 2, 3, 4, 5, 6)\n    System.out.println(s\"Left folded:\\n${strings.foldLeft(stringConcatenation.zero)(stringConcatenation.op)}\")\n    System.out.println(s\"Right folded:\\n${strings.foldRight(stringConcatenation.zero)(stringConcatenation.op)}\")\n    System.out.println(s\"6! is: ${numbers.foldLeft(intMultiplication.zero)(intMultiplication.op)}\")\n  }\n}\n```", "```java\nobject MonoidOperations {\n  def fold[T](list: List[T], m: Monoid[T]): T = list.foldLeft(m.zero)(m.op)\n}\n```", "```java\nobject MonoidFoldingGeneric {\n  def main(args: Array[String]): Unit = {\n    val strings = List(\"This is\\n\", \"a list of\\n\", \"strings!\")\n    val numbers = List(1, 2, 3, 4, 5, 6)\n    System.out.println(s\"Left folded:\\n${MonoidOperations.fold(strings,\n     stringConcatenation)}\")\n    System.out.println(s\"Right folded:\\n${MonoidOperations.fold(strings,\n     stringConcatenation)}\")\n    System.out.println(s\"6! is: ${MonoidOperations.fold(numbers,\n     intMultiplication)}\")\n  }\n}\n```", "```java\nobject MonoidOperations {\n  def fold[T](list: List[T], m: Monoid[T]): T = foldMap(list, m)(identity)\n\n  def foldMap[T, Y](list: List[T], m: Monoid[Y])(f: T => Y): Y =\n    list.foldLeft(m.zero) {\n      case (t, y) => m.op(t, f(y))\n    }\n}\n```", "```java\nop(op(op(1, 2), 3), 4)\n```", "```java\nop(op(1, 2), op(3, 4))\n```", "```java\ndef balancedFold[T, Y](list: IndexedSeq[T], m: Monoid[Y])(f: T => Y): Y =\n  if (list.length == 0) {\n    m.zero\n  } else if (list.length == 1) {\n    f(list(0))\n  } else {\n    val (left, right) = list.splitAt(list.length / 2)\n    m.op(balancedFold(left, m)(f), balancedFold(right, m)(f))\n  }\n```", "```java\nobject MonoidBalancedFold {\n  def main(args: Array[String]): Unit = {\n    val numbers = Array(1, 2, 3, 4)\n    System.out.println(s\"4! is: ${MonoidOperations.balancedFold(numbers, intMultiplication)(identity)}\")\n  }\n}\n```", "```java\ndef foldPar[T](list: List[T], m: Monoid[T]): T =\n  foldMapPar(list, m)(identity)\n\ndef foldMapPar[T, Y](list: List[T], m: Monoid[Y])(f: T => Y): Y =\n  list.par.foldLeft(m.zero) {\n    case (t, y) => m.op(t, f(y))\n  }\n```", "```java\nobject MonoidFoldingGenericPar {\n  def main(args: Array[String]): Unit = {\n    val strings = List(\"This is\\n\", \"a list of\\n\", \"strings!\")\n    val numbers = List(1, 2, 3, 4, 5, 6)\n    System.out.println(s\"Left folded:\\n${MonoidOperations.foldPar(strings,\n     stringConcatenation)}\")\n    System.out.println(s\"Right folded:\\n${MonoidOperations.foldPar(strings,\n     stringConcatenation)}\")\n    System.out.println(s\"6! is: ${MonoidOperations.foldPar(numbers,\n     intMultiplication)}\")\n  }\n}\n```", "```java\ndef compose[T, Y](a: Monoid[T], b: Monoid[Y]): Monoid[(T, Y)] =\n  new Monoid[(T, Y)] {\n    val zero: (T, Y) = (a.zero, b.zero)\n\n    override def op(l: (T, Y), r: (T, Y)): (T, Y) =\n      (a.op(l._1, r._1), b.op(l._2, r._2))\n  }\n```", "```java\nobject ComposedMonoid {\n  def main(args: Array[String]): Unit = {\n    val numbers = Array(1, 2, 3, 4, 5, 6)\n    val sumAndProduct = compose(intAddition, intMultiplication)\n    System.out.println(s\"The sum and product is: ${MonoidOperations.balancedFold(numbers, sumAndProduct)(i => (i, i))}\")\n  }\n}\n```", "```java\ndef mapMerge[K, V](a: Monoid[V]): Monoid[Map[K, V]] =\n  new Monoid[Map[K, V]] {\n    override def zero: Map[K, V] = Map()\n\n    override def op(l: Map[K, V], r: Map[K, V]): Map[K, V] =\n      (l.keySet ++ r.keySet).foldLeft(zero) {\n        case (res, key) => res.updated(key, a.op(l.getOrElse(key,\n         a.zero), r.getOrElse(key, a.zero)))\n      }\n  }\n```", "```java\nobject FeatureCounting {\n  def main(args: Array[String]): Unit = {\n    val features = Array(\"hello\", \"features\", \"for\", \"ml\", \"hello\",\n     \"for\", \"features\")\n    val counterMonoid: Monoid[Map[String, Int]] = mapMerge(intAddition)\n    System.out.println(s\"The features are: ${MonoidOperations.balancedFold(features, counterMonoid)(i => Map(i -> 1))}\")\n  }\n}\n```", "```java\nobject FeatureCountingOneOff {\n  def main(args: Array[String]): Unit = {\n    val features = Array(\"hello\", \"features\", \"for\", \"ml\", \"hello\",\n     \"for\", \"features\")\n    System.out.println(s\"The features are: ${\n      features.foldLeft(Map[String, Int]()) {\n        case (res, feature) => res.updated(feature,\n         res.getOrElse(feature, 0) + 1)\n      }\n    }\")\n  }\n}\n```", "```java\ntrait Functor[F[_]] {\n  def map[T, Y](l: F[T])(f: T => Y): F[Y]\n}\n```", "```java\npackage object functors {\n  val listFunctor = new Functor[List] {\n    override def map[T, Y](l: List[T])(f: (T) => Y): List[Y] = l.map(f)\n  }\n}\n```", "```java\nobject FunctorsExample {\n  def main(args: Array[String]): Unit = {\n    val numbers = List(1, 2, 3, 4, 5, 6)\n    val mapping = Map(\n      1 -> \"one\",\n      2 -> \"two\",\n      3 -> \"three\",\n      4 -> \"four\",\n      5 -> \"five\",\n      6 -> \"six\"\n    )\n    System.out.println(s\"The numbers doubled are:\n     ${listFunctor.map(numbers)(_ * 2)}\")\n    System.out.println(s\"The numbers with strings are:\n     ${listFunctor.map(numbers)(i => (i, mapping(i)))}\")\n  }\n}\n```", "```java\ndef flatMap[T](f: Y => Monad[T]) : Monad[T] = flatten(map(f))\n```", "```java\ndef flatten[T](x: F[F[T]]): M[T]\n```", "```java\ndef unit[T](value: T): Monad[T]\n```", "```java\nList(x)\nArray(x)\nSeq(x)\n```", "```java\ndef map[T](f: Y => T): Monad[T] = flatMap { x => unit(f(x)) }\n```", "```java\ncase class ListWrapper(list: List[Int]) {\n  // just wrap\n  def map[B](f: Int => B): List[B] = list.map(f)\n\n  // just wrap\n  def flatMap[B](f: Int => GenTraversableOnce[B]): List[B] =\n    list.flatMap(f)\n}\n```", "```java\nobject ForComprehensionWithLists {\n  def main(args: Array[String]): Unit = {\n    val l1 = List(1, 2, 3, 4)\n    val l2 = List(5, 6, 7, 8)\n    val result = for {\n      x <- l1\n      y <- l2\n    } yield x * y\n    // same as\n    // val result = l1.flatMap(i => l2.map(_ * i))\n    System.out.println(s\"The result is: ${result}\")\n  }\n}\n```", "```java\nobject ForComprehensionWithObjects {\n  def main(args: Array[String]): Unit = {\n    val wrapper1 = ListWrapper(List(1, 2, 3, 4))\n    val wrapper2 = ListWrapper(List(5, 6, 7, 8))\n    val result = for {\n      x <- wrapper1\n      y <- wrapper2\n    } yield x * y\n    System.out.println(s\"The result is: ${result}\")\n  }\n}\n```", "```java\ntrait Functor[T] {\n  def map[Y](f: T => Y): Functor[Y]\n}\n```", "```java\ntrait Monad[T] extends Functor[T] {\n  def unit[Y](value: Y): Monad[Y]\n\n  def flatMap[Y](f: T => Monad[Y]): Monad[Y]\n\n  override def map[Y](f: T => Y): Monad[Y] =\n    flatMap(i => unit(f(i)))\n}\n```", "```java\ncase class Doer() {\n  def getAlgorithm(isFail: Boolean) =\n    if (isFail) {\n      null\n    } else {\n      Algorithm()\n    }\n}\n\ncase class Algorithm() {\n  def getImplementation(isFail: Boolean, left: Int, right: Int): Implementation =\n    if (isFail) {\n      null\n    } else {\n      Implementation(left, right)\n    }\n}\n\ncase class Implementation(left: Int, right: Int) {\n  def compute: Int = left + right\n}\n```", "```java\nobject NoMonadExample {\n  def main(args: Array[String]): Unit = {\n    System.out.println(s\"The result is: ${compute(Doer(), 10, 16)}\")\n  }\n\n  def compute(doer: Doer, left: Int, right: Int): Int =\n    if (doer != null) {\n      val algorithm = doer.getAlgorithm(false)\n      if (algorithm != null) {\n        val implementation = algorithm.getImplementation(false,\n          left, right)\n        if (implementation != null) {\n          implementation.compute\n        } else {\n          -1\n        }\n      } else {\n        -1\n      }\n    } else {\n      -1\n    }\n}\n```", "```java\nsealed trait Option[A] extends Monad[A]\n\ncase class Some[A](a: A) extends Option[A] {\n  override def unit[Y](value: Y): Monad[Y] = Some(value)\n\n  override def flatMap[Y](f: (A) => Monad[Y]): Monad[Y] = f(a)\n}\n\ncase class None[A]() extends Option[A] {\n  override def unit[Y](value: Y): Monad[Y] = None()\n\n  override def flatMap[Y](f: (A) => Monad[Y]): Monad[Y] = None()\n}\n```", "```java\ncase class Doer_v2() {\n  def getAlgorithm(isFail: Boolean): Option[Algorithm_v2] =\n    if (isFail) {\n      None()\n    } else {\n      Some(Algorithm_v2())\n    }\n}\n\ncase class Algorithm_v2() {\n  def getImplementation(isFail: Boolean, left: Int, right: Int): Option[Implementation] =\n    if (isFail) {\n      None()\n    } else {\n      Some(Implementation(left, right))\n    }\n}\n```", "```java\nobject MonadExample {\n  def main(args: Array[String]): Unit = {\n    System.out.println(s\"The result is: ${compute(Some(Doer_v2()), 10, 16)}\")\n  }\n\n  def compute(doer: Option[Doer_v2], left: Int, right: Int) =\n    for {\n      d <- doer\n      a <- d.getAlgorithm(false)\n      i <- a.getImplementation(false, left, right)\n    } yield i.compute\n\n  // OR THIS WAY:\n  //  doer.flatMap {\n  //    d =>\n  //      d.getAlgorithm(false).flatMap {\n  //        a =>\n  //          a.getImplementation(false, left, right).map {\n  //            i => i.compute\n  //          }\n  //      }\n  //  }\n}\n```", "```java\nsealed trait State {\n  def next: State\n}\n```", "```java\nabstract class FileIO {\n\n  // this makes sure nobody can create a state\n  private class FileIOState(id: Int) extends State {\n    override def next: State = new FileIOState(id + 1)\n  }\n\n  def run(args: Array[String]): Unit = {\n    val action = runIO(args(0), args(1))\n    action(new FileIOState(0))\n  }\n\n  def runIO(readPath: String, writePath: String): IOAction[_]\n}\n```", "```java\nsealed abstract class IOAction[T] extends ((State) => (State, T)) {\n  // START: we don't have to extend. We could also do this...\n  def unit[Y](value: Y): IOAction[Y] = IOAction(value)\n\n  def flatMap[Y](f: (T) => IOAction[Y]): IOAction[Y] = {\n    val self = this\n    new IOAction[Y] {\n      override def apply(state: State): (State, Y) = {\n        val (state2, res) = self(state)\n        val action2 = f(res)\n        action2(state2)\n      }\n\n    }\n  }\n\n  def map[Y](f: T => Y): IOAction[Y] =\n    flatMap(i => unit(f(i)))\n\n  // END: we don't have to extend. We could also do this...\n}\n```", "```java\nobject IOAction {\n  def apply[T](result: => T): IOAction[T] =\n    new SimpleAction[T](result)\n\n  private class SimpleAction[T](result: => T) extends IOAction[T] {\n    override def apply(state: State): (State, T) =\n      (state.next, result)\n  }\n\n}\n```", "```java\n// START: we don't have to extend. We could also do this...\ndef unit[Y](value: Y): IOAction[Y] = IOAction(value)\n\ndef flatMap[Y](f: (T) => IOAction[Y]): IOAction[Y] = {\n  val self = this\n  new IOAction[Y] {\n    override def apply(state: State): (State, Y) = {\n      val (state2, res) = self(state)\n      val action2 = f(res)\n      action2(state2)\n    }\n\n  }\n}\n\ndef map[Y](f: T => Y): IOAction[Y] =\n  flatMap(i => unit(f(i)))\n\n// END: we don't have to extend. We could also do this...\n```", "```java\nprivate class EmptyAction[T](value: T) extends IOAction[T] {\n  override def apply(state: State): (State, T) =\n    (state, value)\n}\n```", "```java\ndef unit[T](value: T): IOAction[T] = new EmptyAction[T](value)\n```", "```java\ndef unit[Y](value: Y): IOAction[Y] = IOAction.unit(value)\n```", "```java\npackage object io {\n  def readFile(path: String) =\n    IOAction(Source.fromFile(path).getLines())\n\n  def writeFile(path: String, lines: Iterator[String]) =\n    IOAction({\n      val file = new File(path)\n      printToFile(file) { p => lines.foreach(p.println) }\n    })\n\n  private def printToFile(file: File)(writeOp: PrintWriter => Unit): Unit = {\n    val writer = new PrintWriter(file)\n    try {\n      writeOp(writer)\n    } finally {\n      writer.close()\n    }\n  }\n}\n```", "```java\nabstract class FileIO {\n\n  // this makes sure nobody can create a state\n  private class FileIOState(id: Int) extends State {\n    override def next: State = new FileIOState(id + 1)\n  }\n\n  def run(args: Array[String]): Unit = {\n    val action = runIO(args(0), args(1))\n    action(new FileIOState(0))\n  }\n\n  def runIO(readPath: String, writePath: String): IOAction[_]\n}\n```", "```java\nobject FileIOExample extends FileIO {\n  def main(args: Array[String]): Unit = {\n    run(args)\n  }\n\n  override def runIO(readPath: String, writePath: String): IOAction[_] =\n    for {\n      lines <- readFile(readPath)\n      _ <- writeFile(writePath, lines.map(_.toUpperCase))\n    } yield ()\n}\n```", "```java\nthis is a file, which\nwill be completely capitalized\nin a monadic way.\n\nEnjoy!\n```"]