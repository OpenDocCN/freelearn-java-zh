- en: Object Relational Mapping with the Java Persistence API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Java持久化API进行对象关系映射
- en: Any non-trivial Java EE application will persist data to a relational database.
    In this chapter, we will cover how to connect to a database and perform CRUD (Create,
    Read, Update, Delete) operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非平凡的Java EE应用程序都会将数据持久化到关系数据库中。在本章中，我们将介绍如何连接到数据库并执行CRUD（创建、读取、更新、删除）操作。
- en: The **Java Persistence API** (**JPA**) is the standard Java EE **Object Relational
    Mapping** (**ORM**) tool. We will discuss this API in detail in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java持久化API**（**JPA**）是标准的Java EE **对象关系映射**（**ORM**）工具。我们将在本章中详细讨论这个API。'
- en: 'Some of the topics covered in this chapter include:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的一些主题包括：
- en: Retrieving data from a database through JPA
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JPA从数据库中检索数据
- en: Inserting data into a database through JPA
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JPA在数据库中插入数据
- en: Updating data in a database through JPA
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JPA在数据库中更新数据
- en: Deleting data in a database through JPA
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JPA在数据库中删除数据
- en: Building queries programmatically through the JPA Criteria API
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JPA Criteria API编程构建查询
- en: Automating data validation through JPA 2.0's Bean Validation support
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过JPA 2.0的Bean Validation支持自动化数据验证
- en: The Customer database
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户数据库
- en: Examples in this chapter will use a database called `CUSTOMERDB`. This database
    contains tables to track customer and order information for a fictitious store.
    The database uses JavaDB for its RDBMS, since it comes bundled with GlassFish,
    but it can be easily adapted to any other RDBMS.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例将使用名为`CUSTOMERDB`的数据库。该数据库包含跟踪虚构商店客户和订单信息的表。该数据库使用JavaDB作为其RDBMS，因为它与GlassFish捆绑在一起，但它可以轻松地适应任何其他RDBMS。
- en: A script is included with this book's code download to create this database
    and pre-populate some of its tables. Instructions on how to execute the script,
    and add a connection pool and data source to access it are included in the download
    as well.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书代码下载中包含一个脚本，用于创建此数据库并预先填充其中的一些表。如何执行脚本以及如何添加连接池和数据源以访问它的说明也包含在下载中。
- en: 'The schema for the `CUSTOMERDB` database is depicted in the following diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUSTOMERDB`数据库的模式在以下图中表示：'
- en: '![](img/44c73028-7fc2-4764-9968-89f35310ae54.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44c73028-7fc2-4764-9968-89f35310ae54.png)'
- en: As can be seen in the diagram, the database contains tables to store customer
    information such as name, address, and email address. It also contains tables
    to store order and item information.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如图中所示，数据库包含存储客户信息（如姓名、地址和电子邮件地址）的表。它还包含存储订单和项目信息的表。
- en: The `ADDRESS_TYPES` table will store values such as "Home", "Mailing", and "Shipping",
    to distinguish the type of address in the `ADDRESSES` table; similarly, the `TELEPHONE_TYPES`
    table stores the "Cell", "Home", and "Work" values. These two tables are prepopulated
    when creating the database, as well as the `US_STATES` table.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`ADDRESS_TYPES`表将存储“家庭”、“邮寄”和“运输”等值，以区分`ADDRESSES`表中的地址类型；同样，`TELEPHONE_TYPES`表存储“手机”、“家庭”和“工作”等值。这两个表在创建数据库时预先填充，以及`US_STATES`表。'
- en: For simplicity, our database only deals with U.S. addresses.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们的数据库只处理美国地址。
- en: The Java Persistence API
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java持久化API
- en: 'The **Java Persistence API (JPA)** was introduced to Java EE in version 5 of
    the specification. Like its name implies, it is used to persist data to a relational
    database management system. JPA is a replacement for the Entity Beans that were
    used in J2EE. Java EE Entities are regular Java classes; the Java EE container
    knows these classes are Entities because they are decorated with the `@Entity`
    annotation. Let''s look at an Entity mapping to the `CUSTOMER` table in the `CUSTOMERDB`
    database:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Java持久化API (JPA**)是在Java EE规范的第5版中引入的。正如其名称所暗示的，它用于将数据持久化到关系数据库管理系统。JPA是J2EE中使用的实体Bean的替代品。Java
    EE实体是常规的Java类；Java EE容器知道这些类是实体，因为它们被`@Entity`注解装饰。让我们看看`CUSTOMERDB`数据库中`CUSTOMER`表的实体映射：'
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code, the `@Entity` annotation lets any other Java EE-compliant
    application server know that this class is a JPA entity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`@Entity`注解让任何其他Java EE兼容的应用程序服务器知道这个类是一个JPA实体。
- en: The `@Table(name = "CUSTOMERS")` annotation lets the application server know
    what table to map the entity to. The value of the `name` element contains the
    name of the database table that the entity maps to. This annotation is optional;
    if the name of the class maps the name of the database table, then it isn't necessary
    to specify what table the entity maps to.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Table(name = "CUSTOMERS")`注解让应用服务器知道将实体映射到哪个表。`name`元素的值包含实体映射到的数据库表的名称。此注解是可选的；如果类的名称映射到数据库表的名称，则不需要指定实体映射到的表。'
- en: The `@Id` annotation indicates that the `customerId` field maps to the primary
    key.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Id`注解表示`customerId`字段映射到主键。'
- en: The `@Column` annotation maps each field to a column in the table. If the name
    of the field matches the name of the database column, then this annotation is
    not needed. This is the reason why the `email` field is not annotated.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Column`注解将每个字段映射到表中的一列。如果字段的名称与数据库列的名称匹配，则不需要此注解。这就是为什么`email`字段没有被注解的原因。'
- en: 'The `EntityManager` class (this is actually an interface; each Java EE compliant
    application server provides its own implementation) is used to persist entities
    to a database. The following example illustrates its usage:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager`类（这实际上是一个接口；每个Java EE兼容的应用服务器都提供自己的实现）用于将实体持久化到数据库。以下示例说明了其用法：'
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding CDI named bean obtains an instance of a class implementing the
    `javax.persistence.EntityManager` interface via dependency injection. This is
    done by decorating the `EntityManager` variable with the `@PersistenceContext`
    annotation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个CDI命名的bean通过依赖注入获取实现`javax.persistence.EntityManager`接口的类的实例。这是通过使用`@PersistenceContext`注解装饰`EntityManager`变量来实现的。
- en: An instance of a class implementing the `javax.transaction.UserTransaction`
    interface is then injected via the `@Resource` annotation. This object is necessary,
    since, without it invoking calls to persist Entities to the database, the code
    would throw a `javax.persistence.TransactionRequiredException` .
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过`@Resource`注解注入实现`javax.transaction.UserTransaction`接口的类的实例。这个对象是必要的，因为没有它，在数据库中持久化实体时，代码将抛出`javax.persistence.TransactionRequiredException`异常。
- en: '`EntityManager` performs many database-related tasks, such as finding entities
    in the database, updating them, or deleting them.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`EntityManager`执行许多数据库相关任务，例如在数据库中查找实体、更新它们或删除它们。'
- en: Since JPA Entities are **plain old Java objects** ( **POJOs** ), they can be
    instantiated via the `new` operator.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于JPA实体是**普通的Java对象**（**POJOs**），它们可以通过`new`运算符进行实例化。
- en: The call to the `setCustomerId()` method takes advantage of autoboxing, a feature
    added to the Java language in JDK 1.5\. Notice that the method takes an instance
    of `java.lang.Long` as its parameter, but we are using `long` primitives. The
    code compiles and executes properly thanks to this feature.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`setCustomerId()`方法利用了自动装箱，这是Java语言在JDK 1.5中添加的一个特性。请注意，该方法接受一个`java.lang.Long`实例作为其参数，但我们使用的是`long`原始类型。多亏了这个特性，代码能够正确编译和执行。
- en: Calls to the `persist()` method on `EntityManager` must be in a transaction,
    therefore it is necessary to start one by calling the `begin()` method on `UserTransaction`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EntityManager`上对`persist()`方法的调用必须在事务中进行，因此需要通过调用`UserTransaction`上的`begin()`方法来启动一个事务。
- en: We then insert two new rows to the `CUSTOMERS` table by calling the `persist()`
    method on `entityManager` for the two instances of the `Customer` class we populated
    earlier in the code.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过在`entityManager`上对两个先前在代码中填充的`Customer`类的实例调用`persist()`方法，向`CUSTOMERS`表插入两行新数据。
- en: After persisting the data contained in the `customer` and `customer2` objects,
    we search the database for a row in the `CUSTOMERS` table with a primary key of
    four. We do this by invoking the `find()` method on `entityManager`. This method
    takes the class of the Entity we are searching for as its first parameter, and
    the primary key of the row corresponding to the object we want to obtain. This
    method is roughly equivalent to the `findByPrimaryKey()` method on an entity bean's
    home interface.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`customer`和`customer2`对象中的数据持久化后，我们通过在`entityManager`上调用`find()`方法在数据库中搜索具有四个主键的`CUSTOMERS`表中的行。这是通过调用我们想要获取的对象对应行的实体类作为其第一个参数来完成的。此方法大致等同于实体bean的home接口上的`findByPrimaryKey()`方法。
- en: The primary key we set for the `customer2` object was 4, therefore what we have
    now is a copy of this object. The last name for this customer was misspelled when
    we originally inserted his data into the database. We can now correct Mr. Johnson's
    last name by invoking the `setLastName()` method on `customer3`, then we can update
    the information in the database by invoking `entityManager.persist()`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为`customer2`对象设置的键是4，因此我们现在有一个该对象的副本。当我们将这位客户的数据最初插入数据库时，他的姓氏被拼错了。现在我们可以通过在`customer3`上调用`setLastName()`方法来纠正约翰逊先生的姓氏，然后我们可以通过调用`entityManager.persist()`来更新数据库中的信息。
- en: We then delete the information for the `customer` object by invoking `entityManager.remove()`
    and passing the `customer` object as a parameter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过调用`entityManager.remove()`并传递`customer`对象作为参数来删除`customer`对象的信息。
- en: Finally, we commit the changes to the database by invoking the `commit()` method
    on `userTransaction`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们通过在`userTransaction`上调用`commit()`方法将更改提交到数据库。
- en: 'In order for the preceding code to work as expected, an XML configuration file
    named `persistence.xml` must be deployed in the WAR file containing the previously-named
    bean. This file must be placed in the `WEB-INF/classes/META-INF/` directory inside
    the WAR file. The contents of this file for the preceding code are shown here:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使前面的代码按预期工作，必须在包含先前命名的bean的WAR文件中部署一个名为`persistence.xml`的XML配置文件。此文件必须放置在WAR文件内的`WEB-INF/classes/META-INF/`目录中。此文件的前面代码内容如下：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`persistence.xml` must contain at least one `<persistence-unit>` element. Each
    `<persistence-unit>` element must provide a value for its `name` attribute and
    must contain a `<jta-data-source>` child element whose value is the JNDI name
    of the data source to be used for the persistence unit.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`persistence.xml`必须至少包含一个`<persistence-unit>`元素。每个`<persistence-unit>`元素必须为其`name`属性提供一个值，并且必须包含一个`<jta-data-source>`子元素，其值是要用于持久化单元的数据源的JNDI名称。'
- en: The reason more than one `<persistence-unit>` element is allowed is because
    an application may access more than one database. A `<persistence-unit>` element
    is required for each database the application will access. If the application
    defines more than one `<persistence-unit>` element, then the `@PersistenceContext`
    annotation used to inject `EntityManager` must provide a value for its `unitName`
    element; the value for this element must match the name attribute of the corresponding
    `<persistence-unit>` element in `persistence.xml`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 允许多于一个`<persistence-unit>`元素的原因是，一个应用程序可能需要访问多个数据库。对于应用程序将要访问的每个数据库，都需要一个`<persistence-unit>`元素。如果应用程序定义了多个`<persistence-unit>`元素，那么用于注入`EntityManager`的`@PersistenceContext`注解必须为其`unitName`元素提供一个值；此元素的值必须与`persistence.xml`中相应`<persistence-unit>`元素的`name`属性匹配。
- en: 'Cannot persist detached object Exception: Frequently, an application will retrieve
    a JPA entity via the `EntityManager.find()` method, then pass this entity to a
    business or user interface layer, where it will potentially be modified, and later
    the database data corresponding to the entity will be updated. In cases such as
    this, invoking `EntityManager.persist()` will result in an exception. In order
    to update JPA entities this way, we need to invoke `EntityManager.merge()`. This
    method takes an instance of the JPA entity as its single argument and updates
    the corresponding row in the database with the data stored in it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 无法持久化分离对象异常：通常，一个应用程序会通过`EntityManager.find()`方法检索一个JPA实体，然后将该实体传递给业务或用户界面层，在那里它可能会被修改，然后相应实体的数据库数据将被更新。在这种情况下，调用`EntityManager.persist()`将导致异常。为了以这种方式更新JPA实体，我们需要调用`EntityManager.merge()`。此方法接受一个JPA实体实例作为其单个参数，并使用其中存储的数据更新数据库中的对应行。
- en: Entity relationships
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体关系
- en: In the previous section, we saw how to retrieve, insert, update, and delete
    single entities from the database. Entities are rarely isolated; in the vast majority
    of cases they are related to other entities.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何从数据库中检索、插入、更新和删除单个实体。实体很少是孤立的；在绝大多数情况下，它们与其他实体相关联。
- en: Entities can have one-to-one, one-to-many, many-to-one, and many-to-many relationships.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 实体可以有一对一、一对多、多对一和多对多的关系。
- en: In the `CustomerDB` database, for example, there is a one-to-one relationship
    between the `LOGIN_INFO` and the `CUSTOMERS` tables. This means that each customer
    has exactly one corresponding row in the login info table. There is also a one-to-many
    relationship between the `CUSTOMERS` table and the `ORDERS` table. This is because
    a customer can place many orders, but each order belongs only to a single customer.
    Additionally, there is a many-to-many relationships between the `ORDERS` table
    and the `ITEMS` table. This is because an order can contain many items and an
    item can be on many orders.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在`CustomerDB`数据库中，`LOGIN_INFO`表和`CUSTOMERS`表之间存在一对一的关系。这意味着每个客户在登录信息表中恰好对应一行。`CUSTOMERS`表和`ORDERS`表之间存在一对多关系。这是因为一个客户可以下多个订单，但每个订单只属于一个客户。此外，`ORDERS`表和`ITEMS`表之间存在多对多关系。这是因为一个订单可以包含多个项目，而一个项目可以出现在多个订单中。
- en: In the next few sections, we will discuss how to establish relationships between
    JPA entities.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将讨论如何建立JPA实体之间的关系。
- en: One-to-one relationships
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一对一关系
- en: One-to-one relationships occur when an instance of an entity can have zero or
    one corresponding instance of another entity.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个实体的实例可以对应零个或一个另一个实体的实例时，就会发生一对一关系。
- en: One-to-one entity relationships can be bidirectional (each entity is aware of
    the relationship) or unidirectional (only one of the entities is aware of the
    relationship). In the `CUSTOMERDB` database, the one-to-one mapping between the
    `LOGIN_INFO` and the `CUSTOMERS` tables is unidirectional, since the `LOGIN_INFO`
    table has a foreign key to the `CUSTOMERS` table, but not the other way around.
    As we will soon see, this fact does not stop us from creating a bidirectional
    one-to-one relationship between the `Customer` entity and the `LoginInfo` entity.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一对一实体关系可以是双向的（每个实体都了解这种关系）或单向的（只有其中一个实体了解这种关系）。在`CUSTOMERDB`数据库中，`LOGIN_INFO`表和`CUSTOMERS`表之间的一对一映射是单向的，因为`LOGIN_INFO`表有一个指向`CUSTOMERS`表的外键，但反之则不然。正如我们很快就会看到的，这个事实并不会阻止我们在这两个实体之间创建一个双向的一对一关系。
- en: 'The source code for the `LoginInfo` entity, which maps to the `LOGIN_INFO`
    table, can be seen here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里可以看到映射到`LOGIN_INFO`表的`LoginInfo`实体的源代码：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code for this entity is very similar to the code for the `Customer` entity.
    It defines fields that map to database columns. Each field whose name does not
    match the database column name is decorated with the `@Column` annotation; in
    addition to that, the primary key is decorated with the `@Id` annotation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实体的代码与`Customer`实体的代码非常相似。它定义了映射到数据库列的字段。每个名称与数据库列名称不匹配的字段都装饰了`@Column`注解；除此之外，主键还装饰了`@Id`注解。
- en: Where the preceding code gets interesting is the declaration of the `customer`
    field. As can be seen in the code, the `customer` field is decorated with the
    `@OneToOne` annotation; this lets the application server know that there is a
    one-to-one relationship between this entity and the `Customer` entity. The customer
    field is also decorated with the `@JoinColumn` annotation. This annotation lets
    the container know which column in the `LOGIN_INFO` table is the foreign key corresponding
    to the primary key on the `CUSTOMER` table. Since `LOGIN_INFO`, the table that
    the `LoginInfo` entity maps to, has a foreign key to the `CUSTOMER` table, the
    `LoginInfo` entity owns the relationship. If the relationship were unidirectional,
    we wouldn't have to make any changes to the `Customer` entity. However, since
    we would like to have a bidirectional relationship between these two entities,
    we need to add a `LoginInfo` field to the `Customer` entity, along with the corresponding
    getter and setter methods.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码变得有趣的地方在于`customer`字段的声明。如代码所示，`customer`字段装饰了`@OneToOne`注解；这使应用服务器知道这个实体与`Customer`实体之间存在一对一的关系。`customer`字段还装饰了`@JoinColumn`注解。这个注解让容器知道`LOGIN_INFO`表中的哪一列是对应`CUSTOMER`表主键的外键。由于`LOGIN_INFO`表（`LoginInfo`实体映射到的表）有一个指向`CUSTOMER`表的外键，因此`LoginInfo`实体拥有这个关系。如果这个关系是单向的，我们就不需要对`Customer`实体做任何修改。然而，由于我们希望这两个实体之间有一个双向关系，我们需要在`Customer`实体中添加一个`LoginInfo`字段，以及相应的getter和setter方法。
- en: 'Like we mentioned before, in order to make the one-to-one relationship between
    the `Customer` and `LoginInfo` entities bidirectional, we need to make a few simple
    changes to the `Customer` entity:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，为了使`Customer`和`LoginInfo`实体之间的一对一关系双向，我们需要对`Customer`实体进行一些简单的修改：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The only change we need to make to the `Customer` entity to make the one-to-one
    relationship bidirectional is to add a `LoginInfo` field to it, along with the
    corresponding setter and getter methods. The `loginInfo` field is decorated with
    the `@OneToOne` annotation. Since the `Customer` entity does not own the relationship
    (the table it maps to does not have a foreign key to the corresponding table),
    the `mappedBy` element of the `@OneToOne` annotation needs to be added. This element
    specifies which field in the corresponding entity has the other end of the relationship.
    In this particular case, the customer field in the `LoginInfo` entity corresponds
    to the other end of this one-to-one relationship.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`Customer`实体中的一对一关系双向，我们只需要在该实体中添加一个`LoginInfo`字段，以及相应的setter和getter方法。`loginInfo`字段被`@OneToOne`注解装饰。由于`Customer`实体不拥有这个关系（它映射的表没有对应表的键外键），`@OneToOne`注解的`mappedBy`元素需要被添加。此元素指定对应实体中哪个字段有关系的另一端。在这个特定的情况下，`LoginInfo`实体中的客户字段对应于这个一对一关系的另一端。
- en: 'The following Java class illustrates the use of the preceding entity:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java类说明了前面实体使用的情况：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this example, we first create an instance of the `LoginInfo` entity and populate
    it with some data. We then obtain an instance of the `Customer` entity from the
    database by invoking the `find()` method of `EntityManager` (data for this entity
    was inserted into the `CUSTOMERS` table in one of the previous examples). We then
    invoke the `setCustomer()` method on the `LoginInfo` entity, passing the customer
    object as a parameter. Finally, we invoke the `EntityManager.persist()` method
    to save the data in the database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先创建一个`LoginInfo`实体的实例，并用一些数据填充它。然后，我们通过调用`EntityManager`的`find()`方法从数据库中获取`Customer`实体的实例（该实体的数据在之前的某个例子中已插入到`CUSTOMERS`表中）。然后，我们在`LoginInfo`实体上调用`setCustomer()`方法，将客户对象作为参数传递。最后，我们调用`EntityManager.persist()`方法将数据保存到数据库中。
- en: What happens behind the scenes is that the `CUSTOMER_ID` column of the `LOGIN_INFO`
    table gets populated with the primary key of the corresponding row in the `CUSTOMERS`
    table. This can be easily verified by querying the `CUSTOMERDB` database.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 背后发生的事情是，`LOGIN_INFO`表的`CUSTOMER_ID`列被填充了对应于`CUSTOMERS`表中相应行的主键。这可以通过查询`CUSTOMERDB`数据库轻松验证。
- en: Notice how the call to `EntityManager.find()` to obtain the customer entity
    is inside the same transaction from where we call `EntityManager.persist()`. This
    must be the case; otherwise, the database will not be updated successfully.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到调用`EntityManager.find()`以获取客户实体是在调用`EntityManager.persist()`的同一事务中进行的。这必须是这样；否则，数据库将无法成功更新。
- en: One-to-many relationships
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一对多关系
- en: JPA one-to-many entity relationships can be bidirectional (one entity contains
    a many-to-one relationship and the corresponding entity contains an inverse one-to-many
    relationship).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: JPA中的一对多实体关系可以是双向的（一个实体包含一个多对一关系，而相应的实体包含一个反向的一对多关系）。
- en: With SQL, one-to-many relationships are defined by foreign keys in one of the
    tables. The `many` part of the relationship is the one containing a foreign key
    to the `one` part of the relationship. One-to-many relationships defined in an
    RDBMS are typically unidirectional, since making them bidirectional usually results
    in denormalized data.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQL，一对多关系通过一个表中的外键来定义。关系中的“多”部分是包含对关系“一”部分引用的部分。在RDBMS中定义的一对多关系通常是单向的，因为使它们双向通常会导致数据非规范化。
- en: Just like when defining a unidirectional one-to-many relationship in an RDBMS,
    in JPA the many part of the relationship is the one that has a reference to the
    `one` part of the relationship, therefore the annotation used to decorate the
    appropriate `setter` method is `@ManyToOne`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在RDBMS中定义单向的一对多关系一样，在JPA中，关系的“多”部分是包含对关系“一”部分引用的部分，因此用于装饰适当setter方法的注解是`@ManyToOne`。
- en: 'In the `CUSTOMERDB` database, there is a unidirectional one-to-many relationship
    between customers and orders. We define this relationship in the `Order` entity:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CUSTOMERDB`数据库中，客户和订单之间存在单向的一对多关系。我们在`Order`实体中定义这个关系：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we were to define a unidirectional many-to-one relationship between the
    `Orders` entity and the `Customer` entity, we wouldn''t need to make any changes
    to the `Customer` entity. To define a bidirectional one-to-many relationship between
    the two entities, a new field decorated with the `@OneToMany` annotation needs
    to be added to the `Customer` entity:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要在`Orders`实体和`Customer`实体之间定义单向的一对多关系，我们就不需要对`Customer`实体进行任何更改。为了在这两个实体之间定义双向的一对多关系，需要在`Customer`实体中添加一个用`@OneToMany`注解装饰的新字段：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The only difference between this version of the `Customer` entity and the previous
    one is the addition of the `orders` field and related `getter` and `setter` methods.
    Of special interest is the `@OneToMany` annotation decorating this field. The
    `mappedBy` attribute must match the name of the corresponding field in the entity
    corresponding to the `many` part of the relationship. In simple terms, the value
    of the `mappedBy` attribute must match the name of the field decorated with the
    `@ManyToOne` annotation in the bean at the other side of the relationship.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的`Customer`实体版本相比，唯一的区别是添加了`orders`字段和相关联的`getter`和`setter`方法。特别值得注意的是装饰此字段的`@OneToMany`注解。`mappedBy`属性必须与对应实体中关系`many`部分的相应字段名称匹配。简单来说，`mappedBy`属性值必须与关系另一端的bean中用`@ManyToOne`注解装饰的字段名称匹配。
- en: 'The following example code illustrates how to persist one-to-many relationships
    to the database:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码说明了如何将一对多关系持久化到数据库中：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding code is pretty similar to the previous example. It instantiates
    two instances of the `Order` entity, populates them with some data, then in a
    transaction an instance of the `Customer` entity is located and used as the parameter
    of the `setCustomer()` method of both instances of the `Order` entity. We then
    persist both `Order` entities by invoking `EntityManager.persist()` for each one
    of them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码与之前的示例非常相似。它创建了两个`Order`实体的实例，用一些数据填充它们，然后在事务中找到`Customer`实体的一个实例并用作两个`Order`实体实例的`setCustomer()`方法的参数。然后我们通过为每个`Order`实体调用`EntityManager.persist()`来持久化这两个`Order`实体。
- en: Just like when dealing with one-to-one relationships, what happens behind the
    scenes is that the `CUSTOMER_ID` column of the `ORDERS` table in the `CUSTOMERDB`
    database is populated with the primary key corresponding to the related row in
    the `CUSTOMERS` table.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像处理一对一关系时一样，幕后发生的事情是`CUSTOMERDB`数据库中`ORDERS`表的`CUSTOMER_ID`列被填充了对应于`CUSTOMERS`表中相关行的主键。
- en: Since the relationship is bidirectional, we can obtain all orders related to
    a customer by invoking the `getOrders()` method on the `Customer` entity.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于关系是双向的，我们可以通过在`Customer`实体上调用`getOrders()`方法来获取与客户相关的所有订单。
- en: Many-to-many relationships
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多对多关系
- en: 'In the `CUSTOMERDB` database, there is a many-to-many relationship between
    the `ORDERS` table and the `ITEMS` table. We can map this relationship by adding
    a new `Collection<Item>` field to the `Order` entity and decorating it with the
    `@ManyToMany` annotation:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CUSTOMERDB`数据库中，`ORDERS`表和`ITEMS`表之间存在多对多关系。我们可以通过向`Order`实体添加一个新的`Collection<Item>`字段并使用`@ManyToMany`注解来映射这种关系：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As we can see in the preceding code, in addition to being decorated with the
    `@ManyToMany` annotation, the `items` field is also decorated with the `@JoinTable`
    annotation. Like its name suggests, this annotation lets the application server
    know what table is used as a join table to create the many-to-many relationship
    between the two entities. This annotation has three relevant elements: the name
    element, which defines the name of the join table, and the `joinColumns` and `inverseJoinColumns`
    elements, which define the columns that serve as foreign keys in the join table
    pointing to the entities'' primary keys. Values for the `joinColumns` and `inverseJoinColumns`
    elements are yet another annotation: the `@JoinColumn` annotation. This annotation
    has two relevant elements: the name element, which defines the name of the column
    in the join table, and the `referencedColumnName` element, which defines the name
    of the column in the entity table.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们可以在前面的代码中看到的那样，除了被`@ManyToMany`注解装饰外，`items`字段还被`@JoinTable`注解装饰。正如其名称所暗示的那样，这个注解让应用程序服务器知道哪个表被用作连接表以在两个实体之间创建多对多关系。这个注解有三个相关元素：名称元素，它定义了连接表的名字，以及`joinColumns`和`inverseJoinColumns`元素，它们定义了作为连接表中指向实体主键的外键的列。`joinColumns`和`inverseJoinColumns`元素的值又是另一个注解：`@JoinColumn`注解。这个注解有两个相关元素：名称元素，它定义了连接表中的列名，以及`referencedColumnName`元素，它定义了实体表中的列名。
- en: 'The `Item` entity is a simple entity mapping to the `ITEMS` table in the `CUSTOMERDB`
    database:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item`实体是一个简单的实体，映射到`CUSTOMERDB`数据库中的`ITEMS`表：'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Just like one-to-one and one-to-many relationships, many-to-many relationships
    can be unidirectional or bidirectional. Since we would like the many-to-many relationship
    between the `Order` and `Item` entities to be bidirectional, we added a `Collection<Order>`
    field and decorated it with the `@ManyToMany` annotation. Since the corresponding
    field in the `Order` entity already has the join table defined, it is not necessary
    to do it again here. The entity containing the `@JoinTable` annotation is said
    to own the relationship; in a many-to-many relationship, either entity can own
    the relationship. In our example, the `Order` entity owns it, since its `Collection<Item>`
    field is decorated with the `@JoinTable` annotation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一和多对一关系一样，多对多关系可以是单向的也可以是双向的。由于我们希望`Order`和`Item`实体之间的多对多关系是双向的，所以我们添加了一个`Collection<Order>`字段，并用`@ManyToMany`注解装饰它。由于`Order`实体中相应的字段已经定义了连接表，因此在这里不需要再次定义。包含`@JoinTable`注解的实体被称为拥有关系；在多对多关系中，任一实体都可以拥有关系。在我们的例子中，`Order`实体拥有它，因为它的`Collection<Item>`字段被`@JoinTable`注解装饰。
- en: Just like with one-to-one and one-to-many relationships, the `@ManyToMany` annotation
    in the non-owning side of a bidirectional many-to-many relationship must contain
    a `mappedBy` element indicating which field in the owning entity defines the relationship.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一对一和多对一关系一样，双向多对多关系非拥有方上的`@ManyToMany`注解必须包含一个`mappedBy`元素，以指示拥有实体中定义关系的哪个字段。
- en: 'Now that we have seen the changes necessary to establish a bidirectional many-to-many
    relationship between the `Order` and `Item` entities, we can see the relationship
    in action in the following example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了在`Order`和`Item`实体之间建立双向多对多关系所必需的更改，我们可以在下面的示例中看到这种关系是如何运作的：
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code creates two instances of the `Item` entity and populates
    them with some data. It then adds these two instances to a collection. A transaction
    is then started and the two `Item` instances are persisted to the database. Then
    an instance of the `Order` entity is retrieved from the database. The `setItems()`
    method of the `Order` entity instance is then invoked, passing the collection
    containing the two `Item` instances as a parameter. The `Customer` instance is
    then persisted into the database. At this point, two rows are created behind the
    scenes to the `ORDER_ITEMS` table, which is the join table between the `ORDERS`
    and `ITEMS` tables.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码创建了两个`Item`实体的实例，并将一些数据填充到它们中。然后，它将这些两个实例添加到一个集合中。随后启动了一个事务，并将两个`Item`实例持久化到数据库中。然后从数据库中检索了一个`Order`实体的实例。随后调用`Order`实体实例的`setItems()`方法，并将包含两个`Item`实例的集合作为参数传递。然后，`Customer`实例被持久化到数据库中。此时，在后台为`ORDER_ITEMS`表创建了两个行，这是`ORDERS`和`ITEMS`表之间的连接表。
- en: Composite primary keys
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合主键
- en: Most tables in the `CUSTOMERDB` database have a column with the sole purpose
    of serving as a primary key (this type of primary key is sometimes referred to
    as a surrogate primary key or as an artificial primary key). However, some databases
    are not designed this way; instead a column in the database that is known to be
    unique across rows is used as the primary key. If there is no column whose value
    is not guaranteed to be unique across rows, then a combination of two or more
    columns is used as the table's primary key. It is possible to map this kind of
    primary key to JPA entities by using a `primary key` class.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUSTOMERDB`数据库中的大多数表都有一个列，其唯一目的是作为主键（这种类型的主键有时被称为代理主键或人工主键）。然而，一些数据库并不是这样设计的；相反，数据库中一个已知在行之间是唯一的列被用作主键。如果没有列的值在行之间不是保证唯一的，那么两个或更多列的组合被用作表的唯一主键。可以通过使用`primary
    key`类将此类主键映射到JPA实体。'
- en: 'There is one table in the `CUSTOMERDB` database that does not have a surrogate
    primary key: the `ORDER_ITEMS` table. This table serves as a join table between
    the `ORDERS` and the `ITEMS` tables, in addition to having foreign keys for these
    two tables, this table has an additional column called `ITEM_QTY` ;this column
    stores the quantity of each item in an order. Since this table does not have a
    surrogate primary key, the JPA entity mapping to it must have a custom `primary
    key` class. In this table, the combination of the `ORDER_ID` and the `ITEM_ID`
    columns must be unique, therefore this is a good combination for a composite primary
    key:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`CUSTOMERDB`数据库中有一个表没有代理主键：`ORDER_ITEMS`表。除了作为`ORDERS`和`ITEMS`表的连接表，以及这两个表的外键之外，这个表还有一个额外的列，称为`ITEM_QTY`；这个列存储每个订单中每个项目的数量。由于这个表没有代理主键，映射到它的JPA实体必须有一个自定义的`primary
    key`类。在这个表中，`ORDER_ID`和`ITEM_ID`列的组合必须是唯一的，因此这是一个复合主键的好组合：'
- en: '[PRE12]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'A custom `primary key` class must satisfy the following requirements:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义`primary key`类必须满足以下要求：
- en: The class must be public
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该类必须是公开的
- en: It must implement `java.io.Serializable`
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须实现`java.io.Serializable`
- en: It must have a public constructor that takes no arguments
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须有一个不接受任何参数的公开构造函数
- en: Its fields must be `public` or `protected`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的字段必须是`public`或`protected`
- en: Its field names and types must match those of the entity
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它的字段名称和类型必须与实体的匹配
- en: It must override the default `hashCode()` and `equals()` methods defined in
    the `java.lang.Object` class
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它必须重写`java.lang.Object`类中定义的默认`hashCode()`和`equals()`方法
- en: The preceding `OrderPK` class meets all of these requirements. It also has a
    convenience constructor that takes two `Long` objects to initialize its `orderId`
    and `itemId` fields. This constructor was added for convenience; this is not a
    prerequisite for the class to be used as a primary key class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`OrderPK`类满足所有这些要求。它还有一个方便的构造函数，该构造函数接受两个`Long`对象来初始化其`orderId`和`itemId`字段。这个构造函数是为了方便而添加的；这不是将此类用作主键类的先决条件。
- en: 'When an entity uses a custom `primary key` class, it must be decorated with
    the `@IdClass` annotation. Since the `OrderItem` class uses `OrderItemPK` as its
    custom `primary key` class, it must be decorated with the aforementioned annotation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当实体使用自定义`primary key`类时，它必须被`@IdClass`注解装饰。由于`OrderItem`类使用`OrderItemPK`作为其自定义`primary
    key`类，它必须被上述注解装饰：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are two differences between the preceding entity and the previous entities
    we have seen. The first difference is that this entity is decorated with the `@IdClass`
    annotation, indicating the primary key class corresponding to it. The second difference
    is that the preceding entity has more than one field decorated with the `@Id`
    annotation. Since this entity has a composite primary key, each field that is
    part of the primary key must be decorated with this annotation.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的实体与我们之前看到的实体有两个不同之处。第一个不同之处在于，这个实体被`@IdClass`注解装饰，表示对应的主键类。第二个不同之处在于，前面的实体有多个字段被`@Id`注解装饰。由于这个实体有一个复合主键，每个作为主键一部分的字段都必须被这个注解装饰。
- en: 'Obtaining a reference of an entity with a composite primary key is not much
    different from obtaining a reference to an entity with a primary key consisting
    of a single field. The following example demonstrates how to do this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 获取具有复合主键的实体引用与获取由单个字段组成的主键的实体引用没有太大区别。以下示例演示了如何做到这一点：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As can be seen in this example, the only difference between locating an entity
    with a composite primary key and an entity with a primary key consisting of a
    single field is that an instance of the custom `primary key` class must be passed
    as the second argument of the `EntityManager.find()` method. Fields for this instance
    must be populated with the appropriate values for each field that is part of the
    primary key.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Java Persistence Query Language
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of our examples that obtain entities from the database so far have conveniently
    assumed that the primary key for the entity is known ahead of time. We all know
    that frequently this is not the case. Whenever we need to search for an entity
    by a field other than the entity's primary key, we must use the **Java Persistence
    Query Language** (**JPQL**).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'JPQL is a SQL-like language used for retrieving, updating, and deleting entities
    in a database. The following example illustrates how to use JPQL to retrieve a
    subset of states from the `US_STATES` table in the `CUSTOMERDB` database:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding code invokes the `EntityManager.createQuery()` method, passing
    a `String` containing a JPQL query as a parameter. This method returns an instance
    of `javax.persistence.Query`. The query retrieves all `UsState` entities whose
    name starts with the word `New`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the preceding code, JPQL is similar to SQL; however, there
    are some differences that may confuse readers with some knowledge of SQL. The
    equivalent SQL code for the query in the code would be:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first difference between JPQL and SQL is that in JPQL we always reference
    entity names, wherein SQL table names are referenced. The `s` after the entity
    name in the JPQL query is an alias for the entity. Table aliases are optional
    in SQL, but entity aliases are required in JPQL. Keeping these differences in
    mind, the JPQL query should now be a lot less confusing.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The `:name` in the query is a **named parameter;** named parameters are meant
    to be substituted with actual values. This is done by invoking the `setParameter()`
    method in the instance of `javax.persistence.Query` returned by the call to `EntityManager.createQuery()`.
    A JPQL query can have multiple named parameters.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: To actually run the query and retrieve the entities from the database, the `getResultList()`
    method must be invoked in the instance of `javax.persistence.Query` obtained from
    `EntityManager.createQuery()`. This method returns an instance of a class implementing
    the `java.util.List` interface; this list contains the entities matching the query
    criteria. If no entities match the criteria, then an empty list is returned.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: If we are certain that the query will return exactly one entity, then the `getSingleResult()`
    method may be alternatively called on `Query` ; this method returns an `Object`
    that must be cast to the appropriate entity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses the `LIKE` operator to find entities whose names
    start with the word "New". This is accomplished by substituting the query's named
    parameter with the value "New%". The percent sign at the end of the parameter
    value means that any number of characters after the word "New" will match the
    expression. The percent sign can be used anywhere in the parameter value, for
    example, a value of "%Dakota" would match any entities whose name end in "Dakota",
    a value of "A%a" would match any states whose name starts with a capital "A" and
    end with a lowercase "a". There can be more than one % sign in a parameter value.
    The underscore sign, (_), can be used to match a single character; all the rules
    for the % sign apply to the underscore as well.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `LIKE` operator, there are other operators that can be used
    to retrieve entities from the database:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: The `=` operator will retrieve entities whose field at the left of the operator
    exactly match as the value to the right of the operator
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>` operator will retrieve entities whose field at the left of the operator
    is greater than the value to the right of the operator
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<` operator will retrieve entities whose field at the left of the operator
    is less than the value to the right of the operator
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>=` operator will retrieve entities whose field at the left of the operator
    is greater than or equal to the value to the right of the operator
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<=` operator will retrieve entities whose field at the left of the operator
    is less than or equal to the value to the right of the operator
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding operators work the same way as the equivalent operators
    in SQL. Just like in SQL, these operators can be combined with the `AND` and `OR`
    operators. Conditions combined with the `AND` operator match if both conditions
    are true; conditions combined with the `OR` operator match if at least one of
    the conditions is true.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'If we intend to use a query many times, it can be stored in a **named query**.
    Named queries can be defined by decorating the relevant entity class with the
    `@NamedQuery` annotation. This annotation has two elements: a `name` element used
    to set the name of the query, and a `query` element defining the query itself.
    To execute a named query, the `createNamedQuery()` method must be invoked in an
    instance of `EntityManager`. This method takes a `String` containing the query
    name as its sole parameter, and returns an instance of `javax.persistence.Query`.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In addition to retrieving entities, JPQL can be used to modify or delete entities.
    However, entity modification and deletion can be done programmatically via the
    `EntityManager` interface; doing so results in code that tends to be more readable
    than when using JPQL. Because of this, we will not cover entity modification and
    deletion via JPQL. Readers interested in writing JPQL queries to modify and delete
    entities, as well as readers wishing to know more about JPQL, are encouraged to
    review the Java Persistence 2.2 specification. This specification can be downloaded
    at [http://jcp.org/en/jsr/detail?id=338](http://jcp.org/en/jsr/detail?id=338).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The Criteria API
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main additions to JPA in the 2.0 specification was the introduction
    of the **Criteria API**. The Criteria API is meant as a complement to JPQL.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'Although JPQL is very flexible, it has some problems that make working with
    it more difficult than necessary. For starters, JPQL queries are stored as strings,
    and the compiler has no way of validating the JPQL syntax. Additionally, JPQL
    is not type-safe: we could write a JPQL query in which our where clause could
    have a string value for a numeric property and our code would compile and deploy
    just fine.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: To get around the JPQL limitations described in the previous paragraph, the
    Criteria API was introduced to JPA in version 2.0 of the specification. The Criteria
    API allows us to write JPA queries programmatically, without having to rely on
    JPQL.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how to use the Criteria API in our Java
    EE applications:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding example is equivalent to the JPQL example we saw earlier in this
    chapter. This example, however, takes advantage of the Criteria API instead of
    relying on JPQL.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: When writing code using the Criteria API, the first thing we need to do is obtain
    an instance of a class implementing the `javax.persistence.criteria.CriteriaBuilder`
    interface; as we can see in the preceding example, we need to obtain this instance
    by invoking the `getCriteriaBuilder()` method on our `EntityManager`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: From our `CriteriaBuilder` implementation, we need to obtain an instance of
    a class implementing the `javax.persistence.criteria.CriteriaQuery` interface.
    We do this by invoking the `createQuery()` method in our `CriteriaBuilder` implementation.
    Notice that `CriteriaQuery` is generically typed. The generic type argument dictates
    the type of result that our `CriteriaQuery` implementation will return upon execution.
    By taking advantage of generics in this way, the Criteria API allows us to write
    type-safe code.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained a `CriteriaQuery` implementation, from it we can obtain
    an instance of a class implementing the `javax.persistence.criteria.Root` interface.
    The root implementation dictates which JPA Entity we will be querying from. It
    is analogous to the `FROM` query in JPQL (and SQL).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines in our example take advantage of another new addition to
    the JPA specification: the **Metamodel API**. In order to take advantage of the
    Metamodel API, we need to obtain an implementation of the `javax.persistence.metamodel.Metamodel`
    interface by invoking the `getMetamodel()` method on our `EntityManager`.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: From our `Metamodel` implementation, we can obtain a generically typed instance
    of the `javax.persistence.metamodel.EntityType` interface. The generic type argument
    indicates the JPA entity our `EntityType` implementation corresponds to. `EntityType`
    allows us to browse the `persistent` attributes of our JPA entities at runtime.
    This is exactly what we do in the next line in our example. In our case, we get
    an instance of `SingularAttribute`, which maps to a simple, singular attribute
    in our JPA entity. `EntityType` has methods to obtain attributes that map to collections,
    sets, lists, and maps. Obtaining these attribute types is very similar to obtaining
    a `SingularAttribute`, therefore we won't be covering those directly. Please refer
    to the Java EE 8 API documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)
    for more information.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in our example, `SingularAttribute` contains two generic type
    arguments. The first argument dictates the JPA entity we are working with, and
    the second one indicates the type of the attribute. We obtain our `SingularAttribute`
    by invoking the `getDeclaredSingularAttribute()` method on our `EntityType` implementation
    and passing the attribute name (as declared in our JPA entity) as a string.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained our `SingularAttribute` implementation, we need to obtain
    an import `javax.persistence.criteria.Path` implementation by invoking the `get()`
    method in our `Root` instance, and passing our `SingularAttribute` as a parameter.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will get a list of all the *new* states in the United States;
    that is, all states whose names start with `New`. This, of course, is a job for
    a "like" condition. We can do this with the criteria API by invoking the `like()`
    method on our `CriteriaBuilder` implementation. The `like()` method takes our
    `Path` implementation as its first parameter, and the value to search for as its
    second parameter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '`CriteriaBuilder` has a number of methods that are analogous to SQL and JPQL
    clauses, such as `equals()`, `greaterThan()`, `lessThan()`, `and()`, and `or()`
    (for the complete list, refer to the Java EE 8 documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)).
    These methods can be combined to create complex queries via the Criteria API.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: The `like()` method in `CriteriaBuilder` returns an implementation of the `javax.persistence.criteria.Predicate`
    interface, which we need to pass to the `where()` method in our `CriteriaQuery`
    implementation. This method returns a new instance of `CriteriaBuilder`, which
    we assign to our `criteriaBuilder` variable.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: At this point we are ready to build our query. When working with the Criteria
    API, we deal with the `javax.persistence.TypedQuery` interface, which can be thought
    of as a type-safe version of the `Query` interface we use with JPQL. We obtain
    an instance of `TypedQuery` by invoking the `createQuery()` method in `EntityManager`,
    and passing our `CriteriaQuery` implementation as a parameter.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: To obtain our query results as a list, we simply invoke `getResultList()` on
    our `TypedQuery` implementation. It is worth reiterating that the Criteria API
    is type-safe, therefore attempting to assign the results of `getResultList()`
    to a list of the wrong type would result in a compilation error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Updating data with the Criteria API
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the JPA Criteria API was initially added to JPA 2.0, it only supported
    selecting data from the database. Modifying existing data was not supported.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'JPA 2.1, introduced in Java EE 7, added support for updating database data
    via the `CriteriaUpdate` interface; the following example illustrates how to use
    it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: What this example is actually doing is finding all of the database rows with
    "New Yorc" (a typo) as a city, and replacing the value with the correct spelling
    of "New York".
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the previous example, we obtain an instance of a class implementing
    the `CriteriaBuilder` interface by invoking the `getCriteriaBuilder()` method
    on our `EntityManager` instance.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: We then obtain an instance of a class implementing `CriteriaUpdate` by invoking
    `createCriteriaUpdate()` on our `CriteriaBuilder` instance.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to obtain an instance of a class implementing `Root` by invoking
    the `from()` method on our `CriteriaUpdate` instance.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: We then invoke the `set()` method on `CriteriaUpdate` to specify the new values
    our rows will have after they have been updated; the first parameter of the `set()`
    method must be a `String` matching the property name in the `Entity` class, and
    the second parameter must be the new value.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we build the where clause by invoking the `where()` method on
    `CriteriaUpdate`, and passing the `Predicate` returned by the `equal()` method
    invoked in `CriteriaBuilder`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Then we get a `Query` implementation by invoking `createQuery()` on `EntityManager`,
    and passing our `CriteriaUpdate` instance as a parameter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we execute our query as usual by invoking `executeUpdate()` on our
    `Query` implementation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data with the Criteria API
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to adding support for data updates via the Criteria API, JPA 2.1
    added the ability to bulk-delete database rows with the new `CriteriaDelete` interface.
    The following code snippet illustrates its usage:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: To use `CriteriaDelete`, we first obtain an instance of `CriteriaBuilder` as
    usual, then invoke the `createCriteriaDelete()` method on our `CriteriaBuilder`
    instance to obtain an implementation of `CriteriaDelete`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an instance of `CriteriaDelete`, we build the where clause in the
    normal way with the Criteria API.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built our where clause, we obtain an implementation of the `Query`
    interface and invoke `executeUpdate()` on it as usual.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation support
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another feature introduced in JPA 2.0 is support for JSR 303 **Bean Validation**.
    Bean Validation support allows us to annotate our JPA entities with Bean Validation
    annotations. These annotations allow us to easily validate user input and perform
    data sanitation.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of Bean Validation is very simple; all we need to do is annotate
    our JPA Entity fields or getter methods with any of the validation annotations
    defined in the `javax.validation.constraints` package. Once our fields are annotated
    as appropriate, the `EntityManager` will prevent non-validating data from being
    persisted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example is a modified version of the `Customer` JPA entity
    we saw earlier in this chapter. It has been modified to take advantage of Bean
    Validation in some of its fields:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we used the `@NotNull` annotation to prevent the `firstName`
    and `lastName` of our entity from being persisted with `null` values. We also
    used the `@Size` annotation to restrict the minimum and maximum length of these
    fields.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: That is all we need to do to take advantage of Bean Validation in JPA. If our
    code attempts to persist or update an instance of our entity that does not pass
    the declared validation, an exception of type `javax.validation.ConstraintViolationException`
    will be thrown, and the entity will not be persisted.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Bean Validation pretty much automates data validation, freeing
    us from having to manually write validation code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the two annotations discussed in the previous example, the `javax.validation.constraints`
    package contains several additional annotations we can use to automate validation
    on our JPA entities. Please refer to the Java EE 8 API documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)
    for the complete list.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Final notes
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the examples for this chapter, we showed database access performed directly
    from CDI named beans serving as controllers. We did this to get the point across
    without getting mired in the details; however, in general, this is not a good
    practice. Database access code should be encapsulated in **Data Access Objects**
    (**DAOs**).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the DAO design pattern, see [http://www.oracle.com/technetwork/java/dao-138818.html.](http://www.oracle.com/technetwork/java/dao-138818.html)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Named beans typically assume the role of controllers and/or model when using
    the **Model-View-Controller** (**MVC**) design pattern, a practice so common that
    it has become the de facto standard for Java EE applications.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the MVC design pattern, see [http://www.oracle.com/technetwork/java/mvc-140477.html.](http://www.oracle.com/technetwork/java/mvc-140477.html)
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we chose not to show any user interface code in our examples since
    it is irrelevant to the topic at hand. However, code downloads for this chapter
    include JSF pages that invoke named beans in this chapter, and display a confirmation
    page once the named bean invocation finishes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered how to access data in a database via the Java Persistence
    API (JPA).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: We covered how to mark a Java class as a JPA entity by decorating it with the
    `@Entity` annotation. Additionally, we covered how to map an entity to a database
    table via the `@Table` annotation. We also covered how to map entity fields to
    database columns via the `@Column` annotation, as well as declaring an entity's
    primary key via the `@Id` annotation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Using the `javax.persistence.EntityManager` interface to find, persist, and
    update JPA entities was also covered.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Defining both unidirectional and bidirectional one-to-one, one-to-many, and
    many-to-many relationships between JPA entities was covered as well.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored how to use JPA composite primary keys by developing
    custom primary key classes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Also, we covered how to retrieve entities from a database by using the Java
    Persistence Query Language (JPQL).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: We discussed additional JPA features such as the Criteria API, which allows
    us to build JPA queries programmatically; the Metamodel API, which allows us to
    take advantage of Java's type safety when working with JPA; and Bean Validation,
    which allows us to easily validate input by simply annotating our JPA entity fields.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
