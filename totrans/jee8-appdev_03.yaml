- en: Object Relational Mapping with the Java Persistence API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any non-trivial Java EE application will persist data to a relational database.
    In this chapter, we will cover how to connect to a database and perform CRUD (Create,
    Read, Update, Delete) operations.
  prefs: []
  type: TYPE_NORMAL
- en: The **Java Persistence API** (**JPA**) is the standard Java EE **Object Relational
    Mapping** (**ORM**) tool. We will discuss this API in detail in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the topics covered in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data from a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting data into a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating data in a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting data in a database through JPA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building queries programmatically through the JPA Criteria API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating data validation through JPA 2.0's Bean Validation support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Customer database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Examples in this chapter will use a database called `CUSTOMERDB`. This database
    contains tables to track customer and order information for a fictitious store.
    The database uses JavaDB for its RDBMS, since it comes bundled with GlassFish,
    but it can be easily adapted to any other RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: A script is included with this book's code download to create this database
    and pre-populate some of its tables. Instructions on how to execute the script,
    and add a connection pool and data source to access it are included in the download
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema for the `CUSTOMERDB` database is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/44c73028-7fc2-4764-9968-89f35310ae54.png)'
  prefs: []
  type: TYPE_IMG
- en: As can be seen in the diagram, the database contains tables to store customer
    information such as name, address, and email address. It also contains tables
    to store order and item information.
  prefs: []
  type: TYPE_NORMAL
- en: The `ADDRESS_TYPES` table will store values such as "Home", "Mailing", and "Shipping",
    to distinguish the type of address in the `ADDRESSES` table; similarly, the `TELEPHONE_TYPES`
    table stores the "Cell", "Home", and "Work" values. These two tables are prepopulated
    when creating the database, as well as the `US_STATES` table.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, our database only deals with U.S. addresses.
  prefs: []
  type: TYPE_NORMAL
- en: The Java Persistence API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Java Persistence API (JPA)** was introduced to Java EE in version 5 of
    the specification. Like its name implies, it is used to persist data to a relational
    database management system. JPA is a replacement for the Entity Beans that were
    used in J2EE. Java EE Entities are regular Java classes; the Java EE container
    knows these classes are Entities because they are decorated with the `@Entity`
    annotation. Let''s look at an Entity mapping to the `CUSTOMER` table in the `CUSTOMERDB`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `@Entity` annotation lets any other Java EE-compliant
    application server know that this class is a JPA entity.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Table(name = "CUSTOMERS")` annotation lets the application server know
    what table to map the entity to. The value of the `name` element contains the
    name of the database table that the entity maps to. This annotation is optional;
    if the name of the class maps the name of the database table, then it isn't necessary
    to specify what table the entity maps to.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Id` annotation indicates that the `customerId` field maps to the primary
    key.
  prefs: []
  type: TYPE_NORMAL
- en: The `@Column` annotation maps each field to a column in the table. If the name
    of the field matches the name of the database column, then this annotation is
    not needed. This is the reason why the `email` field is not annotated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EntityManager` class (this is actually an interface; each Java EE compliant
    application server provides its own implementation) is used to persist entities
    to a database. The following example illustrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding CDI named bean obtains an instance of a class implementing the
    `javax.persistence.EntityManager` interface via dependency injection. This is
    done by decorating the `EntityManager` variable with the `@PersistenceContext`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of a class implementing the `javax.transaction.UserTransaction`
    interface is then injected via the `@Resource` annotation. This object is necessary,
    since, without it invoking calls to persist Entities to the database, the code
    would throw a `javax.persistence.TransactionRequiredException` .
  prefs: []
  type: TYPE_NORMAL
- en: '`EntityManager` performs many database-related tasks, such as finding entities
    in the database, updating them, or deleting them.'
  prefs: []
  type: TYPE_NORMAL
- en: Since JPA Entities are **plain old Java objects** ( **POJOs** ), they can be
    instantiated via the `new` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The call to the `setCustomerId()` method takes advantage of autoboxing, a feature
    added to the Java language in JDK 1.5\. Notice that the method takes an instance
    of `java.lang.Long` as its parameter, but we are using `long` primitives. The
    code compiles and executes properly thanks to this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the `persist()` method on `EntityManager` must be in a transaction,
    therefore it is necessary to start one by calling the `begin()` method on `UserTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: We then insert two new rows to the `CUSTOMERS` table by calling the `persist()`
    method on `entityManager` for the two instances of the `Customer` class we populated
    earlier in the code.
  prefs: []
  type: TYPE_NORMAL
- en: After persisting the data contained in the `customer` and `customer2` objects,
    we search the database for a row in the `CUSTOMERS` table with a primary key of
    four. We do this by invoking the `find()` method on `entityManager`. This method
    takes the class of the Entity we are searching for as its first parameter, and
    the primary key of the row corresponding to the object we want to obtain. This
    method is roughly equivalent to the `findByPrimaryKey()` method on an entity bean's
    home interface.
  prefs: []
  type: TYPE_NORMAL
- en: The primary key we set for the `customer2` object was 4, therefore what we have
    now is a copy of this object. The last name for this customer was misspelled when
    we originally inserted his data into the database. We can now correct Mr. Johnson's
    last name by invoking the `setLastName()` method on `customer3`, then we can update
    the information in the database by invoking `entityManager.persist()`.
  prefs: []
  type: TYPE_NORMAL
- en: We then delete the information for the `customer` object by invoking `entityManager.remove()`
    and passing the `customer` object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we commit the changes to the database by invoking the `commit()` method
    on `userTransaction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for the preceding code to work as expected, an XML configuration file
    named `persistence.xml` must be deployed in the WAR file containing the previously-named
    bean. This file must be placed in the `WEB-INF/classes/META-INF/` directory inside
    the WAR file. The contents of this file for the preceding code are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`persistence.xml` must contain at least one `<persistence-unit>` element. Each
    `<persistence-unit>` element must provide a value for its `name` attribute and
    must contain a `<jta-data-source>` child element whose value is the JNDI name
    of the data source to be used for the persistence unit.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason more than one `<persistence-unit>` element is allowed is because
    an application may access more than one database. A `<persistence-unit>` element
    is required for each database the application will access. If the application
    defines more than one `<persistence-unit>` element, then the `@PersistenceContext`
    annotation used to inject `EntityManager` must provide a value for its `unitName`
    element; the value for this element must match the name attribute of the corresponding
    `<persistence-unit>` element in `persistence.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cannot persist detached object Exception: Frequently, an application will retrieve
    a JPA entity via the `EntityManager.find()` method, then pass this entity to a
    business or user interface layer, where it will potentially be modified, and later
    the database data corresponding to the entity will be updated. In cases such as
    this, invoking `EntityManager.persist()` will result in an exception. In order
    to update JPA entities this way, we need to invoke `EntityManager.merge()`. This
    method takes an instance of the JPA entity as its single argument and updates
    the corresponding row in the database with the data stored in it.'
  prefs: []
  type: TYPE_NORMAL
- en: Entity relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to retrieve, insert, update, and delete
    single entities from the database. Entities are rarely isolated; in the vast majority
    of cases they are related to other entities.
  prefs: []
  type: TYPE_NORMAL
- en: Entities can have one-to-one, one-to-many, many-to-one, and many-to-many relationships.
  prefs: []
  type: TYPE_NORMAL
- en: In the `CustomerDB` database, for example, there is a one-to-one relationship
    between the `LOGIN_INFO` and the `CUSTOMERS` tables. This means that each customer
    has exactly one corresponding row in the login info table. There is also a one-to-many
    relationship between the `CUSTOMERS` table and the `ORDERS` table. This is because
    a customer can place many orders, but each order belongs only to a single customer.
    Additionally, there is a many-to-many relationships between the `ORDERS` table
    and the `ITEMS` table. This is because an order can contain many items and an
    item can be on many orders.
  prefs: []
  type: TYPE_NORMAL
- en: In the next few sections, we will discuss how to establish relationships between
    JPA entities.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One-to-one relationships occur when an instance of an entity can have zero or
    one corresponding instance of another entity.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one entity relationships can be bidirectional (each entity is aware of
    the relationship) or unidirectional (only one of the entities is aware of the
    relationship). In the `CUSTOMERDB` database, the one-to-one mapping between the
    `LOGIN_INFO` and the `CUSTOMERS` tables is unidirectional, since the `LOGIN_INFO`
    table has a foreign key to the `CUSTOMERS` table, but not the other way around.
    As we will soon see, this fact does not stop us from creating a bidirectional
    one-to-one relationship between the `Customer` entity and the `LoginInfo` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for the `LoginInfo` entity, which maps to the `LOGIN_INFO`
    table, can be seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The code for this entity is very similar to the code for the `Customer` entity.
    It defines fields that map to database columns. Each field whose name does not
    match the database column name is decorated with the `@Column` annotation; in
    addition to that, the primary key is decorated with the `@Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Where the preceding code gets interesting is the declaration of the `customer`
    field. As can be seen in the code, the `customer` field is decorated with the
    `@OneToOne` annotation; this lets the application server know that there is a
    one-to-one relationship between this entity and the `Customer` entity. The customer
    field is also decorated with the `@JoinColumn` annotation. This annotation lets
    the container know which column in the `LOGIN_INFO` table is the foreign key corresponding
    to the primary key on the `CUSTOMER` table. Since `LOGIN_INFO`, the table that
    the `LoginInfo` entity maps to, has a foreign key to the `CUSTOMER` table, the
    `LoginInfo` entity owns the relationship. If the relationship were unidirectional,
    we wouldn't have to make any changes to the `Customer` entity. However, since
    we would like to have a bidirectional relationship between these two entities,
    we need to add a `LoginInfo` field to the `Customer` entity, along with the corresponding
    getter and setter methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like we mentioned before, in order to make the one-to-one relationship between
    the `Customer` and `LoginInfo` entities bidirectional, we need to make a few simple
    changes to the `Customer` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The only change we need to make to the `Customer` entity to make the one-to-one
    relationship bidirectional is to add a `LoginInfo` field to it, along with the
    corresponding setter and getter methods. The `loginInfo` field is decorated with
    the `@OneToOne` annotation. Since the `Customer` entity does not own the relationship
    (the table it maps to does not have a foreign key to the corresponding table),
    the `mappedBy` element of the `@OneToOne` annotation needs to be added. This element
    specifies which field in the corresponding entity has the other end of the relationship.
    In this particular case, the customer field in the `LoginInfo` entity corresponds
    to the other end of this one-to-one relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Java class illustrates the use of the preceding entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first create an instance of the `LoginInfo` entity and populate
    it with some data. We then obtain an instance of the `Customer` entity from the
    database by invoking the `find()` method of `EntityManager` (data for this entity
    was inserted into the `CUSTOMERS` table in one of the previous examples). We then
    invoke the `setCustomer()` method on the `LoginInfo` entity, passing the customer
    object as a parameter. Finally, we invoke the `EntityManager.persist()` method
    to save the data in the database.
  prefs: []
  type: TYPE_NORMAL
- en: What happens behind the scenes is that the `CUSTOMER_ID` column of the `LOGIN_INFO`
    table gets populated with the primary key of the corresponding row in the `CUSTOMERS`
    table. This can be easily verified by querying the `CUSTOMERDB` database.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how the call to `EntityManager.find()` to obtain the customer entity
    is inside the same transaction from where we call `EntityManager.persist()`. This
    must be the case; otherwise, the database will not be updated successfully.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JPA one-to-many entity relationships can be bidirectional (one entity contains
    a many-to-one relationship and the corresponding entity contains an inverse one-to-many
    relationship).
  prefs: []
  type: TYPE_NORMAL
- en: With SQL, one-to-many relationships are defined by foreign keys in one of the
    tables. The `many` part of the relationship is the one containing a foreign key
    to the `one` part of the relationship. One-to-many relationships defined in an
    RDBMS are typically unidirectional, since making them bidirectional usually results
    in denormalized data.
  prefs: []
  type: TYPE_NORMAL
- en: Just like when defining a unidirectional one-to-many relationship in an RDBMS,
    in JPA the many part of the relationship is the one that has a reference to the
    `one` part of the relationship, therefore the annotation used to decorate the
    appropriate `setter` method is `@ManyToOne`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `CUSTOMERDB` database, there is a unidirectional one-to-many relationship
    between customers and orders. We define this relationship in the `Order` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were to define a unidirectional many-to-one relationship between the
    `Orders` entity and the `Customer` entity, we wouldn''t need to make any changes
    to the `Customer` entity. To define a bidirectional one-to-many relationship between
    the two entities, a new field decorated with the `@OneToMany` annotation needs
    to be added to the `Customer` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this version of the `Customer` entity and the previous
    one is the addition of the `orders` field and related `getter` and `setter` methods.
    Of special interest is the `@OneToMany` annotation decorating this field. The
    `mappedBy` attribute must match the name of the corresponding field in the entity
    corresponding to the `many` part of the relationship. In simple terms, the value
    of the `mappedBy` attribute must match the name of the field decorated with the
    `@ManyToOne` annotation in the bean at the other side of the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example code illustrates how to persist one-to-many relationships
    to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is pretty similar to the previous example. It instantiates
    two instances of the `Order` entity, populates them with some data, then in a
    transaction an instance of the `Customer` entity is located and used as the parameter
    of the `setCustomer()` method of both instances of the `Order` entity. We then
    persist both `Order` entities by invoking `EntityManager.persist()` for each one
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: Just like when dealing with one-to-one relationships, what happens behind the
    scenes is that the `CUSTOMER_ID` column of the `ORDERS` table in the `CUSTOMERDB`
    database is populated with the primary key corresponding to the related row in
    the `CUSTOMERS` table.
  prefs: []
  type: TYPE_NORMAL
- en: Since the relationship is bidirectional, we can obtain all orders related to
    a customer by invoking the `getOrders()` method on the `Customer` entity.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `CUSTOMERDB` database, there is a many-to-many relationship between
    the `ORDERS` table and the `ITEMS` table. We can map this relationship by adding
    a new `Collection<Item>` field to the `Order` entity and decorating it with the
    `@ManyToMany` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, in addition to being decorated with the
    `@ManyToMany` annotation, the `items` field is also decorated with the `@JoinTable`
    annotation. Like its name suggests, this annotation lets the application server
    know what table is used as a join table to create the many-to-many relationship
    between the two entities. This annotation has three relevant elements: the name
    element, which defines the name of the join table, and the `joinColumns` and `inverseJoinColumns`
    elements, which define the columns that serve as foreign keys in the join table
    pointing to the entities'' primary keys. Values for the `joinColumns` and `inverseJoinColumns`
    elements are yet another annotation: the `@JoinColumn` annotation. This annotation
    has two relevant elements: the name element, which defines the name of the column
    in the join table, and the `referencedColumnName` element, which defines the name
    of the column in the entity table.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Item` entity is a simple entity mapping to the `ITEMS` table in the `CUSTOMERDB`
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just like one-to-one and one-to-many relationships, many-to-many relationships
    can be unidirectional or bidirectional. Since we would like the many-to-many relationship
    between the `Order` and `Item` entities to be bidirectional, we added a `Collection<Order>`
    field and decorated it with the `@ManyToMany` annotation. Since the corresponding
    field in the `Order` entity already has the join table defined, it is not necessary
    to do it again here. The entity containing the `@JoinTable` annotation is said
    to own the relationship; in a many-to-many relationship, either entity can own
    the relationship. In our example, the `Order` entity owns it, since its `Collection<Item>`
    field is decorated with the `@JoinTable` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Just like with one-to-one and one-to-many relationships, the `@ManyToMany` annotation
    in the non-owning side of a bidirectional many-to-many relationship must contain
    a `mappedBy` element indicating which field in the owning entity defines the relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have seen the changes necessary to establish a bidirectional many-to-many
    relationship between the `Order` and `Item` entities, we can see the relationship
    in action in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates two instances of the `Item` entity and populates
    them with some data. It then adds these two instances to a collection. A transaction
    is then started and the two `Item` instances are persisted to the database. Then
    an instance of the `Order` entity is retrieved from the database. The `setItems()`
    method of the `Order` entity instance is then invoked, passing the collection
    containing the two `Item` instances as a parameter. The `Customer` instance is
    then persisted into the database. At this point, two rows are created behind the
    scenes to the `ORDER_ITEMS` table, which is the join table between the `ORDERS`
    and `ITEMS` tables.
  prefs: []
  type: TYPE_NORMAL
- en: Composite primary keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most tables in the `CUSTOMERDB` database have a column with the sole purpose
    of serving as a primary key (this type of primary key is sometimes referred to
    as a surrogate primary key or as an artificial primary key). However, some databases
    are not designed this way; instead a column in the database that is known to be
    unique across rows is used as the primary key. If there is no column whose value
    is not guaranteed to be unique across rows, then a combination of two or more
    columns is used as the table's primary key. It is possible to map this kind of
    primary key to JPA entities by using a `primary key` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one table in the `CUSTOMERDB` database that does not have a surrogate
    primary key: the `ORDER_ITEMS` table. This table serves as a join table between
    the `ORDERS` and the `ITEMS` tables, in addition to having foreign keys for these
    two tables, this table has an additional column called `ITEM_QTY` ;this column
    stores the quantity of each item in an order. Since this table does not have a
    surrogate primary key, the JPA entity mapping to it must have a custom `primary
    key` class. In this table, the combination of the `ORDER_ID` and the `ITEM_ID`
    columns must be unique, therefore this is a good combination for a composite primary
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'A custom `primary key` class must satisfy the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The class must be public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must implement `java.io.Serializable`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must have a public constructor that takes no arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its fields must be `public` or `protected`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Its field names and types must match those of the entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It must override the default `hashCode()` and `equals()` methods defined in
    the `java.lang.Object` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding `OrderPK` class meets all of these requirements. It also has a
    convenience constructor that takes two `Long` objects to initialize its `orderId`
    and `itemId` fields. This constructor was added for convenience; this is not a
    prerequisite for the class to be used as a primary key class.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an entity uses a custom `primary key` class, it must be decorated with
    the `@IdClass` annotation. Since the `OrderItem` class uses `OrderItemPK` as its
    custom `primary key` class, it must be decorated with the aforementioned annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There are two differences between the preceding entity and the previous entities
    we have seen. The first difference is that this entity is decorated with the `@IdClass`
    annotation, indicating the primary key class corresponding to it. The second difference
    is that the preceding entity has more than one field decorated with the `@Id`
    annotation. Since this entity has a composite primary key, each field that is
    part of the primary key must be decorated with this annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtaining a reference of an entity with a composite primary key is not much
    different from obtaining a reference to an entity with a primary key consisting
    of a single field. The following example demonstrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in this example, the only difference between locating an entity
    with a composite primary key and an entity with a primary key consisting of a
    single field is that an instance of the custom `primary key` class must be passed
    as the second argument of the `EntityManager.find()` method. Fields for this instance
    must be populated with the appropriate values for each field that is part of the
    primary key.
  prefs: []
  type: TYPE_NORMAL
- en: Java Persistence Query Language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All of our examples that obtain entities from the database so far have conveniently
    assumed that the primary key for the entity is known ahead of time. We all know
    that frequently this is not the case. Whenever we need to search for an entity
    by a field other than the entity's primary key, we must use the **Java Persistence
    Query Language** (**JPQL**).
  prefs: []
  type: TYPE_NORMAL
- en: 'JPQL is a SQL-like language used for retrieving, updating, and deleting entities
    in a database. The following example illustrates how to use JPQL to retrieve a
    subset of states from the `US_STATES` table in the `CUSTOMERDB` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code invokes the `EntityManager.createQuery()` method, passing
    a `String` containing a JPQL query as a parameter. This method returns an instance
    of `javax.persistence.Query`. The query retrieves all `UsState` entities whose
    name starts with the word `New`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen in the preceding code, JPQL is similar to SQL; however, there
    are some differences that may confuse readers with some knowledge of SQL. The
    equivalent SQL code for the query in the code would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first difference between JPQL and SQL is that in JPQL we always reference
    entity names, wherein SQL table names are referenced. The `s` after the entity
    name in the JPQL query is an alias for the entity. Table aliases are optional
    in SQL, but entity aliases are required in JPQL. Keeping these differences in
    mind, the JPQL query should now be a lot less confusing.
  prefs: []
  type: TYPE_NORMAL
- en: The `:name` in the query is a **named parameter;** named parameters are meant
    to be substituted with actual values. This is done by invoking the `setParameter()`
    method in the instance of `javax.persistence.Query` returned by the call to `EntityManager.createQuery()`.
    A JPQL query can have multiple named parameters.
  prefs: []
  type: TYPE_NORMAL
- en: To actually run the query and retrieve the entities from the database, the `getResultList()`
    method must be invoked in the instance of `javax.persistence.Query` obtained from
    `EntityManager.createQuery()`. This method returns an instance of a class implementing
    the `java.util.List` interface; this list contains the entities matching the query
    criteria. If no entities match the criteria, then an empty list is returned.
  prefs: []
  type: TYPE_NORMAL
- en: If we are certain that the query will return exactly one entity, then the `getSingleResult()`
    method may be alternatively called on `Query` ; this method returns an `Object`
    that must be cast to the appropriate entity.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example uses the `LIKE` operator to find entities whose names
    start with the word "New". This is accomplished by substituting the query's named
    parameter with the value "New%". The percent sign at the end of the parameter
    value means that any number of characters after the word "New" will match the
    expression. The percent sign can be used anywhere in the parameter value, for
    example, a value of "%Dakota" would match any entities whose name end in "Dakota",
    a value of "A%a" would match any states whose name starts with a capital "A" and
    end with a lowercase "a". There can be more than one % sign in a parameter value.
    The underscore sign, (_), can be used to match a single character; all the rules
    for the % sign apply to the underscore as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `LIKE` operator, there are other operators that can be used
    to retrieve entities from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: The `=` operator will retrieve entities whose field at the left of the operator
    exactly match as the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>` operator will retrieve entities whose field at the left of the operator
    is greater than the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<` operator will retrieve entities whose field at the left of the operator
    is less than the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `>=` operator will retrieve entities whose field at the left of the operator
    is greater than or equal to the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `<=` operator will retrieve entities whose field at the left of the operator
    is less than or equal to the value to the right of the operator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the preceding operators work the same way as the equivalent operators
    in SQL. Just like in SQL, these operators can be combined with the `AND` and `OR`
    operators. Conditions combined with the `AND` operator match if both conditions
    are true; conditions combined with the `OR` operator match if at least one of
    the conditions is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we intend to use a query many times, it can be stored in a **named query**.
    Named queries can be defined by decorating the relevant entity class with the
    `@NamedQuery` annotation. This annotation has two elements: a `name` element used
    to set the name of the query, and a `query` element defining the query itself.
    To execute a named query, the `createNamedQuery()` method must be invoked in an
    instance of `EntityManager`. This method takes a `String` containing the query
    name as its sole parameter, and returns an instance of `javax.persistence.Query`.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to retrieving entities, JPQL can be used to modify or delete entities.
    However, entity modification and deletion can be done programmatically via the
    `EntityManager` interface; doing so results in code that tends to be more readable
    than when using JPQL. Because of this, we will not cover entity modification and
    deletion via JPQL. Readers interested in writing JPQL queries to modify and delete
    entities, as well as readers wishing to know more about JPQL, are encouraged to
    review the Java Persistence 2.2 specification. This specification can be downloaded
    at [http://jcp.org/en/jsr/detail?id=338](http://jcp.org/en/jsr/detail?id=338).
  prefs: []
  type: TYPE_NORMAL
- en: The Criteria API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main additions to JPA in the 2.0 specification was the introduction
    of the **Criteria API**. The Criteria API is meant as a complement to JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although JPQL is very flexible, it has some problems that make working with
    it more difficult than necessary. For starters, JPQL queries are stored as strings,
    and the compiler has no way of validating the JPQL syntax. Additionally, JPQL
    is not type-safe: we could write a JPQL query in which our where clause could
    have a string value for a numeric property and our code would compile and deploy
    just fine.'
  prefs: []
  type: TYPE_NORMAL
- en: To get around the JPQL limitations described in the previous paragraph, the
    Criteria API was introduced to JPA in version 2.0 of the specification. The Criteria
    API allows us to write JPA queries programmatically, without having to rely on
    JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example illustrates how to use the Criteria API in our Java
    EE applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is equivalent to the JPQL example we saw earlier in this
    chapter. This example, however, takes advantage of the Criteria API instead of
    relying on JPQL.
  prefs: []
  type: TYPE_NORMAL
- en: When writing code using the Criteria API, the first thing we need to do is obtain
    an instance of a class implementing the `javax.persistence.criteria.CriteriaBuilder`
    interface; as we can see in the preceding example, we need to obtain this instance
    by invoking the `getCriteriaBuilder()` method on our `EntityManager`.
  prefs: []
  type: TYPE_NORMAL
- en: From our `CriteriaBuilder` implementation, we need to obtain an instance of
    a class implementing the `javax.persistence.criteria.CriteriaQuery` interface.
    We do this by invoking the `createQuery()` method in our `CriteriaBuilder` implementation.
    Notice that `CriteriaQuery` is generically typed. The generic type argument dictates
    the type of result that our `CriteriaQuery` implementation will return upon execution.
    By taking advantage of generics in this way, the Criteria API allows us to write
    type-safe code.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained a `CriteriaQuery` implementation, from it we can obtain
    an instance of a class implementing the `javax.persistence.criteria.Root` interface.
    The root implementation dictates which JPA Entity we will be querying from. It
    is analogous to the `FROM` query in JPQL (and SQL).
  prefs: []
  type: TYPE_NORMAL
- en: 'The next two lines in our example take advantage of another new addition to
    the JPA specification: the **Metamodel API**. In order to take advantage of the
    Metamodel API, we need to obtain an implementation of the `javax.persistence.metamodel.Metamodel`
    interface by invoking the `getMetamodel()` method on our `EntityManager`.'
  prefs: []
  type: TYPE_NORMAL
- en: From our `Metamodel` implementation, we can obtain a generically typed instance
    of the `javax.persistence.metamodel.EntityType` interface. The generic type argument
    indicates the JPA entity our `EntityType` implementation corresponds to. `EntityType`
    allows us to browse the `persistent` attributes of our JPA entities at runtime.
    This is exactly what we do in the next line in our example. In our case, we get
    an instance of `SingularAttribute`, which maps to a simple, singular attribute
    in our JPA entity. `EntityType` has methods to obtain attributes that map to collections,
    sets, lists, and maps. Obtaining these attribute types is very similar to obtaining
    a `SingularAttribute`, therefore we won't be covering those directly. Please refer
    to the Java EE 8 API documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in our example, `SingularAttribute` contains two generic type
    arguments. The first argument dictates the JPA entity we are working with, and
    the second one indicates the type of the attribute. We obtain our `SingularAttribute`
    by invoking the `getDeclaredSingularAttribute()` method on our `EntityType` implementation
    and passing the attribute name (as declared in our JPA entity) as a string.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have obtained our `SingularAttribute` implementation, we need to obtain
    an import `javax.persistence.criteria.Path` implementation by invoking the `get()`
    method in our `Root` instance, and passing our `SingularAttribute` as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we will get a list of all the *new* states in the United States;
    that is, all states whose names start with `New`. This, of course, is a job for
    a "like" condition. We can do this with the criteria API by invoking the `like()`
    method on our `CriteriaBuilder` implementation. The `like()` method takes our
    `Path` implementation as its first parameter, and the value to search for as its
    second parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`CriteriaBuilder` has a number of methods that are analogous to SQL and JPQL
    clauses, such as `equals()`, `greaterThan()`, `lessThan()`, `and()`, and `or()`
    (for the complete list, refer to the Java EE 8 documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)).
    These methods can be combined to create complex queries via the Criteria API.'
  prefs: []
  type: TYPE_NORMAL
- en: The `like()` method in `CriteriaBuilder` returns an implementation of the `javax.persistence.criteria.Predicate`
    interface, which we need to pass to the `where()` method in our `CriteriaQuery`
    implementation. This method returns a new instance of `CriteriaBuilder`, which
    we assign to our `criteriaBuilder` variable.
  prefs: []
  type: TYPE_NORMAL
- en: At this point we are ready to build our query. When working with the Criteria
    API, we deal with the `javax.persistence.TypedQuery` interface, which can be thought
    of as a type-safe version of the `Query` interface we use with JPQL. We obtain
    an instance of `TypedQuery` by invoking the `createQuery()` method in `EntityManager`,
    and passing our `CriteriaQuery` implementation as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: To obtain our query results as a list, we simply invoke `getResultList()` on
    our `TypedQuery` implementation. It is worth reiterating that the Criteria API
    is type-safe, therefore attempting to assign the results of `getResultList()`
    to a list of the wrong type would result in a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Updating data with the Criteria API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the JPA Criteria API was initially added to JPA 2.0, it only supported
    selecting data from the database. Modifying existing data was not supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'JPA 2.1, introduced in Java EE 7, added support for updating database data
    via the `CriteriaUpdate` interface; the following example illustrates how to use
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: What this example is actually doing is finding all of the database rows with
    "New Yorc" (a typo) as a city, and replacing the value with the correct spelling
    of "New York".
  prefs: []
  type: TYPE_NORMAL
- en: Just like in the previous example, we obtain an instance of a class implementing
    the `CriteriaBuilder` interface by invoking the `getCriteriaBuilder()` method
    on our `EntityManager` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We then obtain an instance of a class implementing `CriteriaUpdate` by invoking
    `createCriteriaUpdate()` on our `CriteriaBuilder` instance.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to obtain an instance of a class implementing `Root` by invoking
    the `from()` method on our `CriteriaUpdate` instance.
  prefs: []
  type: TYPE_NORMAL
- en: We then invoke the `set()` method on `CriteriaUpdate` to specify the new values
    our rows will have after they have been updated; the first parameter of the `set()`
    method must be a `String` matching the property name in the `Entity` class, and
    the second parameter must be the new value.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we build the where clause by invoking the `where()` method on
    `CriteriaUpdate`, and passing the `Predicate` returned by the `equal()` method
    invoked in `CriteriaBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Then we get a `Query` implementation by invoking `createQuery()` on `EntityManager`,
    and passing our `CriteriaUpdate` instance as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we execute our query as usual by invoking `executeUpdate()` on our
    `Query` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data with the Criteria API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to adding support for data updates via the Criteria API, JPA 2.1
    added the ability to bulk-delete database rows with the new `CriteriaDelete` interface.
    The following code snippet illustrates its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To use `CriteriaDelete`, we first obtain an instance of `CriteriaBuilder` as
    usual, then invoke the `createCriteriaDelete()` method on our `CriteriaBuilder`
    instance to obtain an implementation of `CriteriaDelete`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an instance of `CriteriaDelete`, we build the where clause in the
    normal way with the Criteria API.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have built our where clause, we obtain an implementation of the `Query`
    interface and invoke `executeUpdate()` on it as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Bean Validation support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another feature introduced in JPA 2.0 is support for JSR 303 **Bean Validation**.
    Bean Validation support allows us to annotate our JPA entities with Bean Validation
    annotations. These annotations allow us to easily validate user input and perform
    data sanitation.
  prefs: []
  type: TYPE_NORMAL
- en: Taking advantage of Bean Validation is very simple; all we need to do is annotate
    our JPA Entity fields or getter methods with any of the validation annotations
    defined in the `javax.validation.constraints` package. Once our fields are annotated
    as appropriate, the `EntityManager` will prevent non-validating data from being
    persisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code example is a modified version of the `Customer` JPA entity
    we saw earlier in this chapter. It has been modified to take advantage of Bean
    Validation in some of its fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we used the `@NotNull` annotation to prevent the `firstName`
    and `lastName` of our entity from being persisted with `null` values. We also
    used the `@Size` annotation to restrict the minimum and maximum length of these
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: That is all we need to do to take advantage of Bean Validation in JPA. If our
    code attempts to persist or update an instance of our entity that does not pass
    the declared validation, an exception of type `javax.validation.ConstraintViolationException`
    will be thrown, and the entity will not be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, Bean Validation pretty much automates data validation, freeing
    us from having to manually write validation code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the two annotations discussed in the previous example, the `javax.validation.constraints`
    package contains several additional annotations we can use to automate validation
    on our JPA entities. Please refer to the Java EE 8 API documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/)
    for the complete list.
  prefs: []
  type: TYPE_NORMAL
- en: Final notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the examples for this chapter, we showed database access performed directly
    from CDI named beans serving as controllers. We did this to get the point across
    without getting mired in the details; however, in general, this is not a good
    practice. Database access code should be encapsulated in **Data Access Objects**
    (**DAOs**).
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the DAO design pattern, see [http://www.oracle.com/technetwork/java/dao-138818.html.](http://www.oracle.com/technetwork/java/dao-138818.html)
  prefs: []
  type: TYPE_NORMAL
- en: Named beans typically assume the role of controllers and/or model when using
    the **Model-View-Controller** (**MVC**) design pattern, a practice so common that
    it has become the de facto standard for Java EE applications.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the MVC design pattern, see [http://www.oracle.com/technetwork/java/mvc-140477.html.](http://www.oracle.com/technetwork/java/mvc-140477.html)
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we chose not to show any user interface code in our examples since
    it is irrelevant to the topic at hand. However, code downloads for this chapter
    include JSF pages that invoke named beans in this chapter, and display a confirmation
    page once the named bean invocation finishes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered how to access data in a database via the Java Persistence
    API (JPA).
  prefs: []
  type: TYPE_NORMAL
- en: We covered how to mark a Java class as a JPA entity by decorating it with the
    `@Entity` annotation. Additionally, we covered how to map an entity to a database
    table via the `@Table` annotation. We also covered how to map entity fields to
    database columns via the `@Column` annotation, as well as declaring an entity's
    primary key via the `@Id` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `javax.persistence.EntityManager` interface to find, persist, and
    update JPA entities was also covered.
  prefs: []
  type: TYPE_NORMAL
- en: Defining both unidirectional and bidirectional one-to-one, one-to-many, and
    many-to-many relationships between JPA entities was covered as well.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we explored how to use JPA composite primary keys by developing
    custom primary key classes.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we covered how to retrieve entities from a database by using the Java
    Persistence Query Language (JPQL).
  prefs: []
  type: TYPE_NORMAL
- en: We discussed additional JPA features such as the Criteria API, which allows
    us to build JPA queries programmatically; the Metamodel API, which allows us to
    take advantage of Java's type safety when working with JPA; and Bean Validation,
    which allows us to easily validate input by simply annotating our JPA entity fields.
  prefs: []
  type: TYPE_NORMAL
