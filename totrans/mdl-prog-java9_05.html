<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Platform APIs</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we looked at how the Java platform has been modularized, what the modules look like and how to navigate and find more information about them. In this chapter, we'll get hands-on and implement and extend functionality in the address book viewer application by using some of the platform APIs. In the process, I'll walk you through the typical process of finding and using platform APIs, as well as how to organize application modules to have better reusability and modularity.</p>
<p class="calibre2">Here are the enhancements we'll make to the address book viewer application in this chapter:</p>
<ul class="calibre14">
<li class="calibre15">We'll add logging logic to the application using the Java Logging APIs. This is not really a user-facing feature, but it's handy as a developer to be able to log informational and error messages from your application.</li>
<li class="calibre15">We'll use XML APIs to read contact information from an XML file. The application currently has a bunch of hardcoded users. We'd like to update that to read from an XML file on a path that's provided by the user.</li>
<li class="calibre15">We'll add a graphical user interface to the application by displaying a list of names. Clicking on a name in the list then displays detailed contact information of that contact. We'll be building this using the Java FX APIs.</li>
</ul>
<p class="calibre2">All of the preceding features requires the usage of Java platform APIs. By achieving the preceding three objectives, you will have had good practice in establishing dependencies on and using the Java platform modules. Note that the focus in this chapter is on using the platform APIs and not on learning about the specific APIs themselves. So, even though you don't plan to use or learn about the Java XML APIs or the Java FX APIs, I still recommend you open your editor and follow through the steps covered in this chapter hands-on. Using these specific APIs in this chapter is just a means to learning about using platform APIs in general. Once you are done working on this chapter, you'll be in a much better position to browse and use other Java Platform APIs too.</p>
<p class="calibre2">We have a lot to cover, so let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding logging ability</h1>
                
            
            <article>
                
<p class="calibre2">Let's start with using the logging API in Java to log messages to the console. As an example, we want to be able to log some sample messages during the application start and completion.</p>
<p class="calibre2">What we'd typically do in Java 8 or earlier is just import the necessary logging classes and start using the logging APIs. That is, the <kbd class="calibre12">Logger</kbd> class from the <kbd class="calibre12">java.util.logging</kbd> package. However, as we've learned in the previous chapter, there's an additional step in Java 9. Using the logging APIs directly will result in a compilation error. That's because the logging APIs aren't available in the <kbd class="calibre12">java.base</kbd> module. We've seen that the best way to search for a module is using the <kbd class="calibre12">--list-modules</kbd> parameter to the <kbd class="calibre12">java</kbd> command. Let's run that and see if we find a module related to logging:</p>
<pre class="calibre23"><strong class="calibre1">$ java --list-modules 
... 
java.jnlp@9 
java.logging@9
java.management@9
java.naming@9
java.prefs@9</strong></pre>
<p class="calibre2">As you can see, there's a module called <kbd class="calibre12">java.logging</kbd>. That looks promising! The next step is to see if that module exports the APIs we need:</p>
<pre class="calibre23"><strong class="calibre1">$ java -d java.logging 
module java.logging@9
  exports java.util.logging 
  requires mandated java.base 
  provides jdk.internal.logger.DefaultLoggerFinder with</strong><br class="title-page-name"/><strong class="calibre1">  sun.util.logging.internal.LoggingProviderImpl 
  contains sun.net.www.protocol.http.logging 
  contains sun.util.logging.internal 
  contains sun.util.logging.resources</strong> </pre>
<p class="calibre2">Good news! It does. The <kbd class="calibre12">java.logging</kbd> module exports the package <kbd class="calibre12">java.util.logging</kbd>, which is just what we need. Let's add this module as a dependency in the <kbd class="calibre12">packt.addressbook</kbd> module first:</p>
<pre class="calibre23">    module packt.addressbook { 
      requires java.logging; 
      requires packt.sortutil; 
    } </pre>
<p class="calibre2">Now, we are free to use the logging APIs in our code. In the <kbd class="calibre12">Main.java</kbd> class, first import the <kbd class="calibre12">Logger</kbd> class and create a static <kbd class="calibre12">logger</kbd> variable by initializing <kbd class="calibre12">Logger</kbd> with the class name:</p>
<pre class="calibre23">    package packt.addressbook; 
    ... 
    import java.util.logging.Logger; 
    ... 
    public class Main { 
      private static final Logger logger = 
        Logger.getLogger(Main.class.getName()); 
      ... 
    } </pre>
<p class="calibre2">Next, we can use the logger to log a message both at the start and the end of the application:</p>
<pre class="calibre23">    public static void main(String[] args) { 
      logger.info("Address book viewer application: Started"); 
      ... 
      System.out.println(contacts); 
      logger.info("Address book viewer application: Completed"); 
    } </pre>
<p class="calibre2">Compile the modules by running this command in the project root directory:</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out --module <br class="title-page-name"/>  packt.addressbook,packt.sortui</strong></pre>
<p class="calibre2">Execute with the <kbd class="calibre12">java</kbd> command and you should get output that looks like this:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out -m packt.addressbook/packt.addressbook.Main</strong><br class="title-page-name"/><strong class="calibre1">Mar 27, 2017 7:41:51 PM packt.addressbook.Main main</strong><br class="title-page-name"/><strong class="calibre1">INFO: Address book viewer application: Started</strong><br class="title-page-name"/><strong class="calibre1">[Charles Babbage, Tim Berners-Lee, Edsger Dijkstra, Ada Lovelace, Alan Turing]</strong><br class="title-page-name"/><strong class="calibre1">Mar 27, 2017 7:41:51 PM packt.addressbook.Main main</strong><br class="title-page-name"/><strong class="calibre1">INFO: Address book viewer application: Completed</strong></pre>
<p class="calibre2">With this, we've successfully integrated logging APIs into our application. This is the simplest of the three use cases we'll be looking at in this chapter. The usage of the logging platform API involved:</p>
<ul class="calibre14">
<li class="calibre15">Declaring the need for a platform module--with the <kbd class="calibre12">requires</kbd> statement</li>
<li class="calibre15">Usage of the platform module APIs in the Java source</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using an alternative compiler command</h1>
                
            
            <article>
                
<p class="calibre2">As we begin creating more modules, the compiler command will continue to grow. This is because we need to specify every module in the module path that needs compilation directly in the command.</p>
<p class="calibre2">If you are using a macOS/Unix/Linux operating systems, there's an alternative way you can get all the modules compiled, and I find this method shorter and easier. Remember in <a target="_blank" href="part0033.html#VF2I0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 2</a>, <em class="calibre22">Creating Your First Java Module</em>, we listed all the Java classes directly in the command for the compiler to compile. Now rather than entering all the classes in all the modules manually in the command, the idea is to use the Unix <kbd class="calibre12">find</kbd> command with a command line wildcard to get all the file names with the <kbd class="calibre12">.java</kbd> extension and plug them in directly.  The below command illustrates how this works:</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out $(find . -name '*.java')</strong></pre>
<p class="calibre2">The part of the command  <kbd class="calibre12">$(find . -name '*.java')</kbd> expands all the file names of the Java files (as specified by <kbd class="calibre12">-name '*.java'</kbd>) in the current folder (as specified by the  <kbd class="calibre12">.</kbd> ), including nested subfolders, in one go. Since this command is shorter and much easier on the eyes, I'll be using this version from now on. This format also has the additional advantage of being consistent. You can pretty much copy-paste this command to compile all modules in the module current directory, irrespective of how many modules you have. If you are on Windows, or if you prefer to use the <kbd class="calibre12">--module</kbd> format, make sure you specify all the individual module names following the <kbd class="calibre12">--module</kbd> option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Reading contacts from an XML file</h1>
                
            
            <article>
                
<p class="calibre2">The next improvement we'll make is to have the address book viewer application read an XML file to get contact information instead of a hard-coded list. There are a couple of nuances with this integration, so let's try that out now!</p>
<p class="calibre2">The list of contacts being displayed by the address book viewer is from hard-coded data in the <kbd class="calibre12">ContactUtil</kbd> class. Here's the sample structure of the XML file we'd like to read it from:</p>
<pre class="calibre23">    &lt;?xml version="1.0"?&gt; 
    &lt;addressbook&gt; 
      &lt;contact&gt; 
        &lt;firstname&gt;Edsger&lt;/firstname&gt; 
        &lt;lastname&gt;Dijkstra&lt;/lastname&gt; 
        &lt;address&gt; 
          &lt;street&gt;5612&lt;/street&gt; 
          &lt;city&gt;AZ&lt;/city&gt; 
          &lt;state&gt;Eindhoven&lt;/state&gt; 
          &lt;country&gt;Netherlands&lt;/country&gt; 
        &lt;/address&gt; 
        &lt;phone&gt;345-678-9012&lt;/phone&gt; 
      &lt;/contact&gt; 
      &lt;contact&gt; 
          ... 
      &lt;/contact&gt; 
      ... 
    &lt;/addressbook&gt; </pre>
<p class="calibre2">The root node is <kbd class="calibre12">addressbook</kbd> and within it are several <kbd class="calibre12">contact</kbd> child nodes. Each <kbd class="calibre12">contact</kbd> node has <kbd class="calibre12">firstname</kbd>, <kbd class="calibre12">lastname</kbd>, and a nested <kbd class="calibre12">address</kbd> node, as shown.</p>
<p class="calibre2">In order to have the application read from an XML file, what we'd like to do is the following:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Remove the existing hardcoded logic from the module
<div class="title-page-name"><kbd class="calibre12">packt.addressbook</kbd>.</div>
</li>
<li value="2" class="calibre15">Implement functionality of opening and reading the XML file in a separate module. This module will contain code to read from the source XML file and return a list of contacts.</li>
<li value="3" class="calibre15">Update the <em class="calibre22">main</em> address book module to depend on this new module to get the list of contacts.</li>
</ol>
<p class="calibre2">The fact that we need to do #1 is obvious. But why #2 and #3? Why move that portion of the code to its own module? Well, as you can imagine, there's no <em class="calibre22">right</em> answer for this one.</p>
<p class="calibre2">The goal of modularization is to achieve the separation of monolithic code into modular building blocks that can be freely reused and replaced. Consider the scenario where, in the future, you decide to <em class="calibre22">not</em> use an XML file to store the data, but instead, read from a JSON file. Or a database. Or even a REST API! No matter what the new source is, the fact that there is this one separate module that acts as a <em class="calibre22">provider</em> of the list of contacts makes the change relatively easy. All you have to do then is to remove the XML-based module we'll create now and plug in a new module that reads from the new source of data. Granted, you'll still need to change the consumers to depend on the new module. But the change will be minimized, and so will the scope of any side effects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Removing the hard-coded contact list</h1>
                
            
            <article>
                
<p class="calibre2">Let's begin by removing the hard-coded source of contacts. This is fairly simple. You'll need to delete the <kbd class="calibre12">ContactUtil.java</kbd> class in the package <kbd class="calibre12">packt.addressbook.util</kbd>. We are now left with a couple of lines of code in <kbd class="calibre12">Main.java</kbd> that are not valid anymore. Let's remove those two lines too:</p>
<pre class="calibre23">    ContactUtil contactUtil = new ContactUtil(); 
    List&lt;Contact&gt; contacts = contactUtil.getContacts(); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the module</h1>
                
            
            <article>
                
<p class="calibre2">Now let's create a new module that holds code that acts as a source of contact information. I'll call the module <kbd class="calibre12">packt.contact</kbd>. You should know the drill by now. Create a new module root folder with the name <kbd class="calibre12">packt.contact</kbd> in the <kbd class="calibre12">src</kbd> folder, just where the other module root folders reside. Next, create a <kbd class="calibre12">module-info.java</kbd> module descriptor in the module root folder.</p>
<p class="calibre2">What modules do we need here? Since this module needs the XML APIs, we'll have to declare it with the <kbd class="calibre12">requires</kbd> statement. We saw in the previous chapter that there's a module called <kbd class="calibre12">java.xml</kbd> that contains the XML APIs. Of course, a way of searching for the right module is using the <kbd class="calibre12">java --list-modules</kbd> command as before. here's the module descriptor with this dependency added.</p>
<pre class="calibre23">    module packt.contact { 
      requires java.xml; 
    } </pre>
<p class="calibre2">The source code in this module belongs to two classes. First is the class <kbd class="calibre12">ContactLoader</kbd> in the package <kbd class="calibre12">packt.contact.util</kbd>. This class contains the method <kbd class="calibre12">loadContacts</kbd> that takes in the filename of the XML file to read and it returns the list of <kbd class="calibre12">Contact</kbd> objects. This is the method that consumers of this module will call:</p>
<pre class="calibre23">    package packt.contact.util; 
    public class ContactLoader { 
      public List&lt;Contact&gt; loadContacts(String fileName) { 
        ... 
      } </pre>
<p class="calibre2">Note that the name of the method is the generic <kbd class="calibre12">loadContacts</kbd>, and contains no particular indication that what it's loading from is an XML file. This is again useful to achieve the abstraction, and the module could very well change its functionality in the future to read contacts from another source or file format.</p>
<p class="calibre2">The second class <kbd class="calibre12">XMLUtil</kbd> consists of some generic but handy XML utility methods. These are methods that the <kbd class="calibre12">ContactLoader</kbd> class will use to read and parse XML. Since this aspect of dealing with XML is not the <em class="calibre22">purpose</em> of this module, this class will be in a separate <kbd class="calibre12">packt.contact.internal</kbd> package so that it can be protected against use outside the module:</p>
<pre class="calibre23">    package packt.contact.internal; 
    public class XmlUtil { 
      ... 
    } </pre>
<p class="calibre2">Here's the file and folder structure of the module at this time:</p>
<div class="packt_figure"><img class="image-border43" src="../images/00049.jpeg"/><br class="title-page-name"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Coding the XmlUtil class</h1>
                
            
            <article>
                
<p class="calibre2">Let's now add the first of two methods to the  <kbd class="calibre12">XmlUtil</kbd>--a <kbd class="calibre12">loadXmlFile()</kbd> method that takes in an XML filename as a <kbd class="calibre12">String</kbd>, parses it, and returns an XML document object.</p>
<p class="calibre2">The code involves opening the file to get a <kbd class="calibre12">File</kbd> object. Then, using the DOM XML API, we create a <kbd class="calibre12">DocumentBuilderFactory</kbd>. With that, we create a new <kbd class="calibre12">DocumentBuilder</kbd>. And with that, we parse the input file.</p>
<p class="calibre2">The following is the method in its entirety:</p>
<pre class="calibre23">    public Document loadXmlFile(String fileName) throws<br class="title-page-name"/>     ParserConfigurationException, SAXException, IOException { 
       File inputFile = new File(fileName); 
       DocumentBuilderFactory dbFactory =<br class="title-page-name"/>         DocumentBuilderFactory.newInstance(); 
       DocumentBuilder dBuilder = dbFactory.newDocumentBuilder(); 
       Document doc = dBuilder.parse(inputFile); 
       doc.getDocumentElement().normalize(); 
       return doc; 
    } </pre>
<p class="calibre2">Note the exceptions that the method throws. The three exceptions are a result of using the File API to open the file and the XML API to parse it. Rather than have the method catch the exception, which it wouldn't really know what to do with, it throws them. These exceptions have an interesting implication to modularity that we'll look at shortly.</p>
<p class="calibre2">The second method is <kbd class="calibre12">getElement()</kbd>, which takes in an XML node and the element name to return the value of that element in the node. If no value is found, an empty string is returned. This is all XML API specific and not too interesting for us in the context of this chapter, so here's the method in its entirety:</p>
<pre class="calibre23">    public String getElement(Node nNode, String tagName) { 
      if (nNode.getNodeType() == Node.ELEMENT_NODE) { 
        Element eElement = (Element) nNode; 
        return eElement.getElementsByTagName(tagName)<br class="title-page-name"/>         .item(0).getTextContent(); 
      } 
      return ""; 
    } </pre>
<p class="calibre2">With this, we are done with <kbd class="calibre12">XmlUtil</kbd>. We'll now move on to the more interesting <kbd class="calibre12">ContactLoader</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Coding the ContactLoader class</h1>
                
            
            <article>
                
<p class="calibre2">We've already seen that <kbd class="calibre12">ContactLoader</kbd> should have a single method <kbd class="calibre12">loadContacts()</kbd> , which takes as argument the file name and returns a list of <kbd class="calibre12">Contacts</kbd>:</p>
<pre class="calibre23">    public List&lt;Contact&gt; loadContacts(String fileName) {<br class="title-page-name"/>    <br class="title-page-name"/>    }</pre>
<p class="calibre2">In the method, we initialize a new instance of <kbd class="calibre12">XmlUtil</kbd> and use the <kbd class="calibre12">loadXmlFile</kbd> method to get the XML Document object:</p>
<pre class="calibre23">    XmlUtil xmlUtil = new XmlUtil();<br class="title-page-name"/>    Document doc = xmlUtil.loadXmlFile(fileName);</pre>
<p class="calibre2">Now what's left is processing the resulting DOM object structure and constructing the list of contacts in the model type we need. Again, to avoid getting into too much detail about XML, I'll just point you to the bundled source code at <kbd class="calibre12">05-jdk-modules/src/packt.contact</kbd>.</p>
<p class="calibre2">There are a couple of problems with the <kbd class="calibre12">packt.contact</kbd> module right now--shared classes and dependency leakage. One of which you might have already noticed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Shared classes</h1>
                
            
            <article>
                
<p class="calibre2">This is the more obvious of the two problems. We've created a new module and designed a method in a class to return a list of <kbd class="calibre12">Contact</kbd> instances. The problem is that the <kbd class="calibre12">Contact</kbd> and <kbd class="calibre12">Address</kbd> model classes are not in the module! They are in the <kbd class="calibre12">packt.addressbook</kbd> module. Compiling this module now will result in a compilation error about the two classes not found. How do we solve this?</p>
<p class="calibre2">Here's a thought. How about depending on the module that contains the classes? The <kbd class="calibre12">packt.contact</kbd> module needs the <kbd class="calibre12">Contact</kbd> and <kbd class="calibre12">Address</kbd> classes that are available in the <kbd class="calibre12">packt.addressbook</kbd> module. Could we have the <kbd class="calibre12">packt.contact</kbd> module require the <kbd class="calibre12">packt.addressbook</kbd> module? We'll of course also need the dependency the other way round. <kbd class="calibre12">packt.addressbook</kbd> needs to <kbd class="calibre12">requires packt.contact</kbd> to get the list of contacts. Can this be done? Turns out it cannot, because it introduces circular dependencies, which are not allowed by the Java module system.</p>
<div class="packt_infobox">A <strong class="calibre26">circular dependency</strong> is when two or more modules depend on each other in such a way that the dependency graph forms a loop. Both of the examples in the following diagram represent circular dependencies.</div>
<p class="calibre2">The following diagram shows two circular dependency scenarios. Modules <strong class="calibre1">A</strong> and <strong class="calibre1">B</strong> depend on each other, forming a circular dependency. In the second example, to the right, module <strong class="calibre1">Z</strong> reads <strong class="calibre1">X</strong>, <strong class="calibre1">X</strong> reads <strong class="calibre1">Y</strong>, and <strong class="calibre1">Y</strong>, in turn, reads <strong class="calibre1">Z</strong>. This is also a circular dependency, now between three modules. If the Java platform encounters circular dependencies like these, it'll throw an error and fail to work:</p>
<div class="packt_figure"><img class="image-border44" src="../images/00050.jpeg"/></div>
<p class="calibre2">Circular dependencies are disallowed by the Java module system because it invalidates the concept of modules having <strong class="calibre1">directed</strong> dependencies. Think back to the module graph we've been drawing. There is a sense in which dependencies have <strong class="calibre1">direction</strong> and when one module depends on another, there's a directed arrow drawn from the former to the latter. Having circular dependencies, or as they are often called, <strong class="calibre1">cyclic</strong> dependencies implies that the two modules are so closely tied to each other, that the idea of splitting them into two separate modules becomes moot. If one module cannot exist without the other, what's the point in having them as separate modules anyway?</p>
<p class="calibre2">It is important to have the module graph as a <strong class="calibre1">directed acyclic graph</strong>. This is a type of graph, which as the name says, is <strong class="calibre1">directed</strong>, as in you can arrange all the nodes in such a way that there is a top-down direction of all dependencies, and it is <strong class="calibre1">acyclic,</strong> as in there are no loops.</p>
<p class="calibre2">Since we cannot implement circular dependencies, we are left with two options to solve this problem. First option--move the model classes from <kbd class="calibre12">packt.addressbook</kbd> to <kbd class="calibre12">packt.contact</kbd> and have <kbd class="calibre12">packt.contact</kbd> export them. This way, since <kbd class="calibre12">packt.addressbook</kbd> requires <kbd class="calibre12">packt.contact</kbd> anyway, it gets to use the model classes too.</p>
<p class="calibre2">The second option is to create a separate module for the model classes and have both <kbd class="calibre12">packt.addressbook</kbd> and <kbd class="calibre12">packt.contact</kbd> require them. This also allows for other modules to possibly use the model classes. For the sake of simplicity, I'll go with the first approach and move the model classes into <kbd class="calibre12">packt.contact</kbd> for now. In a similar real-world use case, you may want to consider the anticipated usage of such shared classes to decide whether they warrant a separate module.</p>
<p class="calibre2">With the model classes in the <kbd class="calibre12">packt.contact</kbd> module, here's how the module looks:</p>
<div class="packt_figure"><img class="image-border45" src="../images/00051.jpeg"/></div>
<p class="calibre2">The <kbd class="calibre12">module-info.java</kbd> needs to be updated to <kbd class="calibre12">export</kbd> the util and model packages:</p>
<pre class="calibre23">    module packt.contact { 
      requires java.xml; 
      exports packt.contact.model; 
      exports packt.contact.util; 
    } </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency leakage</h1>
                
            
            <article>
                
<p class="calibre2">Here's the second problem with the way we've built the <kbd class="calibre12">packt.contact</kbd> module, and this one may not be all that obvious. Here's the method signature of the method in <kbd class="calibre12">ContactLoader</kbd> that we want consumers of this module to call:</p>
<pre class="calibre23">    public List&lt;Contact&gt; loadContacts(String fileName)  
     throws ParserConfigurationException, SAXException, IOException</pre>
<p class="calibre2">What does a consumer of this module need to do to access this method? First, the consuming module needs to <kbd class="calibre12">require packt.contact</kbd>. With that, they have access to <kbd class="calibre12">ContactLoader</kbd> in their module. They can then call the <kbd class="calibre12">loadContacts</kbd> method in one of their classes. But wait! Since the <kbd class="calibre12">loadContacts()</kbd> throws three exceptions, the consuming method will need to catch them too!</p>
<pre class="calibre23">    try { 
      contacts = contactLoader.loadContacts("input.xml"); 
    } catch (ParserConfigurationException | SAXException |<br class="title-page-name"/>       IOException e) { 
         // Handle error here 
    } </pre>
<p class="calibre2">And herein lies the problem. The code from the consuming module is forced to use XML exception classes in order to catch them. <kbd class="calibre12">IOException</kbd> is from <kbd class="calibre12">java.lang</kbd>, so all modules get it because of the implicit <kbd class="calibre12">java.base</kbd> dependency. But the consuming modules don't automatically have access to <kbd class="calibre12">ParserConfigurationException</kbd> or <kbd class="calibre12">SAXException</kbd> , since they are classes from the <kbd class="calibre12">java.xml</kbd> module. The only way <kbd class="calibre12">loadContacts()</kbd> can be used by other modules is if they also <kbd class="calibre12">require java.xml</kbd> overtime they use <kbd class="calibre12">packt.contact</kbd>. Even if they are not using any XML APIs themselves. So much for encapsulating XML functionality!</p>
<p class="calibre2">While this is a workable solution, we don't want to build modules that enforce dependencies like this. Ideally, a module should be self-sufficient, and shouldn't necessitate other peer dependencies just to make it usable. There are a couple of ways to solve this problem. One way is to establish what's called a <em class="calibre22">transitive</em> dependency in the <kbd class="calibre12">packt.contact</kbd> module. Transitive dependency is a way in which the module system allows you to configure modules to declare automatic peer dependencies. For example, you can have a dependency on <kbd class="calibre12">packt.contact</kbd> also establish a dependency on <kbd class="calibre12">java.xml</kbd> automatically, so that any module that has a dependency on the former also gets the latter. We'll learn more about transitive dependencies in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 6</a>, <em class="calibre22">Module Resolution, Accessibility, and Readability</em>.</p>
<p class="calibre2">However, in this case, that's not ideal either. We want to tuck away anything XML-related into <kbd class="calibre12">packt.contact</kbd> and not have any XML classes leak into the consuming module. So, in this case, we'll create a custom exception and throw that when anything goes wrong. We'll make sure the exception is in an exported package, so that the consuming module gets the exception automatically.</p>
<p class="calibre2">We'll call the class <kbd class="calibre12">ContactLoadException</kbd> and place it in the <kbd class="calibre12">packt.contact.util</kbd> package:</p>
<pre class="calibre23">    package packt.contact.util; 
    public class ContactLoadException extends Exception { 
      ... 
      public ContactLoadException() { 
        super(); 
      } 
      public ContactLoadException(String message) { 
        super(message); 
        // TODO Auto-generated constructor stub 
      } 
    } </pre>
<p class="calibre2">Now <kbd class="calibre12">ContactLoader</kbd> needs to catch the XML exceptions and throw the custom exception instead:</p>
<pre class="calibre23">    public List&lt;Contact&gt; loadContacts(String fileName) throws<br class="title-page-name"/>     ContactLoadException { 
       ... 
       Document doc; 
       try { 
         doc = xmlUtil.loadXmlFile(fileName); 
       } catch (ParserConfigurationException | SAXException |<br class="title-page-name"/>          IOException e) { 
            throw new ContactLoadException("Unable to load <br class="title-page-name"/>            Contact file"); 
       } </pre>
<p class="calibre2">Great! Now we've completely isolated the XML-related functionality into <kbd class="calibre12">packt.contact</kbd> and none of the modules that uses it needs to deal with the XML APIs.</p>
<p class="calibre2">With this, we are done with the <kbd class="calibre12">packt.contact</kbd> module. We can now move on to <kbd class="calibre12">packt.addressbook</kbd> and use this module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Consuming the new module</h1>
                
            
            <article>
                
<p class="calibre2">First, we establish a dependency in <kbd class="calibre12">packt.addressbook</kbd>. Here's the <kbd class="calibre12">module-info.java</kbd> file:</p>
<pre class="calibre23">    module packt.addressbook { 
      requires java.logging; 
      requires packt.sortutil; 
      requires packt.contact; 
    } </pre>
<p class="calibre2">Then, in <kbd class="calibre12">Main.java</kbd>, we create a new instance of <kbd class="calibre12">ContactLoader</kbd> and call the <kbd class="calibre12">loadContacts</kbd> method by passing in the path to the XML file. Using the <kbd class="calibre12">input.xml</kbd> file that is bundled with the source code, here's what it takes to read the file and return <kbd class="calibre12">Contact</kbd> instances:</p>
<pre class="calibre23">    try { 
          contacts = contactLoader.loadContacts(<br class="title-page-name"/>            "/Users/koushik/code/java9/input.xml"); 
        } catch (ContactLoadException e) { 
            logger.severe(e.getMessage()); 
            System.exit(0); 
        } </pre>
<p class="calibre2">The <kbd class="calibre12">catch</kbd> block uses the <kbd class="calibre12">logger</kbd> instance previously created to log the exception message and exit the application.</p>
<p class="calibre2">Here's the complete <kbd class="calibre12">Main</kbd> method with these changes:</p>
<pre class="calibre23">    public class Main { 
 
      private static final Logger logger = 
        Logger.getLogger(Main.class.getName()); 
 
      public static void main(String[] args) { 
 
        logger.info("Address book viewer application: Started"); 
        List&lt;Contact&gt; contacts = new ArrayList&lt;&gt;(); 
        ContactLoader contactLoader = new ContactLoader(); 
        SortUtil sortUtil = new SortUtil(); 
        try { 
          contacts = contactLoader.loadContacts(<br class="title-page-name"/>            "/Users/koushik/code/java9/input.xml"); 
        } catch (ContactLoadException e) { 
            logger.severe(e.getMessage()); 
            System.exit(0); 
        } 
 
        sortUtil.sortList(contacts); 
        System.out.println(contacts); 
        logger.info("Address book viewer application: Completed"); 
      } 
    } </pre>
<p class="calibre2">Compiling and executing the application now will result in an output as follows:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out -m packt.addressbook/packt.addressbook.Main<br class="title-page-name"/>Mar 28, 2017 3:25:41 PM packt.addressbook.Main main 
INFO: Address book viewer application: Started 
[Charles Babbage, Tim Berners-Lee, Edsger Dijkstra, Ada Lovelace, Alan Turing]
Mar 28, 2017 3:25:41 PM packt.addressbook.Main main 
INFO: Address book viewer application: Completed</strong> </pre>
<p class="calibre2">Nice work! In the process of adding XML functionality into the address book viewer application, you've handled a couple of issues and design considerations when dealing with modules. Let's move on to the third objective in this chapter--integrating with the Java FX APIs to create a UI for our address book viewer application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Adding UI with Java FX</h1>
                
            
            <article>
                
<p class="calibre2">Let's now create a UI application that allows us to click and browse contact information. We will be using the Java FX APIs to create and display the UI. As in the last section, I should highlight that the focus here is not for us to learn the JavaFX API itself. In fact, I'll be glossing over most of the Java FX API details in this section because that's beyond the scope of this book, although the full working code is available for you to peruse if you are interested. The intention of this exercise is for us to learn how to use Java APIs and how to handle the different usage scenarios and nuances that come with it.</p>
<p class="calibre2">Here's what we'll do to add UI to the address book application:</p>
<ol class="calibre17">
<li value="1" class="calibre15">Create a new module called <kbd class="calibre12">packt.addressbook.ui</kbd> which contains code to display the address book in a Java FX powered user interface.</li>
<li value="2" class="calibre15">Have the <kbd class="calibre12">packt.addressbook.ui</kbd> module depend on <kbd class="calibre12">packt.contacts</kbd> to get the list of <kbd class="calibre12">Contact</kbd> instances. Also have the module depend on <kbd class="calibre12">packt.sortutil</kbd> to sort the <kbd class="calibre12">Contact</kbd> instances by last name.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating the module</h1>
                
            
            <article>
                
<p class="calibre2">Let's start by creating the new module <kbd class="calibre12">packt.addressbook.ui</kbd>. As before, create the module root folder with the same name in the project folder, and then create the module descriptor <kbd class="calibre12">module-info.java</kbd>. We already know that we need to depend on <kbd class="calibre12">packt.contacts</kbd> and <kbd class="calibre12">packt.sortutil</kbd>, so let's add those two dependencies first:</p>
<pre class="calibre23">    module packt.addressbook.ui { 
      requires packt.sortutil; 
      requires packt.contact; 
    } </pre>
<p class="calibre2">We need to use the JavaFX libraries in this module, so we need to use the <kbd class="calibre12">requires</kbd> clause in the module descriptor to specify this dependency. How do we know what the libraries are? The answer is the same as earlier--using <kbd class="calibre12">java --list-modules</kbd> and <kbd class="calibre12">java -d &lt;module-name&gt;</kbd>. But before we browse for what modules to depend on, we should know what APIs we need! Let's look at the code we'll need to write to build the UI.</p>
<p class="calibre2">We'll create a Main.java class in the package <kbd class="calibre12">packt.addressbook.ui</kbd>. This class will launch the UI. As with any Java FX app, the class that <em class="calibre22">launches</em> the application is required to extend <kbd class="calibre12">javafx.application.Application</kbd>. We then override the <kbd class="calibre12">start</kbd> method and add the functionality of building the UI in it. This method is called by the JavaFX framework to launch our application. Remember this method! We will revisit this shortly when we execute the code:</p>
<pre class="calibre23">    public class Main extends Application { 
 
      public static void main(String[] args) { 
        launch(args); 
      } 
 
      @Override 
      public void start(Stage primaryStage) throws Exception { 
        // Build JavaFX UI and application functionality 
      } 
    } </pre>
<p class="calibre2">In the <kbd class="calibre12">start</kbd> method, the logic to get the <kbd class="calibre12">Contact</kbd> instances and to sort them is exactly the same as the command-line application in the <kbd class="calibre12">packt.addressbook</kbd> module:</p>
<pre class="calibre23">    ContactLoader contactLoader = new ContactLoader(); 
    SortUtil sortUtil = new SortUtil(); 
    try { 
          contacts = contactLoader.loadContacts(<br class="title-page-name"/>            "/Users/koushik/code/java9/input.xml"); 
        } catch (ContactLoadException e) { 
            logger.severe(e.getMessage()); 
            System.exit(0); 
        } 
 
        sortUtil.sortList(contacts); </pre>
<p class="calibre2">What's different in this case is what we do with the sorted list of <kbd class="calibre12">Contacts</kbd>. We don't just print it to the console. Instead, we will build a JavaFX <kbd class="calibre12">ListView</kbd> that displays the list. We'll also add a click handler to each element in the list, so that when a name is clicked, we can display the details of that contact to the right of the list. Here's what we'd like the UI to look like:</p>
<div class="packt_figure"><img class="image-border46" src="../images/00052.jpeg"/></div>
<p class="calibre2">Without going into too much detail of how the JavaFX controls are built and displayed, here's the core functionality that builds the list of <kbd class="calibre12">Contacts</kbd> from the list that <kbd class="calibre12">sortutil</kbd> has sorted, and handles click events on the list item:</p>
<pre class="calibre23">    // Create a new JavaFX ListView 
    ListView&lt;String&gt; list = new ListView&lt;String&gt;(); 
    // Collect a String list of Contact names in lastName,<br class="title-page-name"/>    firstName format 
    List&lt;String&gt; listContactNames = contacts.stream()<br class="title-page-name"/>          .map(c -&gt; c.getLastName() + ", " + c.getFirstName()) 
          .collect(Collectors.toList()); 
    // Build an ObservableList from the list of names 
    ObservableList&lt;String&gt; obsContactNames =<br class="title-page-name"/>         FXCollections.observableList(listContactNames); 
    // Pass that to ListView to have them displayed in a list 
    list.setItems(obsContactNames); 
    // Add listener to handle click events 
    list.getSelectionModel()<br class="title-page-name"/>          .selectedItemProperty()<br class="title-page-name"/>         .addListener((obs, oldVal, newVal) -&gt; { 
             // Get the selected index in the ListView 
             int selectedIndex = <br class="title-page-name"/>               list.getSelectionModel().getSelectedIndex(); 
             name.setText(newVal); 
             // Get the Contact instance which was clicked 
             Contact contact = finalContactList.get(selectedIndex); 
             // Set the values to each of the labels on the right 
             street.setText(contact.getAddress().getStreet()); 
             ...    </pre>
<p class="calibre2">The preceding code wires in the logic we are already familiar with (the <kbd class="calibre12">ContactLoader</kbd> and <kbd class="calibre12">SortUtil</kbd>) into the JavaFX code that displays that data in a UI for browsing. We have used quite a lot of JavaFX APIs here, as we normally would when building a JavaFX application like this. Now that we know what the APIs we need to use are, we next need to find the modules that <kbd class="calibre12">exports</kbd> these APIs and set up dependencies in the <kbd class="calibre12">packt.addressbook.ui</kbd> module.</p>
<p class="calibre2">Using the <kbd class="calibre12">java --list-modules</kbd> command, we see there are multiple modules associated with JavaFX. Those are the ones that start with the <kbd class="calibre12">javafx.</kbd> prefix:</p>
<pre class="calibre23"><strong class="calibre1">$ java --list-modules 
... 
javafx.base@9
javafx.controls@9
javafx.deploy@9
javafx.fxml@9
javafx.graphics@9
javafx.media@9
javafx.swing@9
javafx.web@9
...</strong> </pre>
<p class="calibre2">To know the packages we use, all we need to do is look at the list of imports in the <kbd class="calibre12">Main.java</kbd> class. We can examine the package level information for each of the JavaFX modules to get the set of modules that together have all the packages we need.</p>
<p class="calibre2">For example, <kbd class="calibre12">javafx.base</kbd> exports <kbd class="calibre12">javafx.collections</kbd> that we use in <kbd class="calibre12">Main.java</kbd>. So, that's a module we'll be adding. Here are more modules we are interested in. The left column shows the package we need, and used in our Java code. The right column is the Java platform module that exports that package (which we find by running <kbd class="calibre12">java -d &lt;module-name&gt;</kbd>):</p>
<pre class="calibre23"><strong class="calibre1">Package                  Module <br class="title-page-name"/>------------------------------------------
javafx.collections       javafx.base 
javafx.scene.control     javafx.controls 
javafx.application       javafx.graphics 
javafx.scene.layout      javafx.graphics 
javafx.geometry          javafx.graphics </strong></pre>
<p class="calibre2">Based on this, the three modules we'll need to require are <kbd class="calibre12">javafx.base</kbd>, <kbd class="calibre12">javafx.controls</kbd>, and <kbd class="calibre12">javafx.graphics</kbd>. Let's add these three into the <kbd class="calibre12">packt.addressbook.ui</kbd> module definition using the <kbd class="calibre12">requires</kbd> clause. Here's <kbd class="calibre12">module-info.java</kbd> when we are done:</p>
<pre class="calibre23">    module packt.addressbook.ui { 
      requires java.logging; 
      requires javafx.base; 
      requires javafx.controls; 
      requires javafx.graphics; 
      requires packt.sortutil; 
      requires packt.contact; 
    } </pre>
<p class="calibre2">While we've found the packages exported by the modules and we are technically not wrong in what we've required, this step could be done in a much better way. We actually needed to require just one JavaFX module here! This is thanks to a certain qualifier called <kbd class="calibre12">transitive</kbd>. We will be covering more about what that is and how it affects our dependencies in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 6</a>, <em class="calibre22">Module Resolution, Accessibility, and Readability</em>. But, since we haven't covered it yet, let's go with adding all three JavaFX modules for now.</p>
<div class="packt_infobox">If you feel like the process of finding these dependencies by running the
<div class="calibre25"><kbd class="calibre28">--list-modules</kbd> <span class="packt_screen">command is tedious, well, you are not alone! This is something that I hope will quickly be unnecessary once IDEs get support for Java 9. Ideally, an IDE should be able to help us identify the modules based on the packages we import into our Java applications, and preferably add the modules to the module descriptor automatically. This feature might already be available in most of the standard IDEs by the time you are reading this!</span></div>
</div>
<p class="calibre2">OK, so with this, we have all the dependencies established. Let's give this a go! Compile all modules using the  <kbd class="calibre12">javac</kbd> command:</p>
<pre class="calibre23"><strong class="calibre1">$ javac --module-source-path src -d out $(find . -name '*.java')</strong></pre>
<p class="calibre2">The code should compile without any errors. Let's try to execute it. Since we are running the Main.java file in the new module <kbd class="calibre12">packt.addressbook.ui</kbd>, make sure you specify that in the command this time. Notice that we get an error when we run the code:</p>
<pre class="calibre23"><strong class="calibre1">$ java --module-path out -m </strong><strong class="calibre1">packt.addressbook.ui/packt.addressbook.ui.Main</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">Exception in Application constructor</strong><br class="title-page-name"/><strong class="calibre1">Exception in thread "main" </strong><strong class="calibre1">java.lang.reflect.InvocationTargetException</strong><br class="title-page-name"/><strong class="calibre1">...</strong><br class="title-page-name"/><strong class="calibre1">Caused by: java.lang.IllegalAccessException: class com.sun.javafx.application.LauncherImpl (in module javafx.graphics) cannot access class packt.addressbook.ui.Main (in module packt.addressbook.ui) because module packt.addressbook.ui does not export packt.addressbook.ui to module javafx.graphics </strong><br class="title-page-name"/><strong class="calibre1">...</strong></pre>
<p class="calibre2">The error indicates that the module <kbd class="calibre12">javafx.graphics</kbd> is trying to access our <kbd class="calibre12">Main</kbd> class and is unable to access it because our module <kbd class="calibre12">packt.addressbook.ui</kbd> doesn't export it! You might be wondering what business the module <kbd class="calibre12">javafx.graphics</kbd> has with a class we wrote! Why would it need to access our class?</p>
<p class="calibre2">Turns out the answer is because of the way JavaFX works. Remember that I mentioned about the <kbd class="calibre12">start()</kbd> method in <kbd class="calibre12">Main.java</kbd> and how the JavaFX framework calls that method to launch the application. The framework uses reflection to identify classes that extend the <kbd class="calibre12">Application</kbd> class. The framework then uses that information to launch the JavaFX application by calling the <kbd class="calibre12">start()</kbd> method.</p>
<p class="calibre2">And there is our problem. In the module descriptor of <kbd class="calibre12">packt.addressbook.ui</kbd>, we don't export the package that <kbd class="calibre12">Main</kbd> is in, that is <kbd class="calibre12">packt.addressbook.ui</kbd>. So, <kbd class="calibre12">Main</kbd> is not accessible to any code outside the module, and so JavaFX cannot launch the application! The encapsulation that applied to static access of types outside the module is in effect even for runtime reflective access!</p>
<p class="calibre2">One way to solve this problem is by making <kbd class="calibre12">Main</kbd> public. We just need to export the package that the type is in. That's enough for JavaFX to access it. That also actually enables <em class="calibre22">any</em> module to access it! This may or may not be what you want. But for now, let's export the package and make <kbd class="calibre12">Main.java</kbd> available externally. We'll revisit this too in <a target="_blank" href="part0095.html#2QJ5E0-ed2405f4162b4f86b565edd6b6d679fb" class="calibre4">Chapter 6</a>, <em class="calibre22">Module Resolution, Accessibility, and Readability,</em> and find a better way to do this.</p>
<p class="calibre2">Here's the final <kbd class="calibre12">module-info.java</kbd>:</p>
<pre class="calibre23">    module packt.addressbook.ui { 
      exports packt.addressbook.ui;  
      requires java.logging; 
      requires javafx.base; 
      requires javafx.controls; 
      requires javafx.graphics; 
      requires packt.sortutil; 
      requires packt.contact; 
    } </pre>
<p class="calibre2">Compile and run the application again, and everything should work this time around. A GUI window should load with the list of contacts sorted by last name. Clicking on a name should display the details on the right-hand side. You can close the application by clicking the close button on the title bar.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">We've made several enhancements to the address book application to make use of some platform APIs and learnt some lessons on how to find and use platform modules, as well as how to handle some tricky scenarios that showed up along the way. Here's what we have done so far:</p>
<ul class="calibre14">
<li class="calibre15">We used the <kbd class="calibre12">java.logging</kbd> module to add logging functionality to the <kbd class="calibre12">packt.addressbook</kbd> module.</li>
<li class="calibre15">We used the <kbd class="calibre12">java.xml</kbd> module and created a new custom module that reads and parses an XML file to return a list of model objects.</li>
<li class="calibre15">We encountered two problems--shared code and dependency leakage and we implemented a strategy to get around those problems.</li>
<li class="calibre15">We used the JavaFX modules to build a UI for the address book. We created a new module that leveraged our existing contact and sort modules to build this UI. We learnt about the impact of modularity on reflection. We got around the problem by just exporting the class that needed access by the framework, although we'll be learning a better way to do this in the next chapter.</li>
</ul>
<p class="calibre2">One additional point that I want to highlight is how, in this chapter, we were able to leverage the modules that we'd already built to create a new custom GUI module. Notice that we didn't have to mess around with existing code and pile up logic and functionality on them with if clauses. We were easily able to create a new module for GUI, and thanks to the other core functionality being separate modules, we were just able to use them as building blocks to create a brand new module with all the functionality we needed. The <kbd class="calibre12">packt.contact</kbd> and <kbd class="calibre12">packt.sortutil</kbd> aren't aware of where they are being used, so they technically don't care!</p>
<p class="calibre2">In the next chapter, we'll look at a few more tricks that the Java module system has up its sleeve! We'll also deep-dive into concepts related to readability and gain an understanding of more powerful ways to make different modules accessible to one another.</p>


            </article>

            
        </section>
    </body></html>