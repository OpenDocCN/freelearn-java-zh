["```java\npublic static String fetchTester(int id) \n      throws IOException, InterruptedException {\n  HttpClient client = HttpClient.newHttpClient();\n  HttpRequest requestGet = HttpRequest.newBuilder()\n    .GET()\n    .uri(URI.create(\"https://reqres.in/api/users/\" + id))\n    .build();\n  HttpResponse<String> responseGet = client.send(\n    requestGet, HttpResponse.BodyHandlers.ofString());\n  if (responseGet.statusCode() == 200) {\n    return responseGet.body();\n  }\n  throw new UserNotFoundException(\"Code: \" \n    + responseGet.statusCode());\n} \n```", "```java\nprivate static final ExecutorService executor \n  = Executors.newFixedThreadPool(2);\npublic static TestingTeam buildTestingTeam() \n    throws InterruptedException {\n  ... \n```", "```java\n Future<String> future1 = futureTester(1);\n  Future<String> future2 = futureTester(2);\n  Future<String> future3 = futureTester(3);\n  try {\n    ... \n```", "```java\n String tester1 = future1.get();\n    String tester2 = future2.get();\n    String tester3 = future3.get();\n    logger.info(tester1);\n    logger.info(tester2);\n    logger.info(tester3);\n    return new TestingTeam(tester1, tester2, tester3);\n  } catch (ExecutionException ex) {\n    ... \n```", "```java\n throw new RuntimeException(ex);\n  } finally {\n    ... \n```", "```java\n shutdownExecutor(executor);\n  }\n} \n```", "```java\npublic static Future<String> futureTester(int id) {\n  return executor.submit(() -> fetchTester(id));\n} \n```", "```java\nAtomicLong counterOSThreads = new AtomicLong();\nwhile (true) {\n  new Thread(() -> {\n    long currentOSThreadNr\n      = counterOSThreads.incrementAndGet();\n    System.out.println(\"Thread: \" + currentOSThreadNr);\n    LockSupport.park();\n  }).start();\n} \n```", "```java\nAtomicLong counterOSThreads = new AtomicLong();\nwhile (true) {\n  Thread.ofPlatform().start(() -> {\n    long currentOSThreadNr\n      = counterOSThreads.incrementAndGet();\n    System.out.println(\"Thread: \" + currentOSThreadNr);\n    LockSupport.park();\n  });\n} \n```", "```java\nfinal class VirtualThread extends BaseVirtualThread {…}\nsealed abstract class BaseVirtualThread extends Thread\n  permits VirtualThread, ThreadBuilders.BoundVirtualThread {…} \n```", "```java\nRunnable task = () -> logger.info(\n  Thread.currentThread().toString()); \n```", "```java\nThread vThread = Thread.startVirtualThread(task);\n// next you can set its name\nvThread.setName(\"my_vThread\"); \n```", "```java\nThread vThread =Thread.ofVirtual().start(task); \n// a named virtual thread\nThread.ofVirtual().name(\"my_vThread\").start(task); \n```", "```java\nThread.Builder builder \n  = Thread.ofVirtual().name(\"my_vThread\");\nThread vThread = builder.start(task); \n```", "```java\nThread.Builder builder\n  = Thread.ofVirtual().name(\"vThread-\", 1);\n// name \"vThread-1\"\nThread vThread1 = builder.start(task);\nvThread1.join();\nlogger.info(() -> vThread1.getName() + \" terminated\");\n// name \"vThread-2\"\nThread vThread2 = builder.start(task);\nvThread2.join();\nlogger.info(() -> vThread2.getName() + \" terminated\"); \n```", "```java\nvThread.join(); \n```", "```java\nThread vThread = Thread.ofVirtual().unstarted(task); \n```", "```java\nThread.Builder builder = Thread.ofVirtual();\nThread vThread = builder.unstarted(task); \n```", "```java\nvThread.start(); \n```", "```java\nboolean isalive = vThread.isAlive(); \n```", "```java\nThread pThread = Thread.ofPlatform().unstarted(task); \n```", "```java\nThreadFactory tfVirtual = Thread.ofVirtual().factory();\nThreadFactory tfVirtual = Thread.ofVirtual()\n  .name(\"vt-\", 0).factory(); // 'vt-' name prefix, 0 counter \n```", "```java\nThread.Builder builder = Thread.ofVirtual().name(\"vt-\", 0);\nThreadFactory tfVirtual = builder.factory(); \n```", "```java\nThreadFactory tfPlatform = Thread.ofPlatform()\n  .name(\"pt-\", 0).factory(); // 'pt-' name prefix, 0 counter \n```", "```java\nstatic class SimpleThreadFactory implements ThreadFactory {\n  @Override\n  public Thread newThread(Runnable r) {\n    // return new Thread(r);                // platform thread\n    return Thread.ofVirtual().unstarted(r); // virtual thread\n  }\n} \n```", "```java\ntfVirtual.newThread(task).start();\ntfPlatform.newThread(task).start();\nSimpleThreadFactory stf = new SimpleThreadFactory();\nstf.newThread(task).start(); \n```", "```java\nThread vThread = Thread.ofVirtual()\n  .name(\"my_vThread\").unstarted(task);\nThread pThread1 = Thread.ofPlatform()\n  .name(\"my_pThread\").unstarted(task);\nThread pThread2 = new Thread(() -> {});\nlogger.info(() -> \"Is vThread virtual ? \" \n  + vThread.isVirtual());  // true\nlogger.info(() -> \"Is pThread1 virtual ? \" \n  + pThread1.isVirtual()); // false\nlogger.info(() -> \"Is pThread2 virtual ? \" \n  + pThread2.isVirtual()); // false \n```", "```java\nVirtualThread[#22]/runnable@ForkJoinPool-1-worker-1\nVirtualThread[#26,vt-0]/runnable@ForkJoinPool-1-worker-1 \n```", "```java\nAtomicLong counterOSThreads = new AtomicLong();\nwhile (true) {\n  Thread.startVirtualThread(() -> {\n    long currentOSThreadNr\n      = counterOSThreads.incrementAndGet();\n    System.out.println(\"Virtual thread: \" \n      + currentOSThreadNr);\n    LockSupport.park();\n  });\n} \n```", "```java\nRunnable taskr = () ->logger.info(\n  Thread.currentThread().toString());\nCallable<Boolean> taskc = () -> {\n  logger.info(Thread.currentThread().toString());\n  return true;\n}; \n```", "```java\ntry (ExecutorService executor \n      = Executors.newVirtualThreadPerTaskExecutor()) {\n  for (int i = 0; i < NUMBER_OF_TASKS; i++) {\n    executor.submit(taskr); // executing Runnable\n    executor.submit(taskc); // executing Callable\n  }\n} \n```", "```java\nFuture<?> future = executor.submit(taskr);\nFuture<Boolean> future = executor.submit(taskc); \n```", "```java\nVirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 \nVirtualThread[#31]/runnable@ForkJoinPool-1-worker-5 \nVirtualThread[#29]/runnable@ForkJoinPool-1-worker-7 \nVirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 \nVirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 \nVirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 \nVirtualThread[#26]/runnable@ForkJoinPool-1-worker-4 \nVirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \nVirtualThread[#36]/runnable@ForkJoinPool-1-worker-1 \nVirtualThread[#37]/runnable@ForkJoinPool-1-worker-2 \nVirtualThread[#35]/runnable@ForkJoinPool-1-worker-7 \nVirtualThread[#34]/runnable@ForkJoinPool-1-worker-4 \nVirtualThread[#32]/runnable@ForkJoinPool-1-worker-3 \nVirtualThread[#33]/runnable@ForkJoinPool-1-worker-2 \nVirtualThread[#30]/runnable@ForkJoinPool-1-worker-1 \n```", "```java\nstatic class SimpleThreadFactory implements ThreadFactory {\n  @Override\n  public Thread newThread(Runnable r) {\n    return new Thread(r);   // classic\n   // return Thread.ofVirtual().unstarted(r); // virtual \n  }\n}\ntry (ExecutorService executor = \n     Executors.newThreadPerTaskExecutor(\n         new SimpleThreadFactory())) {\n  for (int i = 0; i < NUMBER_OF_TASKS; i++) {\n    executor.submit(taskr); // executing Runnable\n    executor.submit(taskc); // executing Callable\n  }\n} \n```", "```java\nThread[#75,Thread-15,5,main] \nThread[#77,Thread-17,5,main] \nThread[#76,Thread-16,5,main] \nThread[#83,Thread-23,5,main] \nThread[#82,Thread-22,5,main] \nThread[#80,Thread-20,5,main] \nThread[#81,Thread-21,5,main] \nThread[#79,Thread-19,5,main] \nThread[#78,Thread-18,5,main] \nThread[#89,Thread-29,5,main] \nThread[#88,Thread-28,5,main] \nThread[#87,Thread-27,5,main] \nThread[#86,Thread-26,5,main] \nThread[#85,Thread-25,5,main] \nThread[#84,Thread-24,5,main] \n```", "```java\nprivate static ForkJoinPool createDefaultScheduler() {...} \n```", "```java\nprivate static final int NUMBER_OF_TASKS \n  = Runtime.getRuntime().availableProcessors();\nRunnable taskr = () ->\n  logger.info(Thread.currentThread().toString()); \ntry (ExecutorService executor \n    = Executors.newVirtualThreadPerTaskExecutor()) {\n  for (int i = 0; i < NUMBER_OF_TASKS + 1; i++) {\n    executor.submit(taskr);\n  }\n} \ncarriers), and each of them carries a virtual thread. Since we have + 1, a *carrier* will work twice. The output reveals this scenario (check out the workers; here, worker-8 runs virtual threads #30 and #31):\n```", "```java\nVirtualThread[#25]/runnable@ForkJoinPool-1-worker-3 \n**VirtualThread[#30]/runnable@ForkJoinPool-1-worker-8** \nVirtualThread[#28]/runnable@ForkJoinPool-1-worker-6 \nVirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \nVirtualThread[#24]/runnable@ForkJoinPool-1-worker-2 \nVirtualThread[#29]/runnable@ForkJoinPool-1-worker-7 \nVirtualThread[#26]/runnable@ForkJoinPool-1-worker-4 \nVirtualThread[#27]/runnable@ForkJoinPool-1-worker-5 \n**VirtualThread[#31]/runnable@ForkJoinPool-1-worker-8** \n```", "```java\nSynchronousQueue<Integer> queue = new SynchronousQueue<>();\nRunnable task = () -> {\n  logger.info(() -> Thread.currentThread().toString() \n    + \" sleeps for 5 seconds\");\n  try { Thread.sleep(Duration.ofSeconds(5)); } \n    catch (InterruptedException ex) {}\n  logger.info(() -> \"Running \" \n    + Thread.currentThread().toString());\n  **queue.add(Integer.MAX_VALUE);**\n};\nlogger.info(\"Before running the task ...\");\nThread vThread =Thread.ofVirtual().start(task);\nlogger.info(vThread.toString()); \n```", "```java\nlogger.info(() -> Thread.currentThread().toString()\n  + \" can't take from the queue yet\");\n**int****max int****=** **queue.take();** \nlogger.info(() -> Thread.currentThread().toString() \n  + \"took from queue: \" + maxint);\nlogger.info(vThread.toString());\nlogger.info(\"After running the task ...\"); \n```", "```java\n[09:41:59] Before running the task ... \n[09:42:00] VirtualThread[#22]/runnable \n[09:42:00] Thread[#1,main,5,main] \n           can't take from the queue yet\n[09:42:00] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1  \n           sleeps for 5 seconds \n[09:42:05] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n           inserts in the queue\n[09:42:05] Thread[#1,main,5,main]took from queue: 2147483647 \n[09:42:05] VirtualThread[#22]/terminated \n[09:42:05] After running the task ... \n```", "```java\n[09:42:00] VirtualThread[#22]/runnable \n[09:42:00] Thread[#1,main,5,main] \n           can't take from the queue yet \n```", "```java\n[09:42:00] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1  \n           sleeps for 5 seconds \n[09:42:05] VirtualThread[#22]/runnable@ForkJoinPool-1-worker-1 \n           inserts in the queue \n```", "```java\n[09:42:05] Thread[#1,main,5,main]took from queue: 2147483647 \n```", "```java\n[09:42:05] VirtualThread[#22]/terminated \n```", "```java\nstatic class SimpleThreadFactory implements ThreadFactory {\n  @Override\n  public Thread newThread(Runnable r) {\n  return new Thread(r);                      // classic thread\n  // return Thread.ofVirtual().unstarted(r); // virtual thread\n  }\n} \n```", "```java\npublic static void doSomething(int index) {\n  logger.info(() -> index + \" \" \n    + Thread.currentThread().toString());\n  try { Thread.sleep(Duration.ofSeconds(3)); } \n    catch (InterruptedException ex) {}\n   logger.info(() -> index + \" \" \n    + Thread.currentThread().toString());\n} \n```", "```java\ntry (ExecutorService executor = \n    Executors.newThreadPerTaskExecutor(\n      new SimpleThreadFactory())) {\n  for (int i = 0; i < MAX_THREADS; i++) {\n    int index = i;\n    executor.submit(() -> doSomething(index));\n  }\n} \n```", "```java\n@Override\npublic Thread newThread(Runnable r) {\n  // return new Thread(r);    // classic thread\n  return Thread.ofVirtual().unstarted(r); // virtual thread\n} \n```", "```java\nSystem.setProperty(\n  \"jdk.virtualThreadScheduler.maxPoolSize\", \"1\");\nSystem.setProperty(\n  \"jdk.virtualThreadScheduler.maxPoolSize\", \"1\");\nSystem.setProperty(\n  \"jdk.virtualThreadScheduler.maxPoolSize\", \"1\"); \n```", "```java\nRunnable slowTask = () -> {\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | working on something\");\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | break time (blocking)\");\n  try { Thread.sleep(Duration.ofSeconds(5)); } \n    catch (InterruptedException ex) {} // blocking\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | work done\");\n}; \n```", "```java\nRunnable fastTask = () -> {\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | working on something\");\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | break time (blocking)\");\n  try { Thread.sleep(Duration.ofSeconds(1)); } \n    catch (InterruptedException ex) {} // blocking\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | work done\");\n}; \n```", "```java\nThread st = Thread.ofVirtual()\n  .name(\"slow-\", 0).start(slowTask);\nThread ft = Thread.ofVirtual()\n  .name(\"fast-\", 0).start(fastTask);\nst.join();\nft.join(); \n```", "```java\n[08:38:46] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | working on something \n[08:38:46] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | break time (blocking) \n[08:38:46] VirtualThread[#24,fast-0]/runnable\n           @ForkJoinPool-1-worker-1 | working on something \n[08:38:46] VirtualThread[#24,fast-0]/runnable\n           @ForkJoinPool-1-worker-1 | break time (blocking) \n[08:38:47] VirtualThread[#24,fast-0]/runnable\n           @ForkJoinPool-1-worker-1 | work done \n[08:38:51] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | work done \n```", "```java\n[08:38:46] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | working on something \n```", "```java\n[08:38:46] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | break time (blocking) \n```", "```java\n[08:38:46] VirtualThread[#24,fast-0]/runnable\n           @ForkJoinPool-1-worker-1 | working on something \n```", "```java\n[08:38:46] VirtualThread[#24,fast-0]/runnable\n           @ForkJoinPool-1-worker-1 | break time (blocking) \n```", "```java\n[08:38:47] VirtualThread[#24,fast-0]/runnable\n           @ForkJoinPool-1-worker-1 | work done \n```", "```java\n[08:38:51] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | work done \n```", "```java\nRunnable slowTask = () -> {\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | working on something\");\n  logger.info(() -> Thread.currentThread().toString() \n    + \" | break time (non-blocking)\");\n  **while****(dummyTrue()) {}** **// non-blocking** \n  logger.info(() -> Thread.currentThread().toString() \n    + \" | work done\");\n};\nstatic boolean dummyTrue() { return true; } \n```", "```java\n[09:02:45] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | working on something \n[09:02:45] VirtualThread[#22,slow-0]/runnable\n           @ForkJoinPool-1-worker-1 | break time(non-blocking)\n// hang on \n```", "```java\n<T> List<Future<T>> invokeAll(Collection<? extends \n  Callable<T>> tasks) throws InterruptedException\n<T> List<Future<T>> invokeAll(\n  Collection<? extends Callable<T>> tasks, long timeout,\n    TimeUnit unit) throws InterruptedException \n```", "```java\ntry (ExecutorService executor \n    = Executors.newVirtualThreadPerTaskExecutor()) {\n  List<Future<String>> futures = executor.invokeAll(\n    List.of(() -> \"pass01\", () -> \"pass02\", () -> \"pass03\"));\n  futures.forEach(f -> logger.info(() ->\n    \"State: \" + f.state()));\n} \n```", "```java\n[10:17:41] State: SUCCESS \n[10:17:41] State: SUCCESS \n[10:17:41] State: SUCCESS \n```", "```java\n<T> T invokeAny(Collection<? extends Callable<T>> tasks)\n  throws InterruptedException, ExecutionException\n<T> T invokeAny(Collection<? extends Callable<T>> tasks,\n  long timeout, TimeUnit unit) throws InterruptedException,\n    ExecutionException, TimeoutException \n```", "```java\ntry (ExecutorService executor \n    = Executors.newVirtualThreadPerTaskExecutor()) {\n  String result = executor.invokeAny(\n    List.of(() -> \"pass01\", () -> \"pass02\", () -> \"pass03\"));\n  logger.info(result);\n} \n```", "```java\n[10:29:33] pass02 \n```", "```java\npublic static TestingTeam buildTestingTeam() \n      throws InterruptedException {\n  try (ExecutorService executor \n      = Executors.newVirtualThreadPerTaskExecutor()) {\n    List<Future<String>> futures = executor.invokeAll(\n      List.of(() -> fetchTester(1), \n              () -> fetchTester(2), \n              () -> fetchTester(3)));\n    futures.forEach(f -> logger.info(() -> \"State: \" \n      + f.state())); \n    return new TestingTeam(futures.get(0).resultNow(), \n      futures.get(1).resultNow(), futures.get(2).resultNow());\n  } \n} \n```", "```java\n[07:47:32] State: SUCCESS\n[07:47:32] State: SUCCESS \n[07:47:32] State: SUCCESS \n```", "```java\npublic static TestingTeam buildTestingTeam() \n      throws InterruptedException, ExecutionException {\n  try (ExecutorService executor \n    = Executors.newVirtualThreadPerTaskExecutor()) {\n    String result = executor.invokeAny(\n      List.of(() -> fetchTester(1), \n              () -> fetchTester(2), \n              () -> fetchTester(3)));\n    logger.info(result);\n    return new TestingTeam(result);\n  } \n} \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException {\n  List<String> testers = new ArrayList<>();\n  try (ExecutorService executor \n      = Executors.newVirtualThreadPerTaskExecutor()) {\n    List<Future<String>> futures = executor.invokeAll(\n      List.of(() -> fetchTester(Integer.MAX_VALUE),\n              () -> fetchTester(2), \n              () -> fetchTester(Integer.MAX_VALUE)));\n    futures.forEach(f -> {\n      logger.info(() -> \"Analyzing \" + f + \" state ...\"); \n      switch (f.state()) {\n        case RUNNING -> throw new IllegalStateException(\n          \"Future is still in the running state ...\");\n        case SUCCESS -> {\n          logger.info(() -> \"Result: \" + f.resultNow());\n          testers.add(f.resultNow());\n        }\n        case FAILED ->\n          logger.severe(() -> \"Exception: \" \n            + f.exceptionNow().getMessage());\n        case CANCELLED ->\n          logger.info(\"Cancelled ?!?\");\n      }\n    }); \n  }\n  return new TestingTeam(testers.toArray(String[]::new));\n} \n```", "```java\ntry (ExecutorService executor \n      = Executors.newVirtualThreadPerTaskExecutor()) {\n  List<Future<String>> futures = IntStream.range(0, 10)\n    .mapToObj(i -> executor.submit(() -> {\n       return Thread.currentThread().toString() \n         + \"(\" + i + \")\";\n  })).collect(toList());\n  // here we have the following snippet of code\n} \n```", "```java\n futures.forEach(f -> {\n    try {\n      logger.info(f.get());\n    } catch (InterruptedException | ExecutionException ex) {\n      // handle exception\n    }\n  }); \n```", "```java\nList<String> results = executor.invokeAll(\n  List.of(() -> \"pass01\", () -> \"pass02\", () -> \"pass03\"))\n  .stream()\n  .filter(f -> f.state() == Future.State.SUCCESS)\n  .<String>mapMulti((f, c) -> {\n    c.accept((String) f.resultNow());\n  }).collect(Collectors.toList()); \n```", "```java\nList<String> results = executor.invokeAll(\n  List.of(() -> \"pass01\", () -> \"pass02\", () -> \"pass03\"))\n  .stream()\n  .filter(f -> f.state() == Future.State.SUCCESS)\n  .map(f -> f.resultNow().toString())\n  .toList(); \n```", "```java\nList<Object> results = executor.invokeAll(\n  List.of(() -> \"pass01\", () -> \"pass02\", () -> \"pass03\"))\n  .stream()\n  .filter(f -> f.state() == Future.State.SUCCESS)\n  .map(Future::resultNow)\n  .toList(); \n```", "```java\nList<Throwable> exceptions = executor.invokeAll(\n  List.of(() -> \"pass01\", \n          () -> \"pass02\".substring(50), () -> \"pass03\"))\n  .stream()\n  .filter(f -> f.state() == Future.State.FAILED)\n  .<Throwable>mapMulti((f, c) -> {\n    c.accept((Throwable) f.exceptionNow());\n  }).collect(Collectors.toList()); \n```", "```java\nList<Throwable> exceptions = executor.invokeAll(\n  List.of(() -> \"pass01\", () -> \"pass02\".substring(50), \n          () -> \"pass03\"))\n  .stream()\n  .filter(f -> f.state() == Future.State.FAILED)\n  .map(Future::exceptionNow)\n  .toList(); \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException {\n  try (StructuredTaskScope scope \n      = new StructuredTaskScope<String>()) {\n    Subtask<String> subtask\n      = scope.fork(() -> fetchTester(1));\n    logger.info(() -> \"Waiting for \" + subtask.toString() \n      + \" to finish ...\\n\");\n    scope.join(); \n    String result = subtask.get();\n    logger.info(result);\n    return new TestingTeam(result);\n  } \n} \n```", "```java\ntry (StructuredTaskScope scope \n      = new StructuredTaskScope<String>()) {\n    ...  \n} \n```", "```java\nSubtask<String> subtask = scope.fork(() -> fetchTester(1)); \n```", "```java\nscope.join(); \n```", "```java\nString result = subtask.get(); \n```", "```java\nString result = \"\";\nif (subtask.state().equals(Subtask.State.SUCCESS)) {\n  result = subtask.get();\n} \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException, ExecutionException {\n  try (ShutdownOnSuccess scope \n      = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n    Subtask<String> subtask1 \n      = scope.fork(() -> fetchTester(1));\n    Subtask<String> subtask2 \n      = scope.fork(() -> fetchTester(2));\n    Subtask<String> subtask3 \n      = scope.fork(() -> fetchTester(3));\n    scope.join();\n    logger.info(() -> \"Subtask-1 state: \" + future1.state());\n    logger.info(() -> \"Subtask-2 state: \" + future2.state());\n    logger.info(() -> \"Subtask-3 state: \" + future3.state());\n    String result = (String) scope.result();\n    logger.info(result);\n    return new TestingTeam(result);\n  }\n} \n```", "```java\n[09:01:50] Subtask-1 state: UNAVAILABLE\n[09:01:50] Subtask-2 state: SUCCESS\n[09:01:50] Subtask-3 state: UNAVAILABLE \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException, ExecutionException {\n  try (ShutdownOnSuccess scope \n      = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n    scope.fork(() -> fetchTester(1));\n    scope.fork(() -> fetchTester(2));\n    scope.fork(() -> fetchTester(3));\n    scope.join();\n    return new TestingTeam((String) scope.result());\n  }\n} \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException, ExecutionException {\n  try (ShutdownOnFailure scope \n      = new StructuredTaskScope.ShutdownOnFailure()) {\n    Subtask<String> subtask1 \n      = scope.fork(() -> fetchTester(1));\n    Subtask<String> subtask2 \n      = scope.fork(() -> fetchTester(2));\n    Subtask<String> subtask3 \n      = scope.fork(() -> fetchTester(Integer.MAX_VALUE));\n    scope.join();\n    logger.info(() -> \"Subtask-1 state: \" + subtask1.state());\n    logger.info(() -> \"Subtask-2 state: \" + subtask2.state());\n    logger.info(() -> \"Subtask-3 state: \" + subtask3.state());\n    Optional<Throwable> exception = scope.exception();\n    if (exception.isEmpty()) {\n      logger.info(() -> \"Subtask-1 result:\" + subtask1.get());\n      logger.info(() -> \"Subtask-2 result:\" + subtask2.get());\n      logger.info(() -> \"Subtask-3 result:\" + subtask3.get());\n      return new TestingTeam(\n        subtask1.get(), subtask2.get(), subtask3.get());\n    } else {\n      logger.info(() -> exception.get().getMessage());\n      scope.throwIfFailed();\n    }\n  }\n  return new TestingTeam();\n} \n```", "```java\n[16:41:15] Subtask-1 state: SUCCESS\n[16:41:15] Subtask-2 state: SUCCESS\n[16:41:15] Subtask-3 state: FAILED \n```", "```java\nException in thread \"main\" \njava.util.concurrent.ExecutionException: \nmodern.challenge.UserNotFoundException: Code: 404 \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException, ExecutionException {\n  try (ShutdownOnFailure scope \n      = new StructuredTaskScope.ShutdownOnFailure()) {\n    Subtask<String> subtask1 \n      = scope.fork(() -> fetchTester(1));\n    Subtask<String> subtask2 \n      = scope.fork(() -> fetchTester(2));\n    Subtask<String> subtask3 \n      = scope.fork(() -> fetchTester(\n        Integer.MAX_VALUE)); // this causes exception\n    scope.join();\n    scope.throwIfFailed();\n    // because we have an exception the following \n    // code will not be executed\n    return new TestingTeam(\n      subtask1.get(), subtask2.get(), subtask3.get()); \n  }\n} \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException, ExecutionException {\n  try (ShutdownOnSuccess scope \n      = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n    Stream.of(1, 2, 3)\n      .<Callable<String>>map(id -> () -> fetchTester(id))\n      .forEach(scope::fork);\n    scope.join();\n    String result = (String) scope.result();\n    logger.info(result);\n    return new TestingTeam(result);\n  }\n} \n```", "```java\npublic static TestingTeam buildTestingTeam() \n    throws InterruptedException, ExecutionException {\n try (ShutdownOnSuccess scope \n  = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n  List<Subtask> subtasks = Stream.of(Integer.MAX_VALUE, 2, 3)\n    .<Callable<String>>map(id -> () -> fetchTester(id))\n    .map(scope::fork)\n    .toList();\n  scope.join();\n  List<Throwable> failed = subtasks.stream()\n    .filter(f -> f.state() == Subtask.State.FAILED)\n    .map(Subtask::exception)\n    .toList();\n  logger.info(failed.toString());\n  TestingTeam result = subtasks.stream()\n    .filter(f -> f.state() == Subtask.State.SUCCESS)\n    .map(Subtask::get) \n    .collect(collectingAndThen(toList(),\n      list -> { return new TestingTeam(list.toArray(\n        String[]::new)); }));\n  logger.info(result.toString());\n  return result;\n  }\n} \n```", "```java\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<configuration version=\"2.0\" description=\"test\">\n  <event name=\"jdk.VirtualThreadStart\">\n    <setting name=\"enabled\">true</setting>\n    <setting name=\"stackTrace\">true</setting>\n  </event>\n  <event name=\"jdk.VirtualThreadEnd\">\n    <setting name=\"enabled\">true</setting>\n  </event>\n  <event name=\"jdk.VirtualThreadPinned\">\n    <setting name=\"enabled\">true</setting>\n    <setting name=\"stackTrace\">true</setting>\n    <setting name=\"threshold\">20 ms</setting>\n  </event>\n  <event name=\"jdk.VirtualThreadSubmitFailed\">\n    <setting name=\"enabled\">true</setting>\n    <setting name=\"stackTrace\">true</setting>\n  </event>\n</configuration> \n```", "```java\npublic static TestingTeam buildTestingTeam() \n       throws InterruptedException, ExecutionException {\n  try (ShutdownOnSuccess scope \n    = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n    Stream.of(1, 2, 3)\n      .<Callable<String>>map(id -> () -> fetchTester(id))\n      .forEach(scope::fork);\n    scope.join();\n    String result = (String) scope.result();\n    logger.info(result);\n    return new TestingTeam(result);\n  }\n} \n```", "```java\npublic static synchronized String fetchTester(int id) \n    throws IOException, InterruptedException {\n  ...\n} \n```", "```java\nThread[#26,ForkJoinPool-1-worker-1,5,CarrierThreads]    java.base/java.lang.VirtualThread$VThreadContinuation.onPinned(VirtualThread.java:183)\n... \n```", "```java\njcmd <PID> Thread.dump_to_file -format=text <file>\njcmd <PID> Thread.dump_to_file -format=json <file> \n```", "```java\nScheduledExecutorService scheduledExecutor\n      = Executors.newScheduledThreadPool(1);\nscheduledExecutor.scheduleAtFixedRate(() -> {\n  ThreadMXBean threadBean\n    = ManagementFactory.getThreadMXBean();\n  ThreadInfo[] threadInfo\n    = threadBean.dumpAllThreads(false, false);\n  logger.info(() -> \"Platform threads: \" + threadInfo.length);\n}, 500, 500, TimeUnit.MILLISECONDS); \n```", "```java\nnewCachedThreadPool() and platform threads. We also measure the time elapsed to execute these tasks:\n```", "```java\nlong start = System.currentTimeMillis();\ntry (ExecutorService executorCached\n    = Executors.newCachedThreadPool()) {\n  IntStream.range(0, 10_000).forEach(i -> {\n    executorCached.submit(() -> {\n      Thread.sleep(Duration.ofSeconds(1));\n      logger.info(() -> \"Task: \" + i);\n      return i;\n    });\n  });\n}\nlogger.info(() -> \"Time (ms): \" \n  + (System.currentTimeMillis() - start)); \n```", "```java\nlong start = System.currentTimeMillis();\ntry (ExecutorService executorFixed\n    = Executors.newFixedThreadPool(200)) {\n  IntStream.range(0, 10_000).forEach(i -> {\n    executorFixed.submit(() -> {\n      Thread.sleep(Duration.ofSeconds(1));\n      logger.info(() -> \"Task: \" + i);\n      return i;\n    });\n  });\n}\nlogger.info(() -> \"Time (ms): \" \n  + (System.currentTimeMillis() - start)); \n```", "```java\nlong start = System.currentTimeMillis();\ntry (ExecutorService executorVirtual\n      = Executors.newVirtualThreadPerTaskExecutor()) {\n  IntStream.range(0, 10_000).forEach(i -> {\n    executorVirtual.submit(() -> {\n      Thread.sleep(Duration.ofSeconds(1));\n      logger.info(() -> \"Task: \" + i);\n      return i;\n    });\n  });\n}\nlogger.info(() -> \"Time (ms): \" \n  + (System.currentTimeMillis() - start)); \n```", "```java\ntry (ShutdownOnSuccess scope\n  = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n    Stream.of(1, 2, 3)\n          .<Callable<String>>map(id -> () -> fetchTester(id))\n          .forEach(scope::fork);\n  HotSpotDiagnosticMXBean mBean = ManagementFactory\n    .getPlatformMXBean(HotSpotDiagnosticMXBean.class);\n  mBean.dumpThreads(Path.of(\"dumpThreads.json\")\n    .toAbsolutePath().toString(), \n  HotSpotDiagnosticMXBean.ThreadDumpFormat.JSON);\n  scope.join();\n  String result = (String) scope.result();\n  logger.info(result);\n} \n```", "```java\n...\n{\n  \"container\": \"java.util.concurrent\n             .StructuredTaskScope$ShutdownOnSuccess@6d311334\",\n  \"parent\": \"<root>\",\n  \"owner\": \"1\",\n  \"threads\": [\n    {\n    \"tid\": \"22\"\n    \"name\": \"\",\n    \"stack\": [\n      ...\n      \"java.base\\/java.lang.VirtualThread\n       .run(VirtualThread.java:311)\"\n      ]\n    },\n   {\n    \"tid\": \"24\",\n    \"name\": \"\",\n    \"stack\": [\n      ...\n      \"java.base\\/java.lang.VirtualThread\n        .run(VirtualThread.java:311)\"\n      ]\n    },\n    {\n    \"tid\": \"25\",\n    \"name\": \"\",\n    \"stack\": [\n      ...\n      \"java.base\\/java.lang.VirtualThread\n        .run(VirtualThread.java:311)\"\n      ]\n    }\n  ],\n  \"threadCount\": \"3\"\n}\n... \n```"]