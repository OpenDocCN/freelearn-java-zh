- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building the Framework Hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a hexagonal application, the last step consists of exposing the
    application features by connecting input adapters to input ports. Also, if there
    is any need to get data from, or persist it inside, external systems, then we
    need to connect output adapters to output ports. The Framework hexagon is the
    place where we assemble all the adapters required to make the hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first created the domain model using things including entities, value objects,
    and specifications in the Domain hexagon. Then, in the Application hexagon, we
    expressed the user’s intent using use cases and ports. Now, in the Framework hexagon,
    we have to employ adapters to expose system features and define which technologies
    will be used to enable such features. After assembling the Domain, Application,
    and Framework hexagons, we will have an architecture resembling the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Domain, Application, and Frameworks hexagons assembled](img/B19777_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Domain, Application, and Frameworks hexagons assembled
  prefs: []
  type: TYPE_NORMAL
- en: What is so compelling about the hexagonal architecture is that we can add and
    remove adapters without worrying about changing the core system logic wrapped
    in the Domain hexagon. Of course, there is a price to be paid in the form of data
    translation between domain entities and external entities. However, in exchange,
    we gain a more decoupled system with clear boundaries between its realms of responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the Framework hexagon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing output adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing input adapters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Framework hexagon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll have learned to create input adapters to
    make the hexagonal application features accessible to other users and systems.
    Also, you’ll learn how to implement output adapters to enable the hexagonal system
    to communicate with external data sources.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you’ll need
    the latest **Java SE Development Kit** and **Maven 3.8** installed on your computer.
    They are all available for the Linux, Mac, and Windows operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping the Framework hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building a system using hexagonal architecture, you don’t need to decide
    upfront whether the system API will be exposed using REST or gRPC, nor whether
    the system’s primary data source will be a MySQL database or MongoDB. Instead,
    what you need to do is start modeling your problem domain in the Domain hexagon,
    then designing and implementing use cases in the Application hexagon. Then, only
    after creating the previous two hexagons do you need to start thinking about which
    technologies will enable the hexagonal system’s functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: A hexagonal approach centered around **Domain-Driven Design** allows us to postpone
    the decisions regarding the underlying technologies internal or external to the
    hexagonal system. Another prerogative of the hexagonal approach is the pluggable
    nature of the adapters. If you want to expose a certain system feature to be accessible
    via REST, you create and plug a REST input adapter into an input port. Later on,
    if you want to expose that same feature to clients using gRPC, you can create
    and plug a gRPC input adapter into the same input port.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with external data sources, we have the same pluggable prerogatives
    using output adapters. You can plug different output adapters into the same output
    port, changing the underlying data source technology without having to majorly
    refactor the whole hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: To further explore input adapters, we’ll have a more in-depth discussion in
    [*Chapter 12*](B19777_12.xhtml#_idTextAnchor244), *Using RESTEasy Reactive to
    Implement Input Adapters*. We’ll also investigate more possibilities for output
    adapters in [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting Data
    with Output Adapters and* *Hibernate Reactive*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s stick to the basics and create a solid structure for input and output
    adapters. On top of this structure, later on, we’ll be able to add the exciting
    features provided by the Quarkus framework.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing the development of the topology and inventory system, we need to
    bootstrap the Framework hexagon as a Maven and Java module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the topology and inventory Maven root project, we have to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We recommend running the preceding command directly on CMD instead of PowerShell
    if you are using Windows. If you need to use PowerShell, you’ll need to wrap each
    part of the command in double quotes.
  prefs: []
  type: TYPE_NORMAL
- en: The `mvn` `archetype:generate` goal creates a Maven module called `framework`
    inside `topology-inventory`. This module comes with a skeleton directory structure
    based on the `groupId` and `artificatId` we passed into the `mvn` command. Also,
    it includes a child `pom.xml` file inside the `framework` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'After executing the `mvn` command to create the `framework` module, the root
    project’s `pom.xml` file will be updated to contain the new module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `framework` module is inserted at the end as the latest module we have just
    added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the `framework` module depends on both the `domain` and `application`
    modules, we need to add them as dependencies to the `framework` module’s `pom.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the Maven command to create the `framework` module, you should
    see a directory tree similar to the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The directory structure of the Framework hexagon](img/B19777_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The directory structure of the Framework hexagon
  prefs: []
  type: TYPE_NORMAL
- en: There should be a child `pom.xml` file in the `framework` directory and a parent
    `pom.xml` file in the `topology-inventory` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have completed the Maven configuration, we can create the descriptor
    file that turns the `framework` Maven module into a Java module. We do that by
    creating the following file, `topology-inventory/framework/src/java/module-info.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Because we have added `domain` and `application` as Maven dependencies to the
    framework’s `pom.xml` file, we can also add them as Java module dependencies to
    the `module-info.java` descriptor file.
  prefs: []
  type: TYPE_NORMAL
- en: With both the Maven and Java modules properly configured for the Framework hexagon,
    we can move on to creating the output adapters for the topology and inventory
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing output adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by implementing the output adapters to set up the integration
    between our topology and inventory system and the underlying data source technology,
    which is an `H2` in-memory database. It’s also important to implement output adapters
    first because we refer to them when implementing the input adapters.
  prefs: []
  type: TYPE_NORMAL
- en: The topology and inventory system allows external data retrieval for routers’
    and switches’ entities. So, in this section, we will review the output port interfaces
    that get external data related to these entities. We’ll also provide an output
    adapter implementation for each output port interface.
  prefs: []
  type: TYPE_NORMAL
- en: The router management output adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The router management output adapter we need to create should implement this
    `RouterManagementOutputPort` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Both the `retrieveRouter` and `removeRouter` methods’ signatures have `Id` as
    a parameter. We use `Id` to identify the router in the underlying data source.
    Then, we have the `persistRouter` method signature receiving a `Router` parameter,
    which can represent both core and edge routers. We use that `Router` parameter
    to persist the data in the data source.
  prefs: []
  type: TYPE_NORMAL
- en: For the topology and inventory system, for now, we have to implement only one
    output adapter to allow the system to use an `H2` in-memory database.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start the implementation with the `RouterManagementH2Adapter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `H2` database connection is controlled by `EntityManager`. This connection
    is configured by the `setUpH2Database` method, which we execute when we call the
    class’s empty constructor. We use the variable called `instance` to provide a
    singleton so other objects can trigger database operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement each method declared on the output port interface:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with the `retrieveRouter` method, which receives `Id` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `getReference` method from `EntityManager` is called with `RouterData.class`
    and the UUID value is extracted from the `Id` object. `RouterData` is a database
    entity class that we use to map data coming from the database into the `Router`
    domain entity class. This mapping is accomplished by the `routerDataToDomain`
    method from the `RouterH2Mapper` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we implement the `removeRouter` method, which removes a router from the
    database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To remove a router, we first have to retrieve it by calling the `getReference`
    method. Once we have a `RouterData` object representing the database entity, we
    can call the `remove` method from `EntityManager`, which can delete the router
    from the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we implement the `persistRouter` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It receives a `Router` domain entity object that needs to be converted into
    a `RouterData` database entity object that can be persisted with the `persist`
    method from `EntityManager`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By implementing the `retrieveRouter`, `removeRouter`, and `persistRouter` methods,
    we provide the basic database operations required by the topology and inventory
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to see the switch output adapters’ implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The switch management output adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The output adapter we implement for the switch is simpler because we don’t need
    to persist switches directly or remove them. The sole purpose of the switch’s
    output adapter is to enable the retrieval of switches from the database. We allow
    persistence only through the router output adapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let’s define the `SwitchManagementOutputPort` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have just one method called `retrieveSwitch`, which receives `Id` and returns
    `Switch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SwitchManagementH2Adapter` output adapter implementation is very straightforward
    and similar to its router counterpart. So, we’ll just assess the implementation
    of the `retrieveSwitch` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We call the `getReference` method from `EntityManager` with `SwitchData.class`
    and a UUID value as parameters in order to retrieve a `SwitchData` database entity
    object. Then, this object is converted into a `Switch` domain entity when we call
    the `switchDataToDomain` method from the `RouterH2Mapper` class.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have both `RouterManagementH2Adapter` and `SwitchManagementH2Adapter`
    properly implemented, we can proceed to implement the input adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the input adapters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building the Application hexagon, we need to create use cases and input
    ports to express system capabilities. To make these capabilities available to
    users and other systems, we need to build input adapters and connect them to input
    ports.
  prefs: []
  type: TYPE_NORMAL
- en: For the topology and inventory system, we will implement a set of generic input
    adapters as Java POJOs. These generic input adapters are the basis for the technologically
    specific implementation that takes place in [*Chapter 12*](B19777_12.xhtml#_idTextAnchor244),
    *Using RESTEasy Reactive to Implement Input Adapters*. In that chapter, we will
    reimplement the generic input adapters as RESTEasy-based input adapters using
    the Quarkus framework.
  prefs: []
  type: TYPE_NORMAL
- en: The input adapter’s central role is to receive requests from outside the hexagonal
    system and fulfill these requests using an input port.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to develop the topology and inventory system, let’s implement the
    input adapters that receive requests related to router management.
  prefs: []
  type: TYPE_NORMAL
- en: The router management input adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating the `RouterManagementGenericAdapter` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We start the `RouterManagementGenericAdapter` implementation by declaring a
    class attribute for `RouterManagementUseCase`. Instead of using an input port
    class reference, we utilize the use case interface reference, `RouterManagementUseCase`,
    to connect to the input port.
  prefs: []
  type: TYPE_NORMAL
- en: On the constructor of `RouterManagementGenericAdapter`, we call the `setPorts`
    method, which instantiates `RouterManagementInputPort` with a `RouterManagementH2Adapter`
    parameter as an output port to connect to the H2 in-memory database that the input
    port uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we should implement the `setPorts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `setPorts` method stores a `RouterManagementInputPort` object in the `RouterManagementUseCase`
    attribute we defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'After class initialization, we need to create the methods that expose the operations
    supported by the hexagonal system. The intent here is to receive the request in
    the input adapter and forward it to an input port by using its use case interface
    reference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the operations for retrieving and removing routers from the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The comments are to remind us that these operations will be transformed into
    REST endpoints when integrating Quarkus into the hexagonal system. Both `retrieveRouter`
    and `removeRouter` receive `Id` as a parameter. Then, the request is forwarded
    to an input port using a use case reference.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we have the operation to create a new router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the `RouterManagementUseCase` reference, we first call the `createRouter`
    method to create a new router, then we persist it using the `persistRouter` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Remember that in the topology and inventory system, only core routers can receive
    connections from both core and edge routers. To allow the addition and removal
    of routers to or from a core router, we first define the following operation to
    add routers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the `addRouterToCoreRouter` method, we pass the routers’ `Id` instances
    as parameters we intend to add along with the target core router’s `Id`. With
    these IDs, we call the `retrieveRouter` method to get the router objects from
    our data source. Once we have the `Router` and `CoreRouter` objects, we handle
    the request to the input port using a use case reference, by calling `addRouterToCoreRouter`
    to add one router to the other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After that, we define the operation to remove routers from a core router:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the `removeRouterFromCoreRouter` method, we follow the same steps as those
    for the `addRouterToCoreRouter` method. The only difference, though, is that at
    the end, we call `removeRouterFromCoreRouter` from the use case in order to remove
    one router from the other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s now create the adapter that handles switch-related operations.
  prefs: []
  type: TYPE_NORMAL
- en: The switch management input adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we define the methods that expose the switch-related operations, we
    need to configure the proper initialization of the `SwitchManagementGenericAdapter`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`SwitchManagementGenericAdapter` is connected to two input ports – the first
    input port is `SwitchManagementInputPort` from `SwitchManagementUseCase`, and
    the second input port is `RouterManagementInputPort` from `RouterManagementUseCase`.
    That’s why we start the class implementation by declaring the attributes for `SwitchManagementUseCase`
    and `RouterManagementUseCase`. We are connecting the switch adapter to the router
    input port because we want to enforce any persistence activity to happen only
    through a router. The `Router` entity, as an aggregate, controls the life cycles
    of the objects that are related to it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we implement the `setPorts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With the `setPorts` method, we initialize both input ports with the `SwitchManagementH2Adapter`
    and `RouterManagementH2Adapter` adapters to allow access to the H2 in-memory database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how to implement the methods that expose the switch-related operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a simple operation that just retrieves a switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `retrieveSwitch` method receives `Id` as a parameter. Then, it utilizes
    a use case reference to forward the request to the input port.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we have a method that lets us create and add a switch to an edge router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We call the switch input port method, `createSwitch`, by passing the parameters
    received by the `createAndAddSwitchToEdgeRouter` method to create a switch. With
    `routerId`, we retrieve the edge router by calling the `retrieveRouter` method
    from the `router` input port. Once we have the `Switch` and `EdgeRouter` objects,
    we can call the `addSwitchToEdgeRouter` method to add the switch to the edge router.
    As the last step, we call the `persistRouter` method to persist the operation
    in the data source.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, we have the `removeSwitchFromEdgeRouter` method, which allows us to
    remove a switch from an edge router:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`removeSwitchFromEdgeRouter` receives `Id` as a parameter for the switch and
    another `Id` for the edge router. Then, it retrieves the router by calling the
    `retrieveRouter` method. With the switch ID, it retrieves the `switch` object
    from the edge router object. Once it gets the `Switch` and `EdgeRouter` objects,
    it calls the `removeSwitchFromEdgeRouter` method to remove the switch from the
    edge router.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What’s left now is to implement the adapter that deals with the topology and
    inventory networks.
  prefs: []
  type: TYPE_NORMAL
- en: The network management input adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we did with the router and switch adapters, let’s implement the `NetworkManagementGenericAdapter`
    class by first defining the ports it needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides `NetworkManagementUseCase`, we also use `SwitchManagementUseCase`.
    We need to call the `setPorts` method from the constructor of `NetworkManagementGenericAdapter`
    to properly initialize the input port objects and assign them to their respective
    use case references. The following is how we implement the `setPorts` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we did in previous input adapter implementations, we configure the `setPorts`
    method to initialize the input port objects and assign them to the use case references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s implement the network-related methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we implement the `addNetworkToSwitch` method to add a network to a switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `addNetworkToSwitch` method receives the `Network` and `Id` objects as parameters.
    To proceed, we need to retrieve the `Switch` object by calling the `retrieveSwitch`
    method. Then, we can call the `addNetworkToSwitch` method to add the network to
    the switch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, we implement the method to remove a network from a switch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we get a `Switch` object by calling the `retrieveSwitch` method with
    the `Id` parameter. To remove a network from a switch, we use the network name
    to find it from a list of networks attached to the switch. We do that by calling
    the `removeNetworkFromSwitch` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The adapter for managing networks is the last input adapter we have to implement.
    With these three adapters, we can now manage routers, switches, and networks from
    the Framework hexagon. To make sure these adapters are working well, let’s create
    some tests for them.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Framework hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By testing the Framework hexagon, we not only have the opportunity to check
    whether the input and output adapters are working well but we can also test whether
    the other hexagons, Domain and Application, are doing their part in response to
    the requests coming from the Framework hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: To test it, we call the input adapters to trigger the execution of everything
    necessary in the downstream hexagons to fulfill the request. We start by implementing
    tests for the router management adapters. The tests for switches and networks
    follow the same pattern and are available in the GitHub repository for this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the routers, we will put our tests into the `RouterTest` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In the `RouterTest` constructor, we instantiate the `RouterManagementGenericAdapter`
    input adapter class that we use to perform the tests. The `loadData` method loads
    some test data from the `FrameworkTestData` parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have correctly configured the requirements of the tests, we can proceed
    with the testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we test router retrieval:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We call the input adapter, informing it of the router `id` we want to retrieve.
    With `assertEquals`, we compare the expected ID with the actual ID to see whether
    they match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test router creation, we have to implement the `createRouter` test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the router input adapter, we call the `createRouter` method to create and
    persist a new router. Then, we call the `retrieveRouter` method with the ID previously
    generated by the router we have just created. Finally, we run `assertEquals` to
    confirm whether the router retrieved from the data source is indeed the router
    we created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test the addition of a router to a core router, we have the `addRouterToCoreRouter`
    test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We pass the variables, `routerId` and `coreRouterId`, as parameters to the input
    adapter’s `addRouterToCoreRouter` method, which returns a core router. `assertEquals`
    checks whether the core router has the router we added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test the removal of a router from a core router, we’ll use this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test is very similar to the previous one. We again use the `routerId` and
    `coreRouterId` variables, but now we also use the `removeRouterFromCoreRouter`
    method, which returns the removed router. `assertEquals` checks whether the removed
    router’s ID matches the ID from the `routerId` variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To run these tests, execute the following command in the Maven project root
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be similar to the one here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Along with `RouterTest`, we also have tests from `SwitchTest` and `NetworkTest`,
    which you can find in the book’s GitHub repository, as mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: By implementing the Framework hexagon tests, we conclude the development of
    the Framework hexagon and the whole topology and inventory system’s backend. Taking
    what we’ve learned from this chapter and the previous chapters, we can apply all
    the techniques covered to create a system following the hexagonal architecture
    principles.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the Framework hexagon construction by first implementing the output
    adapters to enable the topology and inventory system to use an H2 in-memory database
    as its primary data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we created three input adapters: one for router operations, another one
    for switch operations, and the last one for network-related operations. To conclude,
    we implemented tests to ensure that the adapters and the whole hexagonal system
    worked as expected. By completing the development of the Framework hexagon, we
    have finished the development of our overall hexagonal system.'
  prefs: []
  type: TYPE_NORMAL
- en: We can improve the hexagonal system we have created by exploring the possibilities
    offered by the **Java Module Platform System** (**JPMS**). For example, we can
    leverage the hexagonal modular structure to apply the **Dependency Inversion**
    **Principle** (**DIP**). By doing so, we can make the hexagonal system more loosely
    coupled. We shall examine the DIP and other exciting features in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Which other Java modules does the `Framework hexagon` Java module depend on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why do we need to create the output adapters?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to communicate with the input ports, the input adapters instantiate
    input port objects and assign them to an interface reference. What’s that interface?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When we test a Framework hexagon’s input adapter, we are also testing other
    hexagons. Why does that happen?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Framework hexagon` module depends on the Domain and Application hexagons’
    Java modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create output adapters to enable the hexagonal system to connect to external
    data sources.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s the use case interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because the input adapters depend on the components provided by the Domain and
    Application hexagons.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
