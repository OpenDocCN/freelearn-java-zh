- en: Switching, Throttling, Windowing, and Buffering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换、节流、窗口化和缓冲
- en: It is not uncommon to run into situations where an `Observable` is producing
    emissions faster than an `Observer` can consume them. This happens particularly
    when you introduce concurrency, and the `Observable` chain has different operators
    running on different Schedulers. Whether it is one operator struggling to keep
    up with a preceding one, or the final `Observer` struggling to keep up with emissions
    from the upstream, bottlenecks can occur where emissions start to queue up behind
    slow operations.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 遇到`Observable`产生排放的速度超过`Observer`能够消费它们的情况并不少见。这种情况尤其在引入并发性，且`Observable`链在不同的调度器上运行不同的操作符时发生。无论是某个操作符努力跟上前面的一个，还是最后的`Observer`努力跟上上游的排放，都可能出现瓶颈，导致排放开始排队在缓慢操作之后。
- en: Of course, the ideal way to handle bottlenecks is to leverage backpressure using
    Flowable instead of `Observable`.The `Flowable` is not much different than the `Observable`
    other than that it tells the source to slow down by having the `Observer` request
    emissions at its own pace, as we will learn about it in *[Chapter 8](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml),
    Flowables and Backpressure*. But not every source of emissions can be backpressured.
    You cannot instruct `Observable.interval()` (or even `Flowable.interval()`) to
    slow down because the emissions are logically time-sensitive. Asking it to slow
    down would make those time-based emissions inaccurate. User input events, such
    as button clicks, logically cannot be backpressured either because you cannot
    programmatically control the user.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，处理瓶颈的理想方式是利用Flowable的背压而不是`Observable`。`Flowable`与`Observable`没有太大区别，除了它通过让`Observer`以自己的节奏请求排放来告诉源减慢速度，正如我们将在*[第8章](14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml)，Flowables和背压*中了解的那样。但并非所有排放源都可以使用背压。你不能指示`Observable.interval()`（甚至`Flowable.interval()`）减慢速度，因为排放在逻辑上是时间敏感的。要求它减慢速度会使基于时间的排放不准确。用户输入事件，如按钮点击，在逻辑上也不能使用背压，因为你不能通过编程来控制用户。
- en: Thankfully, there are some operators that help cope with rapidly firing sources
    without using backpressure and are especially appropriate for situations where
    backpressure cannot be utilized. Some of these operators batch up emissions into
    chunks that are more easily consumed downstream. Others simply sample emissions
    while ignoring the rest. There is even a powerful `switchMap()` operator that
    functions similarly to `flatMap()` but will only subscribe to the `Observable`
    derived from the latest emission and dispose of any previous ones.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一些操作符可以帮助处理快速发射的源，而无需使用背压，并且特别适用于无法使用背压的情况。其中一些操作符将排放批量组合成更易于下游消费的块。其他操作符只是采样排放，忽略其余的。甚至还有一个功能强大的`switchMap()`操作符，它的工作方式类似于`flatMap()`，但只会订阅来自最新排放的`Observable`，并丢弃任何之前的`Observable`。
- en: 'We will cover all of these topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖所有这些主题：
- en: Buffering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲
- en: Windowing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 窗口化
- en: Throttling
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节流
- en: Switching
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切换
- en: We will also end the chapter with an exercise that groups up keystrokes to emit
    strings of user inputs.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以一个练习结束本章，该练习将按键组合起来以发射用户输入的字符串序列。
- en: Buffering
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓冲
- en: The `buffer()` operator will gather emissions within a certain scope and emit
    each batch as a list or another collection type. The scope can be defined by a
    fixed buffer sizing or a timing window that cuts off at intervals or even slices
    by the emissions of another `Observable`.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()`操作符将在一定范围内收集排放，并将每个批次作为列表或其他集合类型发射。范围可以通过固定缓冲区大小或一个在间隔处截断的时间窗口来定义，甚至可以通过另一个`Observable`的排放来切片。'
- en: Fixed-size buffering
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定大小缓冲
- en: 'The simplest overload for `buffer()` accepts a `count` argument that batches
    emissions in that fixed size. If we wanted to batch up emissions into lists of
    eight elements, we can do that as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()`的最简单重载接受一个`count`参数，该参数将排放批量组合成固定大小。如果我们想将排放组合成包含八个元素的列表，我们可以这样做：'
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The output is as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Of course, if the number of emissions does not cleanly divide, the remaining
    elements will be emitted in a final list even if it is less than the specified
    count. This is why the last emission in the preceding code has a list of two elements
    (not eight), containing only `49` and `50`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果排放的数量不能被干净地除尽，剩余的元素将作为一个最终列表发射，即使它少于指定的数量。这就是为什么前一个代码中的最后一个排放有一个包含两个元素（而不是八个）的列表，只包含`49`和`50`。
- en: 'You can also supply a second `bufferSupplier` lambda argument to put items
    in another collection besides a list, such as `HashSet`, as demonstrated here
    (this should yield the same output):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以提供一个第二个`bufferSupplier` lambda 参数，将项目放入除了列表之外的另一个集合中，例如`HashSet`，如下所示（这应该产生相同的输出）：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To make things more interesting, you can also provide a `skip` argument that
    specifies how many items should be skipped before starting a new buffer. If `skip`
    is equal to `count`, the `skip` has no effect. But if they are different, you
    can get some interesting behaviors. For instance, you can buffer `2` emissions
    but skip `3` before the next buffer starts, as shown here. This will essentially
    cause every third element to not be buffered:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情更有趣，你也可以提供一个`skip`参数，该参数指定在开始新的缓冲区之前应该跳过多少项。如果`skip`等于`count`，则`skip`没有效果。但如果它们不同，你可以得到一些有趣的行为。例如，你可以缓冲`2`个排放，但在下一个缓冲区开始之前跳过`3`个，如下所示。这将本质上导致每第三个元素不被缓冲：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you make `skip` less than `count`, you can get some interesting rolling
    buffers. If you buffer items into a size of `3` but have `skip` of `1`, you will
    get rolling buffers. In the following code, for instance, we emit the numbers
    `1` through `10` but create buffers `[1, 2, 3]`, then `[2, 3, 4]`, then `[3, 4,
    5]`, and so on:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`skip`设置为小于`count`，你可以得到一些有趣的滚动缓冲。如果你将项目缓冲到大小为`3`，但`skip`为`1`，你将得到滚动缓冲。例如，在以下代码中，我们发出数字`1`到`10`，但创建缓冲区`[1,
    2, 3]`，然后是`[2, 3, 4]`，然后是`[3, 4, 5]`，依此类推：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output is as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Definitely play with the `skip` argument for `buffer()` , and you may find
    surprising use cases for it. For example, I sometimes use `buffer(2,1)` to emit
    the "previous" emission and the next emission together, as shown here. I also
    use `filter()` to omit the last list , which only contains `10`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一定要玩转`buffer()`的`skip`参数，你可能会发现它的令人惊讶的使用案例。例如，我有时使用`buffer(2,1)`来一起发出“上一个”排放和下一个排放，如下所示。我还使用`filter()`来排除最后一个列表，该列表只包含`10`个元素：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Time-based buffering
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于时间的缓冲
- en: 'You can use `buffer()` at fixed time intervals by providing a long and `TimeUnit`.
    To buffer emissions into a list at 1-second intervals, you can run the following
    code. Note that we are making the source emit every `300` milliseconds, and each
    resulting buffered list will likely contain three or four emissions due to the
    one-second interval cut-offs:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过提供一个长`TimeUnit`在固定时间间隔内使用`buffer()`。要将排放缓冲到每秒一次的列表中，你可以运行以下代码。请注意，我们正在使源每`300`毫秒发出一次，由于一秒的间隔截止，每个结果缓冲列表可能包含三个或四个排放：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is an option to also specify a `timeskip` argument, which is the timer-based
    counterpart to `skip`. It controls the timing of when each buffer starts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以指定一个`timeskip`参数，它是基于时间的`skip`的对应参数。它控制每个缓冲开始的时间。
- en: You can also leverage a third `count` argument to provide a maximum buffer size.
    This will result in a buffer emission at each time interval or when `count` is
    reached, whichever happens first. If the `count` is reached right before the time
    window closes, it will result in an empty buffer being emitted.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以利用第三个`count`参数来提供一个最大缓冲区大小。这将导致在每个时间间隔或`count`达到时发出缓冲排放，以先发生者为准。如果在时间窗口关闭之前`count`达到，将导致发出一个空的缓冲区。
- en: 'Here, we buffer emissions every 1 second, but we limit the buffer size to 2:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们每秒缓冲一次排放，但将缓冲区大小限制为`2`：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output is as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that time-based `buffer()` operators will operate on the computation `Scheduler` .
    This makes sense since a separate thread needs to run on a timer to execute the
    cutoffs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，基于时间的`buffer()`操作符将在计算`Scheduler`上操作。这是有意义的，因为需要在定时器上运行一个单独的线程来执行截止时间。
- en: Boundary-based buffering
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于边界的缓冲
- en: The most powerful variance of `buffer()` is accepting another `Observable` as
    a `boundary` argument. It does not matter what type this other `Observable` emits.
    All that matters is every time it emits something, it will use the timing of that
    emission as the buffer cut-off. In other words, the arbitrary occurrence of emissions
    of another `Observable` will determine when to "slice" each buffer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()`函数最强大的变体是接受另一个`Observable`作为`boundary`参数。这个其他`Observable`发出的类型并不重要。重要的是每次它发出东西时，它都会使用那个排放的时间作为缓冲截止时间。换句话说，另一个`Observable`排放的任意发生将决定何时“切片”每个缓冲区。'
- en: 'For example, we can perform our previous example with 300-millisecond emissions
    buffered every 1-second using this technique. We can have `Observable.interval()`
    of 1 second serve as the boundary for our `Observable.interval()`emitting every
    300 milliseconds:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用这种技术以每 1 秒的间隔缓冲 300 毫秒的发射。我们可以让 `Observable.interval()` 的 1 秒作为我们的
    `Observable.interval()` 每 300 毫秒发射的边界：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is probably the most flexible way to buffer items based on highly variable
    events. While the timing of each slicing is consistent in the preceding example
    (which is every 1 second), the `boundary` can be any `Observable` representing
    any kind of event happening at any time. This idea of an `Observable` serving
    as a cut-off for another `Observable` is a powerful pattern we will see throughout
    this chapter.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是基于高度可变事件缓冲项的最灵活方式。虽然前一个例子中每个切割的时间是一致的（每 1 秒），但 `boundary` 可以是任何表示任何时间发生的任何事件的
    `Observable`。这种 `Observable` 作为另一个 `Observable` 截断的想法是我们将在本章中看到的一个强大的模式。
- en: Windowing
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 窗口
- en: The `window()` operators are almost identical to `buffer()`, except that they
    buffer into other Observables rather than collections. This results in an `Observable<Observable<T>>` that
    emits Observables. Each `Observable` emission will cache emissions for each scope
    and then flush them once subscribed (much like the `GroupedObservable` from `groupBy()`,
    which we worked with in *[Chapter 4](d19b22f4-bb94-4f52-99ab-d03b962d4d16.xhtml),
    Combining Observables*). This allows emissions to be worked with immediately as
    they become available rather than waiting for each list or collection to be finalized
    and emitted. The `window()` operator is also convenient to work with if you want
    to use operators to transform each batch.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`window()` 操作符几乎与 `buffer()` 相同，区别在于它们将缓冲操作应用于其他 Observables 而不是集合。这导致了一个 `Observable<Observable<T>>`，它发射
    Observables。每个 `Observable` 的发射都会为每个作用域缓存发射，然后在订阅后一次性清除（类似于我们在 *[第 4 章](d19b22f4-bb94-4f52-99ab-d03b962d4d16.xhtml)，组合
    Observables*）中使用的 `GroupedObservable`）。这允许在可用时立即处理发射，而不是等待每个列表或集合最终确定并发射。如果你想要使用操作符转换每个批次，`window()`
    操作符也非常方便。'
- en: Just like `buffer()`, you can cut-off each batch using fixed sizing, a time
    interval, or a boundary from another `Observable`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `buffer()` 一样，你可以使用固定大小、时间间隔或来自另一个 `Observable` 的边界来截断每个批次。
- en: Fixed-size windowing
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 固定大小窗口
- en: 'Let''s modify our earlier example, where we buffered 50 integers into lists
    of size 8, but we will use `window()` to buffer them as Observables instead. We
    can reactively transform each batch into something else besides a collection,
    such as concatenating emissions into strings with pipe "`|`" separators:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改之前的例子，其中我们将 50 个整数缓冲到大小为 8 的列表中，但我们将使用 `window()` 来将它们作为 Observables 缓冲。我们可以反应性地将每个批次转换成除了集合之外的其他东西，例如使用管道
    "`|`" 分隔符将发射连接成字符串：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Just like `buffer()`, you can also provide a `skip` argument. This is how many
    emissions need to be skipped before starting a new window. Here, our window size
    is 2, but we skip three items. We then take each windowed `Observable` and reduce it
    to a `String` concatenation:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `buffer()` 一样，你也可以提供一个 `skip` 参数。这是在开始新窗口之前需要跳过的发射数量。这里，我们的窗口大小是 2，但我们跳过了三个项目。然后我们取每个窗口
    Observables 并将其减少到字符串连接：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Time-based windowing
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于时间的窗口
- en: 'As you might be able to guess, you can cut-off windowed Observables at time
    intervals just like `buffer()`. Here, we have an `Observable` emitting every 300
    milliseconds like earlier, and we are slicing it into separate Observables every
    1 second. We will then use `flatMapSingle()` on each `Observable` to a `String`
    concatenation of the emissions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能猜到的，你可以像 `buffer()` 一样在时间间隔内截断窗口 Observables。这里，我们有一个每 300 毫秒发射一次的 `Observable`，我们每
    1 秒将其切割成单独的 Observables。然后我们将对每个 `Observable` 使用 `flatMapSingle()` 来进行发射的字符串连接：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Of course, you can use these yielded Observables for other transformations besides
    `String` concatenations. You can use all the operators we learned up to this point
    to perform different operations on each windowed `Observable`, and you will likely
    do that work in `flatMap()`, `concatMap()`, or `switchMap()`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用这些生成的 Observables 进行除了字符串连接之外的转换。你可以使用我们到目前为止学到的所有操作符对每个窗口 Observables
    执行不同的操作，你很可能会在 `flatMap()`、`concatMap()` 或 `switchMap()` 中完成这项工作。
- en: With time-based `window()` operators, you can also specify `count` or `timeshift`
    arguments, just like its `buffer()` counterpart.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基于时间的`window()`运算符，您也可以指定`count`或`timeshift`参数，就像它的`buffer()`对应物一样。
- en: Boundary-based windowing
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于边界的窗口化
- en: It probably is no surprise that since `window()` is similar to `buffer()` (other
    than that it emits Observables instead of connections), you can also use another
    `Observable` as `boundary`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可能不会令人惊讶，因为`window()`与`buffer()`类似（除了它发射Observables而不是连接），您也可以使用另一个`Observable`作为`boundary`。
- en: 'Here, we use an `Observable.interval()` emitting every 1 second to serve as
    the `boundary` on an `Observable` emitting every 300 milliseconds. We leverage
    each emitted `Observable` to concatenate emissions into concatenated strings:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用每秒发射一次的`Observable.interval()`作为每300毫秒发射一次的`Observable`的`boundary`。我们利用每个发射的`Observable`将发射项连接成连接字符串：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output is as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE22]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, the benefit of using another `Observable` as a `boundary` is that it
    allows you to use the arbitrary timing of emissions from any `Observable` to cut-off
    each window, whether it is a button click, a web request, or any other event.
    This makes it the most flexible way to slice `window()` or `buffer()` operations
    when variability is involved.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用另一个`Observable`作为`boundary`的好处是，它允许您使用任何`Observable`的任意发射时间来切断每个窗口，无论是按钮点击、网络请求还是任何其他事件。这使得它在涉及可变性时成为切片`window()`或`buffer()`操作的最灵活方式。
- en: Throttling
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 节流
- en: The `buffer()` and `window()` operators batch up emissions into collections
    or Observables based on a defined scope, which regularly consolidates rather than
    omits emissions.The `throttle()` operator, however, omits emissions when they
    occur rapidly. This is helpful when rapid emissions are assumed to be redundant
    or unwanted, such as a user clicking on a button repeatedly. For these situations,
    you can use the `throttleLast()`, `throttleFirst()`, and `throttleWithTimeout()`
    operators to only let the first or last element in a rapid sequence of emissions
    through. How you choose one of the many rapid emissions is determined by your
    choice of operator, parameters, and arguments.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`buffer()`和`window()`运算符根据定义的范围将发射项批量收集到集合或Observables中，它们会定期合并而不是省略发射项。然而，`throttle()`运算符在发射项快速发生时省略发射项。这在快速发射被认为是冗余或不需要时很有用，例如用户反复点击按钮。对于这些情况，您可以使用`throttleLast()`、`throttleFirst()`和`throttleWithTimeout()`运算符，只让快速发射序列中的第一个或最后一个元素通过。您选择众多快速发射中的哪一个取决于您选择的运算符、参数和参数。'
- en: 'For the examples in this section, we are going to work with this case: we have
    three `Observable.interval()` sources, the first emitting every 100 milliseconds,
    the second every 300 milliseconds, and the third every 2000 milliseconds. We only
    take 10 emissions from the first source, three from the second, and two from the
    third. As you can see here, we will use `Observable.concat()` on them together
    in order to create a rapid sequence that changes pace at three different intervals:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本节中的示例，我们将处理以下情况：我们有三个`Observable.interval()`源，第一个每100毫秒发射一次，第二个每300毫秒发射一次，第三个每2000毫秒发射一次。我们从第一个源中只取10个发射项，从第二个源中取3个，从第三个源中取2个。正如您所看到的，我们将使用`Observable.concat()`将它们一起使用，以创建一个在不同间隔下改变节奏的快速序列：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first source rapidly pushes 10 emissions within a second, the second pushes
    three within a second, and the third pushes two within four seconds. Let's use
    some `throttle()` operators to only choose a few of these emissions and ignore
    the rest.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个源在1秒内快速推送10个发射项，第二个在1秒内推送3个，第三个在4秒内推送2个。让我们使用一些`throttle()`运算符来只选择其中的一些发射项，忽略其余的。
- en: throttleLast() / sample()
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: throttleLast() / sample()
- en: 'The `throttleLast()` operator (which is aliased as `sample()`) will only emit
    the last item at a fixed time interval. Modify your earlier example to use `throttleLast()`
    at 1-second intervals, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleLast()`运算符（别名`sample()`）将仅在固定时间间隔内发出最后一个项目。修改您之前的示例，以每秒1次的时间间隔使用`throttleLast()`，如下所示：'
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The output is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you study the output, you can see that the last emission at every 1-second
    interval was all that got through. This effectively samples emissions by dipping
    into the stream on a timer and pulling out the latest one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您研究输出，您可以看到，每个1秒间隔的最后一个发射项是唯一通过的那个。这实际上通过定时器深入流中并拉出最新的一个来有效地采样发射项。
- en: 'If you want to throttle more liberally at larger time intervals, you will get
    fewer emissions as this effectively reduces the sample frequency. Here, we use `throttleLast()`
    every two seconds:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在较长的时间间隔内更自由地节流，你会得到更少的发射，因为这实际上减少了采样频率。这里，我们每两秒使用一次 `throttleLast()`：
- en: '[PRE27]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If you want to throttle more aggressively at shorter time intervals, you will
    get more emissions, as this increases the sample frequency. Here, we use `throttleLast()`
    every 500 milliseconds:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在较短的时间间隔内更积极地节流，你会得到更多的发射，因为这样可以增加采样频率。这里，我们每 500 毫秒使用一次 `throttleLast()`：
- en: '[PRE29]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The output is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Again, `throttleLast()` will push the last emission at every fixed time interval.
    Next, we will cover `throttleFirst()`, which emits the first item instead.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，`throttleLast()` 将在每个固定的时间间隔推进最后一个发射。接下来，我们将介绍 `throttleFirst()`，它将发出第一个项目。
- en: throttleFirst()
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: throttleFirst()
- en: 'The `throttleFirst()` operates almost identically to `throttleLast()`, but
    it will emit the *first* item that occurs at every fixed time interval. If we
    modify our example to `throttleFirst()` every 1 second, we should get an output
    like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleFirst()` 几乎与 `throttleLast()` 操作相同，但它会在每个固定的时间间隔发出发生的第一个项目。如果我们修改我们的例子为每
    1 秒使用一次 `throttleFirst()`，我们应该得到如下输出：'
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Effectively, the first emission found after each interval starts is the emission
    that gets pushed through. The 100 from `source1` was the first emission found
    on the first interval. On the next interval, 300 from `source2` was emitted, then
    2000, followed by 4000\. The 4000 was emitted right on the cusp of the application
    quitting, hence we got four emissions from `throttleFirst()` as opposed to three
    from `throttleLast()`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每个间隔开始后找到的第一个发射就是被推过的发射。`source1` 的 100 是在第一个间隔中找到的第一个发射。在下一个间隔中，`source2`
    发出了 300，然后是 2000，接着是 4000。4000 正好在应用退出之前发出，因此我们得到了 `throttleFirst()` 的四个发射，而不是
    `throttleLast()` 的三个。
- en: Besides the first item being emitted rather than the last at each interval,
    all the behaviors from `throttleLast()` also apply to `throttleFirst()`. Specifying
    shorter intervals will yield more emissions, whereas longer intervals will yield
    less.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在每个间隔发出第一个项目而不是最后一个项目之外，`throttleLast()` 的所有行为也适用于 `throttleFirst()`。指定较短的间隔会产生更多的发射，而较长的间隔会产生较少的发射。
- en: Both `throttleFirst()` and `throttleLast()` emit on the computation `Scheduler`,
    but you can specify your own `Scheduler` as a third argument.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleFirst()` 和 `throttleLast()` 都会在计算 `Scheduler` 上发出，但你也可以将你自己的 `Scheduler`
    作为第三个参数指定。'
- en: throttleWithTimeout() / debounce()
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: throttleWithTimeout() / debounce()
- en: If you play with `throttleFirst()` and `throttleLast()`, you might be dissatisfied
    with one aspect of their behavior. They are agnostic to the variability of emission
    frequency, and they simply "dip in" at fixed intervals and pull the first or last
    emission they find. There is no notion of waiting for a "period of silence" where
    emissions stop for a moment, and that might be an opportune time to push the last
    emission that occurred forward.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你玩 `throttleFirst()` 和 `throttleLast()`，你可能会对它们行为的一个方面感到不满意。它们对发射频率的变化是盲目的，并且它们只是简单地“插入”在固定的时间间隔，并拉取它们找到的第一个或最后一个发射。没有等待“沉默期”的概念，其中发射暂时停止，这可能是一个推进最后发生发射的好时机。
- en: Think of Hollywood action movies where a protagonist is under heavy gunfire.
    While bullets are flying, he/she has to take cover and is unable to act. But the
    moment their attackers stop to reload, there is a period of silence where they
    have time to react. This is essentially what `throttleWithTimout()` does. While
    emissions are firing rapidly, it will not emit anything until there is a "period
    of silence", and then it will push the last emission forward.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下好莱坞动作电影，其中主角在遭受猛烈的枪战中。当子弹横飞时，他/她必须躲避并无法行动。但是，当他们的攻击者停下来装弹时，会有一个沉默期，他们有时间做出反应。这正是
    `throttleWithTimeout()` 所做的。当发射快速发生时，它不会发出任何东西，直到有一个“沉默期”，然后它会推进最后的发射。
- en: '`throttleWithTimout()` (also called `debounce()`) accepts time interval arguments
    that specify how long a period of inactivity (which means no emissions are coming
    from the source) must be before the last emission can be pushed forward. In our
    earlier example, our three concatenated `Observable.interval()` sources are rapidly
    firing at 100 milliseconds and then 300-millisecond spurts for approximately 2
    seconds. But after that, intervals slow down to every 2 seconds. If we wanted
    to only emit after 1 second of silence, we are not going to emit anything until
    we hit that third `Observable.interval()`, emitting every 2 seconds, as shown
    here:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleWithTimout()`（也称为 `debounce()`）接受时间间隔参数，指定在最后一次发射可以推进之前必须有一段多长时间的不活跃期（这意味着没有发射来自源）。在我们的早期示例中，我们的三个连接的
    `Observable.interval()` 源以每 100 毫秒的速度快速发射，然后是大约 2 秒的 300 毫秒爆发。但之后，间隔减慢到每 2 秒一次。如果我们只想在
    1 秒的静默期后发射，我们不会发射任何东西，直到我们达到第三个 `Observable.interval()`，它每 2 秒发射一次，如下所示：'
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The output is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The 900 emission from `source2` was the last emission as soon as `source3` started,
    since `source3` will not push its first emission for 2 seconds, which gave more
    than the needed 1-second period of silence for the 900 emission to be fired. The
    2000 emission then emitted next and 1 second later no further emissions occurred,
    so it was pushed forward by `throttleWithTimeout()`. Another second later, the
    4000 emission was pushed and the 2-second silence (before the program exited)
    allowed it to fire as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `source3` 开始时，`source2` 的 900 次发射就是最后一次发射，因为 `source3` 将不会在 2 秒内推送其第一次发射，这为
    900 次发射提供了超过所需的 1 秒静默期。然后，2000 次发射紧接着发生，1 秒后没有进一步的发射发生，因此它被 `throttleWithTimeout()`
    推进。另一秒后，4000 次发射被推送，2 秒的静默期（在程序退出之前）也允许它发射。
- en: The `throttleWithTimeout()` is an effective way to handle excessive inputs (such
    as a user clicking on a button rapidly) and other noisy, redundant events that
    sporadically speed up, slow down, or cease. The only disadvantage of `throttleWithTimeout()`
    is that it will delay each winning emission. If an emission does make it through
    `throttleWithTimeout()`, it will be delayed by the specified time interval in
    order to ensure no more emissions are coming. Especially for user experiences,
    this artificial delay may be unwelcome. For these situations, which are sensitive
    to delays, a better option might be to leverage `switchMap()`, which we will cover
    next.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`throttleWithTimeout()` 方法是一种处理过多输入（例如用户快速点击按钮）和其他噪声、冗余事件的有效方式，这些事件会偶尔加速、减速或停止。`throttleWithTimeout()`
    的唯一缺点是它将延迟每个获胜的发射。如果一个发射成功通过了 `throttleWithTimeout()`，它将被延迟指定的时间间隔，以确保没有更多的发射。特别是对于用户体验来说，这种人为的延迟可能不受欢迎。对于这些对延迟敏感的情况，一个更好的选择可能是利用
    `switchMap()`，我们将在下一节中介绍。'
- en: Switching
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 切换
- en: 'In RxJava, there is a powerful operator called `switchMap()`. Its usage feels
    like `flatMap()`, but it has one important behavioral difference: it will emit
    from the latest `Observable` derived from the latest emission and dispose of any
    previous Observables that were processing. In other words, it allows you to cancel
    an emitting `Observable` and switch to a new one, preventing stale or redundant
    processing.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 RxJava 中，有一个功能强大的操作符称为 `switchMap()`。它的使用感觉像 `flatMap()`，但它有一个重要的行为差异：它将从最新的发射中派生的最新
    `Observable` 发射，并丢弃任何之前正在处理的 `Observable`。换句话说，它允许你取消一个正在发射的 `Observable` 并切换到新的一个，防止过时或冗余的处理。
- en: 'Say we have a process that emits nine strings, and it delays each string emission
    randomly from 0 to 2000 milliseconds. This is to emulate an intense calculation
    done to each one, as demonstrated here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个发射九个字符串的过程，并且它将每个字符串发射的延迟随机设置为 0 到 2000 毫秒。这是为了模拟对每个字符串进行的密集计算，如下所示：
- en: '[PRE35]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output is as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As you can tell, each emission takes between 0-2 seconds to be emitted, and
    processing all the strings can take up to 20 seconds.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每次发射需要 0-2 秒的时间来发射，处理所有字符串可能需要长达 20 秒。
- en: 'Say we want to run this process every 5 seconds, but we want to cancel (or
    more technically, `dispose()`) previous instances of the process and only run
    the latest one. This is easy to do with `switchMap()`. Here, we create another
    `Observable.interval()`, emitting every 5 seconds and then we use `switchMap()` on
    it to the `Observable` we want to process (which in this case is `processStrings`).
    Every 5 seconds, the emission going into `switchMap()` will promptly dispose of
    the currently processing `Observable` (if there are any) and then emit from the
    new `Observable` it maps to. To prove that `dispose()` is being called, we will
    put `doOnDispose()` on the `Observable` inside `switchMap()` to display a message:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要每5秒运行这个过程，但我们想取消（或更技术性地，`dispose()`）之前的过程实例，并且只运行最新的一个。使用`switchMap()`可以轻松做到这一点。在这里，我们创建另一个`Observable.interval()`，每5秒发射一次，然后我们使用`switchMap()`将其映射到我们想要处理`Observable`（在这种情况下是`processStrings`）。每5秒，进入`switchMap()`的发射将立即销毁当前正在处理的`Observable`（如果有），然后从它映射的新`Observable`中发射。为了证明`dispose()`被调用，我们将在`switchMap()`内部的`Observable`上放置`doOnDispose()`来显示一条消息：
- en: '[PRE37]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output is as follows (yours will be different):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下（你的输出将不同）：
- en: '[PRE38]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Again, `switchMap()` is just like `flatMap()` except that it will cancel any
    previous Observables that were processing and only chase after the latest one.
    This can be helpful in many situations to prevent redundant or stale work and
    is especially effective in user interfaces where rapid user inputs create stale
    requests. You can use it to cancel database queries, web requests, and other expensive
    tasks and replace it with a new task.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`switchMap()`就像`flatMap()`一样，但它将取消任何之前正在处理的Observables，并且只追踪最新的一个。这在许多情况下都有助于防止冗余或过时的工作，并且在用户界面中，快速的用户输入产生过时请求时尤其有效。你可以用它来取消数据库查询、网络请求和其他昂贵的任务，并用新任务替换它们。
- en: For `switchMap()` to work effectively, the thread pushing emissions into `switchMap()`
    cannot be occupied doing the work inside `switchMap()`. This means that you may
    have to use `observeOn()` or `subscribeOn()` inside `switchMap()` to do work on
    a different thread. If the operations inside `switchMap()` are expensive to stop
    (for instance, a database query using RxJava-JDBC), you might want to use `unsubscribeOn()`
    as well to keep the triggering thread from becoming occupied with disposal.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`switchMap()`有效，将发射推入`switchMap()`的线程不能被`switchMap()`内部的工作占用。这意味着你可能需要在`switchMap()`内部使用`observeOn()`或`subscribeOn()`在不同的线程上执行工作。如果`switchMap()`内部的操作难以停止（例如，使用RxJava-JDBC的数据库查询），你可能还想使用`unsubscribeOn()`，以防止触发线程在销毁时被占用。
- en: 'A neat trick you can do to cancel work within `switchMap()` (without providing
    new work immediately) is to conditionally yield `Observable.empty()`. This can
    be helpful to cancel a long-running or infinite process. For example, if you bring
    in  RxJavaFX ([https://github.com/ReactiveX/RxJavaFX](https://github.com/ReactiveX/RxJavaFX))
    as a dependency, we can quickly create a stop watch application using `switchMap()`,
    as shown in the following code snippet:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`switchMap()`（不立即提供新工作）内取消工作的一个小技巧是条件性地返回`Observable.empty()`。这有助于取消长时间运行或无限过程。例如，如果你将RxJavaFX
    ([https://github.com/ReactiveX/RxJavaFX](https://github.com/ReactiveX/RxJavaFX))作为依赖项引入，我们可以快速创建一个使用`switchMap()`的计时器应用程序，如下面的代码片段所示：
- en: '[PRE39]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The code preceding yields  a stopwatch application that uses `switchMap()`
    , as shown below in Figure 7.1:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码生成了一个使用`switchMap()`的计时器应用程序，如下面图7.1所示：
- en: '![](img/e7a2a8e1-573d-4e78-9fc6-a798cfea939b.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e7a2a8e1-573d-4e78-9fc6-a798cfea939b.png)'
- en: Figure 7.1 - A stopwatch application that uses switchMap()
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 - 使用switchMap()的计时器应用程序
- en: Pressing the `ToggleButton` will start and stop the stopwatch, which displays
    in milliseconds. Note that the `ToggleButton` will emit a Boolean `True`/`False`
    value through an `Observable` called `selectedStates`. We multicast it to prevent
    duplicate listeners on JavaFX, and we have two Observers. The first will use `switchMap()` on
    each Boolean value, where `true` will emit from an `Observable.interval()` every
    millisecond, and `false` will cancel it by replacing it with an `Observable.empty()`.
    Since `Observable.interval()` will emit on a `Scheduler` computation, we will
    use `observeOn()` to put it back on the JavaFX `Scheduler` provided by RxJavaFX.
    The other `Observer` will change the text of the `ToggleButton` to STOP or START
    depending on its state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 按压`ToggleButton`将开始和停止计时器，它以毫秒为单位显示。注意，`ToggleButton`将通过一个名为`selectedStates`的`Observable`发出布尔值`True`/`False`。我们通过`share()`进行多播以防止JavaFX上的重复监听器，并且我们有两个观察者。第一个将使用`switchMap()`对每个布尔值进行操作，其中`true`将每毫秒从`Observable.interval()`发出，而`false`将通过替换为`Observable.empty()`来取消它。由于`Observable.interval()`将在`Scheduler`计算上发出，我们将使用`observeOn()`将其放回由RxJavaFX提供的JavaFX
    `Scheduler`上。另一个观察者将根据其状态将`ToggleButton`的文本更改为STOP或START。
- en: Grouping keystrokes
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合按键
- en: 'We will wrap up this chapter by integrating most of what we learned and achieve
    a complex task: grouping keystrokes that happen in rapid succession to form strings
    without any delay! It can be helpful in user interfaces to immediately "jump"
    to items in a list based on what is being typed or perform auto-completion in
    some way. This can be a challenging task, but as we will see, it is not that difficult
    with RxJava.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过整合我们所学的大部分内容来结束本章，完成一个复杂任务：将快速连续发生的按键组合成字符串，而没有任何延迟！这在用户界面中可以立即根据输入的内容“跳转”到列表中的项目，或者以某种方式执行自动完成。这可能是一个具有挑战性的任务，但正如我们将看到的，使用RxJava并不那么困难。
- en: 'This exercise will use JavaFX again with RxJavaFX. Our user interface will
    simply have a `Label` that receives rolling concatenations of keys we are typing.
    But after 300 milliseconds, it will reset and receive an empty  `""` to clear
    it. Here is the code that achieves this as well as some screenshots with the console
    output when I type "`Hello`" and then type "`World`" a moment later:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将再次使用JavaFX和RxJavaFX。我们的用户界面将简单地有一个`Label`，它接收我们输入的按键的滚动连接。但300毫秒后，它将重置并接收一个空的`""`来清除它。以下是实现此功能的代码，以及一些当我在输入"`Hello`"后稍后输入"`World`"时的控制台输出截图：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output is as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is the rendered UI:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这是渲染的UI：
- en: '![](img/61d41975-4212-48e6-b50f-176d36589673.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/61d41975-4212-48e6-b50f-176d36589673.png)'
- en: When you type keys, the `Label` will display a rolling `String` concatenation
    of their characters in live time on both the UI as well as the console. Note that
    after 500 milliseconds of no activity, it resets and emits a new `scan()` operation
    and disposes of the old one, starting with an empty `""` string. This can be enormously
    helpful to instantly send search requests or autocomplete suggestions while the
    user is typing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当你输入按键时，`Label`将在UI和控制台上实时显示按键字符的滚动连接字符串。注意，在500毫秒的无活动后，它将重置并发出一个新的`scan()`操作，并丢弃旧的，从空字符串`""`开始。这可以在用户输入时立即发送搜索请求或自动完成建议，非常有帮助。
- en: The way it works is that we have an `Observable` emitting the characters that
    were pressed on the keyboard, but it is multicast with `share()` and used for
    two purposes. It is first used to create another `Observable` that signals the
    last character typed after 500 milliseconds of inactivity. But we do not care
    about the character as much as the emission's timing, which signals 500 milliseconds
    of inactivity has occurred. We then use `switchMap()` on it to the `Observable`
    emitting the characters again, and we infinitely concatenate each typed character
    in succession and emit each resulting string. However, this `scan()` operation
    in `switchMap()` will be disposed of when 500 milliseconds of inactivity occurs
    and start over with a new `scan()` instance.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作方式是我们有一个`Observable`发出键盘上按下的字符，但它通过`share()`进行多播，用于两个目的。首先，它用于创建另一个`Observable`，在500毫秒的无活动后发出最后输入的字符。但我们更关心的是发射的时机，它表示500毫秒的无活动已经发生。然后我们使用`switchMap()`将其映射到再次发出字符的`Observable`上，并无限地连续连接每个输入的字符，并发出每个结果字符串。然而，这个`switchMap()`中的`scan()`操作将在500毫秒的无活动发生时被丢弃，并使用一个新的`scan()`实例重新开始。
- en: If you find this example dizzying, take your time and keep studying it. It will
    click ultimately and once it does, you will have truly mastered the ideas in this
    chapter!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你觉得这个例子令人头晕，请慢慢来，继续学习。最终你会恍然大悟，一旦你做到了，你就真正掌握了本章中的思想！
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to leverage buffering, windowing, throttling,
    and switching to cope with rapidly emitting Observables. Ideally, we should leverage
    Flowables and backpressure when we see that Observables are emitting faster than
    the Observers can keep up with, which we will learn about in the next chapter.
    But for situations where backpressure cannot work, such as user inputs or timer
    events, you can leverage these three categories of operations to limit how many
    emissions are passed downstream.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何利用缓冲、窗口、节流和切换来应对快速发射的 Observables。理想情况下，当我们看到 Observables 的发射速度超过了
    Observers 的处理能力时，我们应该利用 Flowables 和背压。我们将在下一章中学习这一点。但对于无法使用背压的情况，例如用户输入或定时器事件，你可以利用这三种操作类别来限制向下传递的发射数量。
- en: In the next chapter, we will learn about backpressuring with Flowables, which
    provides more proactive ways to cope with common cases of rapid emissions overwhelming
    Observers.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何使用 Flowables 进行背压，这提供了更主动的方式来应对快速发射压倒 Observers 的常见情况。
