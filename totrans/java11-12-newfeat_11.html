<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Flight Recorder and Mission Control</h1>
                </header>
            
            <article>
                
<p><strong>Java Flight Recorder</strong> (<strong>JFR</strong>) is a high-performance, low-overhead profiler that is built into the JVM. It is a data collection framework that records events that you can use to troubleshoot your Java applications and HotSpot JVM.</p>
<p>JFR records the events from OS, HotSpot JVM, and JDK binary events as <strong>binary data</strong>. This essentially means that you need a parser, such as <strong>Mission Control</strong> (<strong>MC</strong>), to make sense of this binary data.</p>
<p>MC is an advanced tool for program developers and administrators to analyze the data collected by the JFR profiler in detail. It can be used to analyze the data collected for applications running in local or remote environments.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>The need for JFR and MC</li>
<li>Features of JFR and MC</li>
<li>Usage of JFR and MC</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>JFR is included in the OpenJDK distributions from Java 11. Depending on which JDK distribution you are using, you might need to download and install MC separately. <strong>Java Mission Control</strong> (<strong>JMC</strong>) is not part of the OpenJDK distribution. It has been a part of OracleJDK since JDK version 7, update 40.</p>
<p>If JMC is not included in your JDK, you can download it from <a href="https://jdk.java.net/jmc/"><span class="URLPACKT">https://jdk.java.net/jmc/</span></a>.</p>
<p class="mce-root"/>
<p>All code in this chapter can be accessed from <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a><span class="URLPACKT">.</span></p>
<p>Let's get started with exploring why we need JFR.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The motivation behind JFR</h1>
                </header>
            
            <article>
                
<p>Vaults at banks are created with near zero defects, but they aren't invincible. Imagine what happens after the vault of a bank is broken. One of the steps might include scanning the security camera footage—to check <em>when</em> and <em>how</em> the theft happened. This can lead to varied results—from determining the cause of fixing the issues and formulating measures to prevent it from happening in the future.</p>
<p>Similarly, you can never foresee all the challenges with your application in production. A profiler, such as JFR, helps you to record the events when your application is executing. When your application crashes or doesn't perform as expected, you can monitor or troubleshoot it, using the data collected by the profiler. This data can provide you with the feedback loop.</p>
<p>MC reads the application profiling data recorded by JFR and displays it <em>visually</em>, on varied values (hence saving you from wading through piles of text).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Features</h1>
                </header>
            
            <article>
                
<p>JFR can record a whole lot of events—from your applications to your JVM to the OS. It is a high performance, but low overhead profiler.</p>
<p>JFR extends the capabilities of <strong>event-based JVM tracing</strong> (JEP 167), which adds an initial set of events to HotSpot, to create events in Java. It also provides a high-performance backend to write data from the events to a binary format.</p>
<p>MC displays the application profiling data collected by JFR in a visual environment. You can select the category you want to analyze—from class loading to JVM internals (such as garbage collection), application threads, memory allocation, to complete application data analysis. We'll work with some of the MC features in this chapter (complete coverage of all of its features is beyond the scope of this book).</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modules</h1>
                </header>
            
            <article>
                
<p>JFR defines the following modules:</p>
<ul>
<li><kbd>jdk.jfr</kbd>: This defines the API and internals for the JFR profiler. You can use it to profile your applications that run on resource-constrained devices such as the <strong>IoT</strong> (short for <strong>Internet of Things</strong>) or mobile devices. <kbd>Jdk.jfr</kbd> only needs the <kbd>java.base</kbd> module.</li>
<li><kbd>jdk.management.jfr</kbd>: To use flight recording remotely over <strong>Java Management Extensions</strong> (<strong>JMX</strong>), you can use this module. It requires the <kbd>jdk.jfr</kbd> and <kbd>jdk.management</kbd> modules.</li>
</ul>
<p>We won't cover the code of JMC, just its features and how to use them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with JFR</h1>
                </header>
            
            <article>
                
<p>Let's get started with a simple <kbd>HelloWorld</kbd> example, as follows:</p>
<pre>class HelloWorld { 
    public static void main(String[] args) { 
        System.out.println("Hello World - This is being recorded"); 
    } 
} </pre>
<p>To start flight recording for the preceding application, execute the following command on your console:</p>
<pre>  <strong>&gt; java -XX:StartFlightRecording,filename=hello.jfr </strong>
  <strong>   HelloWorld</strong>  </pre>
<p>The first line instructs the Java Runtime to start flight recording for your <kbd>HelloWorld</kbd> application and save it to the <kbd>HelloWorldRecording.jfr</kbd> file.</p>
<p>There are three parts to the previous command, as follows:</p>
<ul>
<li>Starting JFR with the <kbd>-XX:StartFlightRecording</kbd> <span>JVM option</span></li>
<li>Specifying the target file to save the recording to <kbd>hello.jfr</kbd></li>
<li>Specifying the application to run <kbd>HelloWorld</kbd></li>
</ul>
<p class="mce-root"/>
<p>Let's start MC to view the profiling data stored in <kbd>hello.jfr</kbd>. Use the <kbd>jmc.exe</kbd> file to start JMC. You'll see a window similar to the following screenshot:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/b06ed055-bc05-4aa2-af2b-759c0bea5d06.png"/></div>
<p>Click on the <span class="packt_screen">Click here to start using JDK Mission Control</span> option at the bottom. Using the <span class="packt_screen">File</span> | <span class="packt_screen">Open</span> menu options, open the <kbd>hello.jfr</kbd> file you previously created. Here's what it displays at the <span class="packt_screen">Automated Analysis Results</span> <span>landing page:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c7413d7b-d5b6-446a-b412-8d95df0103d0.png"/></div>
<p class="mce-root"/>
<p><span class="packt_screen">Processes</span> are not the only category on which MC analyzes your application. Depending on your application and how it is profiled, additional categories are included (you can see a few of them in the preceding screenshot).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring further</h1>
                </header>
            
            <article>
                
<p>Let's profile another application that creates a lot of (<kbd>500</kbd>) threads; each thread creates <kbd>ArrayList</kbd> of 1,000,000 <kbd>Double</kbd> values, populating it with random numbers:</p>
<pre>class AThread implements Runnable { 
    String name = "default"; 
    private Random numGenerator = new Random(); 
    private ArrayList&lt;Double&gt; list = new ArrayList&lt;Double&gt;(10_00_000); 
 
    AThread(String name) { 
        this.name = name; 
    } 
    public void run() { 
        for (int i = 0; i &lt; 10_00_000; i++) { 
            list.add(numGenerator.nextDouble()); 
            System.out.println("Allocated : " + name + "[" + i + "]"); 
        } 
    } 
} 
public class TestFlightRecorder { 
    public static void main(String... args) throws Exception { 
        for (int i = 0; i &lt; 500; i++) { 
            new Thread(new AThread("Thread" + i)).start(); 
        } 
    } 
} </pre>
<p>Let's execute the preceding <kbd>TestFlightRecorder</kbd> application, profiling it with JFR using Epsilon GC (to check whether we also get any data on the memory allocation) for 10 seconds:</p>
<pre>    <strong>&gt; java </strong>
    <strong>  -XX:+UnlockExperimentalVMOptions </strong>
    <strong>  -XX:+UseEpsilonGC </strong>
    <strong>  -XX:StartFlightRecording,filename=Epsilon.jfr </strong>
    <strong>     TestFlightRecorder</strong></pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Here's the landing page when you open <kbd>Epsilon.jfr</kbd> in MC:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0dcd6516-9ee2-4eec-b9ea-14c8c2d2c0b9.png"/></div>
<p>Before we discuss the results shown by MC in detail, let's quickly revisit the <kbd>TestFlightRecorder</kbd> application that was profiled. <kbd>TestFlightRecorder</kbd> creates 500 instances of the <kbd>AThread</kbd> class. The <kbd>AThread</kbd> class implements <kbd>Runnable</kbd>. On starting, each <kbd>AThread</kbd> instance creates <kbd>ArrayList</kbd> of 1,000,000 <kbd>Double</kbd> values, populates them with random values and outputs them to the console.</p>
<p>Let's visit the preceding screenshot now—MC displays a consolidated report on how your application fares overall. It includes the environment of the machine that is executing your Java application, the JVM internals, and blocking of threads on locks in your application. Here's a quick listing of these categories:</p>
<ul>
<li><span class="packt_screen">Java Application</span></li>
<li><span class="packt_screen">Context Switches</span> (indent)</li>
<li><span class="packt_screen">Java Blocking</span> (indent)</li>
<li><span class="packt_screen">JVM Internals</span></li>
<li><span class="packt_screen">Environment</span></li>
</ul>
<p class="mce-root"/>
<p>Since MC reports that this application is performing poorly on the <span class="packt_screen">Context Switches</span> and thread blocking categories, let's browse through the options under the <span class="packt_screen">Java Application</span> category on the left-side panel menu in <span>MC </span>and figure out which option will include the relevant information. As you will notice, the <span class="packt_screen">Lock Instances</span> option displays an exclamation mark right next to it. The following screenshot indicates what you will see when you click on it:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/bd8022f4-20c7-4fee-a25b-fdf927d52134.png"/></div>
<p>The preceding screenshot shows that all 500 threads that you created in the <kbd>TestFlightRecorder</kbd> application were blocking on <kbd>PrintStream</kbd> and <kbd>Object</kbd>. It even displays the total blocked time, that is, 2 hours and 40 minutes (calculated collectively for all blocked threads—for 20 seconds of application profiling).</p>
<p>Since the JFR profiler records the profiled data in a binary format to a file, you can view this data with MC at a later time and figure out a whole lot of other issues. For instance, if you click on <span class="packt_screen">Processes</span>, you'll know that your CPU is being used by a lot of other processes that are being executed on your host machine, which can also include auto software updates. Make sure you switch all of these off. Let's say you are tuning the performance of your application on the server.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Here's what you see if you click on <span class="packt_screen">Processes</span> in MC (of course, the results will vary across systems):</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/9d816b66-3332-4b5f-87a1-fdbc9e91850b.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Working with custom events</h1>
                </header>
            
            <article>
                
<p>As a developer, you can also create your own custom events using the JFR API and view and analyze them using MC. Here's an example; let's define a custom event:</p>
<pre>class MyEvent extends Event { 
   @Label("EventMessage") 
   String message; 
} </pre>
<p>Now let's modify the <kbd>AThread</kbd> class to use events, instead of printing to console:</p>
<pre>class AThread implements Runnable { 
    String name = "default"; 
    private Random numGenerator = new Random(); 
    private ArrayList&lt;Double&gt; list = new ArrayList&lt;Double&gt;(1000000); 
 
    AThread(String name) { 
        this.name = name; 
    } 
 
    public void run() { 
        MyEvent event; 
        for (int i = 0; i &lt; 1000000; i++) { 
            list.add(numGenerator.nextDouble()); 
            event = new MyEvent(); 
            event.message = "Allocated : " + name + "[" + i + "]"; 
            event.commit(); 
        } 
    } 
} 
public class WithCustomEvents { 
    public static void main(String... args) throws Exception { 
        for (int i = 0; i &lt; 500; i++) { 
            new Thread(new AThread("Thread" + i)).start(); 
        } 
    } 
} </pre>
<p>You can use the same command line options to execute your application, profiling it with JFR:</p>
<pre>    <strong>&gt; java </strong>
    <strong>  -XX:StartFlightRecording,filename=CustomEvents.jfr </strong>
    <strong>     WithCustomEvents</strong></pre>
<p>Now, instead of using MC to view these events, you can create another application that reads the logged events from <kbd>CustomEvents.jfr</kbd>, as follows:</p>
<pre>class ReadFRData { 
    public static void main(String args[]) throws Exception { 
        Path p = Paths.get("CustomEvents.jfr"); 
        for (RecordedEvent e : RecordingFile.readAllEvents(p)) { 
           System.out.println(e.getStartTime() +  
                              " : " +  
                              e.getValue("message")); 
        } 
    } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about the JFR profiler. With JFR, a high performance, low overhead profiler, built into the JVM, you won't need to rely on third-party profilers to troubleshoot your Java applications and HotSpot JVM.</p>
<p>We also covered MC—an advanced tool for developers and administrators to analyze the data collected by JFR in detail—visually, in local and remote environments.</p>
<p><span>In the next chapter, we'll cover multiple improvements and additions in JDK 11.</span></p>


            </article>

            
        </section>
    </body></html>