<html><head></head><body>
		<div id="_idContainer146">
			<h1 id="_idParaDest-162"><em class="italic"><a id="_idTextAnchor169"/>Chapter 9</em>: GraalVM Polyglot – LLVM, Ruby, and WASM</h1>
			<p>In the previous chapter, we covered Truffle interpreters for Java, Python, and R and interoperability between languages. In this chapter, we will cover other languages' implementations, such as the following:</p>
			<ul>
				<li><strong class="bold">LLVM</strong>: The LLVM Truffle interpreter</li>
				<li><strong class="bold">TruffleRuby</strong>: The Ruby language interpreter implementation</li>
				<li><strong class="bold">WebAssembly</strong> (<strong class="bold">WASM</strong>): WebAssembly implementation</li>
			</ul>
			<p>All of these language implementations are still in the <em class="italic">experimental</em> phase and are not released for production, at the time of writing this book. However, we will explore the features and build some code to understand the various concepts. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding LLVM, Ruby, and WASM interpreters and their polyglot features</li>
				<li>Understanding the compatibility and limitations of these various language interpreters</li>
			</ul>
			<p>By the end of this chapter, you will have had hands-on experience in building polyglot applications with LLVM, Ruby, and WASM interpreters.</p>
			<h1 id="_idParaDest-163"><a id="_idTextAnchor170"/>Technical requirements</h1>
			<p>This chapter requires the following to follow along with the various coding/hands-on sections:</p>
			<ul>
				<li>The latest version of GraalVM.</li>
				<li>Various language Graal runtimes. We will cover in the chapter how to install and run these runtimes.</li>
				<li>Access to GitHub. There are some sample code snippets that are available on the Git repository. The code can be downloaded from the following link: <a href="https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter09">https://github.com/PacktPublishing/Supercharge-Your-Applications-with-GraalVM/tree/main/Chapter09</a>.</li>
				<li>The Code in Action video for this chapter can be found at <a href="https://bit.ly/3hT7Z1A">https://bit.ly/3hT7Z1A</a>.</li>
			</ul>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor171"/>Understanding LLVM – the (Sulong) Truffle interface</h1>
			<p>LLVM is a compiler infrastructure that provides a modular, reusable set of compiler components that <a id="_idIndexMarker698"/>can form a toolchain to compile source code to machine code. The toolchain provides various levels of optimization, on an <strong class="bold">intermediate representation</strong> (<strong class="bold">IR</strong>). Any <a id="_idIndexMarker699"/>source language can use this toolchain, as long as the source code can be represented as an LLVM IR. Once the source <a id="_idIndexMarker700"/>code is represented as an LLVM IR, that language can utilize the advanced optimization techniques that LLVM provides. You can refer to the LLVM project at <a href="https://llvm.org/">https://llvm.org/</a>. There are various compilers that are already built on this infrastructure. Some of the most popular ones are Clang (for C, C++, and Objective C), Swift (used extensively by Apple), Rust, and Fortran. </p>
			<p>Sulong is an LLVM interpreter that is written in Java and internally uses the Truffle language implementation framework. This enables all language compilers that can generate LLVM IR to directly run on GraalVM. The following diagram shows how Sulong enables LLVM languages to run on GraalVM:</p>
			<div>
				<div id="_idContainer140" class="IMG---Figure">
					<img src="image/B16878_Figure_9.1.jpg" alt="Figure 9.1 – LLVM compilation pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – LLVM compilation pipeline</p>
			<p>The preceding <a id="_idIndexMarker701"/>figure shows how LLVM works at a very high level. C/C++ source code is compiled to LLVM IR. Let's understand this diagram better:</p>
			<ul>
				<li>C/C++ code is compiled by Clang to LLVM IR. </li>
				<li>The <strong class="source-inline">lli</strong> GraalVM LLVM IR interpreter has two versions: <em class="italic">native</em> and <em class="italic">managed</em>. Native is the default <strong class="source-inline">lli</strong> version that comes both in Community Edition and Enterprise Edition. Managed <strong class="source-inline">lli</strong> is only available in Enterprise Edition and provides a managed mode of execution, which we will be covering in the <em class="italic">Understanding the LLVM managed environment</em> section. </li>
				<li>The LLVM IR interpreter performs the initial optimization and integrates with Truffle and Graal for further optimizations at runtime. </li>
			</ul>
			<p>To understand how LLVM IR looks, here is some example C code where we are adding two numbers and returning the result:</p>
			<p class="source-code">int addInt(int a, int b)</p>
			<p class="source-code">{</p>
			<p class="source-code">    return a + b;</p>
			<p class="source-code">}</p>
			<p>When we pass this through Clang, the following LLVM IR is generated. We can generate the LLVM IR using the <strong class="source-inline">clang -S -emit-llvm cfile.c</strong> command:</p>
			<p class="source-code">define dso_local i32 @addInt(i32 %0, i32 %1) #0 !dbg !7 {</p>
			<p class="source-code">  %3 = alloca i32, align 4</p>
			<p class="source-code">  %4 = alloca i32, align 4</p>
			<p class="source-code">  store i32 %0, i32* %3, align 4</p>
			<p class="source-code">  call void @llvm.dbg.declare(metadata i32* %3, </p>
			<p class="source-code">  metadata !12, metadata!DIExpression()), !dbg !13</p>
			<p class="source-code">  store i32 %1, i32* %4, align 4</p>
			<p class="source-code">  call void @llvm.dbg.declare(metadata i32* %4, </p>
			<p class="source-code">  metadata !14, metadata !DIExpression()), !dbg !15</p>
			<p class="source-code">  %5 = load i32, i32* %3, align 4, !dbg !16</p>
			<p class="source-code">  %6 = load i32, i32* %4, align 4, !dbg !17</p>
			<p class="source-code">  %7 = add nsw i32 %5, %6, !dbg !18</p>
			<p class="source-code">  ret i32 %7, !dbg !19</p>
			<p class="source-code">}</p>
			<p>The preceding IR <a id="_idIndexMarker702"/>clearly shows how the code gets converted into <strong class="bold">static single assignment</strong> (<strong class="bold">SSA</strong>) from the <strong class="source-inline">a</strong> variable (<strong class="source-inline">%0</strong>), which is passed as a parameter, and <strong class="source-inline">b</strong> (<strong class="source-inline">%1</strong>) is <a id="_idIndexMarker703"/>allocated <strong class="source-inline">%3</strong> and <strong class="source-inline">%4</strong> respectively. The values are then loaded into <strong class="source-inline">%5</strong> and <strong class="source-inline">%6</strong> respectively and added to <strong class="source-inline">%7</strong>. The value in <strong class="source-inline">%7</strong> is returned. SSA makes the optimization algorithms easy to implement, as the algorithms don't have to keep track of the value changes in a single variable, since every change in the variable is assigned to a single static value. </p>
			<p>The LLVM IR can be passed to Sulong, which is the LLVM IR interpreter, which internally uses the Truffle language implementation framework to run the code on GraalVM. This takes advantage of the advanced optimization features of GraalVM.</p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor172"/>Installing the LLVM toolchain</h2>
			<p>LLVM is available <a id="_idIndexMarker704"/>as an optional runtime, and can be installed using Graal Updater, with the following command:</p>
			<p class="source-code">gu install llvm-toolchain</p>
			<p>LLVM gets installed in <strong class="source-inline">$GRAALVM_HOME/languages/llvm/native/bin</strong>. We can check the path by using the following command:</p>
			<p class="source-code">$GRAALVM_HOME/bin/lli --print-toolchain-path </p>
			<p>This will print the path where LLVM is installed. Enterprise Edition also comes with a managed LLVM. We will cover that later in this chapter. </p>
			<p>The GraalVM LLVM runtime can execute language code that is converted to LLVM bitcode. The GraalVM <strong class="source-inline">lli</strong> tool interprets bit code and then compiles dynamically using Graal <strong class="bold">just in time</strong> (<strong class="bold">JIT</strong>). <strong class="source-inline">lli</strong> also enables <a id="_idIndexMarker705"/>interoperability with dynamic languages. The syntax for the <strong class="source-inline">lli</strong> command is shown next:</p>
			<p class="source-code">lli [LLI options] [GraalVM options] [polyglot options] &lt;bitcode file&gt; [program args]</p>
			<p><strong class="source-inline">lli</strong> can execute plain bitcode or native executables with embedded bitcode (Linux: ELF and macOS: Mach-O). </p>
			<p>Let's quickly verify the installation with some simple code:</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">    printf("Welcome to LLVM Graal \n");</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Let's compile the code with Clang:</p>
			<p class="source-code"><strong class="bold">clang HelloGraal.c -o hellograal</strong></p>
			<p>This runs the <strong class="source-inline">hellograal</strong> application. Let's run it using <strong class="source-inline">lli</strong>. <strong class="source-inline">lli</strong> is the LLVM interpreter:</p>
			<p class="source-code"><strong class="bold">lli hellograal</strong></p>
			<p>The following shows the output: </p>
			<p class="source-code">lli hellograal</p>
			<p class="source-code">Hello from GraalVM!</p>
			<p>We can directly execute <strong class="source-inline">/hellograal</strong> and get the same output. This is called native execution. Sometimes native executions run faster than <strong class="source-inline">lli</strong>, but we don't get the polyglot features that GraalVM provides <a id="_idIndexMarker706"/>with <strong class="source-inline">lli</strong>. Let's take something more complex; let's convert <strong class="source-inline">FibonacciCalculator.java</strong> to C. Here is the source code in C:</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;sys/time.h&gt;</p>
			<p class="source-code">long fib(int i) {</p>
			<p class="source-code">    int fib1 = 0;</p>
			<p class="source-code">    int fib2 = 1;</p>
			<p class="source-code">    int currentFib, index;</p>
			<p class="source-code">    long total = 0;</p>
			<p class="source-code">    for (index = 2; index &lt; i; ++index)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        currentFib = fib1 + fib2;</p>
			<p class="source-code">        fib1 = fib2;</p>
			<p class="source-code">        fib2 = currentFib;</p>
			<p class="source-code">        total += currentFib;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    printf("%ld \n", total);</p>
			<p class="source-code">    return total;</p>
			<p class="source-code">}</p>
			<p class="source-code">int main(int argc, char const *argv[])</p>
			<p class="source-code">{</p>
			<p class="source-code">    for (int i = 1000000000; i &lt; 1000000010; i++)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        struct timeval tv_start;</p>
			<p class="source-code">        struct timeval tv_end;</p>
			<p class="source-code">        long time;</p>
			<p class="source-code">        gettimeofday(andtv_start, NULL);</p>
			<p class="source-code">        fib(i);</p>
			<p class="source-code">        gettimeofday(andtv_end, NULL);</p>
			<p class="source-code">        time = (tv_end.tv_sec*1000000 +             tv_end.tv_usec) - (tv_start.tv_sec*1000000 +                 tv_start.tv_usec);</p>
			<p class="source-code">        printf("i=%d time: %10ld\n", i, time);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Let's create <a id="_idIndexMarker707"/>an executable by running the following command:</p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/languages/llvm/native/bin/clang FibonacciCalculator.c -o fibonacci</p>
			<p>We have to make sure we use the right version of Clang. We have to use the Clang that is provided with the GraalVM LLVM toolchain; otherwise, we won't be able to use <strong class="source-inline">lli</strong>. If we use normal Clang and try to execute the generated binary with <strong class="source-inline">lli</strong>, we get the following error: </p>
			<p class="source-code">oplevel executable /fibonacci does not contain bitcode</p>
			<p class="source-code">        at &lt;llvm&gt; null(Unknown)</p>
			<p>Once the binary file is created, we execute it with <strong class="source-inline">lli</strong> to use the GraalVM JIT compilation capabilities. Here is <a id="_idIndexMarker708"/>the output when executed with <strong class="source-inline">lli</strong>:</p>
			<p class="source-code">  llvm git:(main) lli fibonacci</p>
			<p class="source-code">-24641037439717 </p>
			<p class="source-code">i=1000000000 time:    5616852</p>
			<p class="source-code">-24639504571562 </p>
			<p class="source-code">i=1000000001 time:    5592305</p>
			<p class="source-code">-24640314634125 </p>
			<p class="source-code">i=1000000002 time:    5598246</p>
			<p class="source-code">-24639591828533 </p>
			<p class="source-code">i=1000000003 time:    1116430</p>
			<p class="source-code">-24639679085504 </p>
			<p class="source-code">i=1000000004 time:    1092585</p>
			<p class="source-code">-24639043536883 </p>
			<p class="source-code">i=1000000005 time:    1140553</p>
			<p class="source-code">-24638495245233 </p>
			<p class="source-code">i=1000000006 time:    1117817</p>
			<p class="source-code">-24637311404962 </p>
			<p class="source-code">i=1000000007 time:    1121831</p>
			<p class="source-code">-24635579273041 </p>
			<p class="source-code">i=1000000008 time:    1103494</p>
			<p class="source-code">-24636958268145 </p>
			<p class="source-code">i=1000000009 time:    1109705</p>
			<p>Let's plot these results on a graph and see how the performance improved over iterations. The following is the graph:</p>
			<div>
				<div id="_idContainer141" class="IMG---Figure">
					<img src="image/B16878_Figure_9.2.jpg" alt="Figure 9.2 – GraalVM LLVM performance graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – GraalVM LLVM performance graph</p>
			<p>We can see a <a id="_idIndexMarker709"/>significant improvement over iterations. We can see that initially, it runs slow, but after the third iteration, it improves by almost sixfold. </p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor173"/>Exploring LLVM interoperability</h2>
			<p>In this section, we will <a id="_idIndexMarker710"/>explore the interoperability features of LLVM and see how we can interact between Java, LLVM (C), and JavaScript.</p>
			<h3>Java and LLVM interoperability</h3>
			<p>Let's first <a id="_idIndexMarker711"/>try to call the <strong class="source-inline">FibonacciCalculator.c</strong> executable <a id="_idIndexMarker712"/>from Java. Here is the source code for <strong class="source-inline">FibonacciCalculatorLLVMEmbed.java</strong>:</p>
			<p class="source-code">import java.io.File;</p>
			<p class="source-code">import org.graalvm.polyglot.Context;</p>
			<p class="source-code">import org.graalvm.polyglot.Source;</p>
			<p class="source-code">import org.graalvm.polyglot.Value;</p>
			<p class="source-code">public class FibonacciCalculatorLLVMEmbed {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Context polyglot = Context.newBuilder()                .allowAllAccess(true).build();</p>
			<p class="source-code">            File file = new File("fibpoly");</p>
			<p class="source-code">            Source source = Source.newBuilder("llvm",                file).build();</p>
			<p class="source-code">            Value fibpoly = polyglot.eval(source);</p>
			<p class="source-code">            fibpoly.execute();</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The source code is very similar to what we did with JavaScript. We are creating a <strong class="source-inline">Context</strong> object, loading the compiled file with a <strong class="source-inline">Source</strong> object, and building the <strong class="source-inline">Source</strong> object from a binary using <strong class="source-inline">SourceBuilder</strong>. The <strong class="source-inline">Context</strong> object is then used to evaluate the <strong class="source-inline">Source</strong> object and is finally executed. </p>
			<p>Let's compile this Java file and run it with GraalVM Java. The following code shows the output of the file:</p>
			<p class="source-code">java FibonacciCalculatorLLVMEmbed</p>
			<p class="source-code">Inside C code: 10944 </p>
			<p class="source-code">Returned value to Java 10944</p>
			<p>We can see <a id="_idIndexMarker713"/>that we are able to call C code from Java. In this <a id="_idIndexMarker714"/>case, we just executed the C application. Let's now try to call the member function directly and pass an integer, and get the total as a <strong class="source-inline">long</strong> type.</p>
			<p>Here is the modified C code:</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;sys/time.h&gt;</p>
			<p class="source-code">long fib(int i) {</p>
			<p class="source-code">    int fib1 = 0;</p>
			<p class="source-code">    int fib2 = 1;</p>
			<p class="source-code">    int currentFib, index;</p>
			<p class="source-code">    long total = 0;</p>
			<p class="source-code">    for (index = 2; index &lt; i; ++index) {</p>
			<p class="source-code">        currentFib = fib1 + fib2;</p>
			<p class="source-code">        fib1 = fib2;</p>
			<p class="source-code">        fib2 = currentFib;</p>
			<p class="source-code">        total += currentFib;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    printf("Inside C code: %ld \n", total);</p>
			<p class="source-code">    return total;</p>
			<p class="source-code">}</p>
			<p>The preceding <a id="_idIndexMarker715"/>code implements the <strong class="source-inline">FibonacciCalculator</strong> logic that we had previously done using Java.</p>
			<p>In this section, we <a id="_idIndexMarker716"/>looked at how to invoke a C method from Java. Let's now understand how to invoke C code from a dynamic language such as JavaScript.</p>
			<h3>Exploring JavaScript and LLVM interoperability</h3>
			<p>Let's check <a id="_idIndexMarker717"/>the interoperability with JavaScript. JavaScript <a id="_idIndexMarker718"/>provides a very simple snippet. Here is the JavaScript code (<strong class="source-inline">FibonacciCaller.js</strong>):</p>
			<p class="source-code">var fibpoly = Polyglot.evalFile("llvm" , "fibpoly");</p>
			<p class="source-code">var fib = fibpoly.fib(20);</p>
			<p class="source-code">print("Returned value to JS: "+ fib);</p>
			<p>Let's run this JavaScript as follows: </p>
			<p class="source-code"><strong class="bold">js --polyglot FibonacciCaller.js </strong></p>
			<p class="source-code"><strong class="bold">Inside C code: 10944 </strong></p>
			<p class="source-code"><strong class="bold">Returned value to JS: 10944</strong></p>
			<p>We can see that we are now able to pass data to C code and execute the C method. </p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor174"/>Understanding the LLVM managed environment</h2>
			<p>GraalVM Enterprise <a id="_idIndexMarker719"/>Edition provides a managed environment of LLVM. We can find a version of the LLVM managed toolchain under the <strong class="source-inline">/languages/llvm/managed</strong> directory, while the default, unmanaged toolchain can be found under <strong class="source-inline">/languages/llvm/native</strong>. </p>
			<p>When the managed version of <strong class="source-inline">lli</strong> is used, the managed environment or managed mode of execution can be enabled with the <strong class="source-inline">--llvm.managed</strong> flag. In this section, let's understand what the managed mode of execution is, and why it is specifically required for LLVM.</p>
			<p>To understand <a id="_idIndexMarker720"/>the problems we typically face, let's take some very simple code, <strong class="source-inline">ManagedLLVM.c</strong>. In the following code, we are intentionally trying to copy a character array to an uninitialized <strong class="source-inline">char</strong> pointer: </p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">int main() {</p>
			<p class="source-code">  char *string;</p>
			<p class="source-code">  char valueStr[10] = "Hello Graaaaaaal";</p>
			<p class="source-code">  strcpy(string, valueStr);</p>
			<p class="source-code">  printf("%s", string);</p>
			<p class="source-code">  free(string);</p>
			<p class="source-code">  return 0;</p>
			<p class="source-code">}</p>
			<p>Let's compile this code; Clang actually warns us about incorrectly initializing <strong class="source-inline">valueStr</strong>. <strong class="source-inline">valueStr</strong> is only defined to take 10 characters, but we are assigning more than 10 characters. Let's assume that we ignore the warnings and proceed. The application is still built and can be executed. The following is the output of compiling the <strong class="source-inline">ManagedLLVM.c</strong> file:</p>
			<p class="source-code">/Library/Java/JavaVirtualMachines/graalvm-ee-java11-21.0.0.2/Contents/Home/languages/llvm/native/bin/clang ManagedLLVM.c -o managedllvm</p>
			<p class="source-code">ManagedLLVM.c:5:23: warning: initializer-string for char array is too long</p>
			<p class="source-code">  char valueStr[10] = "Hello Graaaaaaal";</p>
			<p class="source-code">                      ^~~~~~~~~~~~~~~~~~</p>
			<p class="source-code">ManagedLLVM.c:6:3: warning: implicitly declaring library function 'strcpy' with type</p>
			<p class="source-code">      'char *(char *, const char *)' [-Wimplicit-function-      declaration]</p>
			<p class="source-code">  strcpy(string, valueStr);</p>
			<p class="source-code">  ^</p>
			<p class="source-code">ManagedLLVM.c:6:3: note: include the header &lt;string.h&gt; or explicitly provide a declaration for 'strcpy'</p>
			<p class="source-code">2 warnings generated.</p>
			<p class="source-code">ManagedLLVM.c:5:23: warning: initializer-string for char array is too long</p>
			<p class="source-code">  char valueStr[10] = "Hello Graaaaaaal";</p>
			<p class="source-code">                      ^~~~~~~~~~~~~~~~~~</p>
			<p class="source-code">ManagedLLVM.c:6:3: warning: implicitly declaring library function 'strcpy' with type</p>
			<p class="source-code">      'char *(char *, const char *)' [-Wimplicit-function-      declaration]</p>
			<p class="source-code">  strcpy(string, valueStr);</p>
			<p class="source-code">  ^</p>
			<p class="source-code">ManagedLLVM.c:6:3: note: include the header &lt;string.h&gt; or explicitly provide a declaration for 'strcpy'</p>
			<p class="source-code">2 warnings generated.</p>
			<p>If we ignore the <a id="_idIndexMarker721"/>warnings and still run the application binary, we obviously get a page fault. This kills the host process and stops the application completely. Such problems cause a core dump and crash the application, and there are a lot of such instances with languages such as C/C++ where we face these kinds of issues. The following is the output when we run the code in native mode (directly native and native <strong class="source-inline">lli</strong>):</p>
			<p class="source-code"> ./managedllvm</p>
			<p class="source-code">[1]    30556 segmentation fault  ./managedllvm</p>
			<p>GraalVM LLVM managed execution mode provides a graceful way of handling these issues. Let's take the same code and compile it this time with the managed version of Clang and run it with the managed version of <strong class="source-inline">lli</strong>. Let's run the application binary with the managed version of <strong class="source-inline">lli</strong>:</p>
			<p class="source-code"><strong class="bold">llvm git:(main) lli --llvm.managed managedllvm</strong></p>
			<p class="source-code"><strong class="bold">Illegal null pointer access in 'store i64'.</strong></p>
			<p class="source-code"><strong class="bold">        at &lt;llvm&gt; main(ManagedLLVM.c:6:112)</strong></p>
			<p>It still fails, but this time it is not a segmentation fault or crash; it is throwing an exception. Exceptions can be caught and handled gracefully. </p>
			<p>To understand <a id="_idIndexMarker722"/>how to handle this better, lets create a Java class (<strong class="source-inline">ManagedLLVM.java</strong>) that calls the <strong class="source-inline">managedllvm</strong> executable from Java and handles the exception gracefully:</p>
			<p class="source-code">import java.io.File;</p>
			<p class="source-code">import org.graalvm.polyglot.Context;</p>
			<p class="source-code">import org.graalvm.polyglot.Source;</p>
			<p class="source-code">import org.graalvm.polyglot.Value;</p>
			<p class="source-code">public class ManagedLLVM {</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            Context polyglot = Context.newBuilder()                .allowAllAccess(true)                .option("llvm.managed", "true")                .build();</p>
			<p class="source-code">            File file = new File("managedLLVM");</p>
			<p class="source-code">            Source source =                 Source.newBuilder("llvm", file).build();</p>
			<p class="source-code">            Value mllvm = polyglot.eval(source);</p>
			<p class="source-code">            mllvm.execute();</p>
			<p class="source-code">        } catch (Exception e) {</p>
			<p class="source-code">            System.out.println("Exception occured....");</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Note that we are now creating a <strong class="source-inline">Context</strong> object with the <strong class="source-inline">llvm.manage</strong> option as <strong class="source-inline">true</strong>. That is very critical <a id="_idIndexMarker723"/>for us to run the executable in managed execution mode. Let's compile and run this Java application:</p>
			<p class="source-code"><strong class="bold">javac ManagedLLVM.java </strong></p>
			<p class="source-code"><strong class="bold">java ManagedLLVM </strong></p>
			<p class="source-code"><strong class="bold">Exception occured....</strong></p>
			<p class="source-code"><strong class="bold">Illegal null pointer access in 'store i64'.</strong></p>
			<p class="source-code"><strong class="bold">        at &lt;llvm&gt; main(ManagedLLVM.c:6:112)</strong></p>
			<p class="source-code"><strong class="bold">        at org.graalvm.sdk/org.graalvm.polyglot.Value.        execute(Value.java:455)</strong></p>
			<p class="source-code"><strong class="bold">        at ManagedLLVM.main(ManagedLLVM.java:13)</strong></p>
			<p>We can see that the Java application is now able to catch the exception and we could be writing exception handling code here. Moreover, it is not stopping the application. This is one of the greatest features of running LLVM in managed execution mode, and it is supported even in polyglot environments.</p>
			<p>Ruby is another language that has a high-performance interpreter implementation in GraalVM. Let's explore and understand TruffleRuby, the Ruby Truffle implementation, in the next section.</p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor175"/>Understanding TruffleRuby – the Ruby Truffle interpreter</h1>
			<p>TruffleRuby is a high-performance <a id="_idIndexMarker724"/>implementation of the Ruby programming <a id="_idIndexMarker725"/>language on GraalVM that is built on Truffle. In this section, we will explore some of the language-specific concepts, with code examples, to gain a good understanding of Ruby implementation on GraalVM.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor176"/>Installing TruffleRuby</h2>
			<p>TruffleRuby, too, does not come by default with GraalVM installation. You'll have to download and <a id="_idIndexMarker726"/>install it using the Graal updater tool. To install TruffleRuby, use the following command:</p>
			<p class="source-code">gu install ruby</p>
			<p>After installing Ruby, we have to run some post-install scripts to make <strong class="source-inline">OpenSSL</strong> C extensions work. We need to run <strong class="source-inline">post_install_hook.sh</strong>, which you will find under the <strong class="source-inline">ruby/lib/truffle</strong> directory. Let's test the installation with a simple Ruby application:</p>
			<p class="source-code">print "enter a "</p>
			<p class="source-code">a = gets.to_i</p>
			<p class="source-code">print "Enter b "</p>
			<p class="source-code">b = gets.to_i</p>
			<p class="source-code">c = a + b</p>
			<p class="source-code">puts "Result " + c.to_s</p>
			<p>The preceding code accepts the values of <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> as integers from the user, adds the numbers, and prints the result as a string. This is a very simple Ruby application to test Ruby. Let's run this program on TruffleRuby. The following is the terminal output:</p>
			<p class="source-code">truffleruby helloruby.rb </p>
			<p class="source-code">enter a 10</p>
			<p class="source-code">Enter b 20</p>
			<p class="source-code">Result 30</p>
			<p>Now that we <a id="_idIndexMarker727"/>know that TruffleRuby is installed and working, let's understand how the TruffleRuby interpreter works.</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor177"/>Understanding the TruffleRuby interpreter/compiler pipeline</h2>
			<p>TrufflyRuby, like any other guest language, is a Truffle interpreter implementation. The following <a id="_idIndexMarker728"/>figure shows the TruffleRuby interpreter/compiler pipeline:</p>
			<div>
				<div id="_idContainer142" class="IMG---Figure">
					<img src="image/B16878_Figure_9.3.jpg" alt="Figure 9.3 – TruffleRuby compiler/interpreter pipeline &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – TruffleRuby compiler/interpreter pipeline </p>
			<p>The interpreter/compiler pipeline is very similar to other guest languages. The preceding diagram does not capture all the details. Refer to the <em class="italic">Exploring the Truffle interpreter/compiler pipeline</em> section in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>, for a more detailed explanation on how Truffle interpreters and Graal JIT executes the code. The TruffleRuby interpreter builds the AST after parsing and performs optimizations and submits the code to Graal JIT, like any other guest language. However, one of the key differences is the way it handles C extensions. C extensions are an integral part of Ruby programming, and traditionally, C extensions are plugged into the Ruby interpreter. TruffleRuby handles this using the LLVM interpreter. This naturally provides polyglot interoperability and we can use other LLVM languages such as C++, Rust, and Swift, not just C. TruffleRuby brings in polyglot interoperability as it's built on Truffle. Let's explore the polyglot interoperability features of TruffleRuby.</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor178"/>Exploring Polyglot interoperability with TruffleRuby</h2>
			<p>TruffleRuby brings all the polyglot interoperability features of Truffle and implements similar APIs. Let's <a id="_idIndexMarker729"/>explore these <a id="_idIndexMarker730"/>features in this section. Let's write some simple Ruby code that calls the JavaScript file we built in previous sections that exports simple math functions and variables:</p>
			<p class="source-code">var helloMathMessage = " Hello Math.js";</p>
			<p class="source-code">function add(a, b) {</p>
			<p class="source-code">    print("message from js: add() called");</p>
			<p class="source-code">    return a+b;</p>
			<p class="source-code">}</p>
			<p class="source-code">function subtract(a, b) {</p>
			<p class="source-code">    print("message from js: subtract() called");</p>
			<p class="source-code">    return a-b;</p>
			<p class="source-code">}</p>
			<p class="source-code">function multiply(a, b) {</p>
			<p class="source-code">    print("message from js: multiply() called");</p>
			<p class="source-code">    return a*b;</p>
			<p class="source-code">}</p>
			<p class="source-code">Polyglot.export('add', add);</p>
			<p class="source-code">Polyglot.export('subtract', subtract);</p>
			<p class="source-code">Polyglot.export('multiply', multiply);</p>
			<p class="source-code">Polyglot.export('message', helloMathMessage);</p>
			<p>The following is the Ruby code that demonstrates the polyglot capabilities:</p>
			<p class="source-code">arrayPy  = Polyglot.eval("python", "[10, 10.23456,     'Array String element']")</p>
			<p class="source-code">puts arrayPy.to_s</p>
			<p class="source-code">lengthOfArray = arrayPy.size</p>
			<p class="source-code">puts "Iterating through the Python Array object of size "     + lengthOfArray.to_s</p>
			<p class="source-code">for i in 0..lengthOfArray - 1</p>
			<p class="source-code">    puts "Element at " + i.to_s + " is " + arrayPy[i].to_s</p>
			<p class="source-code">end</p>
			<p>In the <a id="_idIndexMarker731"/>preceding code, we are calling <a id="_idIndexMarker732"/>JavaScript code that creates an array of three elements: an integer, a float, and a string. We are evaluating this JavaScript code in line with <strong class="source-inline">Polyglot.eval()</strong>. We are then iterating through the array and printing the values. In the following code, we are loading <strong class="source-inline">math.js</strong> and importing the <strong class="source-inline">message</strong> variable and the <strong class="source-inline">add()</strong>, <strong class="source-inline">subtract()</strong>, and <strong class="source-inline">multiply()</strong> functions. We are then invoking those functions and printing the results:</p>
			<p class="source-code">Polyglot.eval_file("./math.js") </p>
			<p class="source-code">message = Polyglot.import("message")</p>
			<p class="source-code">addFunction = Polyglot.import_method("add")</p>
			<p class="source-code">subtractFunction = Polyglot.import_method("subtract")</p>
			<p class="source-code">multiplyFunction = Polyglot.import_method("multiply")</p>
			<p class="source-code">puts "Message from JS " + message</p>
			<p class="source-code">puts "Result of add(10,20) " + add(10,20).to_s</p>
			<p class="source-code">puts "Result of subtract(10,20) " + subtract(40,20).to_s</p>
			<p class="source-code">puts "Result of multiply(10,20) " + multiply(10,20).to_s</p>
			<p>Now let's run this code. The following is the output:</p>
			<p class="source-code">truffleruby --polyglot mathJsCaller.rb</p>
			<p class="source-code">#&lt;Python [10, 10.23456, 'Array String element']&gt;</p>
			<p class="source-code">Iterating throught the Python Array object of size 3</p>
			<p class="source-code">Element at 0 is 10</p>
			<p class="source-code">Element at 1 is 10.23456</p>
			<p class="source-code">Element at 2 is Array String element</p>
			<p class="source-code">Message from JS  Hello Math.js</p>
			<p class="source-code">message from js: add() called</p>
			<p class="source-code">Result of add(10,20) 30</p>
			<p class="source-code">message from js: subtract() called</p>
			<p class="source-code">Result of subtract(10,20) 20</p>
			<p class="source-code">message from js: multiply() called</p>
			<p class="source-code">Result of multiply(10,20) 200</p>
			<p>We can see <a id="_idIndexMarker733"/>that we are able to iterate <a id="_idIndexMarker734"/>through the JavaScript array, and also call the functions in the <strong class="source-inline">math.js</strong> JavaScript code. </p>
			<p>Let's now explore how to interoperate with Java. We use the <strong class="source-inline">Java.type()</strong> method to load the Java class. Let's use a slightly modified version of <strong class="source-inline">FibonacciCalculator</strong>. Here's the Java source code: </p>
			<p class="source-code">public class FibonacciCalculator{  </p>
			<p class="source-code">    public int[] findFibonacci(int count) {</p>
			<p class="source-code">        int fib1 = 0;</p>
			<p class="source-code">        int fib2 = 1;</p>
			<p class="source-code">        int currentFib, index;</p>
			<p class="source-code">        int [] fibNumbersArray = new int[count];</p>
			<p class="source-code">        for(index=2; index &lt; count+1; ++index ) {    </p>
			<p class="source-code">            currentFib = fib1 + fib2;    </p>
			<p class="source-code">            fib1 = fib2;    </p>
			<p class="source-code">            fib2 = currentFib;    </p>
			<p class="source-code">            fibNumbersArray[index - 1] = currentFib;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return fibNumbersArray;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public void iterateFibonacci() {</p>
			<p class="source-code">        long startTime = System.currentTimeMillis();</p>
			<p class="source-code">        long now = 0;</p>
			<p class="source-code">        long last = startTime;</p>
			<p class="source-code">        for (int i = 1000000000; i &lt; 1000000010; i++) {</p>
			<p class="source-code">            int[] fibs = findFibonacci(i);</p>
			<p class="source-code">            long total = 0;</p>
			<p class="source-code">            for (int j=0; j&lt;fibs.length; j++) {</p>
			<p class="source-code">                total += fibs[j];</p>
			<p class="source-code">            }</p>
			<p class="source-code">            now = System.currentTimeMillis();</p>
			<p class="source-code">            System.out.printf("%d (%d ms)%n", i , now - last);</p>
			<p class="source-code">            last = now;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        long endTime = System.currentTimeMillis();</p>
			<p class="source-code">        System.out.printf("total: (%d ms)%n",             System.currentTimeMillis() - startTime);  </p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String args[]) {    </p>
			<p class="source-code">        FibonacciCalculator fibCal =             new FibonacciCalculator();</p>
			<p class="source-code">        fibCal.iterateFibonacci();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>We have defined two methods: <strong class="source-inline">findFibonacci()</strong> and <strong class="source-inline">iterateFibonacci()</strong>. The <strong class="source-inline">findFibonacci()</strong> method takes an integer and returns the Fibonacci numbers, as per the requested count. <strong class="source-inline">iterateFibonacci()</strong> iterates and generates a large number of Fibonacci numbers, and times it to check how the code performs. </p>
			<p>The following <a id="_idIndexMarker735"/>code is the Ruby script <a id="_idIndexMarker736"/>to load the <strong class="source-inline">FibonacciCalculator</strong> class and call the <strong class="source-inline">findFibonacci(int count)</strong> method. We pass an integer value to this method and we get an array of integers. We then go through the array and print the values. We are also calling <strong class="source-inline">iterateFibonacci()</strong> to compare how it performs with running directly with Java:</p>
			<p class="source-code">fibclass = Java.type('FibonacciCalculator')</p>
			<p class="source-code">fibObject = fibclass.new</p>
			<p class="source-code">fibonacciArray = fibObject.findFibonacci(10)</p>
			<p class="source-code">for i in 0..fibonacciArray.size - 1</p>
			<p class="source-code">    puts "Element at " + i.to_s + " is " + fibonacciArray[i]    .to_s</p>
			<p class="source-code">end</p>
			<p class="source-code">puts "Calling iterateFibonacci()"</p>
			<p class="source-code">fibObject.iterateFibonacci()</p>
			<p>To run this <a id="_idIndexMarker737"/>Ruby script, we need to <a id="_idIndexMarker738"/>pass <strong class="source-inline">--jvm</strong> in the command line along with <strong class="source-inline">--vm.cp</strong> to point to the path where the Java class is available. The following is the output of running TruffleRuby:</p>
			<p class="source-code">truffleruby --jvm --vm.cp=. fibonacciJavaCaller.rb</p>
			<p class="source-code">Element at 0 is 0</p>
			<p class="source-code">Element at 1 is 1</p>
			<p class="source-code">Element at 2 is 2</p>
			<p class="source-code">Element at 3 is 3</p>
			<p class="source-code">Element at 4 is 5</p>
			<p class="source-code">Element at 5 is 8</p>
			<p class="source-code">Element at 6 is 13</p>
			<p class="source-code">Element at 7 is 21</p>
			<p class="source-code">Element at 8 is 34</p>
			<p class="source-code">Element at 9 is 55</p>
			<p class="source-code">Calling iterateFibonacci()</p>
			<p class="source-code">1000000000 (2946 ms)</p>
			<p class="source-code">1000000001 (1011 ms)</p>
			<p class="source-code">1000000002 (1293 ms)</p>
			<p class="source-code">1000000003 (1016 ms)</p>
			<p class="source-code">1000000004 (1083 ms)</p>
			<p class="source-code">1000000005 (1142 ms)</p>
			<p class="source-code">1000000006 (1072 ms)</p>
			<p class="source-code">1000000007 (994 ms)</p>
			<p class="source-code">1000000008 (982 ms)</p>
			<p class="source-code">1000000009 (999 ms)</p>
			<p class="source-code">total: (12538 ms)</p>
			<p>We can see <a id="_idIndexMarker739"/>how we are able to call the <a id="_idIndexMarker740"/>Java class and go through the Java array in Ruby, and even <strong class="source-inline">iterateFibonacci()</strong> performed reasonably well. Let's try to compare this with running this Java class directly with Java. Here's the output: </p>
			<p class="source-code">java FibonacciCalculator </p>
			<p class="source-code">1000000000 (2790 ms)</p>
			<p class="source-code">1000000001 (592 ms)</p>
			<p class="source-code">1000000002 (1120 ms)</p>
			<p class="source-code">1000000003 (927 ms)</p>
			<p class="source-code">1000000004 (955 ms)</p>
			<p class="source-code">1000000005 (952 ms)</p>
			<p class="source-code">1000000006 (974 ms)</p>
			<p class="source-code">1000000007 (929 ms)</p>
			<p class="source-code">1000000008 (923 ms)</p>
			<p class="source-code">1000000009 (924 ms)</p>
			<p class="source-code">total: (11086 ms)</p>
			<p>We can see that the performance of Ruby is on par with running Java directly. TruffleRuby is one of the best-performing Ruby runtimes. TruffleRuby is in the experimental phase, while writing this book; for the latest information, refer to <a href="https://www.graalvm.org/reference-manual/ruby/">https://www.graalvm.org/reference-manual/ruby/</a>.</p>
			<p>One of the biggest advantages of<a id="_idIndexMarker741"/> using Ruby is RubyGems. Ruby has a vast library, which the developer community has built over a period of time. All <a id="_idIndexMarker742"/>Gems are hosted in https://rubygems.org/. With GraalVM Polyglot, this opens up a huge opportunity to use these gems in Java or any other language, supported by GraalVM. To illustrate this, let's use a gem in a Java program. There is a gem <a id="_idIndexMarker743"/>called math_engine (<a href="https://rubygems.org/gems/math_engine">https://rubygems.org/gems/math_engine</a>). This has a very interesting method to evaluate complex mathematical expressions. Let's assume that we are building a complex algebra calculator that can be used to evaluate complex expressions. Let's use this gem in a Ruby program, and invoke it from Java. </p>
			<p>Let's first install the gem. To install the gem, let's use <a id="_idIndexMarker744"/>Bundler (https://bundler.io/). Bundler is a <a id="_idIndexMarker745"/>package manager (equivalent to npm in Node.js). To install Bundler, use the gem install command. The following is the output of installing Bundler:</p>
			<p class="source-code">gem install bundler</p>
			<p class="source-code">Fetching bundler-2.2.17.gem</p>
			<p class="source-code">Successfully installed bundler-2.2.17</p>
			<p class="source-code">1 gem installed</p>
			<p>Let's now create a<a id="_idIndexMarker746"/> Gemfile. Bundler uses the <a id="_idIndexMarker747"/>configuration in a Gemfile to install all the packages/gems. (This is equivalent to package.json in npm.) Here is the source of the Gemfile:</p>
			<p class="source-code">source 'https://rubygems.org'</p>
			<p class="source-code">gem 'math_engine'</p>
			<p>We are providing the source of the Gem repository and specifying the gems that depend on our Ruby module. Let's now run Bundler to install these gems. (The bundle install command should be executed in the folder where we have the Ruby program and Gemfile.)</p>
			<p>The bundle install command will install all the gems. Let's <a id="_idIndexMarker748"/>now use the math_engine gem, and define a method called eval() in Ruby that takes in the expression, evaluates it, and returns the result:</p>
			<p class="source-code">require 'rubygems'</p>
			<p class="source-code">require 'math_engine'</p>
			<p class="source-code">def eval(exp)</p>
			<p class="source-code">    engine = MathEngine.new</p>
			<p class="source-code">    ret = engine.evaluate(exp)</p>
			<p class="source-code">    puts(ret)</p>
			<p class="source-code">    return ret.truncate(4).to_f()</p>
			<p class="source-code">end</p>
			<p class="source-code">Polyglot.export_method('eval')</p>
			<p>In the preceding source code, we are exporting the method using Polyglot.export_method(), so that it can be accessed by other languages. Let's now call this eval() method from a Java program. </p>
			<p>The following is the Java source code:</p>
			<p class="source-code">public class MathEngineExample {</p>
			<p class="source-code">    public void evaluateExpression(String exp) {</p>
			<p class="source-code">        Context ctx = Context.newBuilder()            .allowAllAccess(true).build();</p>
			<p class="source-code">        try {</p>
			<p class="source-code">            File fibCal =                 new File("./math_engine_expression.rb");</p>
			<p class="source-code">            ctx.eval(Source.newBuilder("ruby",                fibCal).build());</p>
			<p class="source-code">            Value evaluateFunction =                 ctx.getBindings("ruby").getMember("eval");</p>
			<p class="source-code">            Double evaluatedValue =                 evaluateFunction.execute(exp).asDouble();</p>
			<p class="source-code">            System.out.printf("Evaluated Expression : "                 + evaluatedValue.toString());  </p>
			<p class="source-code">        }   catch (Exception e) {</p>
			<p class="source-code">            System.out.println("Exception : " );</p>
			<p class="source-code">            e.printStackTrace();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public static void main(String[] args) {</p>
			<p class="source-code">        MathEngineExample obj = new MathEngineExample();</p>
			<p class="source-code">        obj.evaluateExpression("20 * (3/2) + (5 * 5)             / (100.5 * 3)");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In the previous Java code, we are using the Context object to load the Ruby runtime and our <a id="_idIndexMarker749"/>Ruby program. We are then binding the eval() method and executing it with the passed expression. The value is then captured and converted to a string for printing. In the main() method, we are passing a complex mathematical expression. Let's now compile and run this Java code. The following is the output: </p>
			<p class="source-code">java MathEngineExample</p>
			<p class="source-code">0.30082918739635157545605306799e2</p>
			<p class="source-code">Evaluated Expression : 30.0829      </p>
			<p>The first output comes from Ruby put_s() and the next output is coming from Java. This opens up a huge opportunity to use the vast library of gems. </p>
			<h3>Understanding TruffleRuby Vs CRuby Vs JRuby</h3>
			<p>Ruby has a lot of implementations on the market. JRuby and CRuby are two popular implementations of Ruby. </p>
			<p>JRuby is the Ruby programming language implemented in Java. CRuby is the Ruby programming language implemented in C. The following diagram shows the high-level compilation pipeline of JRuby and CRuby. JRuby is one of the highest-performing implementations of Ruby, as it brings in the optimizations and JIT compilation. JRuby also does not <a id="_idIndexMarker750"/>have a global interpreter <a id="_idIndexMarker751"/>lock, like in CRuby, and this allows concurrent execution, and hence is faster. However, JRuby starts slow but performs better over a period of time:</p>
			<div>
				<div id="_idContainer143" class="IMG---Figure">
					<img src="image/B16878_Figure_9.4.jpg" alt="Figure 9.4 – JRuby and CRuby compilation pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – JRuby and CRuby compilation pipeline</p>
			<p>TruffleRuby outperforms JRuby and CRuby. Please refer to <a href="https://www.graalvm.org/ruby/">https://www.graalvm.org/ruby/</a> for more detailed optcarrot and Rubycon benchmark results. </p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor179"/>Understanding GraalWasm – the WASM Truffle interpreter</h1>
			<p>GraalVM provides <a id="_idIndexMarker752"/>an interpreter and compiler for WASM code called GraalWasm. GraalWasm opens <a id="_idIndexMarker753"/>up possibilities of building polyglot web applications that perform close to natively. Before we get into the details of GraalWasm, let's have a quick overview of WASM.</p>
			<p>Understanding WASM</p>
			<p><strong class="bold">WASM</strong> is a binary <a id="_idIndexMarker754"/>format that can run on most modern browsers at near-native speeds. Web applications have become more and more sophisticated and demand a high-performance, near-native experience. JavaScript can only get to a certain level, and we have seen a lot of very good applications built on JavaScript that provide almost native experience. WASM augments JavaScript and other technologies to allow us to compile C, C++, and Rust programs on the web. The following figure shows a very simple pipeline of building WASM applications:</p>
			<div>
				<div id="_idContainer144" class="IMG---Figure">
					<img src="image/B16878_Figure_9.5.jpg" alt="Figure 9.5 – WASM compilation pipeline flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – WASM compilation pipeline flow</p>
			<p>In the preceding figure, we can see how C/C++ code can be compiled to WASM using Emscripten, and it <a id="_idIndexMarker755"/>coexists with the other web technologies and runs on web browsers. Both JavaScript and WASM execute logic on the browser. The main difference is WASM is delivered as a binary that is already optimized at compile time. There is no need for abstract syntax trees and type specializations and speculations (refer to the <em class="italic">Exploring the Truffle interpreter/compiler pipeline</em> section in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>, to understand more about AST and speculative optimization). </p>
			<p>This is one of the reasons why WASM has a smaller footprint and faster performance. Modern web application architectures leverage WASM to perform more advanced computational logic in the browser, while JavaScript is used to run the user interface and simple application logic. GraalWasm opens up even more possibilities by bringing in polyglot interoperability and embedding. Let's explore that in the next section.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor180"/>Understanding GraalWasm architecture</h2>
			<p>Let's understand how GraalWasm works. The following figure shows the compilation pipeline for <a id="_idIndexMarker756"/>GraalWasm. The diagram does not capture all the details. Refer to the <em class="italic">Exploring the Truffle interpreter/compiler pipeline</em> section in <a href="B16878_06_Final_SK_ePub.xhtml#_idTextAnchor120"><em class="italic">Chapter 6</em></a>, <em class="italic">Truffle – An Overview</em>, for a more detailed explanation on how Truffle interpreters and Graal JIT execute code:</p>
			<div>
				<div id="_idContainer145" class="IMG---Figure">
					<img src="image/B16878_Figure_9.6.jpg" alt="Figure 9.6 – GraalWasm compilation/interpreter pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – GraalWasm compilation/interpreter pipeline</p>
			<p>C/C++ source code is compiled using Emscripten (<strong class="source-inline">emcc</strong>). Emscripten is a drop-in replacement for <strong class="source-inline">gcc</strong> or Clang, built on LLVM. Emscripten compiles the source to a WASM (<strong class="source-inline">.wasm</strong>) file. The GraalWasm interpreter creates the AST and performs optimizations. There is not much optimization that is required, as the WASM is generated from a strongly typed language, and so already a lot of optimization is performed. Since the WASM format is a sequence of instructions, to reduce the memory footprint, GraalWasm builds an AST, where each node is pointing to a block in WASM (this is called the WASM block node), instead of creating a node for each instruction. The GraalWasm interpreter then optimizes the AST and passes it to Graal for execution.</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor181"/>Installing and running GraalWasm</h2>
			<p>GraalWasm is an optional component; it does not come with the GraalVM installation. We have to <a id="_idIndexMarker757"/>install it using Graal Updater. To install GraalWasm, we can <a id="_idIndexMarker758"/>use the following command to download and install it:</p>
			<p class="source-code">gu install wasm</p>
			<p>Let's now build a WASM binary and run it with GraalWasm. To compile C code to WASM, we have to install <strong class="source-inline">emcc</strong>. The following section walks through the steps to install <strong class="source-inline">emcc</strong>.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor182"/>Installing Emscripten (emcc)</h2>
			<p>Emscripten is installed using Emscripten SDK. We can download the SDK from the Git repository. Let's execute <a id="_idIndexMarker759"/>the following command on a terminal:</p>
			<p class="source-code">git clone https://github.com/emscripten-core/emsdk.git</p>
			<p>This downloads <strong class="source-inline">emsdk</strong>, which also has all the required installation scripts. <strong class="source-inline">git clone</strong> will create an <strong class="source-inline">emsdk</strong> directory. Let's move that to the <strong class="source-inline">cd emsdk</strong>  folder and perform <strong class="source-inline">git pull</strong> to make sure it is up to date. We can install the <strong class="source-inline">emcc</strong> toolchain by executing the following command:</p>
			<p class="source-code">./emsdk install latest</p>
			<p>This will download all the required toolchains and SDKs. Once it's downloaded, we need to activate <strong class="source-inline">emsdk</strong> and then set the environment, using the following commands in sequence:</p>
			<p class="source-code">./emsdk activate latest</p>
			<p class="source-code">./emsdk_env.sh</p>
			<p>Once all of these commands are successfully executed, we should be able to check whether Emscripten is installed by running the <strong class="source-inline">emcc</strong> command on the terminal.</p>
			<p>Now let's build a WASM of the following C code. This is a slight modification of the code that we have already used in the <em class="italic">Exploring LLVM interoperability</em> section:</p>
			<p class="source-code">#include &lt;stdio.h&gt;</p>
			<p class="source-code">#include &lt;stdlib.h&gt;</p>
			<p class="source-code">#include &lt;sys/time.h&gt;</p>
			<p class="source-code">static long fib(int i) {</p>
			<p class="source-code">    int fib1 = 0;</p>
			<p class="source-code">    int fib2 = 1;</p>
			<p class="source-code">    int currentFib, index;</p>
			<p class="source-code">    long total = 0;</p>
			<p class="source-code">    for (index = 2; index &lt; i; ++index) {</p>
			<p class="source-code">        currentFib = fib1 + fib2;</p>
			<p class="source-code">        fib1 = fib2;</p>
			<p class="source-code">        fib2 = currentFib;</p>
			<p class="source-code">        total += currentFib;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return total;</p>
			<p class="source-code">}</p>
			<p>We have defined a method that calculates Fibonacci numbers, sums them up, and returns the sum <a id="_idIndexMarker760"/>of the Fibonacci numbers. In the following code snippet of the <strong class="source-inline">main()</strong> method, we are looping through and calling this <strong class="source-inline">fib()</strong> method in interactions, just to test the method, and printing the total and time taken for executing each iteration:</p>
			<p class="source-code">int main(int argc, char const *argv[])</p>
			<p class="source-code">{</p>
			<p class="source-code">    for (int i = 10000; i &lt; 10010; i++) {</p>
			<p class="source-code">        struct timeval tv_start;</p>
			<p class="source-code">        struct timeval tv_end;</p>
			<p class="source-code">        long time;</p>
			<p class="source-code">        gettimeofday(&amp;tv_start, NULL);</p>
			<p class="source-code">        fib(i);</p>
			<p class="source-code">        gettimeofday(&amp;tv_end, NULL);</p>
			<p class="source-code">        time = (tv_end.tv_sec*1000000 + tv_end.tv_usec) –            (tv_start.tv_sec*1000000 + tv_start.tv_usec);</p>
			<p class="source-code">        printf("i=%d time: %10ld\n", i, time);</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return 0;</p>
			<p class="source-code">}</p>
			<p>Let's compile <a id="_idIndexMarker761"/>this code with <strong class="source-inline">emcc</strong> with the following command:</p>
			<p class="source-code">emcc -o fibonacci.wasm fibonacci.c</p>
			<p>In the previous command, the <strong class="source-inline">-o</strong> option is used to specify the name of the output file; in this case, <strong class="source-inline">fibonacci.wasm</strong> is the binary file that is generated, after successful compilation. Let's run this file with GraalWasm by executing the following command:</p>
			<p class="source-code">wasm --Builtins=wasi_snapshot_preview1 fibonacci.wasm</p>
			<p>In the preceding command, we used <strong class="source-inline">--Builtins</strong> to pass the <strong class="source-inline">wasi_snapshot_preview1</strong> module that the Emscripten toolchain requires. The following shows the output after executing:</p>
			<p class="source-code">wasm --Builtins=wasi_snapshot_preview1 fibonacci.wasm</p>
			<p class="source-code">i=10000 time:       6563</p>
			<p class="source-code">i=10001 time:       6519</p>
			<p class="source-code">i=10002 time:       6841</p>
			<p class="source-code">i=10003 time:       8455</p>
			<p class="source-code">i=10004 time:       6838</p>
			<p class="source-code">i=10005 time:       7156</p>
			<p class="source-code">i=10006 time:       7214</p>
			<p class="source-code">i=10007 time:        237</p>
			<p class="source-code">i=10008 time:        265</p>
			<p class="source-code">i=10009 time:        247 </p>
			<p>We can see the <a id="_idIndexMarker762"/>output generated instantly and is quite fast for the number of Fibonacci numbers we wanted to create and add up. Also, we can see a huge performance improvement from 6,519 ms to 247 ms.</p>
			<h1 id="_idParaDest-176"><a id="_idTextAnchor183"/>Summary</h1>
			<p>In this chapter, we went into the details of how LLVM, Ruby, and WASM, Java on Truffle and Ruby interpreters are implemented on Truffle. We also explored the polyglot interoperability features that these languages provide, along with coding examples. We understood the differences in the way each of these languages is interpreted. The chapter provided a hands-on walkthrough of how to run code and write polyglot applications in these various languages. </p>
			<p>You should be able to use this knowledge to write polyglot applications on GraalVM. Though most of these languages are still in the experimental phase at the time of writing the book, they provide great opportunities to build high-performance polyglot applications. In the next chapter, we will see how the new frameworks such as Quarkus and Micronaut implement Graal for most optimum microservices architecture.</p>
			<h1 id="_idParaDest-177"><a id="_idTextAnchor184"/>Questions</h1>
			<ol>
				<li>What is Sulong?</li>
				<li>What is the LLVM managed mode of execution?</li>
				<li>How does TruffleRuby implement C extensions?</li>
				<li>What is WASM?</li>
				<li>What is <strong class="source-inline">emcc</strong>?</li>
			</ol>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor185"/>Further reading</h1>
			<ul>
				<li>GraalVM Enterprise Edition: <a href="https://docs.oracle.com/en/graalvm/enterprise/19/index.html">https://docs.oracle.com/en/graalvm/enterprise/19/index.html</a></li>
				<li>GraalVM language reference: <a href="https://www.graalvm.org/reference-manual/languages/">https://www.graalvm.org/reference-manual/languages/</a></li>
				<li>GraalWasm announcement blog post: <a href="https://medium.com/graalvm/announcing-graalwasm-a-webassembly-engine-in-graalvm-25cd0400a7f2">https://medium.com/graalvm/announcing-graalwasm-a-webassembly-engine-in-graalvm-25cd0400a7f2</a></li>
				<li><em class="italic">WASM engine in GraalVM: Introducing Oracle's GraalWasm</em>: <a href="https://jaxenter.com/graalvm-webassembly-graalwasm-165111.html">https://jaxenter.com/graalvm-webassembly-graalwasm-165111.html</a></li>
			</ul>
		</div>
	</body></html>