["```java\n    -javaagent:jarpath[=options]\n\n```", "```java\npublic static void premain(String agentArgs, Instrumentation inst);\n\n```", "```java\npublic static void premain(String agentArgs);\n\n```", "```java\nvoid addTransformer(ClassFileTransformer transformer)\n\n```", "```java\nbyte[] transform(Module module, ClassLoader loader, \n                 String className, \n                 Class<?> classBeingRedefined, \n                 ProtectionDomain protectionDomain, \n                 byte[] classfileBuffer) \nthrows IllegalClassFormatException\n\n```", "```java\nvoid retransformClasses(Class<?>... classes)\n\n```", "```java\nvoid redefineClasses(ClassDefinition... definitions)\n\n```", "```java\n@Retention(RetentionPolicy.RUNTIME)\n\n```", "```java\npublic Set<String> getSupportedAnnotationTypes() { \n    SupportedAnnotationTypes sat = this.getClass().getAnnotation \n    (SupportedAnnotationTypes.class); \n    if  (sat == null) { \n        ... error message is sent to compiler output ... \n        return Collections.emptySet(); \n    } \n    else \n        return arrayToSet(sat.value()); \n}\n\n```", "```java\n@Retention(RetentionPolicy.SOURCE) \n@Target(ElementType.TYPE) \npublic @interface CompileScript { \n    String value(); \n    String engine() default \"\"; \n}\n\n```", "```java\npackage com.javax0.scriapt; \nimport ... \n@SupportedAnnotationTypes(\"com.javax0.scriapt.CompileScript\") \n@SupportedSourceVersion(SourceVersion.RELEASE_9) \npublic class Processor extends AbstractProcessor {\n\n```", "```java\n@Override \npublic boolean process( \n    final Set<? extends TypeElement> annotations, \n    final RoundEnvironment roundEnv) { \n        for (final Element rootElement : \n            roundEnv.getRootElements()) { \n                try { \n                    processClass(rootElement); \n                }  \n                catch (Exception e) { \n                    throw new RuntimeException(e); \n                } \n            } \n        return false; \n    }\n\nRunTimeException. If any of these exceptions are thrown by the called method, then the compilation could not run the scripts and it should be treated as failed. The compilation should not succeed in such a case:\n```", "```java\nprivate void processClass(final Element element) \n    throws ScriptException, FileNotFoundException { \n        for (final AnnotationMirror annotationMirror : \n            element.getAnnotationMirrors()) { \n                processAnnotation(annotationMirror); \n        } \n    }\n\n```", "```java\nprivate void processAnnotation( \n    final AnnotationMirror annotationMirror) \n    throws ScriptException, FileNotFoundException { \n        final String script = \n            FromThe.annotation(annotationMirror). \n            getStringValue(); \n        final String engine = \n            FromThe.annotation(annotationMirror). \n            getStringValue(\"engine\"); \n        execute(script, engine); \n    }\n\n```", "```java\nprivate void execute(final String scriptFileName, \n                    final String engineName) \n    throws ScriptException, FileNotFoundException { \n        final ScriptEngineManager factory = \n        new ScriptEngineManager(); \n        final ScriptEngine engine; \n        if (engineName != null && engineName.length() > 0) { \n            engine = factory.getEngineByName(engineName); \n        }  \n        else { \n            engine = \n            factory.getEngineByExtension \n            (getExtensionFrom(scriptFileName)); \n        } \n        Reader scriptFileReader = new FileReader \n        (new File(scriptFileName)); \n        engine.eval(scriptFileReader); \n    }\n\n```", "```java\nprivate String getExtensionFrom(final String scriptFileName) { \n    final int indexOfExtension = scriptFileName.lastIndexOf('.'); \n    if (indexOfExtension == -1) { \n        return \"\"; \n    }  \n    else { \n        return scriptFileName.substring(indexOfExtension + 1); \n    } \n}\n\n```", "```java\n}\n\n```"]