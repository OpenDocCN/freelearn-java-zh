- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods, Interfaces, Records, and Their Relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Java, how we define and organize our code is the cornerstone of the language.
    In this chapter, we will begin by examining the role that a method plays in Java.
    From here, we will examine the relationships afforded by inheritance and interface.
    The immutable `record` class is next up. Polymorphism, the ability to use objects
    in a hierarchy of classes, as it applies to inheritance and interface, is covered
    next. We will finish the chapter by looking at the relationships between objects
    and how they can call upon methods in other objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will learn about the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the class interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the `record` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding composition in classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By understanding all the components and relationships available in Java, you’ll
    be able to read or write Java code.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the tools required to run the examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Java 17 installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A text editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven 3.8.6 or a newer version installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, I must admit that I have been coding since 1980, and since then, the term
    we use to describe discrete blocks of code has changed. When I started coding
    in 1980 using **BASIC**, an unstructured language, I quickly learned to break
    my code up into subroutines. From BASIC, I moved on to **Pascal**, where there
    is a formal designation for blocks of code. These were **functions** for blocks
    that returned a result and procedures for blocks that did not return a result.
    Next up was C, followed by C++. These languages name their blocks of code as functions,
    as they all, except for the constructor, must return a value. Moving on to Java,
    these blocks are called methods. Let us examine the components of a method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a method, you will need to consider some or even all of these
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: Access control designation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static or non-static designation and the `this` reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override permission
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Override required
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameter variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exception handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thread setting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss these, one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Access control designation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, I presented the concepts of access control, so let
    us examine how these concepts can be applied to a method, which may be private,
    public, protected, or package:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A private method, using the `private` designation, can only be accessed by
    non-static methods in the same class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Public methods can be accessed by non-static methods in the same class. They
    can also be accessed from any other object in the program that has a reference
    variable to the object that contains the public method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Protected methods can be accessed as if they were public from any subclass
    that inherits them. We will discuss inheritance later in this chapter. A protected
    member of a class also has package access. Without inheritance and with objects
    in a different package, `protected` behaves the same as `private`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Package methods in one object can be accessed by another object in the same
    package that has a reference to it as if it were public. Objects in other packages,
    if they have the appropriate reference, consider package methods private and cannot
    access them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Static or non-static designation and the this reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A method is non-static by default. This means that when the method is invoked,
    there is always an undeclared first parameter. If other parameters exist, then
    this undeclared parameter always comes first.
  prefs: []
  type: TYPE_NORMAL
- en: The undeclared parameter is a reference to the object invoking the method. Its
    type is the class, and the identifier is `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this, let us look at some code fragments. Here is a partial class
    with just one method. Since the field and the method parameter have the same name,
    we will use the `this` reference to differentiate between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this` reference comes from the compiler adding it as the first parameter
    to the non-static method. Let us look at how the method appears after the compiler
    has added the `this` reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We instantiate the object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we call upon its method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the method is converted by the compiler as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `this` reference allows just one block of code for methods regardless of
    how many instances you create of a class.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `this` reference in the body of the method, but you cannot declare
    it. As shown earlier, the most common use of `this` is to distinguish between
    a field identifier and a local method variable with the same identifier name.
  prefs: []
  type: TYPE_NORMAL
- en: A static method, the one which you have designated by adding the `static` keyword
    to the method, does not have the `this` reference. This means that you can call
    this method without instantiating the object it belongs to first. It also means
    that it cannot call non-static methods in the same class you declared it in, nor
    can it access any non-static fields.
  prefs: []
  type: TYPE_NORMAL
- en: Override permission – final
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance is the creation of new classes derived from an existing class. We
    will look at this topic in detail later in this chapter. This means that a method
    in the derived class or subclass with the same name and the same type and number
    of parameters overrides the same method in the parent or superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `nonStaticMethod` method can be overridden if `StaticTest` is a superclass
    with an inheritance relationship, but we can prevent this if we add the `final`
    keyword to the method declaration. Now, we can no longer override `nonStaticMethod`,
    as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the `final` keyword when we declare the class. This will block
    this class from being used as a superclass. In other words, you cannot inherit
    from a `final` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, we cannot extend this class. This also means that all the methods in the
    class are effectively final, so it is not necessary to use the keyword in method
    names.
  prefs: []
  type: TYPE_NORMAL
- en: Override required – abstract
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While using or not using the `final` keyword determines whether a method can
    be overridden when inheritance is involved, we can also require that the method
    is overridden. We have just discussed how we can control whether you can override
    a method or not. Another choice is to make subclassing mandatory so that you *must*
    override the method. We accomplish this by defining an `abstract` class and declaring
    abstract methods that do not have any code, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A class with one or more abstract methods cannot be instantiated. You can only
    use it as a superclass in inheritance. Therefore, we must also designate the class
    as abstract.
  prefs: []
  type: TYPE_NORMAL
- en: Return type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Java, as with C, all methods return a result. When we declare a method, except
    for a constructor, we must show a return type. A return type may be either a primitive
    variable or a reference variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one special return type, and that is `void`. Using `void` means that
    this method does not have a `return` value and that there cannot be a `return`
    statement that returns a value in the method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This method returns nothing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method returns a primitive:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method returns a reference:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Depending on the logic you are employing in a method, there may be times when
    you wish to return or break out from a method early. In this case, when `void`
    is the return type, you may use `return` by itself. If the method is not `void`,
    then the early returns must also include the appropriate value.
  prefs: []
  type: TYPE_NORMAL
- en: Method name
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rules and conventions for naming a method are identical to that of naming
    a variable we discussed in [*Chapter 4*](B19088_04.xhtml#_idTextAnchor086), *Language
    Fundamentals – Data Types and Variables*. One difference is that while variables
    are nouns, based on naming conventions, methods are expected to be verbs.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the method name comes an opening and closing parenthesis; if left empty,
    this method does not receive any data. As already pointed out, for non-static
    methods, there is an undeclared `this` reference added in the first position of
    the parameter list. A non-static method that we write without any parameters gets
    the reference. This effectively means that all non-static methods have at least
    one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters can be any primitive type or a class reference type. A method can
    have no more than 255 parameters, although you are likely doing something wrong
    if you have anywhere near 255 parameters.
  prefs: []
  type: TYPE_NORMAL
- en: When you call a method, all that is significant is the type of values you pass.
    The identifier is not significant. If you have a parameter of the `int` type named
    `bob`, you can pass any named `int` to the method.
  prefs: []
  type: TYPE_NORMAL
- en: Java does not have a way to set a default value for a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An annotation is a hint. It can modify the behavior of your code at compile
    time or just be informative without any effect. An annotation for a method must
    appear before the method and any of its components.
  prefs: []
  type: TYPE_NORMAL
- en: An annotation is a phrase that follows the same naming conventions as a class
    and begins with the at symbol (`@`). It may have parameters within parentheses
    that follow the annotation, but these are not variable declarations as in method
    parameters. They can be anything.
  prefs: []
  type: TYPE_NORMAL
- en: 'Frameworks, such as `Servlet` class, a class instantiated and run by a web
    application server, we would annotate it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the annotation defines this class as a `WebServlet` class called
    `AddToEmailList` rather than using the class name `AddToEmailListServlet`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use annotations anywhere, not just for the web.
  prefs: []
  type: TYPE_NORMAL
- en: Exception handling – throws
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we look at the syntax of Java code in the next chapter, we will come across
    situations where you can either predict or expect errors when the program is running.
    For example, you are trying to open a connection to a database server, but the
    operation fails. The code that tries to make the connection will throw an exception.
    An exception is just an object that contains the details of the error.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the exception can either be checked or unchecked. A checked exception
    expects there to be code to deal with the exception; if you do not handle the
    exception, it is an error. An unchecked exception does not need to be handled
    and may or may not end your program.
  prefs: []
  type: TYPE_NORMAL
- en: You can also decide that when an exception occurs, it will not be handled in
    the method in which the exception occurred. Instead, you want to pass the exception
    back to the method’s caller. You do this with a `throws` clause. Here is a fragment
    of a method that connects to a database to retrieve a list of items in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we have a method that opens a connection to a
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the connection fails, an exception of the `SQLException` class type, which
    is a checked exception, will occur. This code will result in a compile-time error
    because you are not handling the checked exception. You can decide to defer handling
    the exception in the method that called this one. To do this, we add a `throws`
    clause to the method as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The compiler will now verify that this exception will be handled in the caller
    of this method.
  prefs: []
  type: TYPE_NORMAL
- en: Why not handle the exception when it occurs? We have already seen our `CompoundInterest`
    program broken into a user interface class and a business calculation class. Imagine
    that you decided to handle the error where it happened by requesting new credentials
    from the user such as a username or password. How would you do this? Do you ask
    in the console, a GUI, or a web application?
  prefs: []
  type: TYPE_NORMAL
- en: After asking the user for their database credentials in the user interface class,
    you pass this information to the `openConnection` method in the business class.
    If something goes wrong, we throw the exception and return to the calling method
    in the user interface class. The database class does not need to know what the
    user interface is. It just returns a result or an exception. This business class
    is now usable regardless of the user interface. We call this **Separation of Concerns**;
    we will explore this topic in [*Chapter 10*](B19088_10.xhtml#_idTextAnchor214),
    *Implementing Software Principles and Design Patterns* *in Java*.
  prefs: []
  type: TYPE_NORMAL
- en: Thread setting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code blocks that run concurrently use threads, as we will see in [*Chapter
    9*](B19088_09.xhtml#_idTextAnchor195), *Using Threads in Java*. In some cases,
    you want a block of code in a thread to finish before another thread can run the
    same block. One way we can force this to happen is to indicate that a method must
    run to completion before another thread can execute the same block. This is the
    role of the `synchronized` keyword, as shown in the following code block. This
    keyword is not foolproof but is a part of how we write thread-safe code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Generic parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The concept of generics is present in many languages. This means that you can
    write code in which the data type of variables is determined by a generic parameter.
    We will look more closely into this in [*Chapter 7*](B19088_07.xhtml#_idTextAnchor154),
    *Java Syntax and Exceptions*, but for now, you should recognize the generic parameter
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code block, we have declared a method to return part of a
    larger list. A list is like an array, and we will look at it in detail when we
    discuss `T`, will be, this code ensures that the result returned is the same type
    as the parameters passed to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This code fragment will return a list of objects of a type to be determined
    at compile time. The first `<T>`, the generic parameter, informs the compiler
    that `T` is a type parameter that will be determined by whatever code calls this
    method. In this example, it shows that the given `List` can be of any type of
    object, and this method will return a sub-list of the same type.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever language you are transitioning from, I don’t suspect you ever considered
    using at least 11 different concepts to declare a method. There is no requirement
    that you use all 11 when declaring a method. That we have as many as 11 pieces
    available is one of the aspects of Java that makes it the ideal language for a
    wide range of applications.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the basic syntax of the Java language as used in methods in
    the next chapter. Next up, let us understand the relationships that classes and
    objects can have with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What do you do when you have a class that does almost everything you need to
    get done? What do you do when you have methods in a class that don’t quite do
    what you need to get done? How do you deal with these two issues if you do not
    have access to the source code of the class and its methods? What if you do have
    access to the source code, but other parts of your program expect the original
    unchanged code? The answer is **inheritance**.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is described as a relationship between two classes in which one
    class is called the **superclass**. This class contains the fields and methods
    to handle a specific task. This superclass is a generalization, and sometimes
    you need to enhance this kind of class. In this case, rather than rewriting the
    original class, you can create a new class called the **subclass** that inherits
    or specializes the superclass by overriding methods in the superclass or adding
    additional methods and fields. The subclass is now made up of the public and protected
    methods of the superclass as well as what it has added. A subclass may also be
    called a derived or child class in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you must write a program that manages bank accounts. All accounts,
    such as chequing and savings, have similar tasks they must perform. You must be
    able to deposit money and withdraw money. At the end of the defined period, such
    as monthly, there are tasks that must be carried out that are similar but not
    quite the same for our two account types. Here is where inheritance can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: In this program, we define a superclass with common elements. We then create
    two subclasses that inherit the public and protected members of the superclass.
    This is commonly described as an **is-a** relationship, meaning that the subclass
    is a type of superclass. We will see how we use this relationship when we look
    at **polymorphism**.
  prefs: []
  type: TYPE_NORMAL
- en: Here is a **Unified Modeling Language** (**UML**) diagram. This diagram style
    is useful for planning what classes you will need to solve a problem and what
    the relationship between these classes will be. We begin by simply creating a
    box for each class and then joining the boxes with lines. The line ending describes
    the relationship. The hollow triangle signifies inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following figure, we see that `BankAccount` will be the superclass while
    `SavingsAccount` and `ChequingAccount` are subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – The BankAccount inheritance hierarchy](img/B19088_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – The BankAccount inheritance hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we use inheritance to share data and functionality between
    the superclass and the subclasses. There will never be an object of the `BankAccount`
    type, only objects of the `SavingsAccount` and `ChequingAccount` types. This will
    mean that `BankAccount` will be an abstract class. An abstract class, denoted
    by the class name being in italics, cannot be instantiated into an object; it
    can only be used as a superclass, so `BankAccount` will hold the data elements.
    These elements must be accessible to the subclasses but are private to any other
    classes in the system. To define access control in a UML diagram, we use the following
    prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: An octothorpe (`#`) means the method or field is protected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The plus sign (`+`) means the class, method, or field is public
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The minus sign (`-`) means the class, method, or field is private
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The absence of a prefix means the method or field is package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we are showing that all the fields in `BankAccount` are protected and
    available to the two subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.2 –\uFEFF The BankAccount class fields](img/B19088_06_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The BankAccount class fields
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of this inheritance design is to determine what methods will
    be required. Here we can see the methods in the superclass and subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Methods and their access control](img/B19088_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Methods and their access control
  prefs: []
  type: TYPE_NORMAL
- en: In the case of `BankAccount`, the three tasks—deposit, withdrawal, and report—each
    have a method that performs the actions common to both account types. These methods
    will be called upon by the subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: '`SavingsAccount`, by its nature, must override each of the `BankAccount` methods.
    To override means to have a method with the same name and the same parameters.
    The `return` type can be different but must be a subclass of the original `return`
    type. The methods in the subclass can call upon the overridden method in the superclass
    by prefixing the method call with the `super` reference, such as `super.makeDeposit(amt)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ChequingAccount` only overrides two of the superclass methods. It does not
    override `makeDeposit`, as how the superclass handles this is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance is a one-way street. The subclass can call upon public and protected
    members of the superclass, but the superclass is unaware of the subclass.
  prefs: []
  type: TYPE_NORMAL
- en: The inheritance model that only overrides superclass methods in the subclass
    and does not add any additional public methods or variables in the subclass is
    referred to as **pure inheritance**. The inheritance model that adds additional
    methods and variables to the subclass and may or may not override any superclass
    methods is described as an **is-like-a** relationship and is called an **extension**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We code inheritance of both types using the `extends` keyword. Assuming we
    have defined the `BankAccount` superclass, then we code inheritance as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public class SavingsAccount extends BankAccount { … }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`public class ChequingAccount extends BankAccount { … }`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will need to examine the code in the subclass to determine which approach,
    pure inheritance or extension, is taken.
  prefs: []
  type: TYPE_NORMAL
- en: When instantiated, each of these objects will have its own dataset from its
    superclass and, if the inheritance is an extension, then its own fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `BankAccount` class will be declared as abstract.
    This means that you cannot instantiate `BankAccount` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This will be flagged as an error by the compiler because `BankAccount` is abstract.
    If we had any abstract methods in `BankAccount`, we would be required to override
    them in `SavingsAccount` and `ChequingAccount`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The C++ language supports **multiple inheritances**. This means that a subclass
    can have more than one superclass. The designers of Java chose to only support
    single inheritance. You can only extend a class with a single superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not want your class to be available for inheritance, you can add
    the `final` designation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If we now attempt to create an inherited or derived class, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: An error will be declared when we try and compile this code.
  prefs: []
  type: TYPE_NORMAL
- en: The superclass of all objects, the Object class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Java, all classes extend a special class called `Object` is always available.
    Why does the `Object` class exist? The `Object` class defines methods to support
    threading and object management in any class. This means that every class has
    these methods and may choose to override any of them or use them as is. There
    are three of these methods that are frequently overridden in a class. The first
    of these is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The default implementation inherited from `Object` compares the address of
    the object that invokes `equals` to the object passed as a parameter. This means
    it can only be `true` if two references contain the same address in memory to
    an object. In most cases, you will likely want to compare the values in an object’s
    fields, and therefore you will frequently want to override it. For example, see
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `equals` method performs four tests that must all be passed for one object
    to be equal to another. These are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `this` reference and `obj` contain the same memory address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comparative `obj` is not `null`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both references are for the same class type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, it compares the value of the fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next commonly overridden method is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: When comparing multiple fields in two objects, the necessary code can be quite
    time-consuming. If you need to compare two strings, it will be necessary to compare
    them one character at a time. You will need to compare each one for a class with
    many fields. There is an optimization, and that is **hashCode**.
  prefs: []
  type: TYPE_NORMAL
- en: A hash is an integer computed from the fields in an object. Computing hash values
    is, in most cases, faster than comparing fields one at a time. The default value
    from this method, if it is not overridden, is the address in memory at which the
    object resides. What you will want to do is calculate a hash value based on the
    object’s fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a method that overrides the `Object` class’s `hashCode`
    method with its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The value generated is not a unique value. It is possible that two objects with
    different values would generate the same hash code. What we do know for certain
    is that if the hash codes of two objects are not the same, then the objects, based
    on the fields, are not equal. If the hash code is the same for two objects, then
    to be certain that they are equal, you must now use the `equals` method. This
    will, in almost all cases, speed up the process of comparing objects because the
    slower `equals` method is only called when the hash codes are the same.
  prefs: []
  type: TYPE_NORMAL
- en: One other application of `hashCode` is in data structures—structures that store
    data as a pair of values called the key and value, where the value is an object.
    The value that `hashCode` returns is an integer value that is used as the key.
    As the integer is processed faster than any of the other primitives, these data
    structures perform more efficiently as compared to structures that can use any
    type as the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last of the three commonly overridden methods is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of this method in the `Object` class returns the object’s
    address as returned by the `hashCode` method and the name of the class. Overriding
    it to return the values of the fields as a String can be far more useful. By overloading
    it, you can inspect the state of an object, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Let us now look at an alternative to inheritance in Java, a **class interface**.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the class interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a programming language that has access control features, public methods are
    called the class **interface**. These are the methods that can be called from
    any other object in a system that has a reference to the object it wants to use.
    In Java, we can create a contract that will require any class that implements
    the contract, called an interface, to implement all the methods listed in the
    interface as public methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an interface for reading and writing to a relational database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this code block for an interface class, each method is declared as an abstract
    method, as it ends with a semicolon and does not have a code block. They are all
    public by default as well – hence, the lack of the `public` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use an interface when we declare the class. The implementing class must
    now have public methods as described in the interface. The following are the first
    few lines of a class that implements `GamingDAO`. I have not included the implementation
    of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Each method has the `@Override` annotation. This is an informative annotation
    and is optional in this case. Your code will be more easily understood by other
    developers if you use this annotation. You are also informing the compiler to
    watch out for any changes in the superclass methods and if they are found, the
    compiler will complain. This is the original application of a Java interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Java 8 and then Java 9 modified what can be contained in an interface. The
    changes to the original definition of an interface class are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Having the `default` interface method. This is a `public` method implemented
    in the interface rather than in the implementing class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having `private` methods implemented in the interface class. These `private`
    methods can only be called by a `default` method, or they can be called by other
    `private` methods declared in the interface. Therefore, as in the following code
    block, I can call `write4()` from `write2()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having `static` methods implemented in the interface class. As with all `static`
    methods, it does not have a `this` reference, so it cannot call upon other methods
    in the interface or class. It must be a public method, so the `public` keyword
    is not required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of these three types of methods that can exist in an interface
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If we implement this interface, then the only method that we are under contract
    to implement is `write1()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the `main` method, the object we are creating, `WritingTool`,
    has its reference assigned to an object of the `Pencil` type. You cannot write
    `new Pencil()`, but you use `Pencil` as the reference type when you create `WritingTool`.
    This will restrict your use of the code in the `WritingTool` class to just the
    overridden methods. The last call in the `main` method, `tool.write5()`, will
    generate a compiler error because the `write5` method is not part of the `Pencil`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: The implementing class, in this case, `WritingTool`, can have additional methods
    of any access control designation not listed in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: It is considered a best practice to define the public methods of a class in
    an interface class. It is not necessary to list every public method and a class
    may have multiple interfaces so that what you can do with a class can be restricted
    to a specific set of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract class versus interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an abstract superclass, you must implement every abstract method in the subclass.
    This might lead you to believe that an abstract class with every method abstract
    is the same as an interface. However, as mentioned here, there are significant
    differences between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'An abstract class may have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract method declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Class and instance variables (fields)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An additional non-abstract method of any access control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Whereas, an interface may have these:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract method declarations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default, private, or static methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There is one other significant difference – as Java only supports a single
    inheritance model, you can only extend a single superclass. On the other hand,
    you can implement multiple interfaces for a single class, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also have a subclass with a single superclass and one or more interfaces,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: However, one issue to keep an eye out for when using multiple interfaces is
    that it is a compile-time error, should there be the same abstract method in more
    than one interface. You may have an abstract method in a superclass identical
    to an abstract method in an interface.
  prefs: []
  type: TYPE_NORMAL
- en: Both interfaces and abstract classes can define what a class must implement.
    The fact that a class can only inherit from a single class makes an interface
    class more useful, as a class may have more than one interface.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes and interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, any class can be the superclass for any other class, just as any
    interface can be used with any class. However, you can restrict this behavior
    by using a **sealed class** or **sealed interface**. This means you can list the
    names of classes that may extend or implement it, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have declared a class that can only be used as a superclass to a class
    whose name is `SubClass`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have permitted `SubClass` to extend the `Sealed` class, we can
    write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this subclass must be defined as `final`. This way, it is not possible
    to have `SubClass` as a superclass for some other class. Here is a similar syntax
    for a sealed interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We have one more structure to examine, and that is `record`.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the record class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `record` object is instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its simplest, a record only needs the fields listed when the `record` class
    is declared, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When we instantiate this record, we must provide the values for name and salary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: All records have a default canonical constructor that expects a value for every
    field in the record. In a regular class, you would need to write a canonical constructor
    method to assign the values to the fields. You may add a compact constructor to
    a record that permits you to examine the value each field was assigned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a compact constructor. Notice that it does not have a parameter list,
    as it can only have a parameter for every field declared in the first line of
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'To access the value of a field, you can use the identifier as a method as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: You cannot change the value of a field in a record – you can only read its value.
    As a class, a record also extends `Object`. Furthermore, `record` provides default
    overrides for the `equals`, `hashCode`, and `toString` methods based on the fields.
  prefs: []
  type: TYPE_NORMAL
- en: A record can implement an interface and so can be in the list of a sealed interface.
    As a record is implicitly final, it cannot extend any other classes, so it cannot
    be sealed for a class or classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us examine the concept of polymorphism and see how it allows us to
    reuse code.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Polymorphism** is one of the defining features of object-oriented languages.
    Java has expanded the concept by including interfaces. Let us begin with a simple
    hierarchy of classes as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'In this trivial class, we have a public method to assign a value to `count`
    and a second method that displays the value in `count` along with the name of
    the class. In the following code block, we have a class that uses `SuperClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this, the result is as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us create a subclass from `SuperClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This subclass only overrides the `displayCount` method. Classes are about creating
    new data types. When we create a class that is a subclass, we refer to the class
    type by the superclass name. In other words, we can state that `SubClass` is of
    the `SuperClass` type. If we added a `subclass` variable to `SubClass`, then that
    class is also of the `SuperClass` type. Now let us change the `Polymorphism` class
    to use a `SubClass` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: While the `show` method is unchanged and still expects an object of the `SuperClass`
    type, we are creating an object of `SubClass` in `perform`, and then we call upon
    `show`, passing a reference to the subclass. As `SubClass` is of the `SuperClass`
    type, polymorphism permits any subclass of `SuperClass` to be passed to the `show`
    method. When we call `sc.setCount`, the runtime determines that it must use the
    `superclass` count method because there is no public method with that name in
    the subclass. When it calls upon `sc.displayCount`, it must decide whether to
    use the method that belongs to `SuperClass` that it is expecting or the method
    that belongs to the `SubClass` type that is passed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism means that methods overridden in a subclass are called in favor
    of the superclass version even when the declared type of what is being passed
    is the `SuperClass` type. The result when running the code this time is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Classes that share the same interface are also subject to polymorphism. Here
    is a simple interface that only requires the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Any class that implements this interface must override the abstract `displayCount`
    method. Now, let us create a class that implements this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let us use polymorphism with the interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In this class, we are passing the `Implementation` object to a method expecting
    the interface. When this runs, it produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Any class that implements the interface named `Interface` can be passed to any
    method that declares a parameter using the interface rather than a class.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism is a powerful tool that allows you to write code that evolves over
    time but does not require changes to existing code that uses objects that share
    an interface or inherit from the same superclass.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding composition in classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we create an application that employs numerous classes, we must decide
    how they will interact with each other. In object-oriented programming terminology,
    a method in one class that calls a method in another class is called messaging.
    Despite this, most developers describe this as calling a method, as I do. How
    objects send these messages or call methods in other objects is what **composition**
    is about.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways for objects to be connected – **association** and **aggregation**.
    Let’s discuss these connections.
  prefs: []
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In association, the object reference we need to call or message a method is
    created outside the calling object. Let’s begin with a class that we will want
    to call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a trivial method that has a method to display a String that is passed
    to it. Keep in mind that we are interested in the concepts here and not the task
    the class is responsible for. Now, let us create a class that will want to call
    or message `Receiver`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we declare a reference to the `Receiver` class. We do not plan
    for it to be changed when it is assigned an initial, so we designate it as `final`.
    We do not create an instance of this object using `new`. Rather, we expect this
    object to be created in another class and we will then pass that reference to
    the constructor. Put another way, this `Association` class does not own the reference
    to `Receiver`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of having an object declared in a class and then that object
    passed to another class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: In the `Composition` class’s `perform` method, we are instantiating an object
    of the `Receiver` type. Following this, we instantiate an object of the `Association`
    type, passing to its constructor a reference to the `Receiver` object we just
    created.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the time comes to put an object of the `Association` type out for garbage
    collection, the `Receiver` object is untouched if it is also used in another object.
    Put another way, if the `Receiver` object is in scope, meaning visible and valid,
    in another object, then the `Receiver` object is not garbage-collected. Let’s
    see rewriting `perform` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: To explicitly put an object out of scope and available for garbage collection,
    you can assign a special value named `null`. This will set the address this reference
    contains to zero, and the object will be made available for garbage collection.
    If we try to call `sendMessage` after assigning `null`, then this will be flagged
    as an error by the compiler. If we remove the error line, the final line where
    we call `displayName` in the `Receiver` object will work, as the `Association`
    class did not own the `Receiver` object. Ownership is defined as belonging to
    the object that created it. `Association` did not create `Receiver`. If the `Association`
    object’s `receive` reference is not in scope anywhere else in the program, it
    will go out for garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: Aggregation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects that are created in a class belong to or are owned by that class. When
    we create an object of the owning class, all the other objects in the class will
    be instantiated in the class. When this class goes out of scope, then everything
    it owns also goes out of scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our program employing aggregation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In this `Aggregation` class, an object of the `Receiver` type is created in
    the constructor. It is not coming from another object as it did with `Association`.
    This means that `Aggregatio`n owns the `Receiver` object and when the `Aggregation`
    object goes out of scope, so does the `Receiver` object that it instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have finished examining the building blocks or concepts
    of organizing code in Java that we began in [*Chapter 5*](B19088_05.xhtml#_idTextAnchor106),
    *Language Fundamentals – Classes*. We looked at methods and a range of issues
    that need to be considered when writing a method. From there, we examined inheritance,
    a way in which we can reuse or share code.
  prefs: []
  type: TYPE_NORMAL
- en: The interface introduced the concept of a contract or list of methods that must
    be written by any class that implements the interface. The specialized class type
    called `record` for simplifying the creation of immutable objects was next up.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance and interfaces support the concept of polymorphism. This permits
    the creation of methods that expect an instance of a superclass or interface class
    but receive an instance of any class that either inherits or extends the superclass
    or implements the interface.
  prefs: []
  type: TYPE_NORMAL
- en: We ended the chapter by looking at how we connect objects to objects. Composition
    implies that the object is created outside of the object that has a reference.
    The reference must be passed to the object either through the constructor or another
    method. Aggregation implies that the object we need to use is created inside the
    object that wishes to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we will finally review the syntax of the Java language.
  prefs: []
  type: TYPE_NORMAL
