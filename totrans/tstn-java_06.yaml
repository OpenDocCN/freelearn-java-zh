- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Methods, Interfaces, Records, and Their Relationships
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法、接口、记录及其关系
- en: In Java, how we define and organize our code is the cornerstone of the language.
    In this chapter, we will begin by examining the role that a method plays in Java.
    From here, we will examine the relationships afforded by inheritance and interface.
    The immutable `record` class is next up. Polymorphism, the ability to use objects
    in a hierarchy of classes, as it applies to inheritance and interface, is covered
    next. We will finish the chapter by looking at the relationships between objects
    and how they can call upon methods in other objects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，我们定义和组织代码的方式是语言的基础。在本章中，我们将首先检查方法在Java中的作用。从这里，我们将检查继承和接口提供的关系。接下来是不可变的`record`类。多态，即使用对象在类层次结构中的能力，作为继承和接口的应用，也将被覆盖。我们将通过查看对象之间的关系以及它们如何调用其他对象中的方法来结束本章。
- en: 'We will learn about the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Understanding methods
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解方法
- en: Understanding inheritance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解继承
- en: Understanding the class interface
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类接口
- en: Understanding the `record` class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`record`类
- en: Understanding polymorphism
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解多态
- en: Understanding composition in classes
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类中的组合
- en: By understanding all the components and relationships available in Java, you’ll
    be able to read or write Java code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解Java中所有可用组件和关系，你将能够阅读或编写Java代码。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are the tools required to run the examples in this chapter:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是运行本章示例所需的工具：
- en: Java 17 installed
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Java 17
- en: A text editor
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个文本编辑器
- en: Maven 3.8.6 or a newer version installed
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已安装Maven 3.8.6或更高版本
- en: The sample code for this chapter is available at [https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的示例代码可在[https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06](https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter06)找到。
- en: Understanding methods
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解方法
- en: Now, I must admit that I have been coding since 1980, and since then, the term
    we use to describe discrete blocks of code has changed. When I started coding
    in 1980 using **BASIC**, an unstructured language, I quickly learned to break
    my code up into subroutines. From BASIC, I moved on to **Pascal**, where there
    is a formal designation for blocks of code. These were **functions** for blocks
    that returned a result and procedures for blocks that did not return a result.
    Next up was C, followed by C++. These languages name their blocks of code as functions,
    as they all, except for the constructor, must return a value. Moving on to Java,
    these blocks are called methods. Let us examine the components of a method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我必须承认，我从1980年开始编码，从那时起，我们用来描述代码离散块术语已经改变。当我1980年开始使用**BASIC**，一种无结构语言编码时，我很快学会了将我的代码分解成子程序。从BASIC，我转向**Pascal**，其中代码块有一个正式的指定。这些是为返回结果的**函数**和没有返回结果的**过程**。接下来是C，然后是C++。这些语言将它们的代码块命名为函数，因为它们所有（除了构造函数）都必须返回一个值。转向Java，这些块被称为方法。让我们来检查方法组件。
- en: 'When creating a method, you will need to consider some or even all of these
    components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建方法时，你需要考虑一些甚至所有这些组件：
- en: Access control designation
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制指定
- en: Static or non-static designation and the `this` reference
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态或非静态指定和`this`引用
- en: Override permission
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写权限
- en: Override required
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要重写
- en: Return type
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回类型
- en: Method name
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名
- en: Parameter variables
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数变量
- en: Annotations
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注解
- en: Exception handling
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常处理
- en: Thread setting
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程设置
- en: Generic parameters
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型参数
- en: Let’s discuss these, one by one.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一讨论。
- en: Access control designation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问控制指定
- en: 'In the previous chapter, I presented the concepts of access control, so let
    us examine how these concepts can be applied to a method, which may be private,
    public, protected, or package:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我介绍了访问控制的概念，因此让我们看看这些概念如何应用于可能为私有、公共、受保护或包的方法：
- en: 'A private method, using the `private` designation, can only be accessed by
    non-static methods in the same class:'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`private`指定符的私有方法只能被同一类中的非静态方法访问：
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Public methods can be accessed by non-static methods in the same class. They
    can also be accessed from any other object in the program that has a reference
    variable to the object that contains the public method:'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公共方法可以被同一类中的非静态方法访问。它们也可以被程序中任何具有指向包含公共方法的对象的引用变量的其他对象访问：
- en: '[PRE1]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Protected methods can be accessed as if they were public from any subclass
    that inherits them. We will discuss inheritance later in this chapter. A protected
    member of a class also has package access. Without inheritance and with objects
    in a different package, `protected` behaves the same as `private`:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 受保护的成员可以从继承它们的任何子类中像公共方法一样访问。我们将在本章后面讨论继承。类的一个受保护成员也具有包访问权限。在没有继承和不同包中的对象的情况下，`protected`的行为与`private`相同：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Package methods in one object can be accessed by another object in the same
    package that has a reference to it as if it were public. Objects in other packages,
    if they have the appropriate reference, consider package methods private and cannot
    access them:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含在一个对象中的方法可以被同一包中具有对其引用的其他对象访问，就像它是公共的。其他包中的对象，如果它们有适当的引用，将包方法视为私有，无法访问它们：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Static or non-static designation and the this reference
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态或非静态的指定以及this引用
- en: A method is non-static by default. This means that when the method is invoked,
    there is always an undeclared first parameter. If other parameters exist, then
    this undeclared parameter always comes first.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 方法默认是非静态的。这意味着当方法被调用时，始终有一个未声明的第一个参数。如果存在其他参数，则这个未声明的参数始终位于第一位。
- en: The undeclared parameter is a reference to the object invoking the method. Its
    type is the class, and the identifier is `this`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 未声明的参数是对调用方法的对象的引用。它的类型是类，标识符是`this`。
- en: 'To understand this, let us look at some code fragments. Here is a partial class
    with just one method. Since the field and the method parameter have the same name,
    we will use the `this` reference to differentiate between them:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，让我们看看一些代码片段。这里有一个只有一个方法的类的一部分。由于字段和方法参数具有相同的名称，我们将使用`this`引用来区分它们：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `this` reference comes from the compiler adding it as the first parameter
    to the non-static method. Let us look at how the method appears after the compiler
    has added the `this` reference:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`引用是由编译器添加的，作为非静态方法的第一个参数。让我们看看编译器添加了`this`引用后方法是如何出现的：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We instantiate the object, as shown here:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实例化对象，如下所示：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, we call upon its method, as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用它的方法，如下所示：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, the method is converted by the compiler as shown:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，编译器将方法转换为以下形式：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `this` reference allows just one block of code for methods regardless of
    how many instances you create of a class.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`引用允许方法只有一个代码块，无论你创建了类的多少个实例。'
- en: You can use the `this` reference in the body of the method, but you cannot declare
    it. As shown earlier, the most common use of `this` is to distinguish between
    a field identifier and a local method variable with the same identifier name.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在方法体中使用`this`引用，但不能声明它。如前所述，`this`最常见的使用是区分具有相同标识符名称的字段标识符和局部方法变量。
- en: A static method, the one which you have designated by adding the `static` keyword
    to the method, does not have the `this` reference. This means that you can call
    this method without instantiating the object it belongs to first. It also means
    that it cannot call non-static methods in the same class you declared it in, nor
    can it access any non-static fields.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法，即通过添加`static`关键字指定的方法，没有`this`引用。这意味着你可以先不实例化它所属的对象就调用这个方法。这也意味着它不能调用同一类中声明的非静态方法，也不能访问任何非静态字段。
- en: Override permission – final
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写权限 - final
- en: Inheritance is the creation of new classes derived from an existing class. We
    will look at this topic in detail later in this chapter. This means that a method
    in the derived class or subclass with the same name and the same type and number
    of parameters overrides the same method in the parent or superclass.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是从现有类创建新类的过程。我们将在本章后面详细讨论这个主题。这意味着派生类或子类中具有相同名称、相同类型和参数数量的方法会覆盖父类或超类中的相同方法。
- en: 'The `nonStaticMethod` method can be overridden if `StaticTest` is a superclass
    with an inheritance relationship, but we can prevent this if we add the `final`
    keyword to the method declaration. Now, we can no longer override `nonStaticMethod`,
    as shown in the following code block:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`StaticTest`是一个具有继承关系的超类，则`nonStaticMethod`方法可以被重写，但如果我们将`final`关键字添加到方法声明中，我们可以防止这种情况。现在，我们不能再重写`nonStaticMethod`，如下面的代码块所示：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can also use the `final` keyword when we declare the class. This will block
    this class from being used as a superclass. In other words, you cannot inherit
    from a `final` class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在声明类时使用`final`关键字。这将阻止这个类被用作超类。换句话说，你不能从一个`final`类继承：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we cannot extend this class. This also means that all the methods in the
    class are effectively final, so it is not necessary to use the keyword in method
    names.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们不能再扩展这个类。这也意味着类中的所有方法实际上都是`final`的，所以没有必要在方法名中使用关键字。
- en: Override required – abstract
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 必须重写 - 抽象
- en: 'While using or not using the `final` keyword determines whether a method can
    be overridden when inheritance is involved, we can also require that the method
    is overridden. We have just discussed how we can control whether you can override
    a method or not. Another choice is to make subclassing mandatory so that you *must*
    override the method. We accomplish this by defining an `abstract` class and declaring
    abstract methods that do not have any code, as shown in the following code block:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用或不使用`final`关键字来决定方法在涉及继承时是否可以被重写的同时，我们还可以要求方法必须被重写。我们刚刚讨论了如何控制你是否可以重写一个方法。另一个选择是强制子类化，这样你*必须*重写该方法。我们通过定义一个`abstract`类并声明没有代码的抽象方法来实现这一点，如下面的代码块所示：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A class with one or more abstract methods cannot be instantiated. You can only
    use it as a superclass in inheritance. Therefore, we must also designate the class
    as abstract.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个或多个抽象方法的类不能被实例化。你只能将其用作继承中的超类。因此，我们必须也将该类指定为抽象的。
- en: Return type
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回类型
- en: In Java, as with C, all methods return a result. When we declare a method, except
    for a constructor, we must show a return type. A return type may be either a primitive
    variable or a reference variable.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，与C语言一样，所有方法都返回一个结果。当我们声明一个方法时，除了构造函数外，我们必须显示返回类型。返回类型可以是原始变量或引用变量。
- en: 'There is one special return type, and that is `void`. Using `void` means that
    this method does not have a `return` value and that there cannot be a `return`
    statement that returns a value in the method:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种特殊的返回类型，那就是`void`。使用`void`意味着此方法没有返回值，且在方法中不能有返回值的`return`语句：
- en: 'This method returns nothing:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法不返回任何内容：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This method returns a primitive:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法返回一个原始类型：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This method returns a reference:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法返回一个引用：
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Depending on the logic you are employing in a method, there may be times when
    you wish to return or break out from a method early. In this case, when `void`
    is the return type, you may use `return` by itself. If the method is not `void`,
    then the early returns must also include the appropriate value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你在方法中使用的逻辑，可能会有时候你想提前返回或跳出方法。在这种情况下，当返回类型为`void`时，你可以单独使用`return`。如果方法不是`void`，那么提前返回也必须包括适当的值。
- en: Method name
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法名
- en: The rules and conventions for naming a method are identical to that of naming
    a variable we discussed in [*Chapter 4*](B19088_04.xhtml#_idTextAnchor086), *Language
    Fundamentals – Data Types and Variables*. One difference is that while variables
    are nouns, based on naming conventions, methods are expected to be verbs.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 命名方法的规则和约定与我们讨论过的命名变量的规则和约定相同，见[*第4章*](B19088_04.xhtml#_idTextAnchor086)，*语言基础
    - 数据类型和变量*。一个区别是，根据命名约定，变量是名词，而方法则期望是动词。
- en: Parameter variables
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参数变量
- en: After the method name comes an opening and closing parenthesis; if left empty,
    this method does not receive any data. As already pointed out, for non-static
    methods, there is an undeclared `this` reference added in the first position of
    the parameter list. A non-static method that we write without any parameters gets
    the reference. This effectively means that all non-static methods have at least
    one parameter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 方法名之后跟着一个开括号和闭括号；如果为空，则此方法不接收任何数据。正如已经指出的，对于非静态方法，在参数列表的第一个位置会自动添加一个未声明的`this`引用。如果我们编写一个没有任何参数的非静态方法，则会得到这个引用。这实际上意味着所有非静态方法至少有一个参数。
- en: Parameters can be any primitive type or a class reference type. A method can
    have no more than 255 parameters, although you are likely doing something wrong
    if you have anywhere near 255 parameters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 参数可以是任何原始类型或类引用类型。一个方法最多可以有255个参数，尽管如果你有接近255个参数，那么你很可能在做一些错误的事情。
- en: When you call a method, all that is significant is the type of values you pass.
    The identifier is not significant. If you have a parameter of the `int` type named
    `bob`, you can pass any named `int` to the method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个方法时，重要的是你传递的值的类型。标识符并不重要。如果你有一个名为 `bob` 的 `int` 类型参数，你可以传递任何命名的 `int`
    给这个方法。
- en: Java does not have a way to set a default value for a parameter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Java 没有为参数设置默认值的方法。
- en: Annotations
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注解
- en: An annotation is a hint. It can modify the behavior of your code at compile
    time or just be informative without any effect. An annotation for a method must
    appear before the method and any of its components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一个提示。它可以在编译时修改你的代码的行为，或者只是提供信息而不产生任何效果。一个方法注解必须出现在方法及其任何组件之前。
- en: An annotation is a phrase that follows the same naming conventions as a class
    and begins with the at symbol (`@`). It may have parameters within parentheses
    that follow the annotation, but these are not variable declarations as in method
    parameters. They can be anything.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一个遵循与类相同的命名约定并以下划线符号（`@`）开头的短语。它可以在括号内包含注解后的参数，但这些不是方法参数中的变量声明。它们可以是任何东西。
- en: 'Frameworks, such as `Servlet` class, a class instantiated and run by a web
    application server, we would annotate it as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 框架，如 `Servlet` 类，这是一个由网络应用程序服务器实例化和运行类，我们会这样注解它：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, the annotation defines this class as a `WebServlet` class called
    `AddToEmailList` rather than using the class name `AddToEmailListServlet`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，注解将这个类定义为名为 `AddToEmailList` 的 `WebServlet` 类，而不是使用类名 `AddToEmailListServlet`。
- en: You can use annotations anywhere, not just for the web.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何地方使用注解，而不仅仅是用于网络。
- en: Exception handling – throws
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常处理 – 抛出
- en: When we look at the syntax of Java code in the next chapter, we will come across
    situations where you can either predict or expect errors when the program is running.
    For example, you are trying to open a connection to a database server, but the
    operation fails. The code that tries to make the connection will throw an exception.
    An exception is just an object that contains the details of the error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在下一章查看 Java 代码的语法时，我们会遇到在程序运行时可以预测或期望出现错误的情况。例如，你试图打开到数据库服务器的连接，但操作失败。尝试建立连接的代码将抛出一个异常。异常只是一个包含错误详情的对象。
- en: In Java, the exception can either be checked or unchecked. A checked exception
    expects there to be code to deal with the exception; if you do not handle the
    exception, it is an error. An unchecked exception does not need to be handled
    and may or may not end your program.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，异常可以是检查型或非检查型。检查型异常期望有代码来处理异常；如果你不处理异常，它就是一个错误。非检查型异常不需要处理，可能会或可能不会结束你的程序。
- en: You can also decide that when an exception occurs, it will not be handled in
    the method in which the exception occurred. Instead, you want to pass the exception
    back to the method’s caller. You do this with a `throws` clause. Here is a fragment
    of a method that connects to a database to retrieve a list of items in the database.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以决定当发生异常时，不要在发生异常的方法中处理它。相反，你希望将异常传递回调用该方法。你可以通过 `throws` 子句来完成这个操作。以下是一个连接到数据库以检索数据库中项目列表的方法片段。
- en: 'In the following code block, we have a method that opens a connection to a
    database:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们有一个打开数据库连接的方法：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the connection fails, an exception of the `SQLException` class type, which
    is a checked exception, will occur. This code will result in a compile-time error
    because you are not handling the checked exception. You can decide to defer handling
    the exception in the method that called this one. To do this, we add a `throws`
    clause to the method as shown in the following code block:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接失败，将发生 `SQLException` 类型的异常，这是一个检查型异常。这段代码将导致编译时错误，因为你没有处理检查型异常。你可以决定在调用此方法的方法中延迟处理异常。为此，我们在方法中添加一个
    `throws` 子句，如下面的代码块所示：
- en: '[PRE17]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The compiler will now verify that this exception will be handled in the caller
    of this method.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器现在将验证这个异常将在调用此方法的地方被处理。
- en: Why not handle the exception when it occurs? We have already seen our `CompoundInterest`
    program broken into a user interface class and a business calculation class. Imagine
    that you decided to handle the error where it happened by requesting new credentials
    from the user such as a username or password. How would you do this? Do you ask
    in the console, a GUI, or a web application?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不在异常发生时处理它？我们已经看到我们的`CompoundInterest`程序被分解为用户界面类和业务计算类。想象一下，你决定在发生错误的地方处理错误，例如请求用户的新凭据，如用户名或密码。你将如何做？你是在控制台、GUI还是Web应用程序中询问？
- en: After asking the user for their database credentials in the user interface class,
    you pass this information to the `openConnection` method in the business class.
    If something goes wrong, we throw the exception and return to the calling method
    in the user interface class. The database class does not need to know what the
    user interface is. It just returns a result or an exception. This business class
    is now usable regardless of the user interface. We call this **Separation of Concerns**;
    we will explore this topic in [*Chapter 10*](B19088_10.xhtml#_idTextAnchor214),
    *Implementing Software Principles and Design Patterns* *in Java*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户界面类中询问用户数据库凭据后，你将此信息传递给业务类中的`openConnection`方法。如果出现问题，我们抛出异常并返回到用户界面类的调用方法。数据库类不需要知道用户界面是什么。它只是返回一个结果或异常。现在，无论用户界面如何，这个业务类都是可用的。我们称之为**关注点分离**；我们将在[*第10章*](B19088_10.xhtml#_idTextAnchor214)《在Java中实现软件原则和设计模式》中探讨这个主题。
- en: Thread setting
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程设置
- en: 'Code blocks that run concurrently use threads, as we will see in [*Chapter
    9*](B19088_09.xhtml#_idTextAnchor195), *Using Threads in Java*. In some cases,
    you want a block of code in a thread to finish before another thread can run the
    same block. One way we can force this to happen is to indicate that a method must
    run to completion before another thread can execute the same block. This is the
    role of the `synchronized` keyword, as shown in the following code block. This
    keyword is not foolproof but is a part of how we write thread-safe code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 并发运行的代码块使用线程，正如我们将在[*第9章*](B19088_09.xhtml#_idTextAnchor195)《在Java中使用线程》中看到的。在某些情况下，你希望一个线程中的代码块在另一个线程可以运行相同的代码块之前完成。我们可以强制这种情况发生的一种方法是指示一个方法必须在另一个线程可以执行相同的代码块之前运行完成。这就是`synchronized`关键字的作用，如下面的代码块所示。这个关键字并不是万无一失的，但它是我们编写线程安全代码的一部分：
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Generic parameters
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型参数
- en: The concept of generics is present in many languages. This means that you can
    write code in which the data type of variables is determined by a generic parameter.
    We will look more closely into this in [*Chapter 7*](B19088_07.xhtml#_idTextAnchor154),
    *Java Syntax and Exceptions*, but for now, you should recognize the generic parameter
    syntax.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型概念存在于许多语言中。这意味着你可以编写代码，其中变量的数据类型由泛型参数确定。我们将在[*第7章*](B19088_07.xhtml#_idTextAnchor154)《Java语法和异常》中更详细地探讨这一点，但到目前为止，你应该能够识别泛型参数语法。
- en: 'In the following code block, we have declared a method to return part of a
    larger list. A list is like an array, and we will look at it in detail when we
    discuss `T`, will be, this code ensures that the result returned is the same type
    as the parameters passed to the method:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码块中，我们声明了一个方法来返回较大列表的一部分。列表就像数组一样，当我们讨论`T`时，我们会详细探讨它，此代码确保返回的结果与传递给方法的参数类型相同：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code fragment will return a list of objects of a type to be determined
    at compile time. The first `<T>`, the generic parameter, informs the compiler
    that `T` is a type parameter that will be determined by whatever code calls this
    method. In this example, it shows that the given `List` can be of any type of
    object, and this method will return a sub-list of the same type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段将返回一个在编译时确定类型的对象列表。第一个`<T>`，泛型参数，通知编译器`T`是一个类型参数，它将由调用此方法的任何代码确定。在这个例子中，它表明给定的`List`可以是任何类型的对象，并且此方法将返回相同类型的子列表。
- en: Whatever language you are transitioning from, I don’t suspect you ever considered
    using at least 11 different concepts to declare a method. There is no requirement
    that you use all 11 when declaring a method. That we have as many as 11 pieces
    available is one of the aspects of Java that makes it the ideal language for a
    wide range of applications.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你从哪种语言过渡过来，我怀疑你从未考虑过使用至少11个不同的概念来声明一个方法。在声明方法时，没有要求你必须使用所有11个。我们有这么多可用的部分是Java成为广泛应用的理想语言的一个方面。
- en: We will look at the basic syntax of the Java language as used in methods in
    the next chapter. Next up, let us understand the relationships that classes and
    objects can have with each other.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一章中查看Java语言的基本语法，它在方法中使用。接下来，让我们了解类和对象之间可以存在的相互关系。
- en: Understanding inheritance
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解继承
- en: What do you do when you have a class that does almost everything you need to
    get done? What do you do when you have methods in a class that don’t quite do
    what you need to get done? How do you deal with these two issues if you do not
    have access to the source code of the class and its methods? What if you do have
    access to the source code, but other parts of your program expect the original
    unchanged code? The answer is **inheritance**.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个几乎可以做你需要完成的几乎所有事情的课程时，你会怎么做？当你有一个在类中的方法并不完全做你需要完成的事情时，你会怎么做？如果你没有访问该类及其方法的源代码，你会如何处理这两个问题？如果你确实可以访问源代码，但你的程序的其他部分期望原始未更改的代码呢？答案是**继承**。
- en: Inheritance is described as a relationship between two classes in which one
    class is called the **superclass**. This class contains the fields and methods
    to handle a specific task. This superclass is a generalization, and sometimes
    you need to enhance this kind of class. In this case, rather than rewriting the
    original class, you can create a new class called the **subclass** that inherits
    or specializes the superclass by overriding methods in the superclass or adding
    additional methods and fields. The subclass is now made up of the public and protected
    methods of the superclass as well as what it has added. A subclass may also be
    called a derived or child class in other languages.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 继承被描述为两个类之间的关系，其中一个类被称为**超类**。这个类包含处理特定任务的字段和方法。这个超类是一般化，有时你需要增强这种类。在这种情况下，你不必重写原始类，而是可以创建一个新的类，称为**子类**，通过覆盖超类中的方法或添加额外的字段和方法来继承或专门化超类。子类现在由超类的公共和受保护方法以及它所添加的内容组成。在另一些语言中，子类也可能被称为派生类或子类。
- en: Imagine that you must write a program that manages bank accounts. All accounts,
    such as chequing and savings, have similar tasks they must perform. You must be
    able to deposit money and withdraw money. At the end of the defined period, such
    as monthly, there are tasks that must be carried out that are similar but not
    quite the same for our two account types. Here is where inheritance can be useful.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你必须编写一个管理银行账户的程序。所有账户，如支票和储蓄，都必须执行类似但又不完全相同的任务。你必须能够存款和取款。在定义的期限结束时，例如每月，必须执行一些任务，这些任务对于我们的两种账户类型来说是类似的，但又不完全相同。这就是继承可以发挥作用的地方。
- en: In this program, we define a superclass with common elements. We then create
    two subclasses that inherit the public and protected members of the superclass.
    This is commonly described as an **is-a** relationship, meaning that the subclass
    is a type of superclass. We will see how we use this relationship when we look
    at **polymorphism**.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们定义了一个包含公共元素的超类。然后我们创建了两个子类，它们继承自超类的公共和受保护成员。这通常被描述为**is-a**关系，意味着子类是超类的一种类型。当我们研究**多态**时，我们将看到如何使用这种关系。
- en: Here is a **Unified Modeling Language** (**UML**) diagram. This diagram style
    is useful for planning what classes you will need to solve a problem and what
    the relationship between these classes will be. We begin by simply creating a
    box for each class and then joining the boxes with lines. The line ending describes
    the relationship. The hollow triangle signifies inheritance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个**统一建模语言**（**UML**）图。这种图样式对于规划解决一个问题的所需类及其之间的关系非常有用。我们首先为每个类创建一个框，然后用线连接这些框。线的末端描述了关系。空心三角形表示继承。
- en: 'In the following figure, we see that `BankAccount` will be the superclass while
    `SavingsAccount` and `ChequingAccount` are subclasses:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，我们可以看到`BankAccount`将是超类，而`SavingsAccount`和`ChequingAccount`是子类：
- en: '![Figure 6.1 – The BankAccount inheritance hierarchy](img/B19088_06_01.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – BankAccount继承层次结构](img/B19088_06_01.jpg)'
- en: Figure 6.1 – The BankAccount inheritance hierarchy
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – BankAccount继承层次结构
- en: 'In this example, we use inheritance to share data and functionality between
    the superclass and the subclasses. There will never be an object of the `BankAccount`
    type, only objects of the `SavingsAccount` and `ChequingAccount` types. This will
    mean that `BankAccount` will be an abstract class. An abstract class, denoted
    by the class name being in italics, cannot be instantiated into an object; it
    can only be used as a superclass, so `BankAccount` will hold the data elements.
    These elements must be accessible to the subclasses but are private to any other
    classes in the system. To define access control in a UML diagram, we use the following
    prefixes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用继承在超类和子类之间共享数据和功能。将永远不会有一个`BankAccount`类型的对象，只有`SavingsAccount`和`ChequingAccount`类型的对象。这意味着`BankAccount`将是一个抽象类。抽象类，用斜体表示类名，不能实例化为对象；它只能用作超类，因此`BankAccount`将包含数据元素。这些元素必须对子类可访问，但对系统中的任何其他类都是私有的。为了在UML图中定义访问控制，我们使用以下前缀：
- en: An octothorpe (`#`) means the method or field is protected
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 八角形（`#`）表示方法或字段是受保护的
- en: The plus sign (`+`) means the class, method, or field is public
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加号（`+`）表示类、方法或字段是公共的
- en: The minus sign (`-`) means the class, method, or field is private
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减号（`-`）表示类、方法或字段是私有的
- en: The absence of a prefix means the method or field is package
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有前缀表示方法或字段是包级别的
- en: 'Here, we are showing that all the fields in `BankAccount` are protected and
    available to the two subclasses:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们展示了`BankAccount`中的所有字段都是受保护的，并且对两个子类可用：
- en: "![Figure 6.2 –\uFEFF The BankAccount class fields](img/B19088_06_02.jpg)"
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: "![图6.2 –\uFEFF BankAccount类字段](img/B19088_06_02.jpg)"
- en: Figure 6.2 – The BankAccount class fields
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – BankAccount类字段
- en: 'The last part of this inheritance design is to determine what methods will
    be required. Here we can see the methods in the superclass and subclasses:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个继承设计的最后一部分是确定需要哪些方法。在这里，我们可以看到超类和子类中的方法：
- en: '![Figure 6.3 – Methods and their access control](img/B19088_06_03.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 方法及其访问控制](img/B19088_06_03.jpg)'
- en: Figure 6.3 – Methods and their access control
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 方法及其访问控制
- en: In the case of `BankAccount`, the three tasks—deposit, withdrawal, and report—each
    have a method that performs the actions common to both account types. These methods
    will be called upon by the subclasses.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在`BankAccount`的情况下，三个任务——存款、取款和报告——每个任务都有一个执行两种账户类型共同操作的方法。这些方法将由子类调用。
- en: '`SavingsAccount`, by its nature, must override each of the `BankAccount` methods.
    To override means to have a method with the same name and the same parameters.
    The `return` type can be different but must be a subclass of the original `return`
    type. The methods in the subclass can call upon the overridden method in the superclass
    by prefixing the method call with the `super` reference, such as `super.makeDeposit(amt)`.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`SavingsAccount`由于其本质，必须重写`BankAccount`中的每个方法。重写意味着有一个具有相同名称和相同参数的方法。返回类型可以不同，但必须是原始返回类型的子类。子类中的方法可以通过在方法调用前加上`super`引用来调用超类中的重写方法，例如`super.makeDeposit(amt)`。'
- en: '`ChequingAccount` only overrides two of the superclass methods. It does not
    override `makeDeposit`, as how the superclass handles this is sufficient.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChequingAccount`类只重写了两个超类方法。它没有重写`makeDeposit`方法，因为超类处理这个方法的方式已经足够。'
- en: Inheritance is a one-way street. The subclass can call upon public and protected
    members of the superclass, but the superclass is unaware of the subclass.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 继承是一条单行道。子类可以调用超类的公共和受保护成员，但超类对子类一无所知。
- en: The inheritance model that only overrides superclass methods in the subclass
    and does not add any additional public methods or variables in the subclass is
    referred to as **pure inheritance**. The inheritance model that adds additional
    methods and variables to the subclass and may or may not override any superclass
    methods is described as an **is-like-a** relationship and is called an **extension**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 只在子类中重写超类方法而不在子类中添加任何额外的公共方法或变量的继承模型被称为**纯继承**。在子类中添加额外的方法和变量，并且可能或可能不重写任何超类方法的继承模型被描述为**is-like-a**关系，并称为**扩展**。
- en: 'We code inheritance of both types using the `extends` keyword. Assuming we
    have defined the `BankAccount` superclass, then we code inheritance as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`extends`关键字来编码两种类型的继承。假设我们已经定义了`BankAccount`超类，那么我们编码继承如下：
- en: '`public class SavingsAccount extends BankAccount { … }`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public class SavingsAccount extends BankAccount { … }`'
- en: '`public class ChequingAccount extends BankAccount { … }`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public class ChequingAccount extends BankAccount { … }`'
- en: We will need to examine the code in the subclass to determine which approach,
    pure inheritance or extension, is taken.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要检查子类的代码，以确定采用哪种方法，纯继承还是扩展。
- en: When instantiated, each of these objects will have its own dataset from its
    superclass and, if the inheritance is an extension, then its own fields.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例化时，这些对象中的每一个都将从其超类中拥有自己的数据集，如果继承是扩展，那么它还将有自己的字段。
- en: 'In the following example, the `BankAccount` class will be declared as abstract.
    This means that you cannot instantiate `BankAccount` as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`BankAccount`类将被声明为抽象。这意味着你不能如下实例化`BankAccount`：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This will be flagged as an error by the compiler because `BankAccount` is abstract.
    If we had any abstract methods in `BankAccount`, we would be required to override
    them in `SavingsAccount` and `ChequingAccount`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这将被编译器标记为错误，因为`BankAccount`是抽象的。如果我们有任何抽象方法在`BankAccount`中，我们就会被要求在`SavingsAccount`和`ChequingAccount`中重写它们。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The C++ language supports **multiple inheritances**. This means that a subclass
    can have more than one superclass. The designers of Java chose to only support
    single inheritance. You can only extend a class with a single superclass.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: C++语言支持**多重继承**。这意味着一个子类可以有一个以上的超类。Java的设计者选择只支持单一继承。你只能用一个超类扩展一个类。
- en: 'If you do not want your class to be available for inheritance, you can add
    the `final` designation, as shown here:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想你的类可以被继承，你可以添加`final`指定符，如下所示：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If we now attempt to create an inherited or derived class, we see the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试创建一个继承或派生类，我们会看到以下内容：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: An error will be declared when we try and compile this code.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试编译此代码时，将声明错误。
- en: The superclass of all objects, the Object class
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 所有对象的超类，`Object`类
- en: 'In Java, all classes extend a special class called `Object` is always available.
    Why does the `Object` class exist? The `Object` class defines methods to support
    threading and object management in any class. This means that every class has
    these methods and may choose to override any of them or use them as is. There
    are three of these methods that are frequently overridden in a class. The first
    of these is as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，所有类都扩展了一个名为`Object`的特殊类，这个类始终可用。`Object`类存在的原因是什么？`Object`类定义了支持任何类中的线程和对象管理的方法。这意味着每个类都有这些方法，可以选择重写它们或按原样使用它们。有三种这些方法在类中经常被重写。以下是最先重写的一个：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The default implementation inherited from `Object` compares the address of
    the object that invokes `equals` to the object passed as a parameter. This means
    it can only be `true` if two references contain the same address in memory to
    an object. In most cases, you will likely want to compare the values in an object’s
    fields, and therefore you will frequently want to override it. For example, see
    the following:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 从`Object`继承的默认实现比较调用`equals`的对象的地址与作为参数传递的对象的地址。这意味着只有当两个引用在内存中指向同一个对象的地址时，它才能为`true`。在大多数情况下，你可能想要比较一个对象字段中的值，因此你经常会想要重写它。例如，参见以下内容：
- en: '[PRE24]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `equals` method performs four tests that must all be passed for one object
    to be equal to another. These are the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`方法执行四个测试，一个对象要等于另一个对象，必须通过所有这些测试。以下就是这些测试：'
- en: The `this` reference and `obj` contain the same memory address
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`引用和`obj`包含相同的内存地址'
- en: The comparative `obj` is not `null`
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较的`obj`不为`null`
- en: Both references are for the same class type
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个引用都是同一类类型
- en: Finally, it compares the value of the fields
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它比较字段值
- en: 'The next commonly overridden method is this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个常见的重写方法是：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When comparing multiple fields in two objects, the necessary code can be quite
    time-consuming. If you need to compare two strings, it will be necessary to compare
    them one character at a time. You will need to compare each one for a class with
    many fields. There is an optimization, and that is **hashCode**.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当比较两个对象中的多个字段时，必要的代码可能相当耗时。如果你需要比较两个字符串，你需要逐个字符地比较它们。对于具有许多字段的类，你需要对每个字段进行比较。有一种优化，那就是**hashCode**。
- en: A hash is an integer computed from the fields in an object. Computing hash values
    is, in most cases, faster than comparing fields one at a time. The default value
    from this method, if it is not overridden, is the address in memory at which the
    object resides. What you will want to do is calculate a hash value based on the
    object’s fields.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希是从对象字段计算出的整数。在大多数情况下，计算哈希值比逐个比较字段要快。如果没有重写，此方法的默认值是对象在内存中的地址。你想要做的是根据对象的字段计算哈希值。
- en: 'Here is an example of a method that overrides the `Object` class’s `hashCode`
    method with its own:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个重写 `Object` 类的 `hashCode` 方法的示例：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The value generated is not a unique value. It is possible that two objects with
    different values would generate the same hash code. What we do know for certain
    is that if the hash codes of two objects are not the same, then the objects, based
    on the fields, are not equal. If the hash code is the same for two objects, then
    to be certain that they are equal, you must now use the `equals` method. This
    will, in almost all cases, speed up the process of comparing objects because the
    slower `equals` method is only called when the hash codes are the same.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的值不是唯一的。可能存在两个具有不同值的对象会生成相同的哈希码。我们可以确定的是，如果两个对象的哈希码不相同，那么根据字段，这两个对象也不相等。如果两个对象的哈希码相同，那么为了确保它们相等，现在必须使用
    `equals` 方法。这几乎在所有情况下都会加快比较对象的过程，因为较慢的 `equals` 方法只有在哈希码相同的情况下才会被调用。
- en: One other application of `hashCode` is in data structures—structures that store
    data as a pair of values called the key and value, where the value is an object.
    The value that `hashCode` returns is an integer value that is used as the key.
    As the integer is processed faster than any of the other primitives, these data
    structures perform more efficiently as compared to structures that can use any
    type as the key.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`hashCode` 的另一个应用是在数据结构中——这些结构将数据存储为键值对的值，其中值是一个对象。`hashCode` 返回的值是一个整数，用作键。由于整数处理速度比任何其他原始数据类型都快，因此与可以使用任何类型作为键的结构相比，这些数据结构执行效率更高。'
- en: 'The last of the three commonly overridden methods is this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 三个常用重写方法中的最后一个是这个：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation of this method in the `Object` class returns the object’s
    address as returned by the `hashCode` method and the name of the class. Overriding
    it to return the values of the fields as a String can be far more useful. By overloading
    it, you can inspect the state of an object, as shown here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`Object` 类中此方法的实现返回 `hashCode` 方法返回的对象地址和类名。将其重写为返回字段的值作为字符串可能更有用。通过重载它，你可以检查对象的状态，如下所示：'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Let us now look at an alternative to inheritance in Java, a **class interface**.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 Java 中继承的替代方案，一个 **类接口**。
- en: Understanding the class interface
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类接口
- en: In a programming language that has access control features, public methods are
    called the class **interface**. These are the methods that can be called from
    any other object in a system that has a reference to the object it wants to use.
    In Java, we can create a contract that will require any class that implements
    the contract, called an interface, to implement all the methods listed in the
    interface as public methods.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在具有访问控制功能的编程语言中，公共方法被称为类的 **接口**。这些是可以从系统中的任何其他对象调用的方法。在 Java 中，我们可以创建一个合同，该合同将要求实现该合同（称为接口）的任何类将接口中列出的所有方法作为公共方法实现。
- en: 'Here is an interface for reading and writing to a relational database:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个用于读取和写入关系型数据库的接口：
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this code block for an interface class, each method is declared as an abstract
    method, as it ends with a semicolon and does not have a code block. They are all
    public by default as well – hence, the lack of the `public` keyword.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口类的代码块中，每个方法都被声明为抽象方法，因为它以分号结尾且没有代码块。默认情况下，它们都是公共的——因此，没有使用 `public` 关键字。
- en: 'We use an interface when we declare the class. The implementing class must
    now have public methods as described in the interface. The following are the first
    few lines of a class that implements `GamingDAO`. I have not included the implementation
    of these methods:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们声明类时使用接口。实现类现在必须具有接口中描述的公共方法。以下是一个实现 `GamingDAO` 的类的第一行代码。我没有包括这些方法的实现：
- en: '[PRE30]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Each method has the `@Override` annotation. This is an informative annotation
    and is optional in this case. Your code will be more easily understood by other
    developers if you use this annotation. You are also informing the compiler to
    watch out for any changes in the superclass methods and if they are found, the
    compiler will complain. This is the original application of a Java interface.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都有`@Override`注解。这是一个信息性注解，在这种情况下是可选的。如果你使用这个注解，你的代码将更容易被其他开发者理解。你也在通知编译器注意任何在超类方法中的更改，如果发现更改，编译器将报错。这是Java接口的原始应用。
- en: 'Java 8 and then Java 9 modified what can be contained in an interface. The
    changes to the original definition of an interface class are as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8和Java 9修改了接口中可以包含的内容。接口类原始定义的更改如下：
- en: Having the `default` interface method. This is a `public` method implemented
    in the interface rather than in the implementing class.
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口中实现`default`接口方法。这是一个在接口中而不是在实现类中实现的`public`方法。
- en: Having `private` methods implemented in the interface class. These `private`
    methods can only be called by a `default` method, or they can be called by other
    `private` methods declared in the interface. Therefore, as in the following code
    block, I can call `write4()` from `write2()`.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口类中实现`private`方法。这些`private`方法只能被`default`方法调用，或者可以被接口中声明的其他`private`方法调用。因此，正如以下代码块所示，我可以从`write2()`调用`write4()`。
- en: Having `static` methods implemented in the interface class. As with all `static`
    methods, it does not have a `this` reference, so it cannot call upon other methods
    in the interface or class. It must be a public method, so the `public` keyword
    is not required.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在接口类中实现`static`方法。与所有`static`方法一样，它没有`this`引用，因此不能调用接口或类中的其他方法。它必须是一个公共方法，因此不需要`public`关键字。
- en: 'Here is an example of these three types of methods that can exist in an interface
    class:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例，展示了接口类中可能存在的这三种方法：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we implement this interface, then the only method that we are under contract
    to implement is `write1()`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们实现这个接口，那么我们唯一有合同义务实现的方法是`write1()`：
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that in the `main` method, the object we are creating, `WritingTool`,
    has its reference assigned to an object of the `Pencil` type. You cannot write
    `new Pencil()`, but you use `Pencil` as the reference type when you create `WritingTool`.
    This will restrict your use of the code in the `WritingTool` class to just the
    overridden methods. The last call in the `main` method, `tool.write5()`, will
    generate a compiler error because the `write5` method is not part of the `Pencil`
    interface.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在`main`方法中，我们创建的对象`WritingTool`将其引用分配给了`Pencil`类型的对象。你不能直接使用`new Pencil()`，但在创建`WritingTool`时，你使用`Pencil`作为引用类型。这将限制你在`WritingTool`类中使用代码的范围，仅限于重写的方法。`main`方法中的最后一个调用`tool.write5()`将生成编译错误，因为`write5`方法不是`Pencil`接口的一部分。
- en: The implementing class, in this case, `WritingTool`, can have additional methods
    of any access control designation not listed in the interface.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 实现类，在这个例子中是`WritingTool`，可以拥有接口中未列出的任何访问控制指定的额外方法。
- en: It is considered a best practice to define the public methods of a class in
    an interface class. It is not necessary to list every public method and a class
    may have multiple interfaces so that what you can do with a class can be restricted
    to a specific set of tasks.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 将类的公共方法定义在接口类中是一种最佳实践。没有必要列出每个公共方法，一个类可以有多个接口，这样你可以对类执行的操作限制在特定的任务集中。
- en: Abstract class versus interface
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象类与接口的区别
- en: In an abstract superclass, you must implement every abstract method in the subclass.
    This might lead you to believe that an abstract class with every method abstract
    is the same as an interface. However, as mentioned here, there are significant
    differences between the two.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个抽象超类中，你必须实现子类中的每个抽象方法。这可能会让你认为每个方法都是抽象的抽象类与接口相同。然而，正如这里提到的，两者之间存在显著差异。
- en: 'An abstract class may have the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可能有以下特性：
- en: Abstract method declarations
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象方法声明
- en: Class and instance variables (fields)
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和实例变量（字段）
- en: A constructor
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: An additional non-abstract method of any access control
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何访问控制的额外非抽象方法
- en: 'Whereas, an interface may have these:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 而接口可能具有以下特性：
- en: Abstract method declarations
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象方法声明
- en: Default, private, or static methods
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认、私有或静态方法
- en: 'There is one other significant difference – as Java only supports a single
    inheritance model, you can only extend a single superclass. On the other hand,
    you can implement multiple interfaces for a single class, as shown here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个其他显著的区别——由于Java只支持单继承模型，你只能扩展一个超类。另一方面，你可以为单个类实现多个接口，如下所示：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can also have a subclass with a single superclass and one or more interfaces,
    as shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以有一个只有一个超类和一个或多个接口的子类，如下所示：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: However, one issue to keep an eye out for when using multiple interfaces is
    that it is a compile-time error, should there be the same abstract method in more
    than one interface. You may have an abstract method in a superclass identical
    to an abstract method in an interface.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用多个接口时要注意的一个问题是，如果有多个接口中有相同的抽象方法，则这是一个编译时错误。你可以在超类中有一个与接口中相同的抽象方法。
- en: Both interfaces and abstract classes can define what a class must implement.
    The fact that a class can only inherit from a single class makes an interface
    class more useful, as a class may have more than one interface.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接口和抽象类都可以定义一个类必须实现的内容。一个类只能从单个类继承的事实使得接口类更有用，因为一个类可以有多个接口。
- en: Sealed classes and interfaces
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封类和接口
- en: 'By default, any class can be the superclass for any other class, just as any
    interface can be used with any class. However, you can restrict this behavior
    by using a **sealed class** or **sealed interface**. This means you can list the
    names of classes that may extend or implement it, as shown in the following snippet:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，任何类都可以是任何其他类的超类，就像任何接口都可以与任何类一起使用一样。然而，你可以通过使用**密封类**或**密封接口**来限制这种行为。这意味着你可以列出可能扩展或实现它的类名，如下面的代码片段所示：
- en: '[PRE35]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we have declared a class that can only be used as a superclass to a class
    whose name is `SubClass`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们声明了一个只能用作名为`SubClass`的类的超类的类。
- en: 'Now that we have permitted `SubClass` to extend the `Sealed` class, we can
    write this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经允许`SubClass`扩展`Sealed`类，我们可以写出如下代码：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note that this subclass must be defined as `final`. This way, it is not possible
    to have `SubClass` as a superclass for some other class. Here is a similar syntax
    for a sealed interface:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个子类必须定义为`final`。这样，就不可能让`SubClass`成为其他类的超类。以下是一个密封接口的类似语法：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We have one more structure to examine, and that is `record`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个结构要检查，那就是`record`。
- en: Understanding the record class
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解记录类
- en: A `record` object is instantiated.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化了一个`record`对象。
- en: 'At its simplest, a record only needs the fields listed when the `record` class
    is declared, as shown here:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，记录只需要在声明`record`类时列出的字段，如下所示：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When we instantiate this record, we must provide the values for name and salary:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实例化这个记录时，我们必须提供名称和薪水的值：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: All records have a default canonical constructor that expects a value for every
    field in the record. In a regular class, you would need to write a canonical constructor
    method to assign the values to the fields. You may add a compact constructor to
    a record that permits you to examine the value each field was assigned.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 所有记录都有一个默认的规范构造函数，它期望记录中每个字段的值。在一个常规类中，你需要编写一个规范构造函数方法来分配字段的值。你可以在记录中添加一个紧凑构造函数，允许你检查每个字段分配的值。
- en: 'Here is a compact constructor. Notice that it does not have a parameter list,
    as it can only have a parameter for every field declared in the first line of
    the class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个紧凑构造函数。注意，它没有参数列表，因为它只能有参数，这些参数是类第一行中声明的每个字段：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'To access the value of a field, you can use the identifier as a method as shown
    here:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问字段的值，你可以使用标识符作为方法，如下所示：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You cannot change the value of a field in a record – you can only read its value.
    As a class, a record also extends `Object`. Furthermore, `record` provides default
    overrides for the `equals`, `hashCode`, and `toString` methods based on the fields.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能改变记录中字段的值——你只能读取它的值。作为一个类，记录也扩展了`Object`。此外，`record`根据字段提供了默认的`equals`、`hashCode`和`toString`方法的覆盖。
- en: A record can implement an interface and so can be in the list of a sealed interface.
    As a record is implicitly final, it cannot extend any other classes, so it cannot
    be sealed for a class or classes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 记录可以实现接口，因此它可以出现在密封接口的列表中。由于记录是隐式最终的，它不能扩展任何其他类，因此它不能被密封为类或类。
- en: Now, let us examine the concept of polymorphism and see how it allows us to
    reuse code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来探讨多态的概念，看看它是如何允许我们重用代码的。
- en: Understanding polymorphism
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解多态
- en: '**Polymorphism** is one of the defining features of object-oriented languages.
    Java has expanded the concept by including interfaces. Let us begin with a simple
    hierarchy of classes as shown here:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**多态**是面向对象语言的一个定义特征。Java通过包括接口来扩展了这个概念。让我们从一个简单的类层次结构开始，如下所示：'
- en: '[PRE42]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In this trivial class, we have a public method to assign a value to `count`
    and a second method that displays the value in `count` along with the name of
    the class. In the following code block, we have a class that uses `SuperClass`:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的类中，我们有一个公共方法来分配`count`的值，以及第二个方法，它显示`count`的值以及类的名称。在下面的代码块中，我们有一个使用`SuperClass`的类：
- en: '[PRE43]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'When we run this, the result is as we expected:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这个程序时，结果正如我们所预期：
- en: '[PRE44]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, let us create a subclass from `SuperClass`:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从`SuperClass`创建一个子类：
- en: '[PRE45]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This subclass only overrides the `displayCount` method. Classes are about creating
    new data types. When we create a class that is a subclass, we refer to the class
    type by the superclass name. In other words, we can state that `SubClass` is of
    the `SuperClass` type. If we added a `subclass` variable to `SubClass`, then that
    class is also of the `SuperClass` type. Now let us change the `Polymorphism` class
    to use a `SubClass` object:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个子类只重写了`displayCount`方法。类是关于创建新的数据类型。当我们创建一个子类时，我们通过父类名称来引用类类型。换句话说，我们可以声明`SubClass`是`SuperClass`类型。如果我们向`SubClass`添加一个`subclass`变量，那么这个类也是`SuperClass`类型。现在让我们将`Polymorphism`类更改为使用`SubClass`对象：
- en: '[PRE46]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: While the `show` method is unchanged and still expects an object of the `SuperClass`
    type, we are creating an object of `SubClass` in `perform`, and then we call upon
    `show`, passing a reference to the subclass. As `SubClass` is of the `SuperClass`
    type, polymorphism permits any subclass of `SuperClass` to be passed to the `show`
    method. When we call `sc.setCount`, the runtime determines that it must use the
    `superclass` count method because there is no public method with that name in
    the subclass. When it calls upon `sc.displayCount`, it must decide whether to
    use the method that belongs to `SuperClass` that it is expecting or the method
    that belongs to the `SubClass` type that is passed.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`show`方法没有改变，仍然期望一个`SuperClass`类型的对象，但在`perform`中我们创建了一个`SubClass`对象，然后调用`show`方法，传递子类的引用。由于`SubClass`是`SuperClass`类型，多态允许将`SuperClass`的任何子类传递给`show`方法。当我们调用`sc.setCount`时，运行时确定必须使用`superclass`的计数方法，因为在子类中没有以该名称公开的方法。当它调用`sc.displayCount`时，它必须决定是使用它期望的`SuperClass`类型的方法还是传递的`SubClass`类型的方法。
- en: 'Polymorphism means that methods overridden in a subclass are called in favor
    of the superclass version even when the declared type of what is being passed
    is the `SuperClass` type. The result when running the code this time is the following:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 多态意味着在子类中重写的方法会优先于父类版本被调用，即使传递给方法的声明类型是`SuperClass`类型。这次运行代码的结果如下：
- en: '[PRE47]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Classes that share the same interface are also subject to polymorphism. Here
    is a simple interface that only requires the method:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 具有相同接口的类也受到多态的影响。这里有一个简单的接口，它只需要一个方法：
- en: '[PRE48]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Any class that implements this interface must override the abstract `displayCount`
    method. Now, let us create a class that implements this interface:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此接口的任何类都必须重写抽象的`displayCount`方法。现在，让我们创建一个实现此接口的类：
- en: '[PRE49]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Now, let us use polymorphism with the interface:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用接口的多态：
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In this class, we are passing the `Implementation` object to a method expecting
    the interface. When this runs, it produces the following output:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们向一个期望接口的方法传递了`Implementation`对象。当运行时，它产生了以下输出：
- en: '[PRE51]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Any class that implements the interface named `Interface` can be passed to any
    method that declares a parameter using the interface rather than a class.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 实现名为`Interface`的任何类都可以传递给任何声明参数使用接口而不是类的任何方法。
- en: Polymorphism is a powerful tool that allows you to write code that evolves over
    time but does not require changes to existing code that uses objects that share
    an interface or inherit from the same superclass.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是一个强大的工具，它允许你编写随时间演变的代码，但不需要更改使用具有相同接口或继承自相同父类的对象的现有代码。
- en: Understanding composition in classes
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类中的组合
- en: When we create an application that employs numerous classes, we must decide
    how they will interact with each other. In object-oriented programming terminology,
    a method in one class that calls a method in another class is called messaging.
    Despite this, most developers describe this as calling a method, as I do. How
    objects send these messages or call methods in other objects is what **composition**
    is about.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个使用众多类的应用程序时，我们必须决定它们将如何相互交互。在面向对象编程术语中，一个类中的方法调用另一个类的方法被称为消息传递。尽管如此，大多数开发者描述这为调用方法，正如我所做的那样。对象如何发送这些消息或调用其他对象的方法是**组合**的内容。
- en: There are two ways for objects to be connected – **association** and **aggregation**.
    Let’s discuss these connections.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 对象之间有两种连接方式——**关联**和**聚合**。让我们来讨论这些连接。
- en: Association
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联
- en: 'In association, the object reference we need to call or message a method is
    created outside the calling object. Let’s begin with a class that we will want
    to call:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在关联中，我们需要调用或发送消息的方法的对象引用是在调用对象外部创建的。让我们从一个我们想要调用的类开始：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is a trivial method that has a method to display a String that is passed
    to it. Keep in mind that we are interested in the concepts here and not the task
    the class is responsible for. Now, let us create a class that will want to call
    or message `Receiver`:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的函数，它有一个用于显示传递给它的字符串的方法。请注意，我们在这里关注的是概念，而不是类负责的任务。现在，让我们创建一个想要调用或发送消息给
    `Receiver` 的类：
- en: '[PRE53]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this class, we declare a reference to the `Receiver` class. We do not plan
    for it to be changed when it is assigned an initial, so we designate it as `final`.
    We do not create an instance of this object using `new`. Rather, we expect this
    object to be created in another class and we will then pass that reference to
    the constructor. Put another way, this `Association` class does not own the reference
    to `Receiver`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们声明了一个对 `Receiver` 类的引用。我们不打算在它被分配初始值时改变它，因此我们将其指定为 `final`。我们不是使用 `new`
    创建这个对象的实例，而是期望这个对象在另一个类中创建，然后我们将那个引用传递给构造函数。换句话说，这个 `Association` 类不拥有 `Receiver`
    的引用。
- en: 'Here is an example of having an object declared in a class and then that object
    passed to another class:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子，展示了在一个类中声明一个对象，然后将该对象传递给另一个类：
- en: '[PRE54]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the `Composition` class’s `perform` method, we are instantiating an object
    of the `Receiver` type. Following this, we instantiate an object of the `Association`
    type, passing to its constructor a reference to the `Receiver` object we just
    created.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Composition` 类的 `perform` 方法中，我们正在实例化一个 `Receiver` 类型的对象。随后，我们实例化一个 `Association`
    类型的对象，将其构造函数传递了我们刚刚创建的 `Receiver` 对象的引用。
- en: 'When the time comes to put an object of the `Association` type out for garbage
    collection, the `Receiver` object is untouched if it is also used in another object.
    Put another way, if the `Receiver` object is in scope, meaning visible and valid,
    in another object, then the `Receiver` object is not garbage-collected. Let’s
    see rewriting `perform` as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要将 `Association` 类型的对象进行垃圾回收时，如果该对象也被另一个对象使用，则 `Receiver` 对象保持不变。换句话说，如果 `Receiver`
    对象在另一个对象的作用域内，即可见且有效，那么 `Receiver` 对象不会被垃圾回收。让我们看看如何重写 `perform` 方法：
- en: '[PRE55]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To explicitly put an object out of scope and available for garbage collection,
    you can assign a special value named `null`. This will set the address this reference
    contains to zero, and the object will be made available for garbage collection.
    If we try to call `sendMessage` after assigning `null`, then this will be flagged
    as an error by the compiler. If we remove the error line, the final line where
    we call `displayName` in the `Receiver` object will work, as the `Association`
    class did not own the `Receiver` object. Ownership is defined as belonging to
    the object that created it. `Association` did not create `Receiver`. If the `Association`
    object’s `receive` reference is not in scope anywhere else in the program, it
    will go out for garbage collection.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 要显式地将对象移出作用域并使其可用于垃圾回收，你可以分配一个名为 `null` 的特殊值。这将设置该引用包含的地址为零，对象将可用于垃圾回收。如果我们尝试在分配
    `null` 后调用 `sendMessage`，那么编译器将标记这为错误。如果我们删除错误行，最后一条在 `Receiver` 对象中调用 `displayName`
    的行将工作，因为 `Association` 类没有拥有 `Receiver` 对象。所有权是指属于创建它的对象。`Association` 没有创建 `Receiver`。如果
    `Association` 对象的 `receive` 引用在程序的其他地方没有作用域，它将进行垃圾回收。
- en: Aggregation
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: Objects that are created in a class belong to or are owned by that class. When
    we create an object of the owning class, all the other objects in the class will
    be instantiated in the class. When this class goes out of scope, then everything
    it owns also goes out of scope.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个类中创建的对象属于或被该类拥有。当我们创建一个拥有类的对象时，该类中的所有其他对象都会在该类中实例化。当这个类超出作用域时，它所拥有的所有东西也会超出作用域。
- en: 'Here is our program employing aggregation:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们的使用聚合的程序：
- en: '[PRE56]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this `Aggregation` class, an object of the `Receiver` type is created in
    the constructor. It is not coming from another object as it did with `Association`.
    This means that `Aggregatio`n owns the `Receiver` object and when the `Aggregation`
    object goes out of scope, so does the `Receiver` object that it instantiated.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`聚合`类中，构造函数中创建了一个`Receiver`类型的对象。它不是来自另一个对象，就像在`关联`中那样。这意味着`聚合`拥有`Receiver`对象，当`聚合`对象超出作用域时，它所实例化的`Receiver`对象也会超出作用域。
- en: Summary
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have finished examining the building blocks or concepts
    of organizing code in Java that we began in [*Chapter 5*](B19088_05.xhtml#_idTextAnchor106),
    *Language Fundamentals – Classes*. We looked at methods and a range of issues
    that need to be considered when writing a method. From there, we examined inheritance,
    a way in which we can reuse or share code.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们完成了对Java中组织代码的构建块或概念的考察，这些概念我们在[*第五章*](B19088_05.xhtml#_idTextAnchor106)“语言基础
    – 类”中开始探讨。我们探讨了编写方法时需要考虑的方法和一系列问题。从那里，我们考察了继承，这是我们重用或共享代码的一种方式。
- en: The interface introduced the concept of a contract or list of methods that must
    be written by any class that implements the interface. The specialized class type
    called `record` for simplifying the creation of immutable objects was next up.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接口引入了合同或必须由实现接口的任何类编写的列表方法的概念。接下来是用于简化不可变对象创建的专用类类型`record`。
- en: Inheritance and interfaces support the concept of polymorphism. This permits
    the creation of methods that expect an instance of a superclass or interface class
    but receive an instance of any class that either inherits or extends the superclass
    or implements the interface.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 继承和接口支持多态的概念。这允许创建期望超类或接口类实例的方法，但接收任何继承或扩展超类或实现接口的类的实例。
- en: We ended the chapter by looking at how we connect objects to objects. Composition
    implies that the object is created outside of the object that has a reference.
    The reference must be passed to the object either through the constructor or another
    method. Aggregation implies that the object we need to use is created inside the
    object that wishes to use it.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过探讨如何将对象连接到对象来结束本章。组合意味着对象是在具有引用的对象之外创建的。引用必须通过构造函数或另一个方法传递给对象。聚合意味着我们需要使用的对象是在希望使用它的对象内部创建的。
- en: Next up, we will finally review the syntax of the Java language.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将最终回顾Java语言的语法。
