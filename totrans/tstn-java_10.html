<html><head></head><body>
		<div id="_idContainer056">
			<h1 id="_idParaDest-195" class="chapter-number"><a id="_idTextAnchor214"/>10</h1>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor215"/>Implementing Software Design Principles and Patterns in Java</h1>
			<p>Software design principles<a id="_idIndexMarker710"/> provide guidance on how you construct your classes and how your objects should interact. They are not tied to a specific problem. For example, the <strong class="bold">single responsibility</strong> principle<a id="_idIndexMarker711"/> encourages us to write methods that perform a single task. Software design patterns are reusable concepts for solving common problems in software design. For example, should we need to have a single instance of an object in an application, you will want to use<a id="_idIndexMarker712"/> the <strong class="bold">Singleton</strong> pattern. This pattern has nothing to do with the language you are using, nor does it describe the required code for the pattern. What these principles and patterns do is describe a solution to common problems that you can then implement in the language you are using. Principles and patterns can be applied to any language, and I will assume that you have likely applied them in whatever language you are <span class="No-Break">coming from.</span></p>
			<p>The goal of this chapter is to look at a handful of the most commonly used principles and patterns and how they are coded in Java. They are <span class="No-Break">as follow<a id="_idTextAnchor216"/>s:</span></p>
			<ul>
				<li>SOLID software <span class="No-Break">design principles</span></li>
				<li>Software <span class="No-Break">design patterns</span></li>
			</ul>
			<p>As a software developer, you are expected to write code that is reusable, understandable, flexible, <span class="No-Break">and maintainable.</span></p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor217"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Java <span class="No-Break">17 installed</span></li>
				<li><span class="No-Break">Text editor</span></li>
				<li>Maven 3.8.6 or a newer <span class="No-Break">version installed</span></li>
			</ul>
			<p>The sample code for this chapter is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter10</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor218"/>SOLID software design principles</h1>
			<p>Software <a id="_idIndexMarker713"/>design principles, as applied to object-oriented programming, provide guidelines for how you construct your classes. Unlike patterns that are tied to specific coding requirements, principles should be considered for any code that you write every day. There are numerous principles, but we will look at five principles that fall under the <span class="No-Break">acronym </span><span class="No-Break"><strong class="bold">SOLID</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor219"/>S  – Separation of concerns/single responsibility</h2>
			<p>In my opinion, <strong class="bold">separation of concerns</strong> may <a id="_idIndexMarker714"/>be the most important of the principles. Simply put, it<a id="_idIndexMarker715"/> directs us to design classes that are responsible for a specific function in the program. We have seen this already in <a href="B19088_05.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Language Fundamentals – Classes</em>, in the <em class="italic">Class organization based on functionality</em> section, where we took the <strong class="source-inline">CompoundInterest05</strong> program and organized the classes based <span class="No-Break">on functionality:</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/B19088_10_01.jpg" alt="Figure 10.1 – Class organization for the separation of concerns principle"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 10.1 – Class organization for the separation of concerns principle</p>
			<p>What we see in this figure are four packages that describe the required functionality of any classes in the package. The individual classes in each package contain any methods and data structures required to carry out their task. The business class is independent of the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>) class. We can <a id="_idIndexMarker716"/>change the UI class to employ a GUI rather than a text or console interface. We can do this without the need to make any changes to the business class. We will do just this in <a href="B19088_13.xhtml#_idTextAnchor254"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Desktop Graphical User Interface Coding with Swing and JavaFX</em>, when we change the UI from text to GUI. We will even turn this application into a web app in <a href="B19088_15.xhtml#_idTextAnchor301"><span class="No-Break"><em class="italic">Chapter 15</em></span></a>, <em class="italic">Jakarta Faces Application</em>, leaving the business and data <span class="No-Break">classes untouched.</span></p>
			<p>The single <a id="_idIndexMarker717"/>responsibility principle<a id="_idIndexMarker718"/> is not technically part of SOLID but its close association with the separation of concerns merits including it here. This principle is applied to methods. A single method should be written to be responsible for a single concern. You would not write a single method that performs a calculation and then displays the result. These are two concerns, and each belongs to its <span class="No-Break">own method.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor220"/>O – Open/closed</h2>
			<p>This principle states that you <a id="_idIndexMarker719"/>should be able to add to or extend a <a id="_idIndexMarker720"/>class’s functionality, the open part, without changing or modifying any code in the class, the closed part. This can be accomplished using either inheritance or interface. Consider our <strong class="source-inline">CompoundInterestCalculator05.java</strong> example. It contains a single calculation for compound interest. What if I’d like to add another calculation? Should I just edit this file and add a new method for the new calculation? The answer <span class="No-Break">is no.</span></p>
			<p>If I use inheritance, I will create a new class that extends the original single calculation and adds the new calculation. Here is a class that implements a method to calculate <span class="No-Break">loan payments:</span></p>
			<pre class="source-code">
public class Calculation {
    pu<a id="_idTextAnchor221"/>blic void loanCalculator(FinancialData data) {
        var monthlyPayment = data.getPrincipalAmount() *
           (data.getMonthlyInterestRate() / (1 - Math.pow(
           (1 + data.getMonthlyInterestRate()), -
           data.getMonthlyPeriods())));
        data.setMonthlyPayment(monthlyPayment);
    }
}</pre>
			<p>You have thoroughly tested this calculation and you are confident that it is correct. Now, you are asked to add two more calculations, one for the savings goal and the other for the future value of regular savings. The open/closed principle tells us that we should not modify this class. Although it's a simple example, there is still the possibility that you may inadvertently change<a id="_idIndexMarker721"/> something in this class when you add <a id="_idIndexMarker722"/>methods to it. The solution <span class="No-Break">is inheritance:</span></p>
			<pre class="source-code">
public class Calculation2 extends Calculation {
    public void futureValueCalculator(FinancialData data) {
        var futureValue = data.getMonthlyPayment() *
            ((1 - Math.pow(
            (1 + data.getMonthlyInterestRate()),
            data.getMonthlyPeriods())) /
            data.getMonthlyInterestRate());
        data.setPrincipalAmount(futureValue);
    }
    public void savingsGoalCalculator(FinancialData data) {
        double monthlyPayment = data.getPrincipalAmount() *
            (data.getMonthlyInterestRate() /
            (1 - Math.pow(
            (1 + data.getMonthlyInterestRate()),
            data.getMonthlyPeriods())));
        data.setMonthlyPayment(monthlyPayment);
    }
}</pre>
			<p>This <strong class="source-inline">Calculator2</strong> class inherits the public <strong class="source-inline">loanCalculator</strong> method from the <strong class="source-inline">Calculator</strong> superclass and then adds the two <span class="No-Break">new calculations.</span></p>
			<p>The second approach, called the<a id="_idIndexMarker723"/> polymorphic open/closed principle, is<a id="_idIndexMarker724"/> to use an interface class. This is the closed class. All calculations must implement <span class="No-Break">this interface:</span></p>
			<pre class="source-code">
public interface FinanceCalculate {
    void determine(FinancialData data);
}</pre>
			<p>Now, let us look at one of the three classes that will implement <span class="No-Break">this interface:</span></p>
			<pre class="source-code">
 public class FutureValue implements FinanceCalculate {
    @Override
    public void determine(FinancialData data) {
        var futureValue = data.getMonthlyPayment() *
           ((1 - Math.pow(
           (1 + data.getMonthlyInterestRate()),
           data.getMonthlyPeriods())) /
           data.getMonthlyInterestRate());
        data.setPrincipalAmount(futureValue);
    }
}</pre>
			<p>Now, we can write a class that can call upon any of these operations. If we wish to add new financial calculations, we can without modifying this class, as it expects to receive a reference to an object that implements the <span class="No-Break"><strong class="source-inline">FinanceCalculate</strong></span><span class="No-Break"> interface:</span></p>
			<pre class="source-code">
public class BankingServices {
    public void doCalculation(FinanceCalculate process,
                              FinancialData data) {
        process.determine(data);
    }
}</pre>
			<p>As new features are <a id="_idIndexMarker725"/>added to an application, you want to<a id="_idIndexMarker726"/> accomplish this without modifying existing code. There is one exception, and that is to correct bugs. This will likely require modifications to <span class="No-Break">the code.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor222"/>L – Liskov substitution</h2>
			<p>This <a id="_idIndexMarker727"/>principle describes how <a id="_idIndexMarker728"/>to use inheritance effectively. Put simply, when you create a new class that extends an existing class, you can override methods in the superclass. What you must not do is reuse a superclass method name and change its return type or the number or type <span class="No-Break">of parameters.</span></p>
			<p>Here is a very simple superclass that displays <span class="No-Break">a message:</span></p>
			<pre class="source-code">
public class SuperClass {
    public void display(String name) {
        System.out.printf("Welcome %s%n", name);
    }
}</pre>
			<p>Now, let us create a subclass that displays a slightly <span class="No-Break">different message:</span></p>
			<pre class="source-code">
public class SubClass extends SuperClass {
    @Override
    public void display(String name) {
        System.out.printf("Welcome to Java %s%n", name);
    }
}</pre>
			<p>When we override the <strong class="source-inline">display</strong> method, we are not changing its return value or its parameters. This means that, in the following code, we can use either the superclass or the subclass, and the version matching the reference type passed to <strong class="source-inline">doDisplay</strong> <span class="No-Break">will run:</span></p>
			<pre class="source-code">
public class Liskov {
    public void doDisplay(SuperClass sc) {
        sc.display("Ken");
    }
    public static void main(String[] args) {
        new Liskov().doDisplay(new SuperClass());
    }
}</pre>
			<p>The program’s output will be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">Welcome Ken</strong></pre>
			<p>Now, let us pass a reference <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">SubClass</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        new Liskov().doDisplay(new SubClass());</pre>
			<p>The output will now be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">Welcome to Java Ken</strong></pre>
			<p>Changing <a id="_idIndexMarker729"/>the return type of <strong class="source-inline">display</strong> in the <a id="_idIndexMarker730"/>subclass is a compiler error. Leaving the return type as <strong class="source-inline">void</strong> but adding or removing parameters breaks the override. The superclass <strong class="source-inline">display</strong> method is the only one that can be called if the <strong class="source-inline">display</strong> method’s reference is to <strong class="source-inline">SubClass</strong>. Here is the <span class="No-Break">new </span><span class="No-Break"><strong class="source-inline">SubClass</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class SubClass extends SuperClass {
    public void display(String name, int age) {
        System.out.printf("Welcome to Java %s at age %d%n",
                           name, age);
    }
}</pre>
			<p>We cannot use the <strong class="source-inline">@Override</strong> annotation as this is considered overloading, keeping the same method name but changing parameters. Now, if we pass <strong class="source-inline">SubClass</strong> to <strong class="source-inline">doDisplay</strong>, the<a id="_idIndexMarker731"/> method chosen will always be<a id="_idIndexMarker732"/> the <strong class="source-inline">SuperClass</strong> version, thus breaking the <span class="No-Break">Liskov principle.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor223"/>I – Interface segregation</h2>
			<p>This principle provides <a id="_idIndexMarker733"/>guidance on developing interfaces. Simply<a id="_idIndexMarker734"/> put, do not add new methods to an interface that not every implementation of an interface will require. Let us look at a simple interface for a delivery service. Keep in mind that, for brevity, this and many other examples are not complete but show what is relevant to the concept <span class="No-Break">being explained:</span></p>
			<pre class="source-code">
public interface Delivery {
    void doPackageSize(int length, int height, int width);
    void doDeliveryCharge();
}</pre>
			<p>Now, let us implement <span class="No-Break">this interface:</span></p>
			<pre class="source-code">
public class Courier implements Delivery {
    private double packageSize;
    private double charge;
    @Override
    public void doPackageSize(int length, int height,
                                            int width) {
       packageSize = length * width * width;
    }
    @Override
    public void doDeliveryCharge() {
        if (packageSize &lt; 5) {
            charge = 2.0;
        } else if (packageSize &lt; 10 ) {
            charge = 4.0;
        } else {
            charge = 10.0;        }
    }
}</pre>
			<p>Now, imagine that we need to expand <strong class="source-inline">Courier</strong> to handle packages that will travel by air freight. We now must add methods just used for this type of transport. Do we add this to the existing interface? No, we do not. Interface segregation tells us to keep interfaces to the minimum number of methods required for a specific use. The new interface could look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public interface AirDelivery extends Delivery {
    boolean isHazardous();
}</pre>
			<p>We are using <a id="_idIndexMarker735"/>interface inheritance here. With <a id="_idIndexMarker736"/>this interface, you will need to implement the methods from <strong class="source-inline">Delivery</strong> as well as the new method in <strong class="source-inline">AirDelivery</strong>. Now, if we implement a class with the <strong class="source-inline">Delivery</strong> interface, we only need to implement two methods. When we use <strong class="source-inline">AirDelivery</strong>, we need to implement <span class="No-Break">three methods.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor224"/>D – Dependency inversion</h2>
			<p>This last principle in SOLID states<a id="_idIndexMarker737"/> that classes should not <a id="_idIndexMarker738"/>depend on a concrete class. Rather, classes should depend on abstraction. An abstraction can be an abstract class or, more commonly in Java, an interface. Imagine a program that deals with the inventory for a store. We would create a class for each item. We could have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class Bread {
    private String description;
    private int stockAmount;
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public int getStockAmount() {
        return stockAmount;
    }
    public void setStockAmount(int stockAmount) {
        this.stockAmount = stockAmount;
    }
}</pre>
			<p>For another<a id="_idIndexMarker739"/> item, such as <strong class="source-inline">Milk</strong>, we could <a id="_idIndexMarker740"/>have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
public class Milk {
    private String description;
    private int stockAmount;
    public String getDescription() {
        return description;
    }
    public void setDescription(String description) {
        this.description = description;
    }
    public int getStockAmount() {
        return stockAmount;
    }
    public void setStockAmount(int stockAmount) {
        this.stockAmount = stockAmount;
    }
}</pre>
			<p>A program<a id="_idIndexMarker741"/> that uses either <strong class="source-inline">Bread</strong> or <strong class="source-inline">Milk</strong> is considered a high-level module, while <strong class="source-inline">Bread</strong> and <strong class="source-inline">Milk</strong> are considered <a id="_idIndexMarker742"/>concrete low-level modules. It also implies that the high-level module must depend on the concrete class. Imagine that we need a program to produce a report on items in inventory. Without following dependency inversion, we will need one report class for every item in <span class="No-Break">the inventory:</span></p>
			<pre class="source-code">
public class MilkReport {
    private final Milk milkData;
    public MilkReport(Milk data) {
        milkData = data;
    }
    public void displayReport() {
        System.out.printf("Description: %s  Stock: %d%n",
            milkData.getDescription(),
            milkData.getStockAmount());
    }
}</pre>
			<p>We will now need a second class for <strong class="source-inline">BreadReport</strong>. A store with 100 items for sale will need 100 classes, one for each item. The problem that dependency inversion resolves is the need for 100 report classes. We begin the solution using <span class="No-Break">an interface:</span></p>
			<pre class="source-code">
public interface Inventory {
    public String getDescription();
    public void setDescription(String description);
    public int getStockAmount();
    public void setStockAmount(int stockAmount);
}</pre>
			<p>Now, every<a id="_idIndexMarker743"/> item class will<a id="_idIndexMarker744"/> <span class="No-Break">implement </span><span class="No-Break"><strong class="source-inline">Inventory</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class MilkDI implements Inventory{ . . . }
public class BreadDI implements Inventory{ . . . }</pre>
			<p>There can now be just one <span class="No-Break">report class:</span></p>
			<pre class="source-code">
public class InventoryReport {
    private final Inventory inventoryData;
    public InventoryReport(Inventory data) {
        inventoryData = data;
    }
    public void displayReport() {
        System.out.printf("Description: %s  Stock: %d%n",
            inventoryData.getDescription(),
            inventoryData.getStockAmount() );
    }
}</pre>
			<p>In using dependency inversion, your program can eliminate redundancy while still permitting your program to process any new items in <span class="No-Break">the inventory.</span></p>
			<p>Software design principles<a id="_idIndexMarker745"/> will contribute to writing <a id="_idIndexMarker746"/>efficient and maintainable code. These principles, along with other principles, should be considered every time you write a line of code. You can read more about these principles and others from links in the <em class="italic">Further </em><span class="No-Break"><em class="italic">reading</em></span><span class="No-Break"> section.</span></p>
			<p>Principles should govern every line of code that you write. The upcoming patterns guide you in solving <span class="No-Break">specific problems.</span></p>
			<h1 id="_idParaDest-204"><a id="_idTextAnchor225"/>Software design patterns</h1>
			<p>Software design patterns <a id="_idIndexMarker747"/>describe solutions to specific issues in software. This concept comes from architecture and engineering. Imagine that you need to design a bridge to cross a river. You will likely begin by choosing the bridge type or pattern. There are seven types <span class="No-Break">of bridges:</span></p>
			<ul>
				<li><span class="No-Break">Arch bridge</span></li>
				<li><span class="No-Break">Beam bridge</span></li>
				<li><span class="No-Break">Cantilever bridge</span></li>
				<li><span class="No-Break">Suspension bridge</span></li>
				<li><span class="No-Break">Cable-stayed bridge</span></li>
				<li><span class="No-Break">Tied-arch bridge</span></li>
				<li><span class="No-Break">Truss bridge</span></li>
			</ul>
			<p>These types, or patterns, describe how the bridge should span the river you wish to build your bridge over, but they do not provide detailed instructions or blueprints. They guide the architect in the design of the bridge. Software patterns work in a similar fashion. Let us look at four widely used patterns and how they could be implemented <span class="No-Break">in Java.</span></p>
			<h2 id="_idParaDest-205"><a id="_idTextAnchor226"/>Singleton</h2>
			<p>A<a id="_idIndexMarker748"/> singleton <a id="_idIndexMarker749"/>is a Java object that can only be instantiated once. It is<a id="_idIndexMarker750"/> a <strong class="bold">creational</strong> pattern. Wherever this object is used in an application, it is always the same object. In an application that requires exclusive access to resources by means of passing a token object, a singleton is one pattern you could follow. In <a href="B19088_11.xhtml#_idTextAnchor232"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Documentation and Logging</em>, we will look at logging, and most logging frameworks use a singleton logger object. Otherwise, there would be a separate logger in every class that uses it. Objects that manage thread pools are also frequently written <span class="No-Break">as singletons.</span></p>
			<p>Implementing a singleton in Java can be quite easy. In the examples that follow, the singletons are doing nothing other than ensuring that there will be only one instance of them. I leave it to you to add the actual work that these singletons <span class="No-Break">should perform.</span></p>
			<pre class="source-code">
public class SingletonSafe {</pre>
			<p>We use a static variable to represent this object when the <strong class="source-inline">getInstance</strong> method is called. As this method is static, it can only access static fields in the class. Static fields are also shared by all instances of <span class="No-Break">an object.</span></p>
			<pre class="source-code">
    private static Singleton instance;</pre>
			<p>Up until now, all constructors were <strong class="source-inline">public</strong>. Designating the constructor as <strong class="source-inline">private</strong> means that you cannot instantiate this object <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
    private Singleton() {}</pre>
			<p>In this method, we test to see whether an instance already exists. If it does, then we return the instance. If it does not, then we instantiate the object with <strong class="source-inline">new</strong>. But wait, I just wrote that you cannot use <strong class="source-inline">new</strong> on a class with a <strong class="source-inline">private</strong> constructor. This is true if this object is instantiated in another object. Here, we are instantiating the object inside itself, and access control does not apply. Every method in a class can access any other method regardless <a id="_idIndexMarker751"/>of its access. So, while the constructor is <strong class="source-inline">private</strong> to<a id="_idIndexMarker752"/> the <strong class="source-inline">getInstance</strong> method, it can be run when the object is created <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">new</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}</pre>
			<p>Now, let us test whether this <span class="No-Break">is working:</span></p>
			<pre class="source-code">
public class SingletonExample {
    public void perform() {</pre>
			<p>Here, we are instantiating two class fields by calling upon the <strong class="source-inline">getInstance</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">Singleton</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        var myInstance1 = Singleton.getInstance();
        var myInstance2 = Singleton.getInstance();</pre>
			<p>If our <strong class="source-inline">Singleton</strong> class<a id="_idIndexMarker753"/> is working, the two instances of <strong class="source-inline">Singleton</strong> will be<a id="_idIndexMarker754"/> the same. When we compare object references, we are comparing the address in memory of these objects. If the address is the same, then we have the <span class="No-Break">same object:</span></p>
			<pre class="source-code">
        if (myInstance1 == myInstance2) {
            System.out.printf(
               "Objects are the same%n");
        } else {
            System.out.printf(
              " Objects are different%n");
        }
    }
    public static void main(String[] args) {
        new SingletonExample().perform ();
    }
}</pre>
			<p>There is one problem with our <strong class="source-inline">Singleton</strong> class. It is not thread-safe. It is possible that <strong class="source-inline">getInstance</strong> could be interrupted by a thread or threads, and this could result in two or more instances of <strong class="source-inline">Singleton</strong>. We can make this class thread-safe by synchronizing the creation of the object. Here is the updated <span class="No-Break"><strong class="source-inline">getInstance</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
    public static Singleton getInstance() {</pre>
			<p>When we create a synchronized block, we are guaranteeing that the instantiation of the <strong class="source-inline">Singleton</strong> class cannot be interrupted. This ensures that all threads get the same instance after the one time it <span class="No-Break">is instantiated:</span></p>
			<pre class="source-code">
        synchronized (Singleton.class) {
            if (instance == null) {
                instance = new Singleton();
            }
        }
        return instance;
    }</pre>
			<p>With this, we now<a id="_idIndexMarker755"/> have a <a id="_idIndexMarker756"/>thread-safe <span class="No-Break"><strong class="source-inline">Singleton</strong></span><span class="No-Break"> class.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor227"/>Factory</h2>
			<p>A factory, another <a id="_idIndexMarker757"/>creational pattern, is a class that instantiates a specific class <a id="_idIndexMarker758"/>from a family of classes that either share the same interface or are all subclasses of the same abstract class. It is<a id="_idIndexMarker759"/> a <strong class="bold">creational</strong> pattern. We will look at an example that uses an interface. Here is the <span class="No-Break">shared interface:</span></p>
			<pre class="source-code">
public interface SharedInterface {
    String whatAmI();
    void perform();
}</pre>
			<p>Now, let us create two classes that<a id="_idIndexMarker760"/> both implement the same interface. As mentioned <a id="_idIndexMarker761"/>previously, my examples only show the code that demonstrates the concept. You will add whatever code is necessary for the class to do <span class="No-Break">its work:</span></p>
			<pre class="source-code">
public class Version01 implements SharedInterface{
    @Override
    public String whatAmI() {
        return "Version 01";
    }
    @Override
    public void perform() {
        System.out.printf("Running perform in Version 01");
    }
}
public class Version02 implements SharedInterface {
    @Override
    public String whatAmI() {
        return "Version 02";
    }
    @Override
    public void perform() {
        System.out.printf("Running perform in Version 02");
    }
}</pre>
			<p>Now, we can<a id="_idIndexMarker762"/> look at<a id="_idIndexMarker763"/> the <strong class="source-inline">Factory</strong> <span class="No-Break">class itself:</span></p>
			<pre class="source-code">
public class Factory {
    public static SharedInterface getInstance(
                                 String designator) {</pre>
			<p>Based on the string we pass to <strong class="source-inline">getInstance</strong>, we instantiate the appropriate object. Take note of <strong class="source-inline">default</strong> in the switch. It will return a <strong class="source-inline">null</strong> reference, a reference to nothing. You should test for this and take the appropriate action in the case where an invalid string is being used <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">designator</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        return switch (designator) {
            case "version01" -&gt; new Version01();
            case "version02" -&gt; new Version02();
            default -&gt; null;
        };
    }
}</pre>
			<p>Now, let us<a id="_idIndexMarker764"/> look at code <a id="_idIndexMarker765"/>that will use the <strong class="source-inline">Factory</strong> pattern to instantiate <span class="No-Break">the classes:</span></p>
			<pre class="source-code">
public class FactoryExample {</pre>
			<p>The objects we create will implement <span class="No-Break">this interface:</span></p>
			<pre class="source-code">
    private SharedInterface version;
    public void perform(String versionName) {</pre>
			<p>Here, we pass the string that the <strong class="source-inline">Factory</strong> pattern will use to determine which class <span class="No-Break">to instantiate:</span></p>
			<pre class="source-code">
        version = Factory.getInstance(versionName);
        System.out.printf(
            "Version: %s%n",version.whatAmI());
        version.perform();
    }
    public static void main(String[] args) {
        new FactoryExample().perform("version02");
    }
}</pre>
			<p>Using the <a id="_idIndexMarker766"/>factory<a id="_idIndexMarker767"/> pattern can simplify the creation of families of classes that all share the <span class="No-Break">same interface.</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor228"/>Adapter</h2>
			<p>Imagine <a id="_idIndexMarker768"/>that you are working with existing code that uses a specific class with its<a id="_idIndexMarker769"/> own unique interface. One day, you come across another class that performs a similar task that meets the needs of a different client or is superior to what you have been using. The problem with the new class is that it does not have the same interface. Do you rewrite your code so that it will call upon the methods in the new class? You could, but the moment you start altering the existing code, there is the potential for unforeseen problems. The solution is to wrap the new class in an adapter class. The adapter presents the interface your code is already familiar with but then calls upon the appropriate method in the new class. This is where the adapter, a <strong class="bold">structural</strong> pattern, <span class="No-Break">comes</span><span class="No-Break"><a id="_idIndexMarker770"/></span><span class="No-Break"> in.</span></p>
			<p>Let us begin with a very simple application that calculates the fuel consumption of a vehicle and returns the result as miles per gallon. We begin with an interface for a class that will perform the calculation followed by <span class="No-Break">its implementation:</span></p>
			<pre class="source-code">
public interface USFuelConsumption {
    String calculateUS(double distance, double volume);
}
public class USCar implements USFuelConsumption {
    @Override
    public String calculateUS(double distance,
                                   double volume) {
        return "MPG = " + distance/volume;
    }
}</pre>
			<p>Here is the code that will be used in <span class="No-Break">this class:</span></p>
			<pre class="source-code">
public class AdapterExample {
    private USFuelConsumption consumption;
    public AdapterExample() {
        consumption = new USCar();
    }
    public void perform() {
        System.out.printf(
              "%s%n",consumption.calculateUS(350.0, 12.0));
    }
    public static void main(String[] args) {
        new AdapterExample().perform();
    }
}</pre>
			<p>The <a id="_idIndexMarker771"/>output of this<a id="_idIndexMarker772"/> program is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">MPG = 29.166666666666668</strong></pre>
			<p>Now imagine that a new client wants to use your system but needs the calculation done using metric measurement. For cars, this is described as liters per 100 kilometers. We have an interface and a class that will <span class="No-Break">do this:</span></p>
			<pre class="source-code">
public interface MetricFuelConsumptions {
    String calculateMetric(double distance, double volume);
}
public class MetricCar implements MetricFuelConsumptions {
    @Override
    public String calculateMetric(double distance,
                                     double volume) {
        return "l/100km = " + volume/distance * 100;
    }
}</pre>
			<p>To be <a id="_idIndexMarker773"/>able to use <a id="_idIndexMarker774"/>this new class, we need an adapter, which will implement the same interface but in the method call, will use the metric <span class="No-Break">calculation class:</span></p>
			<pre class="source-code">
public class UstoMetricAdapter implements USFuelConsumption {
    private final MetricCar metric;
    public UstoMetricAdapter() {
        metric = new MetricCar();
    }</pre>
			<p>Here is the method we are adapting. Rather than doing the calculation here, it will call upon the method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">MetricCar</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    @Override
    public String calculateUS(double distance,
                                     double volume) {
        return metric.calculateMetric(distance, volume);
    }
}</pre>
			<p>Now, let us see how it will <span class="No-Break">be used:</span></p>
			<pre class="source-code">
public class AdapterExample {
    private USFuelConsumption consumption;
    public AdapterExample() {</pre>
			<p>Here is the only line we need to change. As the adapter shares the same interface, it can be used in place <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">USCar</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
        consumption = new UstoMetricAdapter();
    }
    public void perform() {
        System.out.printf("%s%n",
            consumption.calculateUS(350.0, 44.0));
    }
    public static void main(String[] args) {
        new AdapterExample().perform();
    }
}</pre>
			<p>The program output is now <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">l/100km = 12.571428571428573</strong></pre>
			<p>This is a <a id="_idIndexMarker775"/>trivial<a id="_idIndexMarker776"/> example, but it is an example of code reuse. The adapter allows you to reuse code expecting a specific interface with new code. This new code has a different interface, and the adapter resolves this by presenting the original interface to <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-208"><a id="_idTextAnchor229"/>Observer</h2>
			<p>For this <a id="_idIndexMarker777"/>pattern, we are interested in when the state of an object changes. When a state change <a id="_idIndexMarker778"/>happens, a method in another class is called to carry out some tasks. These tasks could be to validate the state change, write the change to a database, or they could update the display. Java makes it easy to use this pattern by providing the <strong class="source-inline">PropertyChangeListener</strong> interface and the <strong class="source-inline">PropertyChangeSupport</strong> class. This is an example <a id="_idIndexMarker779"/>of a <span class="No-Break"><strong class="bold">behavioral</strong></span><span class="No-Break"> pattern.</span></p>
			<p>We begin with a class that must notify other classes should the state of any or all of its <span class="No-Break">fields change:</span></p>
			<pre class="source-code">
public class TheProperty {</pre>
			<p>This is the field in this class that we are planning to listen for changes to <span class="No-Break">its state:</span></p>
			<pre class="source-code">
    private String observedValue = "unicorn";
    private final PropertyChangeSupport support;</pre>
			<p>The constructor is instantiating an instance of the <strong class="source-inline">PropertyChangeSupport</strong> class. This object will allow us to add to or remove from a list of all the classes that implement the <strong class="source-inline">PropertyChangeListener</strong> listener for this class. It supports firing an event when a <span class="No-Break">field changes:</span></p>
			<pre class="source-code">
    public TheProperty() {
        support = new PropertyChangeSupport(this);
    }</pre>
			<p>This method lets us add to the list <span class="No-Break">of listeners:</span></p>
			<pre class="source-code">
    Public void addPropertyChangeListener(
                  PropertyChangeListener listener) {
        support.addPropertyChangeListener(listener);
    }</pre>
			<p>This<a id="_idIndexMarker780"/> method allows<a id="_idIndexMarker781"/> the removal of <span class="No-Break">a listener:</span></p>
			<pre class="source-code">
    Public void removePropertyChangeListener(
                  PropertyChangeListener listener) {
        support.removePropertyChangeListener(listener);
    }</pre>
			<p>This is the <strong class="source-inline">set</strong> method for the <strong class="source-inline">observedValue</strong> variable. When this method is called, <strong class="source-inline">firePropertyMethod</strong> will call <strong class="source-inline">propertyChange</strong> in every class that is in the list <span class="No-Break">of listeners:</span></p>
			<pre class="source-code">
    public void setObservedValue(String value) {
        System.out.printf(
               "TP: observedValue has changed.%n");
        support.firePropertyChange(
               "observedValue", this.observedValue, value);
        observedValue = value;
    }</pre>
			<p><strong class="source-inline">observedValue</strong> is a <strong class="source-inline">private</strong> field, as it should be. We need methods such as the previous <strong class="source-inline">set</strong> method and this <strong class="source-inline">get</strong> method to read the value in <span class="No-Break">the field:</span></p>
			<pre class="source-code">
    public String getObservedValue() {
        return observedValue;
    }
}</pre>
			<p>Now, we need a <strong class="source-inline">listener</strong> class. There can be just one or there can <span class="No-Break">be many:</span></p>
			<pre class="source-code">
public class TheListener implements PropertyChangeListener{</pre>
			<p>This is the field that we wish to change if the field in <strong class="source-inline">TheProperty</strong> changes. While this is the usual way to use this pattern, the method that will be called when a change occurs is free to do whatever it wants and not just update a field in <span class="No-Break">the listener:</span></p>
			<pre class="source-code">
    private String updatedValue;</pre>
			<p>Here is<a id="_idIndexMarker782"/> the method that <a id="_idIndexMarker783"/>is called in every listener to <strong class="source-inline">TheProperty</strong>. While it is assigning the new value from <strong class="source-inline">TheProperty</strong> to its own <strong class="source-inline">updatedValue</strong>, you could do anything in this method, even write to a database as an example. Notice that the <strong class="source-inline">PropertyChangeEvent</strong> object has access to a name you gave to the property, usually the field name, along with the previous and new values. The name can be used to decide on different actions depending on which field <span class="No-Break">was changed:</span></p>
			<pre class="source-code">
    @Override
    public void propertyChange(PropertyChangeEvent evt) {
        System.out.printf("TL: The state has changed.%n");
        System.out.printf("TL: Observed field:%s%n",
                          evt.getPropertyName());
        System.out.printf("TL: Previous value: %s%n",
                          evt.getOldValue());
        System.out.printf("TL: New value: %s%n",
                          evt.getNewValue());
        setUpdatedValue((String) evt.getNewValue());
    }</pre>
			<p>This <a id="_idIndexMarker784"/>class also <a id="_idIndexMarker785"/>has a set and get method for its private <span class="No-Break"><strong class="source-inline">updatedValue</strong></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
    public String getUpdatedValue() {
        return updatedValue;
    }
    public void setUpdatedValue(String updatedValue) {
        this.updatedValue = updatedValue;
    }
}</pre>
			<p>Now we can test that if a change is made to the <strong class="source-inline">TheProperty</strong> object’s field, then <strong class="source-inline">TheListener</strong> <span class="No-Break">is notified:</span></p>
			<pre class="source-code">
public class PropertyListenerExample {
    public void perform() {</pre>
			<p>We need at least one observable and any number of observers. They can be local variables like this or <span class="No-Break">class fields:</span></p>
			<pre class="source-code">
        var observable = new TheProperty();
        var observer = new TheListener();</pre>
			<p>A listener is added to the <span class="No-Break">observed object:</span></p>
			<pre class="source-code">
        observable.addPropertyChangeListener(observer);</pre>
			<p>Now, we <a id="_idIndexMarker786"/>update the<a id="_idIndexMarker787"/> observed field in the observable object. This will also result in the field in the observer object <span class="No-Break">being updated:</span></p>
			<pre class="source-code">
        observable.setObservedValue("moose");
        System.out.printf(
                "PLE: New value in observer is %s%n",
                observable.getObservedValue());
    }
    public static void main(String[] args) {
        new PropertyListenerExample().perform();
    }
}</pre>
			<p>In this section, we looked at four of the many patterns. Patterns themselves are broken down into categories. Singleton and factory are creational patterns. Adapter is a structural pattern. Observer is a behavioral pattern. All the patterns can be applied to any language <span class="No-Break">you use.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor230"/>Summary</h1>
			<p>In this chapter, we just touched upon SOLID software design principles and the singleton, factory, adapter, and observer design patterns. There are dozens of other principles and patterns. Design principles should guide your everyday coding, and design patterns offer solutions to design problems. Both are applicable to <span class="No-Break">any language.</span></p>
			<p>Next up, we will be looking at documenting and testing the code that <span class="No-Break">you write.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor231"/>Further reading</h1>
			<ul>
				<li><em class="italic">Design Principles in </em><span class="No-Break"><em class="italic">Java</em></span><span class="No-Break">: </span><a href="https://www.javatpoint.com/design-principles-in-java"><span class="No-Break">https://www.javatpoint.com/design-principles-in-java</span></a></li>
				<li><em class="italic">Object Oriented Design Principles in </em><span class="No-Break"><em class="italic">Java</em></span><span class="No-Break">: </span><a href="https://stackabuse.com/object-oriented-design-principles-in-java/"><span class="No-Break">https://stackabuse.com/object-oriented-design-principles-in-java/</span></a></li>
				<li><em class="italic">What’s a Software Design Pattern? (+7 Most Popular </em><span class="No-Break"><em class="italic">Patterns)</em></span><span class="No-Break"> </span><a href="https://www.netsolutions.com/insights/software-design-pattern/"><span class="No-Break">https://www.netsolutions.com/insights/software-design-pattern/</span></a></li>
				<li><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em>, by Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm, 0-201-63361-2, available in libraries or from <span class="No-Break">online booksellers</span></li>
			</ul>
		</div>
	</body></html>