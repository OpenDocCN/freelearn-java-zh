<html><head></head><body>
		<div id="_idContainer010">
			<h1 class="chapter-number" id="_idParaDest-29"><a id="_idTextAnchor028"/>2</h1>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Data Structures</h1>
			<p>Data structures are important components that contribute to, or detract from, the performance of our Java applications. They are foundational parts that are used throughout our programs and can help us organize and manipulate data efficiently. Data structures are essential for optimizing the performance of our Java applications because they can ensure that our data access, memory management, and caching are efficient. Proper use of data structures can lead to algorithm efficiency, the scalability of our solutions, and the safety of <span class="No-Break">our threads.</span></p>
			<p>The significance of data structures can be evidenced by reducing the time complexity of operations. With proper data structure implementation, we can improve the predictability and consistency of our application’s performance. In addition to improving the performance of our Java applications, properly chosen data structures result in increased code readability, making them easier <span class="No-Break">to maintain.</span></p>
			<p>In this chapter, we are going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li><span class="No-Break">Lists</span></li>
				<li><span class="No-Break">Arrays</span></li>
				<li><span class="No-Break">Trees</span></li>
				<li>Stacks <span class="No-Break">and queues</span></li>
				<li>Advanced <span class="No-Break">data structures</span></li>
			</ul>
			<p>By the end of this chapter, you should understand how specific data structures, such as <strong class="bold">lists</strong>, <strong class="bold">arrays</strong>, <strong class="bold">trees</strong>, <strong class="bold">stacks</strong>, and <strong class="bold">queues</strong>, can impact the performance of Java applications. You will have the opportunity to gain hands-on experience with Java code that demonstrates how to improve performance through proper data structure selection <span class="No-Break">and implementation.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Technical requirements</h1>
			<p>To follow the examples and instructions in this chapter, you will need to be able to load, edit, and run Java code. If you haven’t set up your development environment, please refer to <a href="B21942_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><span class="No-Break">.</span></p>
			<p>The code for this chapter can be found <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter02</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Improving performance with lists</h1>
			<p>A list is a fundamental data<a id="_idIndexMarker041"/> structure in the Java programming language. They give us the ability to easily create, store, and manipulate an ordered collection of elements. This data structure uses the <strong class="source-inline">java.util.list</strong> interface and extends the <span class="No-Break"><strong class="source-inline">java.util.Collection</strong></span><span class="No-Break"> interface.</span></p>
			<p>In this section, we will take a <a id="_idIndexMarker042"/>close look at lists, why and when to use them, and techniques for getting the highest performance out <span class="No-Break">of them.</span></p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor032"/>Why use lists?</h2>
			<p>Perhaps the most common way of explaining what the list data structure can be used for is as a check-off/to-do list or a <a id="_idIndexMarker043"/>grocery shopping list. We create lists in our programs because we want to leverage one or more of <span class="No-Break">its advantages:</span></p>
			<ul>
				<li><strong class="bold">Ordered elements</strong>: Lists are used to maintain the order of our elements, even as we add new elements. This allows us to manipulate our data in a specific sequence. Consider a system log that has new entries added with date and time stamps. We would want those entries to be maintained in a <span class="No-Break">specific order.</span></li>
				<li><strong class="bold">Automatic resizing</strong>: Lists can be used to dynamically resize themselves as our programs add and remove elements. This is <a id="_idIndexMarker044"/>especially true in <strong class="bold">ArrayLists</strong>, which are covered later in <span class="No-Break">this chapter.</span></li>
				<li><strong class="bold">Positional data access</strong>: Lists allow<a id="_idIndexMarker045"/> us to obtain random access efficiently by using the element’s index, also referred to as <span class="No-Break"><strong class="bold">positional data</strong></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Duplicate elements</strong>: Lists allow us to have duplicate elements. So, if this is important for your use case, then you might consider using a list as your data <span class="No-Break">structure selection.</span></li>
				<li><strong class="bold">Iterability</strong>: The list data structure allows us to easily iterate through our elements. We can use loops and the <strong class="source-inline">forEach</strong> method. We will look at an example of this in the next<a id="_idIndexMarker046"/> section of <span class="No-Break">this chapter.</span></li>
				<li><strong class="bold">Multiple implementation options</strong>: Java’s list data structure can be implemented as a <strong class="source-inline">LinkedList</strong>, <strong class="source-inline">ArrayList</strong>, or <strong class="source-inline">Vector</strong> list type. These list types offer unique characteristics. The following table shows the different characteristics of these list types. Pay special attention to the <span class="No-Break">performance row:</span></li>
			</ul>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-2">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">LinkedList</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">ArrayList</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Vector</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Data structure</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Doubly-linked list</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Dynamic array</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Dynamic array</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Use case</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>To frequently <span class="No-Break">manipulate data</span></p>
						</td>
						<td class="No-Table-Style">
							<p>For <span class="No-Break">fast reads</span></p>
						</td>
						<td class="No-Table-Style">
							<p>When thread safety <span class="No-Break">is required</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Performance</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>+ Adds <span class="No-Break">and deletes</span></p>
							<p>- Access <span class="No-Break">by index</span></p>
						</td>
						<td class="No-Table-Style">
							<p>- Adds <span class="No-Break">and deletes</span></p>
							<p>+ Access <span class="No-Break">by index</span></p>
						</td>
						<td class="No-Table-Style">
							<p>- Adds <span class="No-Break">and deletes</span></p>
							<p>- Access <span class="No-Break">by index</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Thread safety</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>No, not <span class="No-Break">by default</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No, not <span class="No-Break">by default</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Yes, <span class="No-Break">by default</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Figure">Table 2.1 – Lists</p>
			<p class="list-inset">When choosing between <strong class="source-inline">LinkedList</strong>, <strong class="source-inline">ArrayList</strong>, and <strong class="source-inline">Vector</strong> list types, we should consider the requirements based on our use case. For example, if our use case includes frequent adds and deletes, then <strong class="source-inline">LinkedList</strong> might be the best option. Alternatively, if we have infrequent adds and deletes, but heavy reads, then <strong class="source-inline">ArrayList</strong> is likely our best option. Finally, if we are most concerned about thread safety, <strong class="source-inline">Vector</strong> might be our <span class="No-Break">best option.</span></p>
			<p class="callout-heading">Important note about thread safety</p>
			<p class="callout">While <strong class="source-inline">LinkedList</strong> and <strong class="source-inline">ArrayList</strong> are not<a id="_idIndexMarker047"/> thread-safe by default, they can be made thread-safe by explicitly synchronizing access. This should prevent concurrent access-related data corruption, but it will likely lead to lower performance regarding your <span class="No-Break">Java application.</span></p>
			<ul>
				<li><strong class="bold">Build-in methods</strong>: Perhaps one of the greatest benefits of using a list is that we can take advantage of methods in the <strong class="source-inline">java.util.List</strong> interface, which the list implements. These built-in methods include functionality for searching, adding, and removing elements. A full list of <strong class="source-inline">java.util.Llist</strong> methods are available in the official Java <a id="_idIndexMarker048"/><span class="No-Break">documentation: </span><a href="https://docs.oracle.com/javase/8/docs/api/java/util/List.html"><span class="No-Break">https://docs.oracle.com/javase/8/docs/api/java/util/List.html</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>Now that we’ve reviewed why we should use lists, let’s look at examples of <span class="No-Break">common implementations.</span></p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Common list implementations</h2>
			<p>In this section, we will look at <a id="_idIndexMarker049"/>implementation examples for <strong class="source-inline">ArrayList</strong>, <strong class="source-inline">LinkedList</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Vector</strong></span><span class="No-Break">.</span></p>
			<h3>ArrayList example</h3>
			<p>Our first list<a id="_idIndexMarker050"/> implementation example is an <strong class="source-inline">ArrayList</strong> list type of numbers. We will <a id="_idIndexMarker051"/>assume that this is part of a human resources (HR) system that stores start dates, end dates, and length of service. As shown in the following code, we must import both <strong class="source-inline">java.util.ArrayList</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">java.util.List</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
import java.util.ArrayList;
import java.util.List;</pre>			<p>Next, we have our class declaration and main method. Here, we must create an <strong class="source-inline">ArrayList</strong> list type <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">hr_numbers</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Example1 {
  public static void main(String[] args) {
    <strong class="bold">List&lt;Integer&gt; hr_numbers = new ArrayList&lt;&gt;();</strong></pre>			<p>The next two lines of code use the <strong class="source-inline">.add</strong> method to add elements to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    hr_numbers.<strong class="bold">add</strong>(1983);
    hr_numbers.<strong class="bold">add</strong>(2008);</pre>			<p>The next three lines of code get the first two numbers, using the <strong class="source-inline">get</strong> method, and use them to calculate a value to <a id="_idIndexMarker052"/>add as a third element <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">ArrayList</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    int startYear = hr_numbers.get(0);
    int endYear = hr_numbers.get(1);
    hr_numbers.add(endYear-startYear);</pre>			<p>The last section of the code is a <strong class="source-inline">for</strong> loop. This iterates through the list and provides output to the <span class="No-Break">terminal window:</span></p>
			<pre class="source-code">
    for (int number : hr_numbers) {
      System.out.println(number);
    }</pre>			<p>Here’s the <span class="No-Break">program’s output:</span></p>
			<pre class="console">
1983
2008
25</pre>			<p>As you can see, our output is as expected; we simply print each of the three elements to the terminal window using a <span class="No-Break"><strong class="source-inline">for-each</strong></span><span class="No-Break"> loop.</span></p>
			<p class="callout-heading">for-each loops</p>
			<p class="callout">Java 5 introduced an enhanced <strong class="source-inline">for</strong> loop called the <strong class="source-inline">for-each</strong> loop. We can use this loop to iterate through elements <a id="_idIndexMarker053"/>without using an explicit iterator or index. This makes our code quicker to write and <span class="No-Break">more readable.</span></p>
			<h3>LinkedList example</h3>
			<p>Our <strong class="source-inline">LinkedList</strong> implementation <a id="_idIndexMarker054"/>example is a simple <strong class="bold">LinkedList</strong> of pet names. The <a id="_idIndexMarker055"/>following code demonstrates how to create a list and use the <strong class="source-inline">get</strong>, <strong class="source-inline">remove</strong>, <strong class="source-inline">contains</strong>, and <strong class="source-inline">size</strong> methods. As you can see, we import both <strong class="source-inline">java.util.LinkedList</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">java.util.List</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Import java.util.LinkedList;
import java.util.List;</pre>			<p>Next, we have our class declaration and the main method. Here, we create a <strong class="source-inline">LinkedList</strong> list type <a id="_idIndexMarker056"/><span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">petNames</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Example2 {
  public static void main(String[] args) {
    <strong class="bold">List&lt;String&gt; petNames = new LinkedList&lt;&gt;();</strong></pre>			<p>The next four lines of code use the <strong class="source-inline">.add</strong> method to add elements to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">LinkedList</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    petNames.<strong class="bold">add</strong>("Brandy");
    petNames.<strong class="bold">add</strong>("Muzz");
    petNames.<strong class="bold">add</strong>("Java");
    petNames.<strong class="bold">add</strong>("Bougie");</pre>			<p>The next two lines of code demonstrate how to get the first two pets using the <span class="No-Break"><strong class="source-inline">get</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
    String firstPet = petNames.get(0);
    String secondPet = petNames.get(1);</pre>			<p>The next section of the code is a <strong class="source-inline">for-each</strong> loop that iterates through the list and provides output to the <span class="No-Break">terminal window:</span></p>
			<pre class="source-code">
    for (String pet : petNames) {
      System.out.println(pet);
    }</pre>			<p>Here’s the <span class="No-Break">loop’s output:</span></p>
			<pre class="console">
Brandy
Muzz
Java
Bougie</pre>			<p>We can remove an element from our <strong class="source-inline">LinkedList</strong> by using the <strong class="source-inline">remove</strong> method, as illustrated here. As you can see, after calling the <strong class="source-inline">remove</strong> method, <strong class="source-inline">Brandy</strong> is no longer an element <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">LinkedList</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
petNames.remove("Brandy");</pre>			<p>The next part of our code calls the <strong class="source-inline">contains</strong> method to check if a specific value is found in <strong class="source-inline">LinkedList</strong>. Since <a id="_idIndexMarker057"/>we previously removed this pet from <strong class="source-inline">LinkedList</strong>, the Boolean result <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
boolean containsBrandy = petNames.contains("Brandy");
System.out.println(containsBrandy);</pre>			<p>The output of the <strong class="source-inline">println</strong> statement is <span class="No-Break">as expected:</span></p>
			<pre class="console">
false</pre>			<p>This final section of our code demonstrates the use of the <strong class="source-inline">size</strong> method. Here, we make a call to that method, which returns an integer. We use that value in our <span class="No-Break">final output:</span></p>
			<pre class="source-code">
int size = petNames.size();
System.out.println("You have " + size + " pets.");</pre>			<p>The final output reflects the expected size of <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">LinkedList</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
You have 3 pets.</pre>			<p>Now that we’ve looked at how to implement <strong class="source-inline">ArrayList</strong> and <strong class="source-inline">LinkedList</strong>, let’s look at our final <a id="_idIndexMarker058"/><span class="No-Break">example, </span><span class="No-Break"><strong class="bold">Vector</strong></span><span class="No-Break">.</span></p>
			<h3>Vector example</h3>
			<p>Our last list implementation<a id="_idIndexMarker059"/> example is a <strong class="source-inline">Vector</strong> list type. As you will see, <strong class="source-inline">Vector</strong> is similar to <strong class="source-inline">ArrayList</strong>. We implement them as dynamic arrays so that we can benefit from efficient random access to our vector’s elements. Vectors have the added benefit of being thread-safe by default. This is due to the default synchronization we previously discussed. Let’s look at some <span class="No-Break">example code.</span></p>
			<p>Our example program will <a id="_idIndexMarker060"/>store a set of lucky numbers. It starts by importing the <strong class="source-inline">java.util.Vector</strong> and <span class="No-Break"><strong class="source-inline">java.util.Enumeration</strong></span><span class="No-Break"> packages:</span></p>
			<pre class="source-code">
import java.util.Vector;
import java.util.Enumeration;</pre>			<p>Next, we have our class declaration and the main method. Here, we create a <strong class="source-inline">Vector</strong> list type called <strong class="source-inline">luckyNumbers</strong> that will <span class="No-Break">store integers:</span></p>
			<pre class="source-code">
public class Example3 {
  public static void main(String[] args) {
    <strong class="bold">Vector&lt;Integer&gt; luckyNumbers = new Vector&lt;&gt;();</strong></pre>			<p>The next three lines of code use the <strong class="source-inline">.add</strong> method to add elements to <span class="No-Break">our </span><span class="No-Break"><strong class="source-inline">Vector</strong></span><span class="No-Break">.</span></p>
			<pre class="source-code">
    luckyNumbers.<strong class="bold">add</strong>(8);
    luckyNumbers.<strong class="bold">add</strong>(19);
    luckyNumbers.<strong class="bold">add</strong>(24);</pre>			<p>The next two lines of code demonstrate how to access a vector’s elements with the use of the index and the <strong class="source-inline">get</strong> method. Note that indices start at <span class="No-Break">zero (0):</span></p>
			<pre class="source-code">
    int firstNumber = luckyNumbers.get(0);
    int secondNumber = luckyNumbers.get(2);</pre>			<p>The next section of the code uses a legacy approach for iterating through a <strong class="source-inline">Vector</strong> list type. The enumeration approach can be used in place of an enhanced or <strong class="source-inline">for-each</strong> loop. Vectors, in and of themselves, are considered a list type that’s falling out of common use. The following code iterates through the list and provides output to the <span class="No-Break">terminal window:</span></p>
			<pre class="source-code">
    Enumeration&lt;Integer&gt; enumeration = luckyNumbers.elements();
    while (enumeration.hasMoreElements()) {
      int number = enumeration.nextElement();
      System.out.println(number);
    }</pre>			<p>Here’s the <span class="No-Break">program’s output:</span></p>
			<pre class="console">
8
19
24</pre>			<p>We can remove an element from our <strong class="source-inline">Vector</strong> by using the <strong class="source-inline">removeElement</strong> method, as illustrated here. After <a id="_idIndexMarker061"/>calling the <strong class="source-inline">removElement</strong> method, the lucky number 19 is removed as an element <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Vector</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
luckyNumbers.removeElement(19);</pre>			<p>The next part of our code calls the <strong class="source-inline">contains</strong> method to check if a specific value is found in <strong class="source-inline">Vector</strong>. Since we previously removed this lucky number from <strong class="source-inline">Vector</strong>, the Boolean result <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
boolean containsNineteen= luckyNumbers.contains(19);
System.out.println(containsNineteen);</pre>			<p>The output of the <strong class="source-inline">println</strong> statement is <span class="No-Break">as expected:</span></p>
			<pre class="console">
false</pre>			<p>This final section of our code demonstrates the use of the <strong class="source-inline">size</strong> method. Here, we make a call to that method, which returns an integer. We use that value in our <span class="No-Break">final output:</span></p>
			<pre class="source-code">
int mySize = luckyNumbers.size();
System.out.println("You have " + mySize + " lucky numbers.");</pre>			<p>The final output reflects the expected size of our <strong class="source-inline">LinkedList</strong> <span class="No-Break">list type:</span></p>
			<pre class="console">
You have 2 lucky numbers.</pre>			<p>This section provided examples of using lists for <strong class="source-inline">ArrayList</strong>, <strong class="source-inline">LinkedList</strong>, and <strong class="source-inline">Vector</strong>. There are additional implementations that you can consider, including <strong class="source-inline">CopyOnWriteArrayList</strong>, <strong class="source-inline">CopyOnWriteArraySet</strong>, and <strong class="source-inline">LinkedHashSet</strong>. Stacks are another<a id="_idIndexMarker062"/> implementation and are covered later in this chapter. Next, we will look at achieving high performance <span class="No-Break">with lists.</span></p>
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>High performance with lists</h2>
			<p>Let’s take a look at <a id="_idIndexMarker063"/>how we can improve the performance of our Java apps when using lists. The following code example implements a <strong class="source-inline">LinkedList</strong> list type of integers. Here, we’ll create a <strong class="source-inline">LinkedList</strong> list type, add four elements to it, and then iterate through the list, printing each element to <span class="No-Break">the screen:</span></p>
			<pre class="source-code">
import java.util.LinkedList;
import java.util.List;
public class Example4 {
  public static void main(String[] args) {
    List&lt;Integer&gt; numbers = new LinkedList&lt;&gt;();
    numbers.add(3);
    numbers.add(1);
    numbers.add(8);
    numbers.add(9);
    System.out.println("Initial LinkedList elements:");
    for (int number : numbers) {
      System.out.println(number);
    }
  }
}</pre>			<p>The output of this first section<a id="_idIndexMarker064"/> is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Initial LinkedList elements:
3
1
8
9</pre>			<p>The next section of code removes an element using the <strong class="source-inline">remove</strong> method – specifically, the first occurrence <span class="No-Break">of 8:</span></p>
			<pre class="source-code">
numbers.remove(Integer.valueOf(8));</pre>			<p>The following code segment performs two checks using the <strong class="source-inline">contains</strong> method. First, it checks for a 3 and then an 8. The results are printed on <span class="No-Break">the screen:</span></p>
			<pre class="source-code">
boolean containsThree = numbers.contains(3);
System.out.println("\nThe question of 3: " + containsThree);
boolean containsEight = numbers.contains(8);
System.out.println("The question of 8: " + containsEight);</pre>			<p>The output of this section of code is <span class="No-Break">shown here:</span></p>
			<pre class="console">
The question of 3: true
The question of 8: false</pre>			<p>This final segment of code iterates through <strong class="source-inline">LinkedList</strong> and prints <span class="No-Break">its values:</span></p>
			<pre class="source-code">
System.out.println("\nModified LinkedList elements:");
for (int number : numbers) {
  System.out.println(number);
}</pre>			<p>The output of this final section of code is <span class="No-Break">as follows:</span></p>
			<pre class="console">
Modified LinkedList elements:
3
1
9</pre>			<p>Now, it’s time to see what we can do to modify our code to improve overall performance. There are several <a id="_idIndexMarker065"/>techniques we <span class="No-Break">can use:</span></p>
			<ul>
				<li><strong class="bold">Data type usage</strong>: We should always use the most appropriate data types for our LinkedLists. In our example, we used <strong class="source-inline">List&lt;Integer&gt;</strong> objects. The <strong class="source-inline">Integer</strong> class is essentially a wrapper around the primitive <strong class="source-inline">int</strong> data type. The <strong class="source-inline">Integer</strong> object only contains one field of the <strong class="source-inline">int</strong> type. Here’s how we can modify <span class="No-Break">our code:</span><pre class="source-code">
LinkedList&lt;Integer&gt; numbers = new LinkedList&lt;&gt;();</pre></li>				<li><strong class="bold">Element removal</strong>: When we remove elements from <strong class="source-inline">LinkedList</strong>, we should use an <strong class="bold">iterator</strong>. To use <a id="_idIndexMarker066"/>an iterator, we need to import the <strong class="source-inline">java.util.Iterator</strong> package. This is an efficient method of avoiding errors such as <strong class="bold">ConcurrentModificationsException</strong>, which is thrown when we attempt to make two<a id="_idIndexMarker067"/> simultaneous modifications to a collection. Here’s how we can write such <span class="No-Break">an iterator:</span><pre class="source-code">
Iterator&lt;Integer&gt; iterator = numbers.iterator();
while (iterator.hasNext()) {
  int number = iterator.next();
  if (number == 8) {
    iterator.remove();
  }
}</pre><p class="list-inset">The fully revised example is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example5.java"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter02</span><span class="No-Break">/</span><span class="No-Break">Example5.java</span></a><span class="No-Break">.</span></p></li>			</ul>
			<p>You should now have<a id="_idIndexMarker068"/> increased knowledge and confidence in using lists in Java to help improve the performance of your applications. Next, we will look at arrays and how to use <span class="No-Break">them optimally.</span></p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor035"/>Improving performance with arrays</h1>
			<p>Previously, we discussed <strong class="source-inline">ArrayList</strong>; in this section, we will focus on arrays. There are key differences in these two data types: arrays<a id="_idIndexMarker069"/> have a fixed size, while ArrayLists <a id="_idIndexMarker070"/>do not. In this section, we will review the characteristics of arrays and how to improve the performance of our Java applications when <span class="No-Break">implementing arrays.</span></p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor036"/>Array characteristics</h2>
			<p>There are four primary characteristics<a id="_idIndexMarker071"/> of arrays. Let’s take <span class="No-Break">a look:</span></p>
			<ul>
				<li><strong class="bold">Size</strong>: The size of an array is determined when it’s created. It cannot be changed when the application is <a id="_idIndexMarker072"/>running. This fixed-sized characteristic is also referred to as <strong class="bold">static</strong>. Here’s the syntax for creating <span class="No-Break">an array:</span><pre class="source-code">
int[] myNumbers = new int[10];</pre><p class="list-inset">As you can see, we explicitly specify a size of <strong class="source-inline">10</strong> as part of the <span class="No-Break">array’s declaration.</span></p></li>				<li><strong class="bold">Homeogeneous</strong>: Homeogeneous means that all data in an array must be of the same kind. As with the previous example, we created an array of integers. We could have used strings, but we cannot mix data types in a single array. We can also have an array of objects and arrays <span class="No-Break">of arrays.</span></li>
				<li><strong class="bold">Indexing</strong>: This should go without saying, so as a reminder, our indexes start with 0, not 1. So, the array that we previously created has 10 elements, indexed from 0 <span class="No-Break">to 9.</span></li>
				<li><strong class="bold">Continuous memory</strong>: One of the great efficiencies offered to us by arrays is random access. This efficiency <a id="_idIndexMarker073"/>stems from the fact that all elements in an array are stored in contiguous memory. In other words, the elements are stored in memory locations next to <span class="No-Break">each other.</span></li>
			</ul>
			<p>Now that we have a firm understanding of array characteristics, let’s explore some code that implements this important <span class="No-Break">data structure.</span></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor037"/>Implementing arrays</h2>
			<p>This section features a basic Java<a id="_idIndexMarker074"/> application that implements an array of planets using the <strong class="source-inline">String</strong> data type. As we walk through the code, we will create the array, access and print array elements, use the length method, access an array element using its index, and modify <span class="No-Break">an array.</span></p>
			<p>This first section of code<a id="_idIndexMarker075"/> creates an array <span class="No-Break">of </span><span class="No-Break"><strong class="bold">strings</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Example6 {
  public static void main(String[] args) {
    String[] planets = {
      "Mercury",
      "Venus",
      "Earth",
      "Mars",
      "Jupiter",
      "Saturn",
      "Uranus",
      "Neptune"
    };
  }
}</pre>			<p>As you can see, we created an array of eight strings. This next section of code demonstrates accessing and printing all <a id="_idIndexMarker076"/>elements of <span class="No-Break">an array:</span></p>
			<pre class="source-code">
System.out.println("Planets in our solar system:");
for (int i = 0; i &lt; planets.length; i++) {
  System.out.println(planets[i]);
}</pre>			<p>Here’s the output of the preceding <span class="No-Break">code snippet:</span></p>
			<pre class="console">
Planets in our solar system:
Mercury
Venus
Earth
Mars
Jupiter
Saturn
Uranus
Neptune</pre>			<p>We can use the <strong class="source-inline">length</strong> method to determine the size of our array. It might seem like we don’t need to determine the size since it is determined when the array is created. Often, we don’t know the initial size of our arrays because they’re based on external data sources. Here’s how to determine an <span class="No-Break">array’s size:</span></p>
			<pre class="source-code">
int numberOfPlanets = planets.length;
System.out.println("Number of planets: " + numberOfPlanets);</pre>			<p>The output of the preceding code is <span class="No-Break">shown here:</span></p>
			<pre class="console">
Number of planets: 8</pre>			<p>Next, we will look at how to access an<a id="_idIndexMarker077"/> array element by referencing its index position within <span class="No-Break">the array:</span></p>
			<pre class="source-code">
String thirdPlanet = planets[2];
System.out.println("The third planet is: " + thirdPlanet);</pre>			<p>The output of the previous two lines of code is <span class="No-Break">as follows:</span></p>
			<pre class="console">
The third planet is: Earth</pre>			<p>As you can see, we printed the third element in our array by using an index reference of <strong class="source-inline">2</strong>. Remember, our indexes start <span class="No-Break">with 0.</span></p>
			<p>Our last segment of code shows how we can modify an element in <span class="No-Break">our array:</span></p>
			<pre class="source-code">
planets[1] = "Shrouded Venus";
System.out.println("After renaming Venus:");
for (String planet : planets) {
  System.out.println(planet);
}</pre>			<p>The output of the preceding code is shown here. As you can see, the new name for the element at index position 1 is reflected in <span class="No-Break">the output:</span></p>
			<pre class="console">
After renaming Venus:
Mercury
Shrouded Venus
Earth
Mars
Jupiter
Saturn
Uranus
Neptune</pre>			<p>The fully revised example is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example6.java"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter02</span><span class="No-Break">/</span><span class="No-Break">Example6.java</span></a><span class="No-Break">.</span></p>
			<p>Now that you’ve learned how to<a id="_idIndexMarker078"/> implement arrays in Java, let’s look at some approaches to improving our application’s performance in terms of <span class="No-Break">array usage.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>High performance with arrays</h2>
			<p>As we have seen with lists, our<a id="_idIndexMarker079"/> implementation approaches to data structures can have a direct impact on our Java application’s performance. This section documents several strategies and best practices for optimizing array-related Java code. These strategies can be categorized as algorithmic optimization, data structures, memory management, parallel processing, vectorization, caching, and benchmarking and profiling. Let’s look at each <span class="No-Break">of them.</span></p>
			<h3>Algorithmic optimization</h3>
			<p>Whenever we select algorithms, we<a id="_idIndexMarker080"/> should ensure they are the most appropriate for the data types we’re using. For example, it’s important to select the most efficient sorting algorithm (that is mergesort, quicksort, and so on) based on our array’s size and characteristics. In addition, binary searches can be implemented when searching in <span class="No-Break">sorted arrays.</span></p>
			<p>Additional information is provided in <a href="B21942_05.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> of <span class="No-Break">this book.</span></p>
			<h3>Data structures</h3>
			<p>The core of this chapter focuses on <a id="_idIndexMarker081"/>selecting the right data structure based on your use case and requirements. When it comes to arrays, we should select them when we need frequent read access; here, our dataset can be of a fixed size. In addition, knowing when to select <strong class="source-inline">ArrayList</strong> over <strong class="source-inline">LinkedList</strong> is <span class="No-Break">equally important.</span></p>
			<h3>Memory management</h3>
			<p>Whenever possible, we should avoid creating temporary objects to support array operations. Instead, we should reuse arrays or use methods such as <strong class="source-inline">Arrays.copyOf</strong> or <strong class="source-inline">System.arraycopy</strong> for <a id="_idIndexMarker082"/><span class="No-Break">greater efficiency.</span></p>
			<p>Additional information is provided in <a href="B21942_08.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> of <span class="No-Break">this book.</span></p>
			<h3>Parallel processing</h3>
			<p>When we must sort and process large arrays, it can be beneficial to employ Java’s parallel processing capabilities, such<a id="_idIndexMarker083"/> as by using <strong class="source-inline">parallelSort</strong>. You should consider using multithreading with concurrent array processing. This is especially important for <span class="No-Break">large arrays.</span></p>
			<p>Additional information is provided in <a href="B21942_09.xhtml#_idTextAnchor159"><span class="No-Break"><em class="italic">Chapter 9</em></span></a> of <span class="No-Break">this book.</span></p>
			<h3>Vectorization</h3>
			<p>In the context of Java arrays, vectorization is a technique that involves performing operations on more than one<a id="_idIndexMarker084"/> element of an array simultaneously. This typically includes optimizing modern central processors. The goal is to increase array processing operations. This is often<a id="_idIndexMarker085"/> referred to as <strong class="bold">single instruction, multiple data</strong> (<strong class="bold">SIMD</strong>). There are specific data types that are designed to work with SIMD instructions so that they include the <strong class="source-inline">java.util.Vector</strong> class, which was introduced with <span class="No-Break">Java 16.</span></p>
			<p>Vectorization can provide significant performance benefits, especially with large arrays. This is exponentially true when operations can be parallelized. There are limits to what can be vectorized, such as dependencies and <span class="No-Break">complex operations.</span></p>
			<h3>Caching</h3>
			<p>A proven performance <a id="_idIndexMarker086"/>approach is to optimize array access patterns to support cache locality. This can be achieved by accessing contiguous memory locations. Another approach is to minimize pointer aliasing to the best extent possible. While point aliasing might support compiler optimizations, local variables or array indexes should be used instead for <span class="No-Break">optimal performance.</span></p>
			<p>Additional information is provided in <a href="B21942_08.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> of <span class="No-Break">this book.</span></p>
			<h3>Benchmarking and profiling</h3>
			<p>Whenever possible, we should conduct benchmarking so that we can compare our approach to array operations. Armed with this analysis, we can select the most efficient and proven approach. As part of our analysis, we can employ profiling tools to help identify performance bottlenecks specific to our <span class="No-Break">array operations.</span></p>
			<p>Additional information is provided in <a href="B21942_13.xhtml#_idTextAnchor227"><span class="No-Break"><em class="italic">Chapter 13</em></span></a> of <span class="No-Break">this book.</span></p>
			<p>Now that you’ve learned how to improve Java application performance when dealing with arrays, let’s look at how this can be done <span class="No-Break">with trees.</span></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor039"/>Improving performance with trees</h1>
			<p>A <strong class="bold">tree</strong> is a hierarchical data structure<a id="_idIndexMarker087"/> that consists of <a id="_idIndexMarker088"/>parent and child <strong class="bold">nodes</strong>, analogous to that of a physical tree. The topmost node is referred to as the <strong class="bold">root</strong> and there can <a id="_idIndexMarker089"/>only be one in a tree<a id="_idIndexMarker090"/> data structure. The nodes are the foundational components of this data structure. Each node contains both data and references to child nodes. There are additional terms that you should be familiar with regarding trees. A <strong class="bold">leaf node</strong> has no child. Any <a id="_idIndexMarker091"/>node and its descendants can be <a id="_idIndexMarker092"/>considered <span class="No-Break">a </span><span class="No-Break"><strong class="bold">subtree</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>Examples of a tree structure</h2>
			<p>As shown in the following <a id="_idIndexMarker093"/>example, we can implement trees as objects <span class="No-Break">or classes:</span></p>
			<pre class="source-code">
class TreeNode {
  int data;
  TreeNode left;
  TreeNode right;
  public TreeNode(int data) {
    this.data = data;
    this.left = null;
    this.right = null;
  }
}</pre>			<p>The preceding code snippet defines a <strong class="source-inline">TreeNode</strong> class that can be used along with another class for tree <a id="_idIndexMarker094"/>operation management. We need to create our tree in our <strong class="source-inline">main()</strong> method. Here’s an example of how to <span class="No-Break">do that:</span></p>
			<pre class="source-code">
Example7BinarySearchTree bst = new Example7BinarySearchTree();</pre>			<p>To insert data into our tree, we can use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
bst.insert(50);
bst.insert(30);
bst.insert(70);
bst.insert(20);
bst.insert(40);
bst.insert(60);
bst.insert(80);</pre>			<p>To use or search our tree, we can perform a binary search for an element in our tree using code similar to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
int searchElement = 70;
if (bst.search(searchElement)) {
  System.out.println("\n" + searchElement + " was found in the tree.");
} else {
  System.out.println("\n" + searchElement + " was not found in the 
  tree.");
}</pre>			<p>A full working example is available <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example7.java"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter02</span><span class="No-Break">/</span><span class="No-Break">Example7.java</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor041"/>High-performance considerations</h2>
			<p>The tree data structure can be very complex, so we should consider our Java application’s overall <a id="_idIndexMarker095"/>performance, especially regarding algorithms that manipulate our trees. Additional considerations can be categorized as type, safety, iteration, memory, operations, and caching. Let’s briefly look at each of <span class="No-Break">these categories.</span></p>
			<h3>Type</h3>
			<p>It’s important to <a id="_idIndexMarker096"/>carefully construct our trees so that they are as balanced as possible. We should be mindful of the <strong class="bold">tree’s height</strong>, which is the longest path from the root to a leaf node. The data requirements should be reviewed so that we can select the most optimal tree. For example, we can use a <strong class="bold">binary search tree</strong>, which can <a id="_idIndexMarker097"/>provide us with <span class="No-Break">efficient searches.</span></p>
			<h3>Safety</h3>
			<p>As with other data <a id="_idIndexMarker098"/>structures, you should always implement thread safety protocols or, at a minimum, use concurrent <span class="No-Break">tree structures.</span></p>
			<h3>Iteration</h3>
			<p>Iteration operations can often <a id="_idIndexMarker099"/>present bottlenecks, calling for an optimization strategy. In addition, the use of recursive algorithms should be minimized to improve <span class="No-Break">overall performance.</span></p>
			<h3>Memory</h3>
			<p>Generally, and as it <a id="_idIndexMarker100"/>applies to trees specifically, we should minimize object creation and overhead. We should strive to do our best to manage <span class="No-Break">memory efficiently.</span></p>
			<p>Additional information is provided in <a href="B21942_08.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> of <span class="No-Break">this book.</span></p>
			<h3>Operations</h3>
			<p>There are several things we can do to optimize operations. For example, we can use batch operations to<a id="_idIndexMarker101"/> reduce processing overhead. Optimizing our algorithms can help us avoid excessive processing and <span class="No-Break">data updates.</span></p>
			<p>Additional information is<a id="_idIndexMarker102"/> provided in <a href="B21942_05.xhtml#_idTextAnchor088"><span class="No-Break"><em class="italic">Chapter 5</em></span></a> of <span class="No-Break">this book.</span></p>
			<h3>Caching</h3>
			<p>We can optimize the <a id="_idIndexMarker103"/>way our data is laid out to maximize cache locality. Our goal with caching is to reduce memory access times. In addition, we can access nearly all nodes in memory to further <span class="No-Break">improve performance.</span></p>
			<p>Additional information is provided in <a href="B21942_08.xhtml#_idTextAnchor143"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> of <span class="No-Break">this book.</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor042"/>Improving performance with stacks and queues</h1>
			<p><strong class="bold">Stacks</strong> and <strong class="bold">queues</strong> are almost <a id="_idIndexMarker104"/>always grouped because they can both be used to manage and manipulate collections of<a id="_idIndexMarker105"/> data elements. They <a id="_idIndexMarker106"/>are both linear stacks; that’s where their similarities end. While grouped, there are key differences in how they operate. In this section, we’ll look at how to implement stacks and queues and how to optimize them for high-performance <span class="No-Break">Java applications.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Implementing stacks</h2>
			<p>Stacks are linear data <a id="_idIndexMarker107"/>structures that use the <strong class="bold">last in, first out</strong> (<strong class="bold">LIFO</strong>) principle of element <a id="_idIndexMarker108"/>management. With stacks, elements are added to and removed from the <strong class="bold">top</strong> of the stack. We <strong class="source-inline">push</strong> elements to the top, <strong class="source-inline">peek</strong> to view an element, and <strong class="source-inline">pop</strong> to remove the <span class="No-Break">top element.</span></p>
			<p>The following example demonstrates how to create a stack in Java. You will notice that we start by importing the <span class="No-Break"><strong class="source-inline">java.util.Stack</strong></span><span class="No-Break"> package:</span></p>
			<pre class="source-code">
import java.util.Stack;
public class Example8 {
  public static void main(String[] args) {
    Stack&lt;Double&gt; transactionStack = new Stack&lt;&gt;();
    transactionStack.push(100.0);
    transactionStack.push(-50.0);
    transactionStack.push(200.0);
    while (!transactionStack.isEmpty()) {
      double transactionAmount = transactionStack.pop();
      System.out.println("Transaction: " + transactionAmount);
    }
  }
}</pre>			<p>The preceding code is a<a id="_idIndexMarker109"/> simple implementation of a Java stack. The purpose of the program is to process bank transactions. Now that you’ve seen this simple implementation, let’s see how we can refine our code for <span class="No-Break">greater performance.</span></p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>Improving the performance of stacks</h2>
			<p>Using our previous <a id="_idIndexMarker110"/>example as a starting point, we will refine it for higher performance at runtime. We’ll start by using a custom stack implementation. This type of refinement is especially effective when use cases involve a high volume of transactions. As you can see, we must import the <span class="No-Break"><strong class="source-inline">java.util.EmptyStackException</strong></span><span class="No-Break"> package.</span></p>
			<p>Next, we must declare a class and use an<a id="_idIndexMarker111"/> array with a <strong class="bold">double</strong> data type. We’re opting for this <a id="_idIndexMarker112"/>approach to avoid processing overhead due <span class="No-Break">to </span><span class="No-Break"><strong class="bold">auto-boxing</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public class Example9 {
  private double[] stack;
  private int top;
  public Example9(int capacity) {
    stack = new double[capacity];
    top = -1;
  }</pre>			<p>The following segment of code establishes a method for <strong class="source-inline">push</strong>, <strong class="source-inline">pop</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">isEmpty</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public void push(double transactionAmount) {
  if (top == stack.length - 1) {
    throw new RuntimeException("Stack is full.");
  }
  stack[++top] = transactionAmount;
}
public double pop() {
  if (isEmpty()) {
    throw new EmptyStackException();
  }
  return stack[top--];
}
public boolean isEmpty() {
  return top == -1;
}</pre>			<p>Our last section of <a id="_idIndexMarker113"/>code is our <strong class="source-inline">main()</strong> method, which processes <span class="No-Break">the stack:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
  Example9 transactionStack = new Example9(10);
  transactionStack.push(100.0);
  transactionStack.push(-50.0);
  transactionStack.push(200.0);
  while (!transactionStack.isEmpty()) {
    double transactionAmount = transactionStack.pop();
    System.out.println("Transaction: " + transactionAmount);
  }
}</pre>			<p>The output for both sets of <a id="_idIndexMarker114"/>programs, simple and optimized, are the same and are <span class="No-Break">shown here:</span></p>
			<pre class="console">
Transaction: 200.0
Transaction: -50.0
Transaction: 100.0</pre>			<p>Full working examples of both versions of our stack implementations are available at <a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java">https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example8.java</a> <span class="No-Break">and </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example9.java"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter02</span><span class="No-Break">/</span><span class="No-Break">Example9.java</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor045"/>Implementing queues</h2>
			<p>A queue is another linear<a id="_idIndexMarker115"/> data structure and uses the <strong class="bold">first in, first out</strong> (<strong class="bold">FIFO</strong>) principle. With<a id="_idIndexMarker116"/> queues, we add elements to the <strong class="bold">rear</strong> and remove them from the <strong class="bold">front</strong>. We can use a method such as <strong class="source-inline">enqueue</strong>, <strong class="source-inline">peek</strong>, and <strong class="source-inline">dequeue</strong> to manage <span class="No-Break">our queues.</span></p>
			<p>The following example demonstrates how to create a queue in Java. As you can see, we start by importing the <strong class="source-inline">java.util.LinkedList</strong> and <span class="No-Break"><strong class="source-inline">java.util.Queue</strong></span><span class="No-Break"> packages:</span></p>
			<pre class="source-code">
import java.util.LinkedList;
import java.util.Queue;
public class Example10 {
  public static void main(String[] args) {
    Queue&lt;Double&gt; transactionQueue = new LinkedList&lt;&gt;();
    transactionQueue.offer(100.0);
    transactionQueue.offer(-50.0);
    transactionQueue.offer(200.0);
    while (!transactionQueue.isEmpty()) {
      double transactionAmount = transactionQueue.poll();
      System.out.println("Transaction: " + transactionAmount);
    }
  }
}</pre>			<p>The preceding code is a simple implementation of a Java queue. The purpose of the program, just like that of the <a id="_idIndexMarker117"/>stack example, is to process bank transactions. Now that you’ve seen this simple implementation, let’s see how we can refine our code for <span class="No-Break">greater performance.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Improving the performance of queues</h2>
			<p>Our refined version of a <a id="_idIndexMarker118"/>queue implementation has been optimized for runtime performance. This is especially important for high transactional applications. We start by importing the <strong class="source-inline">java.util.NoSuchElementException</strong> package, after which we declare the class and a set of private class variables before creating a constructor for our custom <span class="No-Break">queue implementation:</span></p>
			<pre class="source-code">
import java.util.NoSuchElementException;
public class Example11 {
  private double[] queue;
  private int front;
  private int rear;
  private int size;
  private int capacity;
  public Example11(int capacity) {
    this.capacity = capacity;
    queue = new double[capacity];
    front = 0;
    rear = -1;
    size = 0;
  }</pre>			<p>The following section of code<a id="_idIndexMarker119"/> includes methods for <strong class="source-inline">enqueue</strong>, <strong class="source-inline">dequeue</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">isEmpty</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
public void enqueue(double transactionAmount) {
  if (size == capacity) {
    throw new RuntimeException("Queue is full.");
  }
  rear = (rear + 1) % capacity;
  queue[rear] = transactionAmount;
  size++;
}
public double dequeue() {
  if (isEmpty()) {
    throw new NoSuchElementException("Queue is empty.");
  }
  double transactionAmount = queue[front];
  front = (front + 1) % capacity;
  size--;
  return transactionAmount;
}
public boolean isEmpty() {
  return size == 0;
}</pre>			<p>Our last section of <a id="_idIndexMarker120"/>code is our <strong class="source-inline">main()</strong> method, which processes <span class="No-Break">the queue:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
  Example11 transactionQueue = new Example11(10);
  transactionQueue.enqueue(100.0);
  transactionQueue.enqueue(-50.0);
  transactionQueue.enqueue(200.0);
  while (!transactionQueue.isEmpty()) {
    double transactionAmount = transactionQueue.dequeue();
    System.out.println("Transaction: " + transactionAmount);
  }
}</pre>			<p>The output for both sets of programs, simple and optimized, are the same and are <span class="No-Break">provided here:</span></p>
			<pre class="console">
Transaction: 100.0
Transaction: -50.0
Transaction: 200.0</pre>			<p>Full working examples of both versions of our queue implementations are available at <a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java">https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example10.java</a> <span class="No-Break">and </span><a href="https://github.com/PacktPublishing/High-Performance-with-Java/tree/main/Chapter02/Example11.java"><span class="No-Break">https://github.com/PacktPublishing/High-Performance-with-Java/</span><span class="No-Break">tree/main/Chapter02</span><span class="No-Break">/</span><span class="No-Break">Example11.java</span></a><span class="No-Break">.</span></p>
			<p>Both stacks and queues can be used for multiple use cases in Java. It’s important to ensure we use them<a id="_idIndexMarker121"/> when it makes the most sense from a performance standpoint. Furthermore, we must consider the previously detailed <span class="No-Break">optimization approaches.</span></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>Improving performance with advanced data structures</h1>
			<p>There are more data structures <a id="_idIndexMarker122"/>available to us than the ones covered in this chapter thus far. Sometimes, instead of improving our use of a data structure, such as a list, array, tree, stack, or queue, we should implement more advanced data structures that are tailored to our specific use case and then optimize <span class="No-Break">their use.</span></p>
			<p>Let’s look at some additional, more advanced, data structures that have <span class="No-Break">performance considerations.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Hash tables</h2>
			<p>We can use <strong class="bold">hash tables</strong> when we need fast <strong class="bold">key-value</strong> lookups. There are multiple hash functions to choose from and<a id="_idIndexMarker123"/> you should be mindful of hash collisions – they need to be managed efficiently. Some additional considerations are load factor, resizing, memory usage, <span class="No-Break">and performance.</span></p>
			<p>Here’s an example of how to<a id="_idIndexMarker124"/> create a <span class="No-Break">hash table:</span></p>
			<pre class="source-code">
import java.util.HashMap;
HashMap&lt;String, Integer&gt; hashMap = new HashMap&lt;&gt;();
hashMap.put("Alice", 25);</pre>			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Graphs</h2>
			<p>Graphs, such as <strong class="bold">matrices</strong> or <strong class="bold">adjacency lists</strong>, can be used to <a id="_idIndexMarker125"/>network an application and model complex<a id="_idIndexMarker126"/> data relationships. When implementing graphs, we <a id="_idIndexMarker127"/>should implement algorithms that transverse the graph efficiently. Two algorithms that are worth exploring are <strong class="bold">breadth-first search</strong> and <strong class="bold">depth-first search</strong>. Comparing the <a id="_idIndexMarker128"/>efficiencies of these algorithms <a id="_idIndexMarker129"/>can help you select the most <span class="No-Break">optimized solution.</span></p>
			<p>Here’s how we can implement <span class="No-Break">a graph:</span></p>
			<pre class="source-code">
import java.util.ArrayList;
import java.util.List;
List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();
int numNodes = 5;
for (int i = 0; i &lt; numNodes; i++) {
  graph.add(new ArrayList&lt;&gt;());
}
graph.get(0).add(1);</pre>			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Trie</h2>
			<p>A <strong class="bold">trie</strong> is a data structure that is<a id="_idIndexMarker130"/> useful when you’re programming methods for auto-completion, prefix matching, and more. Tries allow us to efficiently store and search for <span class="No-Break">string sequences.</span></p>
			<p>Here’s an example of how to create a trie and create a root node <span class="No-Break">for it:</span></p>
			<pre class="source-code">
class TrieNode {
  TrieNode[] children = new TrieNode[26];
    boolean isEndOfWord;
}
TrieNode root = new TrieNode();</pre>			<p>We will cover<a id="_idIndexMarker131"/> string manipulation in <a href="B21942_07.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> of <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Heap</h2>
			<p><strong class="bold">Priority queues</strong> are usually <a id="_idIndexMarker132"/>implemented as <strong class="bold">heaps</strong> because they can efficiently manage elements<a id="_idIndexMarker133"/> based on their order or priority. This can be an ideal data structure for use cases that include scheduling, prioritizing, and <span class="No-Break">element order.</span></p>
			<p>Here’s an example of how to implement a priority queue as a heap. This example demonstrates both <strong class="source-inline">minHeap</strong> and <strong class="source-inline">maxHeap</strong> and adds an element <span class="No-Break">to each:</span></p>
			<pre class="source-code">
import java.util.PriorityQueue;
PriorityQueue&lt;Integer&gt; axheap = new PriorityQueue&lt;&gt;();
axheap.offer(3);
PriorityQueue&lt;Integer&gt; axheap = new PriorityQueue&lt;&gt;((a, b) -&gt; b – a);
axheap.offer(3);</pre>			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Quad trees</h2>
			<p>A <strong class="bold">quad tree</strong> is a two-dimensional <a id="_idIndexMarker134"/>partition that’s used to organize spatial data efficiently. They can be useful for spatial indexing, geographic information systems, collision detection, <span class="No-Break">and more.</span></p>
			<p>Creating a quad tree is a bit more involved than implementing other data structures. Here’s a <span class="No-Break">straightforward </span><span class="No-Break"><a id="_idIndexMarker135"/></span><span class="No-Break">approach:</span></p>
			<pre class="source-code">
class QuadTreeNode {
  int val;
  boolean isLeaf;
  QuadTreeNode topLeft;
  QuadTreeNode topRight;
  QuadTreeNode bottomLeft;
  QuadTreeNode bottomRight;
  public QuadTreeNode() {}
  public QuadTreeNode(int val, boolean isLeaf) {
      this.val = val;
      this.isLeaf = isLeaf;
  }
}
QuadTreeNode root = new QuadTreeNode(0, false);</pre>			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Octrees</h2>
			<p>An <strong class="bold">octree</strong> is a three-dimensional <a id="_idIndexMarker136"/>partition that’s used to organize spatial data efficiently. Like quad trees, octrees can be useful for spatial indexing, geographic information systems, collision detection, <span class="No-Break">and more.</span></p>
			<p>Octrees can be difficult to implement in Java, as is true with most three- or greater-dimensional <span class="No-Break">data structures.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Bitsets</h2>
			<p>When we need space-efficient storage for integer or Boolean datasets and also want to ensure their manipulation is <a id="_idIndexMarker137"/>efficient, the <strong class="bold">bitset</strong> data structure is worth considering. Example use cases include algorithms that traverse graphs and mark <span class="No-Break">visited nodes.</span></p>
			<p>Here’s an example of how to implement <span class="No-Break">a </span><span class="No-Break"><a id="_idIndexMarker138"/></span><span class="No-Break">bitset:</span></p>
			<pre class="source-code">
import java.util.BitSet;
BitSet bitSet = new BitSet(10); // Creates a BitSet with 10 bits
bitSet.set(2);
boolean isSet = bitSet.get(2);</pre>			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Ropes</h2>
			<p>Ropes are great for implementing <a id="_idIndexMarker139"/>efficient string handling, especially large strings. They are used for performing concatenation and substring operations. Some example use cases are text editing applications and string <span class="No-Break">manipulation functionality.</span></p>
			<p>Ropes are extremely complex data structures to implement from scratch. Developers often turn to packages and tools that are external to the JDK to <span class="No-Break">do this.</span></p>
			<p>We will cover string manipulation in <a href="B21942_07.xhtml#_idTextAnchor127"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> of <span class="No-Break">this book.</span></p>
			<p>These are just some of the advanced data structures available to us in Java. When incorporating these structures, we must understand how they work, their strengths, and <span class="No-Break">their weaknesses.</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>Summary</h1>
			<p>This chapter took an in-depth look at several data structures and demonstrated their significance to a Java application’s overall performance. We embraced the essential nature of data structures for optimizing the performance of our Java applications because they can ensure that our data access, memory management, and caching are efficient. Proper use of data structures can lead to algorithm efficiency, the scalability of our solutions, and the safety of <span class="No-Break">our threads.</span></p>
			<p>Through code examples, we looked at nonoptimized and optimized examples of code for lists, arrays, trees, stacks, and queues. We also explored several advanced data structures and examined their added complexities. When we implement data structures properly, we can improve the predictability and consistency of our application’s performance and make our code more readable and easier <span class="No-Break">to maintain.</span></p>
			<p>In the next chapter, we will focus on loops and how to optimize them for increased performance regarding our Java applications. This is a natural progression following our coverage of data structures as we will use them in our examples in the <span class="No-Break">next chapter.</span></p>
		</div>
	</body></html>