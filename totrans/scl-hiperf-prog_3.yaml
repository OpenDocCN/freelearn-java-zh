- en: Chapter 3. Unleashing Scala Performance
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章.释放Scala性能
- en: In this chapter, we will look at Scala-specific constructs and language features,
    and examine how they can help or hurt performance. Equipped with our newly-acquired
    performance measurement knowledge, we will analyze how to use the rich language
    features that are provided by the Scala programming language better. For each
    feature, we will introduce it, show you how it compiles to bytecode, and then
    identify caveats and other considerations when using this feature.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨Scala特定的构造和语言特性，并检查它们如何帮助或损害性能。凭借我们新获得的性能测量知识，我们将分析如何更好地使用Scala编程语言提供的丰富语言特性。对于每个特性，我们将介绍它，展示它如何编译成字节码，然后确定在使用此特性时的注意事项和其他考虑因素。
- en: 'Throughout the chapter, we will show the Scala source code and generated bytecode
    that are emitted by the Scala compiler. It is necessary to inspect these artifacts
    to enrich your understanding of how Scala interacts with the JVM so that you can
    develop an intuition for the runtime performance of your software. We will inspect
    the bytecode by invoking the  `javap` Java disassembler after compiling the command,
    as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将展示Scala源代码和由Scala编译器生成的字节码。检查这些工件对于丰富你对Scala如何与JVM交互的理解是必要的，这样你就可以对你的软件的运行时性能有一个直观的认识。我们将在编译命令后通过调用`javap`Java反汇编器来检查字节码，如下所示：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The minus `c` switch prints the disassembled code. Another useful option is `-private`,
    which prints the bytecode of privately defined methods. For more information on `javap`,
    refer to the manual page. The examples that we will cover do not require in-depth
    JVM bytecode knowledge, but if you wish to learn more about bytecode operations,
    refer to Oracle's JVM specification at [http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.4](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.4).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 减号`c`开关打印反汇编的代码。另一个有用的选项是`-private`，它打印私有定义的方法的字节码。有关`javap`的更多信息，请参阅手册页。我们将涵盖的示例不需要深入了解JVM字节码知识，但如果你希望了解更多关于字节码操作的信息，请参阅Oracle的JVM规范[http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.4](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-3.html#jvms-3.4)。
- en: 'Periodically, we will also inspect a version of the Scala source code with
    Scala-specific features removed by running the following command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 定期，我们还将通过运行以下命令来检查移除Scala特定功能的Scala源代码版本：
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is a useful way to see how the Scala compiler desugars convenient syntax
    into constructs that the JVM can execute. In this chapter, we will explore the
    following topics:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种有用的方式，可以了解Scala编译器如何将便捷的语法转换为JVM可以执行的构造。在本章中，我们将探讨以下主题：
- en: Value classes and tagged types
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类和标记类型
- en: Specialization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专业化
- en: Tuples
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组
- en: Pattern matching
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Tail recursion
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尾递归
- en: The `Option` data type
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`数据类型'
- en: An alternative to `Option`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Option`的替代方案'
- en: Value classes
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类
- en: In [Chapter 2](ch02.html "Chapter 2.  Measuring Performance on the JVM"), *Measuring
    Performance on the JVM*, we introduced the domain model of the order book application.
    This domain model included two classes, `Price` and `OrderId`. We pointed out
    that we created domain classes for `Price` and `OrderId` to provide contextual
    meanings to the wrapped `BigDecimal` and `Long`. While providing us with readable
    code and compilation time safety, this practice also increases the number of instances
    that are created by our application. Allocating memory and generating class instances
    create more work for the garbage collector by increasing the frequency of collections
    and by potentially introducing additional long-lived objects. The garbage collector
    will have to work harder to collect them, and this process may severely impact
    our latency.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 在JVM上测量性能")《在JVM上测量性能》中，我们介绍了订单簿应用程序的领域模型。这个领域模型包括两个类，`Price`和`OrderId`。我们指出，我们为`Price`和`OrderId`创建了领域类，以提供对包装的`BigDecimal`和`Long`的上下文意义。虽然这为我们提供了可读的代码和编译时安全性，但这种做法也增加了我们的应用程序创建的实例数量。分配内存和生成类实例通过增加收集频率和可能引入额外的长生命期对象，为垃圾收集器增加了更多的工作。垃圾收集器将不得不更加努力地收集它们，这个过程可能会严重影响我们的延迟。
- en: Luckily, as of Scala 2.10, the `AnyVal` abstract class is available for developers
    to define their own value classes to solve this problem. The `AnyVal` class is
    defined in the Scala doc ([http://www.scala-lang.org/api/current/#scala.AnyVal](http://www.scala-lang.org/api/current/#scala.AnyVal))
    as, "the root class of all value types, which describe values not implemented
    as objects in the underlying host system." The `AnyVal` class can be used to define
    a value class, which receives special treatment from the compiler. Value classes
    are optimized at compile time to avoid the allocation of an instance, and instead
    they use the wrapped type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从Scala 2.10开始，`AnyVal`抽象类可供开发者为解决此问题定义自己的值类。`AnyVal`类在Scala文档中定义（[http://www.scala-lang.org/api/current/#scala.AnyVal](http://www.scala-lang.org/api/current/#scala.AnyVal)）为，“所有值类型的根类，描述了在底层宿主系统中未实现为对象的值。”`AnyVal`类可用于定义值类，该类会接受编译器的特殊处理。值类在编译时优化，以避免分配实例，而是使用包装类型。
- en: Bytecode representation
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码表示
- en: 'As an example, to improve the performance of our order book, we can define
    `Price` and `OrderId` as value classes:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了提高我们的订单簿的性能，我们可以将`Price`和`OrderId`定义为值类：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To illustrate the special treatment of value classes, we define a dummy method taking
    a `Price` value class and an `OrderId` value class as arguments:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明值类的特殊处理，我们定义了一个假方法，该方法接受一个`Price`值类和一个`OrderId`值类作为参数：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From this definition, the compiler produces the following method signature:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个定义中，编译器生成以下方法签名：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We see that the generated signature takes a `BigDecimal` object and a `long`
    object, even though the Scala code allows us to take advantage of the types defined
    in our model. This means that we cannot use an instance of `BigDecimal` or `Long`
    when calling `printInfo` because the compiler will throw an error.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到生成的签名接受一个`BigDecimal`对象和一个`long`对象，尽管Scala代码允许我们利用模型中定义的类型。这意味着我们不能在调用`printInfo`时使用`BigDecimal`或`Long`的实例，因为编译器会抛出一个错误。
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An interesting thing to notice is that the second parameter of `printInfo` is
    not compiled as `Long` (an object), but `long` (a primitive type, note the lower
    case 'l').  `Long` and other objects matching to primitive types, such as `Int`, `Float`
    or `Short`, are specially handled by the compiler to be represented by their primitive
    type at runtime.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的现象是，`printInfo`的第二个参数不是编译为`Long`（一个对象），而是`long`（一个原始类型，注意小写的'l`）。`Long`和其他与原始类型匹配的对象，如`Int`、`Float`或`Short`，会被编译器特别处理，在运行时以它们的原始类型表示。
- en: 'Value classes can also define methods. Let''s enrich our `Price` class, as
    follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 值类也可以定义方法。让我们丰富我们的`Price`类，如下所示：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Our new method allows us to compare two instances of `Price`. At compile time,
    a companion object is created for `Price`. This companion object defines a `lowerThan`
    method that takes two `BigDecimal` objects as parameters. In reality, when we
    call `lowerThan` on an instance of `Price`, the code is transformed by the compiler
    from an instance method call to a static method call that is defined in the companion
    object:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新方法使我们能够比较两个`Price`实例。在编译时，为`Price`创建了一个伴随对象。这个伴随对象定义了一个`lowerThan`方法，该方法接受两个`BigDecimal`对象作为参数。实际上，当我们对一个`Price`实例调用`lowerThan`时，代码被编译器从实例方法调用转换为在伴随对象中定义的静态方法调用：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we were to write the pseudo-code equivalent to the preceding Scala code,
    it would look something like the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的Scala代码写成伪代码，它看起来可能如下所示：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Performance considerations
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: 'Value classes are a great addition to our developer toolbox. They help us reduce
    the count of instances and spare some work for the garbage collector, while allowing
    us to rely on meaningful types that reflect our business abstractions. However,
    extending `AnyVal` comes with a certain set of conditions that the class must
    fulfill. For example, a value class may only have one primary constructor that
    takes one public `val` as a single parameter. Furthermore, this parameter cannot
    be a value class. We saw that value classes can define methods via `def`. Neither `val`
    nor `var` is allowed inside a value class. A nested class or object definitions
    are also impossible. Another limitation prevents value classes from extending
    anything other than a universal trait, that is, a trait that extends `Any`, only
    has `defs` as members, and performs no initialization. If any of these conditions
    are not fulfilled, the compiler generates an error. In addition to the preceding
    constraints that are listed, there are special cases in which a value class has
    to be instantiated by the JVM. Such cases include performing a pattern matching
    or runtime type test, or assigning a value class to an array. An example of the
    latter looks like the following snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 值类是我们开发者工具箱中的一个很好的补充。它们帮助我们减少实例数量，并为垃圾收集器节省一些工作，同时允许我们依赖有意义的类型，这些类型反映了我们的业务抽象。然而，扩展
    `AnyVal` 需要满足一系列条件，这些条件类必须满足。例如，值类可能只有一个主构造函数，该构造函数接受一个公共 `val` 作为单个参数。此外，此参数不能是值类。我们看到了值类可以通过
    `def` 定义方法。值类内部不允许使用 `val` 或 `var`。嵌套类或对象定义也是不可能的。另一个限制条件阻止值类扩展任何不是通用特质的类型，即扩展
    `Any` 的特质，只有 `defs` 作为成员，并且不执行初始化。如果这些条件中的任何一个没有得到满足，编译器将生成错误。除了前面列出的限制条件之外，还有一些特殊情况，其中值类必须由
    JVM 实例化。这些情况包括执行模式匹配或运行时类型测试，或将值类赋值给数组。后者的一个例子如下所示：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The generated bytecode is as follows:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的字节码如下：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice how `mcVI$sp` is invoked from `newPriceArray`, and this creates a new
    instance of `ValueClasses$Price` at the `5` instruction.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `mcVI$sp` 是如何从 `newPriceArray` 中调用的，并在第 `5` 条指令处创建了一个新的 `ValueClasses$Price`
    实例。
- en: As turning a single field case class into a value class is as trivial as extending
    the `AnyVal` trait, we recommend that you always use `AnyVal` wherever possible.
    The overhead is quite low, and it generate high benefits in terms of garbage collection's
    performance. To learn more about value classes, their limitations, and use cases,
    you can find detailed descriptions at [http://docs.scala-lang.org/overviews/core/value-classes.html](http://docs.scala-lang.org/overviews/core/value-classes.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将单个字段案例类转换为值类与扩展 `AnyVal` 特质一样简单，我们建议您尽可能使用 `AnyVal`。开销相当低，并且它在垃圾收集性能方面带来了高收益。要了解更多关于值类、它们的限制和使用案例，您可以在[http://docs.scala-lang.org/overviews/core/value-classes.html](http://docs.scala-lang.org/overviews/core/value-classes.html)找到详细的描述。
- en: Tagged types - an alternative to value classes
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签类型 - 值类的替代方案
- en: Value classes are an easy to use tool, and they can yield great improvements
    in terms of performance. However, they come with a constraining set of conditions,
    which can make them impossible to use in certain cases. We will conclude this
    section with a glance at an interesting alternative by leveraging the tagged type
    feature that is implemented by the `Scalaz` library ([https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 值类是一个易于使用的工具，并且它们可以在性能方面带来显著的提升。然而，它们附带一系列限制条件，这可能会在某些情况下使它们无法使用。我们将通过查看 `Scalaz`
    库实现的标签类型功能来结束本节，该功能提供了一个有趣的替代方案（[https://github.com/scalaz/scalaz](https://github.com/scalaz/scalaz)）。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Scalaz` implementation of tagged types is inspired by another Scala library,
    named `shapeless`. The `shapeless` library provides tools to write type-safe,
    generic code with minimal boilerplate. While we will not explore `shapeless`,
    we encourage you to learn more about the project at [https://github.com/milessabin/shapeless](https://github.com/milessabin/shapeless).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scalaz` 对标签类型的实现受到了另一个 Scala 库的启发，该库名为 `shapeless`。`shapeless` 库提供了编写类型安全、泛型代码的工具，且具有最少的样板代码。虽然我们不会深入探讨
    `shapeless`，但我们鼓励您了解更多关于这个项目的信息，请访问[https://github.com/milessabin/shapeless](https://github.com/milessabin/shapeless)。'
- en: 'Tagged types are another way to enforce compile-type checking without incurring
    the cost of instance instantiation. They rely on the `Tagged` structural type
    and the `@@` type alias that are defined in the `Scalaz` library, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 标记类型是强制编译时类型检查而不产生实例实例化成本的另一种方式。它们依赖于在`Scalaz`库中定义的`Tagged`结构类型和`@@`类型别名，如下所示：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s rewrite part of our code to leverage tagged types with our `Price` object:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写我们代码的一部分，以利用`Price`对象进行标记类型：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let's perform a short walkthrough of the code snippet. We will define a `PriceTag`
    sealed trait that we will use to tag our instances, a `Price` type alias is created
    and defined as a `BigDecimal` object tagged with `PriceTag`. The `Price` object
    defines useful methods, including the `newPrice` factory function that is used
    to tag a given `BigDecimal` object and return a `Price` object (that is, a tagged `BigDecimal `object).
    We will also implement an equivalent to the `lowerThan` method. This function
    takes two `Price` objects (that is, two tagged `BigDecimal` objects), extracts
    the content of the tags that are two `BigDecimal` objects, and compares them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地浏览一下代码片段。我们将定义一个`PriceTag`密封特质，我们将用它来标记我们的实例，创建并定义一个`Price`类型别名，它是一个标记为`PriceTag`的`BigDecimal`对象。`Price`对象定义了有用的方法，包括用于标记给定的`BigDecimal`对象并返回一个`Price`对象（即标记的`BigDecimal`对象）的`newPrice`工厂函数。我们还将实现一个与`lowerThan`方法等效的函数。这个函数接受两个`Price`对象（即两个标记的`BigDecimal`对象），提取两个`BigDecimal`对象标签的内容，并比较它们。
- en: 'Using our new `Price` type, we rewrite the same `newPriceArray` method that
    we previously looked at (the code is omitted for brevity, but you can refer to
    it in the attached source code), and print the following generated bytecode:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新的`Price`类型，我们重写了之前查看过的相同`newPriceArray`方法（为了简洁，代码被省略，但你可以参考附带的源代码），并打印以下生成的字节码：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this version, we no longer see an instantiation of `Price`, even though
    we are assigning it to an array. The tagged `Price` implementation involves a
    runtime cast, but we anticipate that the cost of this cast will be less than the
    instance allocations (and garbage collection) observed in the previous value class `Price` strategy.
    We will look  at tagged types again later in this chapter, and use them to replace
    a well-known tool of the standard library: the `Option`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个版本中，我们不再看到`Price`的实例化，尽管我们将其分配给一个数组。标记的`Price`实现涉及到运行时转换，但我们预计这个转换的成本将低于之前值类`Price`策略中观察到的实例分配（以及垃圾收集）。我们将在本章后面再次查看标记类型，并使用它们来替换标准库中的一个知名工具：`Option`。
- en: Specialization
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专业化
- en: 'To understand the significance of specialization, it is important to first
    grasp the concept of object boxing. The JVM defines primitive types (`boolean`,
    `byte`, `char`, `float`, `int`, `long`, `short`, and `double`) that are stack-allocated
    rather than heap-allocated. When a generic type is introduced, for example, `scala.collection.immutable.List`,
    the JVM references an object equivalent, instead of a primitive type. In this
    example, an instantiated list of integers would be heap-allocated objects rather
    than integer primitives. The process of converting a primitive to its object equivalent
    is called boxing, and the reverse process is called unboxing. Boxing is a relevant
    concern for performance-sensitive programming because boxing involves heap allocation.
    In performance-sensitive code that performs numerical computations, the cost of
    boxing and unboxing can can create significant performance slowdowns. Consider
    the following example to illustrate boxing overhead:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解专业化的重要性，首先掌握对象装箱的概念是至关重要的。JVM定义了原始类型（`boolean`、`byte`、`char`、`float`、`int`、`long`、`short`和`double`），这些类型是在栈上分配而不是在堆上分配的。当引入泛型类型时，例如`scala.collection.immutable.List`，JVM引用的是对象等价物，而不是原始类型。在这个例子中，一个整数列表的实例化将是堆分配的对象，而不是整数原语。将原始类型转换为对象等价物的过程称为装箱，而相反的过程称为拆箱。装箱对于性能敏感的编程来说是一个相关的问题，因为装箱涉及到堆分配。在执行数值计算的性能敏感代码中，装箱和拆箱的成本可能会造成显著的性能下降。以下是一个示例，用于说明装箱的开销：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Creating the list via `fill` yields 10,000 heap allocations of the integer object.
    Performing the multiplication in `map` requires 10,000 unboxings to perform multiplication
    and then 10,000 boxings to add the multiplication result into the new list. From
    this simple example, you can imagine how critical section arithmetic will be slowed
    down due to boxing or unboxing operations.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`fill`创建列表会产生10,000个整数对象的堆分配。在`map`中进行乘法操作需要10,000次拆箱以执行乘法，然后需要10,000次装箱将乘法结果添加到新列表中。从这个简单的例子中，你可以想象到由于装箱或拆箱操作，临界区算术将如何被减慢。
- en: As shown in Oracle's tutorial on boxing at [https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html),
    boxing in Java and also in Scala happens transparently. This means that, without
    careful profiling or bytecode analysis, it is difficult to discern where you are
    paying the cost for object boxing. To ameliorate this problem, Scala provides
    a feature named specialization. Specialization refers to the compile-time process
    of generating duplicate versions of a generic trait or class that refer directly
    to a primitive type instead of the associated object wrapper. At runtime, the
    compiler-generated version of the generic class (or, as it is commonly referred
    to, the specialized version of the class) is instantiated. This process eliminates
    the runtime cost of boxing primitives, which means that you can define generic
    abstractions while retaining the performance of a handwritten, specialized implementation.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如Oracle在[https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html](https://docs.oracle.com/javase/tutorial/java/data/autoboxing.html)教程中所示，Java和Scala中的装箱是透明的。这意味着，如果没有仔细的剖析或字节码分析，很难确定你在哪里支付了对象装箱的成本。为了改善这个问题，Scala提供了一个名为特殊化的功能。专业化指的是在编译时生成泛型特质的或类的重复版本，这些版本直接引用原始类型而不是相关的对象包装器。在运行时，编译器生成的泛型类（或通常称为类的专业化版本）被实例化。这个过程消除了装箱原始类型的运行时成本，这意味着你可以在保持手写专业化实现性能的同时定义泛型抽象。
- en: Bytecode representation
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码表示
- en: 'Let''s look at a concrete example to better understand how the specialization
    process works. Consider a naive, generic representation of the number of shares
    purchased, as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个具体的例子来更好地理解专业化过程是如何工作的。考虑一个关于购买股票数量的简单、通用的表示，如下所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'For this example, let''s assume that the intended usage is to swap between
    an integer or long representation of `ShareCount`. With this definition, instantiating
    a long-based `ShareCount` instance incurs the cost of boxing, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，让我们假设预期的用法是在`ShareCount`的整数或long表示之间进行交换。根据这个定义，基于long的`ShareCount`实例化将产生装箱的成本，如下所示：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This definition translates to the following bytecode:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义转换成以下字节码：
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the preceding bytecode, it is clear at instruction `5` that the primitive
    long value is boxed before instantiating the `ShareCount` instance. By introducing
    the `@specialized` annotation, we are able to eliminate the boxing by having the
    compiler provide an implementation of `ShareCount` that works with primitive long
    values. It is possible to specify which types you wish to specialize by supplying
    a set of types. As defined in the `Specializables` trait ([http://www.scala-lang.org/api/current/index.html#scala.Specializable"](http://www.scala-lang.org/api/current/index.html#scala.Specializable)),
    you are able to specialize for all JVM primitives, as well as, `Unit` and `AnyRef`.
    For our example, let''s specialize `ShareCount` for integers and longs, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的字节码中，在指令`5`处很明显，在实例化`ShareCount`实例之前，原始的long值被装箱了。通过引入`@specialized`注解，我们能够通过让编译器提供一个与原始long值一起工作的`ShareCount`实现来消除装箱。你可以通过提供一组类型来指定你希望专业化的类型。如`Specializables`特质([http://www.scala-lang.org/api/current/index.html#scala.Specializable](http://www.scala-lang.org/api/current/index.html#scala.Specializable))定义的，你可以为所有JVM原始类型、`Unit`和`AnyRef`进行专业化。对于我们的例子，让我们将`ShareCount`专业化为整数和long，如下所示：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With this definition, the bytecode now becomes the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个定义，字节码现在变成以下形式：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The boxing disappears and is curiously replaced with a different class name,
    `ShareCount $mcJ$sp`. This is because we are invoking the compiler-generated version
    of `ShareCount` that is specialized for long values. By inspecting the output
    of `javap`, we see that the specialized class generated by the compiler is a subclass
    of `ShareCount`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 装箱消失了，奇怪地被不同的类名`ShareCount $mcJ$sp`所取代。这是因为我们正在调用为长值特殊化的编译器生成的`ShareCount`版本。通过检查`javap`的输出，我们看到编译器生成的特殊化类是`ShareCount`的子类：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Bear this specialization implementation detail in mind as we turn to the *Performance
    considerations* section. The use of inheritance forces tradeoffs to be made in
    more complex use cases.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向*性能考虑*部分时，请记住这个特殊化实现细节。使用继承在更复杂的使用案例中会迫使做出权衡。
- en: Performance considerations
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: 'At first glance, specialization appears to be a simple panacea for JVM boxing.
    However, there are several caveats to consider when using specialization. A liberal
    use of specialization leads to significant increases in compile time and resulting
    code size. Consider specializing `Function3`, which accepts three arguments as
    input and produces one result. To specialize four arguments across all types (that
    is, `Byte`, `Short`, `Int`, `Long`, `Char`, `Float`, `Double`, `Boolean`, `Unit`,
    and `AnyRef`) yields 10^4 or 10,000 possible permutations. For this reason, the
    standard library conserves the application of specialization. In your own use
    cases, consider carefully which types you wish to specialize. If we specialize `Function3` only
    for `Int` and `Long`, the number of generated classes shrinks to 2^4 or 16\. Specialization
    involving inheritance requires extra attention because it is trivial to lose specialization
    when extending a generic class. Consider the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 初看起来，特殊化似乎是JVM装箱问题的简单万能药。然而，在使用特殊化时需要考虑几个注意事项。大量使用特殊化会导致编译时间显著增加和代码大小的增加。考虑对`Function3`进行特殊化，它接受三个参数作为输入并产生一个结果。对所有类型（即`Byte`、`Short`、`Int`、`Long`、`Char`、`Float`、`Double`、`Boolean`、`Unit`和`AnyRef`）进行四个参数的特殊化会产生10^4或10,000种可能的排列组合。因此，标准库在应用特殊化时非常谨慎。在你的使用案例中，仔细考虑你希望特殊化的类型。如果我们只为`Int`和`Long`对`Function3`进行特殊化，生成的类数量将减少到2^4或16。涉及继承的特殊化需要特别注意，因为在扩展泛型类时很容易丢失特殊化。考虑以下示例：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this scenario, you likely expect that `ChildFoo` is defined with a primitive
    integer. However, as `ChildFoo` does not mark its type with the `@specialized`
    annotation, zero specialized classes are created. Here is the bytecode to prove
    it:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，你可能会期望`ChildFoo`是用原始整数定义的。然而，由于`ChildFoo`没有用`@specialized`注解标记其类型，因此没有创建任何特殊化的类。以下是证明这一点的字节码：
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The next logical step is to add the `@specialized` annotation to the definition
    of `ChildFoo`. In doing so, we stumble across a scenario where the compiler warns
    about the use of specialization, as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个逻辑步骤是将`@specialized`注解添加到`ChildFoo`的定义中。在这个过程中，我们会遇到编译器警告关于特殊化的使用，如下所示：
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The compiler indicates that you have created a diamond inheritance problem,
    where the specialized versions of `ChildFoo` extend both `ChildFoo` and the associated
    specialized version of `ParentFoo`. This issue can be resolved by modeling the
    problem with a trait, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器指出，你创建了一个菱形继承问题，其中特殊化的`ChildFoo`版本同时扩展了`ChildFoo`及其关联的特殊化版本`ParentFoo`。这个问题可以通过以下方式使用特质来建模：
- en: '[PRE23]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This definition compiles using a specialized version of `ChildBar`, as we originally
    were hoping for, as seen in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义使用特殊化的`ChildBar`版本编译，正如我们最初所希望的，如下所示：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'An analogous and equally error-prone scenario is when a generic method is defined
    around a specialized type. Consider the following definition:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 类似且同样容易出错的场景是当在特殊化类型周围定义泛型方法时。考虑以下定义：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, the definition of `create` is analogous to the child class from the inheritance
    example. Instances of `Foo` wrapping a primitive that are instantiated from the `create`
    method will be boxed. The following bytecode demonstrates how `boxed` leads to
    heap allocations:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`create`的定义与继承示例中的子类类似。从`create`方法实例化的包含原始值的`Foo`实例将被装箱。以下字节码演示了`boxed`如何导致堆分配：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The solution is to apply the `@specialized` annotation at the call site, as
    follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是在调用点应用`@specialized`注解，如下所示：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'One final interesting scenario is when specialization is used with multiple
    types and one of the types extends `AnyRef` or is a value class. To illustrate
    this scenario, consider the following example:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个有趣的场景是当使用多个类型进行特殊化，其中一个类型扩展 `AnyRef` 或是值类时。为了说明这个场景，考虑以下示例：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this example, which methods do you expect to box the second argument to `Container2`?
    For brevity, we omit the bytecode, but you can easily inspect it yourself. As
    it turns out, `shareCount` and `executionCount` box the integer. The compiler
    does not generate a specialized version of `Container2` that accepts a primitive
    integer and a value extending `AnyVal` (for example, `ExecutionCount`). The `shareCount` method also
    causes boxing due to the order in which the compiler removes the value class type
    information from the source code. In both scenarios, the workaround is to define
    a case class that is specific to a set of types (for example, `ShareCount` and `Int`).
    Removing the generics allows the compiler to select the primitive types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，您期望使用哪些方法将 `Container2` 的第二个参数装箱？为了简洁，我们省略了字节码，但您可以轻松地自行检查。结果发现，`shareCount`
    和 `executionCount` 会将整数装箱。编译器不会为 `Container2` 生成一个接受原始整数和扩展 `AnyVal`（例如，`ExecutionCount`）的值的专用版本。`shareCount`
    方法也由于编译器从源代码中移除值类类型信息的顺序而导致装箱。在这两种情况下，解决方案是定义一个特定于一组类型的案例类（例如，`ShareCount` 和 `Int`）。移除泛型允许编译器选择原始类型。
- en: The conclusion to draw from these examples is that specialization requires extra
    focus to be used throughout an application without boxing. As the compiler is
    unable to infer scenarios where you accidentally forgot to apply the `@specialized`
    annotation, it fails to raise a warning. This places the onus on you to be vigilant
    about profiling and inspecting bytecode to detect scenarios where specialization
    is incidentally dropped.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 从这些例子中可以得出的结论是，为了在整个应用程序中避免装箱，特殊化需要额外的关注。由于编译器无法推断出您意外忘记应用 `@specialized` 注解的场景，它无法发出警告。这使您必须对性能分析和检查字节码保持警惕，以检测特殊化意外丢失的场景。
- en: Note
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To combat some of the shortcomings that specialization brings, there is a compiler
    plugin under active development, named miniboxing, at [http://scala-miniboxing.org/](http://scala-miniboxing.org/).
    This compiler plugin applies a different strategy that involves encoding all primitive
    types into a long value and carrying metadata to recall the original type. For
    example, `boolean` can be represented in a `long` using a single bit to signal
    true or false. With this approach, performance is qualitatively similar to specialization
    while producing orders of magnitude fewer classes for large permutations. Additionally,
    miniboxing is able to more robustly handle inheritance scenarios and can warn
    when boxing will occur. While the implementations of specialization and miniboxing
    differ, the end user usage is quite similar. Like specialization, you must add
    appropriate annotations to activate the miniboxing plugin. To learn more about
    the plugin, you can view the tutorials on the miniboxing project site.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服特殊化带来的某些缺点，正在积极开发一个名为 miniboxing 的编译器插件，可以在 [http://scala-miniboxing.org/](http://scala-miniboxing.org/)
    上找到。这个编译器插件采用了一种不同的策略，涉及将所有原始类型编码为一个长值，并携带元数据以回忆原始类型。例如，`boolean` 可以使用一个位来表示真或假，在
    `long` 中表示。这种方法下，性能在定性上与特殊化相似，但为大量排列产生了数量级的更少类。此外，miniboxing 能够更稳健地处理继承场景，并在装箱将要发生时发出警告。虽然特殊化和
    miniboxing 的实现不同，但最终用户的使用方式相当相似。像特殊化一样，您必须添加适当的注解来激活 miniboxing 插件。要了解更多关于插件的信息，您可以查看
    miniboxing 项目网站上的教程。
- en: 'The extra focus to ensure specialization produces heap allocation free code
    is worthwhile because of the performance wins in performance-sensitive code. To
    drive home the value of specialization, consider the following microbenchmark
    that computes the cost of a trade by multiplying share count with execution price.
    For simplicity, primitive types are used directly instead of value classes. Of
    course, in production code this would never happen:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保特殊化生成无堆分配代码的额外关注是值得的，因为在性能敏感的代码中，它带来了性能上的优势。为了强调特殊化的价值，考虑以下微基准测试，该测试通过将份额计数与执行价格相乘来计算贸易的成本。为了简单起见，直接使用原始类型而不是值类。当然，在生产代码中这种情况永远不会发生：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this benchmark, two versions of a generic execution class are defined. `SpecializedExecution`
    incurs zero boxing when computing the total cost because of specialization, while `BoxingExecution`
    requires object boxing and unboxing to perform the arithmetic. The microbenchmark
    is invoked with the following parameterization:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基准测试中，定义了通用执行类的两个版本。`SpecializedExecution` 由于专业化而无需装箱即可计算总成本，而 `BoxingExecution`
    需要对象装箱和拆箱来执行算术。微基准测试使用以下参数化调用：
- en: '[PRE30]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We configure this JMH benchmark via annotations that are placed at the class
    level in the code. This is different from what we saw in [Chapter 2](ch02.html
    "Chapter 2.  Measuring Performance on the JVM"), *Measuring Performance on the
    JVM,* where we used command-line arguments. Annotations have the advantage of
    setting proper defaults for your benchmark, and simplifying the command-line invocation.
    It is still possible to override the values in the annotation with command-line
    arguments. We use the  `-foe` command-line argument to enable failure on error
    because there is no annotation to control this behavior. In the rest of this book,
    we will parameterize JMH with annotations and omit the annotations in the code
    samples because we always use the same values.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在代码中类级别放置的注解来配置这个 JMH 基准测试。这与我们在 [第 2 章](ch02.html "第 2 章。在 JVM 上测量性能")
    中看到的不同，*在 JVM 上测量性能*，在那里我们使用了命令行参数。注解的优势在于为你的基准测试设置适当的默认值，并简化命令行调用。仍然可以通过命令行参数覆盖注解中的值。我们使用
    `-foe` 命令行参数来启用错误时的失败，因为没有注解可以控制这种行为。在这本书的其余部分，我们将使用注解参数化 JMH，并在代码示例中省略注解，因为我们总是使用相同的值。
- en: 'The results are summarized in the following table:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 结果总结如下表：
- en: '| **Benchmark** | **Throughput (ops per second)** | **Error as percentage of
    throughput** |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **吞吐量（每秒操作数）** | **错误作为吞吐量的百分比** |'
- en: '| --- | --- | --- |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `boxed` | 251,534,293.11 | ±2.23 |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `boxed` | 251,534,293.11 | ±2.23 |'
- en: '| `specialized` | 302,371,879.84 | ±0.87 |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `specialized` | 302,371,879.84 | ±0.87 |'
- en: This microbenchmark indicates that the specialized implementation yields approximately
    17% higher throughput. By eliminating boxing in a critical section of the code,
    there is an order of magnitude performance improvement available through the judicious
    usage of specialization. For performance-sensitive arithmetic, this benchmark
    provides justification for the extra effort that is required to ensure that specialization
    is applied properly.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个微基准测试表明专业化实现提供了大约 17% 的更高吞吐量。通过在代码的关键部分消除装箱，可以通过谨慎地使用专业化获得一个数量级的性能提升。对于性能敏感的算术，这个基准测试为确保专业化正确应用所需的额外努力提供了依据。
- en: Tuples
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: First-class tuple support in Scala simplifies use cases where multiple values
    need to be grouped together. With tuples, you can elegantly return multiple values
    using a concise syntax without defining a case class. The following section shows
    how the compiler translates Scala tuples.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Scala 中的第一类元组支持简化了需要将多个值组合在一起的使用场景。使用元组，你可以使用简洁的语法优雅地返回多个值，而无需定义案例类。以下部分展示了编译器如何转换
    Scala 元组。
- en: Bytecode representation
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码表示
- en: 'Let''s look at how the JVM handles creating a tuple to understand how the JVM
    supports tuples better. To develop our intuition, consider creating a tuple with
    an arity of two, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 JVM 如何处理创建元组，以更好地理解 JVM 如何支持元组。为了培养我们的直觉，考虑创建一个长度为二的元组，如下所示：
- en: '[PRE31]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The corresponding bytecode for this method is as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法的对应字节码如下：
- en: '[PRE32]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This bytecode shows that the compiler desugared the parenthesis tuple definition
    syntax into the allocation of a class named `Tuple2`. There is a tuple class that
    is defined for each supported arity (for example, `Tuple5` supports five members)
    up to `Tuple22`. The bytecode also shows at the  `4` and `5` instructions that
    the primitive versions of `Int` and `Double` are used to allocate this `tuple`
    instance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字节码显示编译器将括号元组定义语法反编译为名为 `Tuple2` 的类的分配。为每个支持的元组长度（例如，`Tuple5` 支持五个成员）定义了一个元组类，直到
    `Tuple22`。字节码还显示在第 `4` 和 `5` 条指令中使用了 `Int` 和 `Double` 的原始版本来分配这个 `tuple` 实例。
- en: Performance considerations
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: 'In the preceding example, `Tuple2` avoids the boxing of primitives due to specialization
    on the two generic types. It is often convenient to tuple multiple values together
    because of Scala''s expressive tupling syntax. However, this leads to excessive
    memory allocation because tuples with an arity larger than two are not specialized.
    Here is an example to illustrate this concern:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`Tuple2` 由于对两个泛型类型的特殊化处理，避免了原始数据类型的装箱。由于 Scala 的表达式元组语法，将多个值组合在一起通常很方便。然而，这会导致过度的内存分配，因为大于两个参数的元组没有进行特殊化。以下是一个说明这一问题的示例：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This definition is analogous to the first tuple definition that we reviewed,
    except that there is now an arity of three. This definition produces the following
    bytecode:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义与我们所审查的第一个元组定义类似，但现在有一个三个参数的参数数量。这个定义产生了以下字节码：
- en: '[PRE34]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this bytecode, the absence of specialization is clear because of the presence
    of integer and double boxing. If you are working on a performance-sensitive region
    of your application and find occurrences of tuples with an arity of three or larger,
    you should consider defining a case class to avoid the boxing overhead. The definition
    of your case class will not have any generics. This enables the JVM to use primitives
    instead of allocating objects on the heap for the primitive tuple members.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个字节码中，由于整数和双精度浮点数的装箱存在，可以清楚地看到没有特殊化。如果你正在处理应用程序中性能敏感的区域，并且发现存在三个或更多参数的元组，你应该考虑定义一个案例类以避免装箱开销。你的案例类的定义将不包含任何泛型。这使得
    JVM 能够使用原始数据类型而不是在堆上为原始元组成员分配对象。
- en: 'Even when using `Tuple2`, it is still possible that you are incurring the cost
    of boxing. Consider the following snippet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 即使使用 `Tuple2`，仍然可能你正在承担装箱的成本。考虑以下代码片段：
- en: '[PRE35]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Given what we know about the bytecode representation of Tuple2 and value classes,
    we expect the bytecode for this method to be two stack-allocated integers. Unfortunately,
    in this case, the resulting bytecode is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们对 Tuple2 和值类字节码表示的了解，我们预计这个方法的字节码应该是两个栈分配的整数。不幸的是，在这种情况下，生成的字节码如下：
- en: '[PRE36]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the preceding bytecode, we see that the integer is boxed and an instance
    of Bar is instantiated. This example is analogous to the final specialization
    example that we investigated involving `Container2`. Looking back at that example,
    it should be evident that `Container2` is a close analog to Tuple2\. As before,
    due to how specialization is implemented by the compiler, the compiler is unable
    to avoid boxing in this scenario. If you are faced with performance-sensitive
    code, the workaround remains defining a case class. Here is proof that defining
    a case class erases the undesired value class instantiation and primitive boxing:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的字节码中，我们看到整数被装箱，并且实例化了 Bar。这个例子与我们在 `Container2` 中调查的最终特殊化示例类似。回顾那个例子，应该很明显，`Container2`
    是 `Tuple2` 的一个紧密的类似物。与之前一样，由于编译器实现特殊化的方式，编译器无法避免在这个场景中的装箱。如果你面临性能敏感的代码，解决方案仍然是定义一个案例类。以下是一个证明定义案例类可以消除不希望的值类实例化和原始数据装箱的例子：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This definition produces the following bytecode:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义产生了以下字节码：
- en: '[PRE38]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that `IntBar` is not defined as a value class because it has two parameters.
    In contrast to the tuple definition, there is neither boxing nor any reference
    to the `Bar` value class. In this scenario, defining a case class is a performance
    win for performance-sensitive code.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`IntBar` 不是一个值类，因为它有两个参数。与元组定义不同，这里既没有装箱也没有对 `Bar` 值类的引用。在这种情况下，定义一个案例类对于性能敏感的代码来说是一个性能上的胜利。
- en: Pattern matching
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: For programmers who are new to Scala, pattern matching is often one of the language
    features that is the simplest to understand, but it also unlocks new ways to think
    about writing software. This powerful mechanism enables you to match on disparate
    types with compile-time safety using an elegant syntax. Given how central this
    technique is to writing Scala in the functional paradigm, it is important to consider
    its runtime overhead.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Scala 新手程序员来说，模式匹配通常是语言特性中最容易理解的之一，但它也开启了以新的方式思考编写软件的方法。这个强大的机制允许你使用优雅的语法在编译时安全地对不同类型进行匹配。鉴于这种技术对于函数式编程范式中的
    Scala 编写至关重要，考虑其运行时开销是很重要的。
- en: Bytecode representation
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码表示
- en: 'Let''s consider an example that involves order processing with an algebraic
    data type representing the possible sides of an order:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个涉及使用表示订单可能方向的代数数据类型进行订单处理的示例：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The terminology **algebraic data type** (**ADT**) is a more formal way of referring
    to a sealed trait and its cases. For example, `Side`, `Buy`, and `Sell` form an
    ADT. For our purposes, an ADT defines a closed set of cases. For `Side`, the enclosed
    cases are `Buy` and `Sell`. The sealed modifier provides closed set semantics
    because it disallows the extension of `Side` in separate source files. The closed
    set semantics implied by an ADT is what allows the compiler to infer whether or
    not a pattern match statement is exhaustive. If you are interested in studying
    another example of an ADT, view the order book commands defined in [Chapter](ch02.html
    "Chapter 2.  Measuring Performance on the JVM") [2](ch02.html "Chapter 2.  Measuring
    Performance on the JVM"), *Measuring Performance on the JVM*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**代数数据类型**（**ADT**）是更正式地指代一个密封特性和其情况的方式。例如，`Side`、`Buy`和`Sell`形成一个ADT。就我们的目的而言，一个ADT定义了一个封闭的情况集。对于`Side`，封装的情况是`Buy`和`Sell`。密封修饰符提供了封闭集语义，因为它禁止在单独的源文件中扩展`Side`。ADT隐含的封闭集语义是允许编译器推断模式匹配语句是否完备的原因。如果您想研究ADT的另一个示例，请查看[第2章](ch02.html
    "第2章 测量JVM上的性能")中定义的订单簿命令，*测量JVM上的性能*。
- en: 'As shown in the following bytecode, pattern matching is desugared into a set
    of if statements:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下字节码所示，模式匹配被转换为一系列if语句：
- en: '[PRE40]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Inspecting the bytecode shows how the Scala compiler is able to desugar pattern
    match expressions into a set of efficient if statements with the `ifeq` instructions
    at the `9` and `24` indexes. This an illustrative example of how Scala is able
    to provide expressive and elegant first-class language features that retain efficient
    bytecode equivalents.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 检查字节码可以展示Scala编译器如何将模式匹配表达式转换为一系列高效的if语句，其中包含`ifeq`指令，位于`9`和`24`索引处。这是一个说明Scala如何提供表达性和优雅的一等语言特性，同时保留高效字节码等价的示例。
- en: Performance considerations
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: 'Pattern matching against values that contain state (for example, a case class)
    imposes additional runtime costs that are not immediately clear when looking at
    the Scala source code. Consider the following extension to the previous example
    that introduces state:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对包含状态（例如，一个case类）的值进行模式匹配会带来额外的运行时成本，这在查看Scala源代码时并不立即明显。考虑以下对先前示例的扩展，它引入了状态：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here, the example is more complicated because the instance type must be identified
    for all three cases with the added complexity of a predicate on the `BuyOrder`
    price in the first case. In the following, we look at a snippet of the `scalac`
    output with all Scala-specific features removed:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，示例更加复杂，因为必须为所有三个情况识别实例类型，并在第一种情况中增加了对`BuyOrder`价格的谓词复杂性。在下面，我们将查看移除了所有Scala特定特征的`scalac`输出片段：
- en: '[PRE42]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This desugaring illustrates several interesting points about the Scala compiler.
    Identifying the type of `Order` utilizes `isInstanceOf` from `java.lang.Object`,
    which maps to the `instanceOf` bytecode instruction. Casting, by way of `asInstanceOf`,
    coerces the `Order` into either a `BuyOrder` price or a `SellOrder`.  The first
    takeaway is that pattern matching types carrying state incurs the runtime cost
    of type-checking and casting.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这种转换说明了关于Scala编译器的几个有趣点。识别`Order`的类型利用了`java.lang.Object`中的`isInstanceOf`，它映射到`instanceOf`字节码指令。通过`asInstanceOf`进行类型转换将`Order`强制转换为`BuyOrder`价格或`SellOrder`。第一个启示是，携带状态的模式匹配类型会带来类型检查和转换的运行时成本。
- en: A second insight is that the Scala compiler is able to optimize away the instance
    checking for the second pattern match by creating a Boolean variable named `rc8`
    to determine whether a `BuyOrder` was discovered. This neat optimization is simple
    to handwrite, but it removes the elegance and simplicity of pattern matching.
    This is another example of how the compiler is able to produce efficient bytecode
    from expressive, high-level code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个洞察是，Scala编译器能够通过创建一个名为`rc8`的布尔变量来优化第二个模式匹配的实例检查，以确定是否发现了`BuyOrder`。这种巧妙的优化简单易写，但它去除了模式匹配的优雅和简单性。这是编译器能够从表达性、高级代码中产生高效字节码的另一个示例。
- en: 'From the preceding examples, it is now clear that pattern matches are compiled
    to if statements. One performance consideration for critical path code is the
    ordering of pattern match statements. If your code has five pattern match statements
    and the fifth pattern is the most frequently accessed, then your code is paying
    the price of always evaluating four other branches. Let''s devise a JMH microbenchmark
    that estimates the linear access cost of pattern matching. Each benchmark defines
    ten pattern matches using different values (for example, the value class, the
    integer literal, the case class, and so on). For each benchmark, the matched index
    is swept to show the cost of accessing the first, the fifth, and the the tenth
    pattern match statement. Here is the benchmark definition:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的例子中，现在可以清楚地看出模式匹配被编译成if语句。对于关键路径代码的一个性能考虑是模式匹配语句的顺序。如果你的代码有五个模式匹配语句，并且第五个模式是最频繁访问的，那么你的代码正在为始终评估其他四个分支付出代价。让我们设计一个JMH微基准测试来估计模式匹配的线性访问成本。每个基准定义了十个使用不同值（例如，值类、整数字面量、case类等）的模式匹配。对于每个基准，匹配的索引被遍历以显示访问第一个、第五个和第十个模式匹配语句的成本。以下是基准定义：
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Performance was evaluated by running 30 trials, each lasting 10 seconds with
    three warm-up trials, each lasting 5 seconds. Here is the benchmark invocation:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过运行30次试验，每次持续10秒，并包含三个预热试验，每个试验持续5秒来评估性能。以下是基准调用：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The results are summarized in the following table:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果总结在下表中：
- en: '| **Benchmark** | **Index to match** | **Throughput (ops per second)** | **Error
    as percentage of throughput** | **Throughput change as percentage of base run**
    |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **匹配的索引** | **吞吐量（每秒操作数）** | **吞吐量误差（吞吐量的百分比）** | **吞吐量变化（基准运行的百分比）**
    |'
- en: '| `matchAnyVal` | 1 | 350,568,900.12 | ±3.02 | 0 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| `matchAnyVal` | 1 | 350,568,900.12 | ±3.02 | 0 |'
- en: '| `matchAnyVal` | 5 | 291,126,287.45 | ±2.63 | -17 |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| `matchAnyVal` | 5 | 291,126,287.45 | ±2.63 | -17 |'
- en: '| `matchAnyVal` | 10 | 238,326,567.59 | ±2.95 | -32 |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `matchAnyVal` | 10 | 238,326,567.59 | ±2.95 | -32 |'
- en: '| `matchCaseClass` | 1 | 356,567,498.69 | ±3.66 | 0 |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `matchCaseClass` | 1 | 356,567,498.69 | ±3.66 | 0 |'
- en: '| `matchCaseClass` | 5 | 287,597,483.22 | ±3.50 | -19 |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `matchCaseClass` | 5 | 287,597,483.22 | ±3.50 | -19 |'
- en: '| `matchCaseClass` | 10 | 234,989,504.60 | ±2.60 | -34 |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `matchCaseClass` | 10 | 234,989,504.60 | ±2.60 | -34 |'
- en: '| `matchIntLiterals` | 1 | 304,242,630.15 | ±2.95 | 0 |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `matchIntLiterals` | 1 | 304,242,630.15 | ±2.95 | 0 |'
- en: '| `matchIntLiterals` | 5 | 314,588,776.07 | ±3.70 | 3 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `matchIntLiterals` | 5 | 314,588,776.07 | ±3.70 | 3 |'
- en: '| `matchIntLiterals` | 10 | 285,227,574.79 | ±4.33 | -6 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `matchIntLiterals` | 10 | 285,227,574.79 | ±4.33 | -6 |'
- en: '| `matchIntVariables` | 1 | 332,377,617.36 | ±3.28 | 0 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `matchIntVariables` | 1 | 332,377,617.36 | ±3.28 | 0 |'
- en: '| `matchIntVariables` | 5 | 263,835,356.53 | ±6.53 | -21 |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `matchIntVariables` | 5 | 263,835,356.53 | ±6.53 | -21 |'
- en: '| `matchIntVariables` | 10 | 170,460,049.63 | ±4.20 | -49 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `matchIntVariables` | 10 | 170,460,049.63 | ±4.20 | -49 |'
- en: 'The last column takes the first trial of each benchmark when matching the first
    index as the base case. For trials matching the fifth and tenth indexes, the relative
    performance drop is displayed. In every case, except matching the fifth index
    of literal integers, throughput degrades nearly linearly as deeper indexes are
    matched. The one trial that defies this pattern is the trial matching literal
    integers. In this trial, performance improves relative to the first index when
    accessing the fifth index. Upon inspection of the bytecode, we discover that this
    scenario produces a jump table instead of a set of if statements. Here is a snippet
    from the generated bytecode:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的列取每个基准测试在匹配第一个索引时的第一次尝试作为基准情况。对于匹配第五和第十个索引的尝试，显示相对性能下降。在所有情况下，除了匹配字面整数的第五个索引外，随着匹配更深层的索引，吞吐量几乎线性下降。唯一违反这一模式的是匹配字面整数的尝试。在这个尝试中，当访问第五个索引时，性能相对于第一个索引有所提高。通过检查字节码，我们发现这种情况产生了一个跳转表而不是一系列if语句。以下是生成的字节码片段：
- en: '[PRE45]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This bytecode snippet demonstrates that the JVM converts a pattern match on
    integer literals to a jump table using the `tableswitch` instruction. This is
    a constant time operation rather than a linear traversal of if statements. Given
    that the observed error is several percentage points and the observed differences
    across the three trials are roughly several percentage points, we can deduce that
    the linear access cost does not apply to this scenario. Instead, matching literal
    integers at the N^(th) index has a constant access cost due to the generated jump
    table. In contrast, matching an integer variable proves to be nearly twice as
    expensive at the tenth index. The clear takeaway from this experiment is that,
    for any pattern match that is generating a series of if statements, there is a
    linear cost to access the N^(th) pattern match statement. If you pattern match
    at least three cases in performance-sensitive code, consider reviewing the code
    to determine whether the statement order matches the access frequency.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个字节码片段展示了 JVM 如何使用 `tableswitch` 指令将整数字面量的模式匹配转换为跳转表。这是一个常数时间操作，而不是 if 语句的线性遍历。鉴于观察到的错误是几个百分点，并且三次试验中的观察差异大致也是几个百分点，我们可以推断线性访问成本不适用于这种情况。相反，在
    N^(th) 索引处匹配字面整数由于生成的跳转表而具有常数访问成本。相比之下，在第十个索引处匹配整数变量证明要贵近一倍。从这个实验中可以清楚地看出，对于任何生成一系列
    if 语句的模式匹配，访问 N^(th) 模式匹配语句的成本是线性的。如果你在性能敏感的代码中至少匹配了三个案例，请考虑审查代码以确定语句顺序是否与访问频率相匹配。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Do you have examples of pattern matching containing only two patterns? In scenarios
    involving only two pattern match statements that directly match a value, the compiler
    is able to generate an efficient jump table. When matching primitive literals
    (for example, string literals or integer literals), the compiler is able to generate
    jump tables for larger pattern matches. Analogous to the `@tailrec` annotation,
    Scala defines a `@switch` annotation for you to indicate to the compiler that
    you expect this pattern match statement to be compiled to a jump table. If the
    compiler is unable to generate a jump table, and instead it produces a series
    of if statements, then a warning will be issued. Like the `@tailrec` annotation,
    the compiler will apply the jump table heuristic whether you provide the `@switch`
    annotation or not. In practice, we do not often use this annotation because of
    its limited applicability, but it is worthwhile to be aware of its existence.
    The following is an example of an annotated pattern match that compiles to a jump table:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你有只包含两个模式的模式匹配的例子吗？在只涉及两个直接匹配值的模式匹配语句的场景中，编译器能够生成一个高效的跳转表。当匹配原始字面量（例如，字符串字面量或整数字面量）时，编译器能够为更大的模式匹配生成跳转表。类似于
    `@tailrec` 注解，Scala 定义了一个 `@switch` 注解，以便你告知编译器你期望这个模式匹配语句被编译成跳转表。如果编译器无法生成跳转表，而是生成一系列
    if 语句，那么将发出警告。类似于 `@tailrec` 注解，编译器将应用跳转表启发式方法，无论你是否提供了 `@switch` 注解。在实践中，我们很少使用这个注解，因为它适用性有限，但了解其存在是有价值的。以下是一个编译成跳转表的注解模式匹配的例子：
- en: '[PRE46]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Tail recursion
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尾递归
- en: A function is said to be recursive when it calls itself. Recursion is a powerful
    tool, and it is often used in functional programming. It allows you to break complex
    problems into smaller subproblems, making them easier to reason through and solve.
    Recursion also works well with the idea of immutability. Recursive functions provide
    us with a good way to manage changing state without using mutable structures or
    reassignable variables. In this section, we focus on the different shortcomings
    of using recursion on the JVM, and especially in Scala.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数调用自身时，我们称其为递归。递归是一个强大的工具，它通常用于函数式编程。它允许你将复杂问题分解成更小的子问题，使它们更容易推理和解决。递归也与不可变性概念很好地结合。递归函数为我们提供了一种管理状态变化的好方法，而不需要使用可变结构或可重新分配的变量。在本节中，我们关注在
    JVM 上使用递归的不同缺点，尤其是在 Scala 中。
- en: 'Let''s take a look at a simple example of a recursive method. The following
    snippet shows a `sum` method that is used to calculate the sum of a list of integers:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个递归方法的简单例子。以下片段显示了一个 `sum` 方法，用于计算整数列表的总和：
- en: '[PRE47]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The `sum` method presented in the preceding code snippet performs what is called
    head-recursion. The `sum(xs)` recursive call is not the last instruction in the
    function. This method needs the result of the recursive call to compute its own
    result. Consider the following call:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中展示的`sum`方法执行的是所谓的头递归。`sum(xs)`递归调用不是函数中的最后一条指令。这个方法需要递归调用的结果来计算自己的结果。考虑以下调用：
- en: '[PRE48]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It can be represented as:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以表示为：
- en: '[PRE49]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Note how each time we perform a recursive call, our function is left hanging,
    waiting for the right side of the computation to finish to be able to return.
    As the calling function needs to complete its own computation after receiving
    the result of the recursive call, a new entry is added to the stack for each call.
    The stack has a limited size, and nothing prevents us from calling `sum` with
    a very long list. With a sufficiently long list, a call to `sum` would result
    in a `StackOverflowError`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意每次我们执行递归调用时，我们的函数都会挂起，等待计算的正确部分完成以便返回。由于调用函数需要在收到递归调用的结果后完成自己的计算，因此每个调用都会在栈上添加一个新的条目。栈的大小是有限的，没有任何东西可以阻止我们用一个非常长的列表调用`sum`。如果列表足够长，对`sum`的调用将导致`StackOverflowError`：
- en: '[PRE50]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The stack trace shows all the recursive calls piling up on the stack, waiting
    for the result from the following step. This proves that none of the calls to
    sum were able to complete without first completing the recursive call. Our stack
    ran out of space before the last call could be performed.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 栈跟踪显示了所有递归调用堆积在栈上，等待从后续步骤的结果。这证明了在完成递归调用之前，对`sum`的所有调用都无法完成。在最后一个调用能够执行之前，我们的栈空间已经耗尽。
- en: 'To avoid this problem, we need to refactor our method to make it tail-recursive.
    A recursive method is said to be tail-recursive if the recursive call is the last
    instruction performed. A tail-recursive method can be optimized to turn the series
    of recursive calls into something similar to a `while` loop. This means that only
    the first call is added to the stack:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们需要重构我们的方法使其成为尾递归。如果一个递归调用是最后一条执行的指令，那么这个递归方法被称为尾递归。尾递归方法可以被优化，将一系列递归调用转换为类似于`while`循环的东西。这意味着只有第一个调用被添加到栈上：
- en: '[PRE51]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This new version of `sum` is tail-recursive. Note that we create an internal
    `loop` method, which takes the list to sum, as well as an accumulator to compute
    the current state of the result. The `loop` method is tail-recursive because the
    recursive `loop(xs, acc+x)` call is the last instruction. By calculating the accumulator
    as we iterate, we avoid stacking recursive calls. The initial accumulator value
    is `0`, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`sum`的新版本是尾递归的。注意我们创建了一个内部`loop`方法，它接受要加和的列表以及一个累加器来计算当前结果的状态。`loop`方法是因为递归`loop(xs,
    acc+x)`调用是最后一条指令，所以是尾递归的。通过在迭代过程中计算累加器，我们避免了递归调用的堆栈。初始累加器值如下所示：
- en: '[PRE52]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'We mentioned that recursion is an important aspect of functional programming.
    However, in practice, you should only rarely have to write your own recursive
    method, especially when dealing with collections such as `List`. The standard
    API provides already optimized methods that should be preferred. For example,
    calculating the sum of a list of integers can be written, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到递归是函数式编程的一个重要方面。然而，在实践中，你很少需要自己编写递归方法，尤其是在处理`List`等集合时。标准API已经提供了优化的方法，应该优先使用。例如，计算整数列表的总和可以写成如下：
- en: '`list.foldLeft(0)((acc, x) => acc + x)` Or when taking advantage of Scala sugar,
    we can use the following:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.foldLeft(0)((acc, x) => acc + x)` 或者当利用Scala糖语法时，我们可以使用以下代码：'
- en: '`list.foldLeft(0)(+)` The `foldLeft` function is internally implemented with
    a `while` loop and will not cause a `aStackOverflowError` exception.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`list.foldLeft(0)(+)` 内部实现的`foldLeft`函数使用了一个`while`循环，不会引发`StackOverflowError`异常。'
- en: Actually, `List` has a `sum` method, which makes calculating the sum of a list
    of integers even easier. The `sum` method is implemented with `foldLeft` and is
    similar to the preceding code.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，`List`有一个`sum`方法，这使得计算整数列表的总和变得更加容易。`sum`方法是用`foldLeft`实现的，与前面的代码类似。
- en: Bytecode representation
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码表示
- en: As a matter of fact, the JVM does not support tail-recursion optimization. To
    make this work, the Scala compiler optimizes tail-recursive methods at compile
    time and turns them into a `while` loop. Let's compare the bytecode that was generated
    for each implementation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，JVM不支持尾递归优化。为了让这可行，Scala编译器在编译时优化尾递归方法，并将它们转换为`while`循环。让我们比较每个实现生成的字节码。
- en: 'Our original, head-recursive `sum` method compiled into the following bytecode:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的、头递归的`sum`方法编译成了以下字节码：
- en: '[PRE53]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'While the tail recursive `loop` method produced the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 而尾递归的`loop`方法产生了以下结果：
- en: '[PRE54]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Note how the `sum` method calls itself with the `invokevirtual` instruction
    at the `52` index and still has to perform some instructions with the returned
    value. On the contrary, the `loop` method uses a `goto` instruction at the `60`
    index to jump back to the beginning of its block, thus avoiding stacking several
    recursive calls to itself.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`sum`方法如何在`52`索引处使用`invokevirtual`指令调用自身，并且仍然需要执行一些与返回值相关的指令。相反，`loop`方法在`60`索引处使用`goto`指令跳回到其块的开始，从而避免了多次递归调用自身。
- en: Performance considerations
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: The compiler can only optimize simple tail-recursion cases. Specifically, only
    self-calling functions where the recursive call is the last instruction. There
    are many edge cases that could be described as tail-recursive, but they are too
    complex for the compiler to optimize. To avoid unknowingly writing a nonoptimizable
    recursive method, you should always annotate your tail-recursive methods with
    `@tailrec`. The `@tailrec` annotation is a way to tell the compiler, "I believe
    you will be able to optimize this recursive method; however, if you cannot, please
    give me an error at compile time." One thing to keep in mind is that `@tailrec`
    is not asking the compiler to optimize the method, it will do so anyway if it
    is possible. The annotation is for the developer to make sure the compiler can
    optimize the recursion.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器只能优化简单的尾递归情况。具体来说，只有那些递归调用是最后一条指令的自调用函数。有许多边缘情况可以描述为尾递归，但它们对于编译器来说过于复杂，无法优化。为了避免无意中编写一个不可优化的递归方法，你应该始终使用`@tailrec`来注释你的尾递归方法。`@tailrec`注释是一种告诉编译器的方式：“我相信你将能够优化这个递归方法；然而，如果你不能，请在编译时给我一个错误。”需要记住的一点是，`@tailrec`并不是要求编译器优化方法，如果可能，它仍然会这样做。这个注释是为了让开发者确保编译器可以优化递归。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At this point, you should realize that all `while` loops can be replaced by
    a tail-recursive method without any loss in performance. If you have been using
    while loop constructs in Scala, you can reflect on how to replace them with a
    tail-recursive implementation. Tail recursion eliminates the use of mutable variables.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该意识到所有`while`循环都可以在不损失性能的情况下替换为尾递归方法。如果你在Scala中使用过`while`循环结构，你可以思考如何用尾递归实现来替换它们。尾递归消除了对可变变量的使用。
- en: 'Here is the same `tailrecSum` method with the `@tailrec` annotation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是带有`@tailrec`注释的相同`tailrecSum`方法：
- en: '[PRE55]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we attempted to annotate our first, head-recursive, implementation, we would
    see the following error at compile time:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试注释我们的第一个、头递归的实现，我们会在编译时看到以下错误：
- en: '[PRE56]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We recommend always using `@tailrec` to ensure that your methods can be optimized
    by the compiler. As the compiler is only able to optimize simple cases of tail-recursion,
    it is important to ensure at compile time that you did not inadvertently write
    a nonoptimizable function that may cause a `StackOverflowError` exception. We
    now look at a few cases where the compiler is not able to optimize a recursive
    method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议始终使用`@tailrec`来确保你的方法可以被编译器优化。因为编译器只能优化尾递归的简单情况，所以在编译时确保你没有无意中编写一个可能引起`StackOverflowError`异常的非可优化函数是很重要的。我们现在来看几个编译器无法优化递归方法的案例：
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `loop` method in `sum2` cannot be optimized because the recursion involves
    two different methods calling each other. If we were to replace the call to `info`
    by its actual implementation, then the optimization would be possible, as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`sum2`中的`loop`方法无法优化，因为递归涉及到两个不同的方法相互调用。如果我们用`info`的实际实现替换调用，那么优化将是可能的，如下所示：'
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'A somewhat similar use case involves the compiler''s inability to take into
    account by-name parameters:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种类似的使用案例涉及到编译器无法考虑按名传递的参数：
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The `read` method cannot  be optimized by the compiler because it is unable
    to use the definition of `Option.fold` to understand that the recursive call is
    effectively in the tail position. If we replace the call to fold by its exact
    implementation, we can annotate the method, as follows:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`read`方法无法被编译器优化，因为它无法使用`Option.fold`的定义来理解递归调用实际上是尾位置的。如果我们用其确切实现替换对fold的调用，我们可以按如下方式标注该方法：'
- en: '[PRE60]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The compiler will also refuse to optimize a nonfinal public method. This is
    to prevent the risk of a subclass overriding the method with a non-tail-recursive
    version. A recursive call from the super class may go through the subclass''s
    implementation and break the tail-recursion:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器也会拒绝优化非final的公共方法。这是为了防止子类用非尾递归版本覆盖方法的风险。从超类发出的递归调用可能通过子类的实现，并破坏尾递归：
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Attempting to flag the `printMessageNTimes` method as tail-recursive yields
    the following error:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试将`printMessageNTimes`方法标记为尾递归会导致以下错误：
- en: '[PRE62]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Another case of recursive methods that cannot be optimized is when the recursive
    call is part of a try/catch block:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 递归方法无法优化的另一个案例是当递归调用是try/catch块的一部分时：
- en: '[PRE63]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In contrast to the prior examples, in this example the compiler is not to blame.
    The recursive call is not in the tail position. As it is surrounded by a try/catch,
    the method needs to be ready to receive a potential exception and perform more
    computations to address it. As proof, we can look at the generated bytecode and
    observe that the last instructions are related to the try/catch:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 与先前的示例相反，在这个例子中，编译器不应受到责备。递归调用不在尾位置。由于它被try/catch包围，该方法需要准备好接收潜在的异常并执行更多计算来处理它。作为证明，我们可以查看生成的字节码并观察到最后几条指令与try/catch相关：
- en: '[PRE64]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We hope that these few examples have convinced you that writing a non-tail-recursive
    method is an easy mistake to make. Your best defense against this is to always
    use the `@tailrec` annotation to verify your intuition that your method can be
    optimized.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这些少数示例已经说服你，编写非尾递归方法是容易犯的一个错误。你最好的防御方法是始终使用`@tailrec`注解来验证你的直觉，即你的方法可以被优化。
- en: The Option data type
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Option`数据类型'
- en: The `Option` data type is used pervasively throughout the Scala standard library.
    Like pattern matching, it is a language feature often adopted early by Scala beginners.
    The `Option` data type provides an elegant way to transform and handle values
    that are not required, doing away with null checks often found in Java code. We
    assume you understand and appreciate the value that `Option` brings to writing
    Scala in the functional paradigm, so we will not reiterate its benefits further.
    Instead, we focus on analyzing its bytecode representation to drive performance
    insights.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option`数据类型在Scala标准库中被广泛使用。像模式匹配一样，它是Scala初学者早期经常采用的语言特性。`Option`数据类型提供了一种优雅的方式来转换和处理不需要的值，从而消除了Java代码中常见的null检查。我们假设你理解并欣赏`Option`为在函数式范式编写Scala带来的价值，因此我们不会进一步重申其好处。相反，我们专注于分析其字节码表示，以获得性能洞察。'
- en: Bytecode representation
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字节码表示
- en: 'Inspecting the Scala source code, we see that `Option` is implemented as an
    abstract class with the possible outcomes, `Some` and `None`, extending `Option`
    to encode this relationship. The class definitions with implementations removed
    are shown for convenience in the following code snippet:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 检查Scala源代码，我们看到`Option`被实现为一个抽象类，其中包含可能的输出结果`Some`和`None`，它们扩展了`Option`以编码这种关系。以下代码片段中显示了移除实现后的类定义，以方便查看：
- en: '[PRE65]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Studying the definitions, we can infer several points about the bytecode representation.
    Focusing on `Some`, we note the absence of extending `AnyVal`. As `Option` is
    implemented using inheritance, `Some` cannot be a value class due to limitations
    that we covered in the Value class section. This limitation implies that there
    is an allocation for each value wrapped as a `Some` instance. Furthermore, we
    observe that `Some` is not specialized. From our examination of specialization,
    we realize that primitives wrapped as `Some` instances will be boxed. Here is
    a simple example to illustrate both concerns:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 研究定义后，我们可以推断出关于字节码表示的几个要点。关注`Some`，我们注意到它没有扩展`AnyVal`。由于`Option`是通过继承实现的，因此`Some`不能是一个值类，这是我们在值类部分提到的限制。这种限制意味着每个作为`Some`实例包装的值都有一个分配。此外，我们观察到`Some`没有被专门化。从我们对专门化的考察中，我们意识到作为`Some`实例包装的原始数据将被装箱。以下是一个简单示例，用于说明这两个问题：
- en: '[PRE66]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In this trivial example, an integer is encoded as a `Some` instance to be used
    as an `Option` data type. The following bytecode is produced:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，一个整数被编码为一个`Some`实例，用作`Option`数据类型。以下字节码被生成：
- en: '[PRE67]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: As we expected, there is an object allocation to create a `Some` instance, followed
    by the boxing of the provided integer to construct the `Some` instance.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所预期，有一个对象分配来创建一个`Some`实例，然后是将提供的整数装箱以构建`Some`实例。
- en: The `None` instance is a simpler case to understand from the bytecode perspective.
    As `None` is defined as a Scala object, there is no instantiation cost to create
    a `None` instance. This makes sense because `None` represents a scenario where
    there is no state to maintain.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`实例是一个从字节码角度更容易理解的简单案例。因为`None`被定义为Scala对象，所以创建`None`实例没有实例化成本。这很有意义，因为`None`代表没有状态需要维护的场景。'
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Have you ever considered how the single value, `None`, represents no value for
    all the types? The answer lies in understanding the `Nothing` type. The `Nothing`
    type extends all other types, which allows `None` to be a subtype of any  `A`
    type. For more insight into the Scala type hierarchy, view this useful Scala language
    tutorial at [http://docs.scala-lang.org/tutorials/tour/unified-types.html](http://docs.scala-lang.org/tutorials/tour/unified-types.html).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经考虑过单个值`None`如何代表所有类型的无值？答案在于理解`Nothing`类型。`Nothing`类型扩展了所有其他类型，这使得`None`可以成为任何`A`类型的子类型。要了解更多关于Scala类型层次结构的见解，请查看这个有用的Scala语言教程：[http://docs.scala-lang.org/tutorials/tour/unified-types.html](http://docs.scala-lang.org/tutorials/tour/unified-types.html)。
- en: Performance considerations
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: In any non-performance-sensitive environments, it is sensible to default to
    using `Option` to represent values that are not required. In a performance-sensitive
    area of the code, the choice becomes more challenging and less clear-cut. Particularly
    in performance-sensitive code, you must first optimize for correctness and then
    performance. We suggest always implementing the first version of the problem that
    you are modeling in the most idiomatic style, which is to say, using `Option`.
    Using the awareness gained from the bytecode representation of `Some`, the logical
    next step is to profile in order to determine whether or not `Option` use is the
    bottleneck. In particular, you are focusing on memory allocation patterns and
    garbage collection costs. In our experience, there are often other overhead sources
    present in the code that are more costly than `Option` use. Examples include inefficient
    algorithm implementation, a poorly constructed domain model, or inefficient use
    of system resources. If, in your case, you have eliminated other sources of inefficiency
    and are positive that `Option` is the source of your performance woes, then you
    need to take further steps.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何非性能敏感的环境中，默认使用`Option`来表示不需要的值是合理的。在性能敏感的代码区域，选择变得更加具有挑战性且不那么明确。特别是在性能敏感的代码中，你必须首先优化正确性，然后才是性能。我们建议始终以最地道的方式实现你正在建模的问题的第一个版本，也就是说，使用`Option`。从`Some`的字节码表示中获得的意识，下一步的逻辑是进行性能分析，以确定是否`Option`的使用是瓶颈。特别是，你关注的是内存分配模式和垃圾回收成本。根据我们的经验，代码中通常存在其他开销来源，这些开销比`Option`的使用更昂贵。例如，不高效的算法实现、构建不良的领域模型或系统资源使用不当。如果你的情况下已经消除了其他效率低下的来源，并且确信`Option`是导致你性能问题的原因，那么你需要采取进一步的步骤。
- en: 'An incremental step towards improved performance might include removing use
    of the `Option` higher-order functions. On the critical path, there can be significant
    cost savings by replacing higher-order functions with inlined equivalents. Consider
    the following trivial example that transforms an `Option` data type into a `String` data
    type:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 向提高性能的增量步骤可能包括移除使用`Option`高阶函数。在关键路径上，通过用内联等价物替换高阶函数可以实现显著的成本节约。考虑以下简单的例子，它将`Option`数据类型转换为`String`数据类型：
- en: '[PRE68]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On the critical path, the following change may yield substantive improvements:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在关键路径上，以下变更可能会带来实质性的改进：
- en: '[PRE69]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Replacing the `fold` operation with an if statement saves the cost of creating
    an anonymous function. It bears repeating that this type of change should only
    ever be considered after extensive profiling reveals `Option` usage to be the
    bottleneck. While this type of code change is likely to improve your performance,
    it is verbose and unsafe due to usage of `o.get`. When this technique is used
    judiciously, you may be able to retain use of the `Option` data type in critical
    path code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 将`fold`操作替换为if语句可以节省创建匿名函数的成本。需要重复强调的是，这种类型的更改只有在经过广泛的性能分析并发现`Option`使用是瓶颈之后才应考虑。虽然这种代码更改可能会提高你的性能，但由于使用了`o.get`，它既冗长又不安全。当这种技术被谨慎使用时，你可能会在关键路径代码中保留对`Option`数据类型的使用。
- en: If replacing higher-order `Option` function use with inlined and unsafe equivalents
    fails to sufficiently improve performance, then you need to consider more drastic
    measures. At this point, profiling should reveal that `Option` memory allocation
    is the bottleneck, preventing you from reaching your performance goals. Faced
    with this scenario, you have two options (pun intended!) to explore, both of which
    involve a high cost in terms of time to implement.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用内联和不安全的等效函数替换高阶`Option`函数使用未能充分提高性能，那么你需要考虑更激进的措施。此时，性能分析应该揭示`Option`内存分配是瓶颈，阻止你达到性能目标。面对这种场景，你有两种选择（这并非巧合！）进行探索，这两种选择都涉及实施时间的高成本。
- en: One way to proceed is to admit that, for the critical path, `Option` is unsuitable
    and must be removed from the type signatures and replaced with null checks. This
    is the most performant approach, but it brings significant maintenance costs because
    you and all other team members working on the critical path must be cognizant
    of this modeling decision. If you choose to proceed this way, define clear boundaries
    for the critical path to isolate null checks to the smallest possible region of
    the code. In the next section, we explore a second approach that involves building
    a new data type that leverages the knowledge that we gained in this chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 一种进行的方式是承认，对于关键路径，`Option`是不合适的，必须从类型签名中移除，并用null检查替换。这是最有效的方法，但它带来了显著的维护成本，因为你和所有其他在关键路径上工作的团队成员都必须意识到这个建模决策。如果你选择这种方式进行，为关键路径定义清晰的边界，将null检查限制在代码的最小可能区域。在下一节中，我们将探讨第二种方法，该方法涉及构建一个新的数据类型，该类型利用了我们在本章中获得的知识。
- en: Case study – a more performant option
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究 – 更高性能的选项
- en: 'If you are not yet ready to lose information that is encoded by the `Option`
    data type, then you may wish to explore alternative implementations of `Option`
    that are more garbage-collection-friendly. In this section, we present an alternative
    approach that also provides type-safety while avoiding boxing and instantiation
    of the `Some` instances. We leverage tagged types and specialization, and disallow
    null as a valid value for `Some` to come up with the following implementation:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有准备好丢失由`Option`数据类型编码的信息，那么你可能希望探索更符合垃圾回收友好的`Option`的替代实现。在本节中，我们介绍了一种替代方法，它也提供了类型安全，同时避免了`Some`实例的装箱和实例化。我们利用标记类型和特化，并禁止`Some`作为有效值，从而得出以下实现：
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This implementation defines factory methods to construct optional types (that
    is, `some`, `nullCheckingSome`, and `none`). In contrast to Scala's `Option`,
    this implementation uses tagged types to add type information to a value rather
    than creating a new value to encode optionality. The implementation of `none`
    takes advantage of `null` being a value in Scala rather than a language in keyword
    as is the case in Java. Remember, unless performance requirements required such
    extreme measures, we would not default to these more esoteric approaches. The
    tagged type returned by each factory method preserves type-safety, and it requires
    an explicit unwrapping to access the underlying type.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现定义了用于构建可选类型的工厂方法（即`some`、`nullCheckingSome`和`none`）。与Scala的`Option`相比，此实现使用标记类型向值添加类型信息，而不是创建一个新值来编码可选性。`none`的实现利用了Scala中将`null`视为值而不是语言关键字的事实。记住，除非性能要求需要这种极端措施，否则我们不会默认采用这些更神秘的方法。每个工厂方法返回的标记类型保留了类型安全，并且需要显式解包才能访问底层类型。
- en: Note
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more about Scala's representation of the `null` value,
    we encourage you to check out these two StackOverflow posts at [http://stackoverflow.com/questions/8285916/why-doesnt-null-asinstanceofint-throw-a-nullpointerexception](http://stackoverflow.com/questions/8285916/why-doesnt-null-asinstanceofint-throw-a-nullpointerexception) and
    [http://stackoverflow.com/questions/10749010/if-an-int-cant-be-null-what-does-null-asinstanceofint-mean](http://stackoverflow.com/questions/10749010/if-an-int-cant-be-null-what-does-null-asinstanceofint-mean). In
    both posts, multiple responders provide excellent responses that will help you
    deepen your understanding.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Scala对`null`值表示的信息，我们鼓励你查看这两个StackOverflow帖子：[http://stackoverflow.com/questions/8285916/why-doesnt-null-asinstanceofint-throw-a-nullpointerexception](http://stackoverflow.com/questions/8285916/why-doesnt-null-asinstanceofint-throw-a-nullpointerexception)
    和 [http://stackoverflow.com/questions/10749010/if-an-int-cant-be-null-what-does-null-asinstanceofint-mean](http://stackoverflow.com/questions/10749010/if-an-int-cant-be-null-what-does-null-asinstanceofint-mean)。在这两个帖子中，多位响应者提供了优秀的回答，这将帮助你深化理解。
- en: The remaining methods in `OptOps` define methods that you would find in the
    implementation of Scala's `Option`. Rather than instance methods, we see that
    the methods are static because there are no new instances that are allocated by
    the factory methods. It is possible to define an implicit class that would provide
    a syntax emulating instance method invocation, but we avoid doing this because
    we are operating under the assumption of extreme performance sensitivity. Semantically,
    the operations that are defined in `OptOps` are equivalent to the Scala `Option`
    analogs. Instead of matching against a value representing no value (that is, `None`),
    we again take advantage of the ability to reference `null` as a value.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptOps`中剩余的方法定义了你在Scala的`Option`实现中会发现的方法。由于没有通过工厂方法分配新实例，我们看到这些方法是静态的，而不是实例方法。我们有可能定义一个隐式类，它将提供模拟实例方法调用的语法，但我们避免这样做，因为我们假设极端的性能敏感性。从语义上讲，在`OptOps`中定义的操作与Scala的`Option`类似。我们不是匹配表示无值的值（即`None`），而是再次利用将`null`作为值的引用能力。'
- en: 'With this implementation, the runtime overhead consists of instance checking
    and invocations of `scalaz.Tag`. We lose the ability to pattern match, and instead
    we must either fold or, in extreme cases, use `isSome` and `unsafeGet`. To get
    a better understanding of runtime differences, we microbenchmarked `Option` creation
    using Scala''s `Option` and the preceding tagged type implementation. The microbenchmark
    gives you a taste for the change in syntax. We encourage you to run `javap` to
    disassemble the bytecode in order to prove to yourself that this implementation
    avoids boxing and object creation:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此实现，运行时开销包括实例检查和对`scalaz.Tag`的调用。我们失去了模式匹配的能力，而必须要么折叠，或者在极端情况下使用`isSome`和`unsafeGet`。为了更好地理解运行时差异，我们使用Scala的`Option`和前面的标记类型实现进行了微基准测试。微基准测试让你对语法的变化有所体会。我们鼓励你运行`javap`来反汇编字节码，以证明这个实现避免了装箱和对象创建：
- en: '[PRE71]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We run the test with the following familiar parameters:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下熟悉的参数运行测试：
- en: '[PRE72]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The results are summarized in the following table:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 结果总结在下表中：
- en: '| **Benchmark** | **Throughput (ops per second)** | **Error as percentage of
    throughput** |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| **基准** | **吞吐量（每秒操作数）** | **错误率（吞吐量的百分比）** |'
- en: '| `optNone` | 351,536,523.84 | ±0.75 |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `optNone` | 351,536,523.84 | ±0.75 |'
- en: '| `optNoneReuse` | 344,201,145.90 | ±0.23 |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `optNoneReuse` | 344,201,145.90 | ±0.23 |'
- en: '| `optSome` | 232,684,849.83 | ±0.37 |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `optSome` | 232,684,849.83 | ±0.37 |'
- en: '| `optSomeWithNullChecking` | 233,432,224.39 | ±0.28 |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| `optSomeWithNullChecking` | 233,432,224.39 | ±0.28 |'
- en: '| `scalaNone` | 345,826,731.05 | ±0.35 |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| `scalaNone` | 345,826,731.05 | ±0.35 |'
- en: '| `scalaSome` | 133,583,718.28 | ±0.24 |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| `scalaSome` | 133,583,718.28 | ±0.24 |'
- en: 'Perhaps the most impressive result here is that throughput increases approximately
    57% when using the tagged type implementation of `Some` over the Scala-provided
    implementation. This is likely due to reduced memory allocation pressure. We see
    that `None` creation throughput is qualitatively similar. We also observe that
    there appears to be zero cost to add a null check in the construction of a tagged `Some`
    option. If you trust your team to avoid passing around null values, then the check
    is superfluous. We also created a set of benchmarks to evaluate fold performance
    to get a sense of the relative cost of using this alternative `Option` implementation.
    Here is the source code for a simple fold benchmark:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里最令人印象深刻的结果可能是，当使用`Some`的标记类型实现而不是Scala提供的实现时，吞吐量大约提高了57%。这很可能是由于减少了内存分配压力。我们发现`None`创建的吞吐量在质量上相似。我们还观察到，在标记`Some`选项的构造中添加空检查似乎没有成本。如果你信任你的团队能够避免传递空值，那么这个检查就是多余的。我们还创建了一系列基准测试来评估折叠性能，以了解使用这种替代`Option`实现的相对成本。以下是简单折叠基准测试的源代码：
- en: '[PRE73]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This benchmark was run using the same set of parameters as before:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个基准测试使用了之前相同的参数集：
- en: '[PRE74]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The results of this test are summarized in the following table:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是测试结果的总结：
- en: '| **Benchmark** | **Throughput (ops per second)** | **Error as percentage of
    throughput** |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **基准测试** | **吞吐量（每秒操作数）** | **误差作为吞吐量的百分比** |'
- en: '| `optOption` | 346,208,759.51 | ±1.07 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| `optOption` | 346,208,759.51 | ±1.07 |'
- en: '| `scalaOption` | 306,325,098.74 | ±0.41 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| `scalaOption` | 306,325,098.74 | ±0.41 |'
- en: In this benchmark we are hoping to prove that there is no significant throughput
    degradation when using the alternative tagged type-inspired implementation over
    the Scala `Option`. A significant degradation in performance would jeopardize
    the performance wins that we found in the creation benchmark. Fortunately, this
    benchmark suggests fold throughput actually increases approximately 13% over the
    Scala `Option` fold implementation.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基准测试中，我们希望证明在使用替代的标记类型启发的实现而不是Scala `Option`时，没有显著的吞吐量下降。性能的显著下降将危及我们在创建基准测试中找到的性能提升。幸运的是，这个基准测试表明折叠吞吐量实际上比Scala
    `Option`折叠实现提高了大约13%。
- en: Note
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is a relief to see benchmarking yield results that confirm your hypothesis.
    However, it is equally important to understand why favorable results were produced,
    and to be able to explain this. Without an understanding of how these results
    happened, you are unlikely to be able to reproduce the results. How would you
    explain fold throughput improvement of the tagged type-inspired implementation
    over the Scala `Option` implementation? Consider the implementation and memory
    allocation differences that we covered.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 看到基准测试的结果证实了你的假设，这让人感到欣慰。然而，同样重要的是要理解为什么会产生有利的结果，并且能够解释这一点。如果没有理解这些结果是如何产生的，你很可能无法重现这些结果。你将如何解释标记类型启发的实现相对于Scala
    `Option`实现的折叠吞吐量改进？考虑我们讨论的实现和内存分配差异。
- en: The benchmarks suggest that the tagged type-inspired `Option` implementation
    yields qualitative performance improvements over the Scala `Option` implementation.
    If you are faced with a performance issue and profiling reveals the Scala `Option`
    to be the bottleneck, it may make sense to explore this alternative implementation.
    While the performance improves, realize that a tradeoff exists. When using the
    alternative implementation, you lose the ability to pattern match. This seems
    like a small price to pay because you are able to instead use the fold operation.
    The higher price to pay is integration with the standard library and third-party
    libraries. If your critical path code interacts heavily with the Scala standard
    library or a third-party library, you will be forced to rewrite significant chunks
    of code to use the alternative `Option` implementation. In this scenario, if you
    are under time pressure, it may make sense to reconsider whether or not modeling
    parts of the domain with `null` is sensible. If your critical path code avoids
    significant interaction with the Scala standard library or third-party libraries,
    then using the alternative `Option` implementation might be an easier decision.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试表明，受标记类型启发的`Option`实现相对于Scala的`Option`实现带来了定性的性能提升。如果你面临性能问题，并且分析显示Scala的`Option`是瓶颈，那么探索这种替代实现可能是有意义的。虽然性能有所提升，但要注意存在权衡。在使用替代实现时，你将失去模式匹配的能力。这看起来是一个微不足道的代价，因为你能够使用折叠操作。更高的代价是集成标准库和第三方库。如果你的关键路径代码与Scala标准库或第三方库有大量交互，你将被迫重写大量代码以使用替代的`Option`实现。在这种情况下，如果你处于时间压力之下，重新考虑是否用`null`建模域的部分部分是有意义的。如果你的关键路径代码避免与Scala标准库或第三方库有重大交互，那么使用替代的`Option`实现可能是一个更容易的决定。
- en: Our case study is inspired by a novel approach Alexandre Bertails explores in
    his blog post at [https://bertails.org/2015/02/15/abstract-algebraic-data-type/](https://bertails.org/2015/02/15/abstract-algebraic-data-type/).
    He solves the same performance issues that we addressed by defining an approach
    that he refers to as abstract algebraic data types. Both approaches rely on using
    type constraints to model `Option` without instance allocation. By abstracting
    over the `Option` algebraic data type and its operations, he is able to devise
    an implementation free of allocations and boxing. We encourage you to explore
    this approach because it is another great example of how to achieve safety while
    still providing excellent performance.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的案例研究受到了Alexandre Bertails在他的博客文章[https://bertails.org/2015/02/15/abstract-algebraic-data-type/](https://bertails.org/2015/02/15/abstract-algebraic-data-type/)中探索的一种新颖方法的启发。他通过定义一种他称之为抽象代数数据类型的方法来解决我们处理过的相同性能问题。这两种方法都依赖于使用类型约束来建模`Option`而不进行实例分配。通过抽象`Option`代数数据类型及其操作，他能够设计出一种无分配和无装箱的实现。我们鼓励你探索这种方法，因为它又是如何实现安全性的同时仍然提供优秀性能的一个很好的例子。
- en: Summary
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we dived into the bytecode representation and performance considerations
    of commonly-used Scala language features. In our case study, you saw first-hand
    how you can combine several areas of knowledge about Scala language features in
    combination with the excellent Scalaz library to produce an `Option` implementation
    that is better suited for high-performance needs.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了常用Scala语言特征的字节码表示和性能考虑。在我们的案例研究中，你亲眼看到了如何结合关于Scala语言特征的几个领域的知识，以及出色的Scalaz库，以产生更适合高性能需求的`Option`实现。
- en: A consistent theme across all our examples is to promote type-safety and correctness
    while taking into account performance tradeoffs. As functional programmers, we
    value compile time correctness and referential transparency. Even with the usage
    of `null` in the tagged type `Option` implementation, we preserved correctness
    because the `null` value is an internal implementation detail. When you reflect
    on the strategies that we covered, consider how each one preserves referentially
    transparent (that is, side-effect-free) code while still enabling you to reach
    your performance goals.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们所有的示例中，一个一致的宗旨是在考虑性能权衡的同时，促进类型安全和正确性。作为函数式程序员，我们重视编译时正确性和引用透明性。即使在标记类型`Option`实现中使用`null`，我们也保留了正确性，因为`null`值是一个内部实现细节。当你反思我们所讨论的策略时，考虑每个策略是如何在保持引用透明（即无副作用）的代码的同时，仍然帮助你达到性能目标的。
- en: At this point, you should feel more confident about the tradeoffs that are introduced
    by Scala's elegant language features. Through our analysis, you learned how to
    translate from concise Scala syntax to JVM bytecode. This is an invaluable skill
    to debug performance issues. As you practice your awareness by studying more examples,
    you will develop a stronger intuition for where potential problems lie. Over time,
    you can refer back to this chapter in order to review common remediation strategies
    to balance the tradeoff between elegance and safety with performance. In the next
    chapter, we will continue to grow our ability to leverage Scala to write performant,
    functional code by diving into collections.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你应该对Scala优雅的语言特性带来的权衡更加自信。通过我们的分析，你学习了如何将简洁的Scala语法转换为JVM字节码。这是一项宝贵的技能，可以帮助调试性能问题。随着你通过研究更多示例来提高自己的意识，你将培养出更强的直觉，了解潜在问题的所在。随着时间的推移，你可以回顾这一章节，以复习常见的补救策略，平衡优雅与安全与性能之间的权衡。在下一章中，我们将通过深入研究集合，继续提升利用Scala编写高效、函数式代码的能力。
