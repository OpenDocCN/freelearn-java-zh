- en: Chapter 8. Anatomy of ImageJ Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will examine how a plugin is organized in ImageJ and how
    it is implemented in the main interface. We will examine both the legacy plugins
    (ImageJ1.x) and the new format based on SciJava''s model (ImageJ2). The following
    topics will be discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The basic anatomy of a plugin in ImageJ1.x and ImageJ2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Types of plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining macros and plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running and debugging plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples of available plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basic anatomy of a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A plugin within ImageJ has to adhere to specific rules. The syntax conforms
    to the Java language, but some of the elements are unique to ImageJ. In the following
    sections, I will discuss the conventions and constructs used by ImageJ1.x plugins
    (referred to as **legacy** from here on) and the new SciJav-based conventions
    and constructs (referred to as **scijava** from here on). Note that when using
    the scijava model, you are required to use Java 1.7.x or higher when running and
    compiling your plugins. Also, the scijava model was designed with the Maven and
    Git systems in mind. This means that it is advantageous to use those systems when
    developing plugins for the future releases of ImageJ. The following sections will
    look at the basic anatomy of a plugin in both formats.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A plugin within ImageJ1.x has to adhere to specific rules. The syntax conforms
    to the Java language, but some of the elements are unique to ImageJ. The legacy
    plugin consists of three main types of plugins: the basic `PlugIn`, `PlugInFilter`,
    and `PlugInFrame`. A short description and use case for each of these types will
    follow in the upcoming sections.'
  prefs: []
  type: TYPE_NORMAL
- en: The PlugIn type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `PlugIn` type is used for basic plugins that do not require an image to
    be open by design. The `PlugIn` type is a Java interface, and it only has one
    method that needs to be overridden, which is the `run()` method. The `run()` method
    of the `PlugIn` type is the entry point for this type, and after that, it can
    be structured in any shape or form using Java syntax. This plugin is very basic,
    but can perform any task you can design. It can also deal with images. However,
    selecting an image or opening an image for processing needs to be handled explicitly
    by the programmer. Also, checking the image type before processing needs to be
    verified by the programmer explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: The PlugInFilter type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This type of plugin requires an image to be open when the plugin is being executed,
    and the image also is an input parameter for the plugin. It has two methods that
    are required to be overridden by the programmer: the `setup()` method and the
    `run()` method. The setup method does a basic check on the image and allows for
    the plugin to verify that the current image meets the requirements that are necessary
    for the processing. It returns an integer value that indicates which types of
    images can be handled by the plugin. When you wish to specify an image type, you
    can use the fields defined for the `PlugInFilter` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DOES_ALL`: These are any type of image can be processed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOES_8G`: These are the 8-bit gray scale images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOES_16`: These are the 16-bit gray scale images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOES_32`: These are the 32-bit float images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOES_RGB`: These are the RGB images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOES_STACKS`: These are all types of stacks (channels, slices or frames)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `DOES_STACKS` field, be aware that any multidimensional image
    will be considered a stack, and processing will run over all the channels, slices,
    and/or frames that are present in the image. When using this field, you have to
    perform checks to make sure that your plugin will process the correct dimension.
    If the image does not fit the type specified by the field(s), the plugin will
    abort and give a warning that the image type is not supported by the plugin. If
    you wish to support different types, you can return the sum of the supported types.
    The `run()` method is the main entry point of this type, although you could also
    perform some preprocessing in the setup method.
  prefs: []
  type: TYPE_NORMAL
- en: The PlugInFrame type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This type of plugin is designed to create an interface for your plugin to show
    the user. There is no method to be overridden, and the only required element is
    the constructor for the class. The constructor is the entry point of the plugin.
    The `PlugInFrame` type extends the **Abstract Window Toolkit** (**AWT**) model
    for the user interface, which can be filled with controls or tabbed panels to
    allow for a clear user experience. This type does not assume that any images are
    open, and the developer needs to implement all the logic for the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a legacy plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have decided on a plugin type, all you need to do is implement your
    plugin. This sounds simple, and it can be as well. There are a few things you
    need to consider before you start. ImageJ requires a plugin to have an underscore
    in the name in order for it to show up in the **Plugins** menu if you use a single
    class file. This requirement is lifted when you develop the plugin as a **Java
    archive** (**JAR**) file. When creating your plugin, you need to adhere to the
    Java syntax. This means that you need to declare and initialize your variables.
    When creating functions, you need to specify the return type, if any, and the
    access type (public/private/protected). The regular coding advice applies to ImageJ
    plugins as well. Adding comments can be helpful. It is also possible to create
    documentation for your functions using the Javadoc system that was set up in [Chapter
    7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"), *Explanation of ImageJ
    Constructs*. This allows for a comprehensive documentation of your code, as well
    as being useful as an extended memory when you need to modify something later
    on.
  prefs: []
  type: TYPE_NORMAL
- en: When selecting a plugin type, you need to consider certain points. When using
    `PlugInFilter`, the active image will be used when the plugin is called, causing
    the image to be locked by ImageJ. When a command is issued on the image from outside
    of your plugin, the image is not accessible as it is locked by the plugin. This
    causes the `Image locked` error. If you wish to process images using macros from
    within a plugin, it is better to use the basic `PlugIn` (or `PlugInFrame`) type
    instead of the `PlugInFilter` type. In the next section, we will look at the constructs
    for scijava plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Combining macros and legacy plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is possible to combine macros and plugins as well. The run command can be
    used from within a plugin to execute a specific macro or ImageJ command. The only
    difference is that you need to precede it with the root class `IJ`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first line will change the lookup table to green for the currently active
    image and channel. The second line will run a macro specified by a path. The `runMacro`
    method returns a string that contains the return value of the macro or `NULL`
    if the macro does not return a value. It returns `[Aborted]` when the macro was
    aborted or when it encountered an error. The `IJ` class contains a few useful
    methods that allow us to run macros and plugins as well as open images using an
    open dialog. Another useful method is the `IJ.log()` method, which accepts a string
    that will be displayed in the log window. This can be used to provide feedback
    for the user as well as aid in debugging a plugin, as will be shown in a later
    section. In [Chapter 9](ch09.html "Chapter 9. Creating ImageJ Plugins for Analysis"),
    *Creating ImageJ Plugins for Analysis* we will look at a basic implementation
    where we combine ImageJ commands within `PlugInFilter`.
  prefs: []
  type: TYPE_NORMAL
- en: SciJava plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since ImageJ was developed, many plugins were built using the legacy system
    described earlier. However, certain shortcomings in the design of the legacy format
    necessitated a redesign of the ImageJ core. This new framework is the SciJava
    framework, which consists of scijava-common at its core (among other components).
    The following sections will describe how plugins are implemented in this new framework.
    It should be noted that the way plugins are developed in the SciJava framework
    does not split a plugin in the same types as the legacy system. There is no concept
    of a plugin that requires an image or that creates a user interface. In the framework,
    all plugins have the same construction, and they define the components that are
    required.
  prefs: []
  type: TYPE_NORMAL
- en: The @Plugin annotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the SciJava framework, a plugin is a class that is annotated with the `@Plugin`
    annotation. Classes with this annotation are automatically recognized by ImageJ
    and indexed for use when the plugin is launched by the user. Under this framework,
    you will typically create one of two types of plugins: a service or a command.
    A service-type plugin will consist of utility methods for internal use in ImageJ.
    Services provide methods that can be used throughout the framework. Command-type
    plugins, on the other hand, are meant as plugins that execute a specific function
    with a specific goal. These are the types of plugins that the user will encounter
    when using the ImageJ interface: a menu item in ImageJ is a form of a command-type
    plugin. Command-type plugins can use Service methods to allow for common tasks
    such as opening images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether you create a command or service-style plugin, either will run in what
    is called `Context`. `Context` in the SciJava framework describes the services
    and commands that the plugin will use. It functions as a type of sandbox. It is
    not possible to directly use the methods of services and commands within another
    plugin''s context. If this is required, you have to inject your outside plugin
    into the context of the plugin of which you wish to use its methods. Alternatively,
    you can request a service from within a context using a special annotation to
    request an instance of a type in your plugin using the `@Parameter` annotation.
    For instance, if you wish to use `logService` in your plugin to allow for logging
    events, you could use the following annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When the plugin is run, the context will automatically generate an instance
    of `logService` and give you access to its methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the upcoming sections, we will look at the two basic types of the `@Plugin`
    annotation in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The SciJava framework contains a large number of generic services that can
    be used to perform basic tasks and deal with datasets. Some of the more important
    ones include the following services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AppService`: This deals with applications (that is, ImageJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventService`: This deals with events such as mouse clicks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PluginService`: This deals with the available plugins and their execution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatasetService`: This deals with tools to handle image data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OverlayService`: This deals with tools for overlays and ROIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create your own service, you will need to create a context for it and define
    its methods. If you wish to use the generic services available in the SciJava
    framework, you can add them as parameters to your own service. This allows for
    very extensible code that can be reused over and over consistently. In most cases,
    you will obtain a reference to these services using the `@Parameter` annotation
    in your plugins, giving you access to its methods and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating plugins yourself, the command type will be the most commonly
    used type. Commands describe plugins that face the user and describe an action
    that the user can perform by launching the command. When creating a plugin, you
    can specify the type as a `Command` class, and you can specify where the command
    will be placed in the menu structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The type specifies that this plugin is concerned with a command interface, which
    it implements as stated in the class definition. The `menuPath` parameter allows
    you to set the menu position where the plugin will be placed when it is discovered.
    This allows for fine control and grouping of your plugins. In this case, in a
    predefined submenu (**My Menu**) within the plugins menu of ImageJ.
  prefs: []
  type: TYPE_NORMAL
- en: Running and debugging plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have created your code, you are ready to compile it. Java is not an
    interpreted language and requires that the source code is compiled into byte code
    that can be processed by the **Java Virtual Machine** (**JVM**). Depending on
    how you're developing the code, there are different ways to proceed. You can use
    ImageJ directly, use the Fiji Code Editor, or use the NetBeans IDE. How you proceed
    also depends on whether you are developing a legacy plugin or a scijava plugin.
    The following sections will look at the legacy plugins first.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compiling and running plugins differs a little between vanilla ImageJ and Fiji
    due to the fact that Fiji is based on the SciJava framework. Also, when using
    an IDE, there will be different steps involved in compiling and running your plugin.
  prefs: []
  type: TYPE_NORMAL
- en: When you have finished writing the source code for your plugin using vanilla
    ImageJ, you can run the plugin by first compiling it and then running it. To do
    so, go to **Plugins** | **Compile and Run…** and select your plugin. If your code
    was correctly written, it would compile and then run. If there were any errors
    during compilation, an error dialog would pop up indicating which line(s) contained
    error(s). Most of the time, error messages can be very cryptic and may not always
    point directly to the point where the code failed.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Fiji, you can compile and run your plugin using the **Run**
    button at the bottom of the script editor window. The **Compile and Run…** method
    is not available in Fiji! Any error messages will be displayed in the field below
    to indicate where and why the compilation or running failed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using an IDE for your development, you can use the compile function
    of the IDE. In NetBeans, you can compile your file by going to **Run** | **Compile
    File** or by pressing *F9*. If there were no errors during compilation, you can
    run your plugin using **Run** | **Run Project** from the menu or by pressing *F6*.
    If no errors were found, a new instance of ImageJ will be started, and under the
    **Plugin** menu, your developed plugin should show up. Errors in syntax will prevent
    the compilation, and the IDE will highlight these errors using a red symbol with
    a white exclamation mark (as well as a red wavy line):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Compiling plugins](img/Insert_image_4909_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When hovering the pointer above the red symbol in the margin, a suggestion is
    given about the error. In this case, the message tells us that `;` was expected
    at the end of the statement. The symbol above it does not signify an error, but
    a warning. Warnings will not halt compilation or prevent the running of a plugin.
    However, they can cause problems during runtime. In this example, the warning
    tells us that the use of the keyword `this` used in the constructor is not advised
    and might cause problems. For plugins based on the SciJava framework, the procedures
    and results are the same. However, there are a few important things to consider.
    The next section will briefly explain some of the main points.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling SciJava plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To compile plugins that implement the SciJava framework, you need to make sure
    that you have all the dependencies as well as that the ImageJ framework you will
    run the plugins on supports the framework. For Fiji, this is not a problem. It
    runs on the framework by default already. You can also use the vanilla ImageJ,
    but you must make sure it is the ImageJ2 variant and not the **ImageJ1.x** variant.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can check which variant you're using by clicking on the status line of the
    main interface. If it reads something like *ImageJ 2.0.0-[…]*, it indicates you
    are using ImageJ2\. If it reads something similar to **ImageJ 1.50a**, then you
    are running the **ImageJ1.x** variant.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the modular nature of the framework, it is strongly recommended that
    you use the Maven tools to create and compile your plugins. This will take care
    of all the dependencies required to build your plugin. To make this more streamlined
    and efficient, it is a best practice to use an IDE that supports Maven, although
    you can also use the **Command-line Interface** (**CLI**) if you wish. To refresh
    your memory, refer to the previous chapter, which explains you how to set up your
    IDE with a Maven-based plugin.
  prefs: []
  type: TYPE_NORMAL
- en: To compile your plugin using NetBeans using a Maven-based project, you just
    need to select your project and go to **Run** | **Build Project** or press *F11*.
    To launch your plugin, go to **Run** | **Run Project** from the menu or press
    *F6*. Problems that were encountered during compilation will be displayed in a
    similar way as described for the legacy plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As ImageJ is a tool to run the code, it does not have many utilities to debug
    code. This does not mean, however, that it is not possible to do some debugging.
    For legacy plugins, you can use the `IJ.log` method. It is possible to log statements
    to a log window or to look at the value of variables. For plugins built on the
    SciJava framework, you can use `logService` and use the `info()` and `warn()`
    methods after declaring `@Parameter` to create an instance to the required service.
    An example use of this method of debugging plugins can be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When using this type of method, it can be useful to include a simple control
    statement such as the `if` statement. This allows you to easily disable or control
    the amount of logging that is done in your final incarnation of the plugin. Using
    a global variable that sets a debugging level, you can control to show a certain
    log message or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the global variable `dbglvl` will dictate which messages will
    be shown. The first `if` statement will be executed with the current debug level
    (set to `3`), while the second statement will not be displayed with the current
    level. In the final version of your plugin, you can change the value of `dbglvl`
    to `1` or `0` to disable all low-level debugging statements. Note that this assumes
    that a high value for `dbglvl` is associated with minor logging statements, and
    a low value will only show the most minimal statements. Finally, you might want
    to remove all the if statements when the code is working correctly. The evaluation
    of each statement does require a finite amount of time, so it will slow down your
    code in the end.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the NetBeans IDE to develop plugins, there are more options to debug
    and profile your code. The advantage of using an IDE such as NetBeans is you can
    set breakpoints where you wish to halt the execution of the plugin and look at
    the contents of the variables. To do so, click on the margin before the line where
    you wish to stop. A red square will be displayed, indicating a breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging plugins](img/Insert_image_4909_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The entire line is also colored red to indicate the line where the debugger
    will wait when you run it. Keep in mind that if you place a breakpoint in a statement
    that will never be executed, the debugger will never stop, and your code will
    run uninterrupted.
  prefs: []
  type: TYPE_NORMAL
- en: To run the code using the debugger, you can go to **Debug** | **Debug Project
    (…)** or press *Ctrl* + *F5* on the keyboard. When the debugger hits a breakpoint,
    the line will become green, and you can continue using the different step functions.
    In the variables tab at the bottom of the IDE, you will see all the variables
    that are available at the current breakpoint. Note that you can also evaluate
    expressions and change the values that are currently assigned to variables. Doing
    this may cause problems or may lead to infinite loops or crashes, so be careful
    when changing values!
  prefs: []
  type: TYPE_NORMAL
- en: There is also a profiler to help with identifying sections of code that are
    not efficient in terms of processing speed or memory usage. However, many of these
    advanced features are not always necessary when developing simple plugins. Once
    you start Profiler by selecting **Profile** | **Profile Project (…)**, you can
    select whether you wish to monitor the CPU processing, **garbage collection**
    (**GC**) and/or memory usage. You can use the telemetry to see whether there are
    problems with excessive CPU cycles as well as problems with garbage collection
    and memory management. The use of Profiler extends a little too far beyond the
    scope of this book. However, there are excellent resources available online on
    how to use and interpret the results from profiling.
  prefs: []
  type: TYPE_NORMAL
- en: As profiling an application is very close to an art form, use it carefully and
    only when you really notice very slow performance or memory problems in your application.
    Choosing how much development overhead you wish to dedicate for your plugin should
    always be weighed against the amount of time it gains. Spending hours of optimizing
    your code or algorithm so that it executes 1 second faster may not be worth it
    if it is called only once and is a part of a larger chain of commands. However,
    if you optimize code that is called hundreds of time within a loop, the optimization
    might be worth the extra development time many times over.
  prefs: []
  type: TYPE_NORMAL
- en: In the upcoming section, we will look at some plugins that are available and
    are used for scientific research.
  prefs: []
  type: TYPE_NORMAL
- en: Examples of available plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, I will discuss a few plugins that are available for ImageJ,
    most of which have also been published in scientific journals. They will show
    you how to use ImageJ for advanced image processing, with different degrees of
    automation and user interaction. They also provide a few examples of the design
    of a plugin, either with its own interface or just as a single command that executes.
    Some of these examples also have their source code available so that you can see
    how the developers implemented their algorithms. Be aware that having the source
    code and being able to understand it fully might be difficult: depending on the
    level of documentation or comments in the code. It might be very difficult to
    completely retrace the functioning of the code. As a program grows and new functions
    and algorithms are added, it deviates more from a single core algorithm to a more
    convoluted group of files. Developers using the Javadoc capabilities available
    in IDEs can create detailed documentation relatively easy, making the understanding
    of code slightly easier.'
  prefs: []
  type: TYPE_NORMAL
- en: One point that is very important when trying to analyze source code is to realize
    which file or function is the entry point of the program. You can be sure that
    when the code executes, it will always go into this main entry point, and every
    user interaction or function will be set up in the main entry point. The entry
    points for the different types of plugins were indicated in the previous sections.
    Also, plugins developed using the SciJava framework generally have a `main()`
    method, which is not necessarily the entry point for the plugin. This depends
    on the way that the plugin was launched. When launched through the IDE using Maven,
    the `main()` method is used to instantiate ImageJ and launch the plugin. However,
    when launching the plugin from the ImageJ instance using the menu for example,
    the `main()` method will not be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: When using an interface for your plugin, a lot of the action comes from the
    user pressing a button, adding a number to a field or selecting an option. The
    `main` interface just waits for the user to do something. In Java, this means
    that the `ActionPerformed()` method becomes the entry point for many algorithms
    or processing. When a user clicks a button, this will fire an action event that
    can be used by the programmer to catch it and connect it to further statements.
    First, we will look at some examples of plugins that are available on the ImageJ
    website ([http://imagej.nih.gov/ij/plugins/index.html](http://imagej.nih.gov/ij/plugins/index.html))
    to show how to develop ImageJ solutions to image processing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Example plugins available in ImageJ and Fiji
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ImageJ has a large collection of plugins available that extend the core functionality.
    With the arrival of ImageJ2, the model for distribution of plugins is changing
    as well. In the older ImageJ1.x framework, you were required to download a source
    file of a plugin or a compiled .class file and place it in the plugins folder.
    When the plugin was updated, you would need to repeat the whole process again.
    With ImageJ2, an updating mechanism has been provided that uses a repository system.
    In this system, communication between ImageJ and the repository will determine
    whether there are updates available. When there are updates, the user can automatically
    install the updates without having to search for the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: For most of the plugins that are available, the source code can be viewed or
    studied to look at the way other people have solved a particular image-processing
    problem. For the following example plugins, I will describe the specific problem
    or challenge they are designed to tackle. I will then show a bit of code to explain
    how the plugin tries to solve the problem. Feel free to view or download the source
    code where available to look at the complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: MultipleKymograph
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An example of such a plugin is the **MultipleKymograph** plugin (`MultipleKymograph_.java`),
    which creates a kymograph along a (segmented) line selection. It was designed
    by Jens Rietdorf and Arne Seitz from the **European Molecular Biology Laboratory**
    (**EMBL**) in Heidelberg, Germany. It contains a small set of tools and macros
    that can be used to create and measure kymographs. We already saw kymographs back
    in [Chapter 5](ch05.html "Chapter 5. Basic Measurements with ImageJ"), *Basic
    Measurements with ImageJ,* where we saw how they visualized dynamics in time series.
    There, we used the **Reslice** command to generate the kymograph, which worked
    OK, but there are a few small drawbacks of that method.
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that **Reslice** only considers the pixels that are on
    the line that was selected. This makes it more sensitive to inaccurate placement
    of the line and pixel noise. The **MultipleKymograph** plugin is a legacy plugin
    that tries to solve this problem by providing the user with an input field to
    ask for the line width to be used to create the averaged output pixels. When the
    user calls the plugin without a line selection or an open image, it generates
    an error message indicating that action needs to be taken by the user before calling
    the plugin. As the creation of the kymograph image itself hinges on the correct
    values for the pixels, I will focus on how the plugin calculates the average pixel
    intensity for the line that was placed by the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main generation of the pixel values happens in the `sKymo(…)` method, which
    has the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sum` variable that is returned contains the result of the averaged profiles
    along the stack. The method requires five input parameters, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ImagePlus imp`: This is the source stack that we want to use for the calculations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ImageProcessor ip`: This is the image processor to access the pixels of the
    stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Roi roi`: This is the ROI that marks the line we wish to make into a kymograph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int linewidth`: This is the width of the line as specified by the user input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`int proflength`: This is the length of the line specified by the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method starts by declaring the parameters that will be needed for processing.
    Specifically, the output variable `sum` is defined as a `double[]` vector with
    a length equal to length of the line multiplied with the number of slices (or
    frames). The method then iterates over the slices in the stack (the outer for
    loop) and retrieves the profile using a method called `getProfile()` or `getIrregularProfile()`.
    These methods extract the pixel values from the selection, where the shift parameter
    determines how far the line is shifted compared to the selection. The only difference
    between the two is that one is meant to be used for straight lines (`getProfile`),
    while the other is used for segmented lines (`getIrregularProfile`). For the sake
    of brevity, I will only show the code for the former method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This method takes the ROI that the user specified and shifts it by the amount
    specified in the `shift` parameter. It then uses the `getPixels()` method from
    the `Roi` class to extract the gray values and returns them. As a line is defined
    by only two points, each with an *x* and *y* coordinate, this method is fairly
    brief. The irregular case requires that the line is moved along all the *N* coordinates
    required to define the segmented line. Otherwise, it functions in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: ColorTransformer2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This legacy plugin is useful when dealing with color images such as those acquired
    by digital color cameras or videos from cameras such as webcams. It was originally
    developed by Maria E. Barilla as **ColorTransformer** and modified by Russel Cottrell,
    resulting in the **ColorTransformer2** plugin. The source code can be found at
    [http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java](http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java).
  prefs: []
  type: TYPE_NORMAL
- en: 'A problem with color images, such as RGB images, is that the intensity is not
    well-defined in the RGB color space. Light blue might appear more intense than
    dark blue, but the intensity value for the blue channel might be higher for dark
    blue than for light blue. In order to segment RGB images effectively based on
    specific colors, it is better that you transform it to a color space that is more
    suited for this purpose. The HSB color space separates an image in three components:
    **Hue**, **Saturation**, and **Brightness** (sometimes also labeled as **Value**
    or **Intensity**). The hue indicates the color ranging from red to orange, yellow,
    green, cyan, blue, and magenta. See [Chapter 2](ch02.html "Chapter 2. Basic Image
    Processing with ImageJ"), *Basic Image Processing with ImageJ* for details on
    the use of the HSB color space.'
  prefs: []
  type: TYPE_NORMAL
- en: This plugin implements a `PlugInFilter`, meaning that it overrides the `setup()`
    and `run()` methods, which form the entry points for the plugin. The setup method
    checks whether an image is open and screens the type of image that this plugin
    can process. The run method shows a dialog, which allows the user to choose the
    color space to convert from and to. The method I want to describe here is the
    conversion from RGB to HSI, which is a common format to use in segmentation of
    RGB images where segmentation needs to be performed based on color.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main method that performs the actual RGB-to-HSI conversion is the `getHSI()`
    method. This method looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These conversions are based on the methodology described in *Color Vision and
    Colorimetry, Theory and Applications*, *D Malacara*. The transformation is based
    on transforming the original RGB values stored in the `rf`, `gf`, and `bf` arrays,
    respectively. The transformed values are stored in the `c1`, `c2`, `c3`, and optionally,
    `c4` arrays. For the transformation to HSI, the `c4` array is not used, as an
    HSI image only has three channels. For example, the CMYK color space requires
    all four channels. At the end of the run method, the values for the channels are
    placed in a new image, which will be the transformed image.
  prefs: []
  type: TYPE_NORMAL
- en: MtrackJ
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This plugin is useful when you wish to track objects over time and, optionally,
    in three dimensions. It was developed by Eric Meijering at the University of Lausanne
    in Switzerland. The source code can be found on GitHub at [https://github.com/fiji/MTrackJ/](https://github.com/fiji/MTrackJ/).
    It was published in *Methods in Enzymology*, *vol 504* in February 2012\. The
    main interface of the plugin consists of groups of buttons that allow you to add,
    delete, or move tracks or points and perform measurements or change settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MtrackJ](img/Insert_image_4909_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The function of this plugin is to track objects or particles over time in order
    to establish their speed and direction. Although automated tracking algorithms
    do exist, some data is just too difficult or too dense for automated tracking
    algorithms to cope with. For these types of challenges, this plugin will provide
    a tool that can help establish useful parameters for objects. The goal of this
    plugin is similar to that of the **MultipleKymograph** plugin described earlier:
    measuring the velocity of multiple objects. When the tracks are created and measured,
    the results are presented in a results window. These results can then be used
    for direct plotting and analysis outside of ImageJ or as input for more advanced
    analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As this plugin is quite extensive and has many features, I will focus on one
    very tiny detail that makes this interface great to track objects with amazing
    accuracy. In the options for tracking, accessed through the **Tracking** button,
    you can set a snapping function for the mouse cursor. This type of feature might
    be familiar to many people. Many different applications use it to make it easier
    to align objects nice and evenly. When you check the **Apply local cursor snapping
    during tracking** checkbox, you can choose a snap feature. This snap feature will
    determine when you position your mouse cursor over an object where the tracking
    point will be added. Without snapping, it would be placed at the pixel that you
    clicked. However, when using **bright centroid** as the snap feature, something
    interesting will happen (when using fluorescent images). When you add a tracking
    point by clicking, **MtrackJ** determines the centroid of the snap range that
    you defined. The centroid is the weighted intensity point and is not necessarily
    a single pixel, but it can be a position such as (*x = 12.4, y = 13.45*). For
    image data with good signal-to-noise ratio, you can achieve better tracking resolution
    than the optical system can provide (so-called subpixel resolution). The location
    of the snap coordinates are calculated in a method called `snapcoords()`. I will
    not reproduce the entire method as it is quite extensive, but I will show you
    how it achieves the bright centroid calculation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As the plugin supports multiple methods for snapping, there are multiple cases
    in this `switch` statement, which I omitted for the sake of brevity. The goal
    of the method is to assign values to the `snapos.x` and `snapos.y` variables.
    For the bright centroid method, a threshold is used based on the **Otsu** method.
    In the first loop using the *x* and *y* indices, we went over the pixels of the
    snapping rectangle and sum all the pixel intensities (`val`) that are above the
    threshold value (`thres`) in `sum2` and the intensities below the threshold in
    `sum1`. We used these to calculate the variation, and if it exceeds the maximum
    value in the rectangle, we adjust the value and the Otsu threshold value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second loop over the pixels in the snapping rectangle, the centroid
    is determined by summing the products of each pixel''s *x* and *y* coordinates
    multiplied by the intensity above the Otsu threshold. A running sum of the intensities
    above the threshold is also kept and used to divide the final coordinates with.
    These final values are used in the `draw()` method function that shows the bright
    centroid in the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This method uses a `Graphics2D` object referenced by `g2d` to create a square
    box indicating the snap region (the `// Snap ROI` section), whose size is determined
    by the values of the `snaprect` object. Finally, it draws a small `+` to indicate
    the snap coordinate defined by the `snapos.x` and `snapos.y` variables (the `//
    Snap cursor` section).
  prefs: []
  type: TYPE_NORMAL
- en: Coloc2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For certain types of research questions, it is important to know whether two
    objects overlap or colocalize. The **Coloc2** is a plugin included in the `Colocalisation_Analysis.jar`
    file as developed by Daniel J. White, Tom Kazimiers, and Johannes Schindelin.
    The source is available on GitHub at [https://github.com/fiji/Colocalisation_Analysis/](https://github.com/fiji/Colocalisation_Analysis/).
    The Coloc2 command is used to measure colocalization between two images, usually
    representing different channels in fluorescent images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main functionality is placed in the `colocalise` method, which compares
    the pixel intensities between the two images using different methods. As an example
    of how this plugin functions, I will look at a more basic function that is used
    whenever a selection is present in the ROI manager and needs to be used for the
    colocalization analysis. The method is called `createMasksFromRoiManager`, and
    it calls a second method called `createMasksAndRois`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to retrieve the ROIs from the manager using the `getSelectedRoisAsArray()`
    method, which then passes the ROIs to the `createMasksAndRois` method. This method
    stores the regions in the `mi.mask` variable where it can be used by the `colocalise`
    method. This plugin uses some constructs derived from ImageJ2\. The `ImagePlusAdapter`
    is a wrapper function from the `ImgLib2` library. This convenience method allows
    ImageJ1.x images to be placed inside an `ImgLib2` container as used by ImageJ2\.
    These functions are essential during the transition between ImageJ1.x and ImageJ2
    and allow for interoperability. Next, I will take a look at a plugin that was
    developed within the SciJava framework using the annotations and the **Command
    and Service framework** specifically for ImageJ2.
  prefs: []
  type: TYPE_NORMAL
- en: Goutte_pendante
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Goutte_pendante** plugin (pendant drop) is a plugin built under the SciJava
    framework by Adrian Daerr at the Université Paris Diderot. The source code can
    be found on GitHub at [https://github.com/adaerr/pendent-drop](https://github.com/adaerr/pendent-drop).
    This project is written using the Maven system, so I will briefly show the `pom.xml`
    file as an example of how to define a plugin within the framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the project description is very simple using the POM model.
    The `<parent>` tag describes that this utilizes ImageJ. The dependencies state
    that the ImageJ2 code base should be used, as identified by the `<artifactId>`
    tag using `imagej` instead of `ij` for ImageJ1.x plugins. Plugins built for ImageJ2
    also tend to have a `main` method. To illustrate its function, I will highlight
    some of the code from this plugins'' `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is only used when testing the plugin and performs a few steps that
    are useful when testing code but not when actually using the plugin outside of
    the testing phase. It starts by defining a test image with a hard-coded path string.
    It then performs the step that all plugins for ImageJ will perform in their main
    method: launching an instance of ImageJ. It then goes on to open the image specified
    by the string using `IOService` and finally displaying it using the `ImageDisplay`
    service. The result of this process is the image of a drop hanging from an aperture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Goutte_pendante](img/Insert_image_4909_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, a `rectangle` object is generated over the drop image that was opened.
    This image will be used as an initial search space for the plugin to detect the
    drop. This is done using the `RectangleOverlay` class in the `net.imagej.overlay`
    package. Finally, it adds the overlay to the display and displays the image before
    calling the plugin in the last statement of the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The used pattern in this plugin is similar to that described in the previous
    chapter. However, there are additional steps inserted here to make sure that the
    plugin works fast and correctly. If you would install the plugin using **Update
    site** through Fiji and try to run it immediately by selecting **Plugins** | **Drop
    Analysis** | **Pendant Drop** from the menu, you will get an error message. This
    error message states that there is an error executing the `Goutte_pendante#paramInitializer`
    method. If you run **Plugins** | **Drop Analysis** | **About Pendant Drop**, you
    will see a brief explanation and a usage section for the plugin. In the usage
    section, there will be an explanation of why it failed. There was no rectangular
    ROI or image when you launched it. At the bottom of the about dialog, there are
    buttons with information and documentation, as well as a way to retrieve the image
    of the drop (bottom button).
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this plugin is to fit the shape of the drop, and the parameters
    of that fit can be used to say something about the surface tension of the liquid.
    To do so, it needs a class that describes the shape of the drop that is defined
    as an object called `Contour` within the plugin. It needs to fit a polynomial
    to the drop shape in order to determine `Contour` parameters. To do so, it is
    necessary to determine the borders of the drop. This is achieved by a method called
    `findDropBorders()`. This function will find the shoulders of the drop and store
    the locations in arrays for the left and right borders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This method performs a line scan method to find the index where the drop falls
    below the threshold. In this case, the drop has a low value compared to the background.
    It starts by going in the left-to-right direction. As soon as it has found that
    pixel, the variable `xl` will no longer increase and will be smaller than the
    width of the bounds. This will activate the `else if` clause and will allocate
    the arrays for the borders. The next step is to determine the index on the right-hand
    side using the same methodology. However, now, the search goes in the right-to-left
    direction, starting at the bounding box, and will determine `xr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code mentioned in this method is generic Java code that is not specific
    for ImageJ2, but it performs the task in a similar way. It illustrates the fact
    that ImageJ2 plugins are not necessarily more complicated than or different from
    their legacy counterparts in terms of development. A difference between this plugin
    and a legacy plugin is the use of services such as the `LogService` interface.
    When the plugin is launched, it requests an instance of `LogService` using the
    `@Parameter` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the functional part of the plugin, this service is called to perform the
    logging of errors and other messages. An example can be found in the `run()` method
    of the plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The log variable can be used to write messages to the log window. Based on the
    function used, they will be preceded by a label that indicates the type of the
    message. Methods such as `error`, `warn`, and `info` allow for different categories
    of messages to be reported.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the anatomy of plugins for ImageJ1.x and ImageJ2\.
    We also looked at some of the specific constructs that are used in plugins for
    both frameworks. We examined how to compile, run, and debug our plugins using
    the tools provided by ImageJ or using the IDE. We looked at some established plugins
    and how they implemented plugins to perform a task in image processing.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge will be applied in the next chapter where we will create a plugin
    from scratch to perform image processing.
  prefs: []
  type: TYPE_NORMAL
