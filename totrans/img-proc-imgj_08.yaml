- en: Chapter 8. Anatomy of ImageJ Plugins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：ImageJ插件的解剖结构
- en: 'In this chapter, we will examine how a plugin is organized in ImageJ and how
    it is implemented in the main interface. We will examine both the legacy plugins
    (ImageJ1.x) and the new format based on SciJava''s model (ImageJ2). The following
    topics will be discussed in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨ImageJ中插件的组织方式和在主界面中的实现方式。我们将探讨传统的插件（ImageJ1.x）以及基于SciJava模型的新的格式（ImageJ2）。本章将讨论以下主题：
- en: The basic anatomy of a plugin in ImageJ1.x and ImageJ2
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImageJ1.x和ImageJ2中插件的基本结构
- en: Types of plugins
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件类型
- en: Implementing a plugin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现插件
- en: Combining macros and plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏和插件的组合
- en: Running and debugging plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行和调试插件
- en: Examples of available plugins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用插件的示例
- en: The basic anatomy of a plugin
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件的基本结构
- en: A plugin within ImageJ has to adhere to specific rules. The syntax conforms
    to the Java language, but some of the elements are unique to ImageJ. In the following
    sections, I will discuss the conventions and constructs used by ImageJ1.x plugins
    (referred to as **legacy** from here on) and the new SciJav-based conventions
    and constructs (referred to as **scijava** from here on). Note that when using
    the scijava model, you are required to use Java 1.7.x or higher when running and
    compiling your plugins. Also, the scijava model was designed with the Maven and
    Git systems in mind. This means that it is advantageous to use those systems when
    developing plugins for the future releases of ImageJ. The following sections will
    look at the basic anatomy of a plugin in both formats.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: ImageJ中的插件必须遵循特定的规则。语法遵循Java语言，但其中一些元素是ImageJ特有的。在接下来的几节中，我将讨论ImageJ1.x插件（以下简称**传统**）和基于SciJav的新约定和结构（以下简称**scijava**）。请注意，当使用scijava模型时，运行和编译插件时必须使用Java
    1.7.x或更高版本。此外，scijava模型是考虑到Maven和Git系统设计的。这意味着在为ImageJ的未来版本开发插件时，使用这些系统是有利的。接下来的几节将探讨两种格式中插件的基本结构。
- en: Legacy plugins
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统的插件
- en: 'A plugin within ImageJ1.x has to adhere to specific rules. The syntax conforms
    to the Java language, but some of the elements are unique to ImageJ. The legacy
    plugin consists of three main types of plugins: the basic `PlugIn`, `PlugInFilter`,
    and `PlugInFrame`. A short description and use case for each of these types will
    follow in the upcoming sections.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ImageJ1.x中的插件必须遵循特定的规则。语法遵循Java语言，但其中一些元素是ImageJ特有的。传统的插件包括三种主要类型的插件：基本的`PlugIn`、`PlugInFilter`和`PlugInFrame`。接下来几节将分别介绍这些类型及其用例。
- en: The PlugIn type
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PlugIn`类型'
- en: The `PlugIn` type is used for basic plugins that do not require an image to
    be open by design. The `PlugIn` type is a Java interface, and it only has one
    method that needs to be overridden, which is the `run()` method. The `run()` method
    of the `PlugIn` type is the entry point for this type, and after that, it can
    be structured in any shape or form using Java syntax. This plugin is very basic,
    but can perform any task you can design. It can also deal with images. However,
    selecting an image or opening an image for processing needs to be handled explicitly
    by the programmer. Also, checking the image type before processing needs to be
    verified by the programmer explicitly.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlugIn`类型用于基本插件，这些插件不需要设计上打开图像。`PlugIn`类型是一个Java接口，它只有一个需要重写的方法，即`run()`方法。`PlugIn`类型的`run()`方法是此类型的入口点，之后可以使用Java语法以任何形状或形式进行结构化。这个插件非常基础，但可以执行任何你可以设计的任务。它还可以处理图像。然而，选择图像或为处理打开图像需要程序员显式处理。此外，在处理之前检查图像类型也需要程序员显式验证。'
- en: The PlugInFilter type
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PlugInFilter`类型'
- en: 'This type of plugin requires an image to be open when the plugin is being executed,
    and the image also is an input parameter for the plugin. It has two methods that
    are required to be overridden by the programmer: the `setup()` method and the
    `run()` method. The setup method does a basic check on the image and allows for
    the plugin to verify that the current image meets the requirements that are necessary
    for the processing. It returns an integer value that indicates which types of
    images can be handled by the plugin. When you wish to specify an image type, you
    can use the fields defined for the `PlugInFilter` interface:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此类插件在执行时需要打开一个图像，并且图像也是插件的一个输入参数。它有两个方法需要程序员重写：`setup()` 方法和 `run()` 方法。`setup()`
    方法对图像进行基本检查，并允许插件验证当前图像是否满足处理所需的条件。它返回一个整数值，表示插件可以处理哪些类型的图像。当你想指定图像类型时，可以使用为 `PlugInFilter`
    接口定义的字段：
- en: '`DOES_ALL`: These are any type of image can be processed'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOES_ALL`: 这些是可以处理的任何类型的图像'
- en: '`DOES_8G`: These are the 8-bit gray scale images'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOES_8G`: 这些是8位灰度图像'
- en: '`DOES_16`: These are the 16-bit gray scale images'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOES_16`: 这些是16位灰度图像'
- en: '`DOES_32`: These are the 32-bit float images'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOES_32`: 这些是32位浮点图像'
- en: '`DOES_RGB`: These are the RGB images'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOES_RGB`: 这些是RGB图像'
- en: '`DOES_STACKS`: These are all types of stacks (channels, slices or frames)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOES_STACKS`: 这些是所有类型的栈（通道、切片或帧）'
- en: When using the `DOES_STACKS` field, be aware that any multidimensional image
    will be considered a stack, and processing will run over all the channels, slices,
    and/or frames that are present in the image. When using this field, you have to
    perform checks to make sure that your plugin will process the correct dimension.
    If the image does not fit the type specified by the field(s), the plugin will
    abort and give a warning that the image type is not supported by the plugin. If
    you wish to support different types, you can return the sum of the supported types.
    The `run()` method is the main entry point of this type, although you could also
    perform some preprocessing in the setup method.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `DOES_STACKS` 字段时，请注意，任何多维图像都将被视为栈，处理将在图像中存在的所有通道、切片和/或帧上运行。使用此字段时，你必须进行检查以确保你的插件将处理正确的维度。如果图像不符合字段指定的类型，插件将终止并给出警告，说明图像类型不受插件支持。如果你希望支持不同类型，可以返回支持类型的总和。`run()`
    方法是此类的主要入口点，尽管你也可以在 `setup` 方法中执行一些预处理。
- en: The PlugInFrame type
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PlugInFrame` 类型'
- en: This type of plugin is designed to create an interface for your plugin to show
    the user. There is no method to be overridden, and the only required element is
    the constructor for the class. The constructor is the entry point of the plugin.
    The `PlugInFrame` type extends the **Abstract Window Toolkit** (**AWT**) model
    for the user interface, which can be filled with controls or tabbed panels to
    allow for a clear user experience. This type does not assume that any images are
    open, and the developer needs to implement all the logic for the user interface.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此类插件旨在为你的插件创建一个用户界面。没有需要重写的方法，唯一需要的是类的构造函数。构造函数是插件的入口点。`PlugInFrame` 类型扩展了 **抽象窗口工具包**
    (**AWT**) 模型用于用户界面，可以填充控件或选项卡面板，以提供清晰的用户体验。此类不假设任何图像已打开，开发者需要实现所有用户界面的逻辑。
- en: Implementing a legacy plugin
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现遗留插件
- en: Once you have decided on a plugin type, all you need to do is implement your
    plugin. This sounds simple, and it can be as well. There are a few things you
    need to consider before you start. ImageJ requires a plugin to have an underscore
    in the name in order for it to show up in the **Plugins** menu if you use a single
    class file. This requirement is lifted when you develop the plugin as a **Java
    archive** (**JAR**) file. When creating your plugin, you need to adhere to the
    Java syntax. This means that you need to declare and initialize your variables.
    When creating functions, you need to specify the return type, if any, and the
    access type (public/private/protected). The regular coding advice applies to ImageJ
    plugins as well. Adding comments can be helpful. It is also possible to create
    documentation for your functions using the Javadoc system that was set up in [Chapter
    7](ch07.html "Chapter 7. Explanation of ImageJ Constructs"), *Explanation of ImageJ
    Constructs*. This allows for a comprehensive documentation of your code, as well
    as being useful as an extended memory when you need to modify something later
    on.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定了插件类型，您需要做的就是实现您的插件。这听起来很简单，确实也是如此。在开始之前，您需要考虑一些事情。ImageJ 要求插件名称中包含下划线，以便在您使用单个类文件时，它可以在
    **插件** 菜单中显示。当您将插件作为 **Java 归档**（**JAR**）文件开发时，此要求被取消。在创建您的插件时，您需要遵守 Java 语法。这意味着您需要声明和初始化您的变量。在创建函数时，您需要指定（如果有）返回类型和访问类型（公共/私有/受保护）。常规编码建议也适用于
    ImageJ 插件。添加注释可能会有所帮助。您还可以使用在 [第 7 章](ch07.html "第 7 章。ImageJ 构造解释") 中设置的 Javadoc
    系统为您的函数创建文档，*ImageJ 构造解释*。这允许对您的代码进行全面的文档记录，并在您稍后需要修改某些内容时作为扩展记忆很有用。
- en: When selecting a plugin type, you need to consider certain points. When using
    `PlugInFilter`, the active image will be used when the plugin is called, causing
    the image to be locked by ImageJ. When a command is issued on the image from outside
    of your plugin, the image is not accessible as it is locked by the plugin. This
    causes the `Image locked` error. If you wish to process images using macros from
    within a plugin, it is better to use the basic `PlugIn` (or `PlugInFrame`) type
    instead of the `PlugInFilter` type. In the next section, we will look at the constructs
    for scijava plugins.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择插件类型时，您需要考虑某些要点。当使用 `PlugInFilter` 时，在调用插件时将使用活动图像，导致图像被 ImageJ 锁定。当从您的插件外部对图像发出命令时，由于插件锁定，图像不可访问。这会导致出现
    `Image locked` 错误。如果您希望在插件内部使用宏来处理图像，最好使用基本的 `PlugIn`（或 `PlugInFrame`）类型而不是 `PlugInFilter`
    类型。在下一节中，我们将探讨 scijava 插件的构造。
- en: Combining macros and legacy plugins
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合宏和旧版插件
- en: 'It is possible to combine macros and plugins as well. The run command can be
    used from within a plugin to execute a specific macro or ImageJ command. The only
    difference is that you need to precede it with the root class `IJ`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将宏和插件结合起来。您可以从插件内部使用运行命令来执行特定的宏或 ImageJ 命令。唯一的区别是您需要在其前面加上根类 `IJ`：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first line will change the lookup table to green for the currently active
    image and channel. The second line will run a macro specified by a path. The `runMacro`
    method returns a string that contains the return value of the macro or `NULL`
    if the macro does not return a value. It returns `[Aborted]` when the macro was
    aborted or when it encountered an error. The `IJ` class contains a few useful
    methods that allow us to run macros and plugins as well as open images using an
    open dialog. Another useful method is the `IJ.log()` method, which accepts a string
    that will be displayed in the log window. This can be used to provide feedback
    for the user as well as aid in debugging a plugin, as will be shown in a later
    section. In [Chapter 9](ch09.html "Chapter 9. Creating ImageJ Plugins for Analysis"),
    *Creating ImageJ Plugins for Analysis* we will look at a basic implementation
    where we combine ImageJ commands within `PlugInFilter`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将当前活动图像和通道的查找表更改为绿色。第二行将运行由路径指定的宏。`runMacro` 方法返回一个包含宏的返回值的字符串，或者如果宏不返回值，则返回
    `NULL`。如果宏被中止或遇到错误，它返回 `[Aborted]`。`IJ` 类包含一些有用的方法，允许我们运行宏和插件，以及使用打开对话框打开图像。另一个有用的方法是
    `IJ.log()` 方法，它接受将在日志窗口中显示的字符串。这可以用于为用户提供反馈以及帮助调试插件，正如将在后面的章节中展示的那样。在 [第 9 章](ch09.html
    "第 9 章。创建用于分析的 ImageJ 插件")，*创建用于分析的 ImageJ 插件* 中，我们将查看一个基本实现，其中我们在 `PlugInFilter`
    内部结合 ImageJ 命令。
- en: SciJava plugins
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SciJava 插件
- en: Since ImageJ was developed, many plugins were built using the legacy system
    described earlier. However, certain shortcomings in the design of the legacy format
    necessitated a redesign of the ImageJ core. This new framework is the SciJava
    framework, which consists of scijava-common at its core (among other components).
    The following sections will describe how plugins are implemented in this new framework.
    It should be noted that the way plugins are developed in the SciJava framework
    does not split a plugin in the same types as the legacy system. There is no concept
    of a plugin that requires an image or that creates a user interface. In the framework,
    all plugins have the same construction, and they define the components that are
    required.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 自从ImageJ开发以来，许多插件都是使用前面描述的遗留系统构建的。然而，遗留格式设计中的某些不足迫使ImageJ核心进行了重新设计。这个新框架是SciJava框架，其核心是scijava-common（以及其他组件）。以下章节将描述如何在新的框架中实现插件。需要注意的是，在SciJava框架中开发插件的方式并不将插件分割成与遗留系统相同类型。没有需要图像或创建用户界面的插件概念。在框架中，所有插件具有相同的结构，并且它们定义了所需的组件。
- en: The @Plugin annotation
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '@Plugin注解'
- en: 'In the SciJava framework, a plugin is a class that is annotated with the `@Plugin`
    annotation. Classes with this annotation are automatically recognized by ImageJ
    and indexed for use when the plugin is launched by the user. Under this framework,
    you will typically create one of two types of plugins: a service or a command.
    A service-type plugin will consist of utility methods for internal use in ImageJ.
    Services provide methods that can be used throughout the framework. Command-type
    plugins, on the other hand, are meant as plugins that execute a specific function
    with a specific goal. These are the types of plugins that the user will encounter
    when using the ImageJ interface: a menu item in ImageJ is a form of a command-type
    plugin. Command-type plugins can use Service methods to allow for common tasks
    such as opening images.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在SciJava框架中，插件是一个带有`@Plugin`注解的类。带有此注解的类会被ImageJ自动识别并索引，以便在用户启动插件时使用。在这个框架下，你通常会创建两种类型的插件之一：服务或命令。服务类型的插件将包含ImageJ内部使用的实用方法。服务提供可以在整个框架中使用的功能。另一方面，命令类型的插件旨在执行具有特定目标的特定功能。这些是用户在使用ImageJ界面时会遇到的插件类型：ImageJ中的菜单项是一种命令类型插件。命令类型插件可以使用服务方法来执行常见任务，如打开图像。
- en: 'Whether you create a command or service-style plugin, either will run in what
    is called `Context`. `Context` in the SciJava framework describes the services
    and commands that the plugin will use. It functions as a type of sandbox. It is
    not possible to directly use the methods of services and commands within another
    plugin''s context. If this is required, you have to inject your outside plugin
    into the context of the plugin of which you wish to use its methods. Alternatively,
    you can request a service from within a context using a special annotation to
    request an instance of a type in your plugin using the `@Parameter` annotation.
    For instance, if you wish to use `logService` in your plugin to allow for logging
    events, you could use the following annotation:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你创建命令或服务风格的插件，它们都会在所谓的`Context`中运行。在SciJava框架中，`Context`描述了插件将使用的服务和命令。它充当一种沙盒。无法直接在另一个插件的上下文中使用服务和命令的方法。如果需要这样做，你必须将你的外部插件注入到你希望使用其方法的插件的上下文中。或者，你可以在上下文中使用特殊注解请求一个服务，使用`@Parameter`注解请求你的插件中类型的实例。例如，如果你想在插件中使用`logService`以允许记录事件，你可以使用以下注解：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When the plugin is run, the context will automatically generate an instance
    of `logService` and give you access to its methods:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当插件运行时，上下文将自动生成一个`logService`实例，并允许你访问其方法：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the upcoming sections, we will look at the two basic types of the `@Plugin`
    annotation in more detail.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将更详细地探讨`@Plugin`注解的两种基本类型。
- en: Services
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 服务
- en: 'The SciJava framework contains a large number of generic services that can
    be used to perform basic tasks and deal with datasets. Some of the more important
    ones include the following services:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: SciJava框架包含大量通用服务，可用于执行基本任务和处理数据集。其中一些更重要服务包括以下服务：
- en: '`AppService`: This deals with applications (that is, ImageJ)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AppService`：这处理应用程序（即ImageJ）'
- en: '`EventService`: This deals with events such as mouse clicks'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventService`：这处理鼠标点击等事件'
- en: '`PluginService`: This deals with the available plugins and their execution'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PluginService`：这涉及可用的插件及其执行'
- en: '`DatasetService`: This deals with tools to handle image data'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DatasetService`：这涉及处理图像数据的相关工具'
- en: '`OverlayService`: This deals with tools for overlays and ROIs'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OverlayService`：这涉及处理叠加和ROIs的工具'
- en: To create your own service, you will need to create a context for it and define
    its methods. If you wish to use the generic services available in the SciJava
    framework, you can add them as parameters to your own service. This allows for
    very extensible code that can be reused over and over consistently. In most cases,
    you will obtain a reference to these services using the `@Parameter` annotation
    in your plugins, giving you access to its methods and functionality.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的服务，您需要为其创建一个上下文并定义其方法。如果您希望使用SciJava框架中可用的通用服务，您可以将它们作为参数添加到自己的服务中。这允许非常可扩展的代码，可以反复一致地重用。在大多数情况下，您将使用`@Parameter`注解在您的插件中获取这些服务的引用，从而获得其方法和功能。
- en: Commands
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令
- en: 'When creating plugins yourself, the command type will be the most commonly
    used type. Commands describe plugins that face the user and describe an action
    that the user can perform by launching the command. When creating a plugin, you
    can specify the type as a `Command` class, and you can specify where the command
    will be placed in the menu structure:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当您自己创建插件时，命令类型将是最常用的类型。命令描述了面向用户的插件，并描述了用户可以通过启动命令执行的操作。在创建插件时，您可以指定类型为`Command`类，并可以指定命令将在菜单结构中的位置：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The type specifies that this plugin is concerned with a command interface, which
    it implements as stated in the class definition. The `menuPath` parameter allows
    you to set the menu position where the plugin will be placed when it is discovered.
    This allows for fine control and grouping of your plugins. In this case, in a
    predefined submenu (**My Menu**) within the plugins menu of ImageJ.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 类型指定此插件关注命令接口，它按照类定义实现。`menuPath`参数允许您设置插件被发现时放置的菜单位置。这允许对您的插件进行精细控制和分组。在这种情况下，在ImageJ插件菜单中的预定义子菜单（**我的菜单**）内。
- en: Running and debugging plugins
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行和调试插件
- en: Once you have created your code, you are ready to compile it. Java is not an
    interpreted language and requires that the source code is compiled into byte code
    that can be processed by the **Java Virtual Machine** (**JVM**). Depending on
    how you're developing the code, there are different ways to proceed. You can use
    ImageJ directly, use the Fiji Code Editor, or use the NetBeans IDE. How you proceed
    also depends on whether you are developing a legacy plugin or a scijava plugin.
    The following sections will look at the legacy plugins first.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完您的代码后，您就可以编译它了。Java不是一种解释型语言，需要将源代码编译成字节码，以便由**Java虚拟机**（**JVM**）处理。根据您如何开发代码，有不同的方法可以采取。您可以直接使用ImageJ，使用Fiji代码编辑器，或使用NetBeans
    IDE。您采取的方法也取决于您是在开发遗留插件还是scijava插件。以下章节将首先查看遗留插件。
- en: Compiling plugins
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译插件
- en: Compiling and running plugins differs a little between vanilla ImageJ and Fiji
    due to the fact that Fiji is based on the SciJava framework. Also, when using
    an IDE, there will be different steps involved in compiling and running your plugin.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Fiji基于SciJava框架，编译和运行插件在vanilla ImageJ和Fiji之间略有不同。此外，当使用IDE时，编译和运行您的插件将涉及不同的步骤。
- en: When you have finished writing the source code for your plugin using vanilla
    ImageJ, you can run the plugin by first compiling it and then running it. To do
    so, go to **Plugins** | **Compile and Run…** and select your plugin. If your code
    was correctly written, it would compile and then run. If there were any errors
    during compilation, an error dialog would pop up indicating which line(s) contained
    error(s). Most of the time, error messages can be very cryptic and may not always
    point directly to the point where the code failed.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用vanilla ImageJ编写完插件的源代码后，您可以通过先编译它然后运行它来运行插件。要这样做，请转到**插件** | **编译和运行…**并选择您的插件。如果您的代码编写正确，它将编译并运行。如果在编译过程中出现任何错误，将弹出一个错误对话框，指示哪些行包含错误。大多数情况下，错误消息可能非常晦涩，并且不一定直接指向代码失败的地方。
- en: If you are using Fiji, you can compile and run your plugin using the **Run**
    button at the bottom of the script editor window. The **Compile and Run…** method
    is not available in Fiji! Any error messages will be displayed in the field below
    to indicate where and why the compilation or running failed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用Fiji，您可以使用脚本编辑器窗口底部的**运行**按钮编译和运行您的插件。**编译和运行…**方法在Fiji中不可用！任何错误消息都将显示在下面的字段中，以指示编译或运行失败的原因。
- en: 'If you are using an IDE for your development, you can use the compile function
    of the IDE. In NetBeans, you can compile your file by going to **Run** | **Compile
    File** or by pressing *F9*. If there were no errors during compilation, you can
    run your plugin using **Run** | **Run Project** from the menu or by pressing *F6*.
    If no errors were found, a new instance of ImageJ will be started, and under the
    **Plugin** menu, your developed plugin should show up. Errors in syntax will prevent
    the compilation, and the IDE will highlight these errors using a red symbol with
    a white exclamation mark (as well as a red wavy line):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用IDE进行开发，您可以使用IDE的编译功能。在NetBeans中，您可以通过转到**运行** | **编译文件**或按*F9*来编译您的文件。如果在编译过程中没有错误，您可以通过菜单中的**运行**
    | **运行项目**或按*F6*来运行您的插件。如果没有发现错误，将启动ImageJ的新实例，在**插件**菜单下，您开发的插件应该会出现。语法错误将阻止编译，IDE将使用带有白色感叹号的红色符号（以及红色波浪线）突出显示这些错误：
- en: '![Compiling plugins](img/Insert_image_4909_08_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![编译插件](img/Insert_image_4909_08_01.jpg)'
- en: When hovering the pointer above the red symbol in the margin, a suggestion is
    given about the error. In this case, the message tells us that `;` was expected
    at the end of the statement. The symbol above it does not signify an error, but
    a warning. Warnings will not halt compilation or prevent the running of a plugin.
    However, they can cause problems during runtime. In this example, the warning
    tells us that the use of the keyword `this` used in the constructor is not advised
    and might cause problems. For plugins based on the SciJava framework, the procedures
    and results are the same. However, there are a few important things to consider.
    The next section will briefly explain some of the main points.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当指针悬停在页边距上的红色符号上方时，会给出有关错误的建议。在这种情况下，消息告诉我们期望在语句的末尾出现`;`。上面的符号不表示错误，而是一个警告。警告不会阻止编译或阻止插件的运行。然而，它们可能在运行时引起问题。在这个例子中，警告告诉我们使用构造函数中使用的`this`关键字是不建议的，可能会引起问题。对于基于SciJava框架的插件，程序和结果都是相同的。然而，有一些重要的事情需要考虑。下一节将简要解释一些主要点。
- en: Compiling SciJava plugins
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编译SciJava插件
- en: To compile plugins that implement the SciJava framework, you need to make sure
    that you have all the dependencies as well as that the ImageJ framework you will
    run the plugins on supports the framework. For Fiji, this is not a problem. It
    runs on the framework by default already. You can also use the vanilla ImageJ,
    but you must make sure it is the ImageJ2 variant and not the **ImageJ1.x** variant.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译实现SciJava框架的插件，您需要确保您拥有所有依赖项，以及您将要运行插件的ImageJ框架支持该框架。对于Fiji来说，这不是问题。它默认已经运行在框架上。您也可以使用纯ImageJ，但您必须确保它是ImageJ2版本，而不是**ImageJ1.x**版本。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can check which variant you're using by clicking on the status line of the
    main interface. If it reads something like *ImageJ 2.0.0-[…]*, it indicates you
    are using ImageJ2\. If it reads something similar to **ImageJ 1.50a**, then you
    are running the **ImageJ1.x** variant.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过单击主界面的状态栏来检查您正在使用哪个版本。如果它显示类似*ImageJ 2.0.0-[…]*的内容，则表示您正在使用ImageJ2。如果它显示类似**ImageJ
    1.50a**的内容，那么您正在运行**ImageJ1.x**版本。
- en: Due to the modular nature of the framework, it is strongly recommended that
    you use the Maven tools to create and compile your plugins. This will take care
    of all the dependencies required to build your plugin. To make this more streamlined
    and efficient, it is a best practice to use an IDE that supports Maven, although
    you can also use the **Command-line Interface** (**CLI**) if you wish. To refresh
    your memory, refer to the previous chapter, which explains you how to set up your
    IDE with a Maven-based plugin.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于框架的模块化特性，强烈建议您使用Maven工具创建和编译您的插件。这将处理构建插件所需的所有依赖项。为了使这个过程更加流畅和高效，使用支持Maven的IDE是一种最佳实践，尽管如果您愿意，也可以使用**命令行界面**（**CLI**）。为了刷新您的记忆，请参考上一章，其中解释了如何使用基于Maven的插件设置您的IDE。
- en: To compile your plugin using NetBeans using a Maven-based project, you just
    need to select your project and go to **Run** | **Build Project** or press *F11*.
    To launch your plugin, go to **Run** | **Run Project** from the menu or press
    *F6*. Problems that were encountered during compilation will be displayed in a
    similar way as described for the legacy plugins.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用基于 Maven 的项目使用 NetBeans 编译你的插件，你只需选择你的项目，然后转到 **运行** | **构建项目** 或按 *F11*。要启动你的插件，从菜单转到
    **运行** | **运行项目** 或按 *F6*。在编译过程中遇到的问题将以与旧插件描述的类似方式显示。
- en: Debugging plugins
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试插件
- en: 'As ImageJ is a tool to run the code, it does not have many utilities to debug
    code. This does not mean, however, that it is not possible to do some debugging.
    For legacy plugins, you can use the `IJ.log` method. It is possible to log statements
    to a log window or to look at the value of variables. For plugins built on the
    SciJava framework, you can use `logService` and use the `info()` and `warn()`
    methods after declaring `@Parameter` to create an instance to the required service.
    An example use of this method of debugging plugins can be as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 ImageJ 是一个运行代码的工具，它没有很多调试代码的实用工具。但这并不意味着不可能进行一些调试。对于旧插件，你可以使用 `IJ.log` 方法。对于基于
    SciJava 框架的插件，你可以在声明 `@Parameter` 之后使用 `logService` 并使用 `info()` 和 `warn()` 方法来创建所需服务的实例。这种调试插件方法的示例用法如下：
- en: '[PRE4]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When using this type of method, it can be useful to include a simple control
    statement such as the `if` statement. This allows you to easily disable or control
    the amount of logging that is done in your final incarnation of the plugin. Using
    a global variable that sets a debugging level, you can control to show a certain
    log message or not:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此类方法时，包含一个简单的控制语句，如 `if` 语句，可能很有用。这允许你轻松地禁用或控制插件最终版本中进行的日志记录量。使用设置调试级别的全局变量，你可以控制是否显示特定的日志消息：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In this case, the global variable `dbglvl` will dictate which messages will
    be shown. The first `if` statement will be executed with the current debug level
    (set to `3`), while the second statement will not be displayed with the current
    level. In the final version of your plugin, you can change the value of `dbglvl`
    to `1` or `0` to disable all low-level debugging statements. Note that this assumes
    that a high value for `dbglvl` is associated with minor logging statements, and
    a low value will only show the most minimal statements. Finally, you might want
    to remove all the if statements when the code is working correctly. The evaluation
    of each statement does require a finite amount of time, so it will slow down your
    code in the end.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，全局变量 `dbglvl` 将决定哪些消息将被显示。第一个 `if` 语句将以当前的调试级别（设置为 `3`）执行，而第二个语句在当前级别下将不会显示。在你的插件最终版本中，你可以将
    `dbglvl` 的值更改为 `1` 或 `0` 来禁用所有低级别的调试语句。请注意，这假设 `dbglvl` 的较高值与较小的日志语句相关联，而较低值只会显示最基本的消息。最后，当代码运行正确时，你可能想要移除所有的
    `if` 语句。每个语句的评估确实需要一定的时间，所以最终会减慢你的代码执行速度。
- en: 'When using the NetBeans IDE to develop plugins, there are more options to debug
    and profile your code. The advantage of using an IDE such as NetBeans is you can
    set breakpoints where you wish to halt the execution of the plugin and look at
    the contents of the variables. To do so, click on the margin before the line where
    you wish to stop. A red square will be displayed, indicating a breakpoint:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 NetBeans IDE 开发插件时，有更多选项可以调试和性能分析你的代码。使用像 NetBeans 这样的 IDE 的优点是，你可以在希望停止插件执行并查看变量内容的地方设置断点。要做到这一点，请点击你希望停止的行之前的边缘。将显示一个红色方块，表示断点：
- en: '![Debugging plugins](img/Insert_image_4909_08_02.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![调试插件](img/Insert_image_4909_08_02.jpg)'
- en: The entire line is also colored red to indicate the line where the debugger
    will wait when you run it. Keep in mind that if you place a breakpoint in a statement
    that will never be executed, the debugger will never stop, and your code will
    run uninterrupted.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 整行也会被涂成红色，以指示在运行时调试器将等待的行。记住，如果你在一个永远不会执行的语句中设置断点，调试器将永远不会停止，你的代码将无间断地运行。
- en: To run the code using the debugger, you can go to **Debug** | **Debug Project
    (…)** or press *Ctrl* + *F5* on the keyboard. When the debugger hits a breakpoint,
    the line will become green, and you can continue using the different step functions.
    In the variables tab at the bottom of the IDE, you will see all the variables
    that are available at the current breakpoint. Note that you can also evaluate
    expressions and change the values that are currently assigned to variables. Doing
    this may cause problems or may lead to infinite loops or crashes, so be careful
    when changing values!
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用调试器运行代码，您可以转到**调试** | **调试项目（…**）或按键盘上的*Ctrl* + *F5*。当调试器遇到断点时，该行将变为绿色，您可以使用不同的单步执行功能继续操作。在IDE底部的变量标签页中，您将看到当前断点处可用的所有变量。请注意，您还可以评估表达式并更改当前分配给变量的值。这样做可能会导致问题或可能导致无限循环或崩溃，因此在更改值时要小心！
- en: There is also a profiler to help with identifying sections of code that are
    not efficient in terms of processing speed or memory usage. However, many of these
    advanced features are not always necessary when developing simple plugins. Once
    you start Profiler by selecting **Profile** | **Profile Project (…)**, you can
    select whether you wish to monitor the CPU processing, **garbage collection**
    (**GC**) and/or memory usage. You can use the telemetry to see whether there are
    problems with excessive CPU cycles as well as problems with garbage collection
    and memory management. The use of Profiler extends a little too far beyond the
    scope of this book. However, there are excellent resources available online on
    how to use and interpret the results from profiling.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个分析器可以帮助识别在处理速度或内存使用方面效率不高的代码部分。然而，当开发简单的插件时，许多这些高级功能并非总是必要的。一旦您通过选择**分析**
    | **分析项目（…**）来启动分析器，您可以选择是否要监控CPU处理、**垃圾回收（GC**）和/或内存使用。您可以使用遥测来查看是否存在CPU周期过多以及垃圾回收和内存管理方面的问题。分析器的使用超出了本书的范围。然而，网上有关于如何使用和解释分析结果的一些优秀资源。
- en: As profiling an application is very close to an art form, use it carefully and
    only when you really notice very slow performance or memory problems in your application.
    Choosing how much development overhead you wish to dedicate for your plugin should
    always be weighed against the amount of time it gains. Spending hours of optimizing
    your code or algorithm so that it executes 1 second faster may not be worth it
    if it is called only once and is a part of a larger chain of commands. However,
    if you optimize code that is called hundreds of time within a loop, the optimization
    might be worth the extra development time many times over.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于分析应用程序非常接近一种艺术形式，因此请谨慎使用，并且仅在您真正注意到应用程序中非常缓慢的性能或内存问题时才使用。您希望为您的插件投入多少开发开销，应始终与您获得的时间量权衡。花费数小时优化代码或算法，以便它执行快1秒可能并不值得，如果它只被调用一次，并且是更大命令链的一部分。然而，如果您优化在循环中调用数百次的代码，优化可能值得额外的开发时间数倍。
- en: In the upcoming section, we will look at some plugins that are available and
    are used for scientific research.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一些可用于科学研究的插件。
- en: Examples of available plugins
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可用插件的示例
- en: 'In this section, I will discuss a few plugins that are available for ImageJ,
    most of which have also been published in scientific journals. They will show
    you how to use ImageJ for advanced image processing, with different degrees of
    automation and user interaction. They also provide a few examples of the design
    of a plugin, either with its own interface or just as a single command that executes.
    Some of these examples also have their source code available so that you can see
    how the developers implemented their algorithms. Be aware that having the source
    code and being able to understand it fully might be difficult: depending on the
    level of documentation or comments in the code. It might be very difficult to
    completely retrace the functioning of the code. As a program grows and new functions
    and algorithms are added, it deviates more from a single core algorithm to a more
    convoluted group of files. Developers using the Javadoc capabilities available
    in IDEs can create detailed documentation relatively easy, making the understanding
    of code slightly easier.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将讨论一些ImageJ可用的插件，其中大部分也已在科学期刊上发表。它们将向您展示如何使用ImageJ进行高级图像处理，具有不同程度的自动化和用户交互。它们还提供了一些插件设计的示例，无论是拥有自己的界面还是仅作为一个执行的单个命令。其中一些示例还提供了源代码，以便您可以了解开发者如何实现他们的算法。请注意，拥有源代码并完全理解它可能很困难：这取决于代码中的文档或注释水平。完全追踪代码的功能可能非常困难。随着程序的增长和新功能、算法的添加，它从单一核心算法偏离到更复杂的文件组。使用IDE中可用的Javadoc功能，开发者可以相对容易地创建详细的文档，使代码理解稍微容易一些。
- en: One point that is very important when trying to analyze source code is to realize
    which file or function is the entry point of the program. You can be sure that
    when the code executes, it will always go into this main entry point, and every
    user interaction or function will be set up in the main entry point. The entry
    points for the different types of plugins were indicated in the previous sections.
    Also, plugins developed using the SciJava framework generally have a `main()`
    method, which is not necessarily the entry point for the plugin. This depends
    on the way that the plugin was launched. When launched through the IDE using Maven,
    the `main()` method is used to instantiate ImageJ and launch the plugin. However,
    when launching the plugin from the ImageJ instance using the menu for example,
    the `main()` method will not be invoked.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试分析源代码时，一个非常重要的点是意识到哪个文件或函数是程序的入口点。你可以确信，当代码执行时，它总是会进入这个主入口点，并且每个用户交互或函数都会在主入口点设置。不同类型插件的入口点已在前面章节中指示。此外，使用SciJava框架开发的插件通常有一个`main()`方法，但这不一定是插件的入口点。这取决于插件启动的方式。当通过Maven使用IDE启动时，`main()`方法用于实例化ImageJ并启动插件。然而，当使用例如菜单从ImageJ实例启动插件时，`main()`方法将不会被调用。
- en: When using an interface for your plugin, a lot of the action comes from the
    user pressing a button, adding a number to a field or selecting an option. The
    `main` interface just waits for the user to do something. In Java, this means
    that the `ActionPerformed()` method becomes the entry point for many algorithms
    or processing. When a user clicks a button, this will fire an action event that
    can be used by the programmer to catch it and connect it to further statements.
    First, we will look at some examples of plugins that are available on the ImageJ
    website ([http://imagej.nih.gov/ij/plugins/index.html](http://imagej.nih.gov/ij/plugins/index.html))
    to show how to develop ImageJ solutions to image processing problems.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当为你的插件使用界面时，大部分动作都来自于用户按下按钮、向字段添加数字或选择一个选项。`main`界面只是等待用户进行操作。在Java中，这意味着`ActionPerformed()`方法成为许多算法或处理的入口点。当用户点击按钮时，这将触发一个动作事件，程序员可以使用它来捕获并连接到后续语句。首先，我们将查看一些在ImageJ网站上可用的插件示例（[http://imagej.nih.gov/ij/plugins/index.html](http://imagej.nih.gov/ij/plugins/index.html)），以展示如何开发ImageJ解决方案来解决图像处理问题。
- en: Example plugins available in ImageJ and Fiji
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ImageJ和Fiji中可用的示例插件
- en: ImageJ has a large collection of plugins available that extend the core functionality.
    With the arrival of ImageJ2, the model for distribution of plugins is changing
    as well. In the older ImageJ1.x framework, you were required to download a source
    file of a plugin or a compiled .class file and place it in the plugins folder.
    When the plugin was updated, you would need to repeat the whole process again.
    With ImageJ2, an updating mechanism has been provided that uses a repository system.
    In this system, communication between ImageJ and the repository will determine
    whether there are updates available. When there are updates, the user can automatically
    install the updates without having to search for the plugin.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: For most of the plugins that are available, the source code can be viewed or
    studied to look at the way other people have solved a particular image-processing
    problem. For the following example plugins, I will describe the specific problem
    or challenge they are designed to tackle. I will then show a bit of code to explain
    how the plugin tries to solve the problem. Feel free to view or download the source
    code where available to look at the complete implementation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: MultipleKymograph
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An example of such a plugin is the **MultipleKymograph** plugin (`MultipleKymograph_.java`),
    which creates a kymograph along a (segmented) line selection. It was designed
    by Jens Rietdorf and Arne Seitz from the **European Molecular Biology Laboratory**
    (**EMBL**) in Heidelberg, Germany. It contains a small set of tools and macros
    that can be used to create and measure kymographs. We already saw kymographs back
    in [Chapter 5](ch05.html "Chapter 5. Basic Measurements with ImageJ"), *Basic
    Measurements with ImageJ,* where we saw how they visualized dynamics in time series.
    There, we used the **Reslice** command to generate the kymograph, which worked
    OK, but there are a few small drawbacks of that method.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: The first problem is that **Reslice** only considers the pixels that are on
    the line that was selected. This makes it more sensitive to inaccurate placement
    of the line and pixel noise. The **MultipleKymograph** plugin is a legacy plugin
    that tries to solve this problem by providing the user with an input field to
    ask for the line width to be used to create the averaged output pixels. When the
    user calls the plugin without a line selection or an open image, it generates
    an error message indicating that action needs to be taken by the user before calling
    the plugin. As the creation of the kymograph image itself hinges on the correct
    values for the pixels, I will focus on how the plugin calculates the average pixel
    intensity for the line that was placed by the user.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'The main generation of the pixel values happens in the `sKymo(…)` method, which
    has the following definition:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `sum` variable that is returned contains the result of the averaged profiles
    along the stack. The method requires five input parameters, which are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '`ImagePlus imp`: This is the source stack that we want to use for the calculations'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImagePlus imp`: 这是我们想要用于计算的源堆栈'
- en: '`ImageProcessor ip`: This is the image processor to access the pixels of the
    stack'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageProcessor ip`: 这是用于访问堆栈像素的图像处理器'
- en: '`Roi roi`: This is the ROI that marks the line we wish to make into a kymograph'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Roi roi`: 这是要制作成轨迹图的线的标记区域（ROI）'
- en: '`int linewidth`: This is the width of the line as specified by the user input'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int linewidth`: 这是由用户输入指定的线宽'
- en: '`int proflength`: This is the length of the line specified by the user'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int proflength`: 这是由用户指定的线长'
- en: 'The method starts by declaring the parameters that will be needed for processing.
    Specifically, the output variable `sum` is defined as a `double[]` vector with
    a length equal to length of the line multiplied with the number of slices (or
    frames). The method then iterates over the slices in the stack (the outer for
    loop) and retrieves the profile using a method called `getProfile()` or `getIrregularProfile()`.
    These methods extract the pixel values from the selection, where the shift parameter
    determines how far the line is shifted compared to the selection. The only difference
    between the two is that one is meant to be used for straight lines (`getProfile`),
    while the other is used for segmented lines (`getIrregularProfile`). For the sake
    of brevity, I will only show the code for the former method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 方法首先声明处理所需的参数。具体来说，输出变量`sum`被定义为长度等于线长度乘以切片数（或帧数）的`double[]`向量。然后方法遍历堆栈中的切片（外层for循环）并使用名为`getProfile()`或`getIrregularProfile()`的方法检索轮廓。这些方法从选择中提取像素值，其中位移参数确定线相对于选择的移动距离。两者之间的唯一区别是，一个用于直线（`getProfile`），而另一个用于分割线（`getIrregularProfile`）。为了简洁起见，我将只展示前者的代码：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method takes the ROI that the user specified and shifts it by the amount
    specified in the `shift` parameter. It then uses the `getPixels()` method from
    the `Roi` class to extract the gray values and returns them. As a line is defined
    by only two points, each with an *x* and *y* coordinate, this method is fairly
    brief. The irregular case requires that the line is moved along all the *N* coordinates
    required to define the segmented line. Otherwise, it functions in the same way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受用户指定的ROI，并将其在`shift`参数指定的量上移动。然后它使用`Roi`类的`getPixels()`方法提取灰度值并返回它们。由于线仅由两个点定义，每个点都有一个*x*和*y*坐标，因此此方法相当简短。不规则情况要求将线沿所有定义分割线的*N*个坐标移动。否则，它以相同的方式工作。
- en: ColorTransformer2
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ColorTransformer2
- en: This legacy plugin is useful when dealing with color images such as those acquired
    by digital color cameras or videos from cameras such as webcams. It was originally
    developed by Maria E. Barilla as **ColorTransformer** and modified by Russel Cottrell,
    resulting in the **ColorTransformer2** plugin. The source code can be found at
    [http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java](http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个遗留插件在处理彩色图像时很有用，例如由数码彩色相机或网络摄像头等设备获取的图像。它最初由Maria E. Barilla开发为**ColorTransformer**，并由Russel
    Cottrell修改，形成了**ColorTransformer2**插件。源代码可以在[http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java](http://www.russellcottrell.com/photo/downloads/Color_Transformer_2.java)找到。
- en: 'A problem with color images, such as RGB images, is that the intensity is not
    well-defined in the RGB color space. Light blue might appear more intense than
    dark blue, but the intensity value for the blue channel might be higher for dark
    blue than for light blue. In order to segment RGB images effectively based on
    specific colors, it is better that you transform it to a color space that is more
    suited for this purpose. The HSB color space separates an image in three components:
    **Hue**, **Saturation**, and **Brightness** (sometimes also labeled as **Value**
    or **Intensity**). The hue indicates the color ranging from red to orange, yellow,
    green, cyan, blue, and magenta. See [Chapter 2](ch02.html "Chapter 2. Basic Image
    Processing with ImageJ"), *Basic Image Processing with ImageJ* for details on
    the use of the HSB color space.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: This plugin implements a `PlugInFilter`, meaning that it overrides the `setup()`
    and `run()` methods, which form the entry points for the plugin. The setup method
    checks whether an image is open and screens the type of image that this plugin
    can process. The run method shows a dialog, which allows the user to choose the
    color space to convert from and to. The method I want to describe here is the
    conversion from RGB to HSI, which is a common format to use in segmentation of
    RGB images where segmentation needs to be performed based on color.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'The main method that performs the actual RGB-to-HSI conversion is the `getHSI()`
    method. This method looks as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These conversions are based on the methodology described in *Color Vision and
    Colorimetry, Theory and Applications*, *D Malacara*. The transformation is based
    on transforming the original RGB values stored in the `rf`, `gf`, and `bf` arrays,
    respectively. The transformed values are stored in the `c1`, `c2`, `c3`, and optionally,
    `c4` arrays. For the transformation to HSI, the `c4` array is not used, as an
    HSI image only has three channels. For example, the CMYK color space requires
    all four channels. At the end of the run method, the values for the channels are
    placed in a new image, which will be the transformed image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: MtrackJ
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This plugin is useful when you wish to track objects over time and, optionally,
    in three dimensions. It was developed by Eric Meijering at the University of Lausanne
    in Switzerland. The source code can be found on GitHub at [https://github.com/fiji/MTrackJ/](https://github.com/fiji/MTrackJ/).
    It was published in *Methods in Enzymology*, *vol 504* in February 2012\. The
    main interface of the plugin consists of groups of buttons that allow you to add,
    delete, or move tracks or points and perform measurements or change settings:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![MtrackJ](img/Insert_image_4909_08_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: 'The function of this plugin is to track objects or particles over time in order
    to establish their speed and direction. Although automated tracking algorithms
    do exist, some data is just too difficult or too dense for automated tracking
    algorithms to cope with. For these types of challenges, this plugin will provide
    a tool that can help establish useful parameters for objects. The goal of this
    plugin is similar to that of the **MultipleKymograph** plugin described earlier:
    measuring the velocity of multiple objects. When the tracks are created and measured,
    the results are presented in a results window. These results can then be used
    for direct plotting and analysis outside of ImageJ or as input for more advanced
    analysis.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'As this plugin is quite extensive and has many features, I will focus on one
    very tiny detail that makes this interface great to track objects with amazing
    accuracy. In the options for tracking, accessed through the **Tracking** button,
    you can set a snapping function for the mouse cursor. This type of feature might
    be familiar to many people. Many different applications use it to make it easier
    to align objects nice and evenly. When you check the **Apply local cursor snapping
    during tracking** checkbox, you can choose a snap feature. This snap feature will
    determine when you position your mouse cursor over an object where the tracking
    point will be added. Without snapping, it would be placed at the pixel that you
    clicked. However, when using **bright centroid** as the snap feature, something
    interesting will happen (when using fluorescent images). When you add a tracking
    point by clicking, **MtrackJ** determines the centroid of the snap range that
    you defined. The centroid is the weighted intensity point and is not necessarily
    a single pixel, but it can be a position such as (*x = 12.4, y = 13.45*). For
    image data with good signal-to-noise ratio, you can achieve better tracking resolution
    than the optical system can provide (so-called subpixel resolution). The location
    of the snap coordinates are calculated in a method called `snapcoords()`. I will
    not reproduce the entire method as it is quite extensive, but I will show you
    how it achieves the bright centroid calculation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As the plugin supports multiple methods for snapping, there are multiple cases
    in this `switch` statement, which I omitted for the sake of brevity. The goal
    of the method is to assign values to the `snapos.x` and `snapos.y` variables.
    For the bright centroid method, a threshold is used based on the **Otsu** method.
    In the first loop using the *x* and *y* indices, we went over the pixels of the
    snapping rectangle and sum all the pixel intensities (`val`) that are above the
    threshold value (`thres`) in `sum2` and the intensities below the threshold in
    `sum1`. We used these to calculate the variation, and if it exceeds the maximum
    value in the rectangle, we adjust the value and the Otsu threshold value.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second loop over the pixels in the snapping rectangle, the centroid
    is determined by summing the products of each pixel''s *x* and *y* coordinates
    multiplied by the intensity above the Otsu threshold. A running sum of the intensities
    above the threshold is also kept and used to divide the final coordinates with.
    These final values are used in the `draw()` method function that shows the bright
    centroid in the image:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This method uses a `Graphics2D` object referenced by `g2d` to create a square
    box indicating the snap region (the `// Snap ROI` section), whose size is determined
    by the values of the `snaprect` object. Finally, it draws a small `+` to indicate
    the snap coordinate defined by the `snapos.x` and `snapos.y` variables (the `//
    Snap cursor` section).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: Coloc2
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For certain types of research questions, it is important to know whether two
    objects overlap or colocalize. The **Coloc2** is a plugin included in the `Colocalisation_Analysis.jar`
    file as developed by Daniel J. White, Tom Kazimiers, and Johannes Schindelin.
    The source is available on GitHub at [https://github.com/fiji/Colocalisation_Analysis/](https://github.com/fiji/Colocalisation_Analysis/).
    The Coloc2 command is used to measure colocalization between two images, usually
    representing different channels in fluorescent images.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'The main functionality is placed in the `colocalise` method, which compares
    the pixel intensities between the two images using different methods. As an example
    of how this plugin functions, I will look at a more basic function that is used
    whenever a selection is present in the ROI manager and needs to be used for the
    colocalization analysis. The method is called `createMasksFromRoiManager`, and
    it calls a second method called `createMasksAndRois`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first step is to retrieve the ROIs from the manager using the `getSelectedRoisAsArray()`
    method, which then passes the ROIs to the `createMasksAndRois` method. This method
    stores the regions in the `mi.mask` variable where it can be used by the `colocalise`
    method. This plugin uses some constructs derived from ImageJ2\. The `ImagePlusAdapter`
    is a wrapper function from the `ImgLib2` library. This convenience method allows
    ImageJ1.x images to be placed inside an `ImgLib2` container as used by ImageJ2\.
    These functions are essential during the transition between ImageJ1.x and ImageJ2
    and allow for interoperability. Next, I will take a look at a plugin that was
    developed within the SciJava framework using the annotations and the **Command
    and Service framework** specifically for ImageJ2.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Goutte_pendante
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Goutte_pendante** plugin (pendant drop) is a plugin built under the SciJava
    framework by Adrian Daerr at the Université Paris Diderot. The source code can
    be found on GitHub at [https://github.com/adaerr/pendent-drop](https://github.com/adaerr/pendent-drop).
    This project is written using the Maven system, so I will briefly show the `pom.xml`
    file as an example of how to define a plugin within the framework:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can see that the project description is very simple using the POM model.
    The `<parent>` tag describes that this utilizes ImageJ. The dependencies state
    that the ImageJ2 code base should be used, as identified by the `<artifactId>`
    tag using `imagej` instead of `ij` for ImageJ1.x plugins. Plugins built for ImageJ2
    also tend to have a `main` method. To illustrate its function, I will highlight
    some of the code from this plugins'' `main` method:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This code is only used when testing the plugin and performs a few steps that
    are useful when testing code but not when actually using the plugin outside of
    the testing phase. It starts by defining a test image with a hard-coded path string.
    It then performs the step that all plugins for ImageJ will perform in their main
    method: launching an instance of ImageJ. It then goes on to open the image specified
    by the string using `IOService` and finally displaying it using the `ImageDisplay`
    service. The result of this process is the image of a drop hanging from an aperture:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Goutte_pendante](img/Insert_image_4909_08_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Next, a `rectangle` object is generated over the drop image that was opened.
    This image will be used as an initial search space for the plugin to detect the
    drop. This is done using the `RectangleOverlay` class in the `net.imagej.overlay`
    package. Finally, it adds the overlay to the display and displays the image before
    calling the plugin in the last statement of the method:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The used pattern in this plugin is similar to that described in the previous
    chapter. However, there are additional steps inserted here to make sure that the
    plugin works fast and correctly. If you would install the plugin using **Update
    site** through Fiji and try to run it immediately by selecting **Plugins** | **Drop
    Analysis** | **Pendant Drop** from the menu, you will get an error message. This
    error message states that there is an error executing the `Goutte_pendante#paramInitializer`
    method. If you run **Plugins** | **Drop Analysis** | **About Pendant Drop**, you
    will see a brief explanation and a usage section for the plugin. In the usage
    section, there will be an explanation of why it failed. There was no rectangular
    ROI or image when you launched it. At the bottom of the about dialog, there are
    buttons with information and documentation, as well as a way to retrieve the image
    of the drop (bottom button).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of this plugin is to fit the shape of the drop, and the parameters
    of that fit can be used to say something about the surface tension of the liquid.
    To do so, it needs a class that describes the shape of the drop that is defined
    as an object called `Contour` within the plugin. It needs to fit a polynomial
    to the drop shape in order to determine `Contour` parameters. To do so, it is
    necessary to determine the borders of the drop. This is achieved by a method called
    `findDropBorders()`. This function will find the shoulders of the drop and store
    the locations in arrays for the left and right borders:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This method performs a line scan method to find the index where the drop falls
    below the threshold. In this case, the drop has a low value compared to the background.
    It starts by going in the left-to-right direction. As soon as it has found that
    pixel, the variable `xl` will no longer increase and will be smaller than the
    width of the bounds. This will activate the `else if` clause and will allocate
    the arrays for the borders. The next step is to determine the index on the right-hand
    side using the same methodology. However, now, the search goes in the right-to-left
    direction, starting at the bounding box, and will determine `xr`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'The code mentioned in this method is generic Java code that is not specific
    for ImageJ2, but it performs the task in a similar way. It illustrates the fact
    that ImageJ2 plugins are not necessarily more complicated than or different from
    their legacy counterparts in terms of development. A difference between this plugin
    and a legacy plugin is the use of services such as the `LogService` interface.
    When the plugin is launched, it requests an instance of `LogService` using the
    `@Parameter` annotation:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the functional part of the plugin, this service is called to perform the
    logging of errors and other messages. An example can be found in the `run()` method
    of the plugin:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The log variable can be used to write messages to the log window. Based on the
    function used, they will be preceded by a label that indicates the type of the
    message. Methods such as `error`, `warn`, and `info` allow for different categories
    of messages to be reported.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the anatomy of plugins for ImageJ1.x and ImageJ2\.
    We also looked at some of the specific constructs that are used in plugins for
    both frameworks. We examined how to compile, run, and debug our plugins using
    the tools provided by ImageJ or using the IDE. We looked at some established plugins
    and how they implemented plugins to perform a task in image processing.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge will be applied in the next chapter where we will create a plugin
    from scratch to perform image processing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
