- en: Chapter 7. Providing a Persistence Layer with Apache Aries and OpenJPA
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 使用Apache Aries和OpenJPA提供持久层
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Installing OpenJPA modules in Apache Karaf
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装OpenJPA模块
- en: Installing Apache Aries JTA modules in Apache Karaf
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装Apache Aries JTA模块
- en: Building a project with a persistence layer for deployment in Karaf
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个具有持久层以在Karaf中部署的项目
- en: Building a project with a persistence layer and transaction support for deployment
    in Karaf
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建一个具有持久层和事务支持的项目以在Karaf中部署
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Your applications will commonly need to safely persist data and make use of
    transactional behaviors. A preferred way to accomplish this for Java developers
    is to use the **Java Persistence API** (**JPA**) and **Java Transaction API**
    (**JTA**). In the context of Apache Karaf, developers will use an OSGi-ready JPA
    implementation, such as **Apache OpenJPA**, **EclipseLink**, or **Hibernate**
    and the **Apache Aries JTA**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用程序通常需要安全地持久化数据并利用事务行为。对于Java开发者来说，完成此任务的一个首选方法是使用**Java持久化API**（**JPA**）和**Java事务API**（**JTA**）。在Apache
    Karaf的上下文中，开发者将使用一个OSGi兼容的JPA实现，例如**Apache OpenJPA**、**EclipseLink**或**Hibernate**以及**Apache
    Aries JTA**。
- en: This book will use OpenJPA as an implementation of the JPA specification for
    the transparent persistence of Java objects. In relation to OSGi containers, it
    provides container-managed persistence for the Blueprint container.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将使用OpenJPA作为JPA规范的实现，以实现Java对象的透明持久化。与OSGi容器相关联时，它为Blueprint容器提供容器管理的持久化。
- en: 'The Apache Aries JTA provides a transaction management service to the container.
    Using this service, developers can build applications requiring the following
    transactional flow:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Aries JTA为容器提供事务管理服务。使用此服务，开发者可以构建需要以下事务流程的应用程序：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The previous pseudo code outlines the general form of a transaction; the developer
    obtains from the container a transaction session, demarks the beginning of the
    transaction, performs their business logic and, then must decide if they can commit
    the transaction or rollback resources.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的伪代码概述了事务的一般形式；开发者从容器中获取事务会话，标记事务的开始，执行他们的业务逻辑，然后必须决定他们是否可以提交事务或回滚资源。
- en: The recipes in this chapter will aid you in deploying JPA and JTA resources
    into Karaf, and guide you by example to use these APIs in your bundles.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的食谱将帮助您将JPA和JTA资源部署到Karaf中，并通过示例指导您如何在您的捆绑包中使用这些API。
- en: Installing OpenJPA modules in Apache Karaf
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Apache Karaf中安装OpenJPA模块
- en: Before we can begin to explore how to build OpenJPA-backed applications, we
    must first install all the required JPA modules into the Karaf container.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索如何构建由OpenJPA支持的应用程序之前，我们必须首先将所有必需的JPA模块安装到Karaf容器中。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的成分包括Apache Karaf发行套件、JDK访问权限和互联网连接。
- en: How to do it…
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Thanks to Apache Karaf''s feature system, installing OpenJPA is a very simple
    two-step process: install the JPA and OpenJPA feature in Karaf. The steps are
    as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了Apache Karaf的功能系统，安装OpenJPA是一个非常简单的两步过程：在Karaf中安装JPA和OpenJPA功能。步骤如下：
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why do we not have to add the feature URL? This is because Apache Karaf's standard
    distribution includes the JPA and OpenJPA feature URLs by default.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不需要添加功能URL？这是因为Apache Karaf的标准发行版默认包含JPA和OpenJPA功能URL。
- en: 'We can install a feature by executing the `feature:install` command with the
    feature''s name as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过执行带有功能名称的`feature:install`命令来安装一个功能，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We can verify the installation by executing the `list –t 0 | grep -i JPA` command,
    which will list all installed OpenJPA components and dependencies in Karaf (Geronimo-jta_1.1_spec,
    Geronimo-jpa_2.0_spec, Aries JPA API, Aries JPA Blueprint, Aries JPA Container,
    and Aries JPA Container Context).
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过执行`list –t 0 | grep -i JPA`命令来验证安装，该命令将在Karaf中列出所有安装的OpenJPA组件和依赖项（Geronimo-jta_1.1_spec、Geronimo-jpa_2.0_spec、Aries
    JPA API、Aries JPA Blueprint、Aries JPA Container和Aries JPA Container Context）。
- en: Similar to the installation of the JPA, we use the feature's name to install
    the OpenJPA engine, as follows.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与JPA的安装类似，我们使用功能名称来安装OpenJPA引擎，如下所示。
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can verify the installation by executing the `list –t 0 | grep -i OpenJPA`
    command, which will list all installed OpenJPA components and dependencies in
    Karaf (core among them is the OpenJPA Aggregate JAR).
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `list –t 0 | grep -i OpenJPA` 命令来验证安装，该命令将列出 Karaf 中所有已安装的 OpenJPA
    组件和依赖项（其中核心是 OpenJPA 聚合 JAR）。
- en: How it works…
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'The Apache Karaf community maintains an Apache Karaf feature descriptor for
    JPA and OpenJPA. These feature descriptor files contain all of the essential bundles
    and dependencies required to install these APIs and providers, which are shown
    in the following diagram:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Karaf 社区维护了一个用于 JPA 和 OpenJPA 的 Apache Karaf 功能描述符。这些功能描述符文件包含了安装这些 API
    和提供者所需的全部基本包和依赖项，如下面的图示所示：
- en: '![How it works…](img/5081OS_07_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_07_01.jpg)'
- en: When the JPA or OpenJPA feature is installed (using the `feature:install` command),
    Karaf will use the appropriate URL handlers to obtain the required resources and
    install them into the container. Next, it attempts to bring them to a started
    state. If you execute the `list –t 0` command on the Karaf console, you will see
    the JPA and all other artifacts deployed into the container. We can depict the
    integration of OpenJPA components into Karaf more simply by illustrating the key
    artifacts being deployed atop a standard Karaf installation.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当安装 JPA 或 OpenJPA 功能（使用 `feature:install` 命令）时，Karaf 将使用适当的 URL 处理程序来获取所需资源并将它们安装到容器中。接下来，它尝试将它们启动。如果你在
    Karaf 控制台中执行 `list –t 0` 命令，你将看到部署到容器中的 JPA 和所有其他工件。我们可以通过展示关键工件被部署在标准 Karaf 安装之上，更简单地描述
    OpenJPA 组件与 Karaf 的集成。
- en: See also
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Deploying applications as a feature* recipe of [Chapter 1](ch01.html "Chapter 1. Apache
    Karaf for System Builders"), *Apache Karaf for System Builders*.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。Apache Karaf for System Builders")中“将应用程序作为功能部署”的食谱，*Apache
    Karaf for System Builders*。'
- en: Installing Apache Aries JTA modules in Apache Karaf
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Apache Karaf 中安装 Apache Aries JTA 模块
- en: Applications often require transaction management alongside the JPA. This is
    accomplished by including the JTA into the Karaf container.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常需要与 JPA 一起进行事务管理。这是通过将 JTA 包含到 Karaf 容器中实现的。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity. Generally, you'll also need to perform the
    steps outlined in the *Installing OpenJPA modules in Apache Karaf* recipe.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的成分包括 Apache Karaf 分发套件、对 JDK 的访问以及互联网连接。通常，你还需要执行“在 Apache Karaf 中安装 OpenJPA
    模块”食谱中概述的步骤。
- en: How to do it…
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Thanks to Apache Karaf's feature system, installing JTA is a very simple one-step
    process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢 Apache Karaf 的功能系统，安装 JTA 是一个非常简单的单步过程。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Why do we not have to add the feature URL? This is because Apache Karaf's standard
    distribution includes the JTA feature URL by default.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不需要添加功能 URL？这是因为 Apache Karaf 的标准分发版默认包含了 JTA 功能 URL。
- en: Installing the JTA feature into Karaf
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 JTA 功能安装到 Karaf 中
- en: 'We install a feature by executing the `feature:install` command with the feature''s
    name as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过执行以下命令来安装功能：`feature:install` 命令，其中包含功能的名称：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We can verify the installation by executing the `list –t 0 | grep -i transaction`
    command, which will list all installed transaction components and dependencies
    in Karaf (such as Apache Aries Transaction Blueprint and Apache Aries Transaction
    Manager). In addition, we can verify that `geronimo_jta_1.1_spec` has been installed
    by grepping on `jta`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `list –t 0 | grep -i transaction` 命令来验证安装，该命令将列出 Karaf 中所有已安装的事务组件和依赖项（例如
    Apache Aries 事务蓝图和 Apache Aries 事务管理器）。此外，我们还可以通过在 `jta` 上进行 grep 操作来验证 `geronimo_jta_1.1_spec`
    是否已安装。
- en: How it works…
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'The Apache Karaf community maintains an Apache Karaf features descriptor for
    JTA. The features descriptor file contains all of the essential bundles and dependencies
    required to install the transaction manager, which are shown in the following
    diagram:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Karaf 社区维护了一个用于 JTA 的 Apache Karaf 功能描述符。功能描述符文件包含了安装事务管理器所需的所有基本包和依赖项，如下面的图示所示：
- en: '![How it works…](img/5081OS_07_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_07_02.jpg)'
- en: When the JTA feature is installed (using the `feature:install` command), Karaf
    will use the appropriate URL handlers to obtain the required resources and install
    them in the container. Next, it attempts to bring them to a started state. If
    you execute the `list –t 0` command on the Karaf console, you will see the JTA
    and all other artifacts deployed into the container. We can depict the integration
    of JTA components into Karaf more simply by illustrating the key artifacts being
    deployed atop a standard Karaf installation. In this deployment, we see the Transaction
    Manager (JTA) deployed among the various JPA modules from the *Installing OpenJPA
    modules in Apache Karaf* recipe.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当 JTA 功能被安装（使用`feature:install`命令）时，Karaf 将使用适当的 URL 处理程序来获取所需资源并将它们安装到容器中。接下来，它尝试将它们带到启动状态。如果您在
    Karaf 控制台中执行`list –t 0`命令，您将看到部署到容器中的 JTA 和所有其他工件。我们可以通过展示关键工件被部署在标准 Karaf 安装之上来更简单地描述
    JTA 组件与 Karaf 的集成。在这个部署中，我们看到事务管理器（JTA）被部署在“在 Apache Karaf 中安装 OpenJPA 模块”食谱中的各种
    JPA 模块之间。
- en: See also
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Deploying applications as a feature* recipe of [Chapter 1](ch01.html "Chapter 1. Apache
    Karaf for System Builders"), *Apache Karaf for System Builders*
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “第 1 章”中关于[将应用程序作为功能部署](ch01.html "第 1 章。Apache Karaf for System Builders")的食谱，*Apache
    Karaf for System Builders*
- en: The *Installing OpenJPA modules in Apache Karaf* recipe
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: “在 Apache Karaf 中安装 OpenJPA 模块”食谱
- en: Building a project with a persistence layer for deployment in Karaf
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Karaf 中构建具有持久层的项目
- en: Application developers often need to make use of a persistence layer in their
    projects; one of the preferred methodologies to perform this in Karaf is to make
    use of the Java Persistence API and OpenJPA.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发人员通常需要在他们的项目中使用持久层；在 Karaf 中执行此操作的一种首选方法是使用 Java 持久性 API 和 OpenJPA。
- en: In the *Installing OpenJPA modules in Apache Karaf* recipe, we learned how to
    install OpenJPA in Karaf; in this recipe, we'll make use of the JPA and OpenJPA
    to build a simple application that persists recipes to a database using a `RecipeBookService`
    class, which will hide the complexities of data storage and retrieval from its
    users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在“在 Apache Karaf 中安装 OpenJPA 模块”食谱中，我们学习了如何在 Karaf 中安装 OpenJPA；在本食谱中，我们将使用 JPA
    和 OpenJPA 来构建一个简单的应用程序，该应用程序使用`RecipeBookService`类将食谱持久化到数据库中，这将隐藏数据存储和检索的复杂性，使其用户难以察觉。
- en: Getting ready
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity. Sample code for this recipe is available at
    [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3).
    Generally, you'll also need to perform the steps outlined in the *Installing OpenJPA
    modules in Apache Karaf* recipe.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的成分包括 Apache Karaf 分发套件、对 JDK 的访问以及互联网连接。本食谱的示例代码可在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3)找到。通常，您还需要执行“在
    Apache Karaf 中安装 OpenJPA 模块”食谱中概述的步骤。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Please uninstall contents of the *Building a project with a persistence layer
    and transaction support for deployment in Karaf* recipe before attempting this
    recipe as conflicts may occur. This recipe comes later in the chapter.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试此食谱之前，请先卸载“在 Karaf 中构建具有持久层和事务支持的部署项目”食谱的内容，因为可能会发生冲突。本食谱在本章的后面部分。
- en: How to do it…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Building a project with a JPA persistence layer will require the following
    nine steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Karaf 中构建具有 JPA 持久层的项目需要以下九个步骤：
- en: The first step is generating a Maven-based bundle project. Create an empty Maven-based
    project. A `pom.xml` file containing the essential Maven coordinate information
    and a bundle packaging directive will suffice.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是生成基于 Maven 的包项目。创建一个空的基于 Maven 的项目。一个包含基本 Maven 坐标信息和包打包指令的`pom.xml`文件就足够了。
- en: 'The next step is adding dependencies to the POM file as shown in the following
    code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是在 POM 文件中添加依赖项，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For Karaf 3.0.0, we use OpenJPA 2.2.2 and OSGi version 5.0.0.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于 Karaf 3.0.0，我们使用 OpenJPA 2.2.2 和 OSGi 版本 5.0.0。
- en: 'The next step is adding build plugins. Our recipe requires two build plugins
    to be configured: OpenJPA and bundle.'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加构建插件。我们的食谱需要配置两个构建插件：OpenJPA 和 bundle。
- en: 'First, we configure the `openjpa-maven-plugin`. The `openjpa-maven-plugin`
    provides tasks for building and maintaining an OpenJPA-based project. We add to
    our POM file the following plugin configuration:'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们配置`openjpa-maven-plugin`。`openjpa-maven-plugin`为基于 OpenJPA 的项目提供构建和维护的任务。我们在
    POM 文件中添加以下插件配置：
- en: '[PRE5]'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `openjpa-maven-plugin`, given in the previous block of code, we instruct
    the plugin to perform an enhance process upon our entity classes to provide the
    persistence functionality. As stated by the OpenJPA project: "Build time enhancement
    is the recommended method to use with OpenJPA, as it is the fastest and most reliable
    method".'
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码块中给出的 `openjpa-maven-plugin` 中，我们指示插件在实体类上执行增强过程以提供持久化功能。正如 OpenJPA 项目所述：“构建时增强是使用
    OpenJPA 的推荐方法，因为它是最快且最可靠的方法”。
- en: 'Next, we configure the `maven-bundle-plugin`. We configure the `maven-bundle-plugin`
    to assemble our project code into an OSGi bundle. We add the following plugin
    configuration to our POM file:'
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们配置 `maven-bundle-plugin`。我们将 `maven-bundle-plugin` 配置为将我们的项目代码组装成一个 OSGi
    包。我们向我们的 POM 文件中添加以下插件配置：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As highlighted in the previous code snippet, the `Meta-Persistence` tag will
    add an entry to our bundle's manifest file pointing to our `persistence.xml` file
    location (we'll create this resource in our next step). The import statements
    for the `javax.persistence`, `dbcp`, and `derby` packages are of greatest importance
    for our example project. The Felix and Karaf imports are required by the optional
    Karaf commands.
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前一个代码片段中突出显示的，`Meta-Persistence` 标签将向我们的包的清单文件中添加一个条目，指向我们的 `persistence.xml`
    文件位置（我们将在下一步中创建此资源）。对于我们的示例项目，`javax.persistence`、`dbcp` 和 `derby` 包的导入语句至关重要。Felix
    和 Karaf 的导入是可选的 Karaf 命令所必需的。
- en: 'The next step is creating the persistence descriptor file. Create a directory
    tree as `src/main/resources/META-INF` in your project. We''ll then create a file
    named `persistence.xml` in this folder. This file is shown in the following code
    snippet:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建持久化描述符文件。在你的项目中创建一个名为 `src/main/resources/META-INF` 的目录树。然后，我们将在这个文件夹中创建一个名为
    `persistence.xml` 的文件。此文件如下代码片段所示：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The persistence descriptor file contains a multitude of configuration entries
    required by our application. The most important among them being the definition
    of the `persistence-unit` and `non-jta-data-source` objects; the former sets the
    data persistence to `RESOURCE_LOCAL`, and the latter sets the use of a JDBC service
    for non-transactional data storage. The various OpenJPA properties are beyond
    the scope of this book, but they are included here to provide a sample configuration.
    The more interesting part of the previous example is the reference of the datasource.
    Since the `persistence.xml` file only knows of JNDI lookup syntax for resources,
    the OSGi service of the datasource needs to be referenced in a JNDI way. This
    results in `osgi:service` being the JNDI lookup for an OSGi service that provides
    a `javax.sql.DataSource` interface where the filter matches the `osgi.jndi.service.name`
    value as equivalent to `jdbc/demo`.
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 持久化描述符文件包含我们应用程序所需的大量配置条目。其中最重要的是 `persistence-unit` 和 `non-jta-data-source`
    对象的定义；前者将数据持久化设置为 `RESOURCE_LOCAL`，后者设置使用 JDBC 服务进行非事务性数据存储。各种 OpenJPA 属性超出了本书的范围，但它们被包含在这里以提供示例配置。上一个示例中更有趣的部分是数据源的引用。由于
    `persistence.xml` 文件只知道资源的 JNDI 查询语法，因此需要以 JNDI 方式引用数据源的 OSGi 服务。这导致 `osgi:service`
    是一个提供 `javax.sql.DataSource` 接口的 OSGi 服务的 JNDI 查询，其中过滤器匹配 `osgi.jndi.service.name`
    值，相当于 `jdbc/demo`。
- en: 'The next step is creating the Blueprint descriptor file. In your project, create
    the `src/main/resources/OSGI-INF` directory tree. We''ll then create a file named
    `blueprint.xml` in this folder as follows:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建 Blueprint 描述符文件。在你的项目中，创建 `src/main/resources/OSGI-INF` 目录树。然后，我们将在这个文件夹中创建一个名为
    `blueprint.xml` 的文件，如下所示：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You should note the inclusion of the `DataSource` service as an OSGi service
    in this `blueprint.xml` file. It contains the service property `osgi.jndi.service.name`
    with the value `jdbc/demo`. This is the `DataSource` service that is referenced
    by the `persistence.xml` file.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你应该注意在 `blueprint.xml` 文件中将 `DataSource` 服务作为 OSGi 服务包含在内。它包含服务属性 `osgi.jndi.service.name`，其值为
    `jdbc/demo`。这是 `persistence.xml` 文件所引用的 `DataSource` 服务。
- en: 'The next step is developing the OSGi service with the JPA backend. We''ve created
    the basic project structure and plumbed in configurations for the persistence
    and Blueprint descriptors; now we''ll focus on the underlying Java code of our
    JPA-backed application. We break down this process into the following three steps:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是开发具有 JPA 后端的 OSGi 服务。我们已经创建了基本的项目结构，并配置了持久化和 Blueprint 描述符的配置；现在我们将专注于我们
    JPA 支持的应用程序的底层 Java 代码。我们将此过程分解为以下三个步骤：
- en: 'The first step is defining a service interface. The service interface will
    define the user API for our project. In our sample code, we implement a `RecipeBookService`
    class, which provides the methods required to interact with a collection of recipes.
    This is shown in the following code:'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是定义服务接口。服务接口将定义我们项目的用户 API。在我们的示例代码中，我们实现了一个 `RecipeBookService` 类，它提供了与一系列食谱交互所需的方法。这在上面的代码中显示：
- en: '[PRE9]'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The interface's implementation follows the standard Java conventions, requiring
    no special OSGi packages.
  id: totrans-81
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接口的实现遵循标准的 Java 规范，不需要特殊的 OSGi 包。
- en: 'The next step is implementing a service DAO. Now that we have defined our service
    interface, we''ll provide an implementation as a DAO. Consider the following code:'
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现服务 DAO。现在我们已经定义了服务接口，我们将提供一个作为 DAO 的实现。考虑以下代码：
- en: '[PRE10]'
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `EntityManagerFactory` function will be wired into our DAO using Blueprint.
    Each service method implemented in our DAO service implementation will require
    management of the JPA-style transaction elements.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`EntityManagerFactory` 函数将通过 Blueprint 连接到我们的 DAO。我们 DAO 服务实现中实现的每个服务方法都需要管理
    JPA 风格的事务元素。'
- en: 'The next step is implementing entities. Finally, we implement our entities
    as shown in the following code:'
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现实体。最后，我们按照以下代码实现我们的实体：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our `Entity` class is where our objects meet their persistent storage definition
    requirement. To store an object into a database, we must describe their storage
    in terms of tables, columns, and so on, and override the `equals` and `hashCode`
    methods.
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的 `Entity` 类是我们对象满足其持久化存储定义要求的地方。要将对象存储到数据库中，我们必须用表、列等术语描述其存储，并重写 `equals`
    和 `hashCode` 方法。
- en: 'The next step is the optional creation of Karaf commands to directly test the
    persistence service. To simplify manual testing of our `RecipeBookService` class,
    we can create a set of custom Karaf commands, which will exercise our JPA-backed
    data storage and retrieval operations. Sample implementations of these commands
    are available from the book''s website. Of particular interest is how they obtain
    a reference to the `RecipeBookService` class and make calls to the service. Now,
    we must wire the command implementation into Karaf via Blueprint as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是可选的创建 Karaf 命令以直接测试持久化服务。为了简化对 `RecipeBookService` 类的手动测试，我们可以创建一组自定义 Karaf
    命令，这些命令将测试我们的基于 JPA 的数据存储和检索操作。这些命令的示例实现可在本书的网站上找到。特别值得注意的是，它们如何获取 `RecipeBookService`
    类的引用并对服务进行调用。现在，我们必须通过 Blueprint 将命令实现连接到 Karaf，如下所示：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Each of our custom command's implementation classes are wired to our `recipeBookService`
    instance.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们每个自定义命令的实现类都连接到我们的 `recipeBookService` 实例。
- en: 'The next step is deploying the project into Karaf. Deploying our application
    in Karaf will require the following three steps: installing a JDBC driver for
    a backing database, installing JNDI, and adding our project bundle to the container.
    For our example project, we''ll use Apache Derby as our JDBC provider.'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将项目部署到 Karaf。在 Karaf 中部署我们的应用程序需要以下三个步骤：为后端数据库安装 JDBC 驱动程序、安装 JNDI 以及将我们的项目包添加到容器中。对于我们的示例项目，我们将使用
    Apache Derby 作为我们的 JDBC 提供者。
- en: 'We can install the JDBC driver using the following command:'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令安装 JDBC 驱动程序：
- en: '[PRE13]'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Once installed, you can check whether the client driver is available by executing
    the classes command and grepping upon the `ClientDataSource` implementation.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完成后，您可以通过执行类命令并 grep `ClientDataSource` 实现来检查客户端驱动程序是否可用。
- en: Tip
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This demo will require a running instance of the Derby database. See [http://db.apache.org/derby/papers/DerbyTut/install_software.html](http://db.apache.org/derby/papers/DerbyTut/install_software.html)
    for a short tutorial on installing Apache Derby.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此演示需要一个正在运行的 Derby 数据库实例。请参阅 [http://db.apache.org/derby/papers/DerbyTut/install_software.html](http://db.apache.org/derby/papers/DerbyTut/install_software.html)
    以获取安装 Apache Derby 的简短教程。
- en: 'We need to install the `jndi` feature using the following command:'
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要使用以下命令安装 `jndi` 功能：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once the `jndi` feature is installed in Karaf, we'll be able to use the `jndi:names`
    command to view the configured datasources in the container.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Karaf 中安装 `jndi` 功能后，我们将能够使用 `jndi:names` 命令查看容器中配置的数据源。
- en: 'We install our project bundle by executing the `install` command on its Maven
    coordinates as follows:'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过在其 Maven 坐标上执行 `install` 命令来安装我们的项目包，如下所示：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can verify the installation by executing the `list –t 0 | grep -i JPA-only`
    command, which will list the bundle state of our project.
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过执行`list –t 0 | grep -i JPA-only`命令来验证安装，这将列出我们项目的捆绑包状态。
- en: 'The last step is testing the project. We''ve now deployed a large collection
    of bundles into the Karaf container; we can test our integration using the supplied
    Karaf test commands as follows:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是测试项目。我们现在已将大量捆绑包部署到Karaf容器中；我们可以使用提供的Karaf测试命令如下进行集成测试：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using the supplied custom Karaf commands, we can add recipe entries to our
    database. In the previous example, we added a recipe for chocolate chip cookies.
    Consider the following command line snippet:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用提供的自定义Karaf命令，我们可以将食谱条目添加到我们的数据库中。在先前的示例中，我们添加了一个巧克力曲奇饼干的食谱。考虑以下命令行片段：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `listrecipes` custom command performs a select all function upon our recipe
    data store, displaying all entries on the console. Alternatively, you could use
    any JDBC tool of your choice to verify that your recipe entries are persisted
    to disk.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`listrecipes`自定义命令在我们的食谱数据存储上执行选择所有功能，在控制台上显示所有条目。或者，您可以使用您选择的任何JDBC工具来验证您的食谱条目是否已持久化到磁盘。'
- en: Tip
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Simplifying datasource administration with the JDBC feature**'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**使用JDBC功能简化数据源管理**'
- en: 'Apache Karaf 3.0 contains a JDBC feature that provides many useful commands
    for interacting with datasources. Try installing the `jdbc` feature and then executing
    the following commands:'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Apache Karaf 3.0包含一个JDBC功能，它提供了许多与数据源交互的有用命令。尝试安装`jdbc`功能，然后执行以下命令：
- en: '`karaf@root()> feature:install jdbc`'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`karaf@root()> feature:install jdbc`'
- en: '`karaf@root()> jdbc:datasources`'
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`karaf@root()> jdbc:datasources`'
- en: '`karaf@root()> jdbc:tables jdbc/demo`'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`karaf@root()> jdbc:tables jdbc/demo`'
- en: '`karaf@root()> jdbc:query jdbc/demo "select * from RECIPES"`'
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`karaf@root()> jdbc:query jdbc/demo "select * from RECIPES"`'
- en: Output from these commands are not formatted to small consoles, so you may need
    to expand your terminal to comfortably display results.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些命令的输出未格式化为小控制台，因此您可能需要扩展您的终端以舒适地显示结果。
- en: Finally, even after restarting Karaf, all of your recipe entries will be available.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，即使在重启Karaf之后，您的所有食谱条目也将可用。
- en: How it works…
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: 'Observing from a high-level point of view, our persistence layer works by integrating
    several Apache Aries libraries and OpenJPA together in the Karaf container. The
    following diagram shows this high-level view:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个高级的角度观察，我们的持久化层通过在Karaf容器中集成几个Apache Aries库和OpenJPA来工作。以下图表显示了这一高级视图：
- en: '![How it works…](img/5081OS_07_03.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_07_03.jpg)'
- en: 'The key interactions in this design are the discovery and wiring of the persistence
    unit and Blueprint descriptor and wiring the entity and data access objects. This
    results in having our persistence bundle interacting with the JPA service implementation
    (OpenJPA), which in turn interacts with the EntityManagerFactory interface (from
    the persistence unit) wired into our DAO service implementation in the Blueprint
    descriptor file. These key deployment artifacts are illustrated in the following
    diagram:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此设计中的关键交互是持久化单元和Blueprint描述符的发现和连接，以及实体和数据访问对象的连接。这导致我们的持久化捆绑包与JPA服务实现（OpenJPA）交互，反过来，JPA服务实现与持久化单元中连接到我们的DAO服务实现的EntityManagerFactory接口交互。以下图表展示了这些关键部署工件：
- en: '![How it works…](img/5081OS_07_04.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/5081OS_07_04.jpg)'
- en: From the point of view of the architecture of our persistence-enabled bundle,
    its operation depends upon the interaction of the bundle manifest, persistent
    configuration, and Blueprint wiring.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们的持久化功能捆绑包的架构角度来看，其操作取决于捆绑包清单、持久化配置和Blueprint连接的交互。
- en: The `Meta-Persistence` manifest header triggers the processing of the bundles'
    persistence configuration, which in turn configures JNDI data source declaration,
    entity discovery, and JDBC integration.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meta-Persistence`清单头触发捆绑包持久化配置的处理，反过来配置JNDI数据源声明、实体发现和JDBC集成。'
- en: The Blueprint descriptor wires together our DAO service interface and implementation,
    as well as further defining datasources. A key feature of this service wiring
    is linking the persistence unit to the DAO service implementation. The DAO service
    uses the persistence unit's `EntityManagerFactory` function to enable entity access,
    manipulation, and transactions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Blueprint描述符将我们的DAO服务接口和实现连接起来，并进一步定义数据源。此服务连接的关键特性是将持久化单元连接到DAO服务实现。DAO服务使用持久化单元的`EntityManagerFactory`功能来启用实体访问、操作和事务。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Building a project with a persistence layer and transaction support for
    deployment in Karaf* recipe
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在Karaf中构建具有持久化层和交易支持的部署项目* 菜谱'
- en: Building a project with a persistence layer and transaction support for deployment
    in Karaf
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Karaf中构建具有持久化层和交易支持的部署项目
- en: Transaction support for your JPA-persisted data can be simply added by introducing
    Apache Aries JTA modules to your project. The JTA components provide a transaction
    manager that coordinates data storage and retrieval.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过引入Apache Aries JTA模块到您的项目中，可以简单地添加对您的JPA持久化数据的交易支持。JTA组件提供了一个事务管理器，用于协调数据存储和检索。
- en: In the *Building a project with a persistence layer for deployment in Karaf*
    recipe, we learned how to use JPA and OpenJPA to build a simple application that
    persists recipes to a database using a `RecipeBookService` class. In this recipe,
    we'll add container-based transaction management via JTA.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *在Karaf中部署项目时使用持久化层的构建* 菜谱中，我们学习了如何使用JPA和OpenJPA通过`RecipeBookService`类构建一个简单的应用程序，将菜谱持久化到数据库。在这个菜谱中，我们将通过JTA添加基于容器的交易管理。
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity. Sample code for this recipe is available at
    [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4).
    Generally, you'll also need to perform the steps outlined in the *Building a project
    with a persistence layer for deployment in Karaf* recipe and the *Installing Apache
    Aries JTA modules in Apache Karaf* recipe.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的成分包括Apache Karaf发行套件、对JDK的访问和互联网连接。此菜谱的示例代码可在[https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4)找到。通常，您还需要执行
    *在Karaf中部署项目时使用持久化层的构建* 菜谱和 *在Apache Karaf中安装Apache Aries JTA模块* 菜谱中概述的步骤。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please uninstall contents of the *Building a project with a persistence layer
    for deployment in Karaf* recipe before attempting this recipe as conflicts may
    occur.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试此菜谱之前，请先卸载 *在Karaf中部署项目时使用持久化层的构建* 菜谱的内容，因为可能会发生冲突。
- en: How to do it…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Given a JPA-based project as outlined in the *Building a project with a persistence
    layer for deployment in Karaf* recipe, we can add Java transaction support using
    the following five steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个基于JPA的项目，如 *在Karaf中部署项目时使用持久化层的构建* 菜谱中概述的，我们可以通过以下五个步骤添加Java交易支持：
- en: 'The first step is updating the persistence to JTA. First, we switch the transaction
    type from `RESOURCE_LOCAL` to `JTA`; this switches the project from self-managed
    persistence to container-managed. This is shown in the following code:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是更新持久化到JTA。首先，我们将交易类型从`RESOURCE_LOCAL`更改为`JTA`；这将项目从自我管理持久化转换为容器管理。以下代码展示了这一点：
- en: '[PRE18]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: After switching the transaction type, we need to add a `jta-data-source`. The
    previous example registers `jdbc/demoxa` as a service with JNDI. The `non-jta-data-source`
    used in the previous recipe is retained to help show the progression from the
    basic design to container-managed transactions; it may be removed during development.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在更改交易类型后，我们需要添加一个`jta-data-source`。上一个示例将`jdbc/demoxa`注册为JNDI上的服务。在先前的菜谱中使用的`non-jta-data-source`被保留，以帮助展示从基本设计到容器管理的交易的发展；在开发过程中可能被删除。
- en: 'The next step is updating the Blueprint descriptor. Switching our transaction
    type from `RESOURCE_LOCAL` to `JTA` changes how we will wire our `RecipeBookService`
    class. This is shown in the following code:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是更新Blueprint描述符。将我们的交易类型从`RESOURCE_LOCAL`更改为`JTA`，这将改变我们连接`RecipeBookService`类的方式。以下代码展示了这一点：
- en: '[PRE19]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We change the `jpa` property to reference the context instead of the unit and
    now add in a reference to the container-provided `entityManager` interface. The
    presence of JTA-style transactions also means that we can now include definitions
    for XA-capable data sources. Consider the following code:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`jpa`属性更改为引用上下文而不是单元，并现在添加对容器提供的`entityManager`接口的引用。JTA风格的交易的存在还意味着我们现在可以包括对XA数据源的定义。考虑以下代码：
- en: '[PRE20]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We wire together data-source-specific XA drivers with `XADataSource` service
    instantiations as follows:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将数据源特定的XA驱动程序与`XADataSource`服务实例连接起来，如下所示：
- en: '[PRE21]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Finally, we add a service reference for the container-provided `TransactionManager`
    interface, and set its presence to `mandatory`.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们添加了对容器提供的`TransactionManager`接口的服务引用，并将其存在性设置为`mandatory`。
- en: 'The next step is updating the service DAO. The changes to our persistence and
    Blueprint configuration to JTA-style transactions necessitates changes to our
    DAO service implementation. Our service does not need to create and manage its
    own transactions, as entities are now accessed through the container-provided
    `EntityManager` function. Consider the following code:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是更新服务 DAO。我们对持久性和蓝图配置进行 JTA 风格事务的更改，需要更改我们的 DAO 服务实现。我们的服务不需要创建和管理自己的事务，因为实体现在是通过容器提供的
    `EntityManager` 函数访问的。考虑以下代码：
- en: '[PRE22]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A result of this subtle change is that our service methods are simplified.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个微妙变化的后果是，我们的服务方法得到了简化。
- en: 'The next step is deploying the project into Karaf. Deploying our application
    into Karaf will require two steps (in addition to those outlined in the *Building
    a project with a persistence layer for deployment in Karaf* recipe): installing
    transaction support and adding our project bundle to the container. JTA will require
    a container-based transaction manager; we can install one using the following
    command:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将项目部署到 Karaf。将我们的应用程序部署到 Karaf 需要两个步骤（除了在 *在 Karaf 中部署具有持久化层的项目* 配方中概述的步骤）：安装事务支持和将我们的项目包添加到容器中。JTA
    需要基于容器的交易管理器；我们可以使用以下命令安装一个：
- en: '[PRE23]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Once installed, we can now deploy our project bundles using the following command:'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 安装完成后，我们现在可以使用以下命令部署我们的项目包：
- en: '[PRE24]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We can verify the installation by executing the `list –t 0 | grep -i JPA-JTA`
    command, which will list the bundle state of our project.
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过执行 `list –t 0 | grep -i JPA-JTA` 命令来验证安装，这将列出我们项目的包状态。
- en: 'The final step is testing the project. We''ve now deployed a large collection
    of bundles into the Karaf container; we can test our integration using the supplied
    Karaf test commands as follows:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是测试项目。我们现在已经将大量包部署到 Karaf 容器中；我们可以使用提供的 Karaf 测试命令来测试我们的集成，如下所示：
- en: '[PRE25]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In the previous code, we have added a simple placeholder entry into our recipe''s
    data store. Now, consider the following command line snippet:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们已经在我们的配方数据存储中添加了一个简单的占位符条目。现在，考虑以下命令行片段：
- en: '[PRE26]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Issuing the `listrecipes` command, we retrieve our previous entry.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 发出 `listrecipes` 命令，我们可以检索到之前的条目。
- en: Tip
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: See the JDBC feature note in the *Building a project with a persistence layer
    for deployment in Karaf* recipe for Karaf console commands to verify data source
    information.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 *在 Karaf 中部署具有持久化层的项目* 配方的 JDBC 功能说明中查看，以验证数据源信息。
- en: How it works…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The operation of this persistence-enabled bundle is very similar to that of
    our previous recipe. The vital changes being the introduction of the JTA transaction
    manager, updating the persistence unit to JTA, adding the XA datasource, then
    wiring an `EntityManager` function into the DAO service implementation and requiring
    the transaction manager's availability.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个启用持久性的包的操作与我们之前的配方非常相似。关键变化是引入了 JTA 事务管理器，将持久化单元更新为 JTA，添加 XA 数据源，然后将 `EntityManager`
    函数连接到 DAO 服务实现，并要求事务管理器的可用性。
- en: Operationally, transactions are coordinated by the container's transaction manager—this
    allows for more complex transactions with more varied enlisted resources than
    standard JPA-style transactions.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作上，事务是由容器的交易管理器协调的——这允许比标准 JPA 风格事务更复杂的事务，并涉及更多种类的资源。
- en: See also
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: For an alternative persistence layer approach, see [Chapter 8](ch08.html "Chapter 8. Providing
    a Big Data Integration Layer with Apache Cassandra"), *Providing a Big Data Integration
    Layer with Apache Cassandra*.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于另一种持久化层方法，请参阅[第 8 章](ch08.html "第 8 章。使用 Apache Cassandra 提供大数据集成层")，*使用 Apache
    Cassandra 提供大数据集成层*。
