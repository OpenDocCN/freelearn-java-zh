- en: Chapter 7. Providing a Persistence Layer with Apache Aries and OpenJPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenJPA modules in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Apache Aries JTA modules in Apache Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a project with a persistence layer for deployment in Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a project with a persistence layer and transaction support for deployment
    in Karaf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your applications will commonly need to safely persist data and make use of
    transactional behaviors. A preferred way to accomplish this for Java developers
    is to use the **Java Persistence API** (**JPA**) and **Java Transaction API**
    (**JTA**). In the context of Apache Karaf, developers will use an OSGi-ready JPA
    implementation, such as **Apache OpenJPA**, **EclipseLink**, or **Hibernate**
    and the **Apache Aries JTA**.
  prefs: []
  type: TYPE_NORMAL
- en: This book will use OpenJPA as an implementation of the JPA specification for
    the transparent persistence of Java objects. In relation to OSGi containers, it
    provides container-managed persistence for the Blueprint container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Apache Aries JTA provides a transaction management service to the container.
    Using this service, developers can build applications requiring the following
    transactional flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The previous pseudo code outlines the general form of a transaction; the developer
    obtains from the container a transaction session, demarks the beginning of the
    transaction, performs their business logic and, then must decide if they can commit
    the transaction or rollback resources.
  prefs: []
  type: TYPE_NORMAL
- en: The recipes in this chapter will aid you in deploying JPA and JTA resources
    into Karaf, and guide you by example to use these APIs in your bundles.
  prefs: []
  type: TYPE_NORMAL
- en: Installing OpenJPA modules in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can begin to explore how to build OpenJPA-backed applications, we
    must first install all the required JPA modules into the Karaf container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Thanks to Apache Karaf''s feature system, installing OpenJPA is a very simple
    two-step process: install the JPA and OpenJPA feature in Karaf. The steps are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why do we not have to add the feature URL? This is because Apache Karaf's standard
    distribution includes the JPA and OpenJPA feature URLs by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can install a feature by executing the `feature:install` command with the
    feature''s name as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can verify the installation by executing the `list –t 0 | grep -i JPA` command,
    which will list all installed OpenJPA components and dependencies in Karaf (Geronimo-jta_1.1_spec,
    Geronimo-jpa_2.0_spec, Aries JPA API, Aries JPA Blueprint, Aries JPA Container,
    and Aries JPA Container Context).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Similar to the installation of the JPA, we use the feature's name to install
    the OpenJPA engine, as follows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can verify the installation by executing the `list –t 0 | grep -i OpenJPA`
    command, which will list all installed OpenJPA components and dependencies in
    Karaf (core among them is the OpenJPA Aggregate JAR).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Apache Karaf community maintains an Apache Karaf feature descriptor for
    JPA and OpenJPA. These feature descriptor files contain all of the essential bundles
    and dependencies required to install these APIs and providers, which are shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the JPA or OpenJPA feature is installed (using the `feature:install` command),
    Karaf will use the appropriate URL handlers to obtain the required resources and
    install them into the container. Next, it attempts to bring them to a started
    state. If you execute the `list –t 0` command on the Karaf console, you will see
    the JPA and all other artifacts deployed into the container. We can depict the
    integration of OpenJPA components into Karaf more simply by illustrating the key
    artifacts being deployed atop a standard Karaf installation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Deploying applications as a feature* recipe of [Chapter 1](ch01.html "Chapter 1. Apache
    Karaf for System Builders"), *Apache Karaf for System Builders*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing Apache Aries JTA modules in Apache Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications often require transaction management alongside the JPA. This is
    accomplished by including the JTA into the Karaf container.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity. Generally, you'll also need to perform the
    steps outlined in the *Installing OpenJPA modules in Apache Karaf* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thanks to Apache Karaf's feature system, installing JTA is a very simple one-step
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Why do we not have to add the feature URL? This is because Apache Karaf's standard
    distribution includes the JTA feature URL by default.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the JTA feature into Karaf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We install a feature by executing the `feature:install` command with the feature''s
    name as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can verify the installation by executing the `list –t 0 | grep -i transaction`
    command, which will list all installed transaction components and dependencies
    in Karaf (such as Apache Aries Transaction Blueprint and Apache Aries Transaction
    Manager). In addition, we can verify that `geronimo_jta_1.1_spec` has been installed
    by grepping on `jta`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Apache Karaf community maintains an Apache Karaf features descriptor for
    JTA. The features descriptor file contains all of the essential bundles and dependencies
    required to install the transaction manager, which are shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the JTA feature is installed (using the `feature:install` command), Karaf
    will use the appropriate URL handlers to obtain the required resources and install
    them in the container. Next, it attempts to bring them to a started state. If
    you execute the `list –t 0` command on the Karaf console, you will see the JTA
    and all other artifacts deployed into the container. We can depict the integration
    of JTA components into Karaf more simply by illustrating the key artifacts being
    deployed atop a standard Karaf installation. In this deployment, we see the Transaction
    Manager (JTA) deployed among the various JPA modules from the *Installing OpenJPA
    modules in Apache Karaf* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Deploying applications as a feature* recipe of [Chapter 1](ch01.html "Chapter 1. Apache
    Karaf for System Builders"), *Apache Karaf for System Builders*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Installing OpenJPA modules in Apache Karaf* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a project with a persistence layer for deployment in Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application developers often need to make use of a persistence layer in their
    projects; one of the preferred methodologies to perform this in Karaf is to make
    use of the Java Persistence API and OpenJPA.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Installing OpenJPA modules in Apache Karaf* recipe, we learned how to
    install OpenJPA in Karaf; in this recipe, we'll make use of the JPA and OpenJPA
    to build a simple application that persists recipes to a database using a `RecipeBookService`
    class, which will hide the complexities of data storage and retrieval from its
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity. Sample code for this recipe is available at
    [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe3).
    Generally, you'll also need to perform the steps outlined in the *Installing OpenJPA
    modules in Apache Karaf* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please uninstall contents of the *Building a project with a persistence layer
    and transaction support for deployment in Karaf* recipe before attempting this
    recipe as conflicts may occur. This recipe comes later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Building a project with a JPA persistence layer will require the following
    nine steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is generating a Maven-based bundle project. Create an empty Maven-based
    project. A `pom.xml` file containing the essential Maven coordinate information
    and a bundle packaging directive will suffice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next step is adding dependencies to the POM file as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For Karaf 3.0.0, we use OpenJPA 2.2.2 and OSGi version 5.0.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is adding build plugins. Our recipe requires two build plugins
    to be configured: OpenJPA and bundle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, we configure the `openjpa-maven-plugin`. The `openjpa-maven-plugin`
    provides tasks for building and maintaining an OpenJPA-based project. We add to
    our POM file the following plugin configuration:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'In `openjpa-maven-plugin`, given in the previous block of code, we instruct
    the plugin to perform an enhance process upon our entity classes to provide the
    persistence functionality. As stated by the OpenJPA project: "Build time enhancement
    is the recommended method to use with OpenJPA, as it is the fastest and most reliable
    method".'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we configure the `maven-bundle-plugin`. We configure the `maven-bundle-plugin`
    to assemble our project code into an OSGi bundle. We add the following plugin
    configuration to our POM file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: As highlighted in the previous code snippet, the `Meta-Persistence` tag will
    add an entry to our bundle's manifest file pointing to our `persistence.xml` file
    location (we'll create this resource in our next step). The import statements
    for the `javax.persistence`, `dbcp`, and `derby` packages are of greatest importance
    for our example project. The Felix and Karaf imports are required by the optional
    Karaf commands.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is creating the persistence descriptor file. Create a directory
    tree as `src/main/resources/META-INF` in your project. We''ll then create a file
    named `persistence.xml` in this folder. This file is shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The persistence descriptor file contains a multitude of configuration entries
    required by our application. The most important among them being the definition
    of the `persistence-unit` and `non-jta-data-source` objects; the former sets the
    data persistence to `RESOURCE_LOCAL`, and the latter sets the use of a JDBC service
    for non-transactional data storage. The various OpenJPA properties are beyond
    the scope of this book, but they are included here to provide a sample configuration.
    The more interesting part of the previous example is the reference of the datasource.
    Since the `persistence.xml` file only knows of JNDI lookup syntax for resources,
    the OSGi service of the datasource needs to be referenced in a JNDI way. This
    results in `osgi:service` being the JNDI lookup for an OSGi service that provides
    a `javax.sql.DataSource` interface where the filter matches the `osgi.jndi.service.name`
    value as equivalent to `jdbc/demo`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is creating the Blueprint descriptor file. In your project, create
    the `src/main/resources/OSGI-INF` directory tree. We''ll then create a file named
    `blueprint.xml` in this folder as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should note the inclusion of the `DataSource` service as an OSGi service
    in this `blueprint.xml` file. It contains the service property `osgi.jndi.service.name`
    with the value `jdbc/demo`. This is the `DataSource` service that is referenced
    by the `persistence.xml` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is developing the OSGi service with the JPA backend. We''ve created
    the basic project structure and plumbed in configurations for the persistence
    and Blueprint descriptors; now we''ll focus on the underlying Java code of our
    JPA-backed application. We break down this process into the following three steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is defining a service interface. The service interface will
    define the user API for our project. In our sample code, we implement a `RecipeBookService`
    class, which provides the methods required to interact with a collection of recipes.
    This is shown in the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The interface's implementation follows the standard Java conventions, requiring
    no special OSGi packages.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is implementing a service DAO. Now that we have defined our service
    interface, we''ll provide an implementation as a DAO. Consider the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `EntityManagerFactory` function will be wired into our DAO using Blueprint.
    Each service method implemented in our DAO service implementation will require
    management of the JPA-style transaction elements.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is implementing entities. Finally, we implement our entities
    as shown in the following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Our `Entity` class is where our objects meet their persistent storage definition
    requirement. To store an object into a database, we must describe their storage
    in terms of tables, columns, and so on, and override the `equals` and `hashCode`
    methods.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is the optional creation of Karaf commands to directly test the
    persistence service. To simplify manual testing of our `RecipeBookService` class,
    we can create a set of custom Karaf commands, which will exercise our JPA-backed
    data storage and retrieval operations. Sample implementations of these commands
    are available from the book''s website. Of particular interest is how they obtain
    a reference to the `RecipeBookService` class and make calls to the service. Now,
    we must wire the command implementation into Karaf via Blueprint as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Each of our custom command's implementation classes are wired to our `recipeBookService`
    instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is deploying the project into Karaf. Deploying our application
    in Karaf will require the following three steps: installing a JDBC driver for
    a backing database, installing JNDI, and adding our project bundle to the container.
    For our example project, we''ll use Apache Derby as our JDBC provider.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can install the JDBC driver using the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Once installed, you can check whether the client driver is available by executing
    the classes command and grepping upon the `ClientDataSource` implementation.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: This demo will require a running instance of the Derby database. See [http://db.apache.org/derby/papers/DerbyTut/install_software.html](http://db.apache.org/derby/papers/DerbyTut/install_software.html)
    for a short tutorial on installing Apache Derby.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to install the `jndi` feature using the following command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Once the `jndi` feature is installed in Karaf, we'll be able to use the `jndi:names`
    command to view the configured datasources in the container.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We install our project bundle by executing the `install` command on its Maven
    coordinates as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We can verify the installation by executing the `list –t 0 | grep -i JPA-only`
    command, which will list the bundle state of our project.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is testing the project. We''ve now deployed a large collection
    of bundles into the Karaf container; we can test our integration using the supplied
    Karaf test commands as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the supplied custom Karaf commands, we can add recipe entries to our
    database. In the previous example, we added a recipe for chocolate chip cookies.
    Consider the following command line snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `listrecipes` custom command performs a select all function upon our recipe
    data store, displaying all entries on the console. Alternatively, you could use
    any JDBC tool of your choice to verify that your recipe entries are persisted
    to disk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Simplifying datasource administration with the JDBC feature**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apache Karaf 3.0 contains a JDBC feature that provides many useful commands
    for interacting with datasources. Try installing the `jdbc` feature and then executing
    the following commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`karaf@root()> feature:install jdbc`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`karaf@root()> jdbc:datasources`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`karaf@root()> jdbc:tables jdbc/demo`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`karaf@root()> jdbc:query jdbc/demo "select * from RECIPES"`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Output from these commands are not formatted to small consoles, so you may need
    to expand your terminal to comfortably display results.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, even after restarting Karaf, all of your recipe entries will be available.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Observing from a high-level point of view, our persistence layer works by integrating
    several Apache Aries libraries and OpenJPA together in the Karaf container. The
    following diagram shows this high-level view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The key interactions in this design are the discovery and wiring of the persistence
    unit and Blueprint descriptor and wiring the entity and data access objects. This
    results in having our persistence bundle interacting with the JPA service implementation
    (OpenJPA), which in turn interacts with the EntityManagerFactory interface (from
    the persistence unit) wired into our DAO service implementation in the Blueprint
    descriptor file. These key deployment artifacts are illustrated in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/5081OS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: From the point of view of the architecture of our persistence-enabled bundle,
    its operation depends upon the interaction of the bundle manifest, persistent
    configuration, and Blueprint wiring.
  prefs: []
  type: TYPE_NORMAL
- en: The `Meta-Persistence` manifest header triggers the processing of the bundles'
    persistence configuration, which in turn configures JNDI data source declaration,
    entity discovery, and JDBC integration.
  prefs: []
  type: TYPE_NORMAL
- en: The Blueprint descriptor wires together our DAO service interface and implementation,
    as well as further defining datasources. A key feature of this service wiring
    is linking the persistence unit to the DAO service implementation. The DAO service
    uses the persistence unit's `EntityManagerFactory` function to enable entity access,
    manipulation, and transactions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Building a project with a persistence layer and transaction support for
    deployment in Karaf* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a project with a persistence layer and transaction support for deployment
    in Karaf
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transaction support for your JPA-persisted data can be simply added by introducing
    Apache Aries JTA modules to your project. The JTA components provide a transaction
    manager that coordinates data storage and retrieval.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Building a project with a persistence layer for deployment in Karaf*
    recipe, we learned how to use JPA and OpenJPA to build a simple application that
    persists recipes to a database using a `RecipeBookService` class. In this recipe,
    we'll add container-based transaction management via JTA.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ingredients of this recipe include the Apache Karaf distribution kit, access
    to JDK, and Internet connectivity. Sample code for this recipe is available at
    [https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4](https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter7/chapter7-recipe4).
    Generally, you'll also need to perform the steps outlined in the *Building a project
    with a persistence layer for deployment in Karaf* recipe and the *Installing Apache
    Aries JTA modules in Apache Karaf* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please uninstall contents of the *Building a project with a persistence layer
    for deployment in Karaf* recipe before attempting this recipe as conflicts may
    occur.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Given a JPA-based project as outlined in the *Building a project with a persistence
    layer for deployment in Karaf* recipe, we can add Java transaction support using
    the following five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is updating the persistence to JTA. First, we switch the transaction
    type from `RESOURCE_LOCAL` to `JTA`; this switches the project from self-managed
    persistence to container-managed. This is shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After switching the transaction type, we need to add a `jta-data-source`. The
    previous example registers `jdbc/demoxa` as a service with JNDI. The `non-jta-data-source`
    used in the previous recipe is retained to help show the progression from the
    basic design to container-managed transactions; it may be removed during development.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is updating the Blueprint descriptor. Switching our transaction
    type from `RESOURCE_LOCAL` to `JTA` changes how we will wire our `RecipeBookService`
    class. This is shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We change the `jpa` property to reference the context instead of the unit and
    now add in a reference to the container-provided `entityManager` interface. The
    presence of JTA-style transactions also means that we can now include definitions
    for XA-capable data sources. Consider the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We wire together data-source-specific XA drivers with `XADataSource` service
    instantiations as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, we add a service reference for the container-provided `TransactionManager`
    interface, and set its presence to `mandatory`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is updating the service DAO. The changes to our persistence and
    Blueprint configuration to JTA-style transactions necessitates changes to our
    DAO service implementation. Our service does not need to create and manage its
    own transactions, as entities are now accessed through the container-provided
    `EntityManager` function. Consider the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A result of this subtle change is that our service methods are simplified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step is deploying the project into Karaf. Deploying our application
    into Karaf will require two steps (in addition to those outlined in the *Building
    a project with a persistence layer for deployment in Karaf* recipe): installing
    transaction support and adding our project bundle to the container. JTA will require
    a container-based transaction manager; we can install one using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once installed, we can now deploy our project bundles using the following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can verify the installation by executing the `list –t 0 | grep -i JPA-JTA`
    command, which will list the bundle state of our project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step is testing the project. We''ve now deployed a large collection
    of bundles into the Karaf container; we can test our integration using the supplied
    Karaf test commands as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the previous code, we have added a simple placeholder entry into our recipe''s
    data store. Now, consider the following command line snippet:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Issuing the `listrecipes` command, we retrieve our previous entry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: See the JDBC feature note in the *Building a project with a persistence layer
    for deployment in Karaf* recipe for Karaf console commands to verify data source
    information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operation of this persistence-enabled bundle is very similar to that of
    our previous recipe. The vital changes being the introduction of the JTA transaction
    manager, updating the persistence unit to JTA, adding the XA datasource, then
    wiring an `EntityManager` function into the DAO service implementation and requiring
    the transaction manager's availability.
  prefs: []
  type: TYPE_NORMAL
- en: Operationally, transactions are coordinated by the container's transaction manager—this
    allows for more complex transactions with more varied enlisted resources than
    standard JPA-style transactions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For an alternative persistence layer approach, see [Chapter 8](ch08.html "Chapter 8. Providing
    a Big Data Integration Layer with Apache Cassandra"), *Providing a Big Data Integration
    Layer with Apache Cassandra*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
