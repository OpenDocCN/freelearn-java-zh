["```java\npublic class SemaphoreExample {\n    volatile int threadSafeInt = 0;\n    Semaphore semaphore = new Semaphore(1);\n    public int incremementAndGet() throws InterruptedException{\n        semaphore.acquire();\n        int previousValue = threadSafeInt++;\n        semaphore.release();\n        return previousValue;\n    }\n}\n```", "```java\npublic class ThreadSafeCounter {\n    AtomicInteger counter;\n    public int incrementAndGet(){\n        while (true){\n            int value = counter.get();\n            if(counter.compareAndSet(value, value+1)){\n                return value;\n            }\n        }\n    }\n}\n```", "```java\npublic class ThreadSafeFixedLengthBlockingQueue<E> {\n```", "```java\n    Semaphore underflowSemaphore;\n    Semaphore overflowSemaphore;\n\n    AtomicInteger nextEnqueueIndex;\n    AtomicInteger nextDequeueIndex;\n```", "```java\n    E[] store;\n```", "```java\n    Semaphore [] enqueueLocks;\n    Semaphore [] dequeueLocks;\n\n    int length;\n```", "```java\n    boolean alive = true;\n```", "```java\n    public ThreadSafeFixedLengthBlockingQueue(int length){\n        this.length = length;\n        store = (E[]) new Object[length];\n        nextEnqueueIndex = new AtomicInteger();\n        nextDequeueIndex = new AtomicInteger();\n        underflowSemaphore = new Semaphore(length);\n        overflowSemaphore = new Semaphore(length);\n        underflowSemaphore.acquireUninterruptibly(length);\n        enqueueLocks = new Semaphore[length];\n        dequeueLocks = new Semaphore[length];\n        for(int i=0;i<length;i++){\n            enqueueLocks[i] = new Semaphore(1);\n            dequeueLocks[i] = new Semaphore(1);\n            dequeueLocks[i].acquireUninterruptibly();\n        }\n    }\n```", "```java\n    public void enqueue(E value) throws InterruptedException {\n        overflowSemaphore.acquire();\n```", "```java\n        int index = (length + nextEnqueueIndex.getAndIncrement() % length) \n          % length;\n```", "```java\n        enqueueLocks[index].acquire();\n        store[index] = value;\n        dequeueLocks[index].release();\n        underflowSemaphore.release();\n    }\n```", "```java\n    public E dequeue() throws InterruptedException {\n```", "```java\n        while (alive && !underflowSemaphore.tryAcquire(1, TimeUnit.SECONDS));\n        if(!alive){\n            Thread.currentThread().interrupt();\n        }\n        int index = (length + nextDequeueIndex.getAndIncrement() % length) \n                 % length;\n        dequeueLocks[index].acquire();\n        E value = store[index];\n        enqueueLocks[index].release();\n        overflowSemaphore.release();\n        return value;\n    }\n```", "```java\n    public int currentElementCount(){\n        return underflowSemaphore.availablePermits();\n    }\n\n    public void killDequeuers(){\n        alive = false;\n    }\n\n}\n```", "```java\npublic interface Consumer<E> {\n    void onMessage(E message);\n    default void onError(Exception error){\n        error.printStackTrace();\n    }\n    default void onComplete(){\n\n    }\n}\n\npublic class ProducerConsumerQueue<E> {\n    enum EventType{\n        INVOCATION, ERROR, COMPLETION\n    }\n```", "```java\n    class Event{\n        E value;\n        Exception error;\n        EventType eventType;\n    }\n    ThreadSafeFixedLengthBlockingQueue<Event> queue;\n    boolean alive = true;\n    Thread [] threads;\n```", "```java\n    public ProducerConsumerQueue(int bufferSize, int threadCount, \n                 Consumer<E> consumer){\n        queue = new ThreadSafeFixedLengthBlockingQueue<>(bufferSize);\n        threads = new Thread[threadCount];\n```", "```java\n        Runnable consumerCode = ()->{\n            try{\n                while(alive || queue.currentElementCount()>0){\n                    Event e = queue.dequeue();\n                    switch (e.eventType) {\n                        case INVOCATION:\n                            consumer.onMessage(e.value);\n                            break;\n                        case ERROR:\n                            consumer.onError(e.error);\n                            break;\n                        case COMPLETION:\n                            alive = false;\n                            consumer.onComplete();\n                    }\n                }\n\n            } catch (InterruptedException e) {\n\n            } finally{\n\n            }\n        };\n```", "```java\n        for(int i=0;i<threadCount;i++) {\n            threads[i] = new Thread(consumerCode);\n            threads[i].start();\n        }\n    }\n```", "```java\n    public void produce(E value) throws InterruptedException {\n        Event event = new Event();\n        event.value = value;\n        event.eventType = EventType.INVOCATION;\n        queue.enqueue(event);\n    }\n```", "```java\n    public void markCompleted() throws InterruptedException {\n        Event event = new Event();\n        event.eventType = EventType.COMPLETION;\n        queue.enqueue(event);\n    }\n```", "```java\n    public void sendError(Exception ex) throws InterruptedException {\n        Event event = new Event();\n        event.error = ex;\n        event.eventType = EventType.ERROR;\n        queue.enqueue(event);\n    }\n```", "```java\n    public void joinThreads() throws InterruptedException {\n        for(Thread t: threads){\n            t.join();\n        }\n    }\n}\n```", "```java\n$ head com-orkut.ungraph.txt \n1\t2 \n1\t3 \n1\t4 \n1\t5 \n1\t6 \n1\t7 \n1\t8 \n1\t9 \n1\t10 \n1\t11 \n$ head ulist \n2508972 \n1081826 \n2022585 \n141678 \n709419 \n877187 \n1592426 \n1013109 \n1490560 \n623595 \n```", "```java\npublic class FileReader {\n    ByteBuffer buf= ByteBuffer.allocate(65536);\n    FileChannel channel;\n```", "```java\n    int readCount = 0;\n\n    public FileReader(String filename) throws FileNotFoundException {\n        channel = new FileInputStream(filename).getChannel();\n        buf.clear();\n    }\n```", "```java\n    public int readIntFromText() throws IOException {\n        int value = 0;\n        while(true){\n```", "```java\n            if(readCount<=0){\n                buf.clear();\n                readCount = channel.read(buf);\n```", "```java\n                if(readCount<0){\n                    break;\n                }\n                buf.flip();\n            }\n```", "```java\n            byte nextChar = buf.get();\n            readCount--;\n```", "```java\n            if(nextChar>='0' && nextChar<='9') {\n                value = value * 10 + (nextChar - '0');\n            }else{\n                break;\n            }\n\n        }\n        return value;\n    }\n}\n```", "```java\npublic class FriendCountProblem {\n    private static final String USER_LIST_FILE = \"ulist\";\n    private static final String EDGES_PATH = \"com-orkut.ungraph.txt\";\n    private static final String OUTPUT_FILE_PATH = \"output\";\n\n    public static void main(String [] args)\n      throws Exception {\n        FileReader userListReader = new FileReader(USER_LIST_FILE);\n```", "```java\n        int count = 0;\n\n        while(true){\n\n            int lineValue = userListReader.readIntFromText();\n            if(lineValue==0){\n                break;\n            }\n            count++;\n        }\n```", "```java\n        Integer [] keys = new Integer[count];\n        AtomicInteger [] values = new AtomicInteger[count];\n```", "```java\n        userListReader = new FileReader(USER_LIST_FILE);\n\n        int index = 0;\n\n        while(true){\n\n            int uid = userListReader.readIntFromText();\n            if(uid==0){\n                break;\n            }\n            keys[index] = uid;\n            values[index] =  new AtomicInteger(0);\n            index++;\n\n        }\n```", "```java\n        ArraySorter.quicksort(keys,(a,b)->a-b);\n```", "```java\n        ProducerConsumerQueue<Integer> queue \n                = new ProducerConsumerQueue<>(4092, 2, (v)->{\n            int pos  = ArraySearcher.binarySearch(keys,v);\n            if(pos<0){\n                return;\n            }\n            values[pos].incrementAndGet();\n        });\n```", "```java\n        FileReader edgeListFileReader = new FileReader(EDGES_PATH);\n        while(true){\n            int val = edgeListFileReader.readIntFromText();\n            if(val == 0){\n                break;\n            }\n            queue.produce(val);\n        }\n```", "```java\n        queue.markCompleted();\n        queue.joinThreads();\n```", "```java\n        PrintStream out = new PrintStream(OUTPUT_FILE_PATH);\n        for(int i=0;i<count;i++){\n            out.println(keys[i] +\" : \"+values[i].get());\n        }\n        out.flush();\n    }\n}\n```", "```java\npublic class ThreadSafeFixedLengthSpinlockQueue<E> {\n    int nextEnqueueIndex;\n    int nextDequeueIndex;\n    E[] store;\n    AtomicBoolean[] enqueueLocks;\n    AtomicBoolean[] dequeueLocks;\n    AtomicInteger currentElementCount = new AtomicInteger(0);\n    int length;\n    volatile boolean alive = true;\n    public ThreadSafeFixedLengthSpinlockQueue(int length){\n        this.length = length;\n        store = (E[]) new Object[length];\n        enqueueLocks = new AtomicBoolean[length];\n        dequeueLocks = new AtomicBoolean[length];\n```", "```java\n        for(int i=0;i<length;i++){\n            enqueueLocks[i] = new AtomicBoolean(false);\n            dequeueLocks[i] = new AtomicBoolean(true);\n        }\n    }\n```", "```java\n    public void enqueue(E value) throws InterruptedException {\n\n        while (true) {\n            int index = nextEnqueueIndex;\n            nextEnqueueIndex = (nextEnqueueIndex+1) % length;\n            if(enqueueLocks[index].compareAndSet(false,true)){\n                currentElementCount.incrementAndGet();\n                store[index] = value;\n                dequeueLocks[index].set(false);\n                return;\n            }\n        }\n    }\n```", "```java\n    public E dequeue() throws InterruptedException {\n        while(alive) {\n            int index = nextDequeueIndex;\n            nextDequeueIndex = (nextDequeueIndex+1) % length;\n            if(dequeueLocks[index].compareAndSet(false,true)){\n                currentElementCount.decrementAndGet();\n                E value = store[index];\n                enqueueLocks[index].set(false);\n                return value;\n            }\n        }\n        throw new InterruptedException(\"\");\n    }\n```", "```java\n    public int currentElementCount(){\n        return currentElementCount.get();\n    }\n\n    public void killDequeuers(){\n        alive = false;\n    }\n\n}\n```", "```java\npublic static boolean isPerfect(long x){\n        long div = 2;\n        long sum=0;\n        while(true){\n            long quotient = x/div;\n            if(quotient<div){\n                break;\n            }\n            if(x%div==0){\n                sum+=div;\n                if(quotient!=div){\n                    sum+=quotient;\n                }\n            }\n            div++;\n        }\n        return 1+sum==x;\n    }\n```", "```java\npublic static void findPerfectNumberWithProducerConsumer() throws InterruptedException{\n        long start = System.currentTimeMillis();\n        ProducerConsumerQueue<Long> queue \n                 = new ProducerConsumerQueue<>(4096, 4, (x)->{\n            if(isPerfect(x)){\n                System.out.println(x);\n            }\n        });\n\n        for(long i=2;i<5_00_000;i++){\n            queue.produce(i);\n        }\n        queue.markCompleted();\n        queue.joinThreads();\n        System.out.println(\"Time in ms: \"+(System.currentTimeMillis()-start));\n    }\n```", "```java\npublic static void findPerfectNumberWithSingleThread(){\n        long start = System.currentTimeMillis();\n        for(long i=2;i<5_00_000;i++){\n            if(isPerfect(i)){\n                System.out.println(i);\n            }\n        }\n        System.out.println(\"Time in ms: \"+(System.currentTimeMillis()-start));\n    }\n```", "```java\n  public static void findPerfectNumbersWithFunctionalAPI(){\n        EventStream<Long> stream = someWayCreateAStream();\n        stream.filter((x)->x>1)\n                .filter(EventStream::isPerfect)\n                .consume((x)->{System.out.println(x);})\n                .onError((x)->System.out.println(x))\n                .process(4096,1,4);\n\n    }\n```", "```java\npublic void enqueueProducerOnly(E value ) throws InterruptedException{\n        int halfLength = length/2;\n        while (true) {\n\n            int index = nextEnqueueIndex;\n            nextEnqueueIndex = (nextEnqueueIndex+1) % length;\n            if(enqueueLocks[index].compareAndSet(false,true)){\n                int numberOfElements = currentElementCount.get();\n                if(numberOfElements>=halfLength\n                   || (!currentElementCount.compareAndSet(numberOfElements, numberOfElements+1))){\n                    enqueueLocks[index].set(false);\n                    continue;\n                }\n                store[index] = value;\n                dequeueLocks[index].set(false);\n                return;\n            }\n        }\n    }\n```", "```java\npublic void produceExternal(E value) throws InterruptedException {\n        Event event = new Event();\n        event.value = value;\n        event.eventType = EventType.INVOCATION;\n        queue.enqueueProducerOnly(event);\n }\n```", "```java\npublic abstract class EventStream<E> {\n    EventStream previous;\n    OneArgumentExpressionWithException mapper;\n    OneArgumentExpressionWithException filter;\n    public <R> EventStream<R> map(OneArgumentExpressionWithException<E,R> mapper){\n        EventStream<R> mapped = new EventStream<R>() {\n\n            @Override\n            public R read() {\n                return null;\n            }\n        };\n        mapped.mapper = mapper;\n        mapped.previous = this;\n        return mapped;\n    }\n    public EventStream<E> filter(OneArgumentExpressionWithException<E, Boolean> filter){\n        EventStream<E> mapped = new EventStream<E>() {\n\n            @Override\n            public E read() {\n                return null;\n            }\n        };\n        mapped.filter = filter;\n        mapped.previous = this;\n        return mapped;\n    }\n```", "```java\n    public EventConsumer<E> consume(\n      OneArgumentStatementWithException<E> consumer){\n            EventConsumer eventConsumer = new EventConsumer(consumer, this) {\n        };\n        return eventConsumer;\n    }\n    public abstract E read();\n}\n```", "```java\npublic interface Task {\n}\n```", "```java\n@FunctionalInterface\npublic interface OneArgumentExpressionWithException<A,R> {\n    R compute(A a) throws Exception;\n}\n@FunctionalInterface\npublic interface OneArgumentStatementWithException<E> {\n    void doSomething(E input) throws Exception;\n}\n```", "```java\npublic class MapperTask implements Task {\n    OneArgumentExpressionWithException mapper;\n    Task nextTask;\n\n    public MapperTask(\n            OneArgumentExpressionWithException mapper,\n            Task nextTask) {\n        this.mapper = mapper;\n        this.nextTask = nextTask;\n    }\n\n}\n\npublic class FilterTask implements Task{\n    OneArgumentExpressionWithException filter;\n    Task nextTask;\n\n    public FilterTask(\n            OneArgumentExpressionWithException filter,\n            Task nextTask) {\n        this.filter = filter;\n        this.nextTask = nextTask;\n    }\n}\n```", "```java\npublic class ProcessorTask<E> implements Task{\n    OneArgumentStatementWithException<E> processor;\n\n    public ProcessorTask(\n            OneArgumentStatementWithException<E> processor) {\n        this.processor = processor;\n    }\n}\n```", "```java\npublic abstract class EventConsumer<E> {\n    OneArgumentStatementWithException consumptionCode;\n    EventStream<E> eventStream;\n    Task taskList = null;\n    private ProducerConsumerQueue<StreamEvent> queue;\n    private OneArgumentStatement<Exception> errorHandler = (ex)->ex.printStackTrace();\n```", "```java\n    class StreamEvent{\n        Object value;\n        Task task;\n    }\n```", "```java\n        private Task eventStreamToTask(EventStream stream){\n        Task t = new ProcessorTask(consumptionCode);\n        EventStream s = stream;\n        while(s.previous !=null){\n            if(s.mapper!=null)\n                t = new MapperTask(s.mapper, t);\n            else if(s.filter!=null){\n                t = new FilterTask(s.filter, t);\n            }\n            s = s.previous;\n        }\n        return t;\n    }\n```", "```java\n    EventConsumer(\n            OneArgumentStatementWithException consumptionCode,\n            EventStream<E> eventStream) {\n        this.consumptionCode = consumptionCode;\n        this.eventStream = eventStream;\n        taskList = eventStreamToTask(eventStream);\n    }\n```", "```java\n    class ConsumerCodeContainer implements Consumer<StreamEvent>{\n        @Override\n        public void onError(Exception error) {\n            errorHandler.doSomething(error);\n        }\n```", "```java\n        @Override\n        public void onMessage(StreamEvent evt) {\n```", "```java\n            if(evt.task instanceof ProcessorTask){\n                try {\n                    ((ProcessorTask) evt.task).processor\n                            .doSomething(evt.value);\n                } catch (Exception e) {\n                    queue.sendError(e);\n                }\n            }\n```", "```java\n            else if(evt.task instanceof FilterTask){\n                StreamEvent nextEvent = new StreamEvent();\n                try {\n                    if((Boolean)((FilterTask) evt.task).filter.compute(evt.value)) {\n                        nextEvent.task =\n                                ((FilterTask) evt.task).nextTask;\n                        nextEvent.value = evt.value;\n                        queue.produce(nextEvent);\n                    }\n                } catch (Exception e) {\n                    queue.sendError(e);\n                }\n            }\n```", "```java\n             else if(evt.task instanceof MapperTask){\n                StreamEvent nextEvent = new StreamEvent();\n                try {\n                    nextEvent.value = ((MapperTask) evt.task).mapper.compute(evt.value);\n                    nextEvent.task = ((MapperTask) evt.task).nextTask;\n                    queue.produce(nextEvent);\n                } catch (Exception e) {\n                    queue.sendError(e);\n                }\n            }\n        }\n    }\n```", "```java\n    public void process(int bufferSize, int numberOfProducerThreads, int numberOfConsumerThreads) {\n      queue = new ProducerConsumerQueue<>(bufferSize,\n      numberOfConsumerThreads, new ConsumerCodeContainer());\n```", "```java\n        EventStream s = eventStream;\n        while(s.previous !=null){\n            s = s.previous;\n        }\n```", "```java\n        EventStream startingStream = s;\n```", "```java\n        Runnable producerRunnable = ()->{\n            while(true){\n                Object value = startingStream.read();\n                if(value==null){\n                    break;\n                }\n                StreamEvent nextEvent = new StreamEvent();\n                try {\n                    nextEvent.value = value;\n                    nextEvent.task = taskList;\n                    queue.produceExternal(nextEvent);\n                } catch (Exception e) {\n                    queue.sendError(e);\n                }\n            }\n            try {\n                queue.markCompleted();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        };\n```", "```java\n        Thread [] producerThreads = new Thread[numberOfProducerThreads];\n        for(int i=0;i<numberOfProducerThreads;i++){\n            producerThreads[i] = new Thread(producerRunnable);\n            producerThreads[i].start();\n        }\n        for(int i=0;i<numberOfProducerThreads;i++){\n            try {\n                producerThreads[i].join();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n```", "```java\n    public EventConsumer<E> onError(\n               OneArgumentStatement<Exception> errorHandler){\n        EventConsumer<E> consumer \n         = new EventConsumer<E>(consumptionCode, eventStream) {};\n        consumer.taskList = taskList;\n        consumer.errorHandler = errorHandler;\n        return consumer;\n    }\n}\n```", "```java\n  public static void findPerfectNumbersWithFunctionalAPI(){\n        long start = System.currentTimeMillis();\n        EventStream<Long> stream = new EventStream<Long>() {\n            AtomicLong next = new AtomicLong(0L);\n            @Override\n            public Long read() {\n                Long ret = next.incrementAndGet();\n                if(ret<=5_00_000L){\n                    return ret;\n                }\n                return null;\n            }\n        };\n        stream.filter((x)->x>1)\n                .filter(EventStream::isPerfect)\n                .consume((x)->{System.out.println(x);})\n                .onError((x)->System.out.println(x))\n                .process(4096,1,4);\n\n        System.out.println(\"Time in ms: \"+(System.currentTimeMillis()-start));\n    }\n```"]