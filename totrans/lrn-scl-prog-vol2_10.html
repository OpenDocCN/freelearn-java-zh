<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working with Implicits and Exceptions</h1>
                
            
            <article>
                
<div class="packt_quote">"How ironic, when you do business you create exceptions to create new opportunities, when you write code (do a job) you handle exceptions to make it clean."</div>
<div class="packt_quote1">- Pushkar Saraf</div>
<p class="calibre2">Functional programs are expressions. When we say we want to run a functional program, we mean we want to evaluate the expressions. When we evaluate an expression, we get a value. We also know that functional programming is about composing and evaluating expressions. This means that the function signature you write down holds true for each evaluation. But there are scenarios where it's unlikely to happen. Your code might not work as expected and might result in an exceptional behavior. How do we deal with such scenarios, and how do we handle exceptions in functional programming? These are some fundamental questions, and anyone who's starting with functional programming might ask the same. So, in this chapter, we'll try answering these questions, and then we'll move forward to look at another important and much-talked-about concept <span>in Scala</span> known as <strong class="calibre1">implicits</strong>. We'll take a look at what they are and the instances where we might want to use them. So here's what we'll go through in our chapter:</p>
<ul class="calibre7">
<li class="calibre8">Exception handling - the old way</li>
<li class="calibre8">Using the option way</li>
<li class="calibre8">Either left or right</li>
<li class="calibre8">Implicits - what and why</li>
<li class="calibre8">Implicit class</li>
<li class="calibre8">Implicit arguments</li>
</ul>
<p class="calibre2">Let's start by introducing an exceptional behavior to a particular functionality and handling it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Exception handling – the old way</h1>
                
            
            <article>
                
<p class="calibre2">Let's write some code so that we can talk about exception handling. Take a look at the following:</p>
<pre class="calibre19">def toInt(str: String): Int = str.toInt </pre>
<p class="calibre2">In the preceding code, the <kbd class="calibre11">toInt</kbd> is a function that takes a <kbd class="calibre11">String</kbd> value, which supposedly can be converted to a corresponding <kbd class="calibre11">Int</kbd> value. The definition looks okay, but as functional programmers, we are so used to trying out the function to see whether it does what it says (in the definition). Let's try out some calls to this function:</p>
<pre class="calibre19">println(toInt("121")) 
println(toInt("-199")) </pre>
<p class="calibre2">The preceding code gives the following result:</p>
<pre class="calibre19">121 
-199 </pre>
<p class="calibre2">Things worked fine for us. We passed a number in a string format and got the corresponding integer values. But what if you try something like the following:</p>
<pre class="calibre19">println(toInt("+ -199")) </pre>
<p class="calibre2">Say that we get something unexpected, some exception saying this:</p>
<pre class="calibre19">Exception in thread "main" java.lang.NumberFormatException: For input string: "+ -199" 
   at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) </pre>
<p class="calibre2">Instead of responding with an integer result, what we got is an exception—that's bad. But let's be positive; there are a few things that we can learn from this failure:</p>
<ul class="calibre7">
<li class="calibre8">The definition of our function was not right. It was telling us, <em class="calibre18">you give me a string and I'll give you back the corresponding integer.</em> But it didn't happen.</li>
<li class="calibre8">We knew that instead of the ideal cases, there might be scenarios where our operation might fail to complete.</li>
</ul>
<p class="calibre2">So, learning from this experience, we now have an idea that we might want to handle the unwanted scenarios. But how?</p>
<p class="calibre2">In some programming languages, we get a construct that wraps a block of code that might throw an exception and catches exceptions when thrown, and we are allowed to introduce our desired behaviour by putting in catch blocks. These are nothing but <kbd class="calibre11">try... catch</kbd> blocks. Why don't we try out these blocks?:</p>
<pre class="calibre19">import java.lang.Exception 
 
object Main extends App { 
 
  def toInt(str: String): Int = 
    try{ 
      str.toInt 
    } catch { 
      case exp: Exception =&gt; 
        println("Something unexpected happened, you may want to check the string you passed for conversion.") 
 
        println("WARN: Overriding the usual behavior, returning Zero!") 
        0 
    } 
 
  println(toInt("121")) 
  println(toInt("-199")) 
  println(toInt("+ -199")) 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">121 
-199 </pre>
<p class="calibre2">Something unexpected happened; you may want to check the string you passed for conversion:</p>
<pre class="calibre19">WARN: Overriding the usual behavior, returning Zero! 
0 </pre>
<p class="calibre2">Did you try to run the preceding code? If you did, you can see that whatever concerns we had, we are able to overcome them with this code snippet. We wrapped our logic for the conversion of a string to an integer in a <kbd class="calibre11">try</kbd> block and also prepared what should be the behavior in case something went wrong. That change gave us a synthetic result, along with a pretty warning message.</p>
<p class="calibre2">Does this implementation seem reasonable? To some extent, it's a workaround and it does what it says in the function's signature. But returning zero in exceptional cases is still not a good option.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the Option way</h1>
                
            
            <article>
                
<p class="calibre2">Let's try and change the function signature in a way that we can reason about and modify it so that it does what it says:</p>
<pre class="calibre19">def toInt(str: String): Option[Int] = Try(str.toInt) match { 
  case Success(value) =&gt; Some(value) 
  case Failure(_) =&gt; None 
}</pre>
<p class="calibre2">In the preceding definition, we knew that the response was optional. We might or might not get a corresponding integer value for every string we pass to our function. Hence, we made the response type an <kbd class="calibre11">Option[Int]</kbd><em class="calibre18">.</em> Also, as you may have noticed, we used another construct available to us from the <kbd class="calibre11">scala.util</kbd> package, named <kbd class="calibre11">Try</kbd><em class="calibre18">.</em> How do we use <kbd class="calibre11">Try</kbd><em class="calibre18">?</em> We pass a function for its evaluation to the <kbd class="calibre11">Try</kbd> block's constructor/apply method. As might be obvious, the <kbd class="calibre11">Try</kbd> block's <kbd class="calibre11">apply</kbd> method takes a function as a <kbd class="calibre11">by-name</kbd> parameter, which tries to evaluate that function. Based on the result or exception, it responds as a <kbd class="calibre11">Success(value)</kbd> or <kbd class="calibre11">Failure(exception)</kbd>.</p>
<p class="calibre2">We used the <kbd class="calibre11">Try</kbd>  <span>construct </span>and passed logic as an argument. On success<em class="calibre18">,</em> we responded as <kbd class="calibre11">Some(value)</kbd>, and in case of failure, we returned <kbd class="calibre11">None</kbd><em class="calibre18">.</em> Both worked well, as these are subtypes of the <kbd class="calibre11">Option</kbd> type<em class="calibre18">.</em> We've already seen <kbd class="calibre11">Option[+T]</kbd> in <a href="part0181.html#5CJLQ0-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 9</a>, <em class="calibre18">Using Powerful Functional Constructs.</em> Let's talk a bit about the <kbd class="calibre11">Try[+T]</kbd> type<em class="calibre18">.</em> We will start with the signature:</p>
<pre class="calibre19">sealed abstract class Try[+T] extends Product with Serializable 
 
object Try { 
  /** Constructs a 'Try' using the by-name parameter.  This 
   * method will ensure any non-fatal exception is caught and a 
   * 'Failure' object is returned. 
   */ 
  def apply[T](r: =&gt; T): Try[T] = 
    try Success(r) catch { 
      case NonFatal(e) =&gt; Failure(e) 
    } 
} 


final case class Success[+T](value: T) extends Try[T] 

final case class Failure[+T](exception: Throwable) extends Try[T] </pre>
<p class="calibre2">Now that we are comfortable working with parameterized types, it will be easier for us to understand the signature of <kbd class="calibre11">Try</kbd><em class="calibre18">.</em> A couple of things to notice are the <kbd class="calibre11">Success</kbd> and <kbd class="calibre11">Failure</kbd> subtypes—no need to explain what they <span>are</span> here for. Let's take a look at the companion object of the type <kbd class="calibre11">Try</kbd>, which has an <kbd class="calibre11">apply</kbd> method, as discussed already. It expects a <kbd class="calibre11">by-name</kbd> parameter. Our famous <kbd class="calibre11">try... catch</kbd> block is taking care of the rest of the stuff.</p>
<p class="calibre2">That's one of the ways you may want to change the function signature to <span>handle exceptions <span>and</span></span> <span>work</span> <span><span>a</span></span><span>s</span> it says it's going to work. Let's talk about a scenario where we might want to pipeline a few operations—in other words, we want to perform functional composition. Take a look at the following function definitions:</p>
<pre class="calibre19">def getAccountInfo(id: String): Option[AccountInfo] 
 
def makeTransaction(amt: Double, accountInfo: AccountInfo): Option[Double] 
 
case class AccountInfo(id: String, balance: Double) </pre>
<p class="calibre2">Seeing these two functions, it seems they can be pipelined together to perform logic in one go. But how? We can pass an account ID to our <kbd class="calibre11">getAccountInfo</kbd> function, which in turn returns an optional <kbd class="calibre11">AccountInfo</kbd>. We can take this account info and the amount and call <kbd class="calibre11">makeTransaction</kbd> to make a transaction. These two operations look good enough to be composed together, but the only problem we have is that the first one's output is optional, and so the second function might or might not get called. So for this, the <kbd class="calibre11">flatMap</kbd> operation looks good. So let's try that:</p>
<pre class="calibre19">import scala.util.Try 
 
object BankApp extends App { 
 
  val accountHolders = Map( 
    "1234" -&gt; AccountInfo("Albert", 1000), 
    "2345" -&gt; AccountInfo("Bob", 3000), 
    "3456" -&gt; AccountInfo("Catherine", 9000), 
    "4567" -&gt; AccountInfo("David", 7000) 
  ) 
 
  def getAccountInfo(id: String): Option[AccountInfo] = Try(accountHolders(id)).toOption 
 
  def makeTransaction(amt: Double, accountInfo: AccountInfo): Option[Double] = Try(accountInfo.balance - amt).toOption 
 
  println(getAccountInfo("1234").flatMap(actInfo =&gt; makeTransaction(100, actInfo))) 
 
  println(getAccountInfo("12345").flatMap(actInfo =&gt; makeTransaction(100, actInfo))) 
} 
 
case class AccountInfo(id: String, balance: Double) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Some(900.0) 
None </pre>
<p class="calibre2">If we take a look at the preceding code, we can see that our <kbd class="calibre11">getAccountInfo</kbd> and <kbd class="calibre11">makeTransaction</kbd> <span>functions</span><span> </span><span>return optional values and either of these results can be</span> <kbd class="calibre11">None</kbd><em class="calibre18">.</em> <span>It will be hard for us to know which operation went wrong as there's no good error message that tells us what went wrong. So to conclude,</span> <kbd class="calibre11">Option</kbd> <span>is a way to handle such scenarios, but it would have been better if we had a way of</span> knowing <span>what went wrong. For that purpose, we can use another construct from Scala, named</span> <kbd class="calibre11">Either</kbd><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Either left or right</h1>
                
            
            <article>
                
<p class="calibre2">Scala has an <kbd class="calibre11">Either[+A, +B]</kbd> <span>type </span><span>for us. But before we talk about</span> <kbd class="calibre11">Either</kbd><span>, let's use it. We'll</span> refactor <span>our code with the</span> <kbd class="calibre11">Either</kbd> <span>type:</span></p>
<pre class="calibre19">import java.lang.Exception 
import scala.util.{Failure, Success, Try} 
 
object Main extends App { 
 
  def toInt(str: String): Either[String, Int] = Try(str.toInt) match { 
    case Success(value) =&gt; Right(value) 
    case Failure(exp) =&gt; Left(s"${exp.toString} occurred," + 
      s" You may want to check the string you passed.") 
  } 
 
  println(toInt("121")) 
  println(toInt("-199")) 
  println(toInt("+ -199")) 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Right(121) 
Right(-199) 
Left(java.lang.NumberFormatException: For input string: "+ -199" occurred, You may want to check the string you passed.) </pre>
<p class="calibre2">In the preceding code, we knew things might go wrong with the conversion from a <kbd class="calibre11">string</kbd> to an <kbd class="calibre11">int</kbd>. So the result can be either an exception or the intended integer. So we tried to do the same: we used the <kbd class="calibre11">Either</kbd> type with the left value as a <kbd class="calibre11">String</kbd> message when things go wrong, and an <kbd class="calibre11">Int</kbd> as the right value. Why so? Let's take a look at the signature of the <kbd class="calibre11">Either</kbd> type to understand that:</p>
<pre class="calibre19">sealed abstract class Either[+A, +B] extends Product with Serializable 
final case class Right[+A, +B](value: B) extends Either[A, B] 
final case class Left[+A, +B](value: A) extends Either[A, B] </pre>
<p class="calibre2">From the preceding signatures, we can see that the <kbd class="calibre11">Either</kbd> type takes two type parameters, <kbd class="calibre11">A</kbd> and <kbd class="calibre11">B</kbd>; by convention, we think of the <kbd class="calibre11">Left</kbd> value as the exceptional case value and the right value as the intended resulting value. That's the reason we declared the response type as follows:</p>
<pre class="calibre19">Either[String, Int] </pre>
<p class="calibre2">This states that we expect either a <kbd class="calibre11">String</kbd> or an <kbd class="calibre11">Int</kbd> value. So the use case is clear. We got to know what happened with our operation—that is, the conversion from a string to the corresponding integer value. Now, why don't we go ahead and try to do some function composition using the <kbd class="calibre11">Either</kbd> type? We can use the same scenario for this:</p>
<pre class="calibre19">import scala.util.{Failure, Success, Try} 
 
object BankApp extends App { 
 
  val accountHolders = Map( 
    "1234" -&gt; AccountInfo("Albert", 1000), 
    "2345" -&gt; AccountInfo("Bob", 3000), 
    "3456" -&gt; AccountInfo("Catherine", 9000), 
    "4567" -&gt; AccountInfo("David", 7000) 
  ) 
 
 
  def getAccountInfo(id: String): Either[String, AccountInfo] = Try(accountHolders(id)) match { 
    case Success(value) =&gt; Right(value) 
    case Failure(excep) =&gt; Left("Couldn't fetch the AccountInfo, Please Check the id passed or try again!") 
  } 
 
 
  def makeTransaction(amount: Double, accountInfo: AccountInfo): Either[String, Double] = Try { 
    if(accountInfo.balance &lt; amount) throw new Exception("Not enough account balance!") else accountInfo.balance - amount 
  } match { 
 
    case Success(value) =&gt; Right(value) 
    case Failure(excep) =&gt; Left(excep.getMessage) 
  }
 
  println(getAccountInfo("1234").flatMap(actInfo =&gt; makeTransaction(100, actInfo))) 
 
  println(getAccountInfo("1234").flatMap(actInfo =&gt; makeTransaction(10000, actInfo))) 
 
  println(getAccountInfo("12345").flatMap(actInfo =&gt; makeTransaction(100, actInfo))) 
} 
 
case class AccountInfo(id: String, balance: Double) </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Right(900.0) 
Left(Not enough account balance!) 
Left(Couldn't fetch the AccountInfo, Please Check the id passed or try again!) </pre>
<p class="calibre2">This is interesting. This new construct made our life easier and gave us meaningful messages about the failures. We're also now able to recognize what went wrong, as well as when things went wrong.</p>
<p class="calibre2">We can see that <kbd class="calibre11">Either</kbd> helps us better in dealing with exceptions. Also, we've seen a couple of ways that we can deal with exceptional cases. What's the take away from the discussion? Let's conclude.</p>
<p class="calibre2">We've seen a few of the constructs available for us to handle exceptional scenarios in Scala programs. You may argue that one of the constructs, <kbd class="calibre11">Try[+T]</kbd>, does nothing but use a <em class="calibre18"/><kbd class="calibre11">try... catch</kbd> block to handle exceptions. So the response we have for the argument is in terms of <em class="calibre18">functional composition.</em> The reason you may want to go for <kbd class="calibre11">scala.util.Try[+T]</kbd> instead of a normal <kbd class="calibre11">try... catch</kbd> block is for reasons of functional composition<em class="calibre18">.</em></p>
<p class="calibre2">The type provides us some functions, such as <kbd class="calibre11">map</kbd> for transformation and <kbd class="calibre11">flatMap</kbd> for composition, so that we can combine two operations together using the <kbd class="calibre11">flatMap</kbd> operation. If you're wondering what this is, let me tell you that we have already seen examples of this. We wanted to compose two functions together to get the result using the <kbd class="calibre11">flatMap</kbd> method, which was possible only because our types <kbd class="calibre11">Try</kbd><em class="calibre18">,</em> <kbd class="calibre11">Option</kbd>, and <kbd class="calibre11">Either</kbd> had this crazy-looking function named <kbd class="calibre11">flatMap</kbd><em class="calibre18">.</em> It's worth taking a look at the implementation of the <kbd class="calibre11">flatMap</kbd> method. This <kbd class="calibre11">flatMap</kbd> function for <kbd class="calibre11">Option</kbd> might look as follows:</p>
<pre class="calibre19">def flatMap[A, B](someValue: Option[A])(functionToPerfom: A =&gt; Option[B]): Option[B] = 
  if (someValue.isEmpty) None else functionToPerfom(someValue.get) </pre>
<p class="calibre2">According to the signature, we're going to pass <kbd class="calibre11">Option[A]</kbd>. The <kbd class="calibre11">A</kbd> argument here is nothing but a type parameter and a function of the form <kbd class="calibre11">A =&gt; Option[B]</kbd>, and the definition is going to give us back the type <kbd class="calibre11">Option[B]</kbd>. That's powerful, and helps us in composing the two functions together. That's one of the reasons you might want to go for <kbd class="calibre11">Option</kbd>/<kbd class="calibre11">Either</kbd>/<kbd class="calibre11">Try</kbd> constructs. Which of the three is going to be used depends upon the use case. The <kbd class="calibre11">Either</kbd> <span>type</span><span> </span><span>gives you the convenience of returning a message when things go wrong.</span></p>
<p class="calibre2">So that explains how we might want to handle exceptions in our Scala programs. Now let's go ahead and talk about a concept that Scala provides to let you do stuff implicitly. Let's talk about implicits in Scala.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implicits - what and why</h1>
                
            
            <article>
                
<p class="calibre2">What are <em class="calibre18">implicits</em>? When we talk about implicits, we mean implicit parameters or conversions that happen implicitly. Implicit parameters are the ones that come along with a keyword, <kbd class="calibre11">implicit</kbd>, and we don't have to explicitly pass an argument for these parameters if they were in Scope. Let's see how.</p>
<p class="calibre2">Let's take an example, and create a <kbd class="calibre11">Future</kbd> value. A <kbd class="calibre11">Future</kbd> is nothing but a computation (that we provide) that's going to happen at a later point in time. It means a computation that's going to happen in the future. We'll talk about <kbd class="calibre11">Future</kbd> values in depth when we discuss concurrent programming techniques in <a target="_blank" href="part0240.html#74S700-921a8f8dca2a47ea817d3e6755fa0e84" class="calibre10">Chapter 13</a>, <em class="calibre18">Concurrent Programming in Scala.</em> Let's write a code snippet for now:</p>
<pre class="calibre19">import scala.concurrent.Future 
 
object FuturesApp extends App { 
 
  val futureComp = Future { 
     1 + 1 
  } 
 
  println(s"futureComp: $futureComp") 
 
  futureComp.map(result =&gt; println(s"futureComp: $result")) 
} </pre>
<p class="calibre2">Okay, we are not sure about how this <kbd class="calibre11">Future</kbd> thing works, but from the code snippet, it looks like there's a computation, 1 + 1, that is wrapped in a <kbd class="calibre11">Future</kbd> block and that we are then printing out this <kbd class="calibre11">Future</kbd> instance. After that, we're extracting the computation's result out of the <kbd class="calibre11">Future</kbd> value and printing it. Looks like it should work fine. Let's run this. We will get the following result:</p>
<pre class="calibre19">Error:(7, 27) Cannot find an implicit ExecutionContext. You might pass 
an (implicit ec: ExecutionContext) parameter to your method 
or import scala.concurrent.ExecutionContext.Implicits.global. 
  val futureComp = Future { 
 
Error:(7, 27) not enough arguments for method apply: (implicit executor: scala.concurrent.ExecutionContext)scala.concurrent.Future[Int] in object Future. 
Unspecified value parameter executor. 
  val futureComp = Future { </pre>
<p class="calibre2">The Scala compiler greets us with two compilation errors. The first one says that it wasn't able to find an implicit value of the <span><kbd class="calibre11">ExecutionContext</kbd> </span>type<em class="calibre18">.</em> Okay, we don't know what this <kbd class="calibre11">ExecutionContext</kbd> is, for now. Let's look at the next error. It says <kbd class="calibre11">not enough arguments for method apply: (implicit executor: ExecutionContext) scala.concurrent.Future[Int]</kbd><em class="calibre18">.</em></p>
<p class="calibre2">Now, we've got this idea that there's an argument that is needed that's not available to our code. Let's take a look at the <kbd class="calibre11">Future</kbd> block's <kbd class="calibre11">apply</kbd> method for that:</p>
<pre class="calibre19">def apply[T](body: =&gt;T)(implicit executor: ExecutionContext): Future[T] </pre>
<p class="calibre2">Okay, this seems interesting. We've got this <kbd class="calibre11">implicit</kbd> keyword for the parameter <kbd class="calibre11">ExecutionContext</kbd>. It means that it's okay to call the <kbd class="calibre11">Future</kbd> block's <kbd class="calibre11">apply</kbd> method; the only thing we need to take care of is the implicit value of the type declared. So things should work fine if somehow we can get the value of type <kbd class="calibre11">ExecutionContext</kbd> available into our scope. What do we mean by scope? Let's think of the current compilation unit (Scala file) as the scope, for now. So let's do this:</p>
<pre class="calibre19">import scala.concurrent.Future 
 
object FuturesApp extends App { 
 
  implicit val ctx = scala.concurrent.ExecutionContext.Implicits.global 
 
  val futureComp = Future { 
     1 + 1 
  } 
 
  println(s"futureComp: $futureComp") 
 
  futureComp.map(result =&gt; println(s"futureComp: $result")) 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">futureComp: Future(Success(2)) 
futureComp: 2 </pre>
<p class="calibre2">We've declared an <kbd class="calibre11">implicit</kbd> value named <kbd class="calibre11">ctx</kbd> of the type <kbd class="calibre11">ExecutionContext</kbd><em class="calibre18">,</em> and then tried to run the application again, and magically things worked fine. We didn't pass any context explicitly or do something extraordinary—we've just brought the value of the desired type into scope and things worked. We've got the results. One thing to note, though, is that we've used this <kbd class="calibre11">implicit</kbd><span> keyword</span><em class="calibre18">;</em> <span>that's the reason</span> <kbd class="calibre11">Future.apply</kbd> <span>was able to infer the value available in scope. If we tried this without the </span><kbd class="calibre11">implicit</kbd> <span>keyword,</span> <span>we'd get similar compilation errors to those that we had previously. So the idea is to get an implicit value in scope, and now we know what's implicit. There's a big question though: why would</span> <span>you</span> <span>want to have this kind of behavior? We're going to have a healthy discussion regarding this idea.</span></p>
<p class="calibre2">Let's start with the idea that implicits in Scala can be used to automate the process of passing a value to an operation or conversion from one type to another type. Let's talk about the first one: implicit parameters.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implicit parameters</h1>
                
            
            <article>
                
<p class="calibre2">We use implicit parameters when we want the compiler to help us find a <span>value</span> that's already available for a certain type. We've just seen an example of an implicit parameter when we talked about <kbd class="calibre11">Future</kbd>. Why don't we define some<span>thing</span> similar for ourselves?</p>
<p class="calibre2">We can think of a scenario where we need to show the present date <span>in our application</span> and we want to avoid passing a date's instance explicitly again and again. Instead, we can make the <kbd class="calibre11">LocalDateTime.now</kbd> value implicit to the respective functions and let the current date and time be passed as an implicit parameter to them. Let's write some code for this:</p>
<pre class="calibre19">import java.time.{LocalDateTime} 
 
object ImplicitParameter extends App { 
 
  implicit val dateNow = LocalDateTime.now() 
 
  def showDateTime(implicit date: LocalDateTime) = println(date) 
   
  //Calling functions! 
  showDateTime 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">2017-11-17T10:06:12.321 </pre>
<p class="calibre2">Think of the <kbd class="calibre11">showDateTime</kbd> <span>function</span><span> </span><span>as the one that needs the date-time's current value—hence it's possible for us to make it available as an implicit one. That's what we did—in the definition of</span> <kbd class="calibre11">showDateTime</kbd><em class="calibre18">,</em> <span>we declared an implicit parameter named</span> <kbd class="calibre11">date</kbd> <span>of the type</span> <kbd class="calibre11">LocalDateTime</kbd><em class="calibre18">.</em><span>  We a</span><span>lso</span> <span>have an implicit value named</span> <kbd class="calibre11">dateNow</kbd> <span>in scope. That's why</span> <span>we didn't have to pass an argument a</span><span>t the call site  and things</span> <span>still</span> <span>worked out good for us.</span></p>
<p class="calibre2">This seems a good use case. You can make your desired values automatically available for yourself using <em class="calibre18">implicits.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The implicitly method</h1>
                
            
            <article>
                
<p class="calibre2">Scala's standard library provides a utility method to create concrete instances of types' availability implicitly. The method's name is also <kbd class="calibre11">implicitly</kbd><em class="calibre18">.</em> Let's take a look at the function signature:</p>
<pre class="calibre19">def implicitly[T](implicit e: T) = e </pre>
<p class="calibre2">This <kbd class="calibre11">implicitly</kbd> method simply expects a type parameter, finds the implicit value available in scope, and summons and returns it to us. This is a good option available to us to tell whether a particular type's value is available in implicit scope. Let's look at an application of this method:</p>
<pre class="calibre19">import java.time.{LocalDateTime} 
 
object ImplicitParameter extends App { 
 
  implicit val dateNow = LocalDateTime.now() 
 
  def showDateTime(implicit date: LocalDateTime) = println(date) 
 
  val ldt = implicitly[LocalDateTime] 
 
  println(s"ldt value from implicit scope: $ldt") 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">ldt value from implicit scope: 2017-12-17T10:47:13.846 </pre>
<p class="calibre2">In the preceding code snippet, a call to <kbd class="calibre11">implicitly</kbd>, along with the type, returned us the value available—as we already know, it's the current date-time value.</p>
<p class="calibre2">So this is how we can use the <kbd class="calibre11">implicit</kbd> parameter in our definitions and make them available to respective scopes.</p>
<p class="calibre2">With some idea about implicits now, let's take a look at <em class="calibre18">implicit conversions.</em></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Implicit conversions</h1>
                
            
            <article>
                
<p class="calibre2">The Standard Scala FAQ page describes implicit conversions as: <em class="calibre18">"</em>If one calls a method <kbd class="calibre11">m</kbd> on an object <kbd class="calibre11">o</kbd> of a class <kbd class="calibre11">C</kbd> and that class <kbd class="calibre11">C</kbd> does not support method <kbd class="calibre11">m</kbd>, then Scala compiler will look for an implicit conversion from <kbd class="calibre11">C</kbd> type to something that does support <kbd class="calibre11">m</kbd> method<em class="calibre18">"</em><span>.</span></p>
<p class="calibre2">The idea is clear: it's a synthetic behavior (using a method) that we're forcing on instances of a particular type, and these behaviors (methods) aren't a part of the <span>defined</span> type. It's like we have a library with certain functionalities already available and we want to give some add-on functionality to a certain type from the library. Think about it—this is powerful. Having the ability to add on a functionality for a particular type is itself powerful. And that's what implicits let us do. We'll try our hand at something like the following.</p>
<p class="calibre2">First, think of a scenario where we want to create some syntax methods. We have a few methods available for the date-time library <kbd class="calibre11">java.time.LocalDate</kbd> that can help us add or subtract days/weeks/months/years, and those methods are:</p>
<pre class="calibre19">scala&gt; import java.time.LocalDate 
import java.time.LocalDate 
 
scala&gt; val ld = LocalDate.now 
ld: java.time.LocalDate = 2017-12-17 
 
scala&gt; ld.plusDays(1) 
res0: java.time.LocalDate = 2017-12-18 
 
scala&gt; ld.plusWeeks(1) 
res1: java.time.LocalDate = 2017-12-24 
 
scala&gt; ld.plusMonths(1) 
res2: java.time.LocalDate = 2018-01-17 
 
scala&gt; ld.plusYears(1) 
res3: java.time.LocalDate = 2018-12-17 </pre>
<p class="calibre2">What we would like to have is a simple + or - for days/weeks/months/years to work as the <kbd class="calibre11">plusXXX</kbd> or  methods. What are all the options we have to achieve such a syntax?</p>
<p class="calibre2">One of the options is to create a <kbd class="calibre11">Wrapper</kbd> class over <kbd class="calibre11">LocalDate</kbd><em class="calibre18">,</em> such as a <kbd class="calibre11">CustomDate(date: LocalDate)</kbd>, and define these methods for it. In that case, the code might look like this:</p>
<pre class="calibre19">import java.time.LocalDate 
 
case class CustomDate(date: LocalDate) { 
  def +(days: Day): CustomDate = CustomDate(this.date.plusDays(days.num)) 
  def -(days: Day): CustomDate = CustomDate(this.date.minusDays(days.num)) 
 
  def +(weeks: Week): CustomDate = CustomDate(this.date.plusWeeks(weeks.num)) 
  def -(weeks: Week): CustomDate = CustomDate(this.date.minusWeeks(weeks.num)) 
 
  def +(months: Month): CustomDate = CustomDate(this.date.plusMonths(months.num)) 
  def -(months: Month): CustomDate = CustomDate(this.date.minusMonths(months.num)) 
 
  def +(years: Year): CustomDate = CustomDate(this.date.plusYears(years.num)) 
  def -(years: Year): CustomDate = CustomDate(this.date.minusYears(years.num)) 
 
  def till(endDate: CustomDate): CustomDateRange = if(this.date isBefore endDate.date) 
    CustomDateRange(this, endDate) 
  else { 
    throw new IllegalArgumentException("Can't create a DateRange with given start and end dates.") 
  } 
 
  override def toString: String = s"Date: ${this.date}" 
} 
 
case class Day(num: Int) 
case class Week(num: Int) 
case class Month(num: Int) 
case class Year(num: Int) 
 
case class CustomDateRange(sd: CustomDate, ed: CustomDate){ 
  override def toString: String = s"$sd till $ed " 
} </pre>
<p class="calibre2">As you might have noticed in the preceding code, we have a <kbd class="calibre11">CustomDate</kbd> <span>class</span><span> </span><span>wrapping over the type</span> <kbd class="calibre11">LocalDate</kbd><span>, and are using the</span> <kbd class="calibre11">LocalDate</kbd> <span>type's methods to define our own</span> desired <span>syntax methods. Let's try using it. For this, we can create another object extending</span> <kbd class="calibre11">App</kbd> <span>trait:</span></p>
<pre class="calibre19">import java.time.LocalDate 
 
object BeautifulDateApp extends App { 
 
  val today = CustomDate(LocalDate.now()) 
  val tomorrow = today + Day(1) 
  val yesterday = today - Day(1) 
 
  println(today) 
  println(tomorrow) 
  println(today + Year(1)) 
 
  val dateRange = today till tomorrow + Day(20) 
  println(dateRange) 
 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Date: 2017-12-17 
Date: 2017-12-18 
Date: 2018-12-17 
Date: 2017-12-17 till Date: 2018-01-07 </pre>
<p class="calibre2">By taking a look at the preceding code snippet, we can see that things worked fine: we've got the desired syntax for adding extra days to our date. But wrapping <kbd class="calibre11">LocalDate</kbd> gives us the feeling that this syntax isn't a part of the standard library we have. So for this, implicits come into the picture. We're going to do a similar syntax hack using the implicit class.</p>
<p class="calibre2">For this, we're going to create an implicit class that takes nothing but a <kbd class="calibre11">val</kbd> of the type <kbd class="calibre11">LocalDate</kbd><em class="calibre18">,</em> then similar logic to provide all of our syntax methods. Afterwards, we'll bring that implicit class in scope by importing it. Let's write that:</p>
<pre class="calibre19">case class Day(num: Int) 
case class Week(num: Int) 
case class Month(num: Int) 
case class Year(num: Int) 
 
case class CustomDateRange(sd: CustomDate, ed:CustomDate){ 
  override def toString: String = s"$sd till $ed " 
} 
 
object LocalDateOps { 
  implicit class CustomDate(val date: LocalDate) { 
 
    def +(days: Day): CustomDate = CustomDate(this.date.plusDays(days.num)) 
    def -(days: Day): CustomDate = CustomDate(this.date.minusDays(days.num)) 
 
    def +(weeks: Week): CustomDate = CustomDate(this.date.plusWeeks(weeks.num)) 
    def -(weeks: Week): CustomDate = CustomDate(this.date.minusWeeks(weeks.num)) 
 
    def +(months: Month): CustomDate = CustomDate(this.date.plusMonths(months.num)) 
    def -(months: Month): CustomDate = CustomDate(this.date.minusMonths(months.num)) 
 
    def +(years: Year): CustomDate = CustomDate(this.date.plusYears(years.num)) 
    def -(years: Year): CustomDate = CustomDate(this.date.minusYears(years.num)) 
 
    def till(endDate: CustomDate): CustomDateRange = if(this.date isBefore endDate.date) 
      CustomDateRange(this, endDate) 
    else { 
      throw new IllegalArgumentException("Can't create a DateRange with given start and end dates.") 
    } 
 
    override def toString: String = s"Date: ${this.date}" 
  } 
} </pre>
<p class="calibre2">Now, it's time to use the same in our <kbd class="calibre11">BeautifulDateApp</kbd> class<em class="calibre18">:</em></p>
<pre class="calibre19">import java.time.LocalDate 
import LocalDateOps._ 
 
object BeautifulDateApp extends App { 
 
  val today = LocalDate.now() 
  val tomorrow = today + Day(1) 
  val yesterday = today - Day(1) 
 
  println(today) 
  println(tomorrow) 
  println(today + Year(1)) 
 
  val dateRange = today till tomorrow + Day(20) 
  println(dateRange) 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">2017-12-17 
Date: 2017-12-18 
Date: 2018-12-17 
Date: 2017-12-17 till Date: 2018-01-07 </pre>
<p class="calibre2">We can see the difference in the two approaches we took. The second one seems the more native approach. As consumers of these syntax methods, we never tried to call the <kbd class="calibre11">CustomDate</kbd> class—rather, we created an instance of the <kbd class="calibre11">LocalDate</kbd> type<em class="calibre18">:</em></p>
<pre class="calibre19">  val today = LocalDate.now() </pre>
<p class="calibre2">We used <kbd class="calibre11">+</kbd> and <kbd class="calibre11">-</kbd> like native methods defined in the <kbd class="calibre11">LocalDate</kbd> class. That's the power, or let's say magic, of <em class="calibre18">implicit conversions.</em> For those who want to know what happened in the background, let's look at the workings of the code in more detail.</p>
<p class="calibre2">The Scala compiler saw this:</p>
<pre class="calibre19">val tomorrow = today + Day(1) </pre>
<p class="calibre2">The compiler then tried to look for a method named <kbd class="calibre11">+</kbd> that takes a day as a parameter in the <kbd class="calibre11">LocalDate</kbd> class. It's not surprising that the compiler wasn't able to find such a method there, hence it tried to check whether there was any other class available in the implicit scope that is expecting a <kbd class="calibre11">LocalDate</kbd> and that was performing operations such as <kbd class="calibre11">+</kbd> with a day/week/month/year<em class="calibre18">.</em> Then, the compiler found our <kbd class="calibre11">CustomDate</kbd> implicit class. Finally, implicit conversion took place and this particular method call worked for us. We were then able to make such method syntax hacks possible.</p>
<p class="calibre2">Now that we've seen such an example, one question that we might want to ask ourselves is what do we mean by <em class="calibre18">implicit scope?</em> We also need to see how the Scala compiler searches for implicit values. Let's try to get an answer to this.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Looking for implicits</h1>
                
            
            <article>
                
<p class="calibre2">Your usual application Scala code might contain some constructs that import other classes and objects, or it might also inherit other classes. You write methods that expect types as parameters and also declare parameters. So when the Scala compiler looks for an implicit value, where should <span>it</span> start looking for such a value? The compiler starts to look for an implicit value according to the following criteria:</p>
<ul class="calibre7">
<li class="calibre8">Defined in current scope</li>
<li class="calibre8">Explicitly imported</li>
<li class="calibre8">Imported using wildcards</li>
<li class="calibre8">Companion object of a type</li>
<li class="calibre8">Implicit scope of an argument's type</li>
<li class="calibre8">Implicit scope of type arguments</li>
<li class="calibre8">Outer objects for nested types</li>
</ul>
<p class="calibre2">We know that if we define an implicit value in the current scope (block of code), it gets the highest precedence. Afterwards, you can also import it using an <kbd class="calibre11">import</kbd> statement, as shown in the following code:</p>
<pre class="calibre19">import scala.concurrent.Future 
import scala.concurrent.ExecutionContext.Implicits.global 
 

object FuturesApp extends App { 
 
  val futureComp = Future { 
     1 + 1 
  } 
 
  println(s"futureComp: $futureComp") 
 
  futureComp.map(result =&gt; println(s"futureComp: $result")) 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">futureComp: Future(Success(2)) 
futureComp: 2 </pre>
<p class="calibre2">A wildcard import can also work for this:</p>
<pre class="calibre19">import scala.concurrent.ExecutionContext.Implicits._ </pre>
<p class="calibre2">But life's a bit uncomfortable for the compiler, as well as us, when it sees two implicit values eligible for the same type in the same scope. What we then see is a compilation error stating <kbd class="calibre11">ambiguous implicits</kbd><em class="calibre18">.</em> Let's try that:</p>
<pre class="calibre19">import scala.concurrent.Future 
import scala.concurrent.ExecutionContext.Implicits.global 
 
object FuturesApp extends App { 
 
  implicit val ctx = scala.concurrent.ExecutionContext.Implicits.global 
 
  val futureComp = Future { 
     1 + 1 
  } 
 
  println(s"futureComp: $futureComp") 
 
  futureComp.map(result =&gt; println(s"futureComp: $result")) 
} </pre>
<p class="calibre2">For the preceding code, we'll face this compilation error:</p>
<pre class="calibre19">Error:(10, 27) ambiguous implicit values: 
 both lazy value global in object Implicits of type =&gt; scala.concurrent.ExecutionContext 
 and value ctx in object FuturesApp of type =&gt; scala.concurrent.ExecutionContext 
 match expected type scala.concurrent.ExecutionContext 
  val futureComp = Future { </pre>
<p class="calibre2">So, we need to take care of the implicit value's ambiguity.</p>
<p class="calibre2">If the compiler isn't able to find the implicit value in the current block of code or via imports, it searches for it in companion objects of the type. That's how the compiler searches for implicit values. The standard Scala documentation explains the topic of finding implicits, which you can find at: <a href="http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html" class="calibre10">http://docs.scala-lang.org/tutorials/FAQ/finding-implicits.html</a>.</p>
<p class="calibre2">With this discussion of implicits, we've seen few ways in which we can use the concept and let the magic work for us. It's widely used by library designers when they define type-classes and make their instances available via implicit values. We've covered what type classes are, and we can create one on our own. Let's try that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Type-classes ahead!</h1>
                
            
            <article>
                
<p class="calibre2">When creating type-classes to solve problems, such as providing a mechanism to encode types in a particular format, we have to unleash the power of languages such as Scala. What we desire is a way to encode values of a certain type in <strong class="calibre1">comma-separated value</strong> (<strong class="calibre1">CSV</strong>) format. For that purpose, we'll create a type-class named <kbd class="calibre11">CSVEncoder</kbd>. In Scala, we can do this using a trait of some type by convention:</p>
<pre class="calibre19">trait CSVEncoder[T]{ 
  def encode(value: T): List[String] 
} </pre>
<p class="calibre2">What we defined is a functionality provider for our types. The functionality right now is to encode a value of some particular type and give back a list of string values that we can represent in CSV. Now, you might want to use this functionality by calling some functions on it, right? For a simple type such as <kbd class="calibre11">Person</kbd>, it can look like this:</p>
<pre class="calibre19">case class Person(name: String) 
 
CSVEncoder.toCSV(Person("Max")) </pre>
<p class="calibre2">Some other syntax might look like this:</p>
<pre class="calibre19">Person("Caroline").toCSV </pre>
<p class="calibre2">To use something like these, what we need is this:</p>
<ul class="calibre7">
<li class="calibre8">A way to encode the type <kbd class="calibre11">Person</kbd> in CSV format</li>
<li class="calibre8">The utility function <kbd class="calibre11">toCSV</kbd></li>
</ul>
<p class="calibre2">Let's define the ways our type-class-provided functionality can be used:</p>
<pre class="calibre19">object CSVEncoder { 
  
 def toCSV[T](list: List[T])(implicit encoder: CSVEncoder[T]): String = 
  list.map(mem =&gt; encoder.encode(mem).mkString(", ")).mkString(", ") 
 
} </pre>
<p class="calibre2">Here, we have defined a companion object for <kbd class="calibre11">CSVEncoder</kbd> and defined our utility function named <kbd class="calibre11">toCSV</kbd>, which takes a type parameter and sequence of values of the same type, except that it expects an implicit <kbd class="calibre11">CSVEncoder</kbd> instance for the same type. What it returns in turn is a <kbd class="calibre11">List[String]</kbd><em class="calibre18">.</em> We know it's easy to convert a sequence of string values in CSV. The definition is something that we want from this function. Hence, we simply call <kbd class="calibre11">encoder.encode(value)</kbd> and convert the values in comma-separated format.</p>
<p class="calibre2">Now, let's define a way to encode the <kbd class="calibre11">Person</kbd> type:</p>
<pre class="calibre19">implicit val personEncoder: CSVEncoder[Person] = new CSVEncoder[Person] { 
  def encode(person: Person) = List(person.name) 
} </pre>
<p class="calibre2">In the preceding code, we provided a way to encode our <kbd class="calibre11">Person</kbd> type. Now, let's use it:</p>
<pre class="calibre19">object EncoderApp extends App { 
  import CSVEncoder.personEncoder 
 
  println(CSVEncoder.toCSV(List(Person("Max Black"), Person("Caroline Channing")))) 
 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Max Black, Caroline Channing </pre>
<p class="calibre2">What we did here in our <kbd class="calibre11">EncoderApp</kbd> is import <kbd class="calibre11">CSVEncoder[Person]</kbd> implicitly and call a <kbd class="calibre11">toCSV</kbd> function with the expected value. Calling this function gives us the desired result<em class="calibre18">.</em> We can now hack the <kbd class="calibre11">toCSV</kbd> <span>function</span><span> </span><span>syntax using an implicit class and give the consumer of our type-class another way of using our encoder. Let's do that:</span></p>
<pre class="calibre19">trait CSVEncoder[T]{ 
  def encode(value: T): List[String] 
} 
 
object CSVEncoder { 
 
  def toCSV[T](list: List[T])(implicit encoder: CSVEncoder[T]): String = 
    list.map(mem =&gt; encoder.encode(mem).mkString(", ")).mkString(", ") 
 
  implicit val personEncoder: CSVEncoder[Person] = new CSVEncoder[Person] {<br class="title-page-name"/>     def encode(person: Person) = List(person.name) 
  } 
 
} 
 
case class Person(name: String) 
 
object EncoderApp extends App { 
  import CSVEncoder._ 
  import CSVEncoderOps._ 
 
  println(CSVEncoder.toCSV(List(Person("Max Black"), Person("Caroline Channing")))) 
 
  println(List(Person("Max Black"), Person("Caroline Channing")).toCSV) 
} 
 
object CSVEncoderOps { 
  implicit class CSVEncoderExt[T](list: List[T]) { 
    def toCSV(implicit encoder: CSVEncoder[T]) : String = 
      list.map(mem =&gt; encoder.encode(mem).mkString(", ")).mkString(", ") 
  } 
} </pre>
<p class="calibre2">The following is the result:</p>
<pre class="calibre19">Max Black, Caroline Channing 
Max Black, Caroline Channing </pre>
<p class="calibre2">In the preceding code snippet, we were able to call the <kbd class="calibre11">toCSV</kbd> function as a method:</p>
<pre class="calibre19">List(Person("Max Black"), Person("Caroline Channing")).toCSV </pre>
<p class="calibre2">We achieved this syntax call using the implicit <kbd class="calibre11">CSVEncoderExt</kbd><span> class</span><span>, which was the approach we took in the case of the syntax methods for</span> <kbd class="calibre11">LocalDate</kbd><span>:</span></p>
<pre class="calibre19">implicit class CSVEncoderExt[T](list: List[T]) { 
    def toCSV(implicit encoder: CSVEncoder[T]) : String = 
      list.map(mem =&gt; encoder.encode(mem).mkString(", ")).mkString(", ") 
  } </pre>
<p class="calibre2">All we had to do was take care that this particular class was in the scope at the call site, so we imported it. This is how we have created and used our first type-class. It wasn't that hard, was it? Sure, we have covered enough <span>about type-classes</span> in this chapter. Let's go ahead and summarize what we've learned in this chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">First, we discussed exceptional cases that occur when we try programming. We saw how we handle these exceptional cases in functional programming. We even tried exception handling in functional composition. Then, we began to see the magic that implicits bring in Scala. We discussed implicit parameters and then <em class="calibre18">implicit conversion.</em> We saw the <kbd class="calibre11">implicitly</kbd> <span>method, <span>provided</span> by the</span> Scala standard library. Finally, we talked about the already much-talked-about type-classes, and defined/used our first one. Once you practice enough with the concepts that we have discussed, it's worth going through type-classes in detail. Most of the Scala libraries' frameworks heavily use this concept.</p>
<p class="calibre2">In the next chapter, we'll learn about the Akka toolkit. We'll cover <em class="calibre18">Actor System</em>, one of Akka's offerings, and much more.</p>


            </article>

            
        </section>
    </body></html>