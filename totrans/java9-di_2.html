<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Injection in Java 9</h1>
                
            
            <article>
                
<p class="calibre2">In the previous chapter, we got acquainted with the Dependency Injection Principle, IOC with different scenarios, and different types of Dependency Injection by writing code.</p>
<p class="calibre2">In this chapter, we will learn about the new features offered in Java 9. Specifically, we will learn about modularity in Java 9, modularity framework, types of modules offered in Java 9, and we will see Dependency Injection using modules.<br class="calibre5"/>
This chapter will mainly cover the following topics:</p>
<ul class="calibre9">
<li class="calibre10">Java 9 introduction</li>
<li class="calibre10">Modular Framework in Java 9</li>
<li class="calibre10">Dependency Injection using Java 9 Modular Framework</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java 9 introduction</h1>
                
            
            <article>
                
<p class="calibre2">Before learning what's new in Java 9, we need to know one of the important components of Java, which is <strong class="calibre4">Java Development Kit</strong> (<strong class="calibre4">JDK</strong>).</p>
<p class="calibre2">JDK is a collection of <strong class="calibre4">Java Standard Edition</strong> (<strong class="calibre4">Java SE</strong>), <strong class="calibre4">Java Enterprise Edition</strong> (<strong class="calibre4">Java EE</strong>), <strong class="calibre4">Java Micro Edition</strong> platforms (<strong class="calibre4">Java ME</strong>), and different tools such as javac, Java console, JAR, JShell, Jlink, and it provides all the libraries for developing, debugging, and monitoring for building Java-based applications.</p>
<p class="calibre2">Java 9 has come up with almost over 100 new features and enhancements in different categories of JDK, such as <span class="calibre11">t</span>ools, security, deployment, performance tuning, API changes of core libraries, and javadoc. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Key features</h1>
                
            
            <article>
                
<p class="calibre2">Let's look at some of the key features of <span class="calibre11">Java 9 in brief</span>, which will change Java software development:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Java Platform Module System</strong> (<strong class="calibre1">JPMS</strong>)</li>
<li class="calibre10">JShell (REPL)—The Java Shell</li>
<li class="calibre10">JLink—Module Linker</li>
<li class="calibre10">Multi-Release JAR Files</li>
<li class="calibre10">Stream API enhancements</li>
<li class="calibre10">Stack—Walking API</li>
<li class="calibre10">Immutable collections with convenient factory methods</li>
<li class="calibre10">Support of HTTP 2.0</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java Platform Module System</h1>
                
            
            <article>
                
<p class="calibre2">The introduction of <strong class="calibre4">Java Platform Module System</strong> (<strong class="calibre4">JPMS</strong>) is key and a game changer feature of Java 9 and JPMS developed under the shed of project Jigsaw.</p>
<p class="calibre2">The main objectives of project Jigsaw are as follows:</p>
<ul class="calibre9">
<li class="calibre22">Scalable JDK: Until Java 8, engineering of JDK is solid and contains a number of components, which make it troublesome to maintain and develop. JDK 9 is partitioned into sets of independent modules, which permits custom runtime capability to incorporate only required modules in our application, which offers assistance to diminish runtime size.</li>
<li class="calibre22">Robust encapsulation and security: Bundles from the module can be expressly exposed if required by other modules. On the other hand, another module has to explicitly define which particular bundles are required from modules. This way, modules can encapsulate particular bundles for security purposes.</li>
<li class="calibre22">Dependency: Modern module frameworks permit us to define unequivocal dependency between modules and all required subset modules dependency can be distinguished at compile time.</li>
<li class="calibre22">Modern rebuild permits us to incorporate runtime <span>images </span>of modules, which gives superior performance of JDK. It moreover evacuates <kbd class="calibre12">tools.jar</kbd> and <kbd class="calibre12">rt.jar</kbd> from runtime <span>images</span>.</li>
<li class="calibre22">To secure the internal structure of runtime images, an unused URI conspire is utilized for naming modules, resources, and classes.</li>
</ul>
<p class="calibre2">We will discuss JPMS in detail in the <em class="calibre13">Modular Framework in Java 9</em> section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">JShell (REPL) – The Java Shell</h1>
                
            
            <article>
                
<p class="calibre2">In earlier JDK, we did not have the luxury of running code using a command line interface. For learning new functions such as the matches function of regular expression API and many more, we had to write a necessary skeleton of Java, <kbd class="calibre12">public static void main(String[] args)</kbd>, and go through the compilation and execution phase.</p>
<p class="calibre2">Java 9 introduced JShell, a command line tool. It uses the <span class="calibre11"><strong class="calibre4">Read-Eval-Print Loop</strong> </span>(<strong class="calibre4">REPL</strong>) principle to provide a command line interface to interact with the Java platform and provide an interactive way of running a program without writing necessary <span class="calibre11">skeletons</span>.</p>
<p class="calibre2">JShell came up with a parser that parses submitted code and identifies different types such as a variable, a declared method, loop, and many more, and put them all together in a dummy skeleton to make a complete Java program to pass it to the compiler. Based on the inputs compiler, it converts it into byte code. During this process, a file is not created, so it will all be saved in memory. At the end, the generated byte code is used by JVM to load and execute.</p>
<p class="calibre2">JShell is located in the <kbd class="calibre12">bin</kbd> directory of shipped JDK 9. Using a command interface, traverse to the <kbd class="calibre12">bin</kbd> directory and type command <kbd class="calibre12">JShell</kbd> to start the tool:</p>
<div class="mce-root"><img src="../images/00013.gif" class="calibre30"/></div>
<p class="calibre2">Let’s consider a program that we used to write in IDE. Here is a simple program to print a string message into uppercase:</p>
<pre class="calibre17">module javaIntroduction {<br class="title-page-name"/>}<br class="title-page-name"/>package com.packt.java9dependency.examples;<br class="title-page-name"/>public class Main {<br class="title-page-name"/>   public static void main(String[] args) {<br class="title-page-name"/>    String s = "hello java module system".toUpperCase();<br class="title-page-name"/>      System.out.println(s);<br class="title-page-name"/>   }<br class="title-page-name"/>}                                                                 </pre>
<p class="calibre2">Now, we can get quick output of the preceding string message by directly writing a statement in the JShell tool, declaring variables and <kbd class="calibre12">println</kbd> statements is not required. <span class="calibre11">JShell provides various command features that make a developer's life easy when writing quick code snippets.</span></p>
<div class="mce-root"><img src="../images/00014.gif" class="calibre31"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">JLink – Module Linker</h1>
                
            
            <article>
                
<p class="calibre2">When we are talking about modular systems, then immediately one question comes, how dependencies  of modules will organize and what will be impact on final deployment?</p>
<p class="calibre2">The JLink tool is designed to provide optional phases between compile time and runtime, called link time, which links a set of modules and its transitive dependencies to create runtime images. JLink makes deployment simpler and also reduces the size of an application.</p>
<p class="calibre2">The invocation syntax of <kbd class="calibre12">jLink</kbd> is as follows:</p>
<pre class="calibre17">jlink --module-path &lt;modulepath&gt; --add-modules &lt;modules&gt; --limit-modules &lt;modules&gt; --output &lt;path&gt;<br class="title-page-name"/><br class="title-page-name"/>--module-path - jLink use module path for finding modules such as modular jars, JMOD files<br class="title-page-name"/>--add-modules - Mention module which needs to include in default set of modules for run time image, by default set of modules in empty.<br class="title-page-name"/>--limit-modules - Use this option to limits modules, which is required for our application.<br class="title-page-name"/>--output - Final resulting run time image will be stored in output directory <br class="title-page-name"/>--help - list details about jLink options<br class="title-page-name"/>--version - show the version number</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Multi-release JAR files</h1>
                
            
            <article>
                
<p class="calibre2">We have seen many third-party libraries, support for several Java versions with backward compatibility. Because of this, they don't use the latest API features introduced in new releases of JDK. Since Java 8, there is no facility to define condition-based platform dependencies for using new features.</p>
<p class="calibre2">Java 9 introduced a multi-release jar concept. It allows developers to create alternative versions of each class, which are only used when running on specific Java versions.</p>
<div class="mce-root">  <img src="../images/00015.jpeg" class="calibre32"/></div>
<p class="calibre2">The preceding diagram shows the structure of a multi-release jar. It contain resources and classes along with the <span class="calibre11"><span class="calibre11">Meta-INF </span></span>directory for metadata. This metadata file contains version-specific details to encode jar files to provide a compatible method for multiple versions of libraries that run on a target Java platform.</p>
<p class="calibre2">To continue on with the preceding example, we can see that the <strong class="calibre4">javaMutipleJar</strong> library has three classes, <strong class="calibre4">Class1.class</strong>, <strong class="calibre4">Class2.class</strong>, and <strong class="calibre4">Class3.class</strong>, at root level build with Java 8. <span class="calibre11">If we deploy this jar in JDK, which does not support MARJAR, then only the root level classes will be visible and later platform classes will be ignored. </span></p>
<p class="calibre2">Moreover, <strong class="calibre4">Class1.class</strong> and <strong class="calibre4">Class2.class</strong> want to use Java 9 features, so then only those classes will bundle with Java 9 compilation. When Java 10 comes and <strong class="calibre4">Class1.class</strong> wants to use Java 10 features, then, as mentioned in the diagram, because of MARJAR concepts, it will bundle with the Java 10 platform. </p>
<p class="calibre2">Ultimately, multi-release jar concepts help third-party library and framework developers to easily separate the use of new APIs for specific JDK for supporting migration as well as continuing to support older versions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stream API enhancements</h1>
                
            
            <article>
                
<p class="calibre2">Stream is a pipeline that contains elements in sequential form to support aggregation operations on collections of data. Stream API is a major feature of Java 8, which provides sequential and parallel execution with filtering based on criteria, all this together is known as internal iteration of Stream.</p>
<p class="calibre2">Java 9 added four new methods to make the Stream API better for iterating operations. <kbd class="calibre12">dropWhile</kbd> and <kbd class="calibre12">takeWhile  </kbd><span class="calibre11">methods are default methods and <kbd class="calibre12">iterate</kbd> and <kbd class="calibre12">ofNullable</kbd> are static methods in the <kbd class="calibre12">java.util.stream</kbd> interface. Let's discuss the <kbd class="calibre12">takeWhile</kbd> method use.</span></p>
<p class="calibre2">Stream API Syntax:</p>
<pre class="calibre17">default Stream&lt;T&gt; takeWhile(Predicate&lt;? super T&gt; predicate)</pre>
<div class="mce-root"><img src="../images/00016.gif" class="calibre33"/></div>
<p class="calibre2"><span class="calibre11">The <kbd class="calibre12">takeWhile()</kbd> method returns the longest prefix, which matches the predicate for the ordered stream. As from the preceding code, <kbd class="calibre12">takeWhile</kbd> returns the first three elements because of matching with the predicate.</span></p>
<p class="calibre2">For u<span class="calibre11">nordered</span> streams, the <kbd class="calibre12">takeWhile()</kbd> method returns a prefixed element until the predicate condition is true. It stops iteration if the predicate condition returns false and returns a list of elements that predicate evaluated until the condition fails for the first time.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Stack-walking API</h1>
                
            
            <article>
                
<p class="calibre2">To debug exceptions, we look at the root cause of exception by traversing the stack trace. Prior to Java 9, we all used <kbd class="calibre12">Thread.getStackTrace()</kbd> to get <kbd class="calibre12">StackTraceElement</kbd> objects in the form of arrays.</p>
<p class="calibre2"><strong class="calibre4">StackTraceElement</strong>: Each element of <kbd class="calibre12">StackTraceElement</kbd> is a single <kbd class="calibre12">StackFrame</kbd>, which provides details about classname, method name, filename, and line number where the exception was generated. Except for the first <kbd class="calibre12">StackFrame</kbd>, all the other elements represent the method invocation call from the starting point of the application to the point where the exception generated. This is helpful when we want auditing of generated error logs.</p>
<p class="calibre2">Java 9 StackWalker API provides several features such as filtering, asserting, and skipping certain classes in the stack trace. We can get either a full stack trace or  short stack trace for a current thread at any point.</p>
<p class="calibre2">StackWalker provides various methods for capturing information about stacks, such as:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">forEach</strong>: For the current thread it returns each StackFrame stream to perform actions</li>
<li class="calibre10"><strong class="calibre1">getInstance()</strong>: This returns the current instance of StackWalker</li>
<li class="calibre10"><strong class="calibre1">walk()</strong>: This is used to open a sequential stream for each StackFrame for the current thread, where we can apply functions such as limit, skip, and filter</li>
</ul>
<pre class="calibre17">List&lt;StackFrame&gt; stack =  StackWalker.getInstance(StackWalker.Option.RETAIN_CLASS_REFERENCE).walk((s) -&gt; s.collect(Collectors.toList()));</pre>
<p class="calibre2">The preceding snippet gives a list of all the StackFrame of the current thread by retaining class references. <span class="calibre11">In the following snippet, we needed only the first 10 frames in the method and the skip frames, which are declared in the <kbd class="calibre12">com.packt.java9dependency </kbd>package:</span></p>
<pre class="calibre17">List&lt;StackFrame&gt; frames = StackWalker.getInstance().walk(s -&gt; s.dropWhile(f -&gt; f.getClassName().startsWith("com.packt.java9dependency")).limit(10).collect(Collectors.toList()));</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Immutable collections with convenient factory methods</h1>
                
            
            <article>
                
<p class="calibre2">Many times we directly add or remove elements from a collection, which is returned from the <kbd class="calibre12">factory</kbd> method. This collection is immutable and adding items into these collection gives us an exception called <kbd class="calibre12">UnSupportedOperationException</kbd>.</p>
<p class="calibre2">To avoid such situations, we create immutable collection objects by using the <kbd class="calibre12">collections.unmodifiableXXX()</kbd> method. These methods are also tedious, such as writing multiple statements for adding individual items and then adding into it <span class="calibre11">immutable</span> <kbd class="calibre12">List</kbd> or <kbd class="calibre12">Set</kbd> or <kbd class="calibre12">Map</kbd>:</p>
<pre class="calibre17">Before Java 9, <br class="title-page-name"/>List&lt;String&gt; asiaRegion = new ArrayList&lt;String&gt;();<br class="title-page-name"/>asiaRegion.add("India");<br class="title-page-name"/>asiaRegion.add("China");<br class="title-page-name"/>asiaRegion.add("SriLanka");<br class="title-page-name"/>List&lt;String&gt; unmodifiableAsiaRegionList = Collections.unmodifiableList(asiaRegion);</pre>
<p class="calibre2"><span class="calibre11">Java 9 provides convenient immutable factory methods such as <kbd class="calibre12">List.of(), Set.of() and Map.of()</kbd> to solve the previously mentioned issue:</span></p>
<pre class="calibre17">After Java 9,<br class="title-page-name"/>List&lt;String&gt; asiaRegion = List.of("India","China","SriLanka");<br class="title-page-name"/>Set&lt;Integer&gt; <span>immutableSet</span> = Set.of(10, 15, 20, 25);</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">HTTP/2.0 support</h1>
                
            
            <article>
                
<p class="calibre2">We used to connect servers using <kbd class="calibre12">HttpURLConnection</kbd>, which works in a single request/response cycle, and this eventually increases web page loading time and latency.</p>
<p class="calibre2">Moreover, the difference between HTTP/1.1 of older JDK and HTTP/2 of JAVA 9 is that data is framed when transporting between clients and servers. HTTP/2 uses the <kbd class="calibre12">HttpClient</kbd> API to push data by using the server push feature, with this it allows us to prioritize and send required data for loading the web page first. The following example shows HTTP interaction for the <kbd class="calibre12">GET</kbd> method:</p>
<pre class="calibre17">//Get the HttpClient object<br class="title-page-name"/>HttpClient client = HttpClient.newHttpClient();<br class="title-page-name"/> <br class="title-page-name"/>// GET Method call<br class="title-page-name"/>HttpResponse&lt;String&gt; getResponse = client.send(<br class="title-page-name"/>    HttpRequest<br class="title-page-name"/>        .newBuilder(new URI("http://www.xyz.com/")<br class="title-page-name"/>        .GET()<br class="title-page-name"/>        .build(),<br class="title-page-name"/>    BodyHandler.asString()<br class="title-page-name"/>);<br class="title-page-name"/>//Response of call<br class="title-page-name"/>int responseStatus = getResponse.statusCode();<br class="title-page-name"/>String body = responseStatus.body(); </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modular Framework in Java 9</h1>
                
            
            <article>
                
<p class="calibre2">In the previous section, we discussed several Java 9 features in brief. Now, in this section, we will learn about the Modular Framework and how it is used in Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is modularity?</h1>
                
            
            <article>
                
<p class="calibre2">Before we move to Java Platform Module System, let's understand the meaning of modularity in the real world.</p>
<p class="calibre2">Modularity is a design that divides systems into smaller parts called a module. Nowadays, modular kitchens are installed in homes. These types of kitchen include several units or modules such as wall <span class="calibre11">cabinets</span>, cupboards, sinks, and <span class="calibre11">many more and all these </span>different parts are built in factories. If at any time there is damage in any unit, then only that module needs to be replaced or repaired.</p>
<p class="calibre2">Another familiar modular system is electric outlets in walls, which allow you to plug in different types of electrical gadgets such as microwaves, mixer grinders, refrigerators, televisions, and they are all designed to work on defined tasks. These devices work in any outlet without caring whether it is in our home or a neighbor's home, they just do their task and function when they are plugged in.</p>
<p class="calibre2">In terms of computer systems, modularity is a concept of combination and linking of multiple independent modules in a single system. It increases usability and removes duplication of code and also makes a system loosely coupled. Similar to the electric outlet concept, modules should do their task without caring where they are plugged into an application.</p>
<div class="mce-root"><img src="../images/00017.jpeg" class="calibre34"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Java Platform Module System</h1>
                
            
            <article>
                
<p class="calibre2"><strong class="calibre4">Java Platform Module System</strong> (<strong class="calibre4">JPMS</strong>) is also known as JSR 376 and is implemented under project Jigsaw. We have to understand why we need module systems in Java and what the changes in current JDK <span class="calibre11">are</span>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The need for a Java modular system</h1>
                
            
            <article>
                
<p class="calibre2">To run a small or big application, a runtime environment up to Java 8 is required because JDK is built to support monolithic design. All libraries are tightly coupled with each other and for deployment full JDK is required.</p>
<p class="calibre2"><strong class="calibre4">Maintainability</strong>: We all want an application to be loosely coupled, highly united, readable, and understandable. So we are using classes and packages. Day by day Java is growing <span class="calibre11">exponentially </span>in terms of size and packages to provide better features, but dependencies between packages is compromised. So we need something new that is better than packages for maintaining our code base.</p>
<p class="calibre2"><strong class="calibre4">JAR Hell</strong>: <span class="calibre11">Before Java 9,  </span>The JVM does not have thought that how JAR on the class path depends on another Jar. It essentially loads a bunch of JARs, but it does not validate their dependencies. The JVM breaks the execution at runtime when a JAR is missing. The JARs don't characterize accessibility constraints such as open or private. The whole substance of all JARs on the class path is totally visible to all the other JARs from the class path. There is no way to declare that a few classes in a JAR are private. All classes and methods are open related to the class path. Sometimes, we have jar files that contain multiple versions of a single class. The Java ClassLoader loads only one version of this class, and it does not determined which one. This creates uncertainty about how our program is  going to work. This issue is known as <strong class="calibre4">JAR Hell</strong>. The Module Path concept presented in Java 9 tends to illuminate issues caused by the class path.</p>
<p class="calibre2"><strong class="calibre4">Implicit Dependency</strong>: We have <span class="calibre11">all </span>seen the <kbd class="calibre12">NoClassDefFoundError</kbd> error a few times. It comes when JVM is not able to discover a class on which code it is executing. Finding depending code and lost dependency is simple, but dependency that is not in classLoader is troublesome to recognize, since there are chances that the same class is stacked by numerous class loaders. The current JAR framework is not able to express which other JAR file is dependent, so that JVM understands and resolves dependency.</p>
<p class="calibre2"><strong class="calibre4">Lack of strong encapsulation</strong>: Java's visibility modifier provides strong encapsulation between classes of the same packages. Current Java encapsulation works with ClassPath where every public class is visible to other classes because several critical JDK API classes are open for other classes.</p>
<p class="calibre2">All preceding issues are fixed with Java 9 module concepts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modular JDK </h1>
                
            
            <article>
                
<p class="calibre2">JDK 9 folder structure has changed compared to Java 8; JDK 9 does not have JRE, it is separately installed into a distinct folder. In JDK 9, we can see a new folder called <span class="calibre11">jmod</span>, which contains all the Java platform modules. Java 9 on wards <kbd class="calibre12">rt.jar</kbd> and <kbd class="calibre12">tool.jar</kbd> is not available in JDK:</p>
<div class="mce-root"><img src="../images/00018.gif" class="calibre35"/></div>
<p class="calibre2">All Java modules, <kbd class="calibre12">src</kbd> are available from the <kbd class="calibre12">..\jdk-9.0.1\lib\src</kbd> folder, and each module includes <kbd class="calibre12">module-info.java</kbd>. The following is a diagram that shows how JDK looks with all modules:</p>
<div class="mce-root"><img src="../images/00019.jpeg" class="calibre36"/></div>
<p class="calibre2">Every other module implicitly or explicitly depends on the <kbd class="calibre12">java.base</kbd> module. It follows a directed acyclic graph dependency, which means no circular dependency is allowed between modules.</p>
<div class="packt_infobox"><span class="calibre18">All modules in JDK 9 are by default dependent on the base module, known as the <kbd class="calibre37">java.base</kbd> module. It includes the <kbd class="calibre37">java.lang</kbd> package.</span></div>
<div class="packt_tip">We can list all modules of Java 9 using the  command <kbd class="calibre37">-- list-modules</kbd>. Each module name is followed by a version number with string <kbd class="calibre37">-@9</kbd>, to indicate that the module belongs to Java 9. A <span class="calibre18">JDK 9 specific module is prefix with keyword <strong class="calibre38"><em class="calibre19">jdk</em></strong> such as                                                            <kbd class="calibre37">jdk.compiler</kbd> and JAVA SE specific modules start with the <strong class="calibre38"><em class="calibre19">java</em></strong> <em class="calibre19">keyword</em>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">What is a module?</h1>
                
            
            <article>
                
<p class="calibre2">When we discuss modular systems, immediately you might ask what is a module? A module is a collection of code, data, and resources with self-descriptive properties. It contains a set of packages and types such as classes, abstract classes, interfaces, and so on, and also, most importantly, every module contains a <kbd class="calibre12">module-info.java</kbd> file.</p>
<p class="calibre2">A module can explicitly declare which package needs to export for other modules and what is required from other modules in order to compile and run. This will also help us to identify which module is missing when we get an error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Structure of a module</h1>
                
            
            <article>
                
<p class="calibre2">Modules are the main building block of JPMS. Modules are similar to JARs, but have additional characteristics, such as: </p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Module Name</strong>: A unique name to identify globally; a name can be defined by using inverse-URL naming convention</li>
<li class="calibre10">Declare dependencies for other modules</li>
<li class="calibre10">Declaration of API that needs to export as packages</li>
</ul>
<div class="mce-root"><img src="../images/00020.jpeg" class="calibre39"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module Descriptor (module-info.java)</h1>
                
            
            <article>
                
<p class="calibre2"><kbd class="calibre12">module-info.java</kbd> is an important file in the modular system, and it contains modular metadata which describes the behavior module. It is a Java file, but it is not like a traditional Java file. It has its own syntax and it's compiled into the <kbd class="calibre12">module-info.class</kbd> file.</p>
<p class="calibre2">The following is the syntax that we have to follow when creating <kbd class="calibre12">module-info.java</kbd>:</p>
<pre class="calibre17">module &lt;module-name&gt; {<br class="title-page-name"/>       requires &lt;module-name-1&gt;;<br class="title-page-name"/>       requires &lt;module-name-2&gt;;<br class="title-page-name"/>               <strong class="calibre1">.</strong><br class="title-page-name"/><strong class="calibre1">               .</strong><br class="title-page-name"/>       requires &lt;module-name-n&gt;;<br class="title-page-name"/>       exports &lt;package-1&gt;;<br class="title-page-name"/>               <strong class="calibre1">.</strong><br class="title-page-name"/><strong class="calibre1">               .<br class="title-page-name"/></strong>       exports &lt;package-n&gt;;<br class="title-page-name"/>}</pre>
<p class="calibre2">The following is an example of the <kbd class="calibre12">module-info.java</kbd> file, where each module contains a unique ID and optional module descriptor details:</p>
<pre class="calibre17">module com.packt.java9dependency.chapter2 {<br class="title-page-name"/> exports com.packt.java9dependency.chapter2.services;<br class="title-page-name"/> requires com.packt.java9dependency.chapter1;<br class="title-page-name"/> requires java.sql;<br class="title-page-name"/>}</pre>
<p class="calibre2">Let's understand different module descriptors, mentioned here:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">requires &lt;module&gt;</strong>: This descriptor specifies that a module depends on another module to run this module, this type of relationship is called a <em class="calibre28">module dependency</em>. At runtime, modules only see modules that are required, and this is called Readability.</li>
<li class="calibre10"><strong class="calibre1">requires transitive &lt;module&gt;</strong>: This means to indicate a dependency on another module and, moreover, to guarantee that other modules perusing your module read that dependency—known as implied readability.  For example, module A reads module B and module B reads module C, then module B needs to declare requires transitive, otherwise module A will not compile unless they read module C explicitly.</li>
<li class="calibre10"><strong class="calibre1">requires static &lt;module&gt;</strong>: By using a static keyword, dependency will be validated at compile time and it will be optional at runtime.</li>
<li class="calibre10"><strong class="calibre1">exports &lt;package-name&gt;</strong>: This descriptor is used to export own packages to other modules.</li>
<li class="calibre10"><strong class="calibre1">exports &lt;package-name&gt; to &lt;module-name&gt;</strong>: By using such descriptor statements, we export packages to specific modules, not to all modules. It's called qualified export.</li>
<li class="calibre10"><strong class="calibre1">opens &lt;package-name&gt;</strong>: Opens descriptor used to define, only public types of packages are accessible to code in other modules at runtime only using reflection.</li>
<li class="calibre10"><span><strong class="calibre1">opens &lt;package-name&gt; to &lt;module-name&gt;</strong></span>: <span>A qualified open. This opens only a specific module that can access public type packages at runtime only through reflection.</span></li>
<li class="calibre10"><strong class="calibre1">uses &lt;service-interface&gt;</strong>: A module directive defined service used for this module. It makes a module as a service consumer. Service implementation can be in the same module or on another module.</li>
<li class="calibre10"><strong class="calibre1">provide &lt;service-interface&gt; with &lt;class1&gt;,&lt;class2&gt;</strong> :  Specifies that a module contains service implementation of an interface defined in a modules's uses descriptor. This makes a module a service provider.</li>
</ul>
<p class="calibre2"><span class="calibre11">The following are important points that we need to understand when creating a module descriptor:</span></p>
<ul class="calibre9">
<li class="calibre10">A module-info can have only a module name; means exports or requires clause are not mandatory.</li>
<li class="calibre10">If a module descriptor has only exports then it means it is only exporting declared packages to other modules and it is not dependent on any other module. We can call them independent modules. For example, the <kbd class="calibre12">java.base</kbd> module.</li>
<li class="calibre10">Opposite to the previous point, module descriptors might contain export and requires clauses, which means the module is exporting packages to other modules and is also dependent on other modules for its own compilation.</li>
<li class="calibre10"> There might be zero or more export or requires clauses in the module descriptor.</li>
</ul>
<div class="packt_infobox">When we create a project, JDK 8 adds a JDK jar into our project ClassPath. But when we create a Java 9 module project, then JDK modules are added into ModulePath.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Module types</h1>
                
            
            <article>
                
<p class="calibre2">There are different types of modules:</p>
<p class="calibre2"><strong class="calibre4">Named application modules</strong>: This is a simple module that we can all create. Any third-party libraries can be application modules.</p>
<p class="calibre2"><strong class="calibre4">Platform modules</strong>: As we have seen, JDK 9 itself migrated to modular architecture. All the existing features will be provided as different modules, such as <kbd class="calibre12">java.sql</kbd>, <kbd class="calibre12">java. desktop</kbd>, <kbd class="calibre12">java.transaction</kbd>. These are called Platform Modules. All modules are implicitly dependent on the <kbd class="calibre12">java.base</kbd> module.</p>
<p class="calibre2"><strong class="calibre4">Automatic modules</strong>:  A pre-Java 9 JAR, which is not migrated to modules, can be placed in a module path without module descriptors. These are called automated modules. This JAR implicitly exports all their packages for other modules and also reads other modules along with unnamed modules. Because there is no unique name for an automatic module, JDK generates depending on the JAR filename by removing the version number and extension. For example, the file <kbd class="calibre12">postgresql-42.1.4.jar</kbd> as a module will be <kbd class="calibre12">postgresql</kbd>.</p>
<p class="calibre2"><strong class="calibre4">Unnamed modules</strong>: JDK 9 does not remove classpaths. So all the JARs and classes placed on the class path are called Unnamed Modules. These modules can read all the modules and export all the packages, as they do not have a name. This module cannot be read or required by named application modules.</p>
<p class="calibre2">In JDK 9, we have two module paths and class paths. Now we might ask which JAR goes where? So, the answer is, a modular jar with an application module goes into <kbd class="calibre12">--module-path</kbd>,  and a modular jar with an unnamed module can be placed into <kbd class="calibre12">--class-path</kbd>. Similarly, a non-modular jar can be migrated into an automatic module and goes into <kbd class="calibre12">--module-path</kbd>. If a jar contains an unnamed module, then it resides in <kbd class="calibre12">--class-path</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dependency Injection using the Java 9 Modular Framework</h1>
                
            
            <article>
                
<p class="calibre2">The last topic we will learn about is molecularity and basics of  Java 9 modules. Now, we will learn how to write modules and how Dependency Injection is handled in modules.</p>
<p class="calibre2">Java 9 has the concept of Service Loader, which is related to IoC and Dependency Injection. New module systems do not provide Dependency Injection, but the same can be achieved by Service Loader and SPI (Service Provider Interface) Pattern. We will now see how this will work with Java 9.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Modules with Service Loader</h1>
                
            
            <article>
                
<p class="calibre2">A service is a bunch of interfaces and classes collectively named a library, which delivers a specific functionality. Simply, we can say API. There are multiple usages for a service and they are called service providers (say implementations) . The client utilizing this service will not have any contact with the implementations. This can be accomplished by utilizing the underneath concept.</p>
<p class="calibre2">Java has <kbd class="calibre12">ClassLoader</kbd>, which simply loads the classes and creates instances of classes on runtime. Compared to Java 9 modules, <kbd class="calibre12">java.util.ServiceLoader</kbd> is capable of finding and loading all the service providers at a runtime for a service interface. The <kbd class="calibre12">ServiceLoader</kbd> class permits decoupling between the API and client app. The service loader will instantiate all the service providers that are implementing the service and makes it accessible to the client to utilize.</p>
<p class="calibre2">Let's take an example of Notification Application containing API and a different implementation of API. We will create three modules, the first one with a service (API) module, the second one will be a provider (Implementation) module, and the last one will be a client module for the accessing service.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service (API) module</h1>
                
            
            <article>
                
<p class="calibre2">The created API module with the name <kbd class="calibre12">com.packt.service.api</kbd>  contains a <kbd class="calibre12">NotificationService</kbd> interface to send notification and load service providers. To make this interface a service provider interface (SPI), we have to mention the <kbd class="calibre12">'use'</kbd> clause in <kbd class="calibre12">module-info.java</kbd>. Our module code will be as follows:</p>
<pre class="calibre17">NotificationService.java<br class="title-page-name"/><br class="title-page-name"/>package com.packt.service.api;<br class="title-page-name"/><br class="title-page-name"/>import java.util.ArrayList;<br class="title-page-name"/>import java.util.List;<br class="title-page-name"/>import java.util.ServiceLoader;<br class="title-page-name"/><br class="title-page-name"/>public interface NotificationService {<br class="title-page-name"/>  <br class="title-page-name"/>  /* Loads all the service providers */<br class="title-page-name"/>  public static List&lt;NotificationService&gt; getInstances() {<br class="title-page-name"/>    ServiceLoader&lt;NotificationService&gt; services = ServiceLoader.load(NotificationService.class);<br class="title-page-name"/>    List&lt;NotificationService&gt; list = new ArrayList&lt;&gt;();<br class="title-page-name"/>    services.iterator().forEachRemaining(list::add);<br class="title-page-name"/>    return list;<br class="title-page-name"/>  }<br class="title-page-name"/>  <br class="title-page-name"/>  /* Send notification with provided message and recipient */<br class="title-page-name"/>  boolean sendNotification(String message, String recipient);<br class="title-page-name"/>  <br class="title-page-name"/>}</pre>
<p class="calibre2"><kbd class="calibre12">module-info.java</kbd> will be as follows:</p>
<pre class="calibre17">module com.packt.service.api {<br class="title-page-name"/>  exports com.packt.service.api;<br class="title-page-name"/>  uses com.packt.service.api.NotificationService;<br class="title-page-name"/>}</pre>
<p class="calibre2">The following  are the command line steps that need to be followed for the <kbd class="calibre12">com.packt.service.api</kbd> module jar. Assume that there will be an out directory in the <kbd class="calibre12">com.packt.service.api</kbd> module:</p>
<div class="mce-root"><img src="../images/00021.jpeg" class="calibre40"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service provider (Implementation) module</h1>
                
            
            <article>
                
<p class="calibre2">Now, create a service provider module <kbd class="calibre12">com.packt.service.impl</kbd> to implement <kbd class="calibre12">N<span>otificationService</span></kbd> service API, and for that we should define a "<em class="calibre13">provides ... with</em>" clause in the <kbd class="calibre12">module-info.java</kbd> file. The <em class="calibre13"><strong class="calibre4">provides</strong></em> keyword is used to mention the service interface name and the <em class="calibre13"><strong class="calibre4">with</strong></em> keyword is used to mention which implementation we want to load. In the event that the module doesn’t have the provides statement in the module descriptor file, the service loader will not load that module. The syntax of the '<em class="calibre13">provides...with'</em> statement is as follows:</p>
<pre class="calibre17">provides &lt;service-interface&gt; with &lt;service-implementation&gt;</pre>
<p class="calibre2">To send an SMS message to a recipient we are creating two implementation classes, <kbd class="calibre12">SMSServiceImpl.java </kbd> and <kbd class="calibre12">EmailServiceImpl</kbd>, by <span class="calibre11">implementing  <kbd class="calibre12">NotificationService</kbd></span>:</p>
<pre class="calibre17">SMSServiceImpl.java<br class="title-page-name"/><br class="title-page-name"/>package com.packt.service.impl;<br class="title-page-name"/><br class="title-page-name"/>import com.packt.service.api.NotificationService;<br class="title-page-name"/><br class="title-page-name"/>public class SMSServiceImpl implements NotificationService {<br class="title-page-name"/><br class="title-page-name"/>  public boolean sendNotification(String message, String recipient) {<br class="title-page-name"/>    // Code to send SMS<br class="title-page-name"/>    System.out.println("SMS has been sent to Recipient :: " + recipient + " with Message :: "+message);<br class="title-page-name"/>    return true;<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">The module descriptor for this provider module will be as follows:</p>
<pre class="calibre17">module-info.java<br class="title-page-name"/><br class="title-page-name"/>module com.packt.service.impl {<br class="title-page-name"/>  requires com.packt.service.api;<br class="title-page-name"/>  provides com.packt.service.api.NotificationService with   com.packt.service.impl.SMSServiceImpl;<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">To generate a jar file of the <kbd class="calibre12">com.packt.service.impl</kbd> module, we have to copy <kbd class="calibre12">notification-api.jar</kbd> of the service API module into the lib folder for compile time dependency resolution. The outcome of the following commands will be <kbd class="calibre12">sms-service.jar</kbd>:</p>
<div class="mce-root"><img src="../images/00022.jpeg" class="calibre41"/></div>
<p class="calibre2">Service Provider Rules:</p>
<ul class="calibre9">
<li class="calibre10">It always has a no-argument constructor. This constructor is used by the <kbd class="calibre12">ServiceLoader</kbd> class to instantiate the service provider using reflection.</li>
<li class="calibre10">The provider must be a public concrete class. It should not be an abstract class or inner class.</li>
<li class="calibre10">An occurrence of the implementation class must be consistent with the service interface.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Service client application</h1>
                
            
            <article>
                
<p class="calibre2">Now, create a client application named <kbd class="calibre12">com.packt.client</kbd>, which lists all implementation of <kbd class="calibre12">NotificationService</kbd> by calling the <kbd class="calibre12">getInstances()</kbd> method. A client application only <em class="calibre13">requires</em> the <kbd class="calibre12">com.packt.service.api</kbd> module as dependency in <kbd class="calibre12">module-info.java</kbd>. But we have to copy <kbd class="calibre12">notification-api.jar</kbd> and <kbd class="calibre12">sms-service.jar</kbd> into the lib folder to resolve compile time dependency of the service API and service provider module. Our <kbd class="calibre12">ClientApplication.java</kbd> and <kbd class="calibre12">module-info.java</kbd> will look as follows:</p>
<pre class="calibre17">ClientApplication.java<br class="title-page-name"/><br class="title-page-name"/>package com.packt.client;<br class="title-page-name"/><br class="title-page-name"/>import java.util.List;<br class="title-page-name"/>import com.packt.service.api.NotificationService;<br class="title-page-name"/><br class="title-page-name"/>public class ClientApplication {<br class="title-page-name"/><br class="title-page-name"/>  public static void main(String[] args) {<br class="title-page-name"/>     List&lt;NotificationService&gt; notificationServices = NotificationService.getInstances();<br class="title-page-name"/>        for (NotificationService services : notificationServices) {<br class="title-page-name"/>          services.sendNotification("Hello", "1234567890");<br class="title-page-name"/>        }<br class="title-page-name"/>  }<br class="title-page-name"/>}</pre>
<p class="calibre2">For our client application, we have to only mention the <em class="calibre13">requires</em> clause for <kbd class="calibre12">com.packt.service.api</kbd> in the <span class="calibre11"><kbd class="calibre12">module-info.java</kbd> file:</span></p>
<pre class="calibre17">module-info.java<br class="title-page-name"/><br class="title-page-name"/>module com.packt.client {<br class="title-page-name"/>  requires com.packt.service.api;<br class="title-page-name"/>}</pre>
<p class="calibre2">The following are commands that need to run in order to run our client application. In the output we will get a message from <kbd class="calibre12">SMSServiceImpl.java</kbd>:</p>
<div class="mce-root"><img src="../images/00023.gif" class="calibre41"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Writing modular code using a command-line interface</h1>
                
            
            <article>
                
<p class="calibre2">As a tradition, let's create a simple module called <kbd class="calibre12">helloApp</kbd>, which will have a simple message and will be required by another module called <kbd class="calibre12">helloClient</kbd>. Here, we will use a command line interface to create and run the module.</p>
<p class="calibre2">Create a <kbd class="calibre12">helloApp</kbd> module folder named <kbd class="calibre12">com.packt.helloapp</kbd> and a package folder named <kbd class="calibre12">com\packt\helloapp</kbd>:</p>
<pre class="calibre17">mkdir <span>com.packt.helloapp<br class="title-page-name"/>mkdir com.packt.helloapp\com\packt\helloapp<br class="title-page-name"/></span></pre>
<p class="calibre2">Now, create a <kbd class="calibre12">HelloApp.java</kbd> component class under the package name <kbd class="calibre12">com.packt.helloapp\com\packt\helloapp</kbd> and a <kbd class="calibre12">modue-info.java</kbd> file at root folder <kbd class="calibre12">com.packt.helloapp</kbd>:</p>
<pre class="calibre17">HelloApp.java<br class="title-page-name"/><br class="title-page-name"/>package com.packt.helloapp;<br class="title-page-name"/><br class="title-page-name"/>public class HelloApp {<br class="title-page-name"/>  public String sayHelloJava() {<br class="title-page-name"/>      return "Hello Java 9 Module System";<br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>module-info.java<br class="title-page-name"/><br class="title-page-name"/>module com.packt.helloapp {<br class="title-page-name"/> // define exports or requires.<br class="title-page-name"/>}</pre>
<p class="calibre2">Now, we will create another module called <kbd class="calibre12">helloClient</kbd>. Create a <kbd class="calibre12">helloClient</kbd> module with the folder name <kbd class="calibre12">com.packt.hello.client</kbd> and a package with the folder name <kbd class="calibre12"><span>com\packt\hello\client</span></kbd>:</p>
<pre class="calibre17">mkdir com.packt.hello.client<br class="title-page-name"/>mkdir com.packt.hello.client\com\packt\hello\client</pre>
<p class="calibre2">Let's create another component class called <kbd class="calibre12">HelloClient.java</kbd> under the <kbd class="calibre12">com.packt.hello.client\com\packt\hello\client</kbd> package and create a <kbd class="calibre12">module-info.java</kbd> file at root folder <span class="calibre11"><kbd class="calibre12">com.packt.hello.client</kbd>:</span></p>
<pre class="calibre17">helloClient.java<strong class="calibre1"><br class="title-page-name"/></strong><br class="title-page-name"/>package com.packt.hello.client;<br class="title-page-name"/><br class="title-page-name"/>public class HelloClient {<br class="title-page-name"/>  public static void main (String arg[]) {<br class="title-page-name"/>     //code <br class="title-page-name"/>  }<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>module-info.java<br class="title-page-name"/>module com.packt.hello.client {<br class="title-page-name"/> //define exports or requires<br class="title-page-name"/>}</pre>
<p class="calibre2">Both modules are independent modules so are not dependent on each other. But if we want to use a method called <kbd class="calibre12">sayHelloJava()</kbd> in the <kbd class="calibre12">HelloClient</kbd> class, then we have to import the module, otherwise it will give a compile time error <kbd class="calibre12">package com.packt.helloapp is not visible</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Defining dependency between modules</h1>
                
            
            <article>
                
<p class="calibre2">To use <kbd class="calibre12">HelloApp</kbd>, we need to export the package <kbd class="calibre12">com.packt.helloapp</kbd> from the <kbd class="calibre12">helloApp</kbd>  module and include the <kbd class="calibre12">helloApp</kbd> module in the <kbd class="calibre12">helloClient</kbd> module:</p>
<pre class="calibre17">module com.packt.helloapp {<br class="title-page-name"/>   exports com.packt.helloapp;<br class="title-page-name"/>}<br class="title-page-name"/><br class="title-page-name"/>module com.packt.hello.client {<br class="title-page-name"/>   requires com.packt.helloapp;<br class="title-page-name"/>}</pre>
<p class="calibre2">From the preceding code, the first module descriptor, the <kbd class="calibre12">exports</kbd> keyword, indicates that packages are available to export to other modules. If a package is explicitly exported, then it is only accessible by other modules. If in a same module some packages are not exported, then it cannot be accessed by other modules.</p>
<p class="calibre2">The second module descriptor uses the <kbd class="calibre12">requires</kbd> keyword to indicate that the module is dependent on the <kbd class="calibre12">com.packt.helloapp</kbd> module,  and this is called Dependency Injection in Java 9 Module.</p>
<p class="calibre2">Finally, the <kbd class="calibre12">HelloClient</kbd> class will be as follows:</p>
<pre class="calibre17"><span>HelloClient.java<br class="title-page-name"/> </span><br class="title-page-name"/>package com.packt.hello.client;<br class="title-page-name"/><br class="title-page-name"/>import com.packt.HelloApp;<br class="title-page-name"/><br class="title-page-name"/>public class HelloClient {<br class="title-page-name"/><br class="title-page-name"/>  public static void main (String arg[]) {<br class="title-page-name"/><br class="title-page-name"/>    HelloApp helloApp = new HelloApp();<br class="title-page-name"/>    System.out.println(helloApp.sayHelloJava());<br class="title-page-name"/>  <br class="title-page-name"/>  }<br class="title-page-name"/><br class="title-page-name"/>}</pre>
<p class="calibre2">After creating two modules, the following will be the final tree structure:</p>
<div class="mce-root"><img src="../images/00024.gif" class="calibre42"/></div>
<p class="calibre2">But wait, we only wrote the code and have not compiled and run it yet. Let's do that in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Compiling and running modules</h1>
                
            
            <article>
                
<p class="calibre2">Let's first compile the <kbd class="calibre12">HelloApp</kbd> module and then the <kbd class="calibre12">HelloClient</kbd> module. Before running the command, make sure that the Java 9 ClassPath is set. To compile module code, the following command needs to run:</p>
<pre class="calibre17">javac -d output com.packt.helloapp\com\packt\helloapp\HelloApp.java com.packt.helloapp\module-info.java</pre>
<p class="calibre2">On successful compilation it will generate <kbd class="calibre12">HelloApp.class</kbd> and <kbd class="calibre12">module-info.class</kbd> into the output directory.</p>
<p class="calibre2">As our <kbd class="calibre12">HelloApp</kbd> module is required by the <kbd class="calibre12">HelloClient</kbd> module, we should generate the <kbd class="calibre12">com.packt.helloapp</kbd> module jar to include it in the <kbd class="calibre12">HelloClient</kbd> module. To create a jar in the <kbd class="calibre12">mlib</kbd> folder, run the following jar command:</p>
<pre class="calibre17"><span>jar </span><span>-</span><span>c </span><span>-</span><span>f mlib\com</span><span>.packt.</span><span>helloapp</span><span>.</span><span>jar </span><span>-</span><span>C output </span><span>.</span></pre>
<p class="calibre2">Now, remove the output directory by running the following command and again make an output directory for the second module:</p>
<pre class="calibre17"><span>rmdir </span><span>/</span><span>s output</span></pre>
<p class="calibre2">In order to compile the <kbd class="calibre12">HelloClient</kbd> module, we need to provide a reference of <span class="calibre11"><kbd class="calibre12">com.packt.hellpapp.jar</kbd></span>  and <kbd class="calibre12">javac</kbd> commands and provide a way to pass <kbd class="calibre12">module-path</kbd> to refer to other modules. Here we pass the <kbd class="calibre12">mlib</kbd> directory as a module path. Without <kbd class="calibre12">module-path</kbd>, compilation of the <kbd class="calibre12">com.packt.hello.client </kbd> module is not possible:</p>
<pre class="calibre17">javac --module-path mlib -d output com.packt.hello.client\module-info.java<br class="title-page-name"/>javac --module-path mlib -d output com.packt.hello.client\com\packt\hello\client\HelloClient.java</pre>
<p class="calibre2">Now, let's run the module with the help of the following command:</p>
<pre class="calibre17">java –-module-path “mlib;output” -m com.packt.hello.client/com.packt.hello.client.HelloClient</pre>
<p class="calibre2">The output will be as follows:</p>
<div class="mce-root"><img src="../images/00025.gif" class="calibre41"/></div>
<p class="calibre2">At the end of the preceding example, we learned how to create a module and define Dependency Injection in Java modules. The following diagram shows how one module is dependent on another:</p>
<div class="mce-root"><img src="../images/00026.jpeg" class="calibre43"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">Here, the journey ends for Dependency Injection in Java 9. Let's summarize what we learned from this chapter. Firstly, we learned key features introduced in Java 9, such as Java Platform Module System, JShell, JLink tool, multi-release of JAR, Enhanced Stream API, Stack-Walking PI, Immutable collection methods, and HTTP 2.0.</p>
<p class="calibre2">Secondly, in Modular Frameworks in Java 9 section,  we learned the meaning of modularity and the need of modular design in Java applications. We also learned how JPMS changes the earlier JDK into Modular JDK in detail.</p>
<p class="calibre2">After that we learned about an important element of modular systems, which is modules. We saw how module structure is defined with the help of different module descriptors and module types.</p>
<p class="calibre2">And lastly, we learned how to write simple modules using commands to understand how Dependency Injection works in Java 9 between modules.</p>
<p class="calibre2">In the next chapter, we will discuss concepts of Dependency Injection in Spring Framework in detail.</p>


            </article>

            
        </section>
    </body></html>