- en: Thread Synchronization Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling concurrent access to one or more copies of a resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for multiple concurrent events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing tasks at a common point
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running concurrent-phased tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling phase change in concurrent-phased tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanging data between concurrent tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Completing and linking tasks asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736), *Basic
    Thread Synchronization*, you learned the concepts of synchronization and critical
    sections. Basically, we talk about synchronization when more than one concurrent
    task shares a resource, for example, an object or an attribute of an object. The
    blocks of code that access this shared resource are called critical sections.
  prefs: []
  type: TYPE_NORMAL
- en: If you don't use appropriate mechanisms, you might have incorrect results, data
    inconsistencies, or error conditions. Therefore, we have to adopt one of the synchronization
    mechanisms provided by the Java language to avoid these problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736), *Basic
    Thread Synchronization*, taught you about the following basic synchronization
    mechanisms:'
  prefs: []
  type: TYPE_NORMAL
- en: The `synchronized` keyword
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Lock interface and its implementation classes: `ReentrantLock`, `ReentrantReadWriteLock.ReadLock`,
    and `ReentrantReadWriteLock.WriteLock`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StampedLock` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to use high-level mechanisms to synchronize
    multiple threads. These high-level mechanisms are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Semaphores**: A semaphore is a counter that controls access to one or more
    shared resources. This mechanism is one of the basic tools of concurrent programming
    and is provided by most programming languages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CountDownLatch**: The `CountDownLatch` class is a mechanism provided by the
    Java language that allows a thread to wait for the finalization of multiple operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CyclicBarrier**: The `CyclicBarrier` class is another mechanism provided
    by the Java language that allows the synchronization of multiple threads at a
    common point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Phaser**: The `Phaser` class is another mechanism provided by the Java language
    that controls the execution of concurrent tasks divided in phases. All the threads
    must finish one phase before they can continue with the next one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exchanger**: The `Exchanger` class is another mechanism provided by the Java
    language that provides a point of data interchange between two threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CompletableFuture**: The `CompletableFuture` class provides a mechanism where
    one or more tasks can wait for the finalization of another task that will be explicitly
    completed in an asynchronous way in future.Â This class was introduced in Java
    8 and has introduced new methods in Java 9.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Semaphores are generic synchronization mechanisms that you can use to protect
    any critical section in any problem. Other mechanisms are thought to be used in
    applications with specific features, as described previously. Be sure to select
    the appropriate mechanism according to the characteristics of your application.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents seven recipes that will show you how to use the mechanisms
    described.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling concurrent access to one or more copies of a resource
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the semaphore mechanism provided by
    the Java language. A semaphore is a counter that protects access to one or more
    shared resources.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a semaphore was introduced by Edsger Dijkstra in 1965 and was
    used for the first time in the THEOS operating system.
  prefs: []
  type: TYPE_NORMAL
- en: When a thread wants to access one of the shared resources, it must first acquire
    the semaphore. If the internal counter of the semaphore is greater than 0, the
    semaphore decrements the counter and allows access to the shared resource. A counter
    bigger than 0 implies that there are free resources that can be used, so the thread
    can access and use one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, if the counter is 0, the semaphore puts the thread to sleep until
    the counter is greater than 0\. A value of 0 in the counter means all the shared
    resources are used by other threads, so the thread that wants to use one of them
    must wait until one is free.
  prefs: []
  type: TYPE_NORMAL
- en: When the thread has finished using the shared resource, it must release the
    semaphore so that another thread can access the resource. This operation increases
    the internal counter of the semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `Semaphore` class to protect more
    than one copy of a resource. You are going to implement an example, which has
    a print queue that could print documents in three different printers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `PrintQueue` that will implement the print queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This class will have three private attributes. A semaphore named `semaphore`,
    an array of Booleans named `freePrinters`, and a lock named `lockPrinters`, as
    shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. It initializes the three attributes
    of the class, as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `printJob()` method that will simulate the printing of a document.
    It receives an object called `document` as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, the `printJob()` method calls the `acquire()` method to acquire
    access to the semaphore. As this method can throw an `InterruptedException` exception,
    you must include the code to process it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get the number of the printers assigned to print this job, using the
    private method `getPrinter()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the lines that simulate the printing of a document waiting
    for a random period of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, release the semaphore by calling the `release()` method and marking
    the printer used as free, and assign `true` to the corresponding index in the
    `freePrinters` array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `getPrinter()` method. It''s a private method that returns
    an `int` value and has no parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'First, declare an `int` variable to store the index of the printer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get access to the `lockPrinters` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Post this, find the first true value in the `freePrinters` array and save its
    index in a variable. Modify this value to `false` because this printer will be
    busy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, free the `lockPrinters` object and return the index of the true value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a class called `Job` and specify that it implements the `Runnable`
    interface. This class implements the job that will send a document to the printer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `PrintQueue` object. Call it `printQueue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. It initializes the `PrintQueue` object
    declared in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First, this method writes a message to the console that shows that the job
    has started its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it calls the `printJob()` method of the `PrintQueue` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the method writes a message to the console that shows that it has
    finished its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the main class of the example by creating a class named `Main`
    and implementing the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `PrintQueue` object named `printQueue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 12 threads. Each one of these threads will execute a `Job` object that
    will send a document to the print queue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, start the 12 threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The key to this example is the `printJob()` method of the `PrintQueue` class.
    This method shows three steps you must follow when you use a semaphore to implement
    a critical section and protect access to a shared resource:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you acquire the semaphore with the `acquire()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you do the necessary operations with the shared resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, release the semaphore with the `release()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another important point in this example is the constructor of the `PrintQueue`
    class and the initialization of the `Semaphore` object. You pass the value `3`
    as the parameter of this constructor, so you are creating a semaphore that will
    protect three resources. The first three threads that call the `acquire()` method
    will get access to the critical section of this example, while the rest will be
    blocked. When a thread finishes a critical section and releases the semaphore,
    another thread will acquire it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00020.gif)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the first three print jobs start at the same time. Then, when
    one printer finishes its job, another one begins.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Semaphore` class has three additional versions of the `acquire()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`acquireUninterruptibly()`: The `acquire()` method, when the internal counter
    of the semaphore is `0`, blocks the thread until the semaphore is released. During
    this period, the thread may be interrupted; if this happens, the method will throw
    an `InterruptedException` exception. This version of the `acquire` operation ignores
    the interruption of the thread and doesn''t throw any exceptions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryAcquire()`: This method tries to acquire the semaphore. If it can, it returns
    the `true` value. But if it can''t, it returns `false` instead of being blocked
    and waits for the release of the semaphore. It''s your responsibility to take
    correct action based on the return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tryAcquire(long timeout, TimeUnit unit)`: This method is equivalent to the
    previous one, but it waits for the semaphore for the period of time specified
    in the parameters. If the period of time ends and the method hasn''t acquired
    the semaphore, it will return `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `acquire()`, `acquireUninterruptibly()`, `tryAcquire()`, and `release()`
    methods have an additional version, which has an `int` parameter. This parameter
    represents the number of permits the thread that uses them wants to acquire or
    release, in other words, the number of units that this thread wants to delete
    or add to the internal counter of the semaphore.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of the `acquire()`, `acquireUninterruptibly()`, and `tryAcquire()`
    methods, if the value of the counter is less than the number passed as parameterÂ value,
    the thread will be blocked until the counter gets the same value or a greater
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Fairness in semaphores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of fairness is used by the Java language in all classes that can
    have various threads blocked and are waiting for the release of a synchronization
    resource (for example, a semaphore). The default mode is called **non-fair mode**.
    In this mode, when the synchronization resource is released, one of the waiting
    threads is selected and is given this resource; however, it's selected without
    any criteria. Fair mode, on the other hand, changes this behavior and selects
    the thread that has been waiting for the longest period of time.
  prefs: []
  type: TYPE_NORMAL
- en: As it occurs with other classes, the `Semaphore` class admits a second parameter
    in its constructor. This parameter must take a Boolean value. If you give it a
    false value, you are creating a semaphore that will work in non-fair mode. You
    will get the same behavior if you don't use this parameter. If you give it a true
    value, you are creating a semaphore that will work in fair mode.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Monitoring a Lock interface* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Synchronizing a block of code with a lock*Â recipe in [Chapter 2](part0081.html#2D7TI0-69b77957c9a14e36a0bec5f5a1363736),
    *Basic Thread Synchronization*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for multiple concurrent events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a class that allows one or more threads to
    wait until a set of operations are made. It's called the `CountDownLatch` class.
    This class is initialized with an integer number, which is the number of operations
    the threads are going to wait for. When a thread wants to wait for the execution
    of these operations, it uses the `await()` method. This method puts the thread
    to sleep until the operations are completed. When one of these operations finishes,
    it uses the `countDown()` method to decrement the internal counter of the `CountDownLatch`
    class. When the counter arrives at `0`, the class wakes up all the threads that
    were sleeping in the `await()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `CountDownLatch` class to implement
    a video conference system. The video conference system should wait for the arrival
    of all the participants before it begins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `Videoconference` and specify that it implements the `Runnable`
    interface. This class will implement the video conference system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `CountDownLatch` object named controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the `CountDownLatch`
    attribute. The `Videoconference` class will wait for the arrival of the number
    of participants received as a parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `arrive()` method. This method will be called each time a participant
    arrives for the video conference. It receives a `String` type named `name` as
    the parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'First, it writes a message with the parameter it has received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, it calls the `countDown()` method of the `CountDownLatch` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it writes another message with the number of participants whose arrival
    is pending, using the `getCount()` method of the `CountDownLatch` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the main method of the video conference system. It''s the `run()`
    method that every `Runnable` object must have:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'First, use the `getCount()` method to write a message with the number of participants
    in the video conference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `await()` method to wait for all the participants. As this method
    can throw an `InterruptedException` exception, you must include the code to process
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, write a message to indicate that all the participants have arrived:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `Participant` class and specify that it implements the `Runnable`
    interface. This class represents each participant in the video conference:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Videoconference` attribute named `conference`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute named `name`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes both the preceding
    attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method of the participants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'First, put the thread to sleep for a random period of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the `arrive()` method of the `Videoconference` object to indicate
    the arrival of this participant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the main class of the example by creating a class named
    `Main` and adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a `Videoconference` object named `conference` that waits for 10
    participants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Create `Thread` to run this `Videoconference` object and start it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Create 10 `Participant` objects, a `Thread` object to run each of them, and
    start all the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CountDownLatch` class has three basic elements:'
  prefs: []
  type: TYPE_NORMAL
- en: The initialization value that determines how many events the `CountDownLatch`
    object waits for
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `await()` method, called by the threads that wait for the finalization of
    all the events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `countDown()` method, called by the events when they finish their execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you create a `CountDownLatch` object, it uses the constructor's parameter
    to initialize an internal counter. Every time a thread calls the `countDown()`
    method, the `CountDownLatch` object decrements the internal counter in one unit.
    When the internal counter reaches 0, the `CountDownLatch` object wakes up all
    the threads that were waiting in the `await()` method.
  prefs: []
  type: TYPE_NORMAL
- en: There's no way to re-initialize the internal counter of the `CountDownLatch`
    object or modify its value. Once the counter is initialized, the only method you
    can use to modify its value is the `countDown()` method explained earlier. When
    the counter reaches `0`, all the calls to the `await()` method are returned immediately
    and all subsequent calls to the `countDown()` method have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some differences with respect to other synchronization methods,
    which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `CountDownLatch` mechanism is not used to protect a shared resource or a
    critical section. It is used to synchronize one or more threads with the execution
    of various tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It only admits one use. As explained earlier, once the counter of `CountDownLatch`
    arrives at `0`, all the calls to its methods have no effect. You have to create
    a new object if you want to do the same synchronization again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how participants arrive, and once the internal counter arrives at
    `0`, the `CountDownLatch` object wakes up the `Videoconference` object that writes
    the messages indicating that the video conference should start.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CountDownLatch` class has another version of the `await()` method, which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`await(long time, TimeUnit unit)`: In this method, the thread will continue
    to sleep until it''s interrupted, that is, either the internal counter of `CountDownLatch`
    arrives at `0` or the specified time passes. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing tasks in a common point
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a synchronizing utility that allows the synchronization
    of two or more threads at a determined point. It's the `CyclicBarrier` class.
    This class is similar to the `CountDownLatch` class explained in the *Waiting
    for multiple concurrent events* recipe in this chapter, but it presents some differences
    that make it a more powerful class.
  prefs: []
  type: TYPE_NORMAL
- en: The `CyclicBarrier` class is initialized with an integer number, which is the
    number of threads that will be synchronized at a determined point. When one of
    these threads arrives at the determined point, it calls the `await()` method to
    wait for the other threads. When the thread calls this method, the `CyclicBarrier`
    class blocks the thread that is sleeping until the other threads arrive. When
    the last thread calls the `await()` method of the `CyclicBarrier` object, it wakes
    up all the threads that were waiting and continues with its job.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting advantage of the `CyclicBarrier` class is that you can pass
    an additional `Runnable` object as an initialization parameter, and the `CyclicBarrier`
    class executes this object as a thread when all the threads arrive at the common
    point. This characteristic makes this class adequate for parallelization of tasks
    using the divide and conquer programming technique.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `CyclicBarrier` class to synchronize
    a set of threads at a determined point. You will also use a `Runnable` object
    that will be executed after all the threads arrive at this point. In the example,
    you will look for a number in a matrix of numbers. The matrix will be divided
    into subsets (using the divide and conquer technique), so each thread will look
    for the number in one subset. Once all the threads have finished their respective
    jobs, a final task will unify their results.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start the example by implementing two auxiliary classes. First, create a class
    named `MatrixMock`. This class will generate a random matrix of numbers between
    one and 10, where the threads will look for a number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` matrix named `data`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. This constructor will receive the number
    of rows of the matrix, the length of each row, and the number we are going to
    look for as parameters. All the three parameters are of the type `int`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize the variables and objects used in the constructor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Fill the matrix with random numbers. Each time you generate a number, compare
    it with the number you are going to look for. If they are equal, increment the
    counter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, print a message in the console, which shows the number of occurrences
    of the number you are going to look for in the generated matrix. This message
    will be used to check that the threads get the correct result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getRow()` method. This method receives an `int` parameter with
    the number of a rows in the matrix; it returns the row if it exists and returns
    `null` if it doesn''t:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement a class named `Results`. This class will store, in an array,
    the number of occurrences of the searched number in each row of the matrix:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` array named `data`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class. This constructor receives an integer
    parameter with the number of elements of the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `setData()` method. This method receives a position in the array
    and a value as a parameter, and it establishes the value of that position in the
    array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `getData()` method. This method returns the array with the array
    of the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have the auxiliary classes, it''s time to implement threads. First,
    implement the `Searcher` class. This class will look for a number in the determined
    rows of the matrix of random numbers. Create a class named `Searcher` and specify
    that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare two private `int` attributes, namely `firstRow` and `lastRow`. These
    two attributes will determine the subset of rows where this object will look for
    the number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `MatrixMock` attribute named `mock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Results` attribute named `results`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `int` attribute named `number`, which will store the number
    we are going to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `CyclicBarrier` object named `barrier`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes all the attributes
    declared previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method that will search for the number. It uses an internal
    variable called `counter` that will store the number of occurrences of the number
    in each row:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Print a message in the console with the rows assigned to this task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Process all the rows assigned to this thread. For each row, count the number
    of occurrences of the number you are searching for and store this number in the
    corresponding position of the `Results` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Print a message in the console to indicate that this object has finished searching:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Call the `await()` method of the `CyclicBarrier` object and add the necessary
    code to process the `InterruptedException` and `BrokenBarrierException` exceptions
    that this method can throw:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the class that calculates the total number of occurrences of
    the number in the matrix. This classÂ uses the `Results` object that stores the
    number of appearances of the number in each row of the matrix to make the calculation.
    Create a class named `Grouper` and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `Results` attribute named `results`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the `Results` attribute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method that will calculate the total number of occurrences
    of the number in the array of results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an `int` variable and write a message to the console to indicate the
    start of the process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the number of occurrences of the number in each row using the `getData()`
    method of the `results` object. Then, process all the elements of the array and
    add their value to the `finalResult` variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the result in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the main class of the example by creating a class named
    `Main` and adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare and initialize five constants to store the parameters of the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MatrixMock` object named `mock`. It will have 10,000 rows of 1,000
    elements. Now, you are going to search for the number five:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Results` object named `results`. It will have 10,000 elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Grouper` object named `grouper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `CyclicBarrier` object called `barrier`. This object will wait for
    five threads. When these five threads finish, it will execute the `Grouper` object
    created previously:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Create five `Searcher` objects, five threads to execute them, and start the
    five threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following screenshot shows the result of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00022.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The problem resolved in the example is simple. We have a big matrix of random
    integers, and you want to know the total number of occurrences of a number in
    this matrix. To get better performance, we used the divide and conquer technique.
    We divided the matrix into five subsets and used a thread to look for the number
    in each subset. These threads are objects of the `Searcher` class.
  prefs: []
  type: TYPE_NORMAL
- en: We used a `CyclicBarrier` object to synchronize the completion of the five threads
    and execute the `Grouper` task to process partial results and calculate the final
    one.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the `CyclicBarrier` class has an internal counter to control
    how many threads need to arrive at the synchronization point. Each time a thread
    arrives at the synchronization point, it calls the `await()` method to notify
    the `CyclicBarrier` object that a thread has arrived at its synchronization point.
    `CyclicBarrier` puts the thread to sleep until all the threads reach the synchronization
    point.
  prefs: []
  type: TYPE_NORMAL
- en: When all the threads have arrived, the `CyclicBarrier` object wakes up all the
    threads that were waiting in the `await()` method. Optionally, it creates a new
    thread that executes a `Runnable` object passed as the parameter in the construction
    of `CyclicBarrier` (in our case, a `Grouper` object) to do additional tasks.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `CyclicBarrier` class has another version of the `await()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '`await(long time, TimeUnit unit)`: In this method, the thread will continue
    to sleep until it''s interrupted, that is, either the internal counter of `CyclicBarrier`
    arrives at `0` or the specified time passes. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This class also provides the `getNumberWaiting()` method that returns the number
    of threads that are blocked in the `await()` method and the `getParties()` method
    that returns the number of tasks that are going to be synchronized with `CyclicBarrier`.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting a CyclicBarrier object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CyclicBarrier` class has some points in common with the `CountDownLatch`
    class, but they also have some differences. One of the most important differences
    is that a `CyclicBarrier` object can be reset to its initial state, assigning
    to its internal counter the value with which it was initialized.
  prefs: []
  type: TYPE_NORMAL
- en: This reset operation can be done using the `reset()` method of the `CyclicBarrier`
    class. When this occurs, all the threads that were waiting in the `await()` method
    receive a `BrokenBarrierException` exception. This exception was processed in
    the example presented in this recipe by printing the stack trace; however, in
    a more complex application, it could perform some other operation, such as restarting
    the execution or recovering the operation at the point it was interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Broken CyclicBarrier objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `CyclicBarrier` object can be in a special state denoted by the broken state.
    When there are various threads waiting in the `await()` method and one of them
    is interrupted, the one that is interrupted receives an `InterruptedException`
    exception, but other threads receive a `BrokenBarrierException` exception; `CyclicBarrier`
    is placed in the broken state.
  prefs: []
  type: TYPE_NORMAL
- en: The `CyclicBarrier` class provides the `isBroken()` method. It returns `true`
    if the object is in the broken state; otherwise, it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Waiting for multiple concurrent events* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running concurrent-phased tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most complex and powerful functionalities offered by the Java concurrency
    API is the ability to execute concurrent-phased tasks using the `Phaser` class.
    This mechanism is useful when we have some concurrent tasks divided into steps.
    The `Phaser` class provides us with a mechanism to synchronize threads at the
    end of each step, so no thread will start with the second step until all the threads
    have finished the first one.
  prefs: []
  type: TYPE_NORMAL
- en: As with other synchronization utilities, we have to initialize the `Phaser`
    class with the number of tasks that participate in the synchronization operation,
    but we can dynamically modify this number by either increasing or decreasing it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to use the `Phaser` class to synchronize
    three concurrent tasks. The three tasks look for files with the extension `.log`
    modified in the last 24 hours in three different folders and their subfolders.
    This task is divided into three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get a list of the files with the extension `.log` in the assigned folder and
    its subfolders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the list created in the first step by deleting the files modified more
    than 24 hours ago.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Print the results in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of step 1 and step 2, we check whether the list has any elements
    or not. If it doesn't, the thread ends its execution and is eliminated from the
    `Phaser` class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `FileSearch` and specify that it implements the `Runnable`
    interface. This class implements the operation of searching for files with a determined
    extension modified in the last 24 hours in a folder and its subfolders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `String` attribute to store the folder in which the search
    operation will begin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare another private `String` attribute to store the extension of the files
    we are going to look for:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `List` attribute to store the full path of the files we will
    find with the desired characteristics:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, declare a private `Phaser` attribute to control the synchronization
    of the different phases of the task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the constructor of the class that will initialize the attributes
    of the class. It receives the full path of the initial folder as parameters, the
    extension of the files, and `phaser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement some auxiliary methods that will be used by the `run()` method.
    The first one is the `directoryProcess()` method. It receives a `File` object
    as a parameter and it processes all its files and subfolders. For each folder,
    the method will make a recursive call while passing the folder as a parameter.
    For each file, the method will call the `fileProcess()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `fileProcess()` method. It receives a `File` object as
    a parameter and checks whether its extension is equal to the one we are looking
    for. If they are equal, this method adds the absolute path of the file to the
    list of results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Now implement the `filterResults()` method. It doesn''t receive any parameter
    and filters the list of files obtained in the first phase; it deletes files that
    were modified more than 24 hours ago. First, create a new empty list and get the
    actual date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, go through all the elements of the results list. For each path in the
    list of results, create a `File` object for the file and get its last modified
    date:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, compare this date with the actual date, and if the difference is less
    than 1 day, add the full path of the file to the new list of results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, change the old results list to the new ones:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, implement the `checkResults()` method. This method will be called at
    the end of the first and second phase, and it will check whether the results list
    is empty or not. This method doesn''t have any parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'First, check the size of the results list. If it''s 0, the object writes a
    message to the console indicating this. After this, it calls the `arriveAndDeregister()`
    method of the `Phaser` object to notify that this thread has finished the actual
    phase and it leaves the phased operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'If the results list has elements, the object writes a message to the console
    indicating this. Then, it calls the `arriveAndAwaitAdvance()` method of the `Phaser`
    object to notify that this thread has finished the actual phase and it wants to
    be blocked until all the participant threads in the phased operation finish the
    actual phase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The last auxiliary method is the `showInfo()` method that prints the elements
    of the results list to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s time to implement the `run()` method that executes the operation using
    the auxiliary methods described earlier. We''ll also implement the `Phaser` object
    to control the change between phases. First, call the `arriveAndAwaitAdvance()`
    method of the `Phaser` object. The search won''t begin until all the threads have
    been created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write a message to the console indicating the start of the search task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Check that the `initPath` attribute stores the name of a folder and use the
    `directoryProcess()` method to find the files with the specified extension in
    that folder and all its subfolders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether there are any results using the `checkResults()` method. If there
    are no results, finish the execution of the thread with the `return` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Filter the list of results using the `filterResults()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Check whether there are any results using the `checkResults()` method once
    again. If there are no results, finish the execution of the thread with the `return`
    keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Print the final list of results to the console with the `showInfo()` method,
    deregister the thread, and print a message indicating the finalization of the
    thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the main class of the example by creating a class named `Main`
    and adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `Phaser` object with three participants:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Create three `FileSearch` objects with a different initial folder for each
    one. Look for the files with the `.log` extension:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and start a thread to execute the first `FileSearch` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and start a thread to execute the second `FileSearch` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Create and start a thread to execute the third `FileSearch` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the three threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the value of the finalized flag of the `Phaser` object using the `isFinalized()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The program starts creating a `Phaser` object that will control the synchronization
    of the threads at the end of each phase. The constructor of `Phaser` receives
    the number of participants as a parameter. In our case, `Phaser` has three participants.
    This number indicates `Phaser` the number of threads that need to execute the
    `arriveAndAwaitAdvance()` method before `Phaser` could change the phase and wake
    up the threads that have been sleeping.
  prefs: []
  type: TYPE_NORMAL
- en: Once `Phaser` has been created, we launch three threads that are executed using
    three different `FileSearch` objects.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we use paths of the Windows operating system. If you work with
    another operating system, modify the paths to adapt them to existing paths in
    your environment, such as `/var/log`, or similar.
  prefs: []
  type: TYPE_NORMAL
- en: The first instruction in the `run()` method of this `FileSearch` object is a
    call to the `arriveAndAwaitAdvance()` method of the `Phaser` object. As mentioned
    earlier, `Phaser` knows the number of threads that we want to synchronize. When
    a thread calls this method, `Phaser` decreases the number of threads that have
    to finalize the actual phase and puts this thread to sleep until all the remaining
    threads finish this phase. Calling this method at the beginning of the `run()`
    method ensures that none of the `FileSearch` threads begin their job until all
    the threads are created.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of phase one and phase two, we check whether the phase has generated
    results and the list with the results has elements or the phase hasn't generated
    results and the list is empty. In the first case, the `checkResults()` method
    calls `arriveAndAwaitAdvance()` as explained earlier. In the second case, if the
    list is empty, there's no point in the thread continuing with its execution, so
    it ends its execution. But you have to notify the `Phaser` object that there will
    be one less participant. For this, we used `arriveAndDeregister()`. This notifies
    `phaser` that the thread has finished the actual phase, but it won't participate
    in future phases, therefore, `phaser` won't have to wait for it to continue.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the phase three implemented in the `showInfo()` method, there
    is a call to the `arriveAndAwaitAdvance()` method of `phaser`. With this call,
    we guarantee that all the threads finish at the same time. When this method ends
    its execution, there is a call to the `arriveAndDeregister()` method of `phaser`.
    With this call, we deregister the threads of `phaser`, as explained before, so
    when all the threads finish, `phaser` will have zero participants.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `main()` method waits for the completion of the three threads and
    calls the `isTerminated()` method of `phaser`. When `phaser` has zero participants,
    it enters the so-called termination state, and this method returns `true`. As
    we deregister all the threads of `phaser`, it will be in the termination state,
    and this call will print `true` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Phaser` object can be in two states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Active**: `Phaser` enters this state when it accepts the registration of
    new participants and its synchronization at the end of each phase. In this state,
    `Phaser` works as it has been explained in this recipe. This state is not mentioned
    in the Java concurrency API.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Termination**: By default, `Phaser` enters this state when all the participants
    in `Phaser` have been deregistered, which means it has zero participants. Further,
    `Phaser` is in the termination state when the method `onAdvance()` returns `true`.
    If you override this method, you can change the default behavior. When `Phaser`
    is in this state, the synchronization method `arriveAndAwaitAdvance()` returns
    immediately without doing any synchronization operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A notable feature of the `Phaser` class is that you haven't had to control any
    exception from the methods related to `phaser`. Unlike other synchronization utilities,
    threads that are sleeping in `phaser` don't respond to interruption events and
    don't throw an `InterruptedException` exception. There is only one exception,
    which is explained in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of one execution of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It shows the first two phases of the execution. You can see how the `Apps` thread
    finishes its execution in phase two because its results list is empty. When you
    execute the example, you will see how some threads finish a phase before the rest
    and how they wait until all have finished one phase before continuing with the
    rest.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Phaser` class provides other methods related to the change of phase. These
    methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arrive()`: This method notifies the `Phaser` class that one participant has
    finished the actual phase but it should not wait for the rest of the participants
    to continue with their execution. Be careful with the utilization of this method
    because it doesn''t synchronize with other threads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitAdvance(int phase)`: This method puts the current thread to sleep until
    all the participants of the `phaser` parameter have finished the current phase,
    that is, if the number we pass as the parameter is equal to the actual phase of
    `phaser`. If the parameter and the actual phase of `phaser` aren''t equal, the
    method Â ends its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awaitAdvanceInterruptibly(int phaser)`: This method is equal to the method
    explained earlier, but it throws an `InterruptedException` exception if the thread
    that is sleeping in this method is interrupted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registering participants in Phaser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create a `Phaser` object, you indicate how many participants will
    have that `phaser`. But the `Phaser` class has two methods to increment the number
    of participants of `phaser`. These methods are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`register()`: This method adds a new participant to `Phaser`. This new participant
    will be considered unarrived to the actual phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bulkRegister(int Parties)`: This method adds the specified number of participants
    to `phaser`. These new participants will be considered unarrived to the actual
    phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only method provided by the `Phaser` class to decrement the number of participants
    is the `arriveAndDeregister()` method that notifies `phaser` that the thread has
    finished the actual phase and it doesn't want to continue with the phased operation.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing the termination of Phaser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When `phaser` has zero participants, it enters a state denoted by termination.
    The `Phaser` class provides `forceTermination()` to change the status of `phaser`
    and makes it enter the termination state independently of the number of participants
    registered in `phaser`. This mechanism may be useful when one of the participants
    has an error situation, where the best thing to do would be to terminate `phaser`.
  prefs: []
  type: TYPE_NORMAL
- en: When `phaser` is in the termination state, the `awaitAdvance()` and `arriveAndAwaitAdvance()`
    methods immediately return a negative number, instead of a positive one that is
    returned normally. If you know that your `phaser` could be terminated, you should
    verify the return value of those methods (`awaitAdvance()` and `arriveAndAwaitAdvance()`)
    to know whether `phaser` has been terminated.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Monitoring a Phaser class* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling phase change in concurrent-phased tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Phaser` class provides a method that is executed each time `phaser` changes
    the phase. It''s the `onAdvance()` method. It receives two parameters: the number
    of the current phases and the number of registered participants. It returns a
    Boolean value `false` if `Phaser` continues its execution or the value `true`
    if `Phaser` has finished and has to enter the termination state.'
  prefs: []
  type: TYPE_NORMAL
- en: The default implementation of this method returns `true` if the number of registered
    participants is zero, and `false` otherwise. But you can modify this behavior
    if you extend the `Phaser` class and override this method. Normally, you will
    be interested in doing this when you have to execute some actions when you advance
    from one phase to the next.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to control phase change in a phaser that
    is implementing your own version of the `Phaser` class that overrides the `onAdvance()`
    method to execute some actions in every phase change. You are going to implement
    a simulation of an exam, where there will be some students who have to do three
    exercises. All the students have to finish one exercise before they proceed with
    the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a class named `MyPhaser` and specify that it extends from the `Phaser`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Override the `onAdvance()` method. According to the value of the `phase` attribute,
    we call it a different auxiliary method. If the `phase` attribute is equal to
    zero, you have to call the `studentsArrived()` method. If the `phase` is equal
    to one, you have to call the `finishFirstExercise()` method. If the phase is equal
    to two, you have to call the `finishSecondExercise()` method. Finally, if the
    phase is equal to three, you have to call the `finishExam()` method. Otherwise,
    return the true value to indicate that `phaser` has terminated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `studentsArrived()`. It writes two log messages
    to the console and returns false to indicate that `phaser` is continuing with
    its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `finishFirstExercise()`. It writes two messages
    to the console and returns false to indicate that `phaser` is continuing with
    its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `finishSecondExercise()`. It writes two messages
    to the console and returns false to indicate that `phaser` is continuing with
    its execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `finishExam()`. It writes two messages to the
    console and returns true to indicate that `phaser` has finished its work:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `Student` and specify that it implements the `Runnable`
    interface. This class will simulate the students of an exam:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `Phaser` object named `phaser`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that initializes the `Phaser` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method that will simulate the realization of the exam:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'First, the method writes a message in the console to indicate that a student
    has arrived at the exam hall and calls the `arriveAndAwaitAdvance()` method of
    `phaser` to wait for the rest of the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, write a message to the console and call the private `doExercise1()` method
    that simulates the realization of the first exercise of the exam. Post this, write
    another message to the console and the `arriveAndAwaitAdvance()` method of `phaser`
    to wait for the rest of the students to finish the first exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the same code for the second and third exercises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `doExercise1()`. This method putsÂ the current
    thread or the thread that executes the method toÂ sleep for a random period of
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `doExercise2()`. This method puts the current
    thread or the thread that executes the method to sleep for a random period of
    time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the auxiliary method `doExercise3()`. This method puts the thread
    to sleep for a random period of time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the main class of the example by creating a class named `Main` and
    adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `MyPhaser` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Create five `Student` objects and register them in the `phaser` attribute using
    the `register()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Create five threads to run students and start them:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait for the finalization of the five threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Write a message to show that `phaser` is in the termination state, using the
    `isTerminated()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This exercise simulates the realization of an exam that has three exercises.
    All the students have to finish one exercise before they can start the next one.
    To implement this synchronization requirement, we use the `Phaser` class; however,
    in this case, you implemented your own `phaser`, extending the original class
    to override the `onAdvance()` method.
  prefs: []
  type: TYPE_NORMAL
- en: This method is called by `Phaser` before making a phase change and waking up
    all the threads that were sleeping in the `arriveAndAwaitAdvance()` method. The
    method is invoked by the last thread that finishes a phase as part of the code
    of the `arriveAndAwaitAdvance()` method. This method receives the number of the
    actual phase as parameters, where 0 is the number of the first phase and the number
    of registered participants. The most useful parameter is the actual phase. If
    you execute a different operation depending on the actual phase, you have to use
    an alternative structure (`if...else` or `switch`) to select the operation you
    want to execute. In the example, we used a `switch` structure to select a different
    method for each change of phase.
  prefs: []
  type: TYPE_NORMAL
- en: The `onAdvance()` method returns a Boolean value that indicates whether `phaser`
    has terminated or not. If `phaser` returns false, it indicates that it hasn't
    terminated; if this happens, the threads will continue with the execution of other
    phases. If `phaser` returns `true`, then `phaser` still wakes up the pending threads
    but moves `phaser` to the terminated state. With this, all future calls to any
    method of `phaser` will return immediately, and the `isTerminated()` method will
    return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Main` class, when you created the `MyPhaser` object, you didn't specify
    the number of participants in the phaser. You made a call to the `register()`
    method for every `Student` object created to register a participant in `phaser`.
    This calling doesn't establish a relation between the `Student` object or the
    thread that executes it and `phaser`. Really, the number of participants in a
    phaser is only a number. There is no relationship between `phaser` and the participants.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the results of an execution of this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00024.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see how the students finished the first exercise at different times.
    When all of them finish the first exercise, `phaser` calls the `onAdvance()` method
    that writes the log messages in the console, then all the students start the second
    exercise at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Running concurrent-phased tasks* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Monitoring a Phaser class* recipe in [Chapter 9](part0432.html#CRVJ00-69b77957c9a14e36a0bec5f5a1363736),
    *Testing Concurrent Applications*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exchanging data between concurrent tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java concurrency API provides a synchronization utility that allows interchange
    of data between two concurrent tasks. In more detail, the `Exchanger` class allows
    you to have a definition of a synchronization point between two threads. When
    the two threads arrive at this point, they interchange a data structure such that
    the data structure of the first thread goes to the second one and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: This class may be very useful in a situation similar to the producer-consumer
    problem. This is a classic concurrent problem where you have a common buffer of
    data, one or more producers of data, and one or more consumers of data. As the
    `Exchanger` class synchronizes only two threads, you can use it if you have a
    producer-consumer problem with one producer and one consumer.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the `Exchanger` class to solve the
    producer-consumer problem with one producer and one consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, begin by implementing the producer. Create a class named `Producer`
    and specify that it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `List<String>` field named `buffer`. This will be the data structure
    that the producer will interchange with the consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an `Exchanger<List<String>>` field named `exchanger`. This will be
    the exchanger object that will be used to synchronize the producer and consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that will initialize the two attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Inside it, implement 10 cycles of interchange:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'In each cycle, add 10 strings to the buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Call the `exchange()` method to interchange data with the consumer. As this
    method can throw an `InterruptedException` exception, you have to add some code
    to process it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the consumer. Create a class named `Consumer` and specify that
    it implements the `Runnable` interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a `List<String>` field named `buffer`. This will be the data structure
    that the producer will interchange with the consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare an `Exchanger<List<String>>` field named `exchanger`. This will be
    the `exchanger` object that will be used to synchronize the producer and consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the constructor of the class that will initialize the two attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `run()` method. Inside it, implement 10 cycles of interchange:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'In each cycle, begin with a call to the `exchange()` method to synchronize
    with the producer. The consumer needs data to consume. As this method can throw
    an `InterruptedException` exception, you have to add some code to process it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Write the 10 strings the producer sent in its buffer to the console and delete
    them from the buffer to leave it empty:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement the `main` class of the example by creating a class named `Main`
    and adding the `main()` method to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two buffers that will be used by the producer and consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Exchanger` object that will be used to synchronize the producer
    and consumer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `Producer` and `Consumer` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the threads to execute the producer and consumer and start the threads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The consumer begins with an empty buffer and calls `Exchanger` to synchronize
    with the producer. It needs data to consume. The producer begins its execution
    with an empty buffer. It creates 10 strings, stores them in the buffer, and uses
    the `Exchanger` to synchronize with the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, both the threads (producer and consumer) are in `Exchanger`,
    which changes the data structures. So when the consumer returns from the `exchange()`
    method, it will have a buffer with 10 strings. When the producer returns from
    the `exchange()` method, it will have an empty buffer to fill again. This operation
    will be repeated 10 times.
  prefs: []
  type: TYPE_NORMAL
- en: If you execute the example, you will see how producer and consumer do their
    jobs concurrently and how the two objects interchange their buffers in every step.
    As it occurs with other synchronization utilities, the first thread that calls
    the `exchange()` method is put to sleep until the other threads arrive.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Exchanger` class has another version of the `exchange` method: `exchange(V
    data, long time, TimeUnit unit)`. where, `V` is the type used as a parameter in
    the declaration of `Phaser` (`List<String>` in our case). The thread will sleep
    until it''s interrupted, another thread arrives, or the specified time passes.
    In this case, a `TimeoutException` is thrown. The `TimeUnit` class is an enumeration
    with the following constants: `DAYS`, `HOURS`, `MICROSECONDS`, `MILLISECONDS`,
    `MINUTES`, `NANOSECONDS`, and `SECONDS`.'
  prefs: []
  type: TYPE_NORMAL
- en: Completing and linking tasks asynchronously
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java 8 Concurrency API includes a new synchronization mechanism with the `CompletableFuture`
    class. This class implements the `Future` object and the `CompletionStage` interface
    that gives it the following two characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: As the `Future` object, a `CompletableFuture` object will return a result sometime
    in future
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the `CompletionStage` object, you can execute more asynchronous tasks after
    the completion of one or more `CompletableFuture` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can work with a `CompletableFuture` class in different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: You can create a `CompletableFuture` object explicitly and use it as a synchronization
    point between tasks. One task will establish the value returned by `CompletableFuture`,
    using the `complete()` method, and the other tasks will wait for this value, using
    the `get()` or `join()` methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use a static method of the `CompletableFuture` class to execute `Runnable`
    or `Supplier` with the `runAsync()` and `supplyAsync()` methods. These methods
    will return a `CompletableFuture` object that will be completed when these tasks
    end their execution. In the second case, the value returned by `Supplier` will
    be the completion value of `CompletableFuture`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify other tasks to be executed in an asynchronous way after the
    completion of one or more `CompletableFuture` objects. This task can implement
    the `Runnable`, `Function`, `Consumer` or `BiConsumer` interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These characteristics make the `CompletableFuture` class very flexible and
    powerful. In this chapter, you will learn how to use this class to organize different
    tasks. The main purpose of the example is that the tasks will be executed, as
    specified in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00025.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we''re going to create a task that will generate a seed. Using this
    seed, the next task will generate a list of random numbers. Then, we will execute
    three parallel tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 will calculate the nearest number to 1,000, in a list of random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 2 will calculate the biggest number in a list of random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 3 will calculate the average number between the largest and smallest numbers
    in a list of random numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or a different IDE, such as NetBeans, open it and create a new Java
    project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''re going to implement the auxiliary tasks we will use in the example.
    Create a class named `SeedGenerator`Â  that implements the `Runnable` interface.
    It will have a `CompletableFuture` object as an attribute, and it will be initialized
    in the constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `run()` method. It will sleep the current thread for 5
    seconds (to simulate a long operation), calculate a random number between 1 and
    10, and then use the `complete()` method of the `resultCommunicator` object to
    complete `CompletableFuture`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a class named `NumberListGenerator`Â that implements the `Supplier` interface
    parameterized with the `List<Long>` data type. This means that the `get()` method
    provided by the `Supplier` interface will return a list of large numbers. This
    class will have an integer number as a private attribute, which will be initialized
    in the constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, implement the `get()` method that will return a list with millions of
    numbers, as specified in the size parameter of larger random numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create a class named `NumberSelector`Â that implements the `Function`
    interface parameterized with the `List<Long>` and `Long` data types. This means
    that the `apply()` method provided by the `Function` interface will receive a
    list of large numbers and will return a `Long` number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to implement the `Main` class and the `main()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'First, create a `CompletableFuture` object and a `SeedGenerator` task and execute
    it as a `Thread`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, wait for the seed generated by the `SeedGenerator` task, using the `get()`
    method of the `CompletableFuture` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create another `CompletableFuture` object to control the execution of a
    `NumberListGenerator` task, but in this case, use the static method `supplyAsync()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, configure the three parallelized tasks that will make calculations based
    on the list of numbers generated in the previous task. These three steps can''t
    start their execution until the `NumberListGenerator` task has finished its execution,
    so we use the `CompletableFuture` object generated in the previous step and the
    `thenApplyAsync()` method to configure these tasks. The first two steps are implemented
    in a functional way, and the third one is an object of the `NumberSelector` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'We wait for the finalization of the three parallel steps with the `allOf()`
    static method of the `CompletableFuture` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we execute a final step to write a message in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use a `CompletableFuture` object with two main purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: Wait for a value or an event that will be produced in future (creating an object
    and using the `complete()` and `get()` or `join()` methods).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To organize a set of tasks to be executed in a determined order so one or more
    tasks won't start their execution until others have finished their execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this example, we made both uses of the `CompletableFuture` class. First,
    we created an instance of this class and sent it as a parameter to a `SeedGenerator`
    task. This task uses the `complete()` method to send the calculated value, and
    the `main()` method uses the `get()` method to obtain the value. The `get()` method
    sleeps the current thread until `CompletableFuture` has been completed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we used the `supplyAsync()` method to generate a `CompletableFuture` object.
    This method receives an implementation of the `Supplier` interface as a parameter.
    This interface provides the `get()` method that must return a value. The `supplyAsync()`
    method returns `CompletableFuture`, which will be completed when the `get()` method
    finishes its execution; the value of completion is the value returned by that
    method. The `CompletableFuture` object returned will be executed by a task in
    the `ForkJoinPool` returns the static method `commonPool()`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we used the `thenApplyAsync()` method to link some tasks. You call this
    method in a `CompletableFuture` object, and you must pass an implementation of
    the `Function` interface as a parameter that can be expressed directly in the
    code using a functional style or an independent object. One powerful characteristic
    is that the value generated by `CompletableFuture` will be passed as a parameter
    to the `Function`. That is to say, in our case, all the three steps will receive
    a random list of numbers as parameters. The `CompletableFuture` class returned
    will be executed by a task in the `ForkJoinPool` returns the static method `commonPool()`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we used the `allOf()` static method of the `CompletableFuture` class
    to wait for the finalization of various tasks. This method receives a variable
    list of `CompletableFuture` objects and returns a `CompletableFuture` class that
    will be completed when all the `CompletableFuture` class passed as parameters
    are completed. We also used the `thenAcceptAsync()` method as another way to synchronize
    tasks because this method receives `Consumer` as a parameter that is executed
    by the default executor when the `CompletableFuture` object used to call the method
    is completed. Finally, we used the `join()` method to wait for the finalization
    of the last `CompletableFuture` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the execution of the example. You can see how
    the tasks are executed in the order we organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the example of this recipe, we used the `complete()`, `get()`, `join()`,
    `supplyAsync()`, `thenApplyAsync()`, `thenAcceptAsync()`, and `allOf()` methods
    of the `CompletableFuture` class. However, this class has a lot of useful methods
    that help increase the power and flexibility of this class. These are the most
    interesting ones:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods to complete a `CompletableFuture` object: In addition to the `complete()`
    method, the `CompletableFuture` class provides the following three methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cancel()`: This completes `CompletableFuture` with a `CancellationException`
    exception.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`completeAsync()`: This completes `CompletableFuture` with the result of the
    `Supplier` object passed as a parameter. The `Supplier` object is executed in
    a different thread by the default executor.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`completeExceptionally()`: This method completes `CompletableFuture` with the
    exception passed as a parameter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods to execute a task: In addition to the `supplyAsync()` method, the `CompletableFuture`
    class provides the following method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAsync()`: This is a static method of the `CompletableFuture` class that
    returns a `CompletableFuture` object. This object will be completed when the `Runnable`
    interface is passed as a parameter to finish its execution. It will be completed
    with a void result.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods to synchronize the execution of different tasks: In addition to the
    `allOf()`, `thenAcceptAsync()`, and `thenApplyAsync()` methods, the `CompletableFuture`
    class provides the following methods to synchronize the execution of tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anyOf()`: This is a static method of the `CompletableFuture` class. It receives
    a list of `CompletableFuture` objects and returns a new `CompletableFuture` object.
    This object will be completed with the result of the first `CompletableFuture`
    parameter that is completed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAfterBothAsync()`: This method receives `CompletionStage` and `Runnable`
    objects as parameters and returns a new `CompletableFuture` object. When `CompletableFuture`
    (which does the calling) and `CompletionStage` (which is received as a parameter)Â are
    completed, the `Runnable` object is executed by the default executor and then
    the `CompletableFuture` object returned is completed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`runAfterEitherAsync()`: This method is similar to the previous one, but here,
    the `Runnable` interface is executed after one of the two (`CompletableFuture`
    or `CompletionStage`) are completed.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenAcceptBothAsync()`: This method receives `CompletionStage` and `BiConsumer`
    objects as parameters and returns `CompetableFuture` as a parameter. When `CompletableFuture`
    (which does the calling) and `CompletionStage` (which is passed as a parameter),
    `BiConsumer` is executed by the default executor. It receives the results of the
    two `CompletionStage` objects as parameters but it won''t return any result. When
    `BiConsumer` finishes its execution, the returned `CompletableFuture` class is
    completed without a result.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenCombineAsync()`: This method receives a `CompletionStage` object and a
    `BiFunction` object as parameters and returns a new `CompletableFuture` object.
    When `CompletableFuture` (which does the calling) and `CompletionStage` (which
    is passed as a parameter)Â are completed, the `BiFunction` object is executed;
    it receives the completion values of both the objects and returns a new result
    that will be the completion value of the returned `CompletableFuture` class.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenComposeAsync()`:This method is analogous to `thenApplyAsync()`, but it
    is useful when the supplied function returns `CompletableFuture` too.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`thenRunAsync()`: This method is analogous to the `thenAcceptAsync()` method,
    but in this case, it receives a `Runnable` object as a parameter instead of a
    `Consumer` object.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Methods to obtain the completion value: In addition to the `get()` and `join()`
    methods, the `CompletableFuture` object provides the following method to get the
    completion value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getNow()`: This receives a value of the same type of the completion value
    of `CompletableFuture`. If the object is completed, it returns the completion
    value. Else, it returns the value passed as the parameter.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TheÂ *Creating a thread executor and controlling its rejected tasks*Â and *Executing
    tasks in an executor that returns a result* recipes in [Chapter 4](part0165.html#4TBCQ0-69b77957c9a14e36a0bec5f5a1363736),
    *Thread Executors*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
