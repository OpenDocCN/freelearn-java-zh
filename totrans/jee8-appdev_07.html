<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">WebSocket</h1>
                </header>
            
            <article>
                
<p>Traditionally, web applications have been developed using the request/response model followed by the HTTP protocol. In this traditional request/response model, the request is always initiated by the client, then the server sends a response back to the client.</p>
<p>There has never been a way for the server to send data to the client independently, that is, without having to wait for a request, until now. The WebSocket protocol allows fully duplex, two-way communication between the client (browser) and the server.</p>
<p>Java EE 7 introduced the Java API for WebSocket, which allows us to develop WebSocket endpoints in Java.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Developing WebSocket server endpoints</li>
<li>Developing WebSocket clients in JavaScript</li>
<li>Developing WebSocket clients in Java</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing a WebSocket server endpoint</h1>
                </header>
            
            <article>
                
<p>There are two ways we can implement a WebSocket server endpoint via the Java API for WebSocket. We can either develop an endpoint programmatically, in which case we need to extend the <kbd>javax.websocket.Endpoint</kbd> class, or by decorating <strong>Plain Old Java Objects</strong> (<strong>POJOs</strong>) with WebSocket specific annotations. These two approaches are very similar, therefore, we will only be discussing the annotation approach in detail, and will briefly explain how to develop WebSocket server endpoints programmatically later in the chapter.</p>
<p>In this chapter, we will develop a simple web-based chat application, taking full advantage of the Java API for WebSocket.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing an annotated WebSocket server endpoint</h1>
                </header>
            
            <article>
                
<p>The following Java class illustrates how we can develop a WebSocket server endpoint by annotating a Java class:</p>
<pre style="padding-left: 60px">package net.ensode.javaeebook.websocketchat.serverendpoint; 
 
import java.io.IOException; 
import java.util.logging.Level; 
import java.util.logging.Logger; 
import javax.websocket.OnClose; 
import javax.websocket.OnMessage; 
import javax.websocket.OnOpen; 
import javax.websocket.Session; 
import javax.websocket.server.ServerEndpoint; 
 
<strong>@ServerEndpoint("/websocketchat")</strong><br/>public class WebSocketChatEndpoint {<br/><br/>    private static final Logger LOG = Logger.getLogger(WebSocketChatEndpoint.class.getName());<br/><br/>   <strong> @OnOpen</strong><br/>    public void connectionOpened() {<br/>        LOG.log(Level.INFO, "connection opened");<br/>    }<br/><br/>    <strong>@OnMessage</strong><br/>    public synchronized void processMessage(Session session, String<br/>        message) {<br/>        LOG.log(Level.INFO, "received message: {0}", message);<br/><br/>        try {<br/>          <strong>  for (Session sess : session.getOpenSessions()) {</strong><br/><strong>                if (sess.isOpen()) {</strong><br/><strong>                    sess.getBasicRemote().sendText(message);</strong><br/><strong>                }</strong><br/><strong>            }</strong><br/>        } catch (IOException ioe) {<br/>            LOG.log(Level.SEVERE, ioe.getMessage());<br/>        }<br/>    }<br/><br/>    @OnClose<br/>    public void connectionClosed() {<br/>        LOG.log(Level.INFO, "connection closed");<br/>    }<br/><br/>}<br/><br/></pre>
<p>The class level <kbd>@ServerEndpoint</kbd> annotation indicates that the class is a WebSocket server endpoint. The <strong>URI</strong> (<strong>Uniform Resource Identifier</strong>) of the server endpoint is the value specified between the parenthesis following the annotation (<kbd>"/websocketchat"</kbd>, in this example). WebSocket clients will use this URI to communicate with our endpoint.</p>
<p>The <kbd>@OnOpen</kbd> annotation is used to decorate a method that needs to be executed whenever a WebSocket connection is opened from any of the clients. In our example, we are simply sending some output to the server log, but of course any valid server-side Java code can be placed here.</p>
<p>Any method annotated with the <kbd>@OnMessage</kbd> annotation will be invoked whenever our server endpoint receives a message from any of the clients. Since we are developing a chat application, our code simply broadcasts the message it receives to all connected clients.</p>
<p>In our example, the <kbd>processMessage()</kbd> method is annotated with <kbd>@OnMessage</kbd>, and it takes two parameters: an instance of a class implementing the <kbd>javax.websocket.Session</kbd> interface, and a <kbd>String</kbd> containing the message that was received. Since we are developing a chat application, our WebSocket server endpoint simply broadcasts the received message to all connected clients.</p>
<p>The <kbd>getOpenSessions()</kbd> method of the <kbd>Session</kbd> interface returns a set of <kbd>Session</kbd> objects representing all open sessions. We iterate through this set to broadcast the received message back to all connected clients by invoking the <kbd>getBasicRemote()</kbd> method on each <kbd>Session</kbd> instance, then invoking the <kbd>sendText()</kbd> method on the resulting <kbd>RemoteEndpoint.Basic</kbd> implementation returned by this call.</p>
<p>The <kbd>getOpenSessions()</kbd> method on the <kbd>Session</kbd> interface returns all the open sessions at the time the method was invoked. It is possible for one or more of the sessions to have closed after the method was invoked, therefore, it is recommended to invoke the <kbd>isOpen()</kbd> method on a <kbd>Session</kbd> implementation before attempting to send data back to the client.</p>
<p>Finally, we need to decorate a method with the <kbd>@OnClose</kbd> annotation if we need to handle the event when a client disconnects from the server endpoint. In our example, we simply log a message to the server log.</p>
<p>There is one additional annotation that we didn't use in our example. The <kbd>@OnError</kbd> annotation is used to decorate a method that needs to be invoked in the event of an error in sending or receiving data to or from the client.</p>
<p>As we can see, developing an annotated WebSocket server endpoint is straightforward; we simply need to add a few annotations and the application server will invoke our annotated methods as necessary.</p>
<p>If we wish to develop a WebSocket server endpoint programmatically, we need to write a Java class that extends <kbd>javax.websocket.Endpoint</kbd>. This class has <kbd>onOpen()</kbd>, <kbd>onClose()</kbd>, and <kbd>onError()</kbd> methods, which are called at appropriate times during the endpoint's lifecycle. There is no method equivalent to the <kbd>@OnMessage</kbd> annotation to handle incoming messages from clients; the <kbd>addMessageHandler()</kbd> method needs to be invoked in the <kbd>Session</kbd>, passing an instance of a class implementing the <kbd>javax.websocket.MessageHandler</kbd> interface (or one of its subinterfaces) as its sole parameter.</p>
<p>In general, it is easier and more straightforward to develop annotated WebSocket endpoints, as opposed to their programmatic counterparts, therefore, we recommend the annotated approach whenever possible.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing WebSocket clients</h1>
                </header>
            
            <article>
                
<p>Most WebSocket clients are implemented as web pages taking advantage of the JavaScript WebSocket API. We will cover how to do this in the next section.</p>
<p>The Java API for WebSocket provides a client API that allows us to develop WebSocket clients as standalone Java applications. We will be covering this capability later in the chapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing JavaScript client-side WebSocket code</h1>
                </header>
            
            <article>
                
<p>In this section, we will cover how to develop client-side JavasScript code to interact with the WebSocket endpoint we developed in the previous section.</p>
<p>The client page for our WebSocket example is implemented as a JSF page using HTML5 friendly markup (as explained in <a href="9059bc2f-04fb-43df-a5c5-8b2cce80792e.xhtml" target="_blank"><span class="ChapterrefPACKT">Chapter 2</span></a>, <em>JavaServer Faces</em>).</p>
<p>Our client page consists of a text area, where we can see what users of our application are saying (it is, after all, a chat application), and an input text we can use to send a message to other users:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/0e0e17e7-5c52-416c-8398-0baee4327a32.png" style="width:27.92em;height:22.50em;"/></div>
<p>The markup for our client page looks like this:</p>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;!DOCTYPE html&gt; 
&lt;html  
&gt; 
&lt;head&gt; 
&lt;title&gt;WebSocket Chat&lt;/title&gt; 
&lt;meta name="viewport" content="width=device-width"/&gt; 
<strong>&lt;script type="text/javascript"&gt; 
var websocket; 
function init() { 
websocket = new WebSocket( 
'ws://localhost:8080/websocketchat/websocketchat'); 
 
websocket.onopen = function(event) { 
websocketOpen(event) 
}; 
websocket.onmessage = function(event) { 
websocketMessage(event) 
}; 
websocket.onerror = function(event) { 
websocketError(event) 
}; 
 
} 
 
function websocketOpen(event) { 
console.log("webSocketOpen invoked"); 
} 
 
function websocketMessage(event) { 
console.log("websocketMessage invoked"); 
document.getElementById('chatwindow').value += '\r' + 
event.data; 
} 
 
function websocketError(event) { 
console.log("websocketError invoked"); 
} 
 
function sendMessage() { 
var userName = 
document.getElementById('userName').value; 
var msg = 
document.getElementById('chatinput').value; 
 
websocket.send(userName + ": " + msg); 
} 
 
function closeConnection(){ 
websocket.close(); 
} 
 
window.addEventListener("load", init);  
&lt;/script&gt;</strong> 
&lt;/head&gt; 
&lt;body&gt; 
&lt;form jsf:prependId="false"&gt; 
&lt;input type="hidden" id="userName" 
value="#{user.userName}"/&gt; 
&lt;table border="0"&gt; 
&lt;tbody&gt; 
&lt;tr&gt; 
&lt;td&gt; 
&lt;label for="chatwindow"&gt; 
Chat Window 
&lt;/label&gt; 
&lt;/td&gt; 
&lt;td&gt; 
<strong>&lt;textArea id="chatwindow" rows="10"/&gt;</strong> 
&lt;/td&gt; 
&lt;/tr&gt; 
&lt;tr&gt; 
&lt;td&gt; 
&lt;label for="chatinput"&gt; 
Type Something Here 
&lt;/label&gt; 
&lt;/td&gt; 
&lt;td&gt; 
<strong>&lt;input type="text" id="chatinput"/&gt;  
&lt;input id="sendBtn" type="button" value="Send"  
 onclick="sendMessage()"/&gt;</strong> 
&lt;/td&gt; 
&lt;/tr&gt; 
&lt;tr&gt; 
&lt;td&gt;&lt;/td&gt; 
&lt;td&gt; 
<strong>&lt;input type="button" id="exitBtn" value="Exit"  
 onclick="closeConnection()"/&gt;</strong> 
&lt;/td&gt; 
&lt;/tr&gt; 
&lt;/tbody&gt; 
&lt;/table&gt; 
&lt;/form&gt; 
&lt;/body&gt; 
&lt;/html&gt; </pre>
<p>The last line of our JavaScript code (<kbd>window.addEventListener("load", init);</kbd>) sets our JavaScript <kbd>init()</kbd> function to be executed as soon as the page loads.</p>
<p>In the <kbd>init()</kbd> function, we initialize a new JavaScript WebSocket object, passing the URI of our server endpoint as a parameter. This lets our JavaScript code know the location of our server endpoint.</p>
<p>The JavaScript WebSocket object has a number of function types, used to handle different events, such as opening the connection, receiving a message, and handling errors. We need to set these types to our own JavaScript functions so that we can handle these events, which is what we do in our <kbd>init()</kbd> function, right after invoking the constructor for the JavaScript WebSocket object. In our example, the functions we assigned to the WebSocket object simply delegate their functionality to standalone JavaScript functions.</p>
<p>Our <kbd>websocketOpen()</kbd> function is called whenever the WebSocket connection is opened. In our example, we simply send a message to the browser's JavaScript console.</p>
<p>Our <kbd>webSocketMessage()</kbd> function is invoked whenever the browser receives a web socket message from our WebSocket endpoint. In our example, we update the contents of the text area with the ID <kbd>chatWindow</kbd> with the contents of the message.</p>
<p>Our <kbd>websocketError()</kbd> function is called whenever there is a WebSocket related error. In our example, we simply send a message to the browser's JavaScript console.</p>
<p>Our JavaScript <kbd>sendMessage()</kbd> function sends a message to the WebSocket server endpoint, containing both the username and the contents of the text input with the ID <kbd>chatinput</kbd>. This function is called when the user clicks on the button with the ID <kbd>sendBtn</kbd>.</p>
<p>Our <kbd>closeConnection()</kbd> JavaScript function closes the connection to our WebSocket server endpoint. This function is called when the user clicks on the button with the ID <kbd>exitBtn</kbd>.</p>
<p>As we can see from this example, writing client-side JavaScript code to interact with WebSocket endpoints is fairly straightforward.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Developing WebSocket clients in Java</h1>
                </header>
            
            <article>
                
<p>Although developing web-based WebSocket clients is currently the most common way of developing WebSocket clients, the Java API for WebSocket provides a client API we can use to develop WebSocket clients in Java.</p>
<p>In this section, we will be developing a simple WebSocket client using the client API of the Java API for WebSocket. The final product looks like this:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img class=" image-border" src="assets/e6ded8e6-c2a0-4abb-bbc9-6ca41962c06a.png" style="width:34.67em;height:16.17em;"/></div>
<p>However, we won't be covering the GUI code (developed using the Swing framework), since it is not relevant to the discussion. The complete code for the example, including the GUI code, can be downloaded from the Packt Publishing website.</p>
<p>Just as with WebSocket server endpoints, Java WebSocket clients can be developed either programmatically or by using annotations. Once again, we will cover only the annotation approach; developing a programmatic client is very similar to the way programmatic server endpoints are developed, which is to say, programmatic clients must extend <kbd>javax.websocket.Endpoint</kbd> and override the appropriate methods.</p>
<p>Without further ado, here is the code for our Java WebSocket client:</p>
<pre style="padding-left: 60px">package net.ensode.websocketjavaclient;<br/><br/>import java.io.IOException;<br/>import java.net.URI;<br/>import java.net.URISyntaxException;<br/>import javax.websocket.ClientEndpoint;<br/>import javax.websocket.CloseReason;<br/>import javax.websocket.ContainerProvider;<br/>import javax.websocket.DeploymentException;<br/>import javax.websocket.OnClose;<br/>import javax.websocket.OnError;<br/>import javax.websocket.OnMessage;<br/>import javax.websocket.OnOpen;<br/>import javax.websocket.Session;<br/>import javax.websocket.WebSocketContainer;<br/><br/><strong>@ClientEndpoint</strong><br/>public class WebSocketClient {<br/><br/>    private String userName;<br/>    private Session session;<br/>    private final WebSocketJavaClientFrame webSocketJavaClientFrame;<br/><br/>    public WebSocketClient(WebSocketJavaClientFrame<br/>        webSocketJavaClientFrame) {<br/>        this.webSocketJavaClientFrame = webSocketJavaClientFrame;<br/><br/>        try {<br/>           <strong> WebSocketContainer webSocketContainer =</strong><br/><strong>                ContainerProvider.getWebSocketContainer();</strong><br/><strong>            webSocketContainer.connectToServer(this, </strong><br/><strong>                new URI(</strong><br/><strong>               </strong><br/><strong>         "ws://localhost:8080/websocketchat/websocketchat"));</strong><br/>        } catch (DeploymentException |<br/>                      IOException | URISyntaxException ex) {<br/>            ex.printStackTrace();<br/>        }<br/><br/>    }<br/><br/>  <strong>  @OnOpen</strong><br/>    public void onOpen(Session session) {<br/>        System.out.println("onOpen() invoked");<br/>        this.session = session;<br/>    }<br/><br/><strong>    @OnClose</strong><br/>    public void onClose(CloseReason closeReason) {<br/>        System.out.println("Connection closed, reason: "<br/>                + closeReason.getReasonPhrase());<br/>    }<br/><br/>    <strong>@OnError</strong><br/>    public void onError(Throwable throwable) {<br/>        System.out.println("onError() invoked");<br/>        throwable.printStackTrace();<br/>    }<br/><br/>    <strong>@OnMessage</strong><br/>    public void onMessage(String message, Session session) {<br/>        System.out.println("onMessage() invoked");<br/>          webSocketJavaClientFrame.getChatWindowTextArea().<br/>            setText(<br/>            webSocketJavaClientFrame.getChatWindowTextArea().<br/>            getText() + "\n" + message);<br/>    }<br/><br/>    public void sendMessage(String message) {<br/>        try {<br/>            System.out.println("sendMessage() invoked, message = " <br/>             + message);<br/>           <strong> session.getBasicRemote().sendText(userName + ": " +<br/>             message);</strong><br/>        } catch (IOException ex) {<br/>            ex.printStackTrace();<br/>        }<br/>    }<br/><br/>    public String getUserName() {<br/>        return userName;<br/>    }<br/><br/>    public void setUserName(String userName) {<br/>        this.userName = userName;<br/>    }<br/><br/>}</pre>
<p>The class-level <kbd>@ClientEndPoint</kbd> annotation denotes our class as a WebSocket client; all Java WebSocket clients must be annotated with this annotation.</p>
<p>The code to establish a connection to the WebSocket server endpoint is in our class constructor. First, we need to invoke <kbd>ContainerProvider.getWebSocketContainer()</kbd> to obtain an instance of <kbd>javax.websocket.WebSocketContainer</kbd>. We then establish the connection by invoking the <kbd>connectToServer()</kbd> method on our <kbd>WebSocketContainer</kbd> instance, passing a class annotated with <kbd>@ClientEndpoint</kbd> as the first parameter (in our example, we use this because the connection code is inside our WebSocket Java client code), and a URI object containing the WebSocket server endpoint URI as the second parameter.</p>
<p>After the connection is established, we are ready to respond to WebSocket events. Alert readers may have noticed that the exact same annotations we used to develop our server endpoint are used again in our client code.</p>
<p>Any method annotated with the <kbd>@OnOpen</kbd> annotation will be invoked automatically when the connection to the WebSocket server endpoint is established. The method must return void and can have an optional parameter of type <kbd>javax.websocket.Session</kbd>. In our example, we send some output to the console and initialize a class variable with the <kbd>Session</kbd> instance we received as a parameter.</p>
<p>Methods annotated with the <kbd>@OnClose</kbd> annotation are invoked whenever the WebSocket session is closed. The annotated method can have an optional <kbd>javax.websocket.Session</kbd> parameter and an optional <kbd>CloseReason</kbd>parameter. In our example, we chose to use only the <kbd>CloseReason</kbd> optional parameter, since this class has a handy <kbd>getReasonPhrase()</kbd> method that provides a short explanation of why the session was closed.</p>
<p>The <kbd>@OnError</kbd> annotation is used to decorate any methods that will be called when an error occurs. Methods annotated with <kbd>@OnError</kbd> must have a <kbd>java.lang.Throwable</kbd> parameter (the parent class of <kbd>java.lang.Exception</kbd>), and can have an optional <kbd>type session</kbd> parameter. In our example, we simply send the stack trace of the <kbd>Throwable</kbd> parameter to <kbd>stderr</kbd>.</p>
<p>Methods annotated with <kbd>@OnMessage</kbd> are invoked whenever an incoming WebSocket message is received. <kbd>@OnMessage</kbd> methods can have different parameters depending on the type of message received and how we wish to handle it. In our example, we used the most common case, receiving a text message. In this particular case, we need a <kbd>String</kbd> parameter, which will hold the contents of the message, and an optional <kbd>Session</kbd> parameter.</p>
<div class="packt_infobox">Refer to the JavaDoc documentation for <kbd>@OnMessage</kbd> at <a href="https://javaee.github.io/javaee-spec/javadocs/javax/websocket/OnMessage.html"><span class="URLPACKT">http://docs.oracle.com/javaee/7/api/javax/websocket/OnMessage.html</span></a> for information on how to handle other types of messages.</div>
<p>In our example, we simply update the <span class="packt_screen">Chat Window</span> text area, appending the received message to its contents.</p>
<p>To send a WebSocket message, we invoke the <kbd>getBasicRemote()</kbd> method on our <kbd>Session</kbd> instance, then invoke the <kbd>sendText()</kbd> method on the resulting <kbd>R.emoteEndpoint</kbd>. A basic implementation is returned by this call (if this looks familiar, it is because we did the exact same thing in the WebSocket server endpoint code). In our example, we do this in the <kbd>sendMessage()</kbd> method.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Additional information about the Java API for WebSocket</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the bulk of the functionality provided by the Java API for WebSocket. For additional information, refer to the user guide for Tyrus, the Java API for WebSocket reference implementation, at <a href="https://tyrus.java.net/documentation/1.3.1/user-guide.html"><span class="URLPACKT">https://tyrus.java.net/documentation/1.3.1/user-guide.html</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the Java API for WebSocket, a Java EE API for developing WebSocket server endpoints and clients. We first saw how to develop WebSocket server endpoints by taking advantage of the Java API for WebSocket. Then, we covered how to develop web-based WebSocket clients using JavaScript. Finally, we explained how to develop WebSocket client applications in Java.</p>


            </article>

            
        </section>
    </body></html>