- en: Chapter 5. Step Execution
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 步骤执行
- en: In the previous chapter, we learned about transactions and managing the transactions
    in different scenarios, along with customizing the transactions with isolation
    levels, and attribute configurations for single and multiple data sources with
    patterns. So far, we have discussed the simple jobs, where the flow is linear
    and contains jobs with steps executing one after the other. In real world applications,
    we need to configure jobs with a combination of steps, sharing data between them
    and deciding which step to execute at runtime.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了事务以及在不同场景下管理事务，包括使用隔离级别和模式配置单数据源和多数据源的事务属性。到目前为止，我们已经讨论了简单的作业，其中流程是线性的，包含一个步骤接着另一个步骤执行的作业。在现实世界应用中，我们需要配置带有步骤组合的作业，它们之间共享数据，并在运行时决定执行哪个步骤。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Controlling the job flow
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制作业流
- en: Data sharing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据共享
- en: Externalization and termination
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部化和终止
- en: Controlling the job flow
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制作业流
- en: So far we have seen batch jobs configured with steps executing consecutively
    in a linear fashion. There could be scenarios to decide which step to execute
    based on the outcome of the previous step during the execution of a batch job,
    which is a nonlinear execution.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了配置了步骤以线性方式连续执行的批处理作业。在批处理作业执行过程中，可能会出现根据前一步的执行结果来决定执行哪个步骤的情况，这是一种非线性执行。
- en: 'The following figure shows how the linear step execution happens in a batch
    job:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了批处理作业中线性步骤执行的情况：
- en: '![Controlling the job flow](img/3372OS_05_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![控制作业流](img/3372OS_05_01.jpg)'
- en: 'The following figure shows how the nonlinear step execution happens in a batch
    job:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了批处理作业中非线性步骤执行的情况：
- en: '![Controlling the job flow](img/3372OS_05_02.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![控制作业流](img/3372OS_05_02.jpg)'
- en: 'Let''s understand how to handle such a job flow. There are primarily two ways
    to handle it:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解如何处理这样的作业流。主要有两种处理方式：
- en: Using an exit code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用退出码
- en: Using a decision logic
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用决策逻辑
- en: Using an exit code
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用退出码
- en: 'Job flow can be handled based on the exit status of a step along with the configuration
    of the `next` tag with the `on` and `to` properties. The following is a sample
    configuration using an exit code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据步骤的退出状态以及带有`on`和`to`属性的`next`标签的配置来处理作业流。以下是一个使用退出码的示例配置：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding configuration, `stepOne` is the first step to be executed
    in the batch job. Based on the output (`ExitStatus`) of this step, which includes
    `testTasklet`, the next tag decides which step to execute. If `testTasklet` returns
    a `FAILED` status, it executes `stepThree`, otherwise `stepTwo`. The status can
    be returned either by the attribute of job execution or step execution. The following
    are the different statuses:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，`stepOne`是批处理作业中要执行的第一步。根据此步骤的输出（`ExitStatus`），包括`testTasklet`，下一个标签决定执行哪个步骤。如果`testTasklet`返回`FAILED`状态，则执行`stepThree`，否则执行`stepTwo`。状态可以由作业执行或步骤执行的属性返回。以下是一些不同的状态：
- en: 'String: The exit status should match with a String, for example, `COMPLETED`/`FAILED`,
    which can be verified from `FlowExecutionStatus`.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串：退出状态应与字符串匹配，例如`COMPLETED`/`FAILED`，这可以从`FlowExecutionStatus`中验证。
- en: '`*`: This matches with zero or more characters. It matches any value.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*`: 可以匹配零个或多个字符。它可以匹配任何值。'
- en: '`?`: This matches only one character.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`?`: 仅匹配一个字符。'
- en: Using a decision logic
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用决策逻辑
- en: The nonlinear job execution can also be handled with the decision logic using
    the implementation of `JobExecutionDecider` and decision tag configuration.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 非线性作业执行也可以通过使用`JobExecutionDecider`实现和决策标签配置的决策逻辑来处理。
- en: 'The following is the `JobExecutionDecider` implementation to check the exit
    status and return `FlowExecutionStatus` accordingly:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对应于检查退出状态并相应返回`FlowExecutionStatus`的`JobExecutionDecider`实现：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following is the job configuration with the `JobExecutionDecider` implementation
    and decision tag configuration:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 以下包含`JobExecutionDecider`实现和决策标签配置的作业配置：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One can choose between these two options (exit codes and decision logic) based
    on the monitoring status needs; the job execution decider makes the configuration
    more readable.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 可以根据监控状态需求在这两种选项（退出码和决策逻辑）之间进行选择；作业执行决策者使配置更易于阅读。
- en: Data sharing
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据共享
- en: 'While each step should be configured to execute on its own in an ideal scenario,
    the steps need to share the data in real-world scenarios. The data can be shared
    between steps in different ways. The following are the options:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想情况下，每个步骤都应该配置为独立执行，但在现实场景中，步骤需要共享数据。数据可以通过不同的方式在步骤之间共享。以下是一些选项：
- en: Using execution context
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用执行上下文
- en: Using Spring holder beans
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring 持有者 beans
- en: Using execution context
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用执行上下文
- en: 'We learned from the previous chapters that the Spring Batch jobs maintain information
    about the job execution in a context called batch job metadata. We can use this
    context to share data between steps. The key-value-based data is maintained by
    `org.springframework.batch.item.ExecutionContext` in its usage. The following
    is the way to put/get the data from it:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的章节中我们了解到，Spring Batch 作业在称为批作业元数据的上下文中维护作业执行信息。我们可以使用这个上下文在步骤之间共享数据。基于键值的数据由
    `org.springframework.batch.item.ExecutionContext` 在其使用中维护。以下是从中获取/设置数据的方式：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Both job and step have their own execution context in the form of `JobExecutionContext`
    and `StepExecutionContext`. While jobs have a unique execution context, each step
    in a job maintains its own step execution context. Step context can be accessed
    from the chunk context (`org.springframework.batch.core.scope.context.ChunkContext`)
    and the job context can be accessed from the step context.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 作业和步骤都有它们自己的执行上下文，形式为 `JobExecutionContext` 和 `StepExecutionContext`。虽然作业有一个唯一的执行上下文，但作业中的每个步骤都维护其自己的步骤执行上下文。步骤上下文可以通过块上下文（`org.springframework.batch.core.scope.context.ChunkContext`）访问，而作业上下文可以通过步骤上下文访问。
- en: Using Spring holder beans
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Spring 持有者 beans
- en: 'The data between steps can be shared using the concept of Spring holder beans
    as well. Metadata configuration is represented by `ImportMetadata`, through which
    we can set and get the data. We can write a bean that can hold the reference of
    `ImportMetadata` and configure the same as `ImportMetadataHolder` in job configuration.
    The following is the sample configuration for `ImportMetadataHolder`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤之间的数据也可以通过使用 Spring 持有者 beans 的概念进行共享。元数据配置由 `ImportMetadata` 表示，通过它可以设置和获取数据。我们可以编写一个可以持有
    `ImportMetadata` 引用的 bean，并在作业配置中将它与 `ImportMetadataHolder` 配置相同。以下是对 `ImportMetadataHolder`
    的示例配置：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The data can be set and got from the holder by using following syntax:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下语法从持有者设置和获取数据：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `ImportMetadataHolder` can be configured just like any other bean and injected
    into the tasklets with the property specification.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`ImportMetadataHolder` 可以像任何其他 bean 一样进行配置，并通过属性规范注入到 tasklets 中。'
- en: Externalization and termination
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部化和终止
- en: Externalization and termination are the concepts that help to make reusable
    components of Spring Batch and handle job termination graciously.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 外部化和终止是帮助使 Spring Batch 的组件可重用并优雅地处理作业终止的概念。
- en: Externalization
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部化
- en: 'Spring Batch allows code reuse using externalization, the concept of separating
    the reusable steps of operation and including them in desired jobs. Along with
    the configuration of the individual steps as beans and including them in each
    job, externalization can be achieved in the following ways:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Batch 允许使用外部化进行代码重用，即分离可重用操作步骤并将其包含在所需作业中。除了将单个步骤作为 beans 进行配置并包含在每个作业中之外，外部化还可以通过以下方式实现：
- en: External flow definition and including it in desired jobs
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部流程定义及其包含在所需作业中
- en: Inherited jobs mechanism
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承作业机制
- en: External flow definition and including it in desired jobs
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 外部流程定义及其包含在所需作业中
- en: 'The following is a sample configuration for external flow definition and including
    it in the desired job:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对外部流程定义及其包含在所需作业中的示例配置：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Inherited jobs mechanism
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承作业机制
- en: 'The other way of externalizing the process is by inheriting one job into the
    other, which means defining an independent job and referring to it in another
    job as a part of it. The following is a sample configuration for it:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将流程外部化的另一种方式是通过继承一个作业到另一个作业，这意味着定义一个独立的作业，并在另一个作业中将其作为其一部分进行引用。以下是对其的示例配置：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main job has a couple of steps and the sub job is defined to refer to the
    main job as a part of its first step.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 主要作业有几个步骤，子作业被定义为在它的第一步中引用主要作业。
- en: Termination
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终止
- en: 'Ending the execution programmatically is an important aspect of the batch job
    execution. To be able to effectively program this, one should be aware of the
    different states in which the job can be terminated. The different states are
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程方式结束执行是批处理作业执行的一个重要方面。为了能够有效地编程，应该了解作业可以终止的不同状态。不同的状态如下：
- en: '`COMPLETED`: This end state can be used to tell Spring Batch that the processing
    has ended successfully. When a job instance is terminated with this end state,
    it isn''t allowed to rerun with the same set of parameters.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMPLETED`：此结束状态可以用来告诉Spring Batch处理已成功结束。当一个作业实例以这种结束状态终止时，不允许使用相同的参数集重新运行。'
- en: '`FAILED`: This end state can be used to tell Spring Batch that the processing
    has failed. Spring Batch lets the failed jobs rerun with the same set of parameters.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FAILED`：此结束状态可以用来告诉Spring Batch处理已失败。Spring Batch允许失败的作业使用相同的参数集重新运行。'
- en: '`STOPPED`: This end state is like pausing an executing job. If ended with this
    state, Spring Batch not only lets us restart the job, it also lets us restart
    from where it left off, even though there are no errors in execution.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`STOPPED`：此结束状态类似于暂停正在执行的作业。如果以这种状态结束，Spring Batch不仅允许我们重新启动作业，而且允许我们从上次停止的地方重新启动，即使执行过程中没有错误。'
- en: Terminating in the COMPLETED state
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以`COMPLETED`状态终止
- en: 'The following is the configuration to terminate a job in the `COMPLETED` state,
    based on the `ExitStatus` with the end tag configuration:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于带有end标签配置的`ExitStatus`终止作业在`COMPLETED`状态的配置：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This configuration ends the job after successful execution, and we can't rerun
    the job with the same set of parameters. The first step is configured to invoke
    the second step if it has failed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置在成功执行后结束作业，并且我们不能使用相同的参数集重新运行作业。第一步配置为在第二步失败时调用第二步。
- en: Terminating in the FAILED state
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以`FAILED`状态终止
- en: 'The following is the configuration to terminate a job in the `FAILED` state,
    based on the `ExitStatus` with the fail tag configuration:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于带有fail标签配置的`ExitStatus`终止作业在`FAILED`状态的配置：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This configuration ends the job with the `FAILED` state if the exit status is
    `FAILED`, and we can rerun the job with the same set of parameters.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果退出状态是`FAILED`，则此配置将以`FAILED`状态结束作业，并且我们可以使用相同的参数集重新运行作业。
- en: Terminating in the STOPPED state
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以`STOPPED`状态终止
- en: 'The following is the configuration to terminate a job in the `STOPPED` state,
    based on the `ExitStatus` with the stop tag configuration:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是基于带有stop标签配置的`ExitStatus`终止作业在`STOPPED`状态的配置：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This configuration ends the job with the `STOPPED` state if the exit status
    is `FAILED`, and we can rerun the job with the same set of parameters.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果退出状态是`FAILED`，则此配置将以`STOPPED`状态结束作业，并且我们可以使用相同的参数集重新运行作业。
- en: Summary
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Through this chapter, we learned about controlling the flow of a batch job using
    exit codes and decision logic. We also learned how to share data between the steps
    in execution with the help of execution context and holder beans. We also learned
    about reusing the process by externalizing the flow and inherited job mechanisms.
    We finished this chapter with an understanding of terminating the batch job in
    different states and their importance. In the next chapter, we will learn in detail
    about the enterprise integration using Spring integration and RESTful job processing.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们学习了如何使用退出代码和决策逻辑控制批处理作业的流程。我们还学习了如何在执行步骤之间通过执行上下文和holder beans共享数据。我们还学习了通过外部化和继承作业机制来重用流程。我们通过理解在不同状态下终止批处理作业及其重要性来结束本章。在下一章中，我们将详细了解使用Spring集成和RESTful作业处理的企业集成。
