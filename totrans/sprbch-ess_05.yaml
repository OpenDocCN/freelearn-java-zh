- en: Chapter 5. Step Execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about transactions and managing the transactions
    in different scenarios, along with customizing the transactions with isolation
    levels, and attribute configurations for single and multiple data sources with
    patterns. So far, we have discussed the simple jobs, where the flow is linear
    and contains jobs with steps executing one after the other. In real world applications,
    we need to configure jobs with a combination of steps, sharing data between them
    and deciding which step to execute at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the job flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data sharing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Externalization and termination
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling the job flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have seen batch jobs configured with steps executing consecutively
    in a linear fashion. There could be scenarios to decide which step to execute
    based on the outcome of the previous step during the execution of a batch job,
    which is a nonlinear execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how the linear step execution happens in a batch
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the job flow](img/3372OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following figure shows how the nonlinear step execution happens in a batch
    job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the job flow](img/3372OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s understand how to handle such a job flow. There are primarily two ways
    to handle it:'
  prefs: []
  type: TYPE_NORMAL
- en: Using an exit code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a decision logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an exit code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Job flow can be handled based on the exit status of a step along with the configuration
    of the `next` tag with the `on` and `to` properties. The following is a sample
    configuration using an exit code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding configuration, `stepOne` is the first step to be executed
    in the batch job. Based on the output (`ExitStatus`) of this step, which includes
    `testTasklet`, the next tag decides which step to execute. If `testTasklet` returns
    a `FAILED` status, it executes `stepThree`, otherwise `stepTwo`. The status can
    be returned either by the attribute of job execution or step execution. The following
    are the different statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'String: The exit status should match with a String, for example, `COMPLETED`/`FAILED`,
    which can be verified from `FlowExecutionStatus`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*`: This matches with zero or more characters. It matches any value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`?`: This matches only one character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a decision logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The nonlinear job execution can also be handled with the decision logic using
    the implementation of `JobExecutionDecider` and decision tag configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `JobExecutionDecider` implementation to check the exit
    status and return `FlowExecutionStatus` accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the job configuration with the `JobExecutionDecider` implementation
    and decision tag configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One can choose between these two options (exit codes and decision logic) based
    on the monitoring status needs; the job execution decider makes the configuration
    more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Data sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While each step should be configured to execute on its own in an ideal scenario,
    the steps need to share the data in real-world scenarios. The data can be shared
    between steps in different ways. The following are the options:'
  prefs: []
  type: TYPE_NORMAL
- en: Using execution context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring holder beans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using execution context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned from the previous chapters that the Spring Batch jobs maintain information
    about the job execution in a context called batch job metadata. We can use this
    context to share data between steps. The key-value-based data is maintained by
    `org.springframework.batch.item.ExecutionContext` in its usage. The following
    is the way to put/get the data from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Both job and step have their own execution context in the form of `JobExecutionContext`
    and `StepExecutionContext`. While jobs have a unique execution context, each step
    in a job maintains its own step execution context. Step context can be accessed
    from the chunk context (`org.springframework.batch.core.scope.context.ChunkContext`)
    and the job context can be accessed from the step context.
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring holder beans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The data between steps can be shared using the concept of Spring holder beans
    as well. Metadata configuration is represented by `ImportMetadata`, through which
    we can set and get the data. We can write a bean that can hold the reference of
    `ImportMetadata` and configure the same as `ImportMetadataHolder` in job configuration.
    The following is the sample configuration for `ImportMetadataHolder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The data can be set and got from the holder by using following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `ImportMetadataHolder` can be configured just like any other bean and injected
    into the tasklets with the property specification.
  prefs: []
  type: TYPE_NORMAL
- en: Externalization and termination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Externalization and termination are the concepts that help to make reusable
    components of Spring Batch and handle job termination graciously.
  prefs: []
  type: TYPE_NORMAL
- en: Externalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Spring Batch allows code reuse using externalization, the concept of separating
    the reusable steps of operation and including them in desired jobs. Along with
    the configuration of the individual steps as beans and including them in each
    job, externalization can be achieved in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: External flow definition and including it in desired jobs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inherited jobs mechanism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External flow definition and including it in desired jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a sample configuration for external flow definition and including
    it in the desired job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Inherited jobs mechanism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The other way of externalizing the process is by inheriting one job into the
    other, which means defining an independent job and referring to it in another
    job as a part of it. The following is a sample configuration for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The main job has a couple of steps and the sub job is defined to refer to the
    main job as a part of its first step.
  prefs: []
  type: TYPE_NORMAL
- en: Termination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ending the execution programmatically is an important aspect of the batch job
    execution. To be able to effectively program this, one should be aware of the
    different states in which the job can be terminated. The different states are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COMPLETED`: This end state can be used to tell Spring Batch that the processing
    has ended successfully. When a job instance is terminated with this end state,
    it isn''t allowed to rerun with the same set of parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FAILED`: This end state can be used to tell Spring Batch that the processing
    has failed. Spring Batch lets the failed jobs rerun with the same set of parameters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`STOPPED`: This end state is like pausing an executing job. If ended with this
    state, Spring Batch not only lets us restart the job, it also lets us restart
    from where it left off, even though there are no errors in execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terminating in the COMPLETED state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the configuration to terminate a job in the `COMPLETED` state,
    based on the `ExitStatus` with the end tag configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This configuration ends the job after successful execution, and we can't rerun
    the job with the same set of parameters. The first step is configured to invoke
    the second step if it has failed.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating in the FAILED state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the configuration to terminate a job in the `FAILED` state,
    based on the `ExitStatus` with the fail tag configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This configuration ends the job with the `FAILED` state if the exit status is
    `FAILED`, and we can rerun the job with the same set of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating in the STOPPED state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is the configuration to terminate a job in the `STOPPED` state,
    based on the `ExitStatus` with the stop tag configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This configuration ends the job with the `STOPPED` state if the exit status
    is `FAILED`, and we can rerun the job with the same set of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Through this chapter, we learned about controlling the flow of a batch job using
    exit codes and decision logic. We also learned how to share data between the steps
    in execution with the help of execution context and holder beans. We also learned
    about reusing the process by externalizing the flow and inherited job mechanisms.
    We finished this chapter with an understanding of terminating the batch job in
    different states and their importance. In the next chapter, we will learn in detail
    about the enterprise integration using Spring integration and RESTful job processing.
  prefs: []
  type: TYPE_NORMAL
