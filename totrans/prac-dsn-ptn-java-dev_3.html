<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-75" class="chapter-number"><a id="_idTextAnchor093"/>3</h1>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor094"/>Working with Creational Design Patterns</h1>
			<p>In recent decades, the IT community has experienced a dramatic shift from previously isolated systems to distributed or hybrid solutions. These approaches bring to light new possibilities for <span class="No-Break">software development.</span></p>
			<p>Distribution solutions may appear to meet the migration needs of legacy systems, but the reality may prove otherwise. The required refactoring can cause additional problems due to the division of responsibilities or refactoring of tightly coupled logic and business rules and many unknown, hidden logics that are discovered too late to <span class="No-Break">react to.</span></p>
			<p>In this chapter, we will explore creational design patterns. These patterns play a vital role in the software composition. They are very useful for achieving maintainability or readability of the code base. Creational design patterns attempt to follow all the previously noted principles or the <strong class="bold">don’t repeat yourself</strong> (<strong class="bold">DRY</strong>) approach. Let’s dive deeper into specific patterns in the <span class="No-Break">following order:</span></p>
			<ul>
				<li>Applying the factory <span class="No-Break">method pattern</span></li>
				<li>Instantiating additional factories in encapsulation with the abstract <span class="No-Break">factory pattern</span></li>
				<li>Creating a different configuration of object instances with the <span class="No-Break">builder pattern</span></li>
				<li>Avoiding a repeatedly complex configuration with the <span class="No-Break">prototype pattern</span></li>
				<li>Examining only one instance presence with the <span class="No-Break">singleton pattern</span></li>
				<li>Speeding up runtime with prepared objects by using the object <span class="No-Break">pool pattern</span></li>
				<li>Controlling instances on demand with the lazy <span class="No-Break">initialization pattern</span></li>
				<li>Reducing the object instances with the dependency <span class="No-Break">injection pattern</span></li>
			</ul>
			<p>By the end of this chapter, you will have built up a solid understanding of how to write maintainable code to create objects that can reside on the JVM’s heap <span class="No-Break">or stack.</span></p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor095"/>Technical requirements</h1>
			<p>You can find the code files for this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03"><span class="No-Break">https://github.com/PacktPublishing/Practical-Design-Patterns-for-Java-Developers/tree/main/Chapter03</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor096"/>It all starts with a class that becomes an object</h1>
			<p>In Java, every object<a id="_idIndexMarker201"/> must first be described by<a id="_idIndexMarker202"/> a class. Let us briefly introduce a common theoretical scenario of a software application. Such scenarios are often divided into the <span class="No-Break">following parts:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B18884_03_01.jpg" alt="Figure 3.1 – Common application data process from a big picture"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Common application data process from a big picture</p>
			<p>The incoming input data<a id="_idIndexMarker203"/> stream (that is, the information flow) has been accepted by an application. The application processes the input and creates the result. The result is stored and subjected to the required targeting by <span class="No-Break">a system.</span></p>
			<p>Such a system has the capability to satisfy several different processes under various conditions. The results are stored in several ways, such as a database or a file, or possibly embedded into an intended output stream, such as a web page, to display information to <span class="No-Break">the user.</span></p>
			<p>The system acts as a reservoir<a id="_idIndexMarker204"/> of the incoming information flow, processes and stores<a id="_idIndexMarker205"/> it in the database, and provides the result. Most of the time, everything is tightly coupled <span class="No-Break">and interconnected.</span></p>
			<p>Coupling has been happening on different levels, without the software designer noticing. The tight coherence was between classes, objects, or even packages. In many ways, it was possible to correct the application performance weaknesses with the more powerful hardware. The system’s evolution progressed more or less as a statistical observation of Moore’s law, which was published <span class="No-Break">in 1965.</span></p>
			<p>Moore’s law<a id="_idIndexMarker206"/> stated that each year, the number of components per integrated circuit doubles. The law was revised in 1975 to state that the number of components doubles every <em class="italic">two</em> years. Although the debate over the law’s validity may turn controversial, current trends (and the speed with which hardware upgrades are needed) show that the time for another review is coming. It may not be necessary worldwide to speed up the hardware upgrade (already so fast) because it may not have any effect on the speed of processing information. This observation addresses the feature requirements of a software application, focusing more on the quality and complexity of the <span class="No-Break">implemented algorithms.</span></p>
			<p>It may not be possible to constantly increase the rate at which an object is instantiated due to physical limits, as such information must be physically stored in memory. It means that in the coming decades, we can expect an increase in pressure to improve the efficiency of software and design. To gain clarity of the application logic, it needs to be crystal clear how the application works, and moreover, how the application feeds the key JVM areas, namely, the method stack and heap followed by the thread utilization through the stack areas (as shown previously in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">).</span></p>
			<p>Due to the current software applications’ trends focused on mapping, transforming, or managing a large amount of data, creational design patterns are worthwhile to study, understand, and learn how to deal with common scenarios. Although the time of the <strong class="bold">Gang of Four</strong> (<strong class="bold">GoF</strong>) book has passed, evolution is inevitable and the challenges remain. In many cases, with proper abstraction, the initial creational design patterns are applicable. Creating objects and class instances, and filling out the intended parts of the JVM, may drastically influence the computation and performance costs, as well as enforce business <span class="No-Break">logic clarity.</span></p>
			<p>In the next section, we discuss different possibilities for object creation. We will also consider the recently added Java syntactic features and possibilities, which should reduce the source code’s verbosity. Let us start with one of the most <span class="No-Break">common patterns.</span></p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor097"/>Creating objects based on input with the factory method pattern</h1>
			<p>The primary purpose<a id="_idIndexMarker207"/> of this pattern is to centralize<a id="_idIndexMarker208"/> the class’s instantiation of a specific type. The pattern leaves the decision to create the exact class type up to the client at runtime. The factory method design pattern was described in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor098"/>Motivation</h2>
			<p>The factory method pattern<a id="_idIndexMarker209"/> enforces the separation of code and its responsibility for creating new instances of the class, that is, such a method provides the expected result. The factory hides an application class hierarchy based on a generics abstraction and introduces a common interface. It transparently separates the instantiation logic from the rest of the code. By introducing the common interface, the client gains the freedom to decide on a particular class instance <span class="No-Break">at runtime.</span></p>
			<p>The pattern is often used in the early stages of an application because it is simple to refactor and provides a high level <span class="No-Break">of clarity.</span></p>
			<p>Although this can introduce a bit of complexity, the pattern is easy <span class="No-Break">to follow.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor099"/>Finding it in the JDK</h2>
			<p>The factory method pattern<a id="_idIndexMarker210"/> is often utilized in the Java Collection framework to construct the desired type. The framework implementations reside in the <strong class="source-inline">java.util</strong> package of the <strong class="source-inline">java.base</strong> module. This package contains different implementations of <strong class="source-inline">Set</strong>, <strong class="source-inline">List</strong>, and <strong class="source-inline">Map</strong>. Although the <strong class="source-inline">Map</strong> type is a valid member of the Java Collection framework, it does not inherit the <strong class="source-inline">Collection</strong> interface as it implements <strong class="source-inline">Map.Entry</strong> to store element tuples, keys, and values. Each implementation of <strong class="source-inline">Set</strong>, <strong class="source-inline">List</strong>, and <strong class="source-inline">Map</strong> provides overloaded <strong class="source-inline">of</strong> factory method to create <span class="No-Break">an inst<a id="_idTextAnchor100"/><a id="_idTextAnchor101"/>ance.</span></p>
			<p>The <strong class="source-inline">Collections</strong> class<a id="_idIndexMarker211"/> is a utility class. It contains several factory methods for creating specific collections, such as a list of individual items, a map, or a set. Another useful example of the factory method pattern usage is the <strong class="source-inline">Executors</strong> utility class, which can be found in the <strong class="source-inline">java.util.concurrent</strong> package of the <strong class="source-inline">java.base</strong> module. The <strong class="source-inline">Executors</strong> class defines static methods such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">newFixedThreadPool</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor102"/>Sample code</h2>
			<p>Let’s imagine a simple straightforward<a id="_idIndexMarker212"/> example that is easily applicable in the real world using a suitable abstraction. The goal is to design an application that tracks vehicle production. Most likely, the company offers different types of vehicles. Each vehicle can be represented<a id="_idIndexMarker213"/> by its own object. To draw the intent, we created a <strong class="bold">Unified Modeling Language</strong> (<strong class="bold">UML</strong>) class diagram to maintain clarity (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B18884_03_02.jpg" alt="Figure 3.2 – The vehicle production tracking example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The vehicle production tracking example</p>
			<p>The intended factory intends to produce two different types of vehicles, and the application fulfills the wishes on the fly (<span class="No-Break"><em class="italic">Example 3.1</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public s<a id="_idTextAnchor103"/>tatic<a id="_idTextAnchor104"/> void main(String[] args) {
    System.out.println("Pattern Factory Method: Vehicle
        Factory 2");
    var sportCar = VehicleFactory.produce("sport");
    System.out.println("sport-car:" + sportCar);
    sportCar.move();
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Factory Method: Vehicle Factory 2</strong>
<strong class="bold">sport-car:SportCar[type=porsche 911]</strong>
<strong class="bold">SportCar, type:'porsche 911', move</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.1 – VehicleFactory produces vehicles of the same “family” based on input arguments</p>
			<p>Instead of distributing the creation <a id="_idIndexMarker214"/>of such vehicle types over multiple places, we create a factory. The factory abstraction concentrates the whole vehicle composition process and exposes only one entry point that allows the client to create the desired vehicle type (as shown in <em class="italic">Example 3.2</em>). A factory only implements one static method, so it makes sense to keep its constructor private because factory instances <span class="No-Break">are undesirable:</span></p>
			<pre class="source-code">
final class VehicleFactory {
private Veh<a id="_idTextAnchor105"/>icleFactory(){}
    sta<a id="_idTextAnchor106"/>tic Vehicle pro<a id="_idTextAnchor107"/>duce(String type){
        return switch (type) {
            case "sport" -&gt; new SportCar("porsche 911");
            case "suv" -&gt; new SuvCar("skoda kodiaq");
            default -&gt; throw new
                IllegalArgumentException("""
            not implemented type:'%s'
      <a id="_idTextAnchor108"/>          """.formatted(type));
        };
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.2 – The VehicleFactory class exposes the static factory method to produce an instance of the object that implements a Vehicle interface</p>
			<p>The presented <strong class="source-inline">switch</strong> expression may use the pattern-matching<a id="_idIndexMarker215"/> approach to simplify code instead of the traditional <strong class="source-inline">switch-label-match</strong> construct. The application provides multiple implementations of the vehicle (<span class="No-Break"><em class="italic">Example 3.3</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
interface Vehicl<a id="_idTextAnchor109"/>e {
    void move();
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.3 – Each considered vehicle inherits the method abstractions through the Vehicle interface</p>
			<p>Due to another platform-syntactical improvement, the <strong class="source-inline">records</strong> type, it is possible to choose the level of the class encapsulation with the reflection of SOLID principles. It depends on how much the software architect intends to allow the vehicle instance to change its inner state. Let us first look at the standard Java class definition approach (<span class="No-Break"><em class="italic">Example 3.4</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class SuvCar implements Vehicle {
    private final String type;
    public S<a id="_idTextAnchor110"/>uvCar(String t){
        this.type = t;
    }
    @Override
    public void move() {...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.4 – SuvCar allows adding inner fields that could hold a mutable state</p>
			<p>The software architect<a id="_idIndexMarker216"/> has the chance to use the <strong class="source-inline">record</strong> class to create immutable instances of the desired vehicle along with the <strong class="source-inline">hashCode</strong> and <strong class="source-inline">equals</strong> methods followed by the <span class="No-Break"><strong class="source-inline">toString</strong></span><span class="No-Break"> implementation:</span></p>
			<pre class="source-code">
record SportCar(String type) implements Vehicle {
    @Override
  <a id="_idTextAnchor111"/>  public void move() {
        System.out.println("""
        SportCar, type:'%s', move""".formatted(type));
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.5 – SportCar is considered to be immutable</p>
			<p>The recently introduced <strong class="source-inline">record</strong> feature reduces the potential boilerplate code base while still allowing internal functionality to be implemented (as discussed in the <em class="italic">Records (Java SE 16, JEP-395)</em> section of the <span class="No-Break">previous chapter).</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor112"/>Conclusion</h2>
			<p>A factory method has some limitations. The most<a id="_idIndexMarker217"/> important one is that it can only be used for a specific family of objects. This means that all classes must maintain similar properties or common ground. The deviation from the base class of a class can introduce a dramatic strong coupling between the code and <span class="No-Break">the application.</span></p>
			<p>The point to consider may be related to the method itself, as it may be static or belong to the instances (as covered in the previous chapter under <em class="italic">The</em> <em class="italic">stack area</em> and <em class="italic">The heap area</em> sections, respectively). This depends on the software <span class="No-Break">designer’s decision.</span></p>
			<p>The object of the one family is created. Let us investigate how to deal with factory families that share a <span class="No-Break">common property.</span></p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor113"/>Creating objects from different families using the abstract factory pattern</h1>
			<p>This pattern introduces<a id="_idIndexMarker218"/> a factory abstraction without the requirement to define specific classes (or classes that should be instantiated). The client requests a proper factory that instantiates the object instead of attempting to create it. The abstract factory pattern was mentioned in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor114"/>Motivation</h2>
			<p>Modularizing applications<a id="_idIndexMarker219"/> can become a challenge. Software designers can avoid adding code to classes to preserve encapsulation. The motivation is to separate the factory logic from the application code so that it can supply the appropriate factory to produce the required objects. An abstract factory provides a standardized way to create an instance of the desired factory and deliver that instance to the client for use. The client uses the resulting factory to instantiate the object. Abstract factory provides an interface for creating both factories and objects without specifying their classes. The pattern implicitly supports SOLID principles and maintainability by isolating the logic of participants and insiders. The application is independent of how its products are created, composed, <span class="No-Break">and represented.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor115"/>Finding it in the JDK</h2>
			<p>The abstract factory method<a id="_idIndexMarker220"/> pattern can be found in the JDK in the <strong class="source-inline">java.xml </strong>package of the <strong class="source-inline">java.xml</strong> module. The abstract factory pattern can be found in the representation and implementation of the <strong class="source-inline">DocumentBuilderFactory</strong> abstract class and its static <strong class="source-inline">newInstance</strong> method. The factory uses a lookup service to find the required <span class="No-Break">builder implementation.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor116"/>Sample code</h2>
			<p>Consider that although vehicles<a id="_idIndexMarker221"/> share some common features, their production requires different kinds of processes (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B18884_03_03.jpg" alt="Figure 3.3 – Manufacturing different types of vehicles with the Abstract Factory pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Manufacturing different types of vehicles with the Abstract Factory pattern</p>
			<p>In such cases, we create multiple factories<a id="_idIndexMarker222"/> responsible for specific objects. Although these classes belong to different families, they do have properties in common. An important feature is that each factory can implement its own initialization sequence while sharing generic logic. The example requires the correct <strong class="source-inline">CarFactory</strong> instance to create a <strong class="source-inline">SlowCa</strong>r object (<span class="No-Break"><em class="italic">Example 3.6</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
<a id="_idTextAnchor117"/>publi<a id="_idTextAnchor118"/>c static void main(String[] args) {
    ...
    AbstractFactory carFactory =
         FactoryProvider.getFactory("car");
     Vehicle slowCar = carFactory.createVehicle("slow");
        slowCar.move();
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Abstract Factory: create factory to produce</strong>
<strong class="bold">    </strong><strong class="bold">vehicle...</strong>
<strong class="bold">slow car, move</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.6 – The client decides which Vehicle type is required</p>
			<p>A key element of the game<a id="_idIndexMarker223"/> is the factory provider; this distinguishes which factory is created based on incoming arguments (<em class="italic">Example 3.7</em>). The provider is implemented as a utility, so its class is final, and the constructor is private because instances are not required. Of course, the implementation may vary depending on <span class="No-Break">the requirements:</span></p>
			<pre class="source-code">
final class FactoryProvider {
private FactoryProvider(){}
    static AbstractFactor<a id="_idTextAnchor119"/>y getFactory(String type){
        return switch (type) {
            case "car" -&gt; new CarFactory();
            case "truck" -&gt; new TruckFactory();
            default -&gt; throw new IllegalArgumentException
                ("""         this is %s
                 """.formatted(type));
        };
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.7 – The FactoryProvider class defines how the particular factory of the object families is configured and instantiated</p>
			<p>Each factory from the group shares common logic or features to maintain the DRY approach in the <span class="No-Break">code base:</span></p>
			<pre class="source-code">
abstract class AbstractFactory {
    abstract Vehicle createVehicle(String type);
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.8 – The AbstractFactory class provides the common logic or methods that may require implementation by a specific factory</p>
			<p>These individual factories<a id="_idIndexMarker224"/> can implement additional logic to distinguish which product should be delivered, similar to the <strong class="source-inline">TruckFactory</strong> and <strong class="source-inline">CarFactory</strong> implementations in the following example (<span class="No-Break"><em class="italic">Example 3.9</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class TruckFactory extends AbstractFactory {
    @Override
    Vehicle createVehicle(String type) {
        return switch(type) {
            case "heavy" -&gt; new HeavyTruck();
            case "light" -&gt; new LightTruck();
            default -&gt; throw new IllegalArgumentException
                ("not implemented");
        };
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.9 – The TruckFactory class represents the specific AbstractFactory implementation</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor120"/>Conclusion</h2>
			<p>The abstract factory pattern<a id="_idIndexMarker225"/> provides consistency across products. Using a super factory can cause instability in the client runtime because the requested product can throw an exception or error due to incorrect implementation, as such information was not known on the fly. The abstract factory pattern, on the other hand, promotes testability. An abstract factory is free to represent the many other interfaces that came with its implementation. The pattern provides a common way to deal with products without depending on their implementation, which can improve the separation of concerns of application code. It can use interfaces or abstract classes. The client becomes independent of how objects are composed <span class="No-Break">and created.</span></p>
			<p>The benefit of encapsulating factories and code separation can be seen as a limitation. An abstract factory must be controlled by one or more parameters to properly define a dependency. To improve the code maintainability of the required factories, it may be useful to consider the previously discussed <em class="italic">sealed classes</em> enhancements (see the <em class="italic">Sealed classes (Java SE 17, JEP-409)</em> section in the previous chapter). Sealed classes can have a positive impact on code <span class="No-Break">base stability.</span></p>
			<p>Let us examine how to customize an object creation process<a id="_idTextAnchor121"/> in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor122"/>Instantiating complex objects with the builder pattern</h1>
			<p>The builder pattern<a id="_idIndexMarker226"/> helps separate the construction<a id="_idIndexMarker227"/> of a complex object from its code representation so that the same composition process can be reused to create different configurations of an object type. The builder design pattern was identified early and is the part of <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor123"/>Motivation</h2>
			<p>The main motivation<a id="_idIndexMarker228"/> behind the builder pattern is to construct complex instances without polluting the constructor. It helps to separate or even break down the creation process into specific steps. The composition of objects is transparent to the client and allows the creation of different configurations of the same type. The builder is represented by a separate class. It can help to transparently extend the constructor on demand. The pattern helps to encapsulate and enforce the clarity of the instantiation process with respect to the previously discussed SOLID<a id="_idIndexMarker229"/> <span class="No-Break">design principles.</span></p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor124"/>Finding it in the JDK</h2>
			<p>The builder pattern<a id="_idIndexMarker230"/> is a commonly used pattern inside the JDK. A great example is creating sequences of characters that represent a string. For example, <strong class="source-inline">StringBuilder</strong> and <strong class="source-inline">StringBuffer</strong> are located in the <strong class="source-inline">java.lang</strong> package of the <strong class="source-inline">java.base</strong> module, which is visible by default to every Java application. The string builder provides multiple overloaded connection methods that accept different types of input. Such input is concatenated with an already-created byte array. Another example can be found in the <strong class="source-inline">java.net.http</strong> package represented by the <strong class="source-inline">HttpRequest.Builder</strong> interface and its implementation or the <strong class="source-inline">Stream.Builder</strong> interface found in the <strong class="source-inline">java.util.stream</strong> package. As mentioned earlier, the builder pattern is very often used. Worth noting are <strong class="source-inline">Locale.Builder</strong> and <strong class="source-inline">Calendar.Builder</strong>, which use the setter methods to store values of the final product. Both can be found in the <strong class="source-inline">java.util</strong> package of the <span class="No-Break"><strong class="source-inline">java.based</strong></span><span class="No-Break"> module.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor125"/>Sample code</h2>
			<p>The builder, which is the key element<a id="_idIndexMarker231"/> of the pattern, holds required field values during a <strong class="source-inline">Vehicle</strong> instance creation, more precisely, references to the objects (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B18884_03_04.jpg" alt="Figure 3.4 – How to transparently make a new vehicle with the builder pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – How to transparently make a new vehicle with the builder pattern</p>
			<p>The overall responsibility<a id="_idIndexMarker232"/> of the builder pattern is to create vehicles (<span class="No-Break"><em class="italic">Exampl<a id="_idTextAnchor126"/>e 3.1<a id="_idTextAnchor127"/>0</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Builder pattern: building
        vehicles");
    var slowVehicle = VehicleBuilder.buildSlowVehicle();
    var fastVehicle = new FastVehicle.Builder()
                        .addCabin("cabin")
                        .addEngine("Engine")
                        .build();
    slowVehicle.parts();
    fastVehicle.parts();
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Builder pattern: building vehicles</strong>
<strong class="bold">SlowVehicle,engine: RecordPart[name=engine]</strong>
<strong class="bold">SlowVehicle,cabin: StandardPart{name='cabin'}</strong>
<strong class="bold">FastVehicle,engine: StandardPart{name='Engine'}</strong>
<strong class="bold">FastVehicle,cabin: RecordPart[name=cabin]</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.10 – The builder pattern can be implemented in several ways, depending on the requirements</p>
			<p>The builder pattern may be implemented using different<a id="_idIndexMarker233"/> approaches. One approach is to encapsulate and hide all builder logic and provide a product directly without expo<a id="_idTextAnchor128"/>sing <span class="No-Break">implementation details:</span></p>
			<pre class="source-code">
final class VehicleBuilder {
    static Vehicle buildSlowCar(){
        var engine = new RecordPart("engine");
        var cabin = new StandardPart("cabin");
        return new SlowCar(engine, cabin);
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.11 – The VehicleBuilder hides the logic in order to provide a particular instance</p>
			<p>Or the builder may become a part of the class for which the instance is intended to be created. In such a case, it is possible to decide which element should be added to the newly created <span class="No-Break">specific instance:</span></p>
			<pre class="source-code">
class FastCar implements Vehicle {
    final static class Builder {
        private Part engine;
        private<a id="_idTextAnchor129"/> Part cabin;
        Builder(){}
        Builder addEngine(String e){...}
        Builder addCabin(St<a id="_idTextAnchor130"/>ring c<a id="_idTextAnchor131"/>){...}
        FastCar build(){
            return new FastCar(engine, cabin);
        }
    }
    private final Part engine;
    private final Part cabin;
    ...
    @Override
    public void move() {...}
    @Override
    public void parts() {...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.12 – The FastVehicle.Builder is represented as a static class and needs to be instantiated, and provides the possibility of final result customization</p>
			<p>Both example approaches<a id="_idIndexMarker234"/> are implemented according to SOLID principles. The builder pattern is a nice example of abstraction, polymorphism, inheritance, and encapsulation (APIE) principles and is very open to refactoring, extending, or <span class="No-Break">validating properties.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor132"/>Conclusion</h2>
			<p>The builder pattern helps enforce <a id="_idIndexMarker235"/>the single responsibility principle by separating complex creation from business logic. It also improves code readability and the DRY principle, as the instantiation is extensible and user-understandable. The builder pattern is a commonly used design pattern because it reduces “code smell” and constructor pollution. It also improves testability. The code base helps avoid multiple constructors with different representations, some of which have never <span class="No-Break">been used.</span></p>
			<p>Another good point<a id="_idIndexMarker236"/> to consider while implementing a pattern is to use the JVM’s heap or stack – more specifically, to create a statically or dynamically allocated representation of the pattern. This decision is commonly answered by the software <span class="No-Break">designers themselves.</span></p>
			<p>It is not always necessary to reveal the construction process. The next section presents the simplicity of <span class="No-Break">object cloning.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor133"/>Cloning objects with the prototype pattern</h1>
			<p>The prototype pattern<a id="_idIndexMarker237"/> solves the difficulty of creating new instances<a id="_idIndexMarker238"/> of an object with complicated instantiation process, which is too cumbersome and undesirable because it can lead to unnecessary subclassing. The prototype is a very common design pattern and was described in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor134"/>Motivation</h2>
			<p>The prototype design pattern<a id="_idIndexMarker239"/> becomes very useful when heavy objects need to be created and factories are an unwanted approach. The newly created instance is cloned from its parent because the parent acts as a prototype. Instances are independent of each other and can be customized. Instance logic is not exposed to, and cannot be contributed to by, <span class="No-Break">the client.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor135"/>Finding it in the JDK</h2>
			<p>There are many examples<a id="_idIndexMarker240"/> of using prototype patterns across JDK packages. The Collection framework members implement the <strong class="source-inline">clone</strong> method required by the inherited <strong class="source-inline">Cloneable</strong> interface. For example, an <strong class="source-inline">ArrayList.clone()</strong> method execution creates a shallow <strong class="source-inline">List</strong> copy of entities, field by field. Another prototype implementation could be the <strong class="source-inline">Calendar</strong> class from the <strong class="source-inline">java.util</strong> package of the <strong class="source-inline">java.base</strong> module. A clone of the overridden method is also used for the <strong class="source-inline">Calendar</strong> implementation itself, as it helps to avoid unwanted modification of an already<a id="_idIndexMarker241"/> configured one. Usage can be found in the <strong class="source-inline">getActualMinimum</strong> and <span class="No-Break"><strong class="source-inline">getActualMaximum</strong></span><span class="No-Break"> methods.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor136"/>Sample code</h2>
			<p>When there<a id="_idIndexMarker242"/> are only a few vehicle models in production, there is no need to constantly establish new objects by factories or builders, which could actually lead to unwieldy code behavior as internal properties may change. Imagine the early stage of vehicle production where equality is required with each new iteration to track progress (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B18884_03_05.jpg" alt="Figure 3.5 – Creating new instances from the prototype"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Creating new instances from the prototype</p>
			<p>In such cases, it is easier to create an exact copy of an already designed vehicle as <span class="No-Break">its prototype:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    Vehicle fastCar1 = VehicleCache.getVehicle("fast-car");
    Vehicle fastCar2 = VehicleCache.getVehicle("fast-car");
    fastCar1.move();
    fastCar2.move();
    System.out.println("equals : " + (fastCar1
        .equals(fastCar2)));
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Prototype: vehicle prototype 1</strong>
<strong class="bold">fast car, move</strong>
<strong class="bold">fast car, move</strong>
<strong class="bold">equals : false</strong>
<strong class="bold">fastCar1:FastCar@659e0bfd</strong>
<strong class="bold">fastCar2:FastCar@2a139a55</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.13 – A new vehicle can be cloned from the available instances</p>
			<p>The instances<a id="_idIndexMarker243"/> can be recreated (respectively, cloned) on demand. The <strong class="source-inline">Vehicle</strong> abstract class provides a foundation for each new prototype implementation and provides <span class="No-Break">cloning details:</span></p>
			<pre class="source-code">
abstract class Vehicle implements Cloneable{
    protected final String type;
    Vehicle(String t){
        this.type = t;
    }
    abstract void move();
    @Override
    protected Object clone() {
        Object clone = null;
        try{
        clone = super.clone();
        } catch (CloneNotSupportedException e){...}
        return clone;
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.14 – The Vehicle abstract class must implement a Cloneable interface and introduce the clone method implementation</p>
			<p>Each vehicle implementation<a id="_idIndexMarker244"/> requires the extension of the parent <span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break"> class:</span></p>
			<pre class="source-code">
class SlowCar extends Vehicle {
    SlowCar(){
        super("slow car");
    }
    @Override
    void move() {...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.15 – The Vehicle interface-specific implementation provided by the SlowCar class and the move method implementation</p>
			<p>The prototype pattern introduces an internal cache that collects available <strong class="source-inline">Vehicle</strong> type prototypes (<em class="italic">Example 3.16</em>). The proposed implementation implements a static method to make the cache work as a tool. It makes sense for its constructor to <span class="No-Break">be private:</span></p>
			<pre class="source-code">
final class VehicleCache {
private static final Map&lt;String, Vehicle&gt; map =
    Map.of("fast-car", new FastCar(), "slow-car", new
        SlowCar());
private VehicleCache(){}
    static Vehicle ge<a id="_idTextAnchor137"/><a id="_idTextAnchor138"/>tVehicle(String type){
        Vehicle vehicle = map.get(type);
        if(vehicle == null) throw
        new     IllegalArgumentException("not allowed:" +
            type);
        return (Vehicle) vehicle.clone();
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.16 – VehicleCache holds the references to the already prepared prototypes that may be cloned</p>
			<p>The examples show<a id="_idIndexMarker245"/> that the client works each time with an identical copy of the base prototype. This copy may be customized based on <span class="No-Break">the requirements.</span></p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor139"/>Conclusion</h2>
			<p>The prototype pattern<a id="_idIndexMarker246"/> is useful for dynamic loading or to avoid increasing the complexity of the code base by introducing<a id="_idIndexMarker247"/> unnecessary abstractions, known as <strong class="bold">subclassing</strong>. This does not mean that clones do not need to implement the interface, but cloning can reduce exposure requirements or make the instantiation process too complicated. A prototype properly encapsulates the complicated logic of an instance that is not meant to be touched or modified. Software designers should be aware of the possibility that such a code base can easily change to legacy code. On the other hand, a pattern can defer and support iterative changes to the <span class="No-Break">code base.</span></p>
			<p>Multiple instances of an object are not always desirable and are sometimes even undesirable. In the next section, we’ll learn how to guarantee the presence of only one unique class instance<a id="_idIndexMarker248"/> <span class="No-Break">at runtime.</span></p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor140"/>Ensuring only one instance with the singleton pattern</h1>
			<p>A singleton object provides<a id="_idIndexMarker249"/> transparent and global access to its instance and ensures that only one instance is present. The singleton pattern was identified very early by industry requirements and is mentioned in the <span class="No-Break">GoF’s book.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor141"/>Motivation</h2>
			<p>A client or application<a id="_idIndexMarker250"/> wants to ensure that only one instance is present at runtime. An application may require multiple object instances that all use one unique resource. This fact introduces instability because any of these objects can access such a resource. A singleton guarantees only one instance that provides a global access point to all clients within the desired scope of the <span class="No-Break">running JVM.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor142"/>Finding it in the JDK</h2>
			<p>The best example <a id="_idIndexMarker251"/>of using a singleton is a running Java application, or more precisely, the runtime. It is found in the <strong class="source-inline">Runtime</strong> class and its method, <strong class="source-inline">getRuntime</strong>, resides in the <strong class="source-inline">java.lang</strong> package of the <strong class="source-inline">java.base</strong> module. The method returns an object associated with the current Java application. The runtime instance allows the client to add, for example, shutdown hooks to the <span class="No-Break">running application.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor143"/>Sample code</h2>
			<p>The following example suggests<a id="_idIndexMarker252"/> an application that only runs one car with its engine (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B18884_03_06.jpg" alt="Figure 3.6 – How the Singleton pattern represents an engine"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – How the Singleton pattern represents an engine</p>
			<p>In other words, this means<a id="_idIndexMarker253"/> that only one instance of a particular type of engine and vehicle must be present in <span class="No-Break">the JVM:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Singleton pattern: only one
        engine");
    var engine = OnlyEngine.getInstance();
    var vehicle = OnlyVehicle.getInstance();
    vehicle.move();
    System.out.println("""
        OnlyEngine:'%s', equals with vehicle:'%s'"""
        .formatted(engine, (vehicle.getEngine()
            .equals(engine))));
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Singleton: only one engine</strong>
<strong class="bold">OnlyVehicle, move</strong>
<strong class="bold">OnlyEngine:'OnlyEngine@7e9e5f8a', equals with</strong>
<strong class="bold">    vehicle:'true'</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.17 – One instance of OnlyEngine and OnlyCar is present at runtime</p>
			<p>There are a couple of different ways to ensure that the instance of the object will be unique. The implementation<a id="_idIndexMarker254"/> of the <strong class="source-inline">OnlyEngine</strong> class introduces the possible singleton implementation where its instance is lazily created on demand (<em class="italic">Example 3.18</em>). The <strong class="source-inline">OnlyEngine</strong> class implements the generic <strong class="source-inline">Engine</strong> interface. Its implementation provides a static <strong class="source-inline">getInstance</strong> method as a transparent <span class="No-Break">entry point:</span></p>
			<pre class="source-code">
interface Engine {}
class OnlyEngine implements Engine {
    private static OnlyEngine INSTANCE;
    static OnlyEngine getInstance(){
        if(INSTANCE == null){
            INSTANCE = new OnlyEngine();
        }
    return INSTANCE;
    }
    private OnlyEngine(){}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.18 – The OnlyEngine class checks the existence of its instance – lazy initiation</p>
			<p>Another way to implement a singleton is to create a <strong class="source-inline">static</strong> field that belongs to the class itself and expose a <strong class="source-inline">getInstance</strong> entry point to the potential client (<em class="italic">Example 3.19</em>). It is fair to note that, in such a case, the constructor <span class="No-Break">becomes private:</span></p>
			<pre class="source-code">
class OnlyVehicle {
    private static OnlyVehicle INSTANCE = new
        OnlyVehicle();
    static OnlyVehicle getInstance(){
        return INSTANCE;
}
    private OnlyVehicle(){
        this.engine = OnlyEngine<a id="_idTextAnchor144"/>.getInstance();
    }
    private final Engine engine;
    void move(){
       System.out.println("OnlyVehicle, move");
   }
    Engine getEngine(){
        return engine;
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.19 – The OnlyVehicle class provides its instance as a static field that belongs to the class</p>
			<p>The lazily initialized singleton pattern<a id="_idIndexMarker255"/> implementation may become a challenge in a multithreaded environment where the <strong class="source-inline">getInstance</strong> method must be synchronized to obtain a unique instance. One possibility is to create a singleton as an <strong class="source-inline">enum</strong> class (<span class="No-Break"><em class="italic">Example 3.20</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
enum OnlyEngineEnum implements Engine {
    INSTANCE;
    }
    ...
    private OnlyVehicle(){
    this.engine = OnlyEngineEnum.INSTANCE;
}
...</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.20 – The OnlyEngineEnum singleton enum class approach</p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor145"/>Conclusion</h2>
			<p>Singleton is a relatively trivial design<a id="_idIndexMarker256"/> pattern, although it can get complicated when used inside a multithreading environment due to its guarantee that there will be only one instance of the required object. The pattern can be challenged when enforcing the principle of single responsibility since the class is actually responsible for instantiating itself. On the other hand, the singleton pattern ensures that clients can access allocated resources globally, preventing accidental object initialization or destruction. The pattern should be used wisely as it creates tightly coupled code in the manner of required class instantiations, which can tend to cause testability issues. The pattern also suppresses other subclasses, making any extension <span class="No-Break">nearly impossible.</span></p>
			<p>Creating instances is not always a good approach. Let us examine how to do this <span class="No-Break">on demand.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor146"/>Improving performance with the object pool pattern</h1>
			<p>The object pool pattern<a id="_idIndexMarker257"/> instantiates ready-to-use objects<a id="_idIndexMarker258"/> and limits their initialization time. The required instances can be recreated on demand. A pool of objects can represent a base of conditions on which new instances could be created, or limit <span class="No-Break">their creation.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor147"/>Motivation</h2>
			<p>Instead of constantly creating<a id="_idIndexMarker259"/> new object instances over the code base, the object pool provides an encapsulated solution for managing application or client performance by serving an already initialized object ready for use. The pattern separates the build logic from the business code and helps manage the resource and performance aspects of the application. It may not only help with an object’s life cycle but also with validation when it is created <span class="No-Break">or destroyed.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor148"/>Finding it in the JDK</h2>
			<p>A nice example <a id="_idIndexMarker260"/>of the object pool pattern is the <strong class="source-inline">ExecutorService</strong> interface found in the <strong class="source-inline">java.util.concurrent</strong> package and the implementation provided by the <strong class="source-inline">Executors</strong> class of the <strong class="source-inline">util</strong> factory that handles the appropriate executor instances, for example, the <span class="No-Break"><strong class="source-inline">newScheduledThreadPool</strong></span><span class="No-Break"> method.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor149"/>Sample code</h2>
			<p>The current example introduces<a id="_idIndexMarker261"/> a scenario where the garage contains a specific number of cars that drivers may drive (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B18884_03_07.jpg" alt="Figure 3.7 – A garage following the Object Pool pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – A garage following the Object Pool pattern</p>
			<p>When a car is not available, the garage<a id="_idIndexMarker262"/> has implemented a logic to buy a new one<a id="_idTextAnchor150"/> in o<a id="_idTextAnchor151"/>rder to keep all <span class="No-Break">drivers busy:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    var garage = new PooledVehicleGarage();
    var vehicle1 = garage.driveVehicle();
    ...
    vehicle1.move();
    vehicle2.move();
    vehicle3.move();
    garage.returnVehicle(vehicle1);
    garage.returnVehicle(vehicle3);
    garage.printStatus();
    var vehicle4 = garage.driveVehicle();
    var vehicle5 = garage.driveVehicle();
    vehicle4.move();
    vehicle5.move();
    garage.printStatus();
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Object Pool: vehicle garage</strong>
<strong class="bold">PooledVehicle, move, vin=1</strong>
<strong class="bold">PooledVehicle, move, vin=2</strong>
<strong class="bold">PooledVehicle, move, vin=3</strong>
<strong class="bold">returned vehicle, vin:1</strong>
<strong class="bold">returned vehicle, vin:3</strong>
<strong class="bold">Garage Pool vehicles available=2[[3, 1]] inUse=1[[2]]</strong>
<strong class="bold">PooledVehicle, move, vin=3</strong>
<strong class="bold">PooledVehicle, move, vin=1</strong>
<strong class="bold">Garage Pool vehicles available=0[[]] inUse=3[[3, 2, 1]]</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.21 – The pooling vehicles in the garage instance help reduce the cost of the object</p>
			<p>A core element<a id="_idIndexMarker263"/> of the pattern is pool abstraction, as it contains all the required logic for managing entities. One option is to create an abstract garage pool class (<em class="italic">Example 3.22</em>) that contains all the synchronization mechanisms. These mechanisms are required to avoid potential code instability <span class="No-Break">and inconsistency:</span></p>
			<pre class="source-code">
abstract class AbstractGaragePool&lt;T extends Vehicle&gt; {
    private final Set&lt;T&gt; available = new HashSet&lt;&gt;();
    private final Set&lt;T&gt; inUse = new HashSet&lt;&gt;();
    protected abstract T buyVehicle();
    synchronized T driveVehicle() {
        if (available.isEmpty()) {
            available.add(buyVehicle());
        }
        var instance = available.iterator().next();
        available.remove(instance);
        inUse.add(instance);
        return instance;
    }
    synchronized void returnVehicle(T instance) {...}
    void printStatus() {...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.22 – An abstract garage pool provides all the required logic to properly administrate elements</p>
			<p>The garage pool limits the possible<a id="_idIndexMarker264"/> instance types. A class is bound by the <strong class="source-inline">Vehicle</strong> abstraction (<em class="italic">Example 3.23</em>). The interface provides the common functions used by the client. In the following example, the implementation of <strong class="source-inline">AbstractGaragePool</strong> represents <span class="No-Break">the client:</span></p>
			<pre class="source-code">
interface Vehicle {
    int getVin();
    void move();
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.23 – The Vehicle interfaces need to be implemented by PooledVehicle</p>
			<p>In addition to implementing<a id="_idIndexMarker265"/> functions, the <strong class="source-inline">PooledVehicle</strong> class provides a private counter (<em class="italic">Example 3.24</em>). A counter belongs to a class, so it is marked as <strong class="source-inline">static</strong> and <strong class="source-inline">final</strong>. The counter counts the number of instances purchased by the <span class="No-Break">garage pool:</span></p>
			<pre class="source-code">
class PooledVehicle implements Vehicle{
    private static final AtomicInteger COUNTER = new
        AtomicInteger();
    private final int vin;
    PooledVehicle() {
        this.vin = COUNTER.incrementAndGet();
    }
    @Override
    public int getVin(){...}
    @Override
    public void move(){..}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.24 – The PooledVehicle class implementation also holds the number of instances created</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor152"/>Conclusion</h2>
			<p>Improving client performance helps reduce<a id="_idIndexMarker266"/> the expensive object instantiation time (as we saw in <em class="italic">Example 3.21</em>). Object pools are also quite useful in cases where only short-lived objects are required, as they help reduce memory fragmentation by uncontrolled instances. It is worth touching upon the implementation of the internal cache pattern, as seen in the <span class="No-Break">garage example.</span></p>
			<p>Although the pattern is quite efficient, the right choice of collection structure can also have a dramatic impact on its performance. It can reduce search and <span class="No-Break">save time.</span></p>
			<p>Another positive outcome can be considered as the impact on the garbage collection process and memory compaction due to the analysis of active objects since there may be fewer objects <span class="No-Break">to analyze.</span></p>
			<p>It is not always necessary to store everything in memory for later reuse. Let us examine how to postpone the object initialization process and not <span class="No-Break">polluting memory.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor153"/>Initiating objects on demand with the lazy initialization pattern</h1>
			<p>This pattern’s purpose<a id="_idIndexMarker267"/> is to defer an instance<a id="_idIndexMarker268"/> of the desired class instance until the client actually <span class="No-Break">requests it.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor154"/>Motivation</h2>
			<p>Although operational memory<a id="_idIndexMarker269"/> has grown drastically over the years, we learned in the previous chapter that the JVM allocated a defined, specific size of memory reserved for the heap. When the heap is exhausted and the JVM is unable to allocate any new object, it causes an out of memory error. Lazy handling can have quite a positive impact on this heap pollution. It is sometimes also called asynchronous loading<a id="_idIndexMarker270"/> because of the delayed instance. The pattern has quite a nice use in a web application where the web page is generated on demand rather than during the application initialization process. It also has its place in an application, where the cost of operating the relevant object <span class="No-Break">is high.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor155"/>Finding it in the JDK</h2>
			<p>Lazy initialization can be demonstrated<a id="_idIndexMarker271"/> using the example of dynamic loading by <strong class="source-inline">ClassLoader</strong> of classes that were not linked at runtime when the application was started. Classes can be loaded eagerly or deferred by the class policy. Certain classes, such as <strong class="source-inline">ClassNotFoundException</strong>, are loaded implicitly through the <strong class="source-inline">java.base</strong> module. They support the class implementation located in the <strong class="source-inline">java.lang</strong> package and its <strong class="source-inline">forName</strong> method. The implementation of the method is provided by an internal API. A lazy initiated class may be the reason the application requires a warm-up time. For example, <strong class="source-inline">Enum</strong> classes are a special type of static final classes that act as constants and are <span class="No-Break">loaded eagerly.</span></p>
			<p><strong class="source-inline">-&gt;</strong> refers to loading steps into the class loader and filling out the appropriate method area, as we learned in the <span class="No-Break">previous chapter.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor156"/>Sample code</h2>
			<p>The basic idea of the lazy initialization<a id="_idIndexMarker272"/> example is that the created vehicle is initialized on demand or, when already created, a reference is provided to the client (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.8</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B18884_03_08.jpg" alt="Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – How to create a vehicle on demand with the lazy initiation pattern</p>
			<p>Such vehicles are present only if they are really required by the client. In such cases, specific vehicle instances<a id="_idIndexMarker273"/> are created. When a vehicle is already present inside the provider context, then such an instance <span class="No-Break">is reused:</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Lazy Initialization: lazy
        vehicles");
    var vehicleProvider = new VehicleProvider();
    var truck1 = vehicleProvider.getVehicleByType("truck");
    vehicleProvider.printStatus();
    truck1.move();
    var car1 = vehicleProvider.getVehicleByType("car");
    var car2 = vehicleProvider.getVehicleByType("car");
    vehicleProvider.printStatus();
    car1.move();
    car2.move();
    System.out.println("ca1==car2: " + (car1.equals
       (car2)));
}</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Lazy Initialization: lazy vehicles</strong>
<strong class="bold">lazy truck created</strong>
<strong class="bold">status, truck:LazyVehicle[type=truck]</strong>
<strong class="bold">status, car:null</strong>
<strong class="bold">LazyVehicle, move, type:truck</strong>
<strong class="bold">lazy car created</strong>
<strong class="bold">status, truck:LazyVehicle[type=truck]</strong>
<strong class="bold">status, car:LazyVehicle[type=car]</strong>
<strong class="bold">LazyVehicle, move, type:car</strong>
<strong class="bold">LazyVehicle, move, type:car</strong>
<strong class="bold">ca1==car2: true</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.25 – An example implementation of the pooled vehicle</p>
			<p>The implementation<a id="_idIndexMarker274"/> of the <strong class="source-inline">VehicleProvider</strong> class considers the fields private. Those fields hold the references to the desired vehicle if required. The provider encapsulates the decision and instantiation logic. One of the possible implementations may use the <strong class="source-inline">switch-label-match</strong> construct (<em class="italic">Example 3.26</em>), <strong class="source-inline">switch</strong> expressions, and so on. It’s good to point out that in this example, the <strong class="source-inline">VehicleProvider</strong> class requires an instance in the package scope, so its constructor is a <strong class="source-inline">private</strong> package and is not exposed to <span class="No-Break">other packages:</span></p>
			<pre class="source-code">
final class VehicleProvider {
    private Vehicle truck;
    private Vehicle car;
    VehicleProvider() {}
    Vehicle getVehicleByType(String type){
        switch(type){
        case "car":
            ...
            return car;
        case "truck":
            if(truck == null){
                System.out.println("lazy truck created");
                truck = new LazyVehicle(type);
            }
            return truck;
        default:
            ...
    }
    void printStatus(){...}
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.26 – VehicleProvider hides the possible entity instantiation logic from the client</p>
			<p>In order to enforce the extendibility<a id="_idIndexMarker275"/> to the possible lazily initiated object, each entity implements the <span class="No-Break"><strong class="source-inline">Vehicle</strong></span><span class="No-Break"> abstraction:</span></p>
			<pre class="source-code">
interface Vehicle {
    void move();
}
record LazyVehicle(String type) implements Vehicle{
    @Override
    public void move() {
        System.out.println("LazyVehicle, move, type:" +
            type);
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.27 – Vehicle abstraction and possible LazyVehicle implementation using record to enforce immutability</p>
			<p>Such an approach enforces<a id="_idIndexMarker276"/> continual vehicle evolution without complicated changes to the <span class="No-Break">provider logic.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor157"/>Conclusion</h2>
			<p>The lazy initialization<a id="_idIndexMarker277"/> design pattern can help keep application memory small. Improper use, on the other hand, can cause unwanted delays, as objects can be too complex to create and take a significant amount of time <span class="No-Break">to run.</span></p>
			<p>The next section shows how to inject the logic into the client, represented by the newly created <span class="No-Break">vehicle instance.</span></p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor158"/>Reducing class dependencies with the dependency injection pattern</h1>
			<p>This pattern separates<a id="_idIndexMarker278"/> the initialization of the class (that <em class="italic">acts</em> as a service) from<a id="_idIndexMarker279"/> the client (that <em class="italic">uses</em> <span class="No-Break">the service).</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor159"/>Motivation</h2>
			<p>The dependency injection<a id="_idIndexMarker280"/> pattern is widely used where there is a need to separate the implementation of a particular object (service) from the target object (client) that uses its exposed services, methods, and the like. Services are available when a client instance is to be created. The pattern allows you to eliminate any hardcoded dependencies. These services are instantiated outside of the client creation process. This means that the two are loosely connected, and SOLID principles can be enforced. There are three ways that dependency injection can <span class="No-Break">be implemented:</span></p>
			<ul>
				<li><strong class="bold">Constructor dependency injection</strong>: Intended services are made available to the client<a id="_idIndexMarker281"/> through the initialization of <span class="No-Break">the constructor.</span></li>
				<li><strong class="bold">Injection method</strong>: The client exposes the method<a id="_idIndexMarker282"/> normally through an interface. Such a method supplies dependencies to the client. The supplier object uses a method to inject the service(s) into <span class="No-Break">the client.</span></li>
				<li><strong class="bold">Field dependency injection</strong>: This type of injection is done using<a id="_idIndexMarker283"/> a setup-like method. These setters refer to the respective field held by the client. The client can also expose the field as a <span class="No-Break"><strong class="source-inline">public</strong></span><span class="No-Break"> property.</span></li>
			</ul>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor160"/>Finding it in the JDK</h2>
			<p>A good example<a id="_idIndexMarker284"/> of using the dependency injection pattern is the <strong class="source-inline">ServiceLoader</strong> utility class. It can be found in the <strong class="source-inline">java.base</strong> module and its <strong class="source-inline">java.util</strong> package. The <strong class="source-inline">ServiceLoader</strong> instance tries to find services during the application startup at runtime. A service is considered to be represented by a well-specified interface that is implemented by the relevant service provider or providers. The application code is able to distinguish the desired provider at runtime. It is good to note that <strong class="source-inline">ServiceLoader</strong> works with the classic <strong class="source-inline">classpath</strong> configuration or can be used seamlessly with the Java Platform Module System (discussed in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Discovering the Java Platform for </em><span class="No-Break"><em class="italic">Design Patterns</em></span><span class="No-Break">).</span></p>
			<p>In the past, dependency injection was part of the Java EE scope, not the classic JDK. This means that the feature was available on the Java platform. Due to the evolution of the JDK, the dependency<a id="_idIndexMarker285"/> injection features were moved to the <strong class="bold">Jakarta Dependency Injection</strong> project. A newly created project follows its own release and development cycle without dependency on the JDK. Nevertheless, the dependency injection is well known due to the usage of <strong class="source-inline">@Inject</strong>, <strong class="source-inline">@Named</strong>, <strong class="source-inline">@Scope</strong>, or <strong class="source-inline">@Qualifier</strong> annotations. These annotations allow the class to be turned into a managed object at runtime, where the implementation of the desired provider can <span class="No-Break">be distinguished.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor161"/>Sample code</h2>
			<p>An example<a id="_idIndexMarker286"/> shows a simplified dependency injection pattern in order to receive a general experience. It is a very trivial implementation; in fact, it draws a picture of how the previously mentioned API works behind the scenes. Let’s imagine a scenario where the intended vehicle instance requires an engine (<span class="No-Break"><em class="italic">Figure 3</em></span><span class="No-Break"><em class="italic">.9</em></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B18884_03_09.jpg" alt="Figure 3.9 – Injecting engine as a service to the vehicle instance"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Injecting engine as a service to the vehicle instance</p>
			<p>Specific engine construction<a id="_idIndexMarker287"/> log<a id="_idTextAnchor162"/>ic is<a id="_idTextAnchor163"/> detached from vehicle-related code (<span class="No-Break"><em class="italic">Example 3.28</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
1 public static void main(String[] args) {
2     System.out.println("Pattern Dependency Injection:
          vehicle and engine");
3     Engi<a id="_idTextAnchor164"/><a id="_idTextAnchor165"/>neServiceProvider.addEngine(new FastEngine
          ("sport"));
4     Engine e<a id="_idTextAnchor166"/><a id="_idTextAnchor167"/>ngine =
        EngineServiceProvider.getEngineByType("sport");
5     Vehicle vehicle = new SportVehicle(engine);
6     vehicle.move();
7 }</pre>
			<p>Here is <span class="No-Break">the output:</span></p>
			<pre class="source-code">
<strong class="bold">Pattern Dependency Injection: vehicle and engine</strong>
<strong class="bold">FastEngine, started</strong>
<strong class="bold">FastEngine, run</strong>
<strong class="bold">SportCar, move</strong></pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.28 – Creating an instance of FastEngine separately from the vehicle and then adding the engine to the constructed SportVehicle</p>
			<p>The <strong class="source-inline">FastEngine</strong> instance is used when it is fully<a id="_idIndexMarker288"/> ready (initiated, verified, and so on). The desired type of vehicle can be constructed independently without any dependence on engine logic. An engine instance is provided to <strong class="source-inline">SportVehicle</strong> using <strong class="source-inline">EngineServiceProvider</strong> (<span class="No-Break"><em class="italic">Example 3.29</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
final class EngineServiceProvider {
    private static final Map&lt;String, Engine&gt; ENGINES = new
        HashMap&lt;&gt;();
    ...
    static Engine getEngineByType(String t){
        return ENGINES.values().stream()
                .filter(e -&gt; e.type().equals(t))
                .findFirst().orElseThrow
                    (IllegalArgumentException::new);
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.29 – EngineServiceProvider registers instantiated reusable services</p>
			<p>The <strong class="source-inline">SportVehicle</strong> class implements the <strong class="source-inline">Vehicle</strong> interface (<em class="italic">Example 3.30</em>) in order to reflect the open-close approach mentioned as part of the SOLID <span class="No-Break">design principles:</span></p>
			<pre class="source-code">
interface Vehicle {
    void move();
}
class SportVehicle implements Vehicle{
    private final Engine engine;
    SportVehicle(Engine e) {...}
    @Override
    public void move() {
        if(!engine.isStarted()){
            engine.start();
    }
        engine.run();
        System.out.println("SportCar, move");
    }
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.30 – SportVehicle implements the Vehicle interface together with additional internal logic for the provided Engine instance</p>
			<p>It is important<a id="_idIndexMarker289"/> to note that although a specific <strong class="source-inline">Engine</strong> type (<em class="italic">Example 3.31</em>) instance (<strong class="source-inline">FastEngine</strong>) is created somewhere else (<em class="italic">Example 3.28</em>, line <strong class="source-inline">3</strong>), its presence is required when the <strong class="source-inline">SportVehicle</strong> object is instantiated (<em class="italic">Example 3.28</em>, <span class="No-Break">line </span><span class="No-Break"><strong class="source-inline">5</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
interface Engine {
    void start();
    boolean isStarted();
    void run();
    String type();
}
class FastEngine implements Engine{
    private final String type;
    private boolean started;
    FastEngine(String type) {
        this.type = type;
    }
    ...
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.31 – Engine interfaces implemented by the FastEngine class and provided by EngineServiceProvider</p>
			<p>The key player object<a id="_idIndexMarker290"/> in the described example is <strong class="source-inline">EngineServiceProvider</strong>. It provides a reference to already created desired <strong class="source-inline">Engine</strong> instances and distributes them across the business code. This means that any client that needs to work on <strong class="source-inline">Engine</strong>, similar to the <strong class="source-inline">SportVehicle</strong> instance, will get access to the correct instance through the link exposed <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">EngineServiceProvider</strong></span><span class="No-Break">.</span></p>
			<p>The presented trivial example can be easily turned into another using the <strong class="source-inline">ServiceProvider</strong> utility class instance. The changes are very minimal (<span class="No-Break"><em class="italic">Example 3.32</em></span><span class="No-Break">):</span></p>
			<pre class="source-code">
public static void main(String[] args) {
    System.out.println("Pattern Dependency Injection
       Service Loader: vehicle and engine");
    ServiceLoader&lt;Engine&gt; engineService =
        ServiceLoader.load(Engine.class);
    Engine engine = engineService.findFirst()
        .orElseThrow();
    Vehicle vehicle = new SportVehicle(engine);
    vehicle.move();
}</pre>
			<p class="SC---Link" lang="en-US" xml:lang="en-US">Example 3.32 – ServiceLoader provides an available implementation of the Engine interface used to instantiate the SportVehicle type</p>
			<p>In the standard classpath utilization, the Java platform requires service providers to be registered in the <strong class="source-inline">META-INF</strong> folder and the <strong class="source-inline">services</strong> subfolder. The filename is made up of the package and the service interface name, and the file contains the available <span class="No-Break">service providers.</span></p>
			<p>The Java Platform Module System<a id="_idIndexMarker291"/> simplifies the configuration steps. The relevant modules provide (and make available service implementations to) the target modules, as we touched on in <a href="B18884_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">, Discovering the Java Platform for </em><span class="No-Break"><em class="italic">Design Patterns</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor168"/>Conclusion</h2>
			<p>The dependency injection pattern<a id="_idIndexMarker292"/> ensures that the client does not know about the instantiation of the used service. The client has access to the service through the common interfaces. It makes the code base better testable. It also simplifies the code base testability. Dependency injection is a widely used pattern by various frameworks, such as Spring and Quarkus. Quarkus uses the Jakarta Dependency Injection specification. The dependency injection pattern conforms to the SOLID and APIE object-oriented programming principles as it provides the abstraction of interfaces. The code does not depend on the implementation but communicates with the services through the interfaces. The dependency injection pattern enforces a DRY principle as it is not required to continually initiate <span class="No-Break">a service.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor169"/>Summary</h1>
			<p>Creational design patterns play a very important role in software application design. They help in transparently centralizing object instantiation logic with respect to basic object-oriented principles. The examples showed that each pattern may have multiple implementations. This is because the implementation decision may depend on other software architecture factors. Those factors take into account JVM heap and stack usage, application runtime, or business <span class="No-Break">logic encapsulation.</span></p>
			<p>Using design patterns implicitly for authoring promotes a DRY approach, which has a positive impact on application development and reduces code base pollution. The application becomes testable and software architects have a framework to confirm the presence of expected objects inside the JVM. This becomes particularly important when a logic issue is identified, which could be an exception or unexpected results. A well-created code base helps to get into the root cause quite fast, maybe even without the necessity <span class="No-Break">to debug.</span></p>
			<p>In this chapter, we have learned how to create an object of a particular family using the transparent factory method pattern. The abstract factory pattern showed the encapsulated way of creating different factories types. Not all the required information is always present at one moment, and the builder pattern introduced a way to deal with such a challenge of composing complex objects. The prototype pattern showed the approach of not exposing the instance logic to the client, where the singleton pattern ensured the presence of a single instance at runtime. The object pool design pattern revealed how to improve memory usage at runtime, while the lazy instantiation pattern showed how to defer an object until it is needed. The dependency injection pattern demonstrated the reusability of instances when creating <span class="No-Break">new objects.</span></p>
			<p>Creational design patterns not only bring clarity to the creation of new instances but, in many cases, they can also contribute to the decision about the correct structure of the code (a code structure that reflects the required business logic). The last three mentioned patterns solve not only the issue of creating objects but also their reusability for efficient memory use. The examples we covered showed us how creational patterns can be implemented and we learned about the differences and purposes of each <span class="No-Break">of them.</span></p>
			<p>The next chapter will discuss the structure design pattern. This pattern will help us organize our code based on the most common scenarios. Let’s <span class="No-Break">move on.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor170"/>Questions</h1>
			<ol>
				<li>What challenges do the creational design <span class="No-Break">patterns solve?</span></li>
				<li>Which patterns may be helpful to reduce object <span class="No-Break">initiation costs?</span></li>
				<li>What is the key reason to utilize the singleton <span class="No-Break">design pattern?</span></li>
				<li>Which pattern helps to reduce <span class="No-Break">constructor pollution?</span></li>
				<li>How do you hide complex instantiation logic from <span class="No-Break">the client?</span></li>
				<li>Is it possible to reduce the instantiation application <span class="No-Break">memory footprint?</span></li>
				<li>What design pattern is useful for creating objects of a <span class="No-Break">specific family?</span></li>
			</ol>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor171"/>Further reading</h1>
			<ul>
				<li><em class="italic">Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, <span class="No-Break">Addison-Wesley, 1995</span></li>
				<li><em class="italic">Design Principles and Design Patterns</em> by Robert C. Martin, Object <span class="No-Break">Mentor, 2000</span></li>
				<li><em class="italic">Cramming more components onto integrated circuits</em> by Gordon E. Moore, Electronics <span class="No-Break">Magazine, 1965-04-19</span></li>
				<li><em class="italic">Oracle Tutorials: </em><span class="No-Break"><em class="italic">Generics</em></span><span class="No-Break">: </span><a href="https://docs.oracle.com/javase/tutorial/java/generics/index.html"><span class="No-Break">https://docs.oracle.com/javase/tutorial/java/generics/index.html</span></a></li>
				<li><em class="italic">Quarkus </em><span class="No-Break"><em class="italic">Framework</em></span><span class="No-Break">: </span><a href="https://quarkus.io/"><span class="No-Break">https://quarkus.io/</span></a></li>
				<li><em class="italic">Spring </em><span class="No-Break"><em class="italic">Framework</em></span><span class="No-Break">: </span><a href="https://spring.io/"><span class="No-Break">https://spring.io/</span></a></li>
				<li><em class="italic">Jakarta Dependency </em><span class="No-Break"><em class="italic">Injection</em></span><span class="No-Break">: </span><a href="https://jakarta.ee/specifications/dependency-injection/"><span class="No-Break">https://jakarta.ee/specifications/dependency-injection/</span></a></li>
				<li><em class="italic">Clean Code</em> by Robert C. Martin, Pearson Education, <span class="No-Break">Inc, 2009</span></li>
				<li><em class="italic">Effective Java – Third Edition</em> by Joshua Bloch, <span class="No-Break">Addison-Wesley, 2018</span></li>
			</ul>
		</div>
	</body></html>