<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Building Routes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Building Routes</h1></div></div></div><p>In this chapter, we will be covering the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Defining the services supported by an application</li><li class="listitem" style="list-style-type: disc">The flow of requests received</li><li class="listitem" style="list-style-type: disc">Configuring routes</li><li class="listitem" style="list-style-type: disc">Handling assets</li></ul></div><div class="section" title="Introduction to Play routes"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Introduction to Play routes</h1></div></div></div><p>All the supported routes are <a id="id84" class="indexterm"/>specified within a single file: <code class="literal">routes</code> (by default). This makes it all the easier to figure out which one would be ideal.</p><p>The <code class="literal">routes</code> file is compiled and if any errors occur, the compilation fails.</p><p>However, the <code class="literal">routes</code> file is not a Scala object. So how does the compiler know what to do with the <code class="literal">routes</code> file? To find this out, let's perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Let's create a project that displays a <span class="emphasis"><em>Hello, World!</em></span> page. Now, define the <code class="literal">index.scala.html</code> home page as follows:<div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Home&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello, World!&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div></li><li class="listitem">We will use this in our controller in this way:<div class="informalexample"><pre class="programlisting">package controllers

import play.api.mvc._
object AppController extends Controller {

  def index = Action {
    Ok(views.html.index())
  }

}</pre></div></li><li class="listitem">All we need to view our page is an entry in the <code class="literal">routes</code> file:<div class="informalexample"><pre class="programlisting"># Home page
GET           /                    controllers.AppController.index</pre></div></li><li class="listitem">Now compile the project. You will notice that a <code class="literal">routes_routing.scala</code> file is now available <a id="id85" class="indexterm"/>in the <code class="literal">HelloWorld/target/scala-2.10/src_managed/main</code> directory. The contents of the file will be similar to the following code snippet:<div class="informalexample"><pre class="programlisting">import play.core._
import play.core.Router._
import play.core.j._

import play.api.mvc._


import Router.queryString

object Routes extends Router.Routes {

private var _prefix = "/"

def setPrefix(prefix: String) {
  _prefix = prefix
  List[(String,Routes)]().foreach {
    case (p, router) =&gt; router.setPrefix(prefix + (if(prefix.endsWith("/")) "" else "/") + p)
  }
}

def prefix = _prefix

lazy val defaultPrefix = { if(Routes.prefix.endsWith("/")) "" else "/" }


// @LINE:5
private[this] lazy val controllers_AppController_index0 = Route("GET", PathPattern(List(StaticPart(Routes.prefix))))
        
def documentation = List(("""GET""", prefix,"""controllers.AppController.index""")).foldLeft(List.empty[(String,String,String)]) { (s,e) =&gt; e.asInstanceOf[Any] match {
  case r @ (_,_,_) =&gt; s :+ r.asInstanceOf[(String,String,String)]
  case l =&gt; s ++ l.asInstanceOf[List[(String,String,String)]]
}}
      

def routes:PartialFunction[RequestHeader,Handler] = {

// @LINE:5
case controllers_AppController_index0(params) =&gt; {
   call {
        invokeHandler(controllers.AppController.index, HandlerDef(this, "controllers.AppController", "index", Nil,"GET", """ Routes
 This file defines all application routes (Higher priority routes first)
 ~~~~
 Home page""", Routes.prefix + """"""))
   }
}
        
}

}</pre></div></li></ol></div><p>So, Play generates Scala code from the <code class="literal">routes</code> file. A <code class="literal">routes</code> partial function is created using the routes file. The <code class="literal">call</code> method takes a function that returns a handler and defines the parameters to be passed to it. It is defined to handle 0 to 21 parameters.</p><p>The <code class="literal">invokeHandler</code> <a id="id86" class="indexterm"/>method is defined as follows:</p><div class="informalexample"><pre class="programlisting">def invokeHandler[T](call: =&gt; T, handler: HandlerDef)(implicit d: HandlerInvoker[T]): Handler = {
      d.call(call, handler) match {
        case javaAction: play.core.j.JavaAction =&gt; new play.core.j.JavaAction with RequestTaggingHandler {
          def invocation = javaAction.invocation
          val annotations = javaAction.annotations
          val parser = javaAction.annotations.parser
          def tagRequest(rh: RequestHeader) = doTagRequest(rh, handler)
        }
        case action: EssentialAction =&gt; new EssentialAction with RequestTaggingHandler {
          def apply(rh: RequestHeader) = action(rh)
          def tagRequest(rh: RequestHeader) = doTagRequest(rh, handler)
        }
        case ws @ WebSocket(f) =&gt; {
          WebSocket[ws.FRAMES_TYPE](rh =&gt; f(doTagRequest(rh, handler)))(ws.frameFormatter)
        }
        case handler =&gt; handler
      }</pre></div><p>The result from <code class="literal">d.call</code>(call and handler) is matched to the predefined <code class="literal">play.core.j.JavaAction</code>, <code class="literal">EssentialAction</code>, and <code class="literal">WebSocket</code> types (all of which extend the handler trait) and their result is returned.</p><p>
<code class="literal">HandlerDef</code> is a class, which <a id="id87" class="indexterm"/>is defined as follows:</p><div class="informalexample"><pre class="programlisting">case class HandlerDef(ref: AnyRef, routerPackage: String, controller: String, method: String, parameterTypes: Seq[Class[_]], verb: String, comments: String, path: String)</pre></div><div class="section" title="Automatic generation of routes_routing.scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec14"/>Automatic generation of routes_routing.scala</h2></div></div></div><p>Let's have a <a id="id88" class="indexterm"/>look at how the <code class="literal">routes_routing.scala</code> file is generated.</p><p>Play utilizes the <a id="id89" class="indexterm"/>features provided by <span class="strong"><strong>Simple Build Tool</strong></span> (<span class="strong"><strong>SBT</strong></span>) to add a source generation task. A source generation task should generate sources in a subdirectory of <code class="literal">sourceManaged</code> and return a sequence of the files generated.</p><p>The SBT documentation can be found at <a class="ulink" href="http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html">http://www.scala-sbt.org/0.13.2/docs/Howto/generatefiles.html</a>.</p><p>The usage can be seen in <code class="literal">PlaySettings.scala</code>, as follows:</p><div class="informalexample"><pre class="programlisting">sourceGenerators in Compile &lt;+= (state, confDirectory, sourceManaged in Compile, routesImport, generateReverseRouter, generateRefReverseRouter, namespaceReverseRouter) map {     
  (s, cd, sm, ri, grr, grrr, nrr) =&gt; RouteFiles(s, Seq(cd), sm, ri, grr, grrr, nrr)    
},</pre></div><p>
<code class="literal">RouteFiles</code> is defined in the <code class="literal">PlaySourceGenerators</code> trait, which handles the Scala code generation for routes and views. Yes, even views are transformed to Scala code. For example, an <code class="literal">index.template.scala</code> file is available for the <code class="literal">HelloWorld</code> project at <code class="literal">HelloWorld/target/scala-2.10/src_managed/main/views/html</code>.</p><p>The definition for <code class="literal">RouteFiles</code> calls the <code class="literal">RoutesCompiler.compile</code> method and then returns the file paths <a id="id90" class="indexterm"/>where the source will be generated. The <code class="literal">compile</code> method parses the file using <code class="literal">RouteFileParser</code> and then generates the Scala code using the <code class="literal">generateRouter</code> method.</p></div></div></div>
<div class="section" title="Reverse routing"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Reverse routing</h1></div></div></div><p>Play provides a <a id="id91" class="indexterm"/>feature to make HTTP calls using Scala methods. For every route defined, an equivalent Scala method is generated in the <code class="literal">routes_ReverseRouting.scala</code> file. This is very convenient when making a request from within our Scala code, for example, within views such as the following:</p><div class="informalexample"><pre class="programlisting"> @(tasks: List[Task], taskForm: Form[String])

@import helper._

@main("Task Tracker") {

    &lt;h2&gt;Task Tracker&lt;/h2&gt;

    &lt;div&gt;
    @form(routes.TaskController.newTask) {

        @taskForm.globalError.map { error =&gt;
            &lt;p class="error"&gt;
                @error.message
            &lt;/p&gt;
        }
        &lt;form&gt;
            &lt;input type="text" name="taskName" placeholder="Add a new Task" required&gt;

            &lt;input type="submit" value="Add"&gt;
        &lt;/form&gt;
    }
    &lt;/div&gt;
    &lt;div&gt;
        &lt;ul&gt;
        @tasks.map { task =&gt;
            &lt;li&gt;
                @form(routes.TaskController.deleteTask(task.id)) {
                  @task.name &lt;input type="submit" value="Remove"&gt;
                }
            &lt;/li&gt;
        }
        &lt;/ul&gt;
    &lt;/div&gt;

}</pre></div><p>The content of <a id="id92" class="indexterm"/>the <code class="literal">routes_reverseRouting.scala</code> file would be similar to the following:</p><div class="informalexample"><pre class="programlisting">import Routes.{prefix =&gt; _prefix, defaultPrefix =&gt; _defaultPrefix}
import play.core._
import play.core.Router._
import play.core.j._

import play.api.mvc._


import Router.queryString


// @LINE:5
package controllers {

// @LINE:5
class ReverseAppController {
    

// @LINE:5
def index(): Call = {
   Call("GET", _prefix)
}
                                                
    
}
                          
}
                   


// @LINE:5
package controllers.javascript {

// @LINE:5
class ReverseAppController {
    

// @LINE:5
def index : JavascriptReverseRoute = JavascriptReverseRoute(
  "controllers.AppController.index",
   """
      function() {
      return _wA({method:"GET", url:"""" + _prefix + """"})
      }
   """
)
                        
    
}
              
}
        


// @LINE:5
package controllers.ref {


// @LINE:5
class ReverseAppController {
    

// @LINE:5
def index(): play.api.mvc.HandlerRef[_] = new play.api.mvc.HandlerRef(
    controllers.AppController.index(), HandlerDef(this, "controllers.AppController", "index", Seq(), "GET", """ Routes
 This file defines all application routes (Higher priority routes first)
 ~~~~
 Home page""", _prefix + """""")
)
                      
    
}
                          
}</pre></div><p>The reverse routes return a call. A call describes an HTTP request and can be used to create links or fill and <a id="id93" class="indexterm"/>redirect data. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">case class Call(method: String, url: String) extends play.mvc.Call {

    //Transform this call to an absolute URL.
    def absoluteURL(secure: Boolean = false)(implicit request: RequestHeader) = {
      "http" + (if (secure) "s" else "") + "://" + request.host + this.url
    }

    // Transform this call to an WebSocket URL.
    def webSocketURL(secure: Boolean = false)(implicit request: RequestHeader) = {
      "ws" + (if (secure) "s" else "") + "://" + request.host + this.url
    }

    override def toString = url

  }</pre></div><div class="section" title="JavaScript reverse routing"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec15"/>JavaScript reverse routing</h2></div></div></div><p>In <code class="literal">routes_reverseRouting.scala</code>, there is also a method that returns <code class="literal">JavascriptReverseRoute</code>. We could use this in our JavaScript code when we wish to send a request. Prior to <a id="id94" class="indexterm"/>this, however, we would need to <a id="id95" class="indexterm"/>define a JavaScript router. We could do this by defining an action and then adding a route for it, as shown in this example:</p><div class="informalexample"><pre class="programlisting">def javascriptRoutes = Action { implicit request =&gt;
    Ok(
      Routes.javascriptRouter("jsRouter")(
        routes.javascript.index
      )
    ).as("text/javascript")
  }</pre></div><p>Then, we could include it in the routes file in this way:</p><div class="informalexample"><pre class="programlisting">GET /javascriptRoutes  controllers.AppController.javascriptRoutes</pre></div><p>Next, we could refer to it in our views as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="@routes.AppController.javascriptRoutes"&gt;&lt;/script&gt;</pre></div><p>Once this is done, in our JavaScript scripts we could use the router to send requests to the server, as follows:</p><div class="informalexample"><pre class="programlisting">jsRouter.controllers.AppController.index.ajax({
  success: function(data) {
    console.log("redirect successful");
  } ,
  error:function(e){
    console.log("something terrible happened" + e);
  }
});</pre></div></div></div>
<div class="section" title="Assets"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Assets</h1></div></div></div><p>Any web application <a id="id96" class="indexterm"/>would require a style sheet or some other resources such as images, scripts, and so in. In a non-Play application, we would refer to these by figuring out the relative location of the file. For example, suppose that our application has a <code class="literal">webapp</code> folder with <code class="literal">index.html</code>, where we need to add a <code class="literal">homePage.css</code> stylesheet, which is located at <code class="literal">webapp/styles</code>. Now, the reference in <code class="literal">index.html</code> would be something similar to the following:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" href="styles/homePage.css" /&gt;</pre></div><p>Such relative paths can get very confusing and, at times, difficult to manage. In a Play application, the resources are placed in the public directory and can be accessed using a request. It is suggested that you split the public directory into three subdirectories for images, CSS style sheets, and JavaScript files for consistency, as shown in the following figure:</p><div class="mediaobject"><img src="graphics/3803OS_03_01.jpg" alt="Assets"/></div><p>In addition to this, Play provides an asset controller by default to support requests, which can access resources (assets). In most Play applications, a route for assets is also available in the routes file, as shown here:</p><div class="informalexample"><pre class="programlisting">GET           /assets/*file        controllers.Assets.at(path="/public", file)</pre></div><p>This route gives access to resources, such as style sheets, scripts, and so on. A file is expected to be the remainder of the path after <code class="literal">/public</code>, which is required to access it. For example, to get the <code class="literal">homePage.css</code> style sheet, we would send a GET request to <code class="literal">/assets/stylesheets/homePage.css</code>. The path preceded by <code class="literal">/assets/</code> is considered to be the path for the file.</p><p>In views, we would need to use a <code class="literal">routes</code> helper. So, if we wish to add a style sheet in one of our views, we would refer to it as follows:</p><div class="informalexample"><pre class="programlisting">&lt;link rel="stylesheet" href="@routes.Assets.at("stylesheets/homePage.css")" /&gt;</pre></div><p>Similarly, we will refer to a JavaScript script as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="@routes.Assets.at("javascripts/slider.js")" type="text/javascript"&gt;&lt;/script&gt;</pre></div><p>It is also possible to specify a <a id="id97" class="indexterm"/>separate path for images, style sheets, or scripts so that the request paths are shorter, as shown here:</p><div class="informalexample"><pre class="programlisting">GET           /styles/*file        controllers.Assets.at(path="/public/styles", file)

GET           /images/*file        controllers.Assets.at(path="/public/images", file)</pre></div><p>The Action <code class="literal">at</code> is defined as follows:</p><div class="informalexample"><pre class="programlisting">  def at(path: String, file: String, aggressiveCaching: Boolean = false): Action[AnyContent] = Action.async {
    implicit request =&gt;

      import Implicits.trampoline
      val pendingResult: Future[Result] = for {
        Some(name) &lt;- Future.successful(resourceNameAt(path, file))
        (assetInfo, gzipRequested) &lt;- assetInfoForRequest(request, name)
      } yield {
        val stream = assetInfo.url(gzipRequested).openStream()
        Try(stream.available -&gt; Enumerator.fromStream(stream)(Implicits.defaultExecutionContext)).map {
          case (length, resourceData) =&gt;
            maybeNotModified(request, assetInfo, aggressiveCaching).getOrElse {
              cacheableResult(
                assetInfo,
                aggressiveCaching,
                result(file, length, assetInfo.mimeType, resourceData, gzipRequested, assetInfo.gzipUrl.isDefined)
              )
            }
        }.getOrElse(NotFound)
      }

      pendingResult.recover {
        case e: InvalidUriEncodingException =&gt;
          Logger.debug(s"Invalid URI encoding for $file at $path", e)
          BadRequest
        case e: Throwable =&gt;
          Logger.debug(s"Unforseen error for $file at $path", e)
          NotFound
      }
  }</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>If a <span class="emphasis"><em>gzipped</em></span> version of a file is available, the asset controller will serve that instead. A gzipped version refers to the version of the file that was obtained by compressing the file using gzip. It adds the <code class="literal">.gz</code> extension to the filename.</p></div></div><p>As well as the resource, <code class="literal">AssetController</code> adds the <code class="literal">etag</code> header.</p><p>The <code class="literal">etag</code> acronym is used <a id="id98" class="indexterm"/>for an entity tag. This is a unique identifier for the resource being requested, and is generally a hash of the resource or of its last modified timestamp.</p><div class="section" title="Client-side libraries"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec16"/>Client-side libraries</h2></div></div></div><p>Views in most <a id="id99" class="indexterm"/>applications rely on third-party libraries. In Play, we <a id="id100" class="indexterm"/>could define dependencies located in such libraries using <span class="strong"><strong>webJars</strong></span> and <a id="id101" class="indexterm"/>
<span class="strong"><strong>npm</strong></span>.</p><p>Play extracts the assets from the WebJar dependencies as well as from <code class="literal">npm</code> packages into the <code class="literal">lib</code> directory within the public assets. We can refer to these when defining an asset with a dependency on the files present there. For example, if our view depends on <code class="literal">d3.js</code>, then we use the following:</p><div class="informalexample"><pre class="programlisting">&lt;script src="@routes.Assets.at("lib/d3/d3.v3.min.js")" charset="utf-8"&gt;&lt;/script&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>WebJars are JARs of libraries used for the client-side development of a web application.</p><p>
<code class="literal">npm</code> is an acronym for node packaged modules. It is the package manager for Node.js. It allows developers to install registered modules through the command line.</p></div></div><p>To use a WebJar, we would need to define our project's dependency on it just as in any other module, as shown here:</p><div class="informalexample"><pre class="programlisting">libraryDependencies+="org.webjars" % "d3js" % "3.4.6-1"  </pre></div><p>To include npm packages, we <a id="id102" class="indexterm"/>would need to place the <code class="literal">package.json</code> file in a project root. The <code class="literal">package.json</code> file would be similar to this:</p><div class="informalexample"><pre class="programlisting">{
  "name": "myApp",
  "version": "1.0.0",
  "dependencies": {
  },
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-concat": "~0.1.3",
    "grunt-contrib-cssmin": "~0.5.0",
    "grunt-contrib-clean": "~0.4.0",
    "grunt-contrib-less": "~0.7.0"
  },
  "engines": {
    "node": "&gt;=0.8.0"
  }
}</pre></div></div></div>
<div class="section" title="Configuring route definitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Configuring route definitions</h1></div></div></div><p>Play supports both <a id="id103" class="indexterm"/>static and dynamic request paths. If a request path cannot be matched to any of the defined routes, an <code class="literal">Action not found</code> error is thrown at runtime, which is rendered using the <code class="literal">devNotFound.scala.html</code> default template.</p><div class="section" title="Dynamic paths"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Dynamic paths</h2></div></div></div><p>Dynamic paths are <a id="id104" class="indexterm"/>those that can be used for multiple requests and they <a id="id105" class="indexterm"/>may or may not result in a similar response. For example, the default assets path is a path used to serve resources:</p><div class="informalexample"><pre class="programlisting">GET           /assets/*file        controllers.Assets.at(path="/public", file)</pre></div><p>The <code class="literal">*</code> symbol indicates that anything following <code class="literal">/assets/</code> until a space is found is the value of the <code class="literal">file</code> variable.</p><p>Let's look at another way to make the path dynamic when we need to add one or more variables. For example, to get a user's details by <code class="literal">userId</code> we use the following code:</p><div class="informalexample"><pre class="programlisting">GET           /api/user/:userId    controllers.UserController.getUser(userId)</pre></div><p>By default, all the variables that occur in a path are of the <code class="literal">String</code> type. If a conversion is required, the type should be mentioned explicitly. So, if the <code class="literal">getUser</code> method takes a long parameter, we would just need to specify it in this way:</p><div class="informalexample"><pre class="programlisting">GET           /api/user/:userId    controllers.UserController.getUser(userId:Long)</pre></div><p>Using the"<code class="literal">:</code>" prefix for <code class="literal">userId</code> means that the <code class="literal">userId</code> variable is exactly one URI part. The assets path uses <span class="emphasis"><em>any suffix indicator</em></span> as the relative file path, which is required to access any file.</p><p>It is not necessary that a path should end with a variable; for example, <code class="literal">/api/user/:userId/album</code> can be used as a valid path to fetch all the albums stored by a user.</p><p>Multiple variables can <a id="id106" class="indexterm"/>also be used in the same path. Supposing we wished to <a id="id107" class="indexterm"/>fetch a specific album, we could use <code class="literal">/api/user/:userId/album/:albumId</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>The maximum number of variables we can specify in a path is 21, since this is the maximum that the <code class="literal">call</code> method used in <code class="literal">routes_routing.scala</code> is defined to handle. Also, the request path becomes complicated and ends up with too many variables. In general, keeping the number of such parameters to less than five is a good practice.</p></div></div><p>Play also supports using regular expressions to match the variables. For example, assume that we want to restrict a string variable to consisting of only letters, such as a region code; in this case, our route can be defined as follows:</p><div class="informalexample"><pre class="programlisting">GET           /api/region/$regionId&lt;[a-zA-Z]{2}&gt;/user       controllers.UserController.getUserByRegion(regionId)</pre></div><p>Notice that when we specify a regular expression for the variable in the route, it is prefixed with a <code class="literal">$</code> symbol instead of the <code class="literal">:</code> symbol while defining the route.</p><p>The preceding route definition restricts the request by a regular expression. For example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">/api/region/IN/user</code> is a valid path</li><li class="listitem" style="list-style-type: disc"><code class="literal">/api/region/CABT/user</code> and <code class="literal">/api/region/99/user</code> are invalid</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note14"/>Note</h3><p>The order of preference to a route is defined by its position in the <code class="literal">routes</code> file. The router returns the first matching route for a given path. If the same request type and route are mapped for two different actions, the compiler does not throw an error or warning. Some IDEs indicate when duplicate route definitions occur, but it is completely the developer's responsibility to ensure that such cases do not occur.</p></div></div><p>This table summarizes the <a id="id108" class="indexterm"/>different ways of defining a dynamic path:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Sr.no.</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th><th style="text-align: left" valign="bottom">
<p>Special characters</p>
</th><th style="text-align: left" valign="bottom">
<p>Example usage(s)</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>URI path separator is part of the variable</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">*</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/assets/*file</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>Single or multiple variables</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">:</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/api/user/:userId</code>
</p>
<p>
<code class="literal">/api/user/:userId/album</code>
</p>
<p>
<code class="literal">/api/user/:userId/album/:albumId</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>Regular expression pattern for variables</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">$</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">/api/region/$regionId&lt;[a-zA-Z]{2}&gt;/user</code>
</p>
</td></tr></tbody></table></div></div><div class="section" title="Static paths"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Static paths</h2></div></div></div><p>Static request paths are fixed and constant. They cannot support arguments in the request path. All the data required for such requests should be sent through request parameters or request bodies. For example, the actions used for signing in or signing out are given as follows:</p><div class="informalexample"><pre class="programlisting">GET           /login               controllers.Application.login</pre></div><p>So does Play search for <a id="id109" class="indexterm"/>specific characters to identify the kind of path?</p><p>Yes, the special <a id="id110" class="indexterm"/>characters are used by <code class="literal">RoutesFileParser</code> to recognize whether a path is static or dynamic. The paths are defined as follows:</p><div class="informalexample"><pre class="programlisting">    def singleComponentPathPart: Parser[DynamicPart] = (":" ~&gt; identifier) ^^ {
      case name =&gt; DynamicPart(name, """[^/]+""", encode = true)
    }

    def multipleComponentsPathPart: Parser[DynamicPart] = ("*" ~&gt; identifier) ^^ {
      case name =&gt; DynamicPart(name, """.+""", encode = false)
    }

    def regexComponentPathPart: Parser[DynamicPart] = "$" ~&gt; identifier ~ ("&lt;" ~&gt; (not("&gt;") ~&gt; """[^\s]""".r +) &lt;~ "&gt;" ^^ { case c =&gt; c.mkString }) ^^ {
      case name ~ regex =&gt; DynamicPart(name, regex, encode = false)
    }

    def staticPathPart: Parser[StaticPart] = (not(":") ~&gt; not("*") ~&gt; not("$") ~&gt; """[^\s]""".r +) ^^ {
      case chars =&gt; StaticPart(chars.mkString)
    }</pre></div><p>In the methods used to identify a path, the <code class="literal">~&gt;</code>, <code class="literal">not</code>, and <code class="literal">^^</code> methods are from <code class="literal">scala.util.parsing.combinator.{Parser, RegexParsers}</code>. <code class="literal">DynamicPart</code> and <code class="literal">StaticPart</code> are <a id="id111" class="indexterm"/>defined with the intention of capturing the parts of a URL, so that <a id="id112" class="indexterm"/>it's simpler to pass values to a corresponding action. They are defined as follows:</p><div class="informalexample"><pre class="programlisting">trait PathPart

case class DynamicPart(name: String, constraint: String, encode: Boolean) extends PathPart with Positional {
  override def toString = """DynamicPart("""" + name + "\", \"\"\"" + constraint + "\"\"\"," + encode + ")" //"
}

case class StaticPart(value: String) extends PathPart {
  override def toString = """StaticPart("""" + value + """")"""
}

case class PathPattern(parts: Seq[PathPart]) {
  def has(key: String): Boolean = parts.exists {
    case DynamicPart(name, _, _) if name == key =&gt; true
    case _ =&gt; false
  }

  override def toString = parts.map {
    case DynamicPart(name, constraint, encode) =&gt; "$" + name + "&lt;" + constraint + "&gt;"
    case StaticPart(path) =&gt; path
  }.mkString

}</pre></div></div></div>
<div class="section" title="Configuring request parameters"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Configuring request parameters</h1></div></div></div><p>Many applications <a id="id113" class="indexterm"/>use additional parameters along with RESTful HTTP GET requests to obtain required information. Play supports configuring these request parameters as well.</p><p>Supposing we have a request to search users by their name, we could define this as follows:</p><div class="informalexample"><pre class="programlisting">GET           /api/search/user    controllers.UserController.search(name)</pre></div><p>Therefore, we wouldn't need to get the parameters from the request in the action. We could let Play handle acquiring the parameters from the request and passing them to the action.</p><p>What do we do when the request parameters are optional? For example, what happens if we allow a search of users by their name where <code class="literal">lastName</code> is optional.</p><p>We can specify <code class="literal">Option</code> as the type for this request parameter. Therefore, the route definition would be similar to the following:</p><div class="informalexample"><pre class="programlisting">GET           /api/search/user    controllers.UserController.search(firstName:String, lastName:Option[String])</pre></div><p>In addition to this, we can also specify the default value, if any, for request parameters. Suppose we had a limit <a id="id114" class="indexterm"/>parameter for the search request as well. In this case, if we wish to set the default value as <code class="literal">10</code>, the route definition would be as follows:</p><div class="informalexample"><pre class="programlisting">GET           /api/search/user    controllers.UserController.search(firstName:String, lastName:Option[String], limit:Int ?= 10)</pre></div></div>
<div class="section" title="Troubleshooting"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Troubleshooting</h1></div></div></div><p>The application works as expected but when the code is added to one or more base packages, the reverse routing doesn't work.</p><p>The routes are <a id="id115" class="indexterm"/>compiled, so when you make changes to the controllers, the project should be recompiled. In this case, run the <code class="literal">clean</code> command and then compile the project. It is better to see whether the generated routing files reflect the changes made. If not, delete the target directory and compile the project.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Summary</h1></div></div></div><p>In this chapter, we saw what an essential role routing plays in a Play application. As well as this, we saw the various default methods that Play provides to simplify the process of routing, in the form of assets, reverse routing, and so on.</p><p>In the next chapter, we will see how to define views in a Play application and also uncover how it works. As well as from the templating mechanism, the internals of building and using forms and internationalization will be covered in detail.</p></div></body></html>