<html><head></head><body><div id="sbo-rt-content"><div class="chapter" title="Chapter 6. Integrating Spring Batch"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Integrating Spring Batch</h1></div></div></div><p>In the previous chapter, we learned about controlling the flow of a batch job using exit code and decision logic, sharing the data between the steps in execution, and reusing the process by externalizing the flow and inherited job mechanisms. We also learned how to terminate the batch job in different states and their importance. An organization performs its operations with the help of a number of tools and maintains its data and applications across locations. It is important to integrate the data across these applications with a decent mechanism to synchronize the systems.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Enterprise Integration</li><li class="listitem" style="list-style-type: disc">Spring Integration</li><li class="listitem" style="list-style-type: disc">RESTful job processing</li></ul></div><div class="section" title="Enterprise Integration"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Enterprise Integration</h1></div></div></div><p>So far we have seen batch <a id="id350" class="indexterm"/>jobs configured with different steps; reading data from different sources, performing operations, and writing data to different destinations. In real time, organizations use different applications to perform their operations. The application used to maintain the employee information and process their payroll might not be the same as the one that takes care of logistics and sales. In such scenarios, it is important to integrate these applications seamlessly to process the whole data together at any particular point and perform an operation on the system.</p><p>The following <a id="id351" class="indexterm"/>figure shows how an <span class="strong"><strong>Enterprise Resource Planning</strong></span> (<span class="strong"><strong>ERP</strong></span>) system integrates different modules, accesses the information from its systems, and maintains it as an entity.</p><div class="mediaobject"><img src="Images/3372OS_06_01.jpg" alt="Enterprise Integration" width="600" height="365"/></div><p>The following are the different ways to integrate enterprise applications:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>File-based data transfer</strong></span>: Applications exchange data based on flat files; the source system <a id="id352" class="indexterm"/>writes data onto a flat file and exports the file to the destination system. The destination system reads data from a flat file and imports into its destination database.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Resource sharing</strong></span>: Applications <a id="id353" class="indexterm"/>share common resources, such as a filesystem or a database, to perform their operations. Virtually, they act as individual systems; however, they populate/write data onto a common system.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Service invocation</strong></span>: Applications <a id="id354" class="indexterm"/>expose their operations as services (web services in recent days) to let other applications call them. One can transfer/receive data from such services, depending on the way they are designed.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Messaging services</strong></span>: Applications <a id="id355" class="indexterm"/>use a common messaging server; one application can send a message and the other receives it.</li></ul></div></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Spring Integration"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Spring Integration</h1></div></div></div><p>Spring project defines <a id="id356" class="indexterm"/>Spring Integration as an extension of the Spring programming model for Enterprise Integration. Spring Integration is developed to support lightweight messaging within Spring-based applications and supports system integration with external systems through declarative adapters. These adapters provide an abstraction of Spring's support for remoting, messaging, and scheduling.</p><div class="mediaobject"><img src="Images/3372OS_06_02.jpg" alt="Spring Integration" width="600" height="112"/></div><p>While Spring Batch operates on a file- or database-based integration system, Spring Integration provides the application's message-based integration. Adding this messaging feature to the Spring Batch application automates its operations and also separates the key operational concerns. Let's understand how we can make Spring Integration configuration be a part of the integrated enterprise application. The following are some of the key operations that can be performed with message integration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Triggering a batch job to execute</li><li class="listitem" style="list-style-type: disc">Triggering a message with the job completion/fail status</li><li class="listitem" style="list-style-type: disc">Asynchronous processor's operation</li><li class="listitem" style="list-style-type: disc">Externalization</li></ul></div><p>The following is the Spring XML application context file with Spring Batch integration enabled:</p><div class="informalexample"><pre class="programlisting">&lt;beans 



xmlns:batch-integrate="http://www.springframework.org/schema/batch-integration"
xsi:schemaLocation="http://www.springframework.org/schema/batch-integration
http://www.springframework.org/schema/batch-integration/spring-batch-integration.xsd
http://www.springframework.org/schema/batch
http://www.springframework.org/schema/batch/spring-batch.xsd
http://www.springframework.org/schema/beans
http://www.springframework.org/schema/beans/spring-beans.xsd
http://www.springframework.org/schema/integration
http://www.springframework.org/schema/integration/spring-integration.xsd"&gt;
...
&lt;/beans&gt;</pre></div><div class="section" title="Triggering a batch job to execute"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>Triggering a batch job to execute</h2></div></div></div><p>So far we have <a id="id357" class="indexterm"/>been triggering jobs through command line, programmatically from applications. However, certain applications have to transfer data <a id="id358" class="indexterm"/>using remote file transfer (FTP/SFTP) and launch jobs to import data into the application. Spring Integration provides different adapters to easily make launch configurations. <code class="literal">JobLaunchingMessageHandler</code> of Spring Integration is an easy-to-implement, event-driven execution on <code class="literal">JobLauncher</code>. Spring Integration provides <code class="literal">JobLaunchRequest</code> as the input for the <code class="literal">JobLaunchingMessageHandler</code>.</p><div class="mediaobject"><img src="Images/3372OS_06_03.jpg" alt="Triggering a batch job to execute" width="600" height="299"/></div><p>The following is the listing for <code class="literal">JobLaunchRequest</code> transformation from a file:</p><div class="informalexample"><pre class="programlisting">package com.java.batchJob;
import org.springframework.batch.core.Job;
import org.springframework.batch.core.JobParametersBuilder;
import org.springframework.batch.integration.launch.JobLaunchRequest;
import org.springframework.integration.annotation.Transformer;
import org.springframework.messaging.Message;
import java.io.File;

public class FileMessageToJobRequest {
private Job job;
private String fileParameterName;
public void setFileParameterName(String fileParameterName) {
this.fileParameterName = fileParameterName;
}
public void setJob(Job job) {
this.job = job;
}
@Transformer
Public JobLaunchRequest toRequest(Message&lt;File&gt; message) {
JobParametersBuilder jobParametersBuilder = 
new JobParametersBuilder();
jobParametersBuilder.addString(fileParameterName, message.getPayload().getAbsolutePath());
return new JobLaunchRequest(job, jobParametersBuilder.toJobParameters());
}
}</pre></div><p>The job execution status is returned with the instance of <code class="literal">JobExecution</code>. The <code class="literal">JobExecution</code> ID helps the user track the status of the job execution through <code class="literal">JobRepository</code>.</p><p>The following <a id="id359" class="indexterm"/>configuration is for taking the file input (CSV file) through <a id="id360" class="indexterm"/>an adapter, transforming it to <code class="literal">JobRequest</code> through the transformer <code class="literal">FileMessageToJobRequest</code>, launching the job through <code class="literal">JobLaunchingGateway</code>, and logging the output of <code class="literal">JobExecution</code>.</p><div class="informalexample"><pre class="programlisting">&lt;integrate:channel id="inputFileRepository"/&gt;
&lt;integrate:channel id="jobRequestChannel"/&gt;
&lt;integrate:channel id="jobTriggeringStatusChannel"/&gt;
&lt;integrate-file:inbound-channel-adapter id="inputFile"
channel="inputFileRepository"
directory="file:/tmp/batchfiles/"
filename-pattern="*.csv"&gt;
&lt;integrate:poller fixed-rate="1000"/&gt;
&lt;/integrate-file:inbound-channel-adapter&gt;
&lt;integrate:transformer input-channel="inputFileRepository"
output-channel="jobRequestChannel"&gt;
&lt;bean class="batchJob.FileMessageToJobRequest"&gt;
&lt;property name="job" ref="employeeJob"/&gt;
&lt;property name="fileParameterName" value="input.file.name"/&gt;
&lt;/bean&gt;
&lt;/integrate:transformer&gt;
&lt;batch-integrate:job-launching-gateway request-channel="jobRequestChannel"
reply-channel="jobTriggeringStatusChannel"/&gt;
&lt;integrate:logging-channel-adapter channel="jobTriggeringStatusChannel"/&gt;</pre></div><p>The item reader can be configured to pick the input filename as job parameter from the following configuration:</p><div class="informalexample"><pre class="programlisting">&lt;bean id="itemReader" class="org.springframework.batch.item.file.FlatFileItemReader"
scope="step"&gt;
&lt;property name="resource" value="file://#{jobParameters['input.file.name']}"/&gt;
...
&lt;/bean&gt;</pre></div><p>Spring Integration has <a id="id361" class="indexterm"/>message access from the Spring application <a id="id362" class="indexterm"/>context. Hence, the batch job can as well be triggered with the request accessed from the application context, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">ApplicationContext ctx = new ClassPathXmlApplicationContext("spring-integration-job.xml");
EmployeeJobLaunchRequest employeeJobLaunchRequest = new EmployeeJobLaunchRequest("employeeJob", Collections.singletonMap("key", "value"));
Message&lt;EmployeeJobLaunchRequest&gt; msg = MessageBuilder.withPayload( employeeJobLaunchRequest).build();
MessageChannel jobRequestsChannel = ctx.getBean("inputFileRepository", MessageChannel.class);
jobRequestsChannel.send(msg);</pre></div><p>In the preceding code, <code class="literal">EmployeeJobLaunchRequest</code> is the user-defined <code class="literal">JobLaunchRequest</code> that is wrapped with the Spring Integration Message. The Spring Integration class to generate a message is <code class="literal">MessageBuilder</code>. With this request, we can pass the input request details, such as file repository, and launch the job. Spring Integration can be learned in detail from <span class="emphasis"><em>Spring Integration Essentials</em></span>, <span class="emphasis"><em>Chandan Pandey</em></span>, <span class="emphasis"><em>Packt Publishing</em></span>.</p></div></div></div>



  
<div id="sbo-rt-content"><div class="section" title="RESTful job processing"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>RESTful job processing</h1></div></div></div><p>A web service is a <a id="id363" class="indexterm"/>method of communication between two electronic devices over a network. It is a software function provided at a network address over the Web, with the service always on as in the concept of utility computing.</p><p>REST is an architectural style consisting of a coordinated set of architectural constraints, applied to components, connectors, and data elements, within a distributed hypermedia system. The REST architectural style is also applied to the development of web services. With REST-compliant web services, the primary purpose of the service is to manipulate XML representations of web resources using a uniform set of stateless operations.</p><p>Spring Batch supports the job launching and processing using REST web services with the methods <code class="literal">Put</code>/<code class="literal">Post</code>. The following is a sample listing with Spring CXF (an open source services framework):</p><div class="informalexample"><pre class="programlisting">@Autowired
private JobLauncher jobLauncher;

@Autowired
private Job job;

public boolean startJob() throws Exception {
try {
final JobParameters jobParameters = new JobParametersBuilder(). addLong("time", System.nanoTime()).toJobParameters();
final JobExecution execution = jobLauncher.run(job, jobParameters);
final ExitStatus status = execution.getExitStatus();
if (ExitStatus.COMPLETED.getExitCode().equals(status.getExitCode())) 
  {
    result = true;
  }
}
} catch (JobExecutionAlreadyRunningException ex) {
  System.out.println("Exception" + ex);
} catch (JobRestartException ex) {
  System.out.println("Exception" + ex);
} catch (JobInstanceAlreadyCompleteException ex) {
  System.out.println("Exception" + ex);
} catch (JobParametersInvalidException ex) {
  System.out.println("Exception" + ex);
} catch (IOException ex) {
  System.out.println("Exception" + ex);
}
 return false;
}</pre></div><p>Autowired <code class="literal">JobLauncher</code> and <code class="literal">Job</code> objects get injected into the application. The <code class="literal">startJob()</code> method <a id="id364" class="indexterm"/>creates <code class="literal">JobParameters</code> using <code class="literal">JobParametersBuilder</code>, and the job gets triggered by <code class="literal">jobLauncher.run()</code>. This invocation of batch job from the web service calls <code class="literal">JobLauncher.run()</code> to trigger a batch job in a synchronous thread. The <code class="literal">ExitStatus</code> can be accessed from the <code class="literal">JobExecution</code> object. Any exception during job launch can be caught with proper exception handling, as mentioned in the preceding list.</p></div></div>



  
<div id="sbo-rt-content"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Summary</h1></div></div></div><p>Through this chapter, we learned about enterprise integration and different methods available for enterprise application integration. We also learned how the Spring Integration project can integrate Spring Batch applications with its message-driven approach. We also learned about launching the batch jobs by accessing the Spring Integration components from the application context. We finished this chapter with an understanding of the RESTful job processing technique.</p><p>In the next chapter, we will learn about inspecting the Spring Batch jobs, including accessing execution data, listeners, and web monitoring.</p></div></div>



  </body></html>