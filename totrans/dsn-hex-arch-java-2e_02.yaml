- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wrapping Business Rules inside Domain Hexagon
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about the Domain as the first hexagon in
    hexagonal architecture. By being the innermost hexagon, the Domain does not depend
    on any code from the Application and Framework hexagons. Also, we make all the
    other hexagons depend on the Domain to conduct their operations. This kind of
    arrangement confers the Domain hexagon a degree of responsibility and relevance
    far higher than other hexagons. We employ such an arrangement because it is in
    the Domain where we group all the business rules and data that most represent
    the problem we try to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Among the techniques to model a problem domain, **Domain-Driven Design** (**DDD**)
    is widely adopted in projects that emphasize software code as a medium to convey
    knowledge about a business. An ever-present concern to separate what constitutes
    the core problem domain and what is secondary to it makes DDD a suitable approach
    to support the hexagonal architecture goal of separating technology code from
    business code.
  prefs: []
  type: TYPE_NORMAL
- en: The principles and techniques we will see in this chapter will serve as the
    basis to build the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Modeling a problem domain with entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing descriptiveness with value objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assuring consistency with aggregates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with domain services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using policy and specification patterns to deal with business rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining business rules as **Plain Old Java** **Objects** (**POJOs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned the building blocks of DDD
    and will be able to apply the presented concepts in the development of hexagonal
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java Standard Edition** (**SE**) development kit and **Maven 3.8** installed
    on your computer. They are all available for the Linux, Mac, and Windows operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter02).
  prefs: []
  type: TYPE_NORMAL
- en: Modeling a problem domain with entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In DDD, before any code is written, there must be lots of discussions between
    developers and domain experts—the people who have a deep understanding of their
    business, which may include other developers as well. Those discussions provide
    valuable information, acquired through a process called knowledge crunching, which
    is based on brainstorming between those developers and domain experts. That knowledge
    is then incorporated into the **ubiquitous language**. This language works as
    the *lingua franca* among everyone involved in the project and is present in documentation,
    day-to-day conversations, and – of course – in code.
  prefs: []
  type: TYPE_NORMAL
- en: When we deal with entities, we must always pay attention to how much we can
    learn about a business by just reading code. Even though just reading code may
    not be enough. That’s when techniques such as knowledge-crunching, where we speak
    with domain experts to learn more about a business, are instrumental in helping
    us continuously evolve the ubiquitous language and translate the business knowledge
    into working code. That’s the basis for rich entities that really capture relevant
    behaviors and are more than mere data objects.
  prefs: []
  type: TYPE_NORMAL
- en: For an entity to be considered an entity, it must have an identity; so, we’ll
    see how to assign identity in a way that is aligned with the hexagonal architecture
    goal to separate concerns between business and technology code.
  prefs: []
  type: TYPE_NORMAL
- en: The purity of domain entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we model a problem domain, the main focus is to capture, as precisely as
    possible, a real-life scenario in code. That scenario is often composed of several
    processes working together to support an organization’s goals to meet customer
    expectations. This ability to fulfill customer needs will ultimately determine
    the organization’s capacity to generate profit. So, the problem-domain modeling
    effort is crucial to determine the overall success of any organization that relies
    on its software to make money. A failure to understand and translate business
    requirements into code will obviously result in not satisfied customer expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Central to that problem-domain modeling effort is the creation of entities.
    Due to the proximity entities have to business requirements, we should strive
    to shield these entities from technical requirements. We do this to prevent the
    blurring of business-related code with technology-related code. By technology,
    I mean those things that exist and make sense only in the context of software.
  prefs: []
  type: TYPE_NORMAL
- en: Those same technology concerns would not make sense if we were only considering
    the business requirements without the software. We also have to recognize that
    a problem domain may not always refer to pure business requirements. A problem
    domain may be purely technological, such as creating a new development framework.
    I don’t think hexagonal architecture is the best approach in those scenarios because
    its emphasis is on projects trying to solve conventional business problems.
  prefs: []
  type: TYPE_NORMAL
- en: Domain entities should be pure in the sense that they deal only with business
    concerns. For technology-specific things, we have the option to utilize ports,
    use cases, and adapters, as we’ll see in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Relevant entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A relevant entity is characterized by the presence of two elements – business
    rules and business data. It is not unusual to see entity classes modeled almost
    like database entity objects that express only the data part and forget the business
    rules represented through the behaviors provided by the entity class methods.
    These business rules may end up in parts of code other than the Domain hexagon.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of leak, where the business rules end up outside the Domain hexagon,
    can be harmful because it may make it difficult to understand what the domain
    entity does. That happens when business rules are defined outside the Domain hexagon
    and depend, for example, on code that handles database entities, which are not
    part of the domain model but are a technical detail supporting the domain model.
    That phenomenon is prevalent in what is called an **anemic domain model**. The
    entity objects coming from anemic domain models generally have data but lack behavior.
    By not coupling data with behavior, the anemic domain model goes against the very
    essence of **Object-Oriented Programming** (**OOP**). When behavior is not present
    in domain objects, we have to go somewhere else to fully grasp what the entity
    is supposed to do, thus generating a mental overload that can quickly become an
    onerous burden as a code base grows.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, we should not overload entity classes with logic that is not intrinsic
    to the entity we try to model. That’s not a trivial thing to do because, at first,
    we may think an operation is a part of the entity, only to discover later on that
    it’s not.
  prefs: []
  type: TYPE_NORMAL
- en: For things considered not intrinsic to entity behavior, we have the option to
    use a domain service. With services, we can accommodate those operations that
    don’t fit smoothly into an entity class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created a `retrieveRouter` method to filter and
    list routers in the `Router` class, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '*Could we consider this list router’s behavior an intrinsic characteristic
    of routers in the real world?* If our problem domain says the opposite, then we
    should remove this behavior from the entity class. *And what about the constraints
    that we use to check the router type before we add a router to the list?* If we
    consider this verification a router-intrinsic behavior, we have the following
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: Embed this constraint directly in the entity class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a specification to assert the constraint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Specifications are a subject we will cover later in this chapter, but for now,
    you can see specifications as predicate mechanisms to ensure we work with the
    correct objects. The following code snippet provides an example of a `Router`
    entity class with the router type-check constraints embedded directly in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To accommodate the domain service method, we need first to create a domain
    service class called `RouterSearch` and move to it the `retrieveRouter` method
    from the `Router` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `isCore`, `isEdge`, and `filterRouterByType` constraint methods continue
    to exist in the `Router` entity class. We only moved the `retrieveRouter` method
    from `Router` to `RouterSearch`. That `retrieveRouter` method can now be consumed
    as a service by other objects in the domain and in other hexagons. Later in this
    chapter, in the *Working with domain services* section, we will take a closer
    look at domain services.
  prefs: []
  type: TYPE_NORMAL
- en: A question that may arise is how complex the domain model methods should be,
    especially those that are part of the domain entities. My take is that the complexity
    will be determined by our knowledge of the problem domain and our ability to translate
    it into a domain entity that captures, through proper method definitions, only
    the necessary behaviors required to change the entity state according to the conditions
    presented by the problem domain. A weak problem domain knowledge may yield unnecessary
    complexity. So, as our knowledge of the problem domain increases, it also increases
    our capacity to provide the right level of complexity to the methods we define
    for the domain entities.
  prefs: []
  type: TYPE_NORMAL
- en: One fundamental characteristic of entities is that they have an identity that
    uniquely identifies them. Having an identity mechanism is paramount to ensuring
    that our entities are unique across a system. One way to provide such identity
    is through the use of UUIDs, a subject we will explore in the section.
  prefs: []
  type: TYPE_NORMAL
- en: Using UUIDs to define identity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may be familiar with **identifier** (**ID**)-generation techniques that
    rely on database sequence mechanisms to generate and avoid duplication of IDs.
    Although it’s convenient to delegate this responsibility to a database, by doing
    so, we couple a crucial aspect of our software to an external system.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s suppose we’re aiming to develop a hexagonal application that lets us evolve
    business code with as few technology dependencies as possible. In this case, we
    need to find a way to turn this identity generation into an independent process.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common approach to establishing an identity that does not rely on a central
    authority is with a **universally unique identifier** (**UUID**). This is a 128-bit
    number widely used to assure universal uniqueness in computer systems. There are
    four different methods to generate UUIDs – time-based, **Distributed Computer
    Environment** (**DCE**) security, name-based, and randomly generated. The following
    code snippet shows how you can create name-based and randomly generated UUIDs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Beware of UUIDs, you can have performance issues if your data source is a relational
    database. Because UUIDs are strings, they consume more memory than the integers
    created by autogenerated IDs provided by relational databases. The use of UUIDs
    can cause a considerable impact on the size and index management of databases.
    There is no free lunch. Computer resources are the price to be paid for such an
    agnostic ID-generation solution. It’s up to you to decide whether the benefits
    of this approach outweigh the disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, the entity ID should not change, so it becomes an immutable attribute.
    This immutable characteristic makes the entity ID attribute a suitable candidate
    to be modeled as a value object. Based on the topology and network inventory example
    that we dealt with in the previous chapter, the following code snippet shows us
    a simple approach to creating a value object class to represent the ID of our
    `Router` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `withId` factory method allows the reconstitution of `Router` entities when
    we have the ID. The `withoutId` factory method enables the generation of new IDs
    if we deal with a new `Router` entity.
  prefs: []
  type: TYPE_NORMAL
- en: The `withId` and `withoutId` methods are both applications of a pattern called
    the static factory method that allows us to encapsulate object creation. These
    methods are part of the domain model because they enable identity provisioning,
    through IDs, on either new or existing router entities.
  prefs: []
  type: TYPE_NORMAL
- en: Entities are first-class citizens in a hexagonal architecture. They are the
    foundational elements from which other software components will derive. However,
    they alone aren’t enough to create rich domain models because not everything in
    a domain possesses an identity. We need something to express objects that don’t
    need to be uniquely identified. We fill this need with value objects, a type of
    object intended to help us increase the descriptiveness of a problem domain.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing descriptiveness with value objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the book *Implementing Domain-Driven Design*, the author Vernon Vaughn points
    out that we should use value objects to measure, quantify, or describe things
    from our problem domain. For example, you can describe an ID attribute with a
    value object instead of a long or integer value. You can wrap a double or big
    decimal attribute into a specific value object to express quantification more
    clearly.
  prefs: []
  type: TYPE_NORMAL
- en: We’re not fully satisfied with just using the built-in language types to model
    a problem domain. To make a system more explicit about its nature and purposes,
    we wrap those built-in language data types – and even our own created types –
    in well-defined value objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This effort to convey meaning is based on the following two fundamental characteristics
    of value objects:'
  prefs: []
  type: TYPE_NORMAL
- en: They are immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don’t have an identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suppose you have painted a picture. Imagine how strange would it be if, for
    some reason, after you’ve finished your work, parts of your picture mysteriously
    change colors. In this analogy, colors are like value objects that we use to create
    a picture, and each color can be a different value object. So, to ensure that
    our paint will persist, the colors, once used, must not change and must be immutable
    once used. I base my argument for value objects on the idea that some characteristics
    must never change because they are the raw material we use to describe a problem
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Raw material alone neither expresses much meaning nor has much value. The real
    value comes when we combine and work with that raw stuff to form relevant and
    discernable things. Because value objects alone are like raw material, we don’t
    bother to replace them or throw them away. *And if they are not so important,
    why should we assign them an identity and take the same care we have* *with entities?*
  prefs: []
  type: TYPE_NORMAL
- en: The bottom line is that value objects should be discardable and easily replaceable
    objects that we use to compose an entity or other type of object.
  prefs: []
  type: TYPE_NORMAL
- en: Using value objects to compose entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When modeling an entity class, for example, we have two options – to use or
    not use value objects on entity attributes. Here is an example of the second approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following log excerpt as data entries we want to parse into the
    `Event` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After being properly parsed, we would have `Event` objects with network traffic
    activity string fields, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**casanova.58183 >** **menuvivofibra.br.domain**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the greater-than sign, we have the source host and, after, the destination
    host. For the sake of this example, let’s see it as an activity representing the
    source and destination of a packet. By being a string, it leaves a burden for
    clients that want to retrieve the source or destination host from it, as illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try it with an `Activity` value object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we update the `Event` entity class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The client code becomes clearer and more expressive, as we can see in the following
    snippet. Also, clients don’t need to handle the data themselves to retrieve the
    source and destination hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With value objects, we have more flexibility and control over our data, letting
    us express the domain model in a more cohesive way.
  prefs: []
  type: TYPE_NORMAL
- en: Assuring consistency with aggregates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve seen how valuable entities are to represent things in a problem
    domain. Also, we saw how value objects are essential to enhance the descriptiveness
    of the model we use. *However, how do we proceed when we have a group of related
    entities and value objects that express a whole concept when put together?* For
    such a scenario, we should employ the use of **aggregates**. The idea is that
    objects inside an aggregate operate in a consistent and isolated manner. To achieve
    such consistency, we must ensure that any change on any aggregate object is conditioned
    to the variants imposed by such an aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: An aggregate is like an orchestrator that orchestrates data and behavior on
    the objects it controls. For this approach to work, we need to define an entry
    point to interact with the aggregate realm. This entry point is also known as
    the aggregate root, which keeps references to the entities and value objects that
    are part of the aggregate. With the boundary provided by aggregates, we’re in
    a better position to assure consistency in the operations conducted by the objects
    within that boundary. By formally establishing conceptual boundaries to ensure
    consistency in the activities based on our problem domain, it will be easier for
    us to incorporate techniques such as optimistic or pessimistic locking, and technologies
    such as the **Java Transaction API** (**Java JTA**) to support consistent transactional
    operations. With well-structured aggregates, we have better conditions to apply
    whatever approach we think is good to enable transactions on our system.
  prefs: []
  type: TYPE_NORMAL
- en: From a performance and scalability perspective, we should always strive to keep
    our aggregates as small as possible. The reason is simple – large aggregate objects
    consume more memory. Too many aggregate objects being instantiated at the same
    time can compromise the overall **Java Virtual Machine** (**JVM**) performance.
    This rule applies to anything in the OOP world, but we emphasize aggregates because
    of their ability to integrate objects.
  prefs: []
  type: TYPE_NORMAL
- en: A small aggregate generally contains just one entity that acts as the aggregate
    root and other value objects. The way to make two different aggregates interact
    with each other is through their aggregate root, which happens to be an entity
    root with its unique ID. The aggregate root is used for persistence purposes as
    well. So, you’ll perform changes on aggregate child objects through the aggregate
    root, and when your changes are done, you’ll use the same aggregate root to commit
    those changes to your persistence system.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if you don’t see the non-functional requirements of performance
    and scalability as something critical, I think, with proper care, that aggregates
    can grow to have more than one entity.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling an aggregate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate how we can model an aggregate, let’s return to our network and
    topology inventory scenario. One of the business needs is to catalog the equipment
    and networks connected to a specific **Edge Router**. Below this **Edge Router**,
    we have a **Level 3 Switch**, responsible for creating **Virtual Local-Area Networks**
    (**VLANs**) for different networks. The structure would be something like the
    one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Network components](img/B19777_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Network components
  prefs: []
  type: TYPE_NORMAL
- en: The catalog of equipment, networks, and relationships is used by the infrastructure
    department to help them plan and implement changes in the overall network. A router
    or switch alone doesn’t tell us too much about the network. The real value comes
    when we aggregate all the network components and their interconnections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of information will allow the infrastructure department to have more
    visibility and make well-based decisions. The epicenter of our aggregate is the
    edge router entity, which happens to be our aggregate root. The switch is also
    an entity. We model its VLAN networks as value objects. The context here is clear
    – a network composed of HR, marketing, and engineering VLAN networks connected
    to a switch that, in turn, is connected to the edge router. The internet or other
    networks can be considered in a different context. Here is a **Unified Modeling
    Language** (**UML**)-like representation of the aggregate root:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The aggregate grouping together all network components](img/B19777_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – The aggregate grouping together all network components
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting from the bottom level, we have `Network` as a value object, as illustrated
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the **Internet Protocol** (**IP**) address attribute is a value object
    as well, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may have noted some validation rules in the constructors of the `IP` and
    `Network` value objects’ classes. Those validations work as guards to prevent
    the wrong construction of value objects. Putting those guards in instance creation
    is one way to free clients from the burden of validating value objects. That’s
    exactly what happens on the `Network` class, where we just validate the `cidr`
    attribute because `IP` will come already validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also a `Protocol` `enum` value object that we will use to compose the
    `IP` value object, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After modeling the `IP`, `Network`, and `Protocol` value objects, we have now
    the necessary objects to model the `Switch` entity class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Because networks are directly connected to a switch, we create an `addNetwork`
    method to support the capability to add more networks to a switch. This method
    first retrieves the existing networks from the router, adding them to a list.
    Then, it adds the new network to the list of existing networks. Note that `addNetwork`
    does not change the current `Switch` object but, rather, creates a new `Switch`
    instance containing the network we added.
  prefs: []
  type: TYPE_NORMAL
- en: 'On top of all the value objects we have created so far, and the `Switch` entity,
    we need to formalize a boundary with an aggregate root. That’s the role of our
    `Router` entity class, as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Along with the `RouterType` and `RouterId` value objects, there is also an entity
    for the switch. The `networkSwitch` entity represents the switch connected directly
    to this router. Then, we add two methods, one to create a new network and another
    to connect an existing network to the switch.
  prefs: []
  type: TYPE_NORMAL
- en: By putting these methods on the aggregate root, we delegate to it the responsibility
    to handle all the objects under its context, thus enhancing consistency when we
    deal with such an aggregation of objects. Also, this is an effort to prevent the
    anemic domain model approach, whereby entities are just data objects without any
    kind of behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to use domain services to call those operations contained
    in the aggregate.
  prefs: []
  type: TYPE_NORMAL
- en: Working with domain services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When modeling a problem domain, we’ll certainly face situations where the task
    at hand does not fit adequately into any of the object categories that we’ve seen
    so far in the domain hexagon – entities, value objects, and aggregates. Earlier
    in this chapter, we encountered a situation where we removed from the `Router`
    entity a method responsible for retrieving a list of routers. That method seemed
    to be in the wrong place because, in our topology and network inventory scenario,
    a router usually doesn’t list other routers. To deal with this cumbersome situation,
    we’ve refactored the router list method in a separate object. Eric Evans calls
    such objects **domain services**.
  prefs: []
  type: TYPE_NORMAL
- en: I believe it’s important to distinguish domain services from any other type
    of service. For example, in **Model-View-Controller** (**MVC**) architectures,
    services are often seen as bridges that connect the different facets of an application,
    handling data and orchestrating calls within and outside the system. Their usage
    is often associated with software development frameworks such as Spring that even
    have a service annotation. However, independent of the context, I believe the
    main difference between distinguished service types lies not in the meaning but
    in the scope.
  prefs: []
  type: TYPE_NORMAL
- en: '*What makes something a service?* It’s the ability to perform some worthwhile
    effort. This characteristic is inherent to any service, both in the real world
    and with computers. However, in the latter case, we should care about the **Separation
    of Concerns** (**SoC**), modularization, decoupling, and other relevant stuff
    for good architecture. It’s based on those concerns that we put domain services
    inside the domain hexagon. They perform worthwhile tasks – as with any other services
    – but within the constrained scope of our problem domain. This means domain services
    should not call services or other objects that operate in application or framework
    hexagons. Instead, objects from those hexagons are clients who call domain services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we created the following two methods in our `Router`
    entity class, which is also the aggregate root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, we have a service class operating over those
    two `Router` entity methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We have a method called `createNewNetwork` that is responsible for creating
    a new network object and adding it to the switch linked to our router. We should
    meet two constraints to be able to create a network. The first, simple one checks
    whether the minimum **Classless Inter-Domain Routing** (**CIDR**) has not been
    violated. The second constraint is somewhat more elaborate. It verifies whether
    the network address is already used on the whole network.
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, we’re delegating to the `NetworkOperation` domain service
    class the responsibility to deal with tasks that don’t fit neatly into entities
    or value objects. It's also a good way to prevent entity and value object classes
    from growing too large, with far more features than necessary according to a problem
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: Until now, we’ve dealt with invariants directly on entities, value objects,
    or service classes. Next, we’ll see an approach to accommodate those invariants
    in a more orderly and organized way.
  prefs: []
  type: TYPE_NORMAL
- en: Using policy and specification to deal with business rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most valuable things a system possesses is its codified business
    rules. Those rules represent a vital effort to understand a real-world problem
    and translate that understanding into working software. That’s not a trivial task,
    for sure. In DDD, we learn how crucial it is to work closely with domain experts
    to model our problem domain correctly. If domain experts are not available, we
    should seek developers with knowledge of a business. If none of them is available,
    we have no choice but to embark on a knowledge-seeking journey through books and
    any other resources that can help us grasp our problem domain’s inner workings.
  prefs: []
  type: TYPE_NORMAL
- en: Once the business knowledge is acquired and we have enough relevant information
    about the problem domain’s steps and processes, we can then start the adventure
    to transform that knowledge into code. At first glance, this process to understand
    business needs and transform them into software seems simple. Instead, it’s been
    the fruit of very good debates that have given rise to various methodologies and
    even an important manifesto called the **Agile Manifesto**. It’s not my goal here
    to discuss the best approach to understanding business needs. Instead, the idea
    here is to present some of the techniques we can use to transform that business
    knowledge into working software.
  prefs: []
  type: TYPE_NORMAL
- en: We always have the option to do things our way, sometimes ignoring the knowledge
    resulting from the experience of others who came before us. When dealing with
    business rules, this is by no means different. In the previous examples, we did
    this very thing, scattering business rules around code without a second thought.
    We now have an opportunity to fix that approach and tap into the knowledge of
    others who came before us.
  prefs: []
  type: TYPE_NORMAL
- en: Policy and specification patterns are two patterns that can help us better organize
    our code’s business rules.
  prefs: []
  type: TYPE_NORMAL
- en: A **policy**, also known as a strategy, is a pattern that encapsulates part
    of the problem domain in a block of code. For those familiar with the Strategy
    pattern (*Gang of Four*), the term *algorithm* can be used to describe that encapsulated
    block of code. The main characteristic of a policy is that it performs some action
    or processing in the data provided. Policies are intentionally kept separate from
    entities and value objects to avoid coupling. This decoupling provides the well-known
    benefit of evolving one part without direct impact or side effects on the other.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, **specifications** are like conditions or predicates used to ensure
    the properties of an object. However, what characterizes a specification is its
    care to encapsulate those predicates in a more expressive way than mere logical
    operators. Once encapsulated, those specifications can be reused and even combined
    to express the problem domain better.
  prefs: []
  type: TYPE_NORMAL
- en: When used together, policies and specifications are sound techniques to improve
    the robustness and consistency of our business rules across code. A specification
    ensures that only suitable objects are handled by our policies. We have a catalog
    of different and easily changeable algorithms at our disposal with policies.
  prefs: []
  type: TYPE_NORMAL
- en: To better illustrate how specifications and policies work, we will now explore
    how to implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating specifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s first see how we can refactor our `NetworkOperation` service class to
    use specifications. We’ll start by creating a `Specification` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s through the `isSatisfiedBy` implementation that we will define our predicates.
    Followed by this interface, we need to create an abstract class that implements
    the `and` method to allow us to combine specifications, as illustrated in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there is only a method for the `AND` operator because we are not dealing
    with other operators such as `OR` and `NOT`, although it’s common to implement
    methods for those operators. To conclude the creation of our base types, we implement
    the `AndSpecification` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to create our own specifications. The first one is about the
    business rule that limits the minimum CIDR allowed for the creation of new networks.
    The code is illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The corresponding specification will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll deal with the business rules that check whether the network address
    is not already used, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The refactoring of the previous code basically consists of moving the `isNetworkAvailable`
    method from the entity to the specification class, as shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate how to combine two specifications with the `and` method, we will
    create two more specifications. The first one is to establish the maximum allowed
    networks and is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'And the second specification is to ensure that we deal only with edge or core
    routers. This is shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined our specifications, we can use a feature introduced
    first as a preview in Java 15 and then as definitive in Java 17, allowing us to
    constrain which classes are permitted to implement an interface or a class. We
    call it a *sealed class/interface*. As the name implies, this feature seals the
    class/interface, so it cannot be implemented unless the implementing class/interface
    name is explicitly declared on the sealed class or interface. Let’s check how
    this feature can work with the specification we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to restrict who can implement the `Specification` interface and the
    `AbstractSpecification` abstract class. In the following code snippet, we can
    see how we can apply it to the `Specification` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we restrict which class can implement the interface by using the
    `permits` clause. Let’s seal the `AbstractSpecification` abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The permit clause now includes all the other classes implementing the `AbstractSpecification`.
    We still need to ensure the implementing classes are `final`. Therefore, we need
    to add the `final` clause on every one of those classes, as shown in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once we have finished adjusting the `final` keyword on the implementing specification
    classes, we have a well-defined set of sealed classes/interfaces, describing which
    specification classes can be used to define a system’s business rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re now ready to refactor our domain service, responsible for creating new
    networks to use those specifications, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have explored how to implement specifications, let’s see how we
    can create policies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how policies work, we will create a service class to help us retrieve
    a list of network events based on a specific algorithm to parse raw event data.
    This parse algorithm can or cannot be considered part of the problem domain; usually,
    it’s not, but for the sake of this example, let’s assume it is.
  prefs: []
  type: TYPE_NORMAL
- en: We will create two policies – the first is to parse string log entries into
    `Event` objects using a pure **regular expression** (**regex**)-based algorithm,
    where we explicitly inform the regex pattern, while the second one will accomplish
    the same thing but with a split-based algorithm that uses just a space delimiter.
    The choice between both policies can be based on performance and the ability to
    customize the parsing mechanisms, among other factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create an `EventParser` interface, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We’ll use the `formatter` attribute in both event-parser implementation classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start implementing the regex parser policy, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The split parser policy seems simpler, as we can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did previously with specifications, the `EventParser` interface can be
    turned into a sealed interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget to include the final keyword on the `RegexEventParser` and `SplitEventParser`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, returning to the parser policy implementation, note that the `Event` constructor
    is called with the parsed attributes. We need to update our `Event` entity class
    to enable it to work with our policies. We can do so with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The switch that allows us to choose between policies relies on the following
    enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re now ready to create an `EventSearch` service class with a method to retrieve
    network events. This domain service will allow us to choose which kind of parse
    algorithm to use when retrieving events. Here’s the code we’ll need for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are acquainted with policy and specification patterns, let’s see
    the benefits of modeling our business rules on POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: Defining business rules as POJOs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Back in the day, when enterprise development was strongly influenced by Java
    2 Platform, **Enterprise Edition** (**J2EE**) (known today as **Jakarta EE**),
    there was a technology called **Enterprise JavaBeans** (**EJBs**), responsible
    for lifting from developers all the heavyweight jobs required to manage software
    development plumbing activities, relating to transaction management, security,
    and object life cycles. The EJB promise was that developers could focus their
    energy on developing business features, while the J2EE container would take care
    of all the infrastructure details. EJBs fulfilled this promise, but not without
    a price. It was time-consuming and boring to create and maintain EJBs in their
    first versions. There were lots of things to do, involving various **Extensible
    Markup Language** (**XML**) configurations and deployment descriptors, and to
    make things worse, there was little space to reuse these EJB objects because they
    had so much boilerplate. They weren’t like POJOs – simple and reusable.
  prefs: []
  type: TYPE_NORMAL
- en: This issue with the first EJB versions – version 2 especially – helped to motivate
    the creation of improved solutions that could leverage the simplicity of POJOs.
    Among those solutions, we can mention EJB 3 and the technologies derived from
    frameworks such as Spring and Quarkus. What all those technologies have in common,
    though, is the incentive and flexibility to work with POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: POJOs are appealing because they are nothing more than regular Java objects.
    It is simple to understand a POJO because we deal only with Java standard **Application
    Programming Interfaces** (**APIs**) instead of custom libraries and frameworks.
    That’s what makes POJOs a category of developer-friendly objects that are easier
    to understand and reuse across different parts of an application. If we aim for
    change-tolerant applications, then the use of POJOs is always recommended to diminish
    coupling with specific technologies, allowing an application to switch between
    different technologies or frameworks without much friction.
  prefs: []
  type: TYPE_NORMAL
- en: This flexibility offered by POJOs allows them to participate, simultaneously
    if needed, in different system departments. For example, nothing prevents someone
    from using the same POJO in transactional, persistence, and user-presentation
    contexts. We can also use POJOs to represent business rules – the entity, policy,
    and specification objects presented in this chapter are good examples of how we
    can embody business rules within POJOs.
  prefs: []
  type: TYPE_NORMAL
- en: By using POJOs to model business rules, we leverage all the benefits related
    to reusability and simplicity that a POJO can provide. They also go hand in hand
    with the important goal of keeping domain objects shielded from any technological
    details, which will ultimately contribute to the essential SoC efforts to support
    more supple and sober designs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The DDD topics we covered in this chapter are paramount in our effort to develop
    hexagonal applications, as it’s through the use of DDD techniques that we’ll be
    able to shape a decoupled, consistent, and business-oriented domain hexagon that
    will be the foundation for the application and framework hexagons.
  prefs: []
  type: TYPE_NORMAL
- en: It’s always essential to understand the basics. By looking closer into the main
    DDD concepts, we found the basic techniques to aid us in developing the domain
    hexagon. We covered how to make pure and relevant entities and how to assign an
    identity to them. With value objects, we understood how important they are in
    conveying meaning and enhancing the descriptiveness of a problem domain. Aggregates
    showed us how to group related entities and value objects to describe whole operations
    in our problem domain. Also, we saw how aggregates are instrumental in assuring
    consistency with transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Following aggregates, we learned that domain services let us express behaviors
    that don’t fit well into entities or value objects, and to better organize business
    rules, we learned about policy and specification patterns. Finally, we assessed
    the benefits of the reusability and simplicity that POJOs provide when defining
    business rules. With the ideas and techniques explored in this chapter, we can
    now build a domain hexagon that captures and properly arranges into code the business
    rules that will influence the behavior of an entire application.
  prefs: []
  type: TYPE_NORMAL
- en: We’re now ready to move one step higher in the ladder by entering the realm
    of the application hexagon, where we’ll see how to combine and orchestrate business
    rules to create software functionality through use cases and ports.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the main attribute of entities not found in value objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can value objects be mutable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Every aggregate must have an entry-point object to allow communication with
    other objects controlled by the aggregate. What is the name of this entry-point
    object?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Are domain services allowed to call objects on other hexagons?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a policy and a specification?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of defining business rules as a POJO?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Implementing Domain-Driven Design* (Vernon, 2016)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Domain-Driven Design: Tackling Complexity in the Heart of Software* (Evans,
    2003)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extreme Programming Explained: Embrace Change* (Beck, 1999)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contrary to value objects, entities have an identity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No. The most important property of a value object is its immutability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The entry-point object for any aggregate is called an aggregate root.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: No, but objects from other domains and other hexagons can call domain services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A policy is a pattern that encapsulates part of the problem domain knowledge
    in a block of code or an algorithm. A specification is a pattern that works with
    predicates to assert the validity of the properties of objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because a POJO doesn’t depend on external technology details, such as a feature
    provided by an external library or a framework. Instead, a POJO relies only on
    a standard Java API, which makes POJOs simple and easy-to-reuse objects. POJOs
    are helpful for creating business rules objects that aren’t blurred by technology
    details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
