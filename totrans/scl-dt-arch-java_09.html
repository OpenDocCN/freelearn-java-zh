<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer214">
<h1 class="chapter-number" id="_idParaDest-143"><a id="_idTextAnchor144"/>9</h1>
<h1 id="_idParaDest-144"><a id="_idTextAnchor145"/>Exposing MongoDB Data as a Service</h1>
<p>In the previous chapters, we learned how to analyze and design solutions for various data ingestion and storage problems. We also learned how to analyze and classify those problems. After that, we learned how to apply scalable design principles and optimally choose technologies to implement those solutions. Finally, we learned how to develop, deploy, execute, and verify those solutions. However, in a real-world scenario, it is not always a good idea to expose the whole database to downstream systems. If we plan to do so, we must ensure that proper authorization and access rules are implemented on the database (please refer to the <em class="italic">Publishing problems</em> section of <a href="B17084_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Basics of Modern Data Architecture</em>, for various ways of publishing data). One of the ways to give selective and authorized access to data is by publishing via <strong class="bold">Data as a Service </strong>(<strong class="bold">DaaS</strong>). </p>
<p>DaaS enables data to be published by a platform and language-independent web service such as SOAP, REST, or GraphQL. In this chapter, we will analyze and implement a DaaS solution using the REST API to publish the previously ingested and sorted data from a MongoDB database. Here, we will learn how to design, develop, and unit test a REST application for publishing data. We will also learn how to deploy our application in Docker. In addition to this, we will briefly learn how to use API management tools and how they can be of help. Although Apigee is the most popular API management tool, we will be using AWS API Gateway as we are deploying and running our application on an AWS cluster. By the end of this chapter, you will know what DaaS is and when it should be used. You will also know how to design and develop a DaaS API, as well as how to enable security and monitor/control traffic on a DaaS API using API management tools.</p>
<p>In this chapter, we’re going to cover the following main topics:</p>
<ul>
<li>Introducing DaaS – what and why</li>
<li>Creating a DaaS to expose data using Spring Boot</li>
<li>API management</li>
<li>Enabling API management over the DaaS API using AWS API Gateway </li>
</ul>
<h1 id="_idParaDest-145"><a id="_idTextAnchor146"/>Technical requirements</h1>
<p>To complete this chapter, you will need the following:</p>
<ul>
<li>Prior knowledge of Java</li>
<li>OpenJDK 1.11 installed on your local system</li>
<li>Maven, Docker, and Postman installed on your local system</li>
<li>An AWS account</li>
<li>The AWS CLI installed on your local system</li>
<li>IntelliJ Idea Community or Ultimate Edition installed on your local system</li>
</ul>
<p>The code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09">https://github.com/PacktPublishing/Scalable-Data-Architecture-with-Java/tree/main/Chapter09</a>.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor147"/>Introducing DaaS – what and why </h1>
<p>In the introduction, we briefly discussed <a id="_idIndexMarker980"/>and established that DaaS is useful for publishing already-ingested and analyzed data securely.</p>
<p>But <em class="italic">what</em> is DaaS? It is a data management strategy that enables data as a business asset, which makes valuable and <a id="_idIndexMarker981"/>business-critical data accessible on demand to various internal and external systems. <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) started becoming popular in the late 90s when software was provided to consumers on demand. Similarly, DaaS enables access to data on demand. With the help of <strong class="bold">service-oriented architectures</strong> (<strong class="bold">SOAs</strong>) and <a id="_idIndexMarker982"/>APIs, it enables secure platform-independent data access. The following diagram provides an overview of a DaaS stack:</p>
<div>
<div class="IMG---Figure" id="_idContainer174">
<img alt="Figure 9.1 – DaaS stack overview " height="530" src="image/B17084_09_001.jpg" width="624"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – DaaS stack overview</p>
<p>As we can see, data from different<a id="_idIndexMarker983"/> kinds of data stores, such as data warehouses, data lakes, or online databases, can be unified by a virtual data layer that can be used to build the services or API layer. The API management layer is present between the users of the data and the API layer. The API management layer is responsible for<a id="_idIndexMarker984"/> registering, securing, documenting, and orchestrating the underlying Service APIs. All consumer applications interact with the API management layer to consume the data from the Service APIs.</p>
<p>Now that we know what a DaaS is, let’s figure out <em class="italic">why</em> it’s important.</p>
<p>Data is the new gold. Every <a id="_idIndexMarker985"/>organization collects huge volumes of data, but a successful organization knows how to optimally use that data to drive its profits. Data collection and storage are done using different mediums across the organization. But to fully utilize the potential of that data, teams across the organization should be able to access it easily and securely. Data in silos, maintained by a team, may have the opportunity to derive value across the organization. </p>
<p>On the other hand, exposing a database to teams across the organization may be a governance or security headache. This is where DaaS plays a vital role. By exposing valuable and business-critical data using APIs, DaaS enables teams to share data with internal teams while implementing the necessary access and security checks on the dataset. This helps teams easily register and subscribe to data on demand instead of having to go through the unnecessary and cumbersome effort of analyzing, ingesting, and maintaining a dataset that is already ingested and maintained by some other team in the organization. This enables fast-paced development and cost saving in developing and maintaining redundant datasets <a id="_idIndexMarker986"/>across the organization. In addition to this, DaaS has enabled a lot of businesses to selectively provide data on demand to the external world for profit or usability.</p>
<p>According to Gartner’s hype cycle, DaaS is still a long way from reaching its plateau of peak productivity, which means it has the potential to be one of the most impactful advancements in data engineering for the next decade. </p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor148"/>Benefits of using DaaS</h2>
<p>The following are a few of the major benefits <a id="_idIndexMarker987"/>of using DaaS:</p>
<ul>
<li><strong class="bold">Agility</strong>: DaaS enables users to access data without needing a comprehensive understanding of where data is stored or how is it indexed. It also enables teams to focus on their business functionality, and not unnecessarily spend time storing and managing the data. This helps considerably decrease time-to-market.</li>
<li><strong class="bold">Easy maintainability</strong>: There are fewer maintenance headaches for the teams that use DaaS to get their data since they don’t have to worry about managing and maintaining it, nor its storage and data pipelines.</li>
<li><strong class="bold">Data quality</strong>: Since data is served by APIs, data is more non-redundant, so taking care of data quality becomes much easier and more robust.</li>
<li><strong class="bold">Flexibility</strong>: DaaS gives companies the flexibility to trade off between initial investment versus operational expenses. It helps organizations save costs on the initial setup to store data, as well as ongoing maintenance costs. It also enables teams to get data on demand, which means that teams don’t need to have a long-term commitment to<a id="_idIndexMarker988"/> that service. This enables teams to start using the data provided by DaaS in a much quicker fashion. On the other hand, if, after a while, there is no need for that data or the user wants to move to a newer technology stack, the migration becomes much faster and hassle-free. DaaS also enables easy integration in on-premises environments or the cloud for its users.</li>
</ul>
<p>Now that we have understood the concept and benefits of publishing data using a DaaS, in the next section, we will learn how to implement a DaaS solution using the REST API.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor149"/>Creating a DaaS to expose data using Spring Boot</h1>
<p>In this section, we will learn how<a id="_idIndexMarker989"/> to expose a REST-based<a id="_idIndexMarker990"/> DaaS API using Java and Spring Boot. But before we try to create the solution, we must understand the problem that we are <a id="_idIndexMarker991"/>going to solve.</p>
<p class="callout-heading">Important note</p>
<p class="callout"><strong class="bold">REST</strong> stands for <strong class="bold">Representational State Transfer</strong>. It is not a protocol or standard; instead, it provides certain architectural constraints to expose the data layer. The REST API allows you to transfer the representational state <a id="_idIndexMarker992"/>of a data resource to the REST endpoint. These representations can be in JSON, XML, HTML, XLT, or plain text format so that they can be transferred over the HTTP/(S) protocol.</p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor150"/>Problem statement</h2>
<p>In the solution described in <a href="B17084_06.xhtml#_idTextAnchor092"><em class="italic">Chapter 6</em></a>, <em class="italic">Architecting a Real-Time Processing Pipeline</em>, we analyzed and ingested<a id="_idIndexMarker993"/> analytical data in a MongoDB-based collection. Now, we want to expose the documents present in the collection using a DaaS service that can be searched for by either <strong class="source-inline">ApplicationId</strong> or <strong class="source-inline">CustomerId</strong>. In the next section, we will analyze and design the solution and then implement it.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor151"/>Analyzing and designing a solution</h2>
<p>Let’s analyze the requirement to solve<a id="_idIndexMarker994"/> the given problem. First, we will note down all the facts and information available. The following are the facts we know:</p>
<ul>
<li>The data to be published is stored in a MongoDB collection hosted in the cloud</li>
<li>We need to publish the DaaS with security and API management</li>
<li>We need to create endpoints so that the data can be fetched by either <strong class="source-inline">ApplicationId</strong> or <strong class="source-inline">CustomerId</strong></li>
<li>The DaaS that’s been built for this data should be platform or language-independent</li>
</ul>
<p>Based on these facts, we can conclude that <a id="_idIndexMarker995"/>we don’t necessarily need a virtual data layer. However, we need the application to publish two endpoints – one exposing data based on <strong class="source-inline">ApplicationId</strong> and the other exposing data based on <strong class="source-inline">CustomerId</strong>. Also, since the MongoDB instance is in the cloud, and most of the frontend applications using this DaaS are in the cloud, it makes sense to <a id="_idIndexMarker996"/>deploy this application in an EC2 or <strong class="bold">Elastic Container Repository</strong> (<strong class="bold">ECR</strong>) instance. However, since we have no information about the traffic that will use this DaaS, it makes more sense to containerize the application so that, in the future, we can easily scale out the application by adding more containers.</p>
<p>The following diagram depicts the proposed solution architecture for our problem:</p>
<div>
<div class="IMG---Figure" id="_idContainer175">
<img alt="Figure 9.2 – Proposed solution architecture of DaaS " height="659" src="image/B17084_09_002.jpg" width="703"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Proposed solution architecture of DaaS</p>
<p>As we can see, we use our REST <a id="_idIndexMarker997"/>application to read data from MongoDB and fetch the results for the REST endpoint. We use Spring Boot as the technology stack to build the REST API as it is modular, flexible, extendible, and provides an amazing range of I/O integrations and community support. We will create Docker containers for this application and deploy them in the AWS Elastic Container Service cluster using the AWS Fargate service. This gives us the flexibility to scale up or down quickly when traffic increases in the future. Finally, we apply the API management layer on top of the deployed application. There are many API management tools available on the market, including Google’s APIJEE, Microsoft’s Azure API Management, AWS API Gateway, and IBM’s API Connect. However, since our stack is deployed on AWS, we will be using the native API management tool of AWS: AWS API Gateway.</p>
<p>Now that we have discussed the overall architecture of the solution, let’s learn more about the design of the Spring Boot application. The following diagram depicts the low-level design of the Spring Boot application:</p>
<div>
<div class="IMG---Figure" id="_idContainer176">
<img alt="Figure 9.3 – Low-level design of the Spring Boot REST application " height="304" src="image/B17084_09_003.jpg" width="695"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Low-level design of the Spring Boot REST application</p>
<p>Our Spring application has a <a id="_idIndexMarker998"/>controller class called <strong class="source-inline">DaaSController</strong> that exposes two <strong class="source-inline">GET</strong> endpoints, as follows:</p>
<ul>
<li><strong class="source-inline">GET /rdaas/application/{applicationId}</strong></li>
<li><strong class="source-inline">GET /rdaas/customer/{id}/application</strong></li>
</ul>
<p>The first REST endpoint returns the application document based on <strong class="source-inline">applicationId</strong>, while the second REST endpoint returns all the applications of a given customer using <strong class="source-inline">customerId</strong> as the search criteria.</p>
<p>The <strong class="source-inline">MongoConfig</strong> class is used to configure and initialize <strong class="source-inline">mongoTemplate</strong> and <strong class="source-inline">MongoRepository</strong>. We create a custom <strong class="source-inline">MongoRepository</strong> called <strong class="source-inline">ApplicationRepository</strong> that uses <strong class="source-inline">QueryDSL</strong> to dynamically generate custom MongoDB queries at runtime. The controller class uses the <strong class="source-inline">ApplicationRepository</strong> class to connect to MongoDB and fetch document(s) from the collection as per the request.</p>
<p>With that, we have analyzed the problem and created a solution design. Now, let’s discuss how we can implement this solution. First, we will develop the Spring Boot REST application.</p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor152"/>Implementing the Spring Boot REST application</h2>
<p>In this section, we will learn how to<a id="_idIndexMarker999"/> build the Spring Boot application to implement the solution we designed in the preceding section.</p>
<p>First, we must create a Maven project using our IDE and add the following Spring dependencies:</p>
<pre class="source-code">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
<p>These dependencies ensure that all the Spring Boot basic dependencies, as well as the REST-based dependencies, are fulfilled. However, we must add dependencies related to MongoDB. The following dependencies are related to Spring’s MongoDB integration, as well as the necessary QueryDSL dependencies, to write custom MongoDB queries via the Spring JPA implementation:</p>
<pre class="source-code">&lt;!-- mongoDB dependencies --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;!-- Add support for Mongo Query DSL --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.querydsl&lt;/groupId&gt;
    &lt;artifactId&gt;querydsl-mongodb&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
    &lt;exclusions&gt;
        &lt;exclusion&gt;
            &lt;groupId&gt;org.mongodb&lt;/groupId&gt;
            &lt;artifactId&gt;mongo-java-driver&lt;/artifactId&gt;
        &lt;/exclusion&gt;
    &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.querydsl&lt;/groupId&gt;
    &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;
    &lt;version&gt;5.0.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;!-- https://mvnrepository.com/artifact/javax.annotation/javax.annotation-api --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;javax.annotation&lt;/groupId&gt;
    &lt;artifactId&gt;javax.annotation-api&lt;/artifactId&gt;
    &lt;version&gt;1.3.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
<p>Apart from these dependencies, we need to add build plugins to the <strong class="source-inline">pom.xml</strong> file. These plugins help generate Q classes<a id="_idIndexMarker1000"/> dynamically, which are required for QueryDSL to work properly. The following plugins need to be added:</p>
<pre class="source-code">&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
    &lt;/plugin&gt;
    &lt;!-- Add plugin for Mongo Query DSL --&gt;
    &lt;plugin&gt;
        &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;
        &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;
        &lt;version&gt;1.1.3&lt;/version&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.querydsl&lt;/groupId&gt;
                &lt;artifactId&gt;querydsl-apt&lt;/artifactId&gt;
                &lt;version&gt;5.0.0&lt;/version&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;executions&gt;
            &lt;execution&gt;
                &lt;phase&gt;generate-sources&lt;/phase&gt;
                &lt;goals&gt;
                    &lt;goal&gt;process&lt;/goal&gt;
                &lt;/goals&gt;
                &lt;configuration&gt;
                    &lt;outputDirectory&gt;target/generated-sources/apt&lt;/outputDirectory&gt;
                    &lt;processor&gt;org.springframework.data.mongodb.repository.support.MongoAnnotationProcessor&lt;/processor&gt;
                    &lt;logOnlyOnError&gt;false&lt;/logOnlyOnError&gt;
                &lt;/configuration&gt;
            &lt;/execution&gt;
        &lt;/executions&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;</pre>
<p>Now that we have added all the <a id="_idIndexMarker1001"/>necessary dependencies, we will create the entry point, or the <strong class="source-inline">main</strong> class, of our Spring Boot application, as follows:</p>
<pre class="source-code">@SpringBootApplication(scanBasePackages = "com.scalabledataarch.rest")
public class RestDaaSApp {
    public static void main(String[] args) {
        SpringApplication.run(RestDaaSApp.class);
    }
}</pre>
<p>As per the preceding code, all the Bean components in the <strong class="source-inline">com.scalabledataarch.rest</strong> package will be scanned recursively and instantiated when the Spring Boot application is<a id="_idIndexMarker1002"/> started. Now, let’s create Mongo configuration beans using the <strong class="source-inline">Configuration</strong> class called <strong class="source-inline">MongoConfig</strong>. The source code for the same is as follows:</p>
<pre class="source-code">@Configuration
@EnableMongoRepositories(basePackages = "com.scalabledataarch.rest.repository")
public class MongoConfig {
    @Value(value = "${restdaas.mongoUrl}")
    private String mongoUrl;
    @Value(value = "${restdaas.mongoDb}")
    private String mongoDb;
    @Bean
    public MongoClient mongo() throws Exception {
        final ConnectionString connectionString = new ConnectionString(mongoUrl);
        final MongoClientSettings mongoClientSettings = MongoClientSettings.builder().applyConnectionString(connectionString).serverApi(ServerApi.builder()
                .version(ServerApiVersion.V1)
                .build()).build();
        return MongoClients.create(mongoClientSettings);
    }
    @Bean
    public MongoTemplate mongoTemplate() throws Exception {
        return new MongoTemplate(mongo(), mongoDb);
    }
}</pre>
<p>As we can see, the <strong class="source-inline">MongoConfig</strong> class is<a id="_idIndexMarker1003"/> annotated with <strong class="source-inline">@EnableMongoRepositories</strong>, where the base package of the repositories is configured. All classes extending the <strong class="source-inline">MongoRepository</strong> interface under the base package will be scanned and Spring beans will be created. Apart from that, we have created the <strong class="source-inline">MongoClient</strong> and <strong class="source-inline">MongoTemplate</strong> beans. Here, we used the <strong class="source-inline">com.mongodb.client.MongoClients</strong> API to create the <strong class="source-inline">MongoClient</strong> bean.</p>
<p>Next, we will create a model class that can hold the deserialized data from a MongoDB document. We can create the model <strong class="source-inline">Application</strong> class as follows:</p>
<pre class="source-code">import com.querydsl.core.annotations.QueryEntity;
import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
@QueryEntity
@Document(collection = "newloanrequest")
public class Application  {
    @Id
    private String _id;
    private String applicationId;</pre>
<p>It is important to annotate the class with <strong class="source-inline">@Document</strong> and give the value of the collection name as its argument for <strong class="source-inline">spring-data-mongo</strong> to understand that this POJO represents a MongoDB document<a id="_idIndexMarker1004"/> structure for the specified collection. Also, annotating with <strong class="source-inline">@QueryEntity</strong> is essential for QueryDSL to generate Q classes dynamically using <strong class="source-inline">apt-maven-plugin</strong>. </p>
<p>Now, we will use this <strong class="source-inline">Application</strong> POJO to write our custom Mongo repository, as shown in the following code:</p>
<pre class="source-code">public interface ApplicationRepository extends MongoRepository&lt;Application, String&gt;, QuerydslPredicateExecutor&lt;Application&gt; {
    @Query("{ 'applicationId' : ?0 }")
    Application findApplicationsById(String applicationId);
    @Query("{ 'id' : ?0 }")
    List&lt;Application&gt; findApplicationsByCustomerId(String id);
}</pre>
<p>To implement a custom repository, it must implement or extend the <strong class="source-inline">MongoRepository</strong> interface. Since our <strong class="source-inline">ApplicationRepository</strong> uses QueryDSL, it must extend <strong class="source-inline">QuerydslPredicateExecutor</strong>. We can specify a Mongo query using the <strong class="source-inline">@Query</strong> annotation, as shown in the preceding code, which will be executed when the corresponding <a id="_idIndexMarker1005"/>method is called.</p>
<p>Now, we will create a controller class called <strong class="source-inline">DaasController</strong>. The <strong class="source-inline">DaasController</strong> class should be annotated with the <strong class="source-inline">@RestController</strong> annotation to indicate that it is a Spring component that publishes REST endpoints. A basepath to the endpoints in <strong class="source-inline">DaaSController</strong> can be created using the <strong class="source-inline">@RequestMapping</strong> annotation, as shown in the following code snippet:</p>
<pre class="source-code">@RestController
@RequestMapping(path = "/rdaas")
public class DaasController {
...
}</pre>
<p>Now, we will add our methods, each corresponding to a REST endpoint. The following code shows the source code for one of the methods:</p>
<pre class="source-code">...
@Autowired
ApplicationRepository applicationRepository;
@GetMapping(path= "/application/{applicationId}", produces = "application/json")
public ResponseEntity&lt;Application&gt; getApplicationById(@PathVariable String applicationId){
  Application application = applicationRepository.findById(applicationId).orElseGet(null);
  return ResponseEntity.ok(application);
}
...</pre>
<p>As we can see, the method that will be triggered when a REST endpoint call is made is annotated with <strong class="source-inline">@GetMapping</strong> or <strong class="source-inline">@PostMapping</strong>, based on the HTTP method type. In our case, we need a <strong class="source-inline">GET</strong> request. Each mapping<a id="_idIndexMarker1006"/> should be accompanied by the URL path and the other necessary properties as parameters for these annotations. In this method, the autowired <strong class="source-inline">applicationRepository</strong> bean is used to fetch Mongo documents using the <strong class="source-inline">applicationId</strong> field.</p>
<p>Finally, we will create <strong class="source-inline">application.yml</strong> to set up the configuration parameters to run the Spring Boot application. The <strong class="source-inline">application.yml</strong> file in our case will look as follows:</p>
<pre class="source-code">restdaas:
  mongoUrl: &lt;mongo url&gt;
  mongoDb: newloanrequest</pre>
<p>As shown in the source code of the <strong class="source-inline">application.yml</strong> file earlier, we configure various Mongo connectivity details in the <strong class="source-inline">application.yml</strong> file.</p>
<p>Now, we can run the application from our local machine by running the <strong class="source-inline">main</strong> class and test it using Postman, as follows:</p>
<ol>
<li>First, click the <strong class="bold">+</strong> button in the <strong class="bold">Collections</strong> tab to create a new collection named <strong class="source-inline">ApplicationDaaS</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer177">
<img alt="Figure 9.4 – Creating a new Postman collection " height="236" src="image/B17084_09_004.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Creating a new Postman collection</p>
<ol>
<li value="2">Add a request to the collection using the <strong class="bold">Add request</strong> option, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer178">
<img alt="Figure 9.5 – Adding a request to the Postman collection " height="574" src="image/B17084_09_005.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Adding a request to the Postman collection</p>
<ol>
<li value="3">Next, fill in the configurations for the HTTP method, REST URL, and headers. Now, you can execute the<a id="_idIndexMarker1007"/> request using the <strong class="bold">Send</strong> button, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer179">
<img alt="Figure 9.6 – Testing the REST API via Postman " height="999" src="image/B17084_09_006.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Testing the REST API via Postman</p>
<p>Now that we have tested the application locally, let’s see how we can deploy it in ECR. Follow these steps to deploy in ECR:</p>
<ol>
<li value="1">First, we need to containerize this application. To do that, we must create our Docker file. The source code for this <strong class="source-inline">DockerFile</strong> is as follows:<p class="source-code">FROM openjdk:11.0-jdk</p><p class="source-code">VOLUME /tmp</p><p class="source-code">RUN useradd -d /home/appuser -m -s /bin/bash appuser</p><p class="source-code">USER appuser</p><p class="source-code">ARG JAR_FILE</p><p class="source-code">COPY ${JAR_FILE} app.jar</p><p class="source-code">EXPOSE 8080</p><p class="source-code">ENTRYPOINT ["java","-jar","/app.jar"]</p></li>
</ol>
<p>Here, the first line imports<a id="_idIndexMarker1008"/> the base image, which contains the preconfigured OpenJDK 11 software. There, we create a volume called <strong class="source-inline">/tmp</strong>. Then, we add a new user to this Docker container called <strong class="source-inline">appuser</strong> using the <strong class="source-inline">RUN useradd</strong> command. Using the <strong class="source-inline">USER</strong> command, we log in as <strong class="source-inline">appuser</strong>. Then, we copy the JAR file to <strong class="source-inline">app.jar</strong>. The JAR file path is passed as an argument to this <strong class="source-inline">DockerFile</strong>. Passing the JAR file path as<a id="_idIndexMarker1009"/> an argument will help us in the future if we want to build a <strong class="bold">continuous integration and continuous deployment</strong> (<strong class="bold">CI/CD</strong>) pipeline for this application. Then, port <strong class="source-inline">8080</strong> is exposed from the container. Finally, we run the <strong class="source-inline">java -jar</strong> command using the <strong class="source-inline">ENTRYPOINT</strong> command.</p>
<ol>
<li value="2">Now, we can build the Docker image by running the following command from a command line or Terminal:<p class="source-code"><strong class="bold">docker build -t apprestdaas:v1.0 .</strong></p></li>
<li>This will create a Docker image called <strong class="source-inline">apprestdaas</strong> with a tag of <strong class="source-inline">v1.0</strong> in the local Docker image repository. You can either view the image listed in Docker Desktop or a Terminal by using the following command:<p class="source-code"><strong class="bold">docker images</strong></p></li>
</ol>
<p>Now that we have created the Docker<a id="_idIndexMarker1010"/> image, let’s discuss how can we deploy this image in an ECS cluster.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor153"/>Deploying the application in an ECS cluster</h2>
<p>In this section, we will discuss how to<a id="_idIndexMarker1011"/> deploy our REST application in an AWS ECS cluster. Follow these steps:</p>
<ol>
<li value="1">First, we are going to create a<a id="_idIndexMarker1012"/> repository in AWS ECR to store our Docker image. We will require the <strong class="bold">Amazon Resource Name</strong> (<strong class="bold">ARN</strong>) for this repository to<a id="_idIndexMarker1013"/> tag and upload the image. First, we will navigate to ECR in the AWS Management Console and click <strong class="bold">Create repository</strong>. You’ll see a <strong class="bold">Create repository</strong> page, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer180">
<img alt="Figure 9.7 – The Create repository page " height="772" src="image/B17084_09_007.jpg" width="1144"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – The Create repository page</p>
<p>Here, fill in the repository’s name, leave<a id="_idIndexMarker1014"/> the rest of the fields as-is, and submit the request. Once it has been <a id="_idIndexMarker1015"/>created, you will be able to see the repository listed on ECR’s <strong class="bold">Private repositories</strong> page, as shown here:</p>
<div>
<div class="IMG---Figure" id="_idContainer181">
<img alt="Figure 9.8 – The ECR repository has been created  " height="614" src="image/B17084_09_008.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – The ECR repository has been created </p>
<ol>
<li value="2">Download the latest AWS CLI and install it. Then, configure the AWS CLI using the following command:<p class="source-code"><strong class="bold">aws configure</strong></p></li>
</ol>
<p>While configuring the AWS CLI, you need to provide the access key ID and the secret access key. You can generate <a id="_idIndexMarker1016"/>these variables by following the instructions at <a href="https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey">https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_access-keys.xhtml#Using_CreateAccessKey</a>.</p>
<ol>
<li value="3">Next, we need to generate an ECR login token for Docker using the following command:<p class="source-code"><strong class="bold">aws ecr get-login-password --region &lt;region&gt;</strong></p></li>
</ol>
<p>When you run this command, an authentication token will be generated that is needed by Docker to push the<a id="_idIndexMarker1017"/> image to ECR. We can pipe the previous command with the following command, where we directly pass the token to a <strong class="source-inline">docker login</strong> command. The final command looks like this:</p>
<p class="source-code"><strong class="bold">aws ecr get-login-password --region &lt;region&gt; | docker login --username AWS --password-stdin &lt;accountid&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com</strong></p>
<p>In the preceding command, please replace <strong class="source-inline">region</strong> with the correct AWS region, such as <strong class="source-inline">us-east-2</strong> or <strong class="source-inline">us-east-1</strong>, and <strong class="source-inline">accountid</strong> with the correct AWS account ID.</p>
<ol>
<li value="4">Next, we will tag the local Docker image with the ECR repository URI. This is required for ECR to map the correct repository with the image we are pushing. The command for this is as follows: <p class="source-code"><strong class="bold">docker tag apprestdaas:v10 &lt;accountid&gt;.dkr.ecr.&lt;region&gt;.amazonaws.com/restdaas:v1</strong></p></li>
<li>Now, we will use the following command to push the Docker image into the ECR repository:<p class="source-code"><strong class="bold">docker push &lt;accountid&gt;.dkr.ecr.us-east-2.amazonaws.com/restdaas:v1</strong></p></li>
</ol>
<p>Upon running this command, the local Docker image will be pushed to the ECR repository with the <strong class="source-inline">restdaas:v1</strong> tag.</p>
<ol>
<li value="6">Now, let’s create an AWS Fargate <a id="_idIndexMarker1018"/>cluster. To do that, we must log into the AWS Management Console again. Here, search for <strong class="source-inline">Elastic Container Services</strong> and select it. From the <strong class="bold">Elastic Container Service</strong> dashboard, navigate to <strong class="bold">Cluster</strong> in the left <a id="_idIndexMarker1019"/>pane and select <strong class="bold">Create Cluster</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer182">
<img alt="Figure 9.9 – Creating an ECS cluster " height="614" src="image/B17084_09_009.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Creating an ECS cluster</p>
<ol>
<li value="7">Next, set the cluster template to <strong class="bold">Networking only</strong> and click <strong class="bold">Next step</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer183">
<img alt="Figure 9.10 – Selecting an ECS cluster template " height="828" src="image/B17084_09_010.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Selecting an ECS cluster template</p>
<ol>
<li value="8">Then, enter the name of the <a id="_idIndexMarker1020"/>cluster. Here, we will name it <strong class="source-inline">daas-cluster</strong>. Leave the other fields as-is. Now, click the <strong class="bold">Create</strong> button to<a id="_idIndexMarker1021"/> create the new ECS cluster:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer184">
<img alt="Figure 9.11 – Naming and creating the ECS cluster " height="973" src="image/B17084_09_011.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Naming and creating the ECS cluster</p>
<ol>
<li value="9">Now, we will create an ECS task. From<a id="_idIndexMarker1022"/> the dashboard of AWS ECS console, select <strong class="bold">Task Definition</strong> from the left menu <a id="_idIndexMarker1023"/>and then click on <strong class="bold">Create new Task Definition</strong>, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer185">
<img alt="Figure 9.12 – Creating a new task definition " height="608" src="image/B17084_09_012.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Creating a new task definition</p>
<ol>
<li value="10">Then, under <strong class="bold">Select launch type compatibility</strong>, choose <strong class="bold">FARGATE</strong> and click <strong class="bold">Next step</strong>, as shown in the following<a id="_idIndexMarker1024"/> screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer186">
<img alt="Figure 9.13 – Selecting the launch type for the ECS task " height="1033" src="image/B17084_09_013.jpg" width="1646"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.13 – Selecting the launch type for the ECS task</p>
<ol>
<li value="11">Next, we <a id="_idIndexMarker1025"/>must set <strong class="bold">Task definition name</strong> to <strong class="source-inline">restdaas</strong>. Set <strong class="bold">Task role</strong> to <strong class="bold">None</strong> and <strong class="bold">Operating system family</strong> to <strong class="bold">Linux</strong>, as shown in<a id="_idIndexMarker1026"/> the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer187">
<img alt="Figure 9.14 – Setting up a task definition " height="1035" src="image/B17084_09_014.jpg" width="1608"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.14 – Setting up a task definition</p>
<p>Leave <strong class="bold">Task execution role</strong> as-is, set <strong class="bold">Task memory (GB)</strong> to <strong class="bold">1GB</strong>, and <a id="_idIndexMarker1027"/>set <strong class="bold">Task CPU (vCPU)</strong> to <strong class="bold">0.5 vCPU</strong>, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer188">
<img alt="Figure 9.15 – Choosing Task memory and Task CPU (vCPU) values " height="1304" src="image/B17084_09_015.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.15 – Choosing Task memory and Task CPU (vCPU) values</p>
<ol>
<li value="12">Now, we will add a container to<a id="_idIndexMarker1028"/> the ECS task. We can add the container by clicking on the <strong class="bold">Add container</strong> button shown in the preceding<a id="_idIndexMarker1029"/> screenshot. A window will appear where we must enter <strong class="source-inline">restdaas</strong> as the container name and populate the ECR ARN of our image, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer189">
<img alt="Figure 9.16 – Adding a container to the ECS task " height="1019" src="image/B17084_09_016.jpg" width="1290"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.16 – Adding a container to the ECS task</p>
<ol>
<li value="13">Click the <strong class="bold">Add</strong> button to add a<a id="_idIndexMarker1030"/> container. Then, click the <strong class="bold">Create</strong> button on the <strong class="bold">Create new Task Definition</strong> page. This will create the<a id="_idIndexMarker1031"/> new task, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer190">
<img alt="Figure 9.17 – ECS task created " height="434" src="image/B17084_09_017.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.17 – ECS task created</p>
<p>As shown in the previous<a id="_idIndexMarker1032"/> screenshot, the task we’ve created, <strong class="bold">restdaas</strong>, is in an <strong class="bold">ACTIVE</strong> state but it is not running. </p>
<ol>
<li value="14">Now, let’s run the task. Click on the <strong class="bold">ACTION</strong> dropdown button and select <strong class="bold">Run Task</strong>. This submits the task so <a id="_idIndexMarker1033"/>that it can be in runnable status. On clicking <strong class="bold">Run Task</strong>, a screen will appear where we must fill out various configurations for running the task, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer191">
<img alt="Figure 9.18 – Run Task " height="969" src="image/B17084_09_018.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.18 – Run Task</p>
<p>Set <strong class="bold">Launch type</strong> to <strong class="bold">FARGATE</strong> and <strong class="bold">Operating system family</strong> to <strong class="bold">Linux</strong>. Also, select any available VPC and subnet<a id="_idIndexMarker1034"/> group, as shown in the following<a id="_idIndexMarker1035"/> screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer192">
<img alt="Figure 9.19 – Setting the VPC and security groups  " height="889" src="image/B17084_09_019.jpg" width="1378"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.19 – Setting the VPC and security groups </p>
<ol>
<li value="15">As shown in the preceding screenshot, please<a id="_idIndexMarker1036"/> make sure that <strong class="bold">Auto-assign public IP</strong> is set to <strong class="bold">ENABLED</strong>. Also, modify the security <a id="_idIndexMarker1037"/>group so that you can add a custom TCP that allows port <strong class="source-inline">8080</strong> since our Spring Boot application will be running on port <strong class="source-inline">8080</strong>, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer193">
<img alt="Figure 9.20 – Allowing port 8080  " height="817" src="image/B17084_09_020.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.20 – Allowing port 8080 </p>
<ol>
<li value="16">Leave the other fields <a id="_idIndexMarker1038"/>as-is and click <strong class="bold">Run Task</strong>. By refreshing<a id="_idIndexMarker1039"/> the <strong class="bold">Task</strong> tab, we can see that the task changes state from <strong class="bold">PROVISIONING</strong> to <strong class="bold">RUNNING</strong>. The following screenshot shows a <strong class="bold">RUNNING</strong> task:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer194">
<img alt="Figure 9.21 – Task in the RUNNING state " height="804" src="image/B17084_09_021.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.21 – Task in the RUNNING state</p>
<ol>
<li value="17">Now, we will test the DaaS that we’ve deployed in ECS. To do that, click on the text under the <strong class="bold">Task</strong> column shown in the <a id="_idIndexMarker1040"/>preceding screenshot. This takes us to the <strong class="bold">Running task</strong> screen, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer195">
<img alt="Figure 9.22 – Running task details " height="756" src="image/B17084_09_022.jpg" width="1629"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.22 – Running task details</p>
<p>As highlighted in the preceding screenshot, we will get the public IP. We will use this IP for testing purposes. Now, from Postman, we can test our REST endpoints using this IP<a id="_idIndexMarker1041"/> address and port <strong class="source-inline">8080</strong>, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer196">
<img alt="Figure 9.23 – Testing the REST endpoint that was deployed in AWS ECS " height="905" src="image/B17084_09_023.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.23 – Testing the REST endpoint that was deployed in AWS ECS</p>
<p>In this section, we learned how to develop a REST<a id="_idIndexMarker1042"/> application to publish the DaaS, containerize the application, deploy it in an AWS ECS cluster, and test the endpoints. In the next section, we will understand the need for API management, and we will provide a step-by-step guide to attaching the API management layer to the REST endpoints that we developed and deployed in this section.</p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor154"/>API management</h1>
<p>API management is a set of tools and <a id="_idIndexMarker1043"/>technologies that allows us to distribute, analyze, and control APIs that expose data and services across the organization. It can act like a wrapper on top of the APIs, whether they are deployed on-premises or in the cloud. It is always a good idea to use API management while we are architecting a solution to publish data via an API. First, let’s understand what API management is and how it helps. The following diagram shows where and how the API management layer helps:</p>
<div>
<div class="IMG---Figure" id="_idContainer197">
<img alt="Figure 9.24 – How API management helps " height="287" src="image/B17084_09_024.jpg" width="607"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.24 – How API management helps</p>
<p>As we can see, API management is a <a id="_idIndexMarker1044"/>wrapper layer that sits between the customer-facing API and the internal service API. We can define resources and methods in the API management layer that get exposed to the customer. Primarily, an architecture gets the following benefits while using an API management layer:</p>
<ul>
<li><strong class="bold">Flexibility</strong>: API management enables<a id="_idIndexMarker1045"/> easy deployment in a different environment by enabling continuous deployment and testing. It also provides a unified interface where a single customer-facing API can be fetched from multiple complex internal service APIs. This enables easy integration and allows you to publish resources without the need to create extra APIs to integrate and manage multiple APIs. On the other hand, in a very dynamic technological landscape, chances are that internal service APIs may be updated or their structure may change frequently. The API management layer gives us easy access to move from an older internal service API to a new one without changing or affecting the customer-facing API. This gives us huge flexibility in design and helps us overcome technical debts in the internal service API layer without any hassle.</li>
<li><strong class="bold">Security</strong>: API management provides security in different ways. First, it enables APIs to have custom authorizers such as OAuth. Second, it enables customer-specific usage plans and API keys. This ensures only a consumer who is registered with a usage plan and API key will be able to access the application. Also, it puts a limit on how many<a id="_idIndexMarker1046"/> transactions a consumer can do per second. This, along with the throttling feature, helps us avoid any <strong class="bold">distributed denial-of-service</strong> (<strong class="bold">DDoS</strong>) attacks on the Service APIs. Apart from these, role-based access can be enabled using the RBAC feature of the API. All these security features make API management a necessary component in designing a DaaS architecture.</li>
<li><strong class="bold">Documentation</strong>: This allows you to easily create, publish, and maintain the documentation of the API. The published documentation can be easily accessed by consumers of the API, making their lives easy. Apart from this, even the <em class="italic">Swagger</em> and <em class="italic">OpenAPI</em> specifications can be published and maintained using API management.</li>
<li><strong class="bold">Analysis</strong>: One of the major advantages of using API management is the ability to monitor and analyze the traffic, latency, and other parameters while the API is deployed and used in production.</li>
</ul>
<p>In this section, we understood what API management is and how it can help us create a robust architecture for DaaS solutions. In the next section, we will attach an API management layer on top of the ECS REST Service API that we developed earlier.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor155"/>Enabling API management over the DaaS API using AWS API Gateway</h1>
<p>In this section, we will discuss<a id="_idIndexMarker1047"/> how to set up API management <a id="_idIndexMarker1048"/>using AWS API Gateway. We will use the REST DaaS API that we developed and deployed in ECS earlier in this chapter. Follow these steps to set up an API management layer for our REST DaaS API:</p>
<ol>
<li value="1">In the AWS Management Console, search for <strong class="source-inline">AWS API Gateway</strong> and navigate to the <strong class="bold">AWS API Gateway</strong> service dashboard. From here, select <strong class="bold">REST API</strong> and click <strong class="bold">Build</strong>, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer198">
<img alt="Figure 9.25 – The AWS API Gateway dashboard " height="905" src="image/B17084_09_025.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.25 – The AWS API Gateway dashboard</p>
<ol>
<li value="2">A new window will <a id="_idIndexMarker1049"/>open, as shown in the<a id="_idIndexMarker1050"/> following screenshot. Select <strong class="bold">REST</strong> as the protocol and then select <strong class="bold">New API</strong> under <strong class="bold">Create new API</strong>. Fill in the API’s name and a description and click <strong class="bold">Create API</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer199">
<img alt="Figure 9.26 – Creating a REST API " height="671" src="image/B17084_09_026.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.26 – Creating a REST API</p>
<ol>
<li value="3">Once the resource has<a id="_idIndexMarker1051"/> been created, we will be taken<a id="_idIndexMarker1052"/> to the details of the API. We can add resources or methods from the <strong class="bold">Actions</strong> dropdown in this interface, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer200">
<img alt="Figure 9.27 – Adding resources to the API " height="1002" src="image/B17084_09_027.jpg" width="964"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.27 – Adding resources to the API</p>
<p>Here, we will click <strong class="bold">Add Resource</strong> and add a resource whose name and path are both <strong class="source-inline">/loanapplications</strong>. Then, we <a id="_idIndexMarker1053"/>will add another resource under <strong class="source-inline">loanapplications</strong> whose <a id="_idIndexMarker1054"/>name is <strong class="source-inline">appId</strong> and the path is <strong class="source-inline">/{appId}</strong>. Note that <strong class="source-inline">{}</strong> denotes that <strong class="source-inline">appId</strong> is a path variable. Finally, in the <strong class="source-inline">appId</strong> resource, we will add a method by selecting <strong class="bold">Create Method</strong>, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer201">
<img alt="Figure 9.28 – Configuring the GET method " height="732" src="image/B17084_09_028.jpg" width="1175"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.28 – Configuring the GET method</p>
<p>Set <strong class="bold">Integration type</strong> to <strong class="bold">HTTP</strong> and provide an <strong class="bold">Endpoint URL</strong>. Since our resource path has a path variable, the <a id="_idIndexMarker1055"/>same path variable should be present in the <strong class="bold">Endpoint URL</strong> area as well. Here, we <a id="_idIndexMarker1056"/>are mapping the <strong class="source-inline">/loanapplications/{appId}</strong> API resource to the <strong class="source-inline">/rdaas/application/{appId}</strong> DaaS API resource.</p>
<ol>
<li value="4">Deploy the API by choosing the <strong class="bold">Deploy API</strong> option from the <strong class="bold">Actions</strong> dropdown, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer202">
<img alt="Figure 9.29 – Deploy API " height="588" src="image/B17084_09_029.jpg" width="1209"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.29 – Deploy API</p>
<p>Upon doing this, a window will appear, as shown in the following screenshot. Set <strong class="bold">Deployment stage</strong> to <strong class="bold">[New Stage]</strong> and fill in the stage’s name and description. Finally, click <strong class="bold">Deploy</strong>:</p>
<div>
<div class="IMG---Figure" id="_idContainer203">
<img alt="Figure 9.30 – Deploying the API configuration " height="682" src="image/B17084_09_031.jpg" width="1012"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.30 – Deploying the API configuration</p>
<ol>
<li value="5">Now, we will test the <a id="_idIndexMarker1057"/>new customer-facing API via<a id="_idIndexMarker1058"/> Postman. But before that, we must find out the base URL of the API. To do so, navigate to <strong class="bold">Stages</strong> in the left pane and select <strong class="bold">dev</strong>. The <strong class="bold">dev Stage Editor</strong> page will appear, as shown in the following screenshot: </li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer204">
<img alt="Figure 9.31 – Using dev Stage Editor to get the base URL of the API " height="493" src="image/B17084_09_032.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.31 – Using dev Stage Editor to get the base URL of the API</p>
<p>As highlighted in the<a id="_idIndexMarker1059"/> preceding screenshot, we can get<a id="_idIndexMarker1060"/> the base URL.</p>
<p>Now, we can form the customer API by adding the consumer API’s URI to the basepath; for example, <strong class="source-inline">http://&lt;baseurl&gt;/loanapplications/&lt;some_app_id&gt;</strong>. We can use this API and test it in Postman, as shown here:</p>
<div>
<div class="IMG---Figure" id="_idContainer205">
<img alt="Figure 9.32 – Testing the external API exposed by AWS API Gateway (without security) " height="986" src="image/B17084_09_033.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.32 – Testing the external API exposed by AWS API Gateway (without security)</p>
<p>We can also see the dashboard<a id="_idIndexMarker1061"/> to monitor the API, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer206">
<img alt="Figure 9.33 – AWS API Gateway dashboard for RESTDaasAPI " height="937" src="image/B17084_09_034.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.33 – AWS API Gateway dashboard for RESTDaasAPI</p>
<p>From this dashboard, we<a id="_idIndexMarker1062"/> can gather useful information about the number of API calls made every day. We can also monitor the<a id="_idIndexMarker1063"/> latency of the response or any internal server errors that have been noticed over time.</p>
<p>Now that we have added the API management layer, we will try to add API key-based security to the consumer-facing API.</p>
<ol>
<li value="6">Navigate to the <strong class="bold">Resource</strong> pane of <strong class="bold">RestDaasAPI</strong> and select the <strong class="bold">GET</strong> method under the <strong class="bold">{appId}</strong> resource. In the configuration, change the value of the required API key from <strong class="bold">false</strong> to <strong class="bold">true</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer207">
<img alt="Figure 9.34 – Changing the API key’s required value to true " height="931" src="image/B17084_09_035.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.34 – Changing the API key’s required value to true</p>
<p>Then, navigate to <strong class="bold">Usage Plans</strong> and<a id="_idIndexMarker1064"/> create a usage plan. Set the API-level throttling parameters and monthly quota, as shown in the <a id="_idIndexMarker1065"/>following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer208">
<img alt="Figure 9.35 – Create Usage Plan " height="761" src="image/B17084_09_036.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.35 – Create Usage Plan</p>
<p>Click <strong class="bold">Next</strong> and set the method-level throttling parameters, as shown here:</p>
<div>
<div class="IMG---Figure" id="_idContainer209">
<img alt="Figure 9.36 – Configuring the method-level throttling parameters " height="365" src="image/B17084_09_037.jpg" width="1232"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.36 – Configuring the method-level throttling parameters</p>
<ol>
<li value="7">Click <strong class="bold">Next</strong> and set up a new API<a id="_idIndexMarker1066"/> key for this usage<a id="_idIndexMarker1067"/> plan by clicking the <strong class="bold">Create API Key and add to Usage Plan</strong> button:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer210">
<img alt="Figure 9.37 – Generating a new API key to attach to the usage plan " height="334" src="image/B17084_09_038.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.37 – Generating a new API key to attach to the usage plan</p>
<ol>
<li value="8">Once you have clicked this, the <strong class="bold">API Key</strong> window will appear. Provide a name and description. Also, set <strong class="bold">API key*</strong> to <strong class="bold">Auto Generate</strong>:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer211">
<img alt="Figure 9.38 – The API Key window " height="707" src="image/B17084_09_039.jpg" width="930"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.38 – The API Key window</p>
<ol>
<li value="9">Once we have saved the newly<a id="_idIndexMarker1068"/> generated API key<a id="_idIndexMarker1069"/> and created the usage plan, we can get the API key’s value by navigating to <strong class="bold">API Keys</strong> and clicking on the <strong class="bold">Show</strong> option. By doing so, we can view the generated API key:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer212">
<img alt="Figure 9.39 – Showing the generated API key by clicking Show (highlighted) " height="601" src="image/B17084_09_040.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.39 – Showing the generated API key by clicking Show (highlighted)</p>
<ol>
<li value="10">Once you have set up the API key as required in the API, and if you do not provide <strong class="source-inline">apikey</strong> in the header while invoking the REST endpoint, you will get an error message in the response body, similar to <strong class="source-inline">{"message":"Forbidden"}</strong>. Now, you must add a header called <strong class="source-inline">x-api-key</strong> whose value should be the<a id="_idIndexMarker1070"/> API key that you generated in <em class="italic">Step 9</em>. Then, you can test the secure API via Postman, along with the API key, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer213">
<img alt="Figure 9.40 – Testing the external API exposed by AWS API Gateway (with Security) " height="939" src="image/B17084_09_041.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.40 – Testing the external API exposed by AWS API Gateway (with Security)</p>
<p>In this section, we learned how to<a id="_idIndexMarker1071"/> create an API management layer on top of our REST DaaS API. We also discussed how AWS API Gateway can help to monitor and secure the API.</p>
<p>Now, let’s summarize what we’ve learned in this chapter.</p>
<h1 id="_idParaDest-155"><a id="_idTextAnchor156"/>Summary</h1>
<p>In this chapter, we learned about the basics of DaaS. First, we discussed how to develop and test REST-based DaaS APIs using Spring Boot. Then, we learned how to containerize the application and publish the containers to the AWS ECR repository. We also learned how to deploy the containers published in the AWS ECR repository to an AWS ECS cluster. After that, we learned how to run this application using the cloud-managed Fargate service. Then, we learned about API management and its benefits. Finally, we implemented an API management layer to provide security and monitoring on top of our REST DaaS API using AWS API Gateway.</p>
<p>Now that we have learned how to build, deploy, publish, and manage a REST-based DaaS API, in the next chapter, we will learn how and when a GraphQL-based DaaS can be a good design choice. We will also learn how to design and develop a GraphQL DaaS API.</p>
</div>
</div>
</body></html>