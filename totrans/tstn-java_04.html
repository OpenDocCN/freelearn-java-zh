<html><head></head><body>
		<div id="_idContainer042">
			<h1 id="_idParaDest-77" class="chapter-number"><a id="_idTextAnchor086"/>4</h1>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor087"/>Language Fundamentals – Data Types and Variables</h1>
			<p>Now that we are comfortable (I hope) with basic Java tooling, we are ready to look at the language itself. As you are already a developer, there is no need to cover low-level concepts, such as what a variable is, in this chapter. So, this chapter will take advantage of what you already know and introduce you to the data types available in Java and the operations we can perform on them. </p>
			<p>In this chapter, you will learn about <span class="No-Break">the following:</span></p>
			<ul>
				<li><span class="No-Break">Type safety</span></li>
				<li>The eight primitive <span class="No-Break">data types</span></li>
				<li><span class="No-Break">Literal values</span></li>
				<li>The <strong class="source-inline">String</strong> <span class="No-Break">data type</span></li>
				<li><span class="No-Break">Naming identifiers</span></li>
				<li><span class="No-Break">Constants</span></li>
				<li>Operations <span class="No-Break">on data</span></li>
				<li><span class="No-Break">Casting</span></li>
				<li>Overflow <span class="No-Break">and underflow</span></li>
				<li>The <span class="No-Break">math class</span></li>
			</ul>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor088"/>Technical requirements</h1>
			<p>Here are the tools required to run the examples in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Text Editor</span></li>
				<li>Maven 3.8.6 or a <span class="No-Break">newer version</span></li>
			</ul>
			<p>You can find the code from this chapter in the GitHub repo <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04"><span class="No-Break">https://github.com/PacktPublishing/Transitioning-to-Java/tree/chapter04</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Ubuntu and other Linux distributions may have a version of Maven already installed. If it is not version 3.8.6 or greater, you must replace it with the <span class="No-Break">newest version.</span></p>
			<h1 id="_idParaDest-80"><a id="_idTextAnchor089"/>Primitive data types</h1>
			<p><strong class="bold">Primitive data types</strong> create<a id="_idIndexMarker291"/> value variables. This means that once you declare variables in a program, you can use them in your code. However, before being represented by reference variables, classes must be instantiated into objects. But the values do not need to be instantiated. </p>
			<p>In the <strong class="source-inline">CompoundInterest</strong> program, we needed to instantiate the <strong class="source-inline">CompoundInterestCalculation</strong> class before we can use it, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
var banker = new CompoundInterestCalculator04();</pre>
			<p>On the other hand, when we needed variables to hold <strong class="source-inline">principal</strong>, <strong class="source-inline">annualInterestRate</strong>, <strong class="source-inline">compoundPerTimeUnit</strong>, and <strong class="source-inline">time</strong>, we simply declared them, as shown in the following code line – we are directly assigning a value to the variable. We did not add the <strong class="source-inline">new</strong> operator, which is responsible for converting classes into objects. Primitive data types are ready <span class="No-Break">to go:</span></p>
			<pre class="source-code">
double principal = 100.0;</pre>
			<p>There are eight primitive types in Java. Before we look at them, let us quickly see what type <span class="No-Break">safety means.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor090"/>Type safety</h2>
			<p>Depending<a id="_idIndexMarker292"/> on <a id="_idIndexMarker293"/>the language you are coming from on your path to Java, the concept of <strong class="bold">type safety</strong> may or may not be something you are familiar with. One form of type safety means that every variable must show its type when declared, and this type cannot change. You cannot assign an integer variable to a string. If you do this, you will get an error message as an exception. This is <span class="No-Break">static typing.</span></p>
			<p>The alternative to static typing is dynamic typing. Here, it is not necessary to declare the type of the variable. Java infers the type from what you assign. It is frequently and incorrectly assumed that dynamic typing is not type-safe. This is not necessarily true. </p>
			<p>How you declare a variable is not at the heart of type safety. Instead, it is how the language handles, at runtime, what happens if a variable’s type does not match the type required. </p>
			<p>Here is a Python<a id="_idIndexMarker294"/> script that demonstrates that Python is type-safe <a id="_idIndexMarker295"/>even though it uses <span class="No-Break">dynamic typing:</span></p>
			<pre class="source-code">
def print_hi(name):
    name = name + 2
    print(f'Hi, {name}') 
if __name__ == '__main__':
    x="bob"
    print_hi(x)</pre>
			<p>In this example, the <strong class="source-inline">print_hi</strong> function is expecting to receive a variable named <strong class="source-inline">name</strong>. The first line of code in this function performs a math operation using the <strong class="source-inline">name</strong> variable. </p>
			<p>In the code that is calling <strong class="source-inline">print_hi</strong>, we are declaring a variable, <strong class="source-inline">x</strong>, as a string. We know this because we are assigning a string to it. In this small snippet of code, it should appear obvious that this will generate an error. It does, and here is the error: </p>
			<pre class="source-code">
<strong class="bold">C:\devapp\PycharmProjects\PythonTest\venv\Scripts\python.exe C:/devapp/PycharmProjects/PythonTest/main.py</strong>
<strong class="bold">Traceback (most recent call last):</strong>
<strong class="bold">  File "C:\devapp\PycharmProjects\PythonTest\main.py", line 8, in &lt;module&gt;</strong>
<strong class="bold">    print_hi(x)</strong>
<strong class="bold">  File "C:\devapp\PycharmProjects\PythonTest\main.py", line 2, in print_hi</strong>
<strong class="bold">    name = name + 2</strong>
<strong class="bold">TypeError: can only concatenate str (not "int") to str</strong>
<strong class="bold">Process finished with exit code 1</strong></pre>
			<p>Python only detects this problem at runtime, but it is an error that will end the program. This means that despite the argument that dynamically typed languages are not type-safe, we have just seen that this is not the case. Python is effectively type-safe. </p>
			<p>Java, on the <a id="_idIndexMarker296"/>other hand, is a statically typed language. Here<a id="_idIndexMarker297"/> is the same code <span class="No-Break">in Java:</span></p>
			<pre class="source-code">
public class TypeSafetyTest {
    private void print_hi(String x) {
        System.out.printf(x);
    }
    
    public void perform() {
        int x = 4;
        print_hi(x);
    }
    
    public static void main(String[] args) {
        var typeTest = new TypeSafetyTest();
        typeTest.perform();
    }
}</pre>
			<p>Notice that <strong class="source-inline">print_hi</strong> clearly expects a string, but in the <strong class="source-inline">perform</strong> method, we are passing an integer. When we run this code with Maven, we will get the following <span class="No-Break">error message:</span></p>
			<pre class="source-code">
<strong class="bold">com/kenfogel/typesafetytest/TypeSafetyTest.java:[12,18] incompatible types: int cannot be converted to java.lang.String</strong></pre>
			<p>In Python, you determine the variable type by where and how you use it. The Python <strong class="source-inline">print_hi</strong> method does not indicate the type of <strong class="source-inline">name</strong>. Only when we see the math expression in the function do we recognize that <strong class="source-inline">name</strong> must be an integer to work. The statically typed Java, by virtue of requiring the type as part of every declaration, makes it easier to spot <span class="No-Break">type errors.</span></p>
			<p>While we are comparing to Python – an excellent language – note that there is a significant difference in each language’s compiler. The Java compiler can incrementally compile a program. The editor in an IDE can detect errors while you type by compiling the code one line at a time. Languages with no incremental compiler, such as Python, can only report errors in an IDE when you compile or run the code. </p>
			<p>Which approach is better? I leave that up to you to decide. </p>
			<p>However, static typing leads to more verbose programs. This means you must enter more code in a Java program compared to Python. On the other hand, static typing makes tracking down type errors easier and enhances the readability of the code. </p>
			<p>One last point about Python – in version 3, the language developers introduced type annotations. These appear in Python code as if you are statically typing a variable. But this is not the <a id="_idIndexMarker298"/>case, as the compiler ignores these <a id="_idIndexMarker299"/>annotations. They<a id="_idIndexMarker300"/> exist to support type checkers, such as what the <strong class="bold">PyCharm</strong> IDE <span class="No-Break">can do.</span></p>
			<p>Before we look at the data types we use when declaring variables, let us take a moment to look at <span class="No-Break">literal values.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor091"/>Literal values</h2>
			<p>A <strong class="bold">literal value</strong> is <a id="_idIndexMarker301"/>one <a id="_idIndexMarker302"/>you enter into source code as a value, not a variable. Java treats a literal number as an integer if the number does not have any decimal places. This means that when you write a literal such as <strong class="source-inline">42</strong>, Java treats this as an integer. Should the literal value exceed the range of an integer when assigned to an integer, you will get an <strong class="source-inline">integer number to large</strong> compiler error. If you assign the literal value to a <strong class="source-inline">long</strong> integer, you must add the letter <strong class="source-inline">L</strong> to the number, such as <strong class="source-inline">14960000000000L</strong>. </p>
			<p>When we write large numbers, we frequently use a separator every three digits to improve legibility. If you want a separator to make the source code easier to read, you can only use the underscore. You cannot use a comma or any other character as a separator. The value <strong class="source-inline">14960000000000L</strong> can be entered <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">14_960_000_000_000L</strong></span><span class="No-Break">.</span></p>
			<p>When working with literal floating-point numbers, the default primitive type is double. If you are assigning a literal double that does not have any decimal places, then add one, rather than adding it <span class="No-Break">like so:</span></p>
			<pre class="source-code">
double value = 100;</pre>
			<p>Enter it in the <span class="No-Break">following manner:</span></p>
			<pre class="source-code">
double value = 100.0;</pre>
			<p>Alternatively, you <a id="_idIndexMarker303"/>could use the suffix <strong class="source-inline">D</strong> for double and <strong class="source-inline">F</strong> for float. You<a id="_idIndexMarker304"/> can write all literal suffixes in upper or lowercase, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
double value = 100D;</pre>
			<p>Now, let us move on to the primitive <span class="No-Break">data types.</span></p>
			<h2 id="_idParaDest-83"><a id="_idTextAnchor092"/>Integers</h2>
			<p>There are four <a id="_idIndexMarker305"/>members of the integer family – <strong class="source-inline">byte</strong>, <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">long</strong>. The<a id="_idIndexMarker306"/> difference is the number of bytes they use to contain a value. Java, like most languages, encodes integers using two’s complement. This means that the range of values for any of the integer types goes from negative to positive values. Like Python, Java does not have unsigned integers, while C, C++, and C# do. </p>
			<p>In the following table, you will find the size in bytes, the allowable range, and how to declare, assign, or declare and initialize all the members of the <span class="No-Break">integer family:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Table_4.1_B19088.jpg" alt="Table 4.1 – Specs for integers and how we can use them&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Figure">Table 4.1 – Specs for integers and how we can use them</p>
			<p>The integer data type on most computers is related to the size of a CPU’s registers. The JVM is a 32-bit virtual machine, meaning that its registers are 32 bits or 4 bytes wide. While the JVM <a id="_idIndexMarker307"/>program is implemented as a 64-bit application, it remains an implementation of a 32-bit computer. </p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor093"/>Floating point</h2>
			<p>Like most<a id="_idIndexMarker308"/> languages, Java uses a subset of the <strong class="bold">IEEE standard binary floating-point numbers</strong> to represent a floating-point value in <a id="_idIndexMarker309"/>memory. In the <em class="italic">Further reading</em> section, you can find links to websites that delve into this physical format. From our perspective, the main interest we have is in accuracy. </p>
			<p>Accuracy is defined as representing a value exactly. We describe integers as accurate because every decimal integer number can be converted into a binary number. We call the conversion<a id="_idIndexMarker310"/> a <span class="No-Break"><strong class="bold">lossless conversion</strong></span><span class="No-Break">.</span></p>
			<p>Not all decimal floating-point values map to a fixed-length binary value, though. One of the best examples is 0.1 in decimal. This is 1 divided by 10. If we divide binary 1 (1) by binary 10 (1010), the result will be an infinitely repeating sequence of 0.00110011001100110011 . . . What this means is that floating point does not have the same accuracy as integers. The IEEE 754 standard deals with this issue, but you must always know that floating-point values are approximations. We call this a <strong class="bold">lossy conversion</strong>. How <a id="_idIndexMarker311"/>accurate or approximate they are is related to the two types of Java’s floating-point data types – <strong class="source-inline">float</strong> and <strong class="source-inline">double</strong>. The measure of accuracy when we convert from decimal to binary floating point and back is referred to as the precision of the result. If a number exceeds the precision, it is considered an approximation of the actual result. </p>
			<p>In the following table, you will find the size in bytes, the allowable range, and how to declare, assign, or declare and initialize all the members of the floating-point family. This information is critical in deciding whether to use double <span class="No-Break">or float:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Table_4.2_B19088.jpg" alt="Table 4.2 – Specs for floating point and how we can use it &#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Figure">Table 4.2 – Specs for floating point and how we can use it </p>
			<p>We usually interpret precision as the number of valid numbers to the right of the decimal place. Float uses 23 bits, and double uses 53 bits. Therefore, thinking in terms of the number of digits is a crude way to define precision; it is about the length of the mantissa as per the IEEE 754 standard. Simply put, doubles, by virtue of their larger mantissa, have a larger range of values and a higher level of precision than float. </p>
			<p>You may now think you should only be using double rather than using float. After all, we all want our results to be as accurate as possible. But the fact that doubles are twice the size in bytes, 64 as opposed to 32, has a performance penalty. In deciding whether to use double or float, consider the range of values and the precision required. For example, the float will be sufficient if the range of values is small and the number of decimal places after the decimal point will never exceed approximately six. The math operations you may perform will also influence your choice. Addition and subtraction are not concerns, but multiplication and division may have an impact. </p>
			<p>The Java compiler can recognize when you assign a floating-point value to an integer variable. You will get a possible lossy conversion from <strong class="source-inline">double</strong> to <strong class="source-inline">int</strong> error if you do. Later in this chapter, we<a id="_idIndexMarker312"/> will look at casting to convert from one numeric data type to another. </p>
			<p>We are now finished with the numeric types – integers and floating points. Now, let’s look at the non-numeric types. </p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor094"/>Boolean</h2>
			<p>The <strong class="bold">Boolean</strong> data <a id="_idIndexMarker313"/>type <a id="_idIndexMarker314"/>represents the value of a single bit – either zero or one. Zero means <strong class="source-inline">false</strong> and one means <strong class="source-inline">true</strong>. In Java, the set of values that you can assign to a Boolean is the <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong> keywords. The result of all logical operations, such as <em class="italic">Is x greater than y?</em>, expressed as <strong class="source-inline">x &gt; y</strong>, always returns a <span class="No-Break">Boolean value.</span></p>
			<p>In Python, you can cast an integer to or from a Boolean value. The C language does not have a Boolean type, so the language uses the integer values of zero for <strong class="source-inline">false</strong> and not zero for <strong class="source-inline">true</strong>. C++ has a Boolean type, but it is just a subset of integers with the zero and one values represented by the <strong class="source-inline">true</strong> and <strong class="source-inline">false</strong> keywords. C++ treats integers as Booleans, the same way C does. </p>
			<p>In Java, a Boolean is a distinct type. You cannot use an integer in place of either <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. This means you cannot use the result of a calculation that may be either zero or not zero, where you require a Boolean type. </p>
			<p>In the following table, you will find the set of allowable values and how to declare, assign, declare, and initialize Booleans. Technically, you only need a single bit to represent <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>. However, there is no machine language or bytecode instruction that can read just one bit. The Java language architects have left the size in bytes of a Boolean up to the specific implementation <span class="No-Break">of Java:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Table_4.3_B19088.jpg" alt="Table 4.3 – Specs for Boolean and how we can use it&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Figure">Table 4.3 – Specs for Boolean and how we can use it</p>
			<p>The CPU <a id="_idIndexMarker315"/>retrieves <a id="_idIndexMarker316"/>data from memory in units of bytes, typically 4 bytes at a time, as this is the word size of the CPU. It cannot directly read a single bit in RAM. Once retrieved and stored in a CPU register, the CPU can determine the state of any bit in a byte. This means that a Boolean can be no smaller than a byte. Java does not define the number of bytes the same way integers and floating points are. The number of bytes a Boolean uses depends on the implementation of the virtual machine. This can mean that the implementation of Java by one organization may use a different number of bytes compared <span class="No-Break">to another.</span></p>
			<p>Booleans are at the heart of decision-making and iteration for many organizations. Now, let’s move on to the data type used to represent the characters of our <span class="No-Break">written language.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor095"/>char</h2>
			<p>The <strong class="source-inline">char</strong> data type<a id="_idIndexMarker317"/> contains the numeric value for 2-byte <a id="_idIndexMarker318"/>Unicode characters. Unicode UTF-8 is a variable-length character encoding from 2 to 4 bytes per character. Currently, Java only supports 2-byte encoding. The first 128 characters are identical to the first 128 characters found in <span class="No-Break">ASCII encoding.</span></p>
			<p>In C and C++, a char is a subset of integers, and you can use it as an integer. Python does not have a character type but uses strings with a length of 1 for a single character. In Java, a char is a unique data type; you cannot use it for an integer as C and C++ allow. You can cast a <strong class="source-inline">char</strong> to an integer or cast an integer to <span class="No-Break">a char.</span></p>
			<p>Take note that a single quotation mark around a single character implies <span class="No-Break">a char.</span></p>
			<p>In the following table, you will find the set of allowable values and how to declare, assign, or declare and initialize <span class="No-Break">a char:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Table_4.4_B19088.jpg" alt="Table 4.4 – Specs for char and how we can use it&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Figure">Table 4.4 – Specs for char and how we can use it</p>
			<p>There is one more table to look at and that is the default value assigned to variables that are not initialized when declared. Variables can be declared as fields in a class or as local variables in a method. Here are the default values <span class="No-Break">for fields:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Default value</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">boolean</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">false</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">byte</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">short</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">long</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0.0f</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">double</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0.0d</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">char</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>\u0000 (Unicode equivalent <span class="No-Break">to null)</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Reference <span class="No-Break">to objects</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">null</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.5 – Default values for fields</p>
			<p>There is no default value for variables declared in a method. Any code that tries to read a local variable that has not been assigned an initial value will result in a <span class="No-Break">compile-time error.</span></p>
			<p>We have now<a id="_idIndexMarker319"/> gone over the eight primitive types. There is <a id="_idIndexMarker320"/>one more type that you can use, similar to a primitive, but it is not primitive. Let’s <span class="No-Break">meet </span><span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-87"><a id="_idTextAnchor096"/>A special case – String</h1>
			<p>A string, with <a id="_idIndexMarker321"/>a <em class="italic">lowercase s</em>, is a list of characters that usually represent a word we may write or speak. <strong class="source-inline">String</strong>, with a <em class="italic">capital S</em>, is a class that contains a list of zero or more characters and numerous operations that you can perform on them. As a class, it normally must be instantiated into an object. As developers commonly use <strong class="source-inline">String</strong> objects, Java can perform the instantiation implicitly whenever you use the assignment operator (<strong class="source-inline">=</strong>) with a <strong class="source-inline">String</strong> variable. When referring to this data type, we always capitalize the first letter. This way, we know that we are referring to the <strong class="source-inline">String</strong> class. We will cover classes and objects in more depth in the coming chapter. </p>
			<p>Let us examine <strong class="source-inline">String</strong> and how we use it. We begin with the <span class="No-Break">specification table:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Table_4.6_B19088.jpg" alt="Table 4.6 – Specs for String and how we can use it&#13;&#10;"/>
				</div>
			</div>
			<p class="IMG---Figure">Table 4.6 – Specs for String and how we can use it</p>
			<p>In this table, <strong class="bold">Size in bytes</strong> refers<a id="_idIndexMarker322"/> to two parts of <strong class="source-inline">String</strong>. The first, called a <strong class="bold">reference</strong>, is a<a id="_idIndexMarker323"/> variable that <a id="_idIndexMarker324"/>contains the address in memory of the <strong class="source-inline">String</strong> object. A reference is like a pointer in other languages, but you cannot manipulate it as you can<a id="_idIndexMarker325"/> in C or C++. The <strong class="bold">length</strong> of this object in memory includes overhead for the object in addition to the characters in the actual text you <span class="No-Break">are storing.</span></p>
			<p>Classes become objects in memory by using the <strong class="source-inline">new</strong> operator in Java, as shown in the previous table. Developers use <strong class="source-inline">String</strong> objects frequently, and Java simplifies its usage by implicitly instantiating it when assigned a value. You can use <strong class="source-inline">new</strong> as shown, but this is rarely written this way. Instead, <strong class="source-inline">String</strong> appears to work like a primitive value for the convenience <span class="No-Break">of programmers.</span></p>
			<p>With the eight primitive types defined along with the one special case, we can now move on to how we can use them in <span class="No-Break">our code.</span></p>
			<h1 id="_idParaDest-88"><a id="_idTextAnchor097"/>Naming identifiers</h1>
			<p>An <strong class="bold">identifier</strong> in any language <a id="_idIndexMarker326"/>is simply the name we assign to a variable, class, or method. We will first focus on naming variables, and in <a href="B19088_05.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Language Fundamentals – Classes</em>, we will look at naming classes <span class="No-Break">and methods.</span></p>
			<p>There are very few rules in Java related to naming identifiers, but for those that are, the compiler enforces them. These are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The first character of an identifier can be one of <span class="No-Break">the following:</span><ul><li>Dollar <span class="No-Break">sign (</span><span class="No-Break"><strong class="source-inline">$</strong></span><span class="No-Break">)</span></li><li><span class="No-Break">Underscore (</span><span class="No-Break"><strong class="source-inline">_</strong></span><span class="No-Break">)</span></li><li>Alpha character (<span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break">–</span><span class="No-Break"><strong class="source-inline">Z</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">a</strong></span><span class="No-Break">–</span><span class="No-Break"><strong class="source-inline">z</strong></span><span class="No-Break">)</span></li></ul></li>
				<li>Subsequent characters can be any of the previously mentioned ones <span class="No-Break">and numbers.</span></li>
			</ul>
			<p>Once you adhere to the rules, the choice of naming is up to you. This is because Java has conventions for naming. A convention is not a rule, and the compiler does not validate them. Instead, conventions are techniques the programming community recommends for a given language. While working in a team, your fellow members expect you to follow these conventions. Here are the conventions for <span class="No-Break">naming variables:</span></p>
			<ul>
				<li>The name of a variable should be a noun; variables are things and <span class="No-Break">not actions.</span></li>
				<li>The first character should be lowercase. The convention for class identifiers requires that its first character be a capital letter. </li>
				<li>When using a name made up of more than one word, use camel case. Each word in the identifier should be lowercase except for the first character. Each subsequent word in the identifier after the first word must begin with a capital letter. It is acceptable if you prefer using the underscore to represent a space in a multi-word identifier rather than camel case. For this usage, all characters should <span class="No-Break">be lowercase.</span></li>
				<li>Do not use abbreviations; use <span class="No-Break">whole words.</span></li>
				<li>Avoid single-character identifiers. There are a limited number of cases where a single character is acceptable, such as for a loop index variable. Otherwise, use meaningful names. </li>
				<li>This table describes the naming conventions for <span class="No-Break">a variable:</span></li>
			</ul>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Convention</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Acceptable</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Unacceptable</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Noun</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">double salary;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">double receive;</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>First <span class="No-Break">character lowercase</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int cars;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int Cars;</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Camel case</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int platesOfPasta;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int platesofpasta;</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Underscore separator</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int plates_of_pasta;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int plates_Of_Pasta;</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Abbreviations</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Never acceptable</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">int lol;</strong> representing layers <span class="No-Break">of lacquer</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.7 – Naming conventions</p>
			<ul>
				<li>You should not<a id="_idIndexMarker327"/> use the dollar sign; the compiler uses it to create identifiers. </li>
				<li>You should not use the underscore as the first character as in other languages, such as C++, because it means the same as the dollar sign as the first character <span class="No-Break">in Java.</span></li>
				<li>Once past the first character, you can use any letter of the alphabet, any number, an underscore, or the dollar sign. </li>
			</ul>
			<p>Now let us look at the length of identifiers compared to other languages in the <span class="No-Break">following table:</span></p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Language</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Maximum # of </strong><span class="No-Break"><strong class="bold">significant characters</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Python</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">79</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Standard C</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">31</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Standard C++</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">1,024</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft C++</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">2,048</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">GNU C++</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Unlimited</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Java</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Unlimited</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.8 – Maximum length of identifiers</p>
			<p>While Java and <strong class="bold">GNU C++</strong> have no restriction on the number of characters in the name of an identifier, you should be reasonable in the number of characters <span class="No-Break">you use.</span></p>
			<p>Coming up with a <a id="_idIndexMarker328"/>meaningful name for identifiers is an important task for making your code readable, so give it some thought. Now, let us look at data that, once assigned a value, cannot <span class="No-Break">be changed.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor098"/>Constants</h2>
			<p>A constant can <a id="_idIndexMarker329"/>be any data type declared with the <strong class="source-inline">final</strong> keyword. It must have a <a id="_idIndexMarker330"/>value assigned when declared, for example, <strong class="source-inline">final double TAX_RATE = </strong><span class="No-Break"><strong class="source-inline">0.05;</strong></span><span class="No-Break">.</span></p>
			<p>If you declare a field in a class as <strong class="source-inline">final</strong>, then you may also assign its value in the class constructor. Once a value is assigned to a constant, however, it cannot be changed. </p>
			<p>The naming rules for constants are the same as identifiers. What differs are the conventions. Constants are nouns written in uppercase. You can use the underscore to separate words in the identifier, as shown in <strong class="source-inline">TAX_RATE</strong> in the <span class="No-Break">previous example.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor099"/>Operators</h2>
			<p>Java supports <a id="_idIndexMarker331"/>the common set of operators found in almost every<a id="_idIndexMarker332"/> language, as shown in the following table: </p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Action</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Operator</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Assignment</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Addition</span></p>
						</td>
						<td class="No-Table-Style">
							<p>x = x + y</p>
						</td>
						<td class="No-Table-Style">
							<p>x += y</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Subtraction</span></p>
						</td>
						<td class="No-Table-Style">
							<p>x = x – y</p>
						</td>
						<td class="No-Table-Style">
							<p>x -= y</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Multiplication</span></p>
						</td>
						<td class="No-Table-Style">
							<p>x = x * y</p>
						</td>
						<td class="No-Table-Style">
							<p>x *= y</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Division</span></p>
						</td>
						<td class="No-Table-Style">
							<p>x = x / y</p>
						</td>
						<td class="No-Table-Style">
							<p>x /= y</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Modulus (remainder)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>x = x % y</p>
						</td>
						<td class="No-Table-Style">
							<p>x %= y</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Increment</span></p>
						</td>
						<td class="No-Table-Style">
							<p>++x <span class="No-Break">or x++</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">N/A</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Decrement</span></p>
						</td>
						<td class="No-Table-Style">
							<p>--x <span class="No-Break">or x--</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">N/A</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.9 – Basic math operators</p>
			<p>Java follows the standard rules of precedence, except for the increment and decrement operators. If the operator is on the left-hand side of the variable, then Java conducts the operation before any other. This, technically, gives it the highest precedence. Placed on the right-hand side, it has the lowest precedence, and Java performs it after all other operations are complete. We will review the logical operators when we look at logical operations in the <span class="No-Break">next chapter.</span></p>
			<h3>String operator</h3>
			<p><strong class="source-inline">String</strong> does<a id="_idIndexMarker333"/> not have a numeric value, and you cannot use a <strong class="source-inline">String</strong> object in a calculation. As you would expect, <strong class="source-inline">int numberOfDogs = 23;</strong> does not mean the same as <strong class="source-inline">String numberOfDogs = "</strong><span class="No-Break"><strong class="source-inline">23 ";</strong></span><span class="No-Break">.</span></p>
			<p>You cannot use a <strong class="source-inline">String</strong> variable in an arithmetic expression. If the characters in <strong class="source-inline">String</strong> match what is allowable for a number, then you must convert <strong class="source-inline">String</strong> into a numeric variable first and then use it in an <span class="No-Break">arithmetic expression.</span></p>
			<p>However, the plus (<strong class="source-inline">+</strong>) operator is permitted along with <strong class="source-inline">String</strong>. When used with <strong class="source-inline">String</strong>, it means to concatenate or join multiple <strong class="source-inline">String</strong> values into one, as shown here: </p>
			<pre class="source-code">
String animal = "moose";
String favoriteAnimal 
    = "My favorite animal is a " + animal;</pre>
			<p>You can also use concatenation to combine <strong class="source-inline">String</strong> with any of the eight primitive types. This will automatically convert the primitive to <strong class="source-inline">String</strong>, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
int numberOfMoose = 36;
String message = "There are " + numberOfMoose 
    + " in the park. "</pre>
			<p>The <strong class="source-inline">String</strong> message will contain <span class="No-Break">the following:</span></p>
			<pre class="source-code">
<strong class="bold">There are 36 moose in the park.</strong></pre>
			<p>You cannot assign a numeric type directly to <strong class="source-inline">String</strong>. You must concatenate it to <strong class="source-inline">String</strong> or use the <strong class="source-inline">String.valueOf</strong> method; it is a simpler approach. Concatenating a primitive to any string, such as the empty String shown here, <span class="No-Break">will work:</span></p>
			<pre class="source-code">
String piecesOfSilver = "" + 23;</pre>
			<p>Alternatively, you can use <span class="No-Break">the following:</span></p>
			<pre class="source-code">
String piecesOfSilver = String.valueOf(23);</pre>
			<p>Where you see the literal values, you can also use a primitive, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
int silverCoins = 23;
String piecesOfSilver = String.valueOf(silverCoins);</pre>
			<p>There is just<a id="_idIndexMarker334"/> one operator you can use with String, which is for concatenation rather than a mathematical function. </p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor100"/>Casting</h2>
			<p>Casting <a id="_idIndexMarker335"/>provides <a id="_idIndexMarker336"/>the ability to cast or convert one data type to another. When coding with primitives, there are two types of casting – implicit and explicit. First, look at this chart, which shows the primitives by order of their range <span class="No-Break">of values:</span></p>
			<table id="table005" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Largest</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Smallest</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">double</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">long</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">short</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">byte</strong></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.10 – Relative number of bytes between types</p>
			<p>What this means is that when assigning a primitive of one type on the chart to a primitive higher on the chart, Java will perform an implicit cast, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
int apples = 23;
double fruit = apples;</pre>
			<p>This is a lossless conversion. You may try the assignment in the other direction, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
double apples = 34.6;
int fruit = apples;</pre>
			<p>You will get the <span class="No-Break">following error:</span></p>
			<pre class="source-code">
<strong class="bold">incompatible types: possible lossy conversion from double to int</strong></pre>
			<p>If you need to<a id="_idIndexMarker337"/> convert from a data type larger than the data type of the destination <a id="_idIndexMarker338"/>variable, you must do an explicit cast. For example, when converting from a floating point to an integer, Java will cut the fractional component. No rounding; it just disappears, as shown here: </p>
			<pre class="source-code">
double apples = 34.6;
int fruit = (int)apples;</pre>
			<p>With casting, there is no error, but the value in <strong class="source-inline">fruit</strong> will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">34</strong></span><span class="No-Break">.</span></p>
			<p>If the value on the right-hand side exceeds the range of the type you are casting to, when it is an integer type, then, like an <strong class="bold">overflow</strong>, discussed in the next section, it will wrap around, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
double apples = 67000.6;
short fruit = (short)fruit;</pre>
			<p>The value in <strong class="source-inline">fruit</strong> will <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">1464</strong></span><span class="No-Break">.</span></p>
			<p>The syntax for casting Java places the type to cast in parentheses. Python, C, and C++ are cast by placing the value in parentheses, while C# follows the same model <span class="No-Break">as Java.</span></p>
			<p>In <em class="italic">Table 4.10</em>, you did not see the <strong class="source-inline">char</strong> type. Its sole purpose in the language is to represent a UTF-8 code that Java will render as a character on the screen. You can assign a character to a <strong class="source-inline">char</strong> variable, or you can assign an integer. If the integer you assign is outside the allowable range, then you will need to cast, and an overflow wrap will occur. </p>
			<p>Here are some examples of declaring a <span class="No-Break"><strong class="source-inline">char</strong></span><span class="No-Break"> variable:</span></p>
			<pre class="source-code">
char letterA1 = 'A';
char letterA2 = 66;
char letterA3 = (char)65601;</pre>
			<p>All three of these will become the <span class="No-Break">letter </span><span class="No-Break"><strong class="source-inline">A</strong></span><span class="No-Break">.</span></p>
			<p>We have seen<a id="_idIndexMarker339"/> that promotion occurs implicitly, moving from one data type to another<a id="_idIndexMarker340"/> data type higher on the chart. To move in the other direction, you <span class="No-Break">must cast.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor101"/>Overflow and underflow</h2>
			<p>An overflow and an <strong class="bold">underflow</strong> can occur when working with floating-point types. Only an overflow can occur with integer and char types. Here is how Java behaves in <span class="No-Break">these situations.</span></p>
			<h3>Integer overflow</h3>
			<p>An overflow <a id="_idIndexMarker341"/>occurs when a value is outside the range of allowable <a id="_idIndexMarker342"/>values. For floating-point values, an overflow results in the special value infinity, and either plus or minus is the result. </p>
			<p>Overflow with integers results in a wraparound. For example, in the following code snippet, we are assigning a value to a short data type. This value is 1 greater than the allowable upper range <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">short</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
short testValue = (short)32768;
System.out.printf("testValue = %d", testValue);</pre>
			<p>The following is the output of this <span class="No-Break">code fragment:</span></p>
			<pre class="source-code">
<strong class="bold">testValue = -32768</strong></pre>
			<h3>Floating-point overflow</h3>
			<p>Unlike the<a id="_idIndexMarker343"/> integer types, floating-point types do not wrap<a id="_idIndexMarker344"/> when overflow occurs. Instead, Java assigns the special value <strong class="source-inline">Infinity</strong>. </p>
			<p>Using a double as an example, we can use the <strong class="source-inline">Double</strong> class, discussed in the next section, as the static constant that contains the maximum allowed value for a double. When we assign a value to a double that exceeds the maximum allowable value: </p>
			<pre class="source-code">
double testValue = Double.MAX_VALUE + Double.MAX_VALUE;
System.out.printf("testValue = %f", testValue);</pre>
			<p>The following will be the output <span class="No-Break">for this:</span></p>
			<pre class="source-code">
testValue = Infinity</pre>
			<p>The nature of the floating point is such that a minor increase over the maximum value does not result in an overflow. As shown in the previous example, a significant increase over the maximum value will generate <strong class="source-inline">Infinity</strong>. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
double testValue = Double.MAX_VALUE + 1.0;
double testValue = Double.MAX_VALUE ;</pre>
			<p>Both expressions return the <span class="No-Break">same answer:</span></p>
			<pre class="source-code">
<strong class="bold">testValue = 179769313486231570000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.000000</strong></pre>
			<h3>Floating-point underflow</h3>
			<p>Underflow<a id="_idIndexMarker345"/> occurs when the floating-point value cannot <a id="_idIndexMarker346"/>represent exceedingly small fractions. Like overflow, this condition does not occur immediately after a value falls below the minimum value for the floating point. A meaningful change that lowers a value below the minimum will trigger an underflow. In this example, we begin by assigning the smallest allowed value to a double. When we divide it by 2, it becomes even smaller but now is smaller than the <span class="No-Break">minimum value:</span></p>
			<pre class="source-code">
double testValue = Double.MIN_VALUE;
System.out.printf("testValue = %2.16e", testValue);</pre>
			<p>When run, the result is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
testValue = 4.9000000000000000e-324</pre>
			<p>This is the minimum value of a double. Say we try to assign an even smaller value by dividing the minimum value by 2, as we have <span class="No-Break">done here:</span></p>
			<pre class="source-code">
double testValue = Double.MIN_VALUE / 2;</pre>
			<p>Then, the result will be <span class="No-Break">the following:</span></p>
			<pre class="source-code">
testValue = 0.0000000000000000e+00</pre>
			<p>This is the value that the code returns when a float or <span class="No-Break">double underflows.</span></p>
			<p>You should<a id="_idIndexMarker347"/> always be wary of overflow and, in the case of floating<a id="_idIndexMarker348"/> point, underflow. Now, let us look at a family of classes that provide class support for the primitive data types. </p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor102"/>Wrapper classes</h2>
			<p>Java, like most<a id="_idIndexMarker349"/> languages, has an array data type – you can have an array<a id="_idIndexMarker350"/> of integers, Booleans, or primitives. You can have an array of objects, such as the String. Every element in the array must be the same type. Many of the object-oriented capabilities in Java require the use of objects and not primitives. For example, Java has a library of data structures called collections that provides greater functionality than a basic array. These collections can only store or collect objects. You cannot have a collection of <strong class="source-inline">int</strong>, <strong class="source-inline">double</strong>, or any of the <span class="No-Break">other primitives.</span></p>
			<p>A <strong class="bold">wrapper class</strong> is the solution Java creators developed for situations where an object must be used rather than a primitive. Every primitive data type has an equivalent wrapper class, which can be used when a primitive is not permitted. Just like with the <strong class="source-inline">String</strong> class, you do not need to use <strong class="source-inline">new</strong> to create a wrapper object. Wrappers have methods to convert from String to primitives. They also contain information about the primitives. We already had a peek at this when I used <strong class="source-inline">Double.MIN_VALUE</strong> and <strong class="source-inline">Double.MAX_VALUE</strong>. </p>
			<p>Here is a table of all the primitives and their matching wrapper classes. Aside from static variables, these wrappers also have static methods to convert to and <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">String</strong></span><span class="No-Break">:</span></p>
			<table id="table006" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Primitive </strong><span class="No-Break"><strong class="bold">data type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Wrapper class</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">byte</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Byte</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">short</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Short</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">int</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Integer</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">long</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Long</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">float</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Float</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">double</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Double</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">boolean</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Boolean</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">char</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Character</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.11 – Primitives and wrappers</p>
			<p>These<a id="_idIndexMarker351"/> classes, like <a id="_idIndexMarker352"/>String, do not have to be explicitly instantiated. This means that you could write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
Integer number = Integer.valueOf(12);</pre>
			<p>But you can also just assign the integer value, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
Integer number = 12;</pre>
			<p>Java refers to this<a id="_idIndexMarker353"/> as <strong class="bold">autoboxing</strong>. A second<a id="_idIndexMarker354"/> feature, called <strong class="bold">unboxing</strong>, permits the reading of a wrapper class as if it were a primitive. </p>
			<p>Here we see an object, <strong class="source-inline">number</strong>, assigned to <span class="No-Break">a primitive:</span></p>
			<pre class="source-code">
int value = number;</pre>
			<p>This now allows us to use objects as primitives. Every wrapper also contains several useful methods we will explore as we delve more into <span class="No-Break">the language.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor103"/>The math library</h2>
			<p>Earlier in this <a id="_idIndexMarker355"/>chapter, we examined the operators available for <a id="_idIndexMarker356"/>working with primitive data types. There are many operations you may wish to perform that do not have a matching symbol, such as raising a value by a power. There are languages that use the caret (<strong class="source-inline">^</strong>) or double asterisk (<strong class="source-inline">**</strong>) to denote raising to a power. In Python, you would write <span class="No-Break">the following:</span></p>
			<pre class="source-code">
value = 5.0**2.0;</pre>
			<p>The result will be <strong class="source-inline">25</strong>. Java does not have a symbol for this operation. Instead, we must use a method that belongs to the math class, as shown here: </p>
			<pre class="source-code">
double value = Math.pow(5.0, 2.0);</pre>
			<p>We have already seen this in the program that calculated compound interest; take a <span class="No-Break">look again:</span></p>
			<pre class="source-code">
var result = principal * Math.pow(
              1 + annualInterestRate / compoundPerTimeUnit, 
           time * compoundPerTimeUnit);</pre>
			<p>The math library has an extensive selection of math operations. See the link in the <em class="italic">Further reading</em> section to learn about all the choices available <span class="No-Break">to you.</span></p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor104"/>Summary</h1>
			<p>The heart of every program you will write is the data that your program operates on. In this chapter, we have learned about the eight primitive types. There is <strong class="source-inline">byte</strong>, particularly useful if you are writing software to interact with other devices. <strong class="source-inline">short</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">long</strong> are useful when what you need to describe has no fractions. When there are fractions, however, you can use floating-point types – <strong class="source-inline">float</strong> and <strong class="source-inline">double</strong>. The <strong class="source-inline">char</strong> type is the building block for strings. If you want to keep track of what is true or false, you should use the <strong class="source-inline">boolean</strong> type. </p>
			<p>As you move forward into Java, always keep in mind the available data types. Just as important is to understand what will happen if a value is out <span class="No-Break">of range.</span></p>
			<p>Having identified the types, we moved to identify variables with meaningful names. We discussed how we assign data to these variables, and how we use them was an important part of <span class="No-Break">this chapter.</span></p>
			<p>We left the primitives briefly to look at classes that are closely associated with primitives. There was <strong class="source-inline">String</strong> – home to characters that make up text that we can read. The wrapper classes provided runtime information about their matching primitives and are freely interchangeable with primitives, when you need an object rather than <span class="No-Break">a primitive.</span></p>
			<p>Coming up, we will look at classes focusing on access control, packages, and how we construct <span class="No-Break">a class.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor105"/>Further reading</h1>
			<ul>
				<li><em class="italic">The IEEE 754 </em><span class="No-Break"><em class="italic">Format</em></span><span class="No-Break">: </span><a href="http://mathcenter.oxford.emory.edu/site/cs170/ieee754/"><span class="No-Break">http://mathcenter.oxford.emory.edu/site/cs170/ieee754/</span></a></li>
				<li><em class="italic">Demystifying Floating Point </em><span class="No-Break"><em class="italic">Precision</em></span><span class="No-Break">: </span><a href="https://blog.demofox.org/2017/11/21/floating-point-precision/"><span class="No-Break">https://blog.demofox.org/2017/11/21/floating-point-precision/</span></a></li>
				<li><em class="italic">Class </em><span class="No-Break"><em class="italic">Math</em></span><span class="No-Break">: </span><a href="https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html"><span class="No-Break">https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/lang/Math.html</span></a></li>
			</ul>
		</div>
	</body></html>