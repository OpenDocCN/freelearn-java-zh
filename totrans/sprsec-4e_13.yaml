- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will write some custom implementations for `Spring Security`’s
    key authorization APIs. Once we have done this, we will use our understanding
    of the custom implementations to understand how `Spring Security`’s authorization
    architecture works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Gaining an understanding of how authorization works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a custom `SecurityMetaDataSource` backed by a database instead of `requestMatchers()`
    methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom **Spring Expression Language** (**SpEL**) expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a custom `PermissionEvaluator` object that allows our permissions
    to be encapsulated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring a custom `AuthorizationManager`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter’s code in action link is here: [https://packt.link/e630f](https://packt.link/e630f).'
  prefs: []
  type: TYPE_NORMAL
- en: Authorizing the Requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the authentication process, `Spring Security` provides an `o.s.s.web.access.intercept.FilterSecurityInterceptor`
    servlet filter, which is responsible for coming up with a decision as to whether
    a particular request will be accepted or denied. At the point the filter is invoked,
    the principal has already been authenticated, so the system knows that a valid
    user has logged in; remember that we implemented the `List<GrantedAuthority>`
    `getAuthorities()` method, which returns a list of authorities for the principal,
    in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*. In
    general, the authorization process will use the information from this method (defined
    by the `Authentication` interface) to determine, for a particular request, whether
    or not the request should be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: This method serves as a means for an `AuthorizationManager` instance to acquire
    a precise String representation of the `GrantedAuthority`. By providing a representation
    as a String, most `AuthorizationManager` implementations can easily `read` the
    `GrantedAuthority`. If a `GrantedAuthority` cannot be accurately represented as
    a String, it is considered `complex`, and the `getAuthority()` method must return
    `null`.
  prefs: []
  type: TYPE_NORMAL
- en: A prime example of a complex `GrantedAuthority` would be an implementation storing
    a list of operations and authority thresholds related to various customer account
    numbers. Trying to represent this intricate `GrantedAuthority` as a String would
    pose considerable challenges. Consequently, the `getAuthority()` method should
    return `null`. This signals to any `AuthorizationManager` that it needs to support
    the specific `GrantedAuthority` implementation to comprehend its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '`Spring Security` features a concrete `GrantedAuthority` implementation named
    `SimpleGrantedAuthority`. This implementation enables the conversion of any user-specified
    String into a `GrantedAuthority`. All `AuthenticationProvider` instances integrated
    into the security architecture utilize `SimpleGrantedAuthority` to populate the
    `Authentication` object.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, role-based authorization rules involve the prefix `ROLE_`. Therefore,
    if an authorization rule mandates a security context to possess the role of `USER`,
    `Spring Security` will automatically seek a `GrantedAuthority#getAuthority` that
    returns `ROLE_USER`.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that authorization is a binary decision—a user either has access to
    a secured resource or does not. There is no ambiguity when it comes to authorization.
  prefs: []
  type: TYPE_NORMAL
- en: A smart object-oriented design is pervasive within the `Spring Security` framework,
    and authorization decision management is no exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Spring Security`, the `o.s.s.access.AccessDecisionManager` interface specifies
    two simple and logical methods that fit sensibly into the processing decision
    flow of requests, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`supports`: This logical operation actually comprises two methods that allow
    the `AccessDecisionManager` implementation to report whether or not it supports
    the current request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decide`: This allows the `AccessDecisionManager` implementation to verify,
    based on the request context and security configuration, whether or not access
    should be allowed and the request accepted. The `Decide` method actually has no
    return value, and instead reports the denial of a request by throwing an exception
    to indicate rejection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific types of exceptions can further dictate the action to be taken by the
    application to resolve authorization decisions. The `o.s.s.access.AccessDeniedException`
    interface is the most common exception thrown in the area of authorization and
    merits special handling by the filter chain.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `AccessDecisionManager` is completely configurable using
    standard Spring bean binding and references. The default `AccessDecisionManager`
    implementation provides an access granting mechanism based on `AccessDecisionVoter`
    and vote aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: 'A voter is an actor in the authorization sequence whose job is to evaluate
    any or all of the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: The context of the request for a secured resource (such as a URL requesting
    an IP address)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The credentials (if any) presented by the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The secured resource being accessed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration parameters of the system, and the resource itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After demonstrating the process of authorizing requests, we will delve into
    the management of invocations.
  prefs: []
  type: TYPE_NORMAL
- en: Handling of Invocations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Spring Security` offers interceptors that are responsible for governing access
    to secure objects, be it method invocations or web requests. `AuthorizationManager`
    instances play a crucial role in making pre-invocation decisions regarding whether
    the invocation is permitted to proceed. Additionally, these instances contribute
    to post-invocation decisions, determining whether a particular value may be returned.'
  prefs: []
  type: TYPE_NORMAL
- en: The AuthorizationManager class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AuthorizationManager` takes precedence over both `AccessDecisionManager` and
    `AccessDecisionVoter`. Applications that customize either an `AccessDecisionManager`
    or an `AccessDecisionVoter` are advised to transition using `AuthorizationManager`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Spring Security`’s request-based, method-based, and message-based authorization
    components invoke `AuthorizationManager` instances, assigning them the responsibility
    of making definitive access control decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: The `check` method of `AuthorizationManager` receives all the pertinent information
    necessary to render an authorization decision. Specifically, passing the secure
    object allows the examination of arguments within the actual invocation of the
    secure object. For instance, if the secure object is a `MethodInvocation`, querying
    it for any client argument becomes straightforward. Subsequently, security logic
    can be implemented in the `AuthorizationManager` to ensure that the principal
    is authorized to operate on that customer. Implementations are expected to return
    a positive `AuthorizationDecision` if access is granted, a negative `AuthorizationDecision`
    if access is denied, and a null `AuthorizationDecision` when abstaining from making
    a decision.
  prefs: []
  type: TYPE_NORMAL
- en: The verify function invokes `check` and throws an `AccessDeniedException` if
    a negative `AuthorizationDecision` is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Delegate-based AuthorizationManager Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although users have the flexibility to implement their own `AuthorizationManager`
    to govern all facets of authorization, `Spring Security` comes with a delegating
    `AuthorizationManager` designed to work in tandem with individual `AuthorizationManagers`.
  prefs: []
  type: TYPE_NORMAL
- en: The `RequestMatcherDelegatingAuthorizationManager` aligns the request with the
    most suitable delegate `AuthorizationManager`. For method security, `AuthorizationManagerBeforeMethodInterceptor`
    and `AuthorizationManagerAfterMethodInterceptor` can be employed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant classes for `AuthorizationManager` implementations are outlined
    for reference in *Figure 13**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Implementations of AuthorizationManager](img/B21757_13_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Implementations of AuthorizationManager
  prefs: []
  type: TYPE_NORMAL
- en: With this approach, a collection of `AuthorizationManager` implementations can
    be consulted for an authorization decision.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will take a deeper look at some authorization
    managers.
  prefs: []
  type: TYPE_NORMAL
- en: AuthorityAuthorizationManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The predominant `AuthorizationManager` provided by `Spring Security` is the
    `AuthorityAuthorizationManager`. It is configured with a specific set of authorities
    to check for in the current `Authentication`. If the `Authentication` contains
    any of the configured authorities, it will yield a positive `AuthorizationDecision`;
    otherwise, it will result in a negative `AuthorizationDecision`.
  prefs: []
  type: TYPE_NORMAL
- en: AuthenticatedAuthorizationManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another manager available is the `AuthenticatedAuthorizationManager`. It proves
    useful in distinguishing between *anonymous*, *fully-authenticated*, and *remember-me*
    authenticated users. Some websites grant limited access under *remember-me* authentication
    but necessitate users to confirm their identity by logging in for complete access.
  prefs: []
  type: TYPE_NORMAL
- en: AuthorizationManagers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AuthorizationManagers` also offer useful static factories for combining individual
    `AuthorizationManagers` into more intricate expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom AuthorizationManagers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Certainly, you have the option to implement a custom `AuthorizationManager`,
    allowing for the inclusion of virtually any access control logic. It may be tailored
    to your application, related to business logic, or involve security administration
    logic. For instance, you can create an implementation capable of querying Open
    Policy Agent or your own authorization database.
  prefs: []
  type: TYPE_NORMAL
- en: After delving into the management of invocations, we will proceed to examine
    the customization of `AccessDecisionManager` and `AccessDecisionVoter`.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying AccessDecisionManager and AccessDecisionVoter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before the introduction of `AuthorizationManager`, `Spring Security` introduced
    `AccessDecisionManager` and `AccessDecisionVoter`.
  prefs: []
  type: TYPE_NORMAL
- en: In certain scenarios, such as when migrating an older application, it might
    be preferable to incorporate an `AuthorizationManager` that invokes an `AccessDecisionManager`
    or `AccessDecisionVoter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke an existing `AccessDecisionManager`, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Subsequently, integrate it into your `SecurityFilterChain`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you wish to only invoke an `AccessDecisionVoter`, you can
    use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Afterward, integrate it into your `SecurityFilterChain`.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Authorization Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a closer look at certain authorization components
    that existed in `Spring Security` but have been deprecated with the introduction
    of `Spring` `Security 6`.
  prefs: []
  type: TYPE_NORMAL
- en: The AccessDecisionManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `AbstractSecurityInterceptor` invokes the `AccessDecisionManager`, which
    is tasked with making conclusive access control decisions. The `AccessDecisionManager`
    interface encompasses three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `decide` method of the `AccessDecisionManager` receives all the pertinent
    information required to make an authorization decision. Specifically, passing
    the secure object allows the inspection of arguments within the actual invocation
    of the secure object. For instance, if the secure object is a `MethodInvocation`,
    you can inquire about any `Customer` argument in the `MethodInvocation` and then
    implement security logic in the `AccessDecisionManager` to verify whether the
    principal is authorized to operate on that customer. Implementations are expected
    to throw an `AccessDeniedException` if access is denied.
  prefs: []
  type: TYPE_NORMAL
- en: The `supports(ConfigAttribute`) method is invoked by the `AbstractSecurityInterceptor`
    during startup to determine whether the `AccessDecisionManager` can handle the
    provided `ConfigAttribute`. The `supports(Class clazz)` method is called by a
    security interceptor implementation to ensure that the configured `AccessDecisionManager`
    supports the type of secure object presented by the security interceptor.
  prefs: []
  type: TYPE_NORMAL
- en: AccessDecisionManager Implementations Based on Voting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although users have the flexibility to implement their own `AccessDecisionManager`
    to oversee all aspects of authorization, `Spring Security` provides various `AccessDecisionManager`
    implementations grounded in a voting mechanism. The relevant classes are explained
    in the **Voting** **Decision Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AccessDecisionManager` interface is illustrated in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – Voting Decision Manager](img/B21757_13_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – Voting Decision Manager
  prefs: []
  type: TYPE_NORMAL
- en: Through this approach, a sequence of `AccessDecisionVoter` implementations is
    consulted for an authorization decision. The `AccessDecisionManager` subsequently
    determines whether or not to throw an `AccessDeniedException` based on its evaluation
    of the votes.
  prefs: []
  type: TYPE_NORMAL
- en: '`Spring Security` provides three concrete `AccessDecisionManager` implementations
    to aggregate votes. The `ConsensusBased` implementation allows or denies access
    based on the consensus of non-abstain votes. Configurable properties govern behavior
    in case of vote equality or if all votes abstain. The `AffirmativeBased` implementation
    grants access if one or more `ACCESS_GRANTED` votes are received (ignoring deny
    votes as long as there is at least one grant vote). Similar to `ConsensusBased`,
    it has a parameter controlling behavior if all voters abstain. The `UnanimousBased`
    implementation requires unanimous `ACCESS_GRANTED` votes for access, disregarding
    abstains. It denies access with any `ACCESS_DENIED` vote. Like the others, it
    has a parameter governing behavior if all voters abstain.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom `AccessDecisionManager` instances can be implemented to customize vote
    tallying. For instance, votes from a specific `AccessDecisionVoter` might carry
    additional weight, and a deny vote from a particular voter could have a veto effect.
  prefs: []
  type: TYPE_NORMAL
- en: RoleVoter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `RoleVoter`, the most commonly utilized `AccessDecisionVoter` provided by
    `Spring Security`, interprets configuration attributes as role names and votes
    to grant access if the user has been assigned that role.
  prefs: []
  type: TYPE_NORMAL
- en: It casts a vote if any `ConfigAttribute` starts with the `ROLE_` prefix. Access
    is granted if there is a `GrantedAuthority` that returns a String representation
    (via the `getAuthority()` method) exactly matching one or more `ConfigAttribute`
    instances, starting with the `ROLE_` prefix. If there is no precise match for
    any `ConfigAttribute` starting with `ROLE_`, `RoleVoter` votes to deny access.
    If no `ConfigAttribute` starts with `ROLE_`, the voter abstains.
  prefs: []
  type: TYPE_NORMAL
- en: AuthenticatedVoter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another implicit voter is the `AuthenticatedVoter`, useful for distinguishing
    between *anonymous*, *fully-authenticated*, and *remember-me* authenticated users.
    Many websites allow limited access under *remember-me* authentication but necessitate
    user confirmation of identity by logging in for full access.
  prefs: []
  type: TYPE_NORMAL
- en: The processing of the `IS_AUTHENTICATED_ANONYMOUSLY` attribute for granting
    anonymous access is handled by the `AuthenticatedVoter`, as seen in previous examples.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Voters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementing a custom `AccessDecisionVoter` enables the inclusion of virtually
    any access control logic. It may be tailored to your application, related to business
    logic, or involve security administration logic. For instance, a blog article
    on the Spring website outlines using a voter to deny real-time access to users
    with suspended accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Expression-based request authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you might expect, `Voter` implementation, `o.s.s.web.access.expression.WebExpressionVoter`,
    which understands how to evaluate the SpEL expressions. The `WebExpressionVoter`
    class relies on an implementation of the `SecurityExpressionHandler` interface
    for this purpose. The `SecurityExpressionHandler` interface is responsible both
    for evaluating the expressions and for supplying the security-specific methods
    that are referenced in the expressions. The default implementation of this interface
    exposes methods defined in the `o.s.s.web.access.expression.WebSecurityExpressionRoot`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flow and relationship between these classes are shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3 – Relationship between WebSecurityExpressionRoot and AccessDecisionManager](img/B21757_13_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.3 – Relationship between WebSecurityExpressionRoot and AccessDecisionManager
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how request authorization works, let’s solidify our understanding
    by making a few custom implementations of some key interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The real power of `Spring Security`’s authorization is demonstrated by how adaptable
    it is to custom requirements. Let’s explore a few scenarios that will help reinforce
    our understanding of the overall architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamically defining access control to URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Spring Security` provides several methods for mapping `ConfigAttribute` objects
    to a resource. For example, the `requestMatchers()` method ensures it is simple
    for developers to restrict access to specific HTTP requests in their web applications.
    Behind the scenes, an implementation of `o.s.s.acess.SecurityMetadataSource` is
    populated with these mappings and queried to determine what is required in order
    to be authorized to make any given HTTP request.'
  prefs: []
  type: TYPE_NORMAL
- en: While the `requestMatchers()` method is very simple, there may be times when
    it would be desirable to provide a custom mechanism for determining the URL mappings.
    An example of this might be if an application needs to be able to dynamically
    provide access control rules. Let’s demonstrate what it would take to move our
    URL authorization configuration into a database.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the RequestConfigMappingService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step is to be able to obtain the necessary information from the database.
    This will replace the logic that reads in the `requestMatchers()` methods from
    our security bean configuration. In order to do this, the chapter’s sample code
    contains `JpaRequestConfigMappingService`, which will obtain a mapping of an `Ant
    Pattern` and an expression from the database represented as `RequestConfigMapping`.
    The rather simple implementation is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It is important to notice that, just as with the `requestMatchers()` methods,
    order matters. Therefore, we ensure the results are sorted by the `sort_order`
    column. The service creates an `AntRequestMatcher` and associates it with `SecurityConfig`,
    an instance of `ConfigAttribute`. This will provide a mapping of the HTTP request
    to `ConfigAttribute` objects that can be used by `Spring Security` to secure our
    URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a domain object to use for **Jakarta Persistence** (**JPA**)
    to map to, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to create a Spring Data repository object, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In order for the new service to work, we will need to initialize our database
    with the schema and the access control mappings, just as with the service implementation.
    The `security_filter_metadata` table schema can be auto-generated by `spring-data-jpa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then use the same `requestMatchers()` mappings from our `SecurityConfig.java`
    file to produce the `data.sql` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once the `RequestConfigMappingService` is configured, we’ll explore the implementation
    of a custom `SecurityMetadataSource`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom SecurityMetadataSource implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order for `Spring Security` to be aware of our URL mappings, we need to
    provide a custom `FilterInvocationSecurityMetadataSource` implementation. The
    `FilterInvocationSecurityMetadataSource` package extends the `SecurityMetadataSource`
    interface which, given a particular HTTP request, is what provides `Spring Security`
    with the information necessary for determining whether access should be granted.
    Let’s take a look at how we can utilize our `RequestConfigMappingService` interface
    to implement a `SecurityMetadataSource` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We are able to use our `RequestConfigMappingService` interface to create a map
    of `RequestMatcher` objects that map to `ConfigAttribute` objects. We then delegate
    to an instance of `ExpressionBasedFilterInvocationSecurityMetadataSource` to do
    all the work. For simplicity, the current implementation would require restarting
    the application to pick up changes. However, with a few minor changes, we could
    avoid this inconvenience.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a custom SecurityMetadataSource
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, all that is left is for us to configure `FilterInvocationServiceSecurityMetadataSource`.
    The only problem is that `Spring Security` does not support configuring a custom
    `FilterInvocationServiceSecurityMetadataSource` interface directly. This is not
    too difficult, so we will register this `SecurityMetadataSource` with our `FilterSecurityInterceptor`
    in our `SecurityConfig` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This sets up our custom `SecurityMetadataSource` interface with the `FilterSecurityInterceptor`
    object as the default metadata source.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the database is being used to map our security configuration, we can
    remove the `requestMatchers()` method from our `SecurityConfig.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: You should now be able to start the application and test to ensure that our
    URLs are secure, as they should be. Our users will not notice a difference, but
    we know that our URL mappings are persisted in a database now.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar13.01-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom expression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `o.s.s.access.expression.SecurityExpresssionHandler` interface is how `Spring
    Security` abstracts how the Spring expressions are created and initialized. Just
    as with the `SecurityMetadataSource` interface, there is an implementation for
    creating expressions for web requests and creating expressions for securing methods.
    In this section, we will explore how we can easily add new expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a custom SecurityExpressionRoot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume that we want to support a custom `Web Expression` named `isLocal`
    that will return `true` if the host is `localhost` and `false` otherwise. This
    new method could be used to provide additional security for our SQL console by
    ensuring that it is only accessed from the same machine that the web application
    is deployed from.
  prefs: []
  type: TYPE_NORMAL
- en: This is an artificial example that does not add any security benefits since
    the host comes from the headers of the HTTP request. This means a malicious user
    could inject a header stating that the host is `localhost` even if they are requesting
    to an external domain.
  prefs: []
  type: TYPE_NORMAL
- en: All of the expressions that we have seen are available because the `SecurityExpressionHandler`
    interface makes them available via an instance of `o.s.s.access.expression.SecurityExpressionRoot`.
    If you open this object, you will find the methods and properties we use in Spring
    expressions (that is, `hasRole`, `hasPermission`, and so on), which are common
    in both web and method security. A subclass provides the methods that are specific
    to the web and method expressions. For example, `o.s.s.web.access.expression.WebSecurityExpressionRoot`
    provides the `hasIpAddress` method for web requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a custom web `SecurityExpressionhandler`, we will first need to create
    a subclass of `WebSecurityExpressionRoot` that defines our `isLocal` method, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that `getServerName()` returns the value that is provided
    in the `Host` header value. This means that a malicious user can inject a different
    value into the header to bypass constraints. However, most application servers
    and proxies can enforce the value of the `Host` header. Please read the appropriate
    documentation before leveraging such an approach to ensure that malicious users
    do not inject a `Host` header value to bypass such a constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a custom SecurityExpressionHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order for our new method to become available, we need to create a custom
    `SecurityExpressionHandler` interface that utilizes our new root object. This
    is as simple as extending `WebSecurityExpressionHandler`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We perform the same steps that the superclass does, except that we use `CustomWebSecurityExpressionRoot`,
    which contains the new method.
  prefs: []
  type: TYPE_NORMAL
- en: The `CustomWebSecurityExpressionRoot` becomes the root of our SpEL expression.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'For further details, refer to the SpEL documentation within the Spring Reference
    documentation: [https://docs.spring.io/spring-framework/reference/core/expressions.xhtml](https://docs.spring.io/spring-framework/reference/core/expressions.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and using CustomWebSecurityExpressionHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now need to configure `CustomWebSecurityExpressionHandler`. Fortunately,
    this can be done easily using the `Spring Security` namespace configuration support.
    Add the following configuration to the `SecurityConfig.java` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s update our initialization SQL query to use the new expression. Update
    the `data.sql` file so that it requires the user to be `ROLE_ADMIN` and requested
    from the local machine. You will notice that we are able to write local instead
    of `isLocal`, since SpEL supports Java Bean conventions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Restart the application and access the H2 console using `localhost:8080/admin/h2`
    and `admin1@example.com/admin1` to see the admin console.
  prefs: []
  type: TYPE_NORMAL
- en: If the H2 console is accessed using `127.0.0.1:8080/admin/h2` and `admin1@example.com/admin1`,
    the **Access Denied** page will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar13.02-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternative to a CustomWebSecurityExpressionHandler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following an examination of the `CustomWebSecurityExpressionHandler` usage,
    we will investigate alternative approaches by employing a custom `PermissionEvaluator`
    to enhance the security of our `CalendarService`.
  prefs: []
  type: TYPE_NORMAL
- en: How does method security work?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The access decision mechanism for method security—whether or not a given request
    is allowed—is conceptually the same as the access decision logic for web request
    access. `AccessDecisionManager` polls a set of `AccessDecisionVoter` instances,
    each of which can provide a decision to grant or deny access or abstain from voting.
    The specific implementation of `AccessDecisionManager` aggregates the voter decisions
    and arrives at an overall decision to allow for the method invocation.
  prefs: []
  type: TYPE_NORMAL
- en: Web request access decision-making is less complicated, due to the fact that
    the availability of servlet filters makes the interception (and summary rejection)
    of securable requests relatively straightforward. As method invocation can happen
    from anywhere, including areas of code that are not directly configured by `Spring
    Security`, the `Spring Security` designers chose to use a Spring-managed **Aspect-****O****riented
    Programming** (**AOP**) approach to recognize, evaluate, and secure method invocations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following high-level flow illustrates the main players involved in authorization
    decisions for method invocation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4 – Main classes involved in authorization decisions for method
    invocation](img/B21757_13_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.4 – Main classes involved in authorization decisions for method invocation
  prefs: []
  type: TYPE_NORMAL
- en: We can see that `Spring Security`’s `o.s.s.access.intercept.aopalliance.MethodSecurityInterceptor`
    is invoked by the standard Spring AOP runtime to intercept method calls of interest.
    From here, the logic of whether or not to allow a method call is relatively straightforward,
    as per the previous flow diagram.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we might wonder about the performance of the method security
    feature. Obviously, `MethodSecurityInterceptor` can’t be invoked for every method
    call in the application—so how do annotations on methods or classes result in
    AOP interception?
  prefs: []
  type: TYPE_NORMAL
- en: First of all, AOP proxying isn’t invoked for all Spring-managed beans by default.
    Instead, if `@EnableMethodSecurity` is defined in the `Spring Security` configuration,
    a standard Spring AOP `o.s.beans.factory.config.BeanPostProcessor` will be registered
    that will introspect the AOP configuration to see whether any AOP advisors indicate
    that proxying (and the interception) is required. This workflow is standard Spring
    AOP handling (known as `Spring Security`. All registered `BeanPostProcessor` instances
    run upon initialization of the Spring `ApplicationContext`; after all, Spring
    bean configurations have occurred.
  prefs: []
  type: TYPE_NORMAL
- en: The AOP auto-proxy functionality queries all registered `PointcutAdvisor` instances,
    to see if there are AOP pointcuts that resolve method invocations that should
    have AOP advice applied. `Spring Security` implements the `o.s.s.access.intercept.aopalliance.MethodSecurityMetadataSourceAdvisor`
    class, which examines any and all configured method security annotations and sets
    up appropriate AOP interception. Take note that only interfaces or classes with
    declared method security annotations will be proxied for AOP!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that it is strongly encouraged to declare AOP rules (and other security
    annotations) on interfaces, and not on implementation classes. The use of classes,
    while available using CGLIB proxying with Spring, may unexpectedly change the
    behavior of your application, and is generally less semantically correct than
    security declarations (through AOP) on interfaces. `MethodSecurityMetadataSourceAdvisor`
    delegates the decision to affect methods with the AOP advice to an `o.s.s.access.method.MethodSecurityMetadataSource`
    instance. The different forms of method security annotation each have their own
    `MethodSecurityMetadataSource` implementation, which is used to introspect each
    method, class in turn, and add AOP advice to be executed at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates how this process occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.5 – AOP interceptors for method security](img/B21757_13_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.5 – AOP interceptors for method security
  prefs: []
  type: TYPE_NORMAL
- en: Depending on the number of Spring beans configured in your application and the
    number of secured method annotations you have, adding method security proxying
    may increase the time required to initialize your `ApplicationContext`. Once your
    Spring context is initialized, however, there is a negligible performance impact
    on individual proxied beans.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of how we can use AOP to apply `Spring Security`,
    let’s strengthen our grasp of `Spring Security` authorization by creating a custom
    `PermissionEvaluator`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a custom PermissionEvaluator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous chapter, we demonstrated that we could use `Spring Security`’s
    built-in `PermissionEvaluator` implementation, `AclPermissionEvaluator`, to restrict
    access to our application. While powerful, this can often be more complicated
    than necessary. We have also discovered how `SpEL` can formulate complex expressions
    that are able to secure our application. While simple, one of the downsides of
    using complex expressions is that the logic is not centralized. Fortunately, we
    can easily create a custom `PermissionEvaluator` that is able to centralize our
    authorization logic and still avoid the complexity of using ACLs.
  prefs: []
  type: TYPE_NORMAL
- en: The CalendarPermissionEvaluator Class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A simplified version of our custom `PermissionEvaluator` that does not contain
    any validation can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The logic is fairly similar to the Spring expressions that we have already used,
    except that it differentiates read and write access. If the current user’s username
    matches the owner’s email of the `Event` object, then both read and write access
    is granted. If the current user’s email matches the attendee’s email, then read
    access is granted. Otherwise, access is denied.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that a single `PermissionEvaluator` is used for every domain
    object. So, in a real-world situation, we must perform `instanceof` checks first.
    For example, if we were also securing our `CalendarUser` objects, these could
    be passed into this same instance. For a full example of these minor changes,
    refer to the sample code included in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring CalendarPermissionEvaluator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can then leverage the `CustomAuthorizationConfig.java` configuration that
    is provided with this chapter to provide an `ExpressionHandler` that uses our
    `CalendarPermissionEvaluator`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The configuration should look similar to the configuration from [*Chapter 12*](B21757_12.xhtml#_idTextAnchor375),
    *Access Control Lists*, except that we now use our `CalendarPermissionEvalulator`
    class instead of `AclPermissionEvaluator`.
  prefs: []
  type: TYPE_NORMAL
- en: Securing our CalendarService
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Lastly, we can secure our `CalendarService getEvent(int eventId)` method with
    a `@PostAuthorize` annotation. You will notice that this step is exactly the same
    as what we did in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015), *Anatomy of
    an Unsafe Application*, and we have only changed the implementation of `PermissionEvaluator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If you have not done so already, restart the application, log in with the username/password
    `admin1@example.com/admin1`, and visit the `events/101`) using the link on the
    **Welcome** page. The **Access Denied** page will be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar13.03-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: However, we would like `ROLE_ADMIN` users to be able to access all events.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of a custom PermissionEvaluator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With only a single method being protected, it would be trivial to update the
    annotation to check whether the user has the role of `ROLE_ADMIN` or has permission.
    However, if we had protected all of our service methods that use an event, it
    would have become quite cumbersome. Instead, we could just update our `CalendarPermissionEvaluator`.
    Make the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, restart the application and repeat the previous exercise. This time, the
    **Conference Call Event** will display successfully.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the ability to encapsulate our authorization logic can be extremely
    beneficial. However, sometimes, it may be useful to extend the expressions themselves.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar13.04-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Removing the CustomWebSecurityExpressionHandler class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a much simpler way of defining custom **Web Expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, you can remove the following classes: `CustomWebSecurity`
    **ExpressionHandler** and `CustomWebSecurityExpressionRoot`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declare a Spring bean containing the custom `Web Expression`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CustomAuthorizationConfig` class, add the following bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then remove the following declaration to the `CustomWebSecurityExpressionHandler`
    inside the `SecurityConfig` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s update our initialization SQL query to adapt the syntax of the new
    expression. Update the `data.sql` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the application and test the application access with the user `admin1@example.com/admin1`
    for both URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://127.0.0.1:8080/admin/h2`: Access should be `denied`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/admin/h2`: Access should be `allowed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar13.05-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a custom AuthorizationManager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Spring Security 6` has deprecated the usage of the `AccessDecissionManager`
    and `AccessDecisionVoter`.'
  prefs: []
  type: TYPE_NORMAL
- en: The recommended approach is to implement a custom `AuthorizationManager`, as
    explained in the introduction of this chapter. To achieve this goal, you can follow
    the next steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will create a custom implementation of the `AuthorizationManager`
    that checks for the allowed permissions based on the `security_filter_metadata`
    table definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will inject the `AuthorizationManager` into the `SecurityFilterChain`
    bean, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will update the `CustomAuthorizationConfig` configuration by replacing the
    bean of type `DefaultWebSecurityExpressionHandler` with another one of type `DefaultHttpSecurityExpressionHandler`,
    as we have chosen to use `http.authorizeHttpRequest()` instead of `http.authorizeRequests()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can remove the `FilterInvocationServiceSecurityMetadataSource` and restart
    your application. You should have the same results as the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar13.06-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After reading this chapter, you should have a firm understanding of how `Spring
    Security` authorization works for HTTP requests and methods. With this knowledge,
    and the provided concrete examples, you should also know how to extend authorization
    to meet your needs. Specifically, in this chapter, we covered the `Spring Security`
    authorization architecture for both HTTP requests and methods. We also demonstrated
    how to configure secured URLs from a database.
  prefs: []
  type: TYPE_NORMAL
- en: We also saw how to create a custom `AuthorizationManager`, `PermissionEvaluator`
    object, and custom `Spring` `Security` expression.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how `Spring Security` performs session
    management. We will also gain an understanding of how it can be used to restrict
    access to our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 5: Advanced Security Features and Deployment Optimization'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part commences with an explanation of session fixation attacks and Spring
    Security’s defense mechanisms against them. It proceeds to explore methods for
    managing logged-in users and limiting the number of concurrent sessions per user.
    The association of a user to `HttpSession` by Spring Security and techniques for
    customizing this behavior are also detailed.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we delve into common security vulnerabilities such as **Cross-Site Scripting**
    (**XSS**), **Cross-Site Request Forgery** (**CSRF**), synchronizer tokens, and
    clickjacking, along with strategies to mitigate these risks effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we present a migration path to Spring Security 6, highlighting
    notable configuration changes, class and package migrations, and significant new
    features, including support for Java 17 and enhanced authentication mechanisms
    with OAuth 2.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequently, we explore microservices-based architectures and examine the role
    of OAuth 2 with **JSON Web Tokens** (**JWTs**) in securing microservices within
    a Spring-based application. Additionally, we discuss the implementation of **Single
    Sign-On** (**SSO**) using the **Central Authentication** **Service** (**CAS**).
  prefs: []
  type: TYPE_NORMAL
- en: Concluding this part, we delve into the process of building native images using
    GraalVM, offering insights into enhancing performance and security within Spring
    Security applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B21757_14.xhtml#_idTextAnchor445), *Session Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B21757_15.xhtml#_idTextAnchor479), *Additional Spring Security
    Features*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B21757_16.xhtml#_idTextAnchor512), *Migration to Spring Security
    6*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B21757_17.xhtml#_idTextAnchor537), *Microservice Security with
    OAuth 2 and JSON Web Tokens*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 18*](B21757_18.xhtml#_idTextAnchor591), *Single Sign-On with the
    Central Authentication Service*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 19*](B21757_19.xhtml#_idTextAnchor625), *Build GraalVM Native Images*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
