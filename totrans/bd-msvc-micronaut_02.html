<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Getting Started with Microservices Using the Micronaut Framework</h1>
			<p>In recent times, there's been a good buzz about <strong class="bold">microservices</strong> and how the <strong class="bold">microservices architecture</strong> has been transformational in developing rapid, agile, and enterprise-grade web services to address the unique challenges and requirements of today's world. The microservices architecture has turned the page toward disciplining the standards on developing these web services. In this chapter, we will walk through the evolution of web services to microservices. We will quickly dive into some useful microservices design patterns. We will zero in on the key pitfalls in most of the traditional Java development frameworks and how their surface-level adoption to the microservices architecture has elevated performance and optimization issues. We will then explore how the Micronaut framework has addressed these performance and optimization issues in the microservices with an overhauled and ground-up approach to microservices development. Lastly, to get started with the Micronaut framework, we will set up the Micronaut CLI and work on a small hello world project.</p>
			<p>In this chapter, we will focus on these topics in particular:</p>
			<ul>
				<li>Introducing microservices and their evolution</li>
				<li>Understanding microservices design patterns</li>
				<li>Why Micronaut is the best choice for developing microservices</li>
				<li>Getting started with the Micronaut framework</li>
				<li>Working on the hello world project in the Micronaut framework</li>
			</ul>
			<p>By the end of this chapter, you will have an understanding of how web services evolved in to microservices and why traditional Java frameworks are ineffective for developing microservices as compared to the Micronaut framework. Furthermore, we will also gain the practical knowledge to start using the Micronaut framework by working on a small project in the Micronaut framework.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>All the commands and technical instructions in this chapter are run on Windows 10 and mac OS X. Code examples covered in this chapter are available in the book's GitHub repository at <a href="https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01">https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter01</a>.</p>
			<p>The following tools need to be installed and set up in the development environment:</p>
			<ul>
				<li><strong class="bold">Java SDK</strong>: Version 13 or above (we used Java 14).</li>
				<li><strong class="bold">Maven</strong>: This is optional and only required if you would like to use Maven as the build system. However, we recommend having Maven set up on any development machine. Instructions to download and install Maven can be found at <a href="https://maven.apache.org/download.cgi">https://maven.apache.org/download.cgi</a>.</li>
				<li><strong class="bold">Development IDE</strong>: Based on your preferences, any Java-based IDE can be used, but for the purpose of writing this chapter, IntelliJ was used. </li>
				<li><strong class="bold">Git</strong>: Instructions to download and install Git can be found at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Introducing microservices and their evolution</h1>
			<p>Before we thoroughly jump into <a id="_idIndexMarker000"/>introducing and defining microservices, it will be helpful to know how microservices have evolved. In the late 1960s, Alan Kay coined the term <strong class="bold">object-oriented programming</strong>. Though it <a id="_idIndexMarker001"/>was a definitive idea, later it birthed the four pillars for building software solutions using object-oriented programming:</p>
			<ul>
				<li>Encapsulation</li>
				<li>Inheritance</li>
				<li>Polymorphism</li>
				<li>Abstraction </li>
			</ul>
			<p>In a short mnemonic, it's known as EIPA. Since the inception of these four pillars, the software industry has seen the rise and fall of many programming languages, frameworks, design patterns, and so on. With each such adaption and idea, thinkers and tinkerers have tried to come closer to EIPA by keeping a modular design and loosely coupled yet tightly encapsulated application components. Over the last few decades, software teams have moved away from the art of object-oriented programming toward the science of object-oriented programming by systematically adopting these key pillars. This iterative journey is the evolution of microservices.</p>
			<p>In the late 1980s and early 1990s, almost <a id="_idIndexMarker002"/>every enterprise application was exposed as either a command line or native desktop software. Applications were tightly connected to databases and it was almost as if the end user was directly interacting with the database with the application as a thin façade in between. It was the era of monolithic applications or client/server architecture. </p>
			<p>In the proceeding diagram, we can see how users interacted with a monolith application:</p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="image/Figure_1.1_B16585.jpg" alt="Figure 1.1 – Monolithic client/server architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Monolithic client/server architecture</p>
			<p>As depicted in <em class="italic">Figure 1.1</em>, in monolithic client/server architecture, the application is tightly coupled to the database and the user interacts through a terminal façade or desktop application. In this architecture, it was painful to <a id="_idIndexMarker003"/>maintain good <strong class="bold">service-level agreements</strong> (<strong class="bold">SLAs</strong>). Almost all the key non-functional factors such as scalability, high availability, fault tolerance, and flexibility underperformed or failed.</p>
			<p>To address some of <a id="_idIndexMarker004"/>these aspects <strong class="bold">service-oriented architecture</strong> (<strong class="bold">SOA</strong>) came into existence. In the 2000s, SOA was formalized in the industry with the definition of <a id="_idIndexMarker005"/>some standard protocols such as <strong class="bold">Simple Object Access Protocol (SOAP</strong>). <strong class="bold">Web Services Description Language</strong> (<strong class="bold">WSDL</strong>) was <a id="_idIndexMarker006"/>also created during this period. Web 2.0 applications <a id="_idIndexMarker007"/>were popular with <strong class="bold">Asynchronous JavaScript And XML (AJAX</strong>). Enterprise service bus and messaging systems were highly used in enterprise applications. Advancements in SOA catalyzed a new paradigm of delivering software solutions to <a id="_idIndexMarker008"/>end users: <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>). Instead of desktop applications and terminal clients, software solutions were delivered to <a id="_idIndexMarker009"/>end users over HTTP as hosted online services. In the proceeding diagram, we can see how users interacted with an SOA-based application:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/Figure_1.2_B16585.jpg" alt="Figure 1.2 – SOA&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – SOA</p>
			<p>As shown, SOA brought in some decoupling by separating the concerns between the web application, web server, and app server. App servers or <strong class="bold">enterprise service buses</strong> (<strong class="bold">ESBs</strong>) usually <a id="_idIndexMarker010"/>interact with the database and the user interacts with the application by accessing it on web browsers (SaaS solutions). Though SOA brought some relief, the adoption of SaaS left scalability and flexibility as key unhashed puzzles. </p>
			<p>Post-2010, the technology world started to move much faster than it did in the previous two decades. With the introduction of containers, the cloud, big data, and machine learning, everything <a id="_idIndexMarker011"/>started moving rapidly in architecture design. It is the era of Uber, Airbnb, Netflix, and freemium/premium applications. Applications are designed for distributed computing and scalability. With the microservices architecture, the application is decomposed to loosely coupled microservices where each microservice owns its database. In the proceeding diagram, we can see how users interact with a microservices-based application:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.3_B16585.jpg" alt="Figure 1.3 – Microservices architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Microservices architecture</p>
			<p>In the previous diagram, we can see a fully realized microservices application where each microservice interacts with and owns its database. The user interacts with a single-page application through a modern browser. Any incoming requests from the web server are routed to the respective microservice. The full realization of microservices architecture is to address key factors of scalability, fault tolerance, high availability, and flexibility. </p>
			<p>To put it simply, microservices or microservices architecture componentize an application into a collection of interacting services. Each service could be developed, tested, deployed, and maintained independently. Thus, each smaller (micro) service has its own unique life cycle. Furthermore, since each service is loosely coupled (interacting with other services using HTTP/HTTPS), we can do the following:</p>
			<ul>
				<li>Scale up or scale down (based on the service traffic).</li>
				<li>Address any runtime faults (boot up the service backup).</li>
				<li>Make new changes (change impact is limited to the service).</li>
			</ul>
			<p>Therefore, through the <a id="_idIndexMarker012"/>complete realization of decoupled architecture in the microservices, we address key issues of scalability, fault tolerance, high availability, and flexibility.</p>
			<p>So far, we have learned about microservices and their evolution and how they have been transformational in addressing the unique, rapid, and agile needs of today's world. This understanding is a good preface to realizing the potential of microservices. In the next section, we will dive into the microservices design patterns. </p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Understanding microservices design patterns</h1>
			<p>To fully realize the <a id="_idIndexMarker013"/>benefits of any architecture (including the microservices architecture), an architectural approach is often backed with design patterns. Understanding these design patterns is crucial for an ideal adoption of the architecture. In the following sections, we will cover some practical and commonly used design patterns in microservices. Each pattern addresses a different aspect of the application development life cycle and our focus would be to see these design patterns from a practical usage standpoint. We will begin with decomposition design patterns.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Decomposition design patterns</h2>
			<p>Decomposition design patterns <a id="_idIndexMarker014"/>dictate how <a id="_idIndexMarker015"/>we can componentize or decompose a big/monolithic application into smaller (micro) services. These patterns come in handy in designing a transformational architecture for any legacy monolithic application. The following are the most commonly used design patterns in decompositions.</p>
			<h3>Decomposing by business capability</h3>
			<p>Any business capability is an <a id="_idIndexMarker016"/>instrument to <a id="_idIndexMarker017"/>make a profit. If we can enlist and categorize an application into a set of business capabilities such as inventory management, customer orders, or operations, then the application can be decomposed into microservices that are based on these business capabilities. This <a id="_idIndexMarker018"/>process to decompose is <a id="_idIndexMarker019"/>effective and recommended for small- to medium-sized applications.</p>
			<h3>Decomposing by domains/sub-domains</h3>
			<p>If the application is an <a id="_idIndexMarker020"/>enterprise-grade and heavy application, then the previous approach may end up decomposing the application into <a id="_idIndexMarker021"/>smaller monoliths. These monoliths are smaller but monoliths nonetheless. In such cases, business modeling can help to categorize and map application functionalities into domains and sub-domains. Functionalities inside a domain/sub-domain are similar but very different from the functionalities of other domains/sub-domains. Microservices then can be designed and built around domains or sub-domains (if there are many functionalities mapped to a domain). </p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Integration design patterns</h2>
			<p>Once the <a id="_idIndexMarker022"/>application is broken down into <a id="_idIndexMarker023"/>smaller (micro) services, we will need to establish cohesion among these services. Integration design patterns address such collaboration requirements. The following are the most commonly used design patterns in integrations.</p>
			<h3>The API gateway pattern</h3>
			<p>Often upstream <a id="_idIndexMarker024"/>frontend consumers need to <a id="_idIndexMarker025"/>access microservices through a façade. This façade is called an API gateway. The API gateway design pattern serves an important purpose to keep things simple for frontend clients:</p>
			<ul>
				<li>The frontend client is not sending too many requests to microservices.</li>
				<li>The frontend client is not processing/aggregating too many responses (from microservices).</li>
				<li>At the server end, the gateway routes a request to multiple microservices, and these microservices can run in parallel.</li>
				<li>Before sending the <a id="_idIndexMarker026"/>final response, we can <a id="_idIndexMarker027"/>aggregate individual responses from different microservices.</li>
			</ul>
			<h3>The aggregator pattern</h3>
			<p>This pattern is very <a id="_idIndexMarker028"/>similar to the aforementioned <a id="_idIndexMarker029"/>API gateway pattern. However, composite microservice is the key differential. The mandate of a composite microservice is to offload an incoming request to multiple microservices and then collaborate to create a unified response. This pattern is used when a user request is atomic from business logic standpoints, but it is processed by multiple microservices. </p>
			<h3>The chained microservices pattern</h3>
			<p>In some scenarios, an <a id="_idIndexMarker030"/>incoming request is <a id="_idIndexMarker031"/>executed in a series of steps wherein each step could be spinning off a call to a microservice. For example, ordering an item in an online marketplace would require the following:</p>
			<ol>
				<li>Searching for an item (inventory management service)</li>
				<li>Adding an item to the cart (cart service)</li>
				<li>Checking out the added item (payment service, mail service, inventory management service)</li>
			</ol>
			<p>All these service calls would be synchronous. Fulfilling a user request would be an amalgamation of all these chained microservice calls. </p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Data management patterns</h2>
			<p>Integrating <a id="_idIndexMarker032"/>with the persistence layer is an <a id="_idIndexMarker033"/>important aspect of any microservice-based application. Greenfield (net new) and brownfield (legacy transformation) applications may dictate their requirements in how to choose a data management pattern. The following are the most often used design patterns in data management in microservices.</p>
			<h3>Database per service</h3>
			<p>In greenfield (net new) applications, it is <a id="_idIndexMarker034"/>ideal to have a <a id="_idIndexMarker035"/>database per service. Each service is the owner of an isolated database (relational or non-relational) and any data operation must be executed through the microservice only. Furthermore, even if any other microservice needs to perform a database operation, then it should be routed through the owner microservice. </p>
			<h3>Shared database</h3>
			<p>In brownfield (transformational) applications, it may <a id="_idIndexMarker036"/>not be practical to decompose the database into one database per <a id="_idIndexMarker037"/>service. In such scenarios, the microservices architecture realization can be kickstarted with services sharing a common monolith database. </p>
			<h3>Command query responsibility segregation (CQRS)</h3>
			<p>In greenfield or fully <a id="_idIndexMarker038"/>transformed applications where each microservice is an independent database owner, there <a id="_idIndexMarker039"/>might be a requirement to query data from multiple databases. The CQRS pattern stipulates to decompose an application into a command and query:</p>
			<ul>
				<li><strong class="bold">Command</strong>: This part will manage any create, update, and delete requests.</li>
				<li><strong class="bold">Query</strong>: This part will manage query requests using database views where database views can unify data from multiple schemas or data sources.</li>
			</ul>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Cross-cutting patterns</h2>
			<p>Some concerns <a id="_idIndexMarker040"/>cut across all the different aspects/layers of <a id="_idIndexMarker041"/>microservices. In the following sub-sections, we will discuss some of these concerns and patterns. </p>
			<h3>The service discovery pattern</h3>
			<p>In a microservices-based application, each <a id="_idIndexMarker042"/>microservice may <a id="_idIndexMarker043"/>have more than one instance at runtime. Furthermore, these service instances can be added or removed at runtime based on traffic. This runtime agility can be an issue for upstream consumers in how they connect with services. </p>
			<p>The service discovery pattern addresses this by implementing a service registry database. The service registry is a metadata store containing information such as the service name, where the service is running, and the current status of the service. Any change to the service runtime information will be updated in the service registry, for example, when a service adds a new instance or a service is down. This eases the pain for upstream consumers to connect with different microservices in the application. </p>
			<h3>The circuit breaker pattern</h3>
			<p>In a microservices-based <a id="_idIndexMarker044"/>application, often <a id="_idIndexMarker045"/>services interact with each other by invoking endpoints. There could be a scenario where a service is calling a downstream service but the downstream service is down. Without a circuit breaker, the upstream service will keep calling the downstream service while it's down and this will keep impacting the user interaction with the application. </p>
			<p>In the circuit breaker pattern, a downstream service call will be routed through a proxy. This proxy will timeout for a fixed interval if the downstream service is down. After the timeout expiry, the proxy will try to connect again. If successful, it will connect with the downstream service; otherwise, it will renew the timeout period. Therefore, the circuit breaker will not bombard the downstream service with unnecessary calls and it will not impact user interaction with the application. </p>
			<h3>The log aggregation pattern</h3>
			<p>In the microservices landscape, often an <a id="_idIndexMarker046"/>incoming request will be processed by multiple services. Each service may create and log its entries. To <a id="_idIndexMarker047"/>trace any issues, it will be counter-intuitive to access these sporadic logs. By implementing a log aggregation pattern, logs could be indexed in a central place, thereby enabling easy access to all application <a id="_idIndexMarker048"/>logs. <strong class="bold">Elasticsearch, Logstash, Kibana</strong> (<strong class="bold">ELK</strong>) can be used to implement log aggregation. </p>
			<p>In this section, we covered some often-used design patterns in different stages of the application life cycle. Understanding these design patterns is required to fully reap the benefits of microservices architecture. In the next section, we will dive into the Micronaut framework for developing microservices. </p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Why Micronaut is the best choice for developing microservices</h1>
			<p>In the previous sections, we learned <a id="_idIndexMarker049"/>about the maturity on the architectural side of microservices. Unfortunately, on the implementation side, an overhaul shift to build/develop microservices is not as mature as microservices architecture. To address some of these implementation challenges, many traditional Java frameworks have added small, iterative changes, but much-sought-after disruptive and overhauled changes are missing. At the core, these traditional Java frameworks have stayed almost the same since the time of monolithic services. Reflections, runtime proxies, and bulky configuration management have plagued all traditional frameworks with slower boot time and bigger memory footprints, making them unsuitable for microservices development.</p>
			<p>Micronaut is developed from the bottom up, considering these important challenges, to organically support microservices development:</p>
			<ul>
				<li><strong class="bold">Dependency injection</strong>: Micronaut uses JSR-330 <strong class="source-inline">@Inject</strong> for dependency injection. It adds the <em class="italic">Java inject</em> module to the compiler and all the annotations are processed at compile time. The compiler generates the byte code for all the classes based on the annotations that are used in their source code. This is all done at compile time. At runtime, Micronaut can instantiate the beans and read their metadata from the generated byte code and does not need to use the slow reflection API.</li>
				<li><strong class="bold">Ahead-of-time compilation</strong>: As discussed before, one of the key contrasts is that Micronaut performs dependency injection, configuration management, and aspect-oriented programming proxying at compile time. Micronaut relies on one or more annotation processors to process the annotation metadata <a id="_idIndexMarker050"/>into <strong class="bold">ASM</strong>-generated (<strong class="bold">assembly</strong>) byte code. Furthermore, this ahead-of-time-generated byte code is <a id="_idIndexMarker051"/>further optimized by Java's <strong class="bold">just-in-time</strong> (<strong class="bold">JIT</strong>) compiler. Other frameworks use reflection and produce the annotation metadata at application boot-up. This metadata is loaded to runtime memory, therefore increasing the memory footprint. Instead <a id="_idIndexMarker052"/>of the Java Reflection API, Micronaut uses the Java annotation processor API, the Kotlin compiler plugin for annotation processors, and Groovy AST transformations for metaprogramming.</li>
				<li><strong class="bold">Faster boot-up time and lower memory consumption</strong>: Other frameworks use Java reflections and at application boot-up, all classpaths are scanned to generate reflection metadata for each field, method, and constructor. This metadata is then used to determine and inject the required object into the application runtime. This adds significantly to boot-up time as well as runtime memory. As discussed previously, Micronaut uses ahead-of-time compilation and the Java annotation processor API to offload such work from the runtime and reduce memory requirements by not pushing unnecessary reflection metadata onto runtime memory.</li>
				<li><strong class="bold">Serverless applications support</strong>: One of the key issues in serverless applications is boot-up time. With a huge memory footprint and slower boot-up time, traditional frameworks are not a prudent choice to develop serverless applications. Micronaut organically supports serverless application development by keeping the minimal runtime memory footprint and sub-second boot-up time. Furthermore, Micronaut natively supports commonly used cloud platforms for serverless function development.</li>
				<li><strong class="bold">Language-agnostic framework</strong>: The Micronaut framework supports the Java, Kotlin, and Groovy programming languages. With varied support for major programming languages, developers can choose their preferred language option when considering cloud requirements. For example, for IoT requirements, Groovy could be a good option. This language-agnostic enablement makes it flexible and apt for varied requirements of mobile/web/cloud solutions.</li>
				<li><strong class="bold">Support to GraalVM</strong>: Since Micronaut doesn't use reflections, any Micronaut-based application can be ahead-of-time compiled into a GraalVM native image. GraalVM is a universal virtual machine offered by Oracle that can run a Java application down to machine code. This increases application performance significantly. Any <a id="_idIndexMarker053"/>Micronaut application compiled to a GraalVM native image can boot up in milliseconds. </li>
			</ul>
			<p>In light of the preceding key points, Micronaut stands out as a preferred framework to develop cloud-native, ultra-light, and rapid microservices. In addition, we performed a quick benchmark experiment to compare the application startup times for Micronaut versus another popular traditional framework. In the following chart, startup times are shown for both Micronaut and a traditional framework:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.4_B16585.jpg" alt="Figure 1.4 – Startup times for a traditional framework versus Micronaut&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Startup times for a traditional framework versus Micronaut</p>
			<p>As shown in the preceding chart, the traditional framework took 6,156 milliseconds to boot up whereas Micronaut took only 3,750 milliseconds. This time difference in booting up the <a id="_idIndexMarker054"/>application is significant and sets Micronaut as a go-to framework for developing cloud-native and rapid microservices. </p>
			<p>In the following section, we will get started with using the Micronaut framework on both Windows as well as mac OS.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Getting started with the Micronaut framework</h1>
			<p>In order to get started with <a id="_idIndexMarker055"/>the Micronaut framework, we will begin by installing the Micronaut CLI on Mac and Windows OS.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Installing the Micronaut CLI on mac OS</h2>
			<p>On mac OS, we <a id="_idIndexMarker056"/>can install the <a id="_idIndexMarker057"/>Micronaut CLI in a couple of ways – using SDKMAN!, Homebrew, or MacPorts. In the following sections, we will cover step-by-step instructions to install the Micronaut CLI.</p>
			<h3>Installing Micronaut using SDKMAN!</h3>
			<p>Please <a id="_idIndexMarker058"/>follow these steps to <a id="_idIndexMarker059"/>install the Micronaut CLI using SDKMAN!:</p>
			<ol>
				<li value="1">Open Terminal.</li>
				<li>If you don't have SDKMAN! installed, take the following steps:<p>a. Type or paste the following command:</p><p class="source-code"><strong class="bold">curl -s https://get.sdkman.io | bash</strong></p><p>b. Next, type or paste the following command: </p><p class="source-code"><strong class="bold">source "$HOME/.sdkman/bin/sdkman-init.sh"</strong></p></li>
				<li>To install the Micronaut CLI, type or paste the following command:<p class="source-code"><strong class="bold">source sdk install micronaut</strong></p><p>You will observe the following interactions on Terminal while installing the Micronaut CLI:</p><div id="_idContainer010" class="IMG---Figure"><img src="image/Figure_1.5_B16585.jpg" alt="Figure 1.5 – Installing Micronaut CLI on mac OS using SDKMAN!&#13;&#10;"/></div><p class="figure-caption">Figure 1.5 – Installing Micronaut CLI on mac OS using SDKMAN!</p></li>
				<li>If all the preceding steps <a id="_idIndexMarker060"/>execute successfully, you can verify the <a id="_idIndexMarker061"/>Micronaut CLI installation by running the following command in Terminal:<p class="source-code"><strong class="bold">mn -version</strong></p></li>
			</ol>
			<h3>Installing Micronaut using Homebrew</h3>
			<p>Please <a id="_idIndexMarker062"/>follow these <a id="_idIndexMarker063"/>steps to install the Micronaut CLI using MacPorts:</p>
			<ol>
				<li value="1">Open Terminal. </li>
				<li>If you don't have Homebrew installed, then take the following steps:<p>a. Type or paste the following command:</p><p class="source-code"><strong class="bold">/bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)"</strong></p><p>b. Next, type or paste the following command:</p><p class="source-code"><strong class="bold">brew update </strong></p></li>
				<li>Type or paste the following command:<p class="source-code"> <strong class="bold">brew install micronaut</strong></p><p>You will observe the following interactions on Terminal while installing the Micronaut CLI:</p><div id="_idContainer011" class="IMG---Figure"><img src="image/Figure_1.6_B16585.jpg" alt="Figure 1.6 – Installing the Micronaut CLI on mac OS using HomeBrew&#13;&#10;"/></div><p class="figure-caption">Figure 1.6 – Installing the Micronaut CLI on mac OS using HomeBrew</p></li>
				<li>If all the preceding steps execute successfully, you can verify the Micronaut CLI installation by hitting the <a id="_idIndexMarker064"/>following <a id="_idIndexMarker065"/>command in Terminal:<p class="source-code"><strong class="bold">mn -version</strong></p></li>
			</ol>
			<h3>Installing Micronaut using MacPorts</h3>
			<p>Please follow <a id="_idIndexMarker066"/>these steps to install the Micronaut CLI <a id="_idIndexMarker067"/>using Homebrew:</p>
			<ol>
				<li value="1">If you don't have MacPorts installed, then follow the instructions at <a href="https://www.macports.org/install.php">https://www.macports.org/install.php</a>.</li>
				<li>Open Terminal.</li>
				<li>Type or paste the following command:<p class="source-code"><strong class="bold">sudo port sync</strong></p></li>
				<li>Type or paste the following command: <p class="source-code"><strong class="bold">sudo port install micronaut</strong></p><p>You will observe the following interactions on Terminal while installing the Micronaut CLI:</p><div id="_idContainer012" class="IMG---Figure"><img src="image/Figure_1.7_B16585.jpg" alt="Figure 1.7 – Installing the Micronaut CLI on macOS using MacPorts&#13;&#10;"/></div><p class="figure-caption">Figure 1.7 – Installing the Micronaut CLI on macOS using MacPorts</p></li>
				<li>If all the preceding steps <a id="_idIndexMarker068"/>execute successfully, you can verify the <a id="_idIndexMarker069"/>Micronaut CLI installation by hitting the followed command in Terminal:<p class="source-code"><strong class="bold">mn -version</strong></p></li>
			</ol>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Installing the Micronaut CLI on Windows</h2>
			<p>Please follow these steps <a id="_idIndexMarker070"/>to install the Micronaut CLI on <a id="_idIndexMarker071"/>Windows:</p>
			<ol>
				<li value="1">Download the Micronaut CLI binary from the Micronaut download page: <a href="https://micronaut.io/download.html">https://micronaut.io/download.html</a>.</li>
				<li>Unzip the downloaded binary file into a folder on your system. It is better to keep this in a separate folder under a root directory such as <strong class="source-inline">C:\Program Files\Micronaut</strong>.</li>
				<li>Create a new system variable called <strong class="source-inline">MICRONAUT_HOME</strong> with the preceding directory path. Please note to add this variable under system variables (not user variables).</li>
				<li>Then, update your <a id="_idIndexMarker072"/>Windows <strong class="source-inline">PATH</strong> environment variable. You <a id="_idIndexMarker073"/>can add a path such as <strong class="source-inline">%MICRONAUT_HOME%\bin</strong>.</li>
				<li>Open Command Prompt or any terminal and type the following command:<p class="source-code"><strong class="bold">mn</strong></p><p>This will boot up the CLI for the first time by resolving any dependencies.</p></li>
				<li>To test that the CLI is installed properly, type the following command:<p class="source-code"><strong class="bold">mn – h</strong></p><p>This is what the command outputs:</p><div id="_idContainer013" class="IMG---Figure"><img src="image/Figure_1.8_B16585_Fixed.jpg" alt="Figure 1.8 – Installing the Micronaut CLI on Windows OS&#13;&#10;"/></div><p class="figure-caption">Figure 1.8 – Installing the Micronaut CLI on Windows OS</p></li>
				<li>You should see <a id="_idIndexMarker074"/>all the <strong class="bold">CLI</strong> options after hitting the preceding <a id="_idIndexMarker075"/>command.</li>
			</ol>
			<p>In this section, we explored different ways to install the Micronaut CLI in Windows and macOS. In order to get hands-on with the Micronaut framework, we will get started with working on a hello world project in the next section.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Working on a hello world project in the Micronaut framework</h1>
			<p>To understand the practical <a id="_idIndexMarker076"/>aspects of using the Micronaut framework for developing a microservice, we will work with a hello world project. This will help you quickly get started with the Micronaut framework and also give you first-hand experience of how easy it is to do microservices development.</p>
			<p>Micronaut works seamlessly with <a id="_idIndexMarker077"/>the Maven and Gradle packaging managers. We will cover one example for each using the Micronaut CLI as well as Micronaut Launch (web interface) for generating barebones projects.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Creating a hello world project using the Micronaut CLI</h2>
			<p>Please take the <a id="_idIndexMarker078"/>following steps to create a <a id="_idIndexMarker079"/>hello world application using the Micronaut CLI:</p>
			<ol>
				<li value="1">Open the terminal (or Command Prompt).</li>
				<li>Change the directory to your desired directory where you want to create the hello world project.</li>
				<li>Type the following command:<p class="source-code"><strong class="bold">mn create-app hello-world-maven --build maven</strong></p></li>
				<li>Wait for the Micronaut CLI to finish and it will create a <strong class="source-inline">hello-world-maven</strong> project. The <strong class="source-inline">create-app</strong> command will create a boilerplate project for you with a Maven build and your system-installed Java version. It will create <strong class="source-inline">Application.java</strong> as well as a sample test class called <strong class="source-inline">ApplicationTest.java</strong>.</li>
				<li>To explore your freshly created <strong class="source-inline">hello-world-maven</strong> project, open this project in your preferred IDE. </li>
				<li>To run your project, run the following command in a Bash terminal:<p class="source-code"><strong class="bold">./mvnw compile exec:exec</strong></p><p>Please note that if you are copying the project from somewhere else, then it's required to regenerate <strong class="source-inline">mvnw</strong> by typing the following command:</p><p class="source-code"><strong class="bold">mvn -N io.takari:maven:wrapper</strong></p></li>
				<li>The Maven wrapper will <a id="_idIndexMarker080"/>build and run your <a id="_idIndexMarker081"/>project on <strong class="source-inline">http://localhost:8080</strong> by default.</li>
			</ol>
			<h3>Adding HelloWorldController </h3>
			<p>To create a simple endpoint, let's add a <a id="_idIndexMarker082"/>simple controller to the <strong class="source-inline">hello-world-maven</strong> project:</p>
			<ol>
				<li value="1">Add a web package to our <strong class="source-inline">hello-world-maven</strong> project.</li>
				<li>Add a <strong class="source-inline">HelloWorldController</strong> Java class. It will contain a simple <strong class="source-inline">hello</strong> endpoint:<p class="source-code">@Controller("/hello")</p><p class="source-code">public class HelloController {</p><p class="source-code">    @Get("/")</p><p class="source-code">    @Produces(MediaType.TEXT_PLAIN)</p><p class="source-code">    public String helloMicronaut() {</p><p class="source-code">        return "Hello, Micronaut!";</p><p class="source-code">    }</p><p class="source-code">}</p><p><strong class="source-inline">HelloController</strong> is accessible on the <strong class="source-inline">…/hello</strong> path. <strong class="source-inline">helloMicronaut()</strong> will generate a plain text <strong class="source-inline">"Hello, Micronaut!"</strong> message.</p></li>
				<li>Rerun your application and hit <a href="http://localhost:8080/hello/">http://localhost:8080/hello/</a> in a browser window. The server will return the following response:</li>
			</ol>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_1.9_B16585_Fixed.jpg" alt="Figure 1.9 – Hello, Micronaut!&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Hello, Micronaut!</p>
			<p>By default, the application will be accessible on port <strong class="source-inline">8080</strong>, and this <a id="_idIndexMarker083"/>port can be changed in the application properties.</p>
			<p>So far, we have worked on a hello world project using the Micronaut CLI. Next, we will explore Micronaut Launch, which is a web interface, to generate a boilerplate project.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Creating a hello world project using Micronaut Launch</h2>
			<p><strong class="bold">Micronaut Launch</strong> (<a href="https://micronaut.io/launch/">https://micronaut.io/launch/</a>) is an <a id="_idIndexMarker084"/>intuitive web interface that came into existence with <a id="_idIndexMarker085"/>Micronaut 2.0.1. We can <a id="_idIndexMarker086"/>use this interface to quickly generate boilerplate for different kinds of Micronaut applications (such as server applications, the CLI, serverless functions, a messaging application, and so on). Let's quickly use this to generate a hello world application for us.</p>
			<p>Please follow these instructions to generate the hello world project using the Micronaut Launch web interface:</p>
			<ol>
				<li value="1">Open Micronaut Launch in a browser window: <a href="https://micronaut.io/launch/">https://micronaut.io/launch/</a>.</li>
				<li>Under <strong class="bold">Application Type</strong>, choose <strong class="bold">Application</strong>.</li>
				<li>Under <strong class="bold">Micronaut Version</strong>, choose <strong class="bold">2.0.1</strong>.</li>
				<li>For the Java version, choose <strong class="bold">Java 14</strong>.</li>
				<li>For <strong class="bold">Language</strong>, choose <strong class="bold">Java</strong>.</li>
				<li>Give a base package name such as <strong class="source-inline">com.packtpub.micronaut</strong>.</li>
				<li>Choose <strong class="bold">Gradle</strong> as the build option.</li>
				<li>Give a name to the application, such as <strong class="source-inline">hello-world-gradle</strong>.</li>
				<li>Choose <strong class="bold">JUnit</strong> as the testing framework</li>
				<li>After you've finished choosing all the options, click on <strong class="bold">GENERATE PROJECT</strong>. </li>
			</ol>
			<p>After choosing the preceding <a id="_idIndexMarker087"/>options and providing <a id="_idIndexMarker088"/>various inputs, the Micronaut Launch interface should look as follows:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_1.10_B16585_Fixed.jpg" alt="Figure 1.10 – Using Micronaut Launch to generate a boilerplate project&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – Using Micronaut Launch to generate a boilerplate project</p>
			<p>Your project boilerplate source code will be generated into a zipped file. You can unarchive this zipped file into your desired directory and open it in your preferred IDE. Just like the previous example (<strong class="source-inline">hello-world-maven</strong>), we can add a basic <strong class="source-inline">HelloWorldController</strong> instance.</p>
			<p>To run your project, run the following command in a Bash terminal:</p>
			<p class="source-code">gradlew.bat run</p>
			<p>When the project is running, go to <strong class="source-inline">http://localhost:8080/hello</strong> and you should see the <strong class="bold">Hello, Micronaut!</strong> message in the browser tab. </p>
			<p>In this section, we explored how to<a id="_idIndexMarker089"/> get started with the <a id="_idIndexMarker090"/>Micronaut framework by developing small hello world projects using the Micronaut CLI as well as the Micronaut Launch user interface. This small exercise will be a good preface for what we will cover in the next chapter.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>Summary</h1>
			<p>In this chapter, we began our journey into microservices by exploring their evolution and some useful design patterns. We covered the Micronaut framework in contrast to the traditional reflection-based Java frameworks. Essentially, Micronaut's approach to leverage ahead-of-time compilation (and not reflections) sets it apart as an ideal framework for developing microservices. To get our hands dirty, we went through setting up the Micronaut CLI on mac OS as well as Windows OS. Lastly, we worked on <strong class="source-inline">hello-world-maven</strong> and <strong class="source-inline">hello-world-gradle</strong> projects. In both projects, we added <strong class="source-inline">hello</strong> endpoints. </p>
			<p>With the fundamentals of microservices as well as practical hello world projects covered, this chapter enhanced your knowledge of the evolution of microservices, their design patterns, and why Micronaut should be preferred for developing microservices. This foundational understanding is the bedrock for starting the adventure of microservices development in the Micronaut framework.</p>
			<p>At the end of this chapter, we kickstarted an exciting journey into microservices development using the Micronaut CLI and Micronaut Launch. In the next chapter, we will explore how we can integrate different kinds of persistent storage and databases in the Micronaut framework.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Questions</h1>
			<ol>
				<li value="1">How did web services evolve into microservices?</li>
				<li>What is a microservice?</li>
				<li>What is the microservice architecture?</li>
				<li>What are the microservices design patterns?</li>
				<li>What is Micronaut?</li>
				<li>Why should Micronaut be preferred for developing microservices? </li>
				<li>Which framework should be used to develop microservices?</li>
				<li>How do you install the Micronaut CLI on macOS?</li>
				<li>How do you install the Micronaut CLI on Windows OS?</li>
				<li>How do you create a project using the Micronaut CLI?</li>
				<li>How do you create a project using Micronaut Launch?</li>
			</ol>
		</div>
	</body></html>