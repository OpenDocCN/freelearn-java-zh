- en: Business Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will cover definitions of the Business Delegate pattern,
    the Session Façade pattern, and the business-object pattern. We will show the
    reasons to use these design patterns, common approaches to each of them, their
    interaction with other patterns, their evolution, and how they behave in the real
    world. We will also demonstrate some examples of these patterns' implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the chapter, you will be able to identify the correct scenarios
    to apply business patterns and choose the best methods for implementing them.
    The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the business tier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the Business Delegate pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the Session Façade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the Session Façade pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the business-object pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the business-object pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the business tier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before talking about the business patterns and the use of these patterns from
    the perspective of JEE8 and its technologies, we must identify where the business
    logic of an application will be within the JEE framework. As we have already seen,
    JEE architecture basically has three tiers. Most JEE technologies, such as **Enterprise
    Java Beans **(**EJB**) and **Java Persistence API** (**JPA**), are related to
    the business tier. The EJB container is located in the business tier, but there
    are a few other technologies that navigate the entire JEE framework, such as CDI
    and Bean Validation. However, the most important thing to know is that the core
    business-logic application is executed in the business tier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see three important patterns in the business tier. We will briefly
    explain the definition and goal of each pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Business Delegate pattern**: It is a proxy for the business service, hiding
    the service lookup and the remote invocation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Session Façade ****pattern**: Encapsulates business rules and exposes coarse-grained
    services to clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Business-object ****pattern**: These are real-world objects with properties
    and methods for applications with a high level of complexity which help to separate
    business logic from the rest of the application, promoting a decoupling between
    business logic and the rest of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e328af9d-10e6-424c-80c5-e4116fba3328.png)'
  prefs: []
  type: TYPE_IMG
- en: We will see later in this chapter that, although the Business Delegate is a
    business-tier component, its physical location is on the web tier.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Business Delegate pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To explain the Business Delegate pattern, we need to understand some points
    that show the reason and evidence for the real goals of this pattern. Thus, we
    will show these points and explain the Business Delegate pattern in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Client tier, presentation tier, and business tier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we go on, here is a brief explanation of the concept of tiers and layers.
  prefs: []
  type: TYPE_NORMAL
- en: Layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A layer is merely a logical division that has a responsibility within the architecture
    of the application. It is a logical way to organize the application code. Martin
    Fowler''s book *Patterns of Enterprise Application Architecture* describes the
    three main layers and their responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Layer** | **Responsibility** |'
  prefs: []
  type: TYPE_TB
- en: '| Presentation | User interaction, validation of input fields, formatting display
    data |'
  prefs: []
  type: TYPE_TB
- en: '| Business | Application logic |'
  prefs: []
  type: TYPE_TB
- en: '| Data | Database communication, messaging-system communication |'
  prefs: []
  type: TYPE_TB
- en: Thus, the classes of an application are logically separated according to their
    responsibilities. There are classes that are used in the data-access layer, while
    other classes prepare the data to be displayed as part of the presentation layer.
    This division is purely logical. A good architecture practice is to have a layered
    chain where a layer interacts with its adjacent layer, providing and consuming
    services. This leads to more cohesion (the same responsibilities are contained
    in the same layer) and low-coupling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/46bcf26c-96ea-4295-b37d-a63d6b04a013.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that the JSF, JSP, and HTML pages, the bean-backing class, and even
    a servlet belong logically to the presentation layer group, since they have the
    same basic responsibility, which is to send information to the user and receive
    requests from a user. An EJB, a servlet (part of it), and a **Business Object**
    belong to the business layer. The DAO classes and the JPA entities belong to the
    data layer.
  prefs: []
  type: TYPE_NORMAL
- en: Tiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A tier is a physical unit, and it is related to hardware and software components.
    It is the infrastructure in which the layer components are deployed and executed.
    Examples of tiers are web browsers, application servers, and database servers.
    A typical *n*-tier application is defined with the following tiers:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Tier** | **Infrastructure** |'
  prefs: []
  type: TYPE_TB
- en: '| Client  | Web browsers, a mobile device |'
  prefs: []
  type: TYPE_TB
- en: '| Presentation  | Web server (container), HTTP protocol |'
  prefs: []
  type: TYPE_TB
- en: '| Business | Application server (such as Java EE server) |'
  prefs: []
  type: TYPE_TB
- en: '| Data/Integration | Database servers, messaging service, web services |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/126719f2-c50e-4c1c-8f5a-e62737e33a1a.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, it is very important to note the difference between the client tier and
    the presentation tier. The client tier is where a client application is executed
    (through platforms such as a browser or a mobile application). Generally, the
    client tier is the client machine or device, and the presentation tier is represented
    by the web server. The presentation tier receives a data request from the client
    tier, prepares the data (with some format defined previously, if necessary), and
    sends it to the business tier. This is the classic mechanism of how data is processed
    in a JEE scenario. We can identify some technologies in the presentation tier,
    such as Servlets, JSP, JSF, WebSockets, JAX‐RS and JAX‐WS, Java API for JSON processing,
    JSON-B, CDI, and bean validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2559f07b-01a4-48a9-87e0-4effbec201e9.png)'
  prefs: []
  type: TYPE_IMG
- en: As previously discussed, it is in the business tier that all business logic
    is executed. The presentation tier is the client of the business tier because
    it requires operations of the business tier and receives the result that comes
    from the business tier. At this point, we can see an additional responsibility
    for the presentation tier, which is to locate the service and make the request.
    It would be interesting if we had a mechanism that delegated the request to the
    real service. This is the role of the Business Delegate pattern, which prevents
    details of the business tier services from being exposed to the presentation tier. The
    coupling between the presentation and business tiers is reduced, and therefore
    modifications in the business tier have a minimal impact in the presentation tier.
  prefs: []
  type: TYPE_NORMAL
- en: The Business Delegate pattern acts as an input door for the client. It is responsible
    for receiving the request, identifying or locating the real business service,
    and calling the service sending the request. After that, the delegate receives
    the service response and then sends the response back to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The classic Business Delegate pattern scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a classic Business Delegate pattern scenario, the implementation of the Business
    Delegate pattern receives a request from a Java client and sends the response
    back to it. In addition, to minimize the coupling between the presentation tier
    and the business tier, it was the responsibility of a delegate to locate remote
    services (in most cases, a remote EJB service) and provide a caching mechanism
    for accessing business services to reduce the network traffic.
  prefs: []
  type: TYPE_NORMAL
- en: So, when EJB was used as a remote service in the past, Business Delegate patterns
    were used with another pattern, the Service Locator Pattern, which is responsible
    for locating the remote (and local) EJB. Also, the stub (a kind of EJB reference
    based on the **RMI** (**Remote Method Invocation**) protocol) of the remote EJB
    is cached by the delegate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the class diagram for the Business Delegate pattern.
    This represents the basic structure of this pattern. The client sends requests
    to the **Business Delegate**, which in turn accesses the correct business service.
    The **Business Delegate** can use a service locator in the case of a remote service
    lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/460cf5b5-4878-40d4-a4ad-a4c8e8becdb6.png)'
  prefs: []
  type: TYPE_IMG
- en: As the **Business Delegate** re-passes the business request to the **Business
    Service**, one natural approach in code development is to make both classes (**Business
    Delegate** and **Business Service**) implement the same business interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b33e8b74-438a-4b44-adc3-4dbd551678dc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the following diagram, we show the sequence diagram for the Business Delegate
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1db85698-a1ad-44ee-9d45-263217219320.png)'
  prefs: []
  type: TYPE_IMG
- en: The benefits of the Business Delegate pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'According to the old J2EE architecture, the benefits of a Business Delegate
    included:'
  prefs: []
  type: TYPE_NORMAL
- en: Hiding the details of the underlying business service. In the case of remote
    services, using the Business Delegate makes naming and looking up services transparent
    to the presentation tier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling business-service exceptions. The Business Delegate can catch service
    exceptions that have a technical meaning and translate them into a more friendly
    exception, generating application exception level to the client. For instance,
    Business Delegate could translate the eventual remote exceptions generated by
    a business service into a specific application exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Business Delegate can transparently carry out a new retry of a failed service
    execution and hide the problem from the client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, a Business Delegate can cache references to remote business services
    in order to improve performance. Calling a remote service is a costly operation,
    and the repetition of remote service calls can greatly increase network traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, as new scenarios have arisen, things have evolved in the world of distributed
    application development. The JEE architecture has been changing in accordance
    with this. As modern mobile applications and web clients developed, new client
    applications, with rich JavaScript frameworks, have been emerging. As a consequence,
    the Business Delegate is seen as a bridge or door between the presentation tier
    (where technologies such as Servlet, JSP, and the JSF mechanism reside) and the
    business tier (where technologies such as EJB reside).
  prefs: []
  type: TYPE_NORMAL
- en: Business Delegate – obsolete or not
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the old J2EE architecture, both remote and local business services, such
    as EJB, use a service locator mechanism. However, dependency injection is now
    used to access local EJBs (and the option for local services is increasingly being
    used). In many cases, using a Business Delegate to look for local services has
    become somewhat obsolete for this reason. Consequently, someone could question
    the use of a pattern, such as Business Delegate, only to handle remote communications.
    This is because, since JEE5, we have begun to use DI annotations to reference
    local EJB with ease. However, if we think of a Business Delegate as a bridge for
    Session Bean EJBs, for example, then we can change these EJBs (when necessary)
    without having to worry about whether or not the presentation tier will be broken.
    If something changes in the session EJB, it is the Business Delegate's job to
    handle this change and keep the presentation tier intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the classic architecture of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/38a77928-6931-4aa1-8b50-e65896a7c33d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In some situations, this architecture was replaced by others, as shown in the
    following diagrams:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5670e52a-7936-4664-937f-6b46d7607ba3.png)'
  prefs: []
  type: TYPE_IMG
- en: '![](img/100aa4e6-665d-46fe-b1e4-4851991e037f.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the two previous alternatives, we can see the way in which Business
    Delegate can be used when there is a need to change the business service layer.
    This can be done without impacting the presentation layer. In addition, when we
    need to handle business-service exceptions and we have a client other than a web
    browser, we can use a Business Delegate with a lookup mechanism (JNDI) for the
    business services (EJBs).
  prefs: []
  type: TYPE_NORMAL
- en: There are several other architectures that can be used in application building.
    We will see that the use of the Business Delegate pattern occurs along with some
    other patterns, especially the Session Façade pattern, as shown in the diagrams.
    Another common pattern is the business-object pattern, which represents a real-world
    business object with properties and methods, not necessarily getter and setter
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the Session Façade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we introduce the Session Façade pattern, it is important to cover the
    façade patterns, which are one of the structural design patterns mentioned in the
    **Gang of Four** (**GoF**) book.
  prefs: []
  type: TYPE_NORMAL
- en: The main goal is to encapsulate the complexity of business logic in a business
    interface. Broadly speaking, this interface only exposes a small number of coarse-grained
    methods to the client. Each of these interface methods is responsible for controlling
    the underlying complexity of business logic. In this way, the internal services
    of finer granularity can be combined into a set of services that are exposed by
    the interface method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using a façade pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides coarse‐grained methods for available services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It reduces remote calls. A remote client does not need to call many fine-grained
    business objects. Instead, it executes a remote call to the exposed interface
    method, which is responsible for making local calls to the fine-grained objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can create a single channel to a legacy backend system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It decreases the coupling between the client and the fine‐grained objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's say, for example, that there is a system for checking vacancies in hotels
    in a city. The hotels offer web services to be consulted about the vacancies.
    A client application that wants to know how many vacancies are available will
    have to make a call to each web service. But if we make a call to a façade layer,
    this façade could take responsibility for searching the web services. In addition
    to reducing calls, the façade removes the high coupling that would exist between
    the client and web services.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding the problem for which the GoF façade pattern is the solution,
    we can then see a similar problem with JEE. In this case, server-side components
    are implemented as **Business Objects** (**BOs**) or POJOs. Almost every request
    coming from the client needs a BO interaction, and each BO involved in the request
    process may have a relationship with other BOs. In addition, the BO might have
    accessed an integration tier using a DAO pattern. We do not want to expose the
    complexity of the business components and their internal relationships to clients—especially
    to remote clients. We then have a Session Façade pattern as a solution to this
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Session Façade
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important not to expose the client to the complexity of using these fine-grained
    BOs. Frequent access to a large set of fine‐grained components greatly increases
    the complexity of BOs control. Transaction-control, security-management, and service-lookup
    are all examples of this complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like the GoF façade pattern, the use of a coarse-grained layer in JEE decreases
    the coupling between the client and the business components represented by BOs
    of fine granularity (and we can think of a Session Façade as an extension of the
    GoF façade pattern in JEE). The Session Façade pattern represents this coarse-grained
    layer. An architecture built with the Session Façade provides a facade of more
    generic (or coarse-grained) methods for clients. The two biggest benefits of using
    the Session Façade pattern are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It does not expose the high complexity of the business objects (BOs) and their
    relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It decreases network traffic. This occurs because remote calls are limited to
    coarse-grained methods exposed by Session Façade instead of the fine-grained business
    objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, EJB remote calling was used much more in the old JEE scenario in
    comparison to current architectures. It is important that this is taken into consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the Session Façade pattern in JEE
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the JEE architecture, Session Façade is implemented by a stateless or stateful
    EJB. An EJB object can use or combine other POJOs, business objects, and EJBs.
    At this point, we must be careful not to accumulate too many unnecessary layers,
    as we run the risk of having a chain of EJBs where one EJB calls another more
    internal EJB, and so on. The services must be mapped and designed well.
  prefs: []
  type: TYPE_NORMAL
- en: Because the Session Façade is primarily implemented by EJBs, services such as
    transaction-control and security-management come naturally to this technology.
    It is in this layer that we usually have the transaction-control of most internal
    objects, such as the POJOs, which represent entities within the JPA technology.
    For an EJB, JPA entity transaction control is native, meaning that it is supplied
    by the JEE container. This provides a large increase in productivity during development.
  prefs: []
  type: TYPE_NORMAL
- en: The classic Session Façade pattern scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Session Façade pattern can be used in several architectures. The following
    diagram shows a classic model of **Session Façade** usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2d1ecf38-09bd-48e3-88b7-7938a01ec71a.png)'
  prefs: []
  type: TYPE_IMG
- en: Looking at the preceding diagram, we can see that a client (typically a web
    component or a Business Delegate implementation) accesses the facade layer. In
    this architecture, we find some options that depict the use of the **Session Façade**.
  prefs: []
  type: TYPE_NORMAL
- en: The Façade can handle different business objects (BO). Later in this chapter,
    we will see a better description of a BO and the business-object pattern. A business
    object is the representation of a conceptual model, which is a real-world object.
    A BO may have methods that describe its behavior. In this case, we will say that
    this BO reflects a non-anemic model (an anemic domain object contains a few business
    methods, such as validation and calculation). Here, the BO can use a **Data-Access
    Object** (**DAO**) pattern as a strategy for executing CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Façade can directly access a POJO JPA (Java Persistence API) entity. If
    the conceptual model of the business object is very close to the data model, we
    can fully represent this business object (an actor of a use case of the application)
    as a persistence entity. Most of the time, a Session Façade is implemented as
    an EJB session. Although a JPA entity does not require an EJB container to run
    because it runs in both JSE and JEE environments, the EJB and JPA technologies
    make a very successful combination. Since the JEE 5.0 platform, JPA has been the
    default specification for object-relational mapping (OR mapping) and persistence-management.
    JPA version 1.0 is part of the JSR 220 specification (EJB 3.0). The final result
    of the EJB 3.0 specification is that three separate documents were produced, the
    third being the Java Persistence API. This described the persistence model for
    the JSE and JEE environments. More internal services are offered naturally by
    the implementation of the EJB technology, such as transaction and security control:'
  prefs: []
  type: TYPE_NORMAL
- en: In most applications, the Session Façade uses a DAO implementation to perform
    the crud operations with the persistence layer. We will see later that the DAO
    pattern encapsulates the details related to crud, and can directly use a JDBC
    implementation or a JPA implementation to perform the crud work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an activity diagram with the component tiers involved in the
    **Session** **Façade** pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9a5ee493-d9b5-40ce-9aef-80e85316d155.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following shows the **Session Façade** pattern-sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04597fcd-fb3b-41e8-b8d3-ba0ae4de29e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the Session Façade pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s make a small application related to the academic world. We will make
    two façades—one façade to manage the financial part of the application, and one
    to manage the academic part of the application. We will also construct some other
    classes, such as DAO classes and classes of the domain model. There is no database;
    all the data is kept in memory through the DAO classes. Consequently, the methods
    designed for finding information are built into the DAO classes. Let''s create
    the following domain model classes: `Discipline`, `Course`, `Member` (`Member`
    is an abstract class that represents a member of a college), `Professor`, and
    `Student`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `Course` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `Member` class which like the previous classes, implements the
    `Serializable` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the `Professor` class inherits the `Member` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the `Student` class, which inherits the `Member` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We could make these application entities with an `id` integer type property
    that would represent a unique entity. It is common to extend an abstract entity
    class that contains this ID. However, for the college members, we simplified it
    and used the `name` property for the identification job. In the `Discipline` and
    `Member` classes, we implemented the equals method to check for equal objects
    within a collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make some DAO classes. There is no POJO JPA entity in these examples.
    The relationships between the model objects are inserted in the DAO classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the `DisciplineDAO` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you will make the `StudentDAO` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the `ProfessorDAO` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We put a lot of responsibility in `DisciplineDAO` for simplicity. We could have
    increased the scope of the `CourseDAO` or `ProfessorDAO` class for access to data
    related to the `Professor` entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the following classes are the two Session Façade implementations: `AcademicFacadeImpl`
    and `FinancialFacadeImpl`. It is important to note that this is only one of several
    ways to build this kind of application. The next part of this chapter will cover
    the business-object pattern, and here we will create a business object that centralizes
    the application''s business rules instead of the Session Façade:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s look at the `FinancialFacadeImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can observe the `@LocalBean` annotation in the EJB Session Façade. This means
    that the bean has a no-interface view. This is just a simplification because there
    is no need to apply local or remote interfaces for the explanation of the Session
    Façade. Just remember, the requirement for local interfaces has been dropped since EJB
    3.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AcademicFacadeImpl` Session Façade has an asynchronous method with an
    event listener parameter. This method is responsible for providing the date and
    time for a test revision when requested by a student. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This event can be fired from a façade client, typically a delegate or a web
    component (a servlet or a JSF-managed bean, for example). The event is injected
    into the client and fired according to the request. It is then fired together
    with a `TestRevisionTO` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `TestRevisionTO` class is fired as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Explaining the business-object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, a business object represents something in the real world
    and something associated with the business of the application. A business object
    is like an actor in an application use case. Examples of business objects include
    bank accounts, car insurance, college professors, students, employees, purchase
    orders, and payable or receivable accounts.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to simple applications with very little business complexity, that
    is, with few (or no) business rules, there may not be a need for a BO in the system.
    Better yet, a POJO entity that represents a database entity can be considered
    a BO. It is important to see the difference here. An entity or a POJO representative
    of an entity (such as a JPA POJO ) is closer to the technology and structure than
    to a business-model object. So, for this example, an entity such as a college
    student can also be considered a BO or an actor of a *college student* use case.
    In fact, in these simpler cases where the data model is sufficient for the business,
    there is no need to define a business object.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we say that the data model related to the college student closely
    represents the conceptual domain model related to the student.
  prefs: []
  type: TYPE_NORMAL
- en: The application is often so simple that business-tier clients, such as a Session Façade
    (or even presentation-tier clients), can directly access the data model through
    DAO. There is no need for a model object to handle greater complexity for the
    application business.
  prefs: []
  type: TYPE_NORMAL
- en: Applications with complex business rules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's say that we want to increase the complexity of the system (let's say the
    system needs to contain more functions, for example). Let's also imagine that
    a college has members that consist of professors, employees, and students. Suppose
    there is a `member` entity that almost matches the `member` table in the related
    database. In addition, we know that professors, students, and employees are members
    of the college, and for that reason, they have common characteristics that every
    member should have. However, the professor, student, and employee also have their
    own characteristics. A professor's main characteristics are that they are a member
    who teaches and has a Masters or PhD qualification.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a student has their own characteristics, such as enrollment in college
    and the number of courses they are enrolled in. Professors and students will both also have
    relationships with other entities. For this, we can architect the application
    in terms of the database and create four tables—`Member`, `Student`, `Employee`,
    and `Professor`. We can establish a one-to-one relationship between `Student`
    and `Member`, `Professor` and `Member`, and also `Employee` and `Member`. In any
    implementation, we can have four JPA entities related to these tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a professor is an actor of the *teaches discipline* use case with
    some business rules. This more complex `professor` object combines the `Member`
    and `Professor` entities. We can then define a `ProfessorBO` (business object)
    object, which is the combination of the `Member` with `Professor`. In addition,
    `ProfessorBO` may have methods that provide a richer behavioral value for the
    object because these methods are used in the use case. Without such methods, the
    object becomes an anemic object. However, it could be said that this is still
    a relatively low complexity. Consequently, we can think of a use case that shows
    all the disciplines taught by a professor, or a professor''s skills that are necessary
    to teach particular disciplines. Here, we have another table and entity: `Discipline`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, a student is related to a particular course. This is another use
    case with one more entity: `Course`. The possibilities conceived for an academic
    system are innumerable and are far from being a simple data-model system. Business
    objects can be used for complex use cases.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the **Professor**, **Student**, and **Employee**
    as more complex objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab30f7bb-1fe2-4e90-809e-3b72e9b34786.png)'
  prefs: []
  type: TYPE_IMG
- en: This scenario is just one of several possible implementations. In our small
    example, we consider the existence of an object called `ProfessorBO`, which uses
    three entities (**Professor**, **Member**, and **Discipline**) and has associated
    business methods.
  prefs: []
  type: TYPE_NORMAL
- en: One could argue that there would be no need to have `ProfessorBO`. We could
    have a Professor Facade that could implement the Session Façade pattern with business
    methods and would also manipulate the different combined entities using a DAO
    (for the execution of CRUD operations).
  prefs: []
  type: TYPE_NORMAL
- en: We can agree with this architecture and, depending on the complexity of the
    system, it may even be the best alternative. However, we chose this architecture,
    which clearly illustrates the definition and use of the BO pattern, so let's continue
    with our example.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, a `ProfessorBO` object represents a professor who is an actor for
    one or more use cases related to the conceptual professor model.
  prefs: []
  type: TYPE_NORMAL
- en: Motivation for using the business-object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever the conceptual model involves a greater complexity, we use the business-object
    pattern. This high complexity may be because the BO uses a combination of other
    objects and has complex business logic, such as validation rules. So, separating
    this business logic from the rest of the application is required (data persistence
    would be an example of this).
  prefs: []
  type: TYPE_NORMAL
- en: Not implementing this pattern can lead to problems, such as reducing code reusability.
    As a consequence of this, there are several possible solutions that make code
    maintenance time-consuming, as it would lose the uniformity that comes with using
    design patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of business-object pattern usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a summary of the benefits of the business-object pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: BOs are responsible for managing their business rules and persistence. This
    leads to a more reusable code. Clients access BOs that are fully responsible for
    the behavior of the application. In our example, `ProfessorBO` can be called from
    several points. As well as being reusable, there is a uniformity of behavior.
    As a consequence, another benefit is faster and more efficient maintenance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BOs are responsible for separating the business logic from the rest of the application,
    which increases the cohesion of the code (separation of responsibilities).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BOs help separate business logic from data persistence.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is the class diagram for the business-object pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04bf7e64-db2a-4c58-963f-5f34010a467e.png)'
  prefs: []
  type: TYPE_IMG
- en: For more complex applications, we typically have a Session Façade that represents
    a set of related use cases. As we have already seen, the Session Façade offers
    high-level methods for clients. For its part, the Session Façade can manage and
    combine BOs that act as real agents or representatives of real-world objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the **Business Object** sequence diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/26873cb7-12a5-45dc-8bca-7244e8cbe5db.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the business-object pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to input some code in order to illustrate the business-object
    pattern. However, we must again pay attention to the fact that there is likely another
    approach to getting the results. For instance, we could use an O-R Mapping (JPA
    or Hibernate technology) to map the entities.
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the `Professor` entity has an *n*-to-*n* relationship with the
    `Discipline` entity, which is done with a JPA annotation. However, we know that
    there are many more use cases here than simply mapping entities.
  prefs: []
  type: TYPE_NORMAL
- en: We will use `ProfessorBO`, `Professor`, `Discipline`, `ProfessorDAO`, and `DisciplineDAO`.
    Let's take advantage of the classes shown in the Session Façade example. We made
    a small change in the `AcademicFacadeImpl` class. Now, this Session Façade uses
    a BO called `ProfessorBO` to handle the business related to `Professor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the `ProfessorBO` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also have a look at the `AcademicFacadeImpl` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code block, the `AcademicFacadeImpl` Session
    Façade calls the `canTeachDiscipline` method from the `ProfessorBO` injected bean. `ProfessorBO`
    then uses `ProfessorDAO` and `DisciplineDAO`. Next, we will see the part of the
    `DisciplineDAO` code that is used by the `ProfessorBO` bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the code used by the `ProfessorDAO` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see the `ProfessorBO` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the fact that the main objective of the Business
    Delegate is to hide the details of service implementations from the presentation
    tier. We have also seen that, in some situations, its use has been replaced by
    CDI technology (this technology is responsible for injecting components into a
    typesafe way application, such as injecting an EJB component), but we believe
    that this is not enough. The Business Delegate is still widely used in the treatment
    of more technical exceptions—for example, when it has remote EJB calls. In addition,
    the delegate protects the presentation tier from possible changes in the service
    layer, and conversely, when there are types of clients other than a web browser,
    using a delegate makes it easier for these new clients to access services.
  prefs: []
  type: TYPE_NORMAL
- en: Session Façade centralizes business logic without exposing complex interactions
    that involve business objects to the client side. In addition, Session Façade
    encapsulates business-tier components and exposes coarse-grained services to both
    local and remote clients. Consequently, the clients access a Session Façade instead
    of directly accessing the business components. Some services, such as transaction-control
    or security-management, are addressed using Session Façade implementations, such
    as EJBs.
  prefs: []
  type: TYPE_NORMAL
- en: The business-object pattern must be used whenever an application presents a
    high level of complexity. This may include when the representation of real-world
    objects cannot be translated merely as a data-model object, and there is, therefore,
    a need for reusability and uniformity in business solutions. Aside from reusability,
    the immediate benefit of this includes efficient code maintenance and a rich cohesion
    between layers caused by the separation of responsibilities. This is because the
    business objects separate business logic and persistence from the rest of the
    application.
  prefs: []
  type: TYPE_NORMAL
