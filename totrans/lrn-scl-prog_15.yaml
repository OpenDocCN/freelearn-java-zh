- en: Project 2 - Building Microservices with Lagom
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 2 - 使用 Lagom 构建微服务
- en: The final part of this book goes into the details of the Lagom framework by
    discussing its philosophy, the way Lagom applications are structured, and available
    APIs and how to use them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书最后一部分将详细探讨 Lagom 框架的细节，通过讨论其哲学、Lagom 应用程序的构建方式以及可用的 API 以及如何使用它们。
- en: In this chapter, we will build, once again, our bakery project, this time structured
    as a number of microservices.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将再次构建我们的面包店项目，这次将其构建为多个微服务。
- en: 'After reading this chapter, you will be able to do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读本章后，你将能够做到以下事项：
- en: Understand the advantages of using Lagom
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解使用 Lagom 的优势
- en: Set up Lagom and use it to create projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Lagom 并使用它来创建项目
- en: Structure an application as required by the framework
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照框架要求构建应用程序结构
- en: Efficiently use provided APIs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用提供的 API
- en: Unit test Lagom services
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试 Lagom 服务
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Before we begin, make sure you have the following installed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，请确保你已经安装了以下内容：
- en: JDK 8+
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JDK 8+
- en: SBT 1.2+
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SBT 1.2+
- en: The code for this chapter is available at GitHub: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15)。
- en: Why Lagom?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 Lagom？
- en: In the previous chapter, we discussed the benefits and downsides of a microservices-based
    approach. We named the main architectural properties of microservices such as
    autonomy, isolation, and data ownership. We also noted that, compared to the traditional
    monolithic approach, microservices reduce the complexity of a single service but
    the complexity of the system as a whole does not disappear. In a sense, it just
    moves from the internals of a single microservice into the space between them.
    We looked at the implementation of the shop as a RESTful microservice, and we
    admitted that we would avoid this additional complexity by focusing on a single
    service.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了基于微服务方法的利弊。我们命名了微服务的主要架构属性，如自治性、隔离性和数据所有权。我们还指出，与传统单体方法相比，微服务减少了单个服务的复杂性，但整个系统的复杂性并没有消失。从某种意义上说，它只是从单个微服务的内部移动到了它们之间的空间。我们研究了将商店作为
    RESTful 微服务的实现，并承认我们将通过专注于单个服务来避免这种额外的复杂性。
- en: As we worked through the Akka-based solution, we also chose the proper database
    to store events as well as defining and applying migrations to have a proper database
    schema. The choice of the configuration mechanism was predetermined by Akka but
    we still had to read and verify the configuration manually. We also needed to
    decide how to pass dependencies as we constructed runnable applications and properly implemented
    this passing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们处理基于 Akka 的解决方案时，我们还选择了适当的数据库来存储事件，并定义和实施迁移以拥有适当的数据库模式。配置机制的选取由 Akka 预先确定，但我们仍然需要手动阅读和验证配置。我们还需要决定如何在构建可运行的应用程序时传递依赖，并正确实现这一传递。
- en: The Lagom framework builds on top of a few existing technologies and utilizes
    the "convention over configuration" approach to reduce the burden of these repetitive
    mechanical tasks and to deliver some additional functionality specific to the
    microservice systems. It does so by providing a kind of "template" for projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom 框架建立在一些现有技术之上，并利用“约定优于配置”的方法来减轻这些重复机械任务的压力，并为微服务系统提供一些特定的附加功能。它是通过为项目提供一种“模板”来实现的。
- en: 'The preconfigured features include the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 预配置的功能包括以下内容：
- en: Use of event sourcing as a mechanism for distributed persistence. The recommended
    database is Apache Cassandra because of its exceptional scalability and natural
    support for the read side of the CQRS principle.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件溯源作为分布式持久化的机制。推荐的数据库是 Apache Cassandra，因为它具有卓越的可伸缩性和对 CQRS 原则的读侧的自然支持。
- en: Support for asynchronous communications by making use of reactive streams with
    Akka Streams as an implementation and message-passing style with Apache Kafka
    as a broker.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用 Akka Streams 作为实现和 Apache Kafka 作为代理的消息传递风格，支持异步通信。
- en: Transparent support for different communication protocols, which allows you
    to abstract complex API calls behind simple method calls.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对不同通信协议提供透明支持，允许你将复杂的 API 调用抽象为简单的函数调用。
- en: Expressive-service-description DSL, which allows you to define APIs in a flexible
    and concise way.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式服务描述DSL，允许您以灵活和简洁的方式定义API。
- en: Dynamic scalability with Akka Cluster.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Akka Cluster实现动态可伸缩性。
- en: A choice of dependency injection frameworks to wire the application at compile
    or runtime.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择依赖注入框架，以在编译时或运行时连接应用程序。
- en: Development mode with hot code reload and an ability to start all services and
    required infrastructure components, including a special development service registry
    and a service gateway with a single command.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发模式，具有热代码重载功能，以及能够通过单个命令启动所有服务和所需的基础设施组件，包括特殊开发服务注册表和服务网关。
- en: Default configuration for the infrastructure and preconfigured logging.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基础设施和预配置日志的默认配置。
- en: Let's see how these features will help us to re-implement our bakery project.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些功能将如何帮助我们重新实现我们的面包店项目。
- en: Project overview and setup
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述和设置
- en: We already implemented our bakery project three times using different technologies
    in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models,* to [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams*. Let's recap what this is about for the readers who aren't familiar
    with the third section of this book.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，《Akka和Actor模型简介》到[第13章](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml)，《Akka
    Streams基础》中，使用不同的技术实现了我们的面包店项目三次。让我们回顾一下，对于不熟悉本书第三部分的读者来说，这是关于什么的。
- en: The bakery project
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面包店项目
- en: 'The bakery contains a few employees working together to produce delicious cookies.
    The structure of their communication is represented in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 面包店包含一些员工，他们共同努力制作美味的饼干。他们的通信结构在以下图中表示：
- en: '![](img/7494c8d3-8fed-453e-ba0c-fb322b2db773.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7494c8d3-8fed-453e-ba0c-fb322b2db773.png)'
- en: 'Each of the employees is skilled in a specific area:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每位员工都在特定领域有专长：
- en: The **Manager** drives the process by taking the results of the work of each
    of the participants and giving them to the next step in the flow. They also create
    initial shopping lists.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经理**通过将每个参与者的工作结果传递给流程中的下一步来驱动流程。他们还创建了初始购物清单。'
- en: The **Boy**, if given a shopping list, will run to the grocery store and return
    with groceries.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**男孩**，如果得到购物清单，将跑到杂货店并带回食材。'
- en: The **Chef**, if given groceries, will make dough. They do so by creating a
    couple of **Mixers** of limited capacity so that bigger amounts of groceries can
    be processed in parallel.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厨师**，如果得到食材，将制作面团。他们通过创建几个容量有限的**混合器**来这样做，以便可以并行处理更多的食材。'
- en: The **Cook**, if given dough, makes some raw cookies.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**厨师**，如果得到面团，将制作一些生饼干。'
- en: The **Baker**, if given raw cookies, will bake them for some time using the
    **Oven**, hence producing delicious cookies.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**面包师**，如果得到生饼干，将使用**烤箱**烘烤一段时间，从而制作出美味的饼干。'
- en: This time we're going to model each worker as a microservice. The **Mixers**
    and the **Oven** will become implementation details of the owning service.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们将每个工作者建模为一个微服务。**混合器**和**烤箱**将成为所属服务的实现细节。
- en: Project setup
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目设置
- en: It goes without saying that we'll implement our microservices using the Lagom
    framework. Lagom supports both Maven and SBT as build tools but SBT provides a
    much better user experience so we will ignore Maven as it is less relevant for
    Scala projects.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 不言而喻，我们将使用Lagom框架来实现我们的微服务。Lagom支持Maven和SBT作为构建工具，但SBT提供了更好的用户体验，因此我们将忽略Maven，因为它对Scala项目来说不太相关。
- en: Further, in this section we're going to create a Lagom project from scratch.
    We could utilize a slightly different approach by creating an example project
    with Giter8 and then modifying and extending it as needed. The command is similar
    to the one we mentioned in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An
    Introduction to the Akka and Actor Models*: `sbt new lagom/lagom-scala.g8`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本节中，我们将从头开始创建一个Lagom项目。我们可以通过使用Giter8创建一个示例项目，然后根据需要对其进行修改和扩展，采用一种稍微不同的方法。命令与我们提到的[第11章](87c2e446-3730-49ae-b86b-fc8269678399.xhtml)，《Akka和Actor模型简介》：`sbt
    new lagom/lagom-scala.g8`相似。
- en: 'As before, our SBT setup will contain a number of files describing different
    aspects of the project. For the following, assume we''ve created a project folder
    and navigated to it in the Terminal:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们的SBT设置将包含描述项目不同方面的多个文件。以下假设我们已创建项目文件夹并在终端中导航到它：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, we define that our project requires a Lagom SBT plugin, the version of
    SBT to be used, as well as few SBT options in the `.sbtopts` file. The first two
    lines define the initial and maximum amount of memory SBT is allowed to consume.
    We're going to start quite a lot of microservices and supporting infrastructure
    components so it is necessary to have enough memory available. The `-Xss` parameter
    defines a stack size of `2M` per thread. It is generally useful in Scala projects
    to prevent non-tail-recursive functions from overflowing the stack too soon. The
    last parameter, `-XX:MaxMetaspaceSize`, defines the size of the metaspace that
    is used (starting from the JVM 8) to store class metadata. Because of the Lagom's
    hot reloading, we're going to create and load many classes during development
    so we need to have a metaspace of significant size.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了我们的项目需要Lagom SBT插件，要使用的SBT版本，以及`.sbtopts`文件中的几个SBT选项。前两行定义了SBT被允许消耗的初始和最大内存量。我们将启动相当多的微服务和支持基础设施组件，因此需要足够的内存。`-Xss`参数定义了每个线程的栈大小为`2M`。在Scala项目中，这通常很有用，可以防止非尾递归函数过早地溢出栈。最后一个参数`-XX:MaxMetaspaceSize`定义了用于存储类元数据（从JVM
    8开始）的元空间的大小。由于Lagom的热重载，我们在开发过程中将创建和加载许多类，因此我们需要一个较大的元空间。
- en: '`build.sbt` will contain a number of submodules so it is easier to create with
    a text editor. This is what the (partial) final result looks like:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sbt` 将包含多个子模块，因此使用文本编辑器创建它会更简单。这就是（部分）最终结果的样子：'
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We've cut the repetitive definitions so please refer to the GitHub repository ([https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15))
    for the full source code. Here, we define general properties of the project, a
    shared model, and five microservices.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经删除了重复的定义，请参阅GitHub仓库（[https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15)）以获取完整的源代码。在这里，我们定义了项目的一般属性、共享模型和五个微服务。
- en: Each microservice consists of two modules, an API definition, and an implementation.
    Most of the API definitions in our case require just a single `lagomScaladslApi`
    dependency and the implementation—just `macwire` in the main scope. We've defined
    `defaultDependencies` including the test scope to keep further definitions concise.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务由两个模块组成，一个API定义和一个实现。在我们的案例中，大多数API定义只需要一个`lagomScaladslApi`依赖项，实现则只需要在主范围内使用`macwire`。我们已定义了`defaultDependencies`，包括测试范围，以保持进一步的定义简洁。
- en: 'For `chef-impl`, we include three other compile-time dependencies:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`chef-impl`，我们还包括了三个其他编译时依赖项：
- en: '`lagomScaladslPersistenceCassandra`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lagomScaladslPersistenceCassandra`'
- en: '`lagomScaladslPubSub`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lagomScaladslPubSub`'
- en: '`lagomScaladslKafkaBroker`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lagomScaladslKafkaBroker`'
- en: The Chef will take some time to mix the dough and because of this we aim to
    implement communication with the Manager via a message broker to decouple both
    from each other.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 大厨将花一些时间来搅拌面团，因此我们希望通过消息代理与Manager进行通信，以解耦两者。
- en: 'Another deviation is the definition of `manager-impl`. The Manager will communicate
    with each of the other services, so it needs to know the API definitions of other
    workers. We also created a folder for each of the defined microservices in the
    filesystem. This is what our file structure with multiple modules looks like in
    the end:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个偏差是`manager-impl`的定义。Manager将与其他每个服务进行通信，因此它需要知道其他工作者的API定义。我们还在文件系统中为每个定义的微服务创建了一个文件夹。这就是我们最终具有多个模块的文件结构的样子：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As we go on with the implementation, we''ll define a project structure as required
    by SBT for each of the modules:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续实施，我们将为每个模块定义SBT所需的项目结构：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: By having this structure, we're done with the preparation of the project infrastructure
    and can move on to implementing the services.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过拥有这种结构，我们已经完成了项目基础设施的准备，可以继续实现服务。
- en: 'The next diagram outlines the communication flow between modules:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图表概述了模块之间的通信流程：
- en: '![](img/4a64ca8a-8335-4bb2-9b30-d29998a4b34a.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4a64ca8a-8335-4bb2-9b30-d29998a4b34a.png)'
- en: In order to simplify our example a bit, we will violate the rule that each microservice
    should own the definition of its model. We'll define a module containing definitions
    of all of the case classes used by the services we're going to build. We will
    add this module as a dependency to every other module we've defined before.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们的示例，我们将违反每个微服务应该拥有其模型定义的规则。我们将定义一个包含将要构建的服务使用的所有案例类定义的模块。我们将把这个模块作为依赖项添加到我们之前定义的每个其他模块中。
- en: 'The module itself will contain definitions already known to us from previous
    chapters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块本身将包含我们之前章节中已经了解到的定义：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our objects will be sent in serialized form between services. This means we
    also need to define serialization rules for them. We''ll do this by relying on
    Play''s macros, similar to Circe, which we used in the `http4s` example project:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的对象将在服务之间以序列化形式发送。这意味着我们还需要为它们定义序列化规则。我们将通过依赖Play的宏来实现这一点，类似于我们在`http4s`示例项目中使用的Circe：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: These formats go into the same `object model` instance along the case classes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式都进入同一个`object model`实例，沿着案例类。
- en: Lagom's APIs
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lagom的API
- en: As before, we will start with an implementation of the simplest of our workers,
    which just performs basic mathematical operations in order to do its work with `Cook`,
    which makes `RawCookies` out of `Dough`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将从一个最简单的工人实现开始，它只执行基本的数学运算，以便使用`Cook`，将`Dough`转换为`RawCookies`。
- en: Service API
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务API
- en: 'In order to define our Cook as a service we need to implement a special interface
    called a service descriptor. The service descriptor defines two aspects of a Lagom
    service:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的Cook定义为服务，我们需要实现一个特殊接口，称为服务描述符。服务描述符定义了Lagom服务的两个方面：
- en: 'The service signature: How the service should be called and its return type'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务签名：如何调用服务及其返回类型
- en: 'The service meta data: How the service call is mapped to the transport layer,
    for example to the REST call'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务元数据：服务调用如何映射到传输层，例如REST调用
- en: 'The service descriptor extends Lagom''s `Service` trait and in its simplest
    form just needs to override the `descriptor` method. This is what it looks like
    in our `Cook` definition, which we place into the `cook-api` module:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 服务描述符扩展了Lagom的`Service`特质，在其最简单形式中只需要重写`descriptor`方法。这就是我们在`Cook`定义中看到的样子，我们将其放入`cook-api`模块：
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here we define a descriptor that connects the single call of the service, the
    `cook` method, to the service identifier `"CookService"` which will be needed
    for the routing later. For the call, we use the simplest identifier which just
    takes the name of the method. The configuration will result in the call mapped
    to the `/cook` REST URL.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个描述符，它将服务的单个调用（`cook`方法）连接到服务标识符`"CookService"`，这在稍后的路由中将是必需的。对于调用，我们使用最简单的标识符，它只取方法的名字。配置将导致调用映射到`/cook`
    REST URL。
- en: 'The call itself is defined to be of the `ServiceCall[Dough, RawCookies]` type.
    Let''s take a look at `ServiceCall` in more detail. The definition in the Lagom''s
    source code looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 调用本身被定义为`ServiceCall[Dough, RawCookies]`类型。让我们更详细地看看`ServiceCall`。在Lagom的源代码中的定义如下：
- en: '[PRE7]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`ServiceCall` is typed by the request and response and can be invoked at the
    moment the request is issued by the client producing a response asynchronously.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ServiceCall`由请求和响应类型指定，并且可以在客户端发出请求时异步调用，产生响应。'
- en: The request and response types in Lagom can be strict or streamed. There are
    four possible combinations ranging from both sides being strict to both sides
    being streamed. Strict means that the request or response is fully buffered in
    the memory at the method boundary. The combination of both the strict request
    and response results in the synchronous semantics of the call. A streamed request
    or response is of the `Source` type, which is known to us from [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams* where we looked at Akka streams. For the streaming calls, Lagom
    will try its best to choose the appropriate semantics. Typically, this will be
    WebSockets, and we will see how it works later in this chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom中的请求和响应类型可以是严格的或流式的。有四种可能的组合，从两边都是严格的到两边都是流式的。严格意味着请求或响应在方法边界处完全缓冲在内存中。严格请求和响应的组合导致调用的同步语义。流式请求或响应是`Source`类型，这是我们熟悉的，在[第13章](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml)，*Akka
    Streams基础*中我们探讨了Akka流。对于流式调用，Lagom将尽力选择适当的语义。通常，这将是通过WebSockets，我们将在本章后面看到它是如何工作的。
- en: Our `Cook` instance is very quick so it is appropriate to define the service
    in synchronous terms.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Cook`实例非常快，因此以同步方式定义服务是合适的。
- en: The implementation of `Cook` goes in another module, `cook-impl`. This separation
    is essential in order to give microservices a possibility to refer to the definitions
    of each other without having any knowledge about implementation details.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cook`的实现位于另一个模块`cook-impl`中。这种分离对于微服务能够引用彼此的定义而没有了解实现细节是至关重要的。'
- en: 'The implementation is somewhat more involving, but not because of the service
    definition itself. The code should be very familiar by now:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实现稍微复杂一些，但并不是因为服务定义本身。代码现在应该非常熟悉了：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The only new part here is the definition of the service call wrapper. It is
    done by using the constructor defined in the `ServiceCall` companion object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新部分是对服务调用包装器的定义。这是通过使用在`ServiceCall`伴生对象中定义的构造函数来完成的：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We provide a function that converts `Dough` (request) into `Future[RawCookies]`
    (response) and the constructor builds a proper `ServiceCall` from it.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个函数，它将`Dough`（请求）转换为`Future[RawCookies]`（响应），并且构造函数从它构建一个合适的`ServiceCall`。
- en: 'The previously mentioned complexity is related to the fact that we also need
    to wire together and start our service. For those who read [Chapter 14](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml),
    *Project 1 - Building Microservices with Scala, *the approach will look very much
    like a combination of both approaches we looked at there: mixing traits and providing
    concrete implementations for abstract members and passing dependencies as constructor
    parameters. But this time, we''ll get the Lagom''s help for this task. First,
    we define `LagomApplication`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的复杂性与我们还需要将我们的服务连接起来并启动的事实有关。对于那些阅读了[第14章](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml)，*项目1
    - 使用Scala构建微服务*的人来说，这种方法将非常类似于我们在那里查看的两种方法的组合：混合特性和为抽象成员提供具体实现，以及将依赖项作为构造函数参数传递。但这次，我们将得到Lagom的帮助来完成这项任务。首先，我们定义`LagomApplication`：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The application extends `LagomApplication` and needs `LagomApplicationContext`,
    which is just passed over via a constructor. No doubt you recognize the thin-cake
    pattern we used to connect together the components of our `Akka-HTTP` example.
    `lagomServer` is an overridden method, which is used by Lagom to provide correct
    wiring for the service calls. Another wiring happening here is the binding of `CookServiceImpl`
    to `CookService` with the help of Macwire.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序扩展了`LagomApplication`并需要`LagomApplicationContext`，这只是一个通过构造函数传递的。毫无疑问，您已经认识到了我们用来连接`Akka-HTTP`示例组件的薄饼模式。`lagomServer`是一个重写的方法，Lagom用它来为服务调用提供正确的连接。这里发生的另一个连接是使用Macwire将`CookServiceImpl`绑定到`CookService`。
- en: Macwire ([https://github.com/adamw/macwire](https://github.com/adamw/macwire))
    is a dependency injection framework that implements constructor-based DI. It does
    so by generating calls to the class constructors with appropriate parameters found
    in scope. In a sense, it provides proper constructor calls behind the scenes the
    same way Circe or Play provide proper mapping to JSON structures. It would be
    very useful in projects of significant size.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Macwire ([https://github.com/adamw/macwire](https://github.com/adamw/macwire))
    是一个基于构造函数的依赖注入框架。它是通过生成带有作用域内找到的适当参数的类构造函数调用来实现的。从某种意义上说，它以Circe或Play提供对JSON结构正确映射相同的方式，在幕后提供正确的构造函数调用。这对于大型项目来说非常有用。
- en: 'Now our application can be used in the application loader, which does the real
    work of starting the service in a development or production environment:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将应用程序用于应用程序加载器，它在开发或生产环境中启动服务的实际工作：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`CookLoader` can be started by Lagom as needed. It overrides two `load` methods
    for respective environments. Please note how we extended `CookApplication` with `AhcWSComponents`.
    The latter is needed in order to provide `wsClient`, which in turn is required
    by `LagomApplication` we defined as a base class for our `CookApplication`. For
    the development mode, we also mix in `LagomDevModeComponents`, which gives us
    a development mode service locator.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`CookLoader`可以根据需要由Lagom启动。它覆盖了相应环境的两个`load`方法。请注意我们如何通过`AhcWSComponents`扩展了`CookApplication`。后者是必需的，以便提供`wsClient`，而`wsClient`反过来又是我们定义的`CookApplication`基类所需的。对于开发模式，我们还混合了`LagomDevModeComponents`，这为我们提供了一个开发模式服务定位器。'
- en: 'Now we need to configure the application loader by providing a corresponding
    play setting in the well-known by now `application.conf`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要通过在众所周知的`application.conf`中提供相应的play设置来配置应用程序加载器：
- en: '[PRE12]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'And that is it—now we are ready to start our application. The easiest way to
    do this is by using Lagom''s `runAll` command in the SBT console. It will try
    to start all of the services we''ve defined so far as well as the components of
    the underlying infrastructure—the development mode service locator, Cassandra
    database, and Kafka message broker:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样——现在我们已准备好启动我们的应用程序。在SBT控制台中，使用Lagom的 `runAll` 命令是最简单的方法。它将尝试启动我们迄今为止定义的所有服务以及底层基础设施的组件——开发模式服务定位器、Cassandra数据库和Kafka消息代理：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The logs witness that the logging is working alongside other infrastructure
    components.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 日志证明，日志记录正在与其他基础设施组件一起工作。
- en: At this stage, the log will contain a lots of stacktraces (not shown here) because
    of missing loader configurations for all but the `boy-impl` modules. We will fix
    this during this chapter, as we will implement the services one after another.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，日志将包含大量堆栈跟踪（此处未显示），因为除了 `boy-impl` 模块之外的所有模块都缺少加载器配置。我们将在本章中修复这个问题，因为我们将会一个接一个地实现服务。
- en: 'We can also see that our service is running on port `57733` and can try to
    communicate with it:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以看到我们的服务正在端口 `57733` 上运行，并且可以尝试与其通信：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Congratulations, we just talked to our first Lagom microservice!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们刚刚与第一个 Lagom 微服务进行了通信！
- en: We communicated to the service directly without using a service registry and
    service locator. It is safe to put the port number into the code listing for reference
    because despite their random appearance, ports are assigned to the services by
    Lagom in a deterministic manner (basically by using a hash of a project name).
    Hence, the services are assigned the same port numbers (with respect to port conflicts) in
    any environment.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们直接与服务通信，而没有使用服务注册表和服务定位器。将端口号放入代码列表作为参考是安全的，因为尽管它们看起来是随机的，但Lagom以确定性的方式（基本上是通过项目名称的哈希值）将端口号分配给服务。因此，服务在任何环境中都会被分配相同的端口号（考虑到端口冲突）。
- en: Now we can move on to the implementation of the `Boy` service, which is similarly
    simple in its functionality. It is expected to forward incoming shopping lists
    to external services and forward groceries it will get in return to the initial
    caller.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以继续实现 `Boy` 服务，它在功能上同样简单。它预计将接收到的购物清单转发到外部服务，并将收到的杂货转发给初始调用者。
- en: 'The definition of the service should look familiar, except that we''re using
    the `namedCall` method to map the `shop` call to the `go-shopping` name in order
    to have a nicer URL:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的定义应该看起来很熟悉，只是我们正在使用 `namedCall` 方法将 `shop` 调用映射到 `go-shopping` 名称，以便有一个更友好的URL：
- en: '[PRE15]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The implementation is a bit more complex then the `Cook` service because the
    `Boy` service needs to call an external HTTP service to make an order. The following
    template should not raise any questions:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实现比 `Cook` 服务要复杂一些，因为 `Boy` 服务需要调用外部HTTP服务来下订单。以下模板不应引起任何疑问：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How do we call the external API though? We could, of course, use an HTTP client
    library and do the call the same way as before, issuing the HTTP request, getting
    the HTTP response, and handling marshalling and unmarshalling. But this would
    lower the abstraction level of our solution and hard-wire the implementation to
    the external service's location.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 那我们如何调用外部API呢？当然，我们可以使用HTTP客户端库，并以与之前相同的方式发出HTTP请求，获取HTTP响应，并处理序列化和反序列化。但这样做会降低我们解决方案的抽象级别，并将实现硬编码到外部服务的位置。
- en: 'We will do the following instead. First, we will register our externally running
    service with the service locator by adding the service''s URL to `build.sbt`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取以下措施。首先，我们将通过将服务的URL添加到 `build.sbt` 中，通过服务定位器注册我们外部运行的服务：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, we will define an API for the grocery store as if we were about to implement
    it:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将定义一个用于杂货店的API，就像我们即将实现它一样：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we specify a service descriptor for the service with the same name as
    we just registered with the service locator. The API call is registered with a
    `restCall` descriptor to be sure that both the HTTP method and the path are correctly
    mapped to the existing service. We also need to wrap and unwrap `ShoppingList`
    and `Groceries` into proper `Order` and `Purchase` as expected with the existing
    shop service. Luckily, the JSON representation of our case classes is the same
    as for `Map[String, Int]` so we can safely just reuse the existing model along
    with serializers and add the wrappers on top of it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为与我们在服务定位器中注册的相同名称的服务指定了一个服务描述符。API调用通过`restCall`描述符注册，以确保HTTP方法和路径正确映射到现有服务。我们还需要将`ShoppingList`和`Groceries`包装和展开为预期的`Order`和`Purchase`，就像现有的商店服务一样。幸运的是，我们case类的JSON表示与`Map[String,
    Int]`相同，因此我们可以安全地重用现有的模型以及序列化器，并在其上添加包装器：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We don't need to provide an implementation for `ShopService`; we just want Lagom
    to apply all existing machinery to represent an existing `REST` service as if
    it were one made with Lagom.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要为`ShopService`提供实现；我们只是希望Lagom应用所有现有机制来表示一个现有的`REST`服务，就像它是用Lagom制作的。
- en: 'The shop service is ready to use with `Boy` now:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在商店服务已经准备好与`Boy`一起使用：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that we provide the `shopService` client and an execution context. The
    latter will be used to transform the future result we''ll get from the service
    invocation. The `callExtApi` function shows how this is done: we refer to the
    `order` method from the `ShopService` definition, which returns `ServiceCall`,
    which we happily invoke with `Order` we created from the shopping list. The result
    is `Future[Purchase]` so we unwrap an order out of it. Finally, we define that,
    if anything wrong happens with the external service, for example, the service
    is not available or there is insufficient inventory to fulfill the order, the
    Boy should just return back with empty hands.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们提供了`shopService`客户端和一个执行上下文。后者将用于转换我们从服务调用中获得的未来结果。`callExtApi`函数展示了如何实现：我们从`ShopService`定义中引用`order`方法，它返回`ServiceCall`，我们愉快地用从购物列表中创建的`Order`调用它。结果是`Future[Purchase]`，所以我们从中提取一个订单。最后，我们定义，如果外部服务发生任何错误，例如，服务不可用或库存不足无法完成订单，`Boy`应该空手而归。
- en: Now `Boy` is able to communicate with `ShopService` we built in [Chapter 14](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml), *Project
    1 - Building Microservices with Scala* using `Akka-HTTP`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`Boy`能够与我们[第14章](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml)中构建的`ShopService`进行通信，*项目1
    - 使用Scala构建微服务*，使用`Akka-HTTP`。
- en: The shop service must be running and must have sufficient inventory in order
    for further examples from this chapter to work properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使本章的后续示例正常工作，商店服务必须正在运行，并且必须有足够的库存。
- en: Our `Boy` and `Cook` services are stateless. The `Cook` service just returns
    the result immediately so there is no point having any state in it. `Boy` is unsophisticated
    and just comes back for instructions if anything unexpected happens. But `Chef`
    and `Baker` are different because they are supposed to represent processes taking
    some time. For this reason we can't implement them in a synchronous manner.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Boy`和`Cook`服务是无状态的。`Cook`服务只是立即返回结果，因此在其中保留任何状态都没有意义。`Boy`很简单，如果发生任何意外情况，它只是回来获取指令。但`Chef`和`Baker`不同，因为它们应该代表需要花费一些时间的过程。因此，我们不能以同步方式实现它们。
- en: The Baker has `m:n` semantics in the sense that it can respond with zero, one,
    or many response messages to a single incoming message. Let's use Lagom's possibility
    to define asynchronous services to implement it. This will allow us to reuse the
    flow definition for `Baker` we constructed in [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml),
    *Basics of Akka Streams*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个意义上，面包师具有`m:n`语义，即它可以对单个传入消息响应零个、一个或多个响应消息。让我们使用Lagom定义异步服务的能力来实现它。这将允许我们重用我们在[第13章](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml)中构建的`Baker`的流定义，*Akka
    Streams基础*。
- en: 'We first need to define the service as we already did, but this time with asynchronous
    semantics:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要定义服务，就像我们之前做的那样，但这次使用异步语义：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we define `BakerService` to have a request of the `Source[RawCookies,
    NotUsed]` type and the response of the `Future[Source[ReadyCookies, NotUsed]]` type.
    This should allow us to just write `RawCookies` at the moment they are available
    and get `ReadyCookies` back after they are baked.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义 `BakerService` 具有请求类型为 `Source[RawCookies, NotUsed]` 和响应类型为 `Future[Source[ReadyCookies,
    NotUsed]]`。这应该允许我们在 `RawCookies` 可用时直接写入，并在烘焙后返回 `ReadyCookies`。
- en: 'The implementation is straightforward because it is literally wrapping the
    flow taken from [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 实现很简单，因为它实际上是封装了来自 [第 13 章](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml) 的流程，*Akka
    Streams 基础*：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We reuse the definition of the `Baker` and `Oven` flows and return the combined
    flow as the result of the call. In this snippet, we also demonstrate the use of `Logger`
    available from the underlying Play framework.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重用了 `Baker` 和 `Oven` 流的定义，并将组合流作为调用结果返回。在这个片段中，我们还展示了如何使用来自底层 Play 框架的 `Logger`。
- en: Persistence API
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持久化 API
- en: '`Chef` in our scenario takes some time to complete the mix process. Because
    of this, we would like to store the work in progress so that, in case the service
    is restarted, it does not get lost and the process just continues from where it
    was interrupted after recovery.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，`Chef` 完成混合过程需要一些时间。正因为如此，我们希望将正在进行的工作存储起来，以便在服务重启时不会丢失，并且恢复后可以从中断的地方继续进行。
- en: We will use persistence facilities provided by the framework in order to implement
    this. The recommended way to persist data in Lagom is by utilizing an event sourcing
    approach, which we already used to implement an example project in [Chapter 14](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml),* Project
    1 - Building Microservices with Scala*. Lagom automates data schema creation with
    Cassandra and also provides a Cassandra instance for development purposes. Therefore,
    we can start directly with the definition of the data model. As in the previous
    chapter, we need to provide a set of commands and events and also have an internal
    representation of the state. The following few snippets show one of the possible
    ways to represent these parts. As this model is just an implementation detail
    of `Chef`, it goes into the `chef-impl` module.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用框架提供的持久化功能来实现这一点。在 Lagom 中，推荐通过利用事件溯源方法来持久化数据，我们已经在 [第 14 章](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml)
    的示例项目中使用了这种方法，*项目 1 - 使用 Scala 构建微服务*。Lagom 自动使用 Cassandra 创建数据模式，并为开发目的提供了一个
    Cassandra 实例。因此，我们可以直接开始定义数据模型。与上一章一样，我们需要提供一组命令和事件，并有一个状态的内部表示。以下几段代码展示了表示这些部分的一种可能方式。由于这个模型只是
    `Chef` 的实现细节，它被放入了 `chef-impl` 模块。
- en: 'First, we need to have a bunch of imports in scope:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在作用域内有一系列导入：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Having these, we can define our commands:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些，我们可以定义我们的命令：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`MixCommand` represents an incoming request to mix some groceries. Commands
    in Lagom define the expected response type and we are using Akka''s `Done` for
    the response. The reason for this is that we''ll always accept `MixCommand` (because
    there is no reason not to), but at the moment the command is accepted it is not
    possible to predict which effect it will have.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`MixCommand` 代表对混合某些食品的请求。Lagom 中的命令定义了预期的响应类型，我们使用 Akka 的 `Done` 作为响应。这样做的原因是，我们总是会接受
    `MixCommand`（因为没有不接受的理由），但在命令被接受的那一刻，无法预测它将产生什么效果。'
- en: '`DoneCommand` represents a state transition from "mixing in progress" to "mixing
    done". It will be an internal command sent by `Chef` to itself. Technically we
    don''t need a response type here but we have to use `Done` again in order to make
    the compiler happy. `id` represents the unique identifier of the mixing job. Where
    does it come from? It is generated at the moment we''re creating an event from
    the command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`DoneCommand` 代表从“混合进行中”到“混合完成”的状态转换。它将是 `Chef` 向自身发送的内部命令。技术上我们在这里不需要响应类型，但我们必须再次使用
    `Done` 以使编译器满意。`id` 代表混合作业的唯一标识符。它从哪里来？它是在我们从命令创建事件的那一刻生成的：'
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Mixing` event is created in response to the `MixCommand` and the `MixingDone` event—in
    response to the `DoneCommand`. Both events relate to each other via the `id` property.
    At the recovery time both events with same `id` will annihilate: presence of both
    events means that in the past a mixing job was started and then finished. In contrast,
    if there is only single event we can conclude that the job was not finished. Having
    unbalanced `Mixing` events after the recovery will mean we need to restart the
    mixing processes for them. Having unbalanced `MixingDone` events can only mean
    programming errors.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mixing`事件是在响应`MixCommand`和`MixingDone`事件时创建的——响应`DoneCommand`。这两个事件通过`id`属性相互关联。在恢复时间，具有相同`id`的两个事件将相互抵消：两个事件的存在意味着在以前已经启动并完成了混合工作。相比之下，如果只有一个事件，我们可以得出结论，该工作未完成。在恢复后存在不平衡的`Mixing`事件意味着我们需要重新启动这些事件的混合过程。不平衡的`MixingDone`事件只能意味着编程错误。'
- en: 'To provide this functionality, we''ll define the state as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供这种功能，我们将状态定义为以下内容：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We''ll take a look at how it is used in the service implementation in a moment,
    after discussing the final bit of the model definition:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论完模型定义的最后部分之后，我们将稍后查看它在服务实现中的使用方式：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, we provide serializers for our events and commands the same way we did
    in the previous chapter. The Lagom's recommended serialization format is JSON
    so we're utilizing the same approach we already used for the shared model definition.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以与上一章相同的方式为我们的事件和命令提供序列化器。Lagom推荐使用JSON作为序列化格式，因此我们正在使用我们之前已经用于共享模型定义的相同方法。
- en: We also define `EventTag` which we'll need to implement the read-side of the
    event journal in order to notify `Manager` about the completed mixing jobs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了`EventTag`，我们将需要实现事件日志的读取端，以便通知`Manager`关于完成的混合工作。
- en: 'The final piece of configuration we need is a definition of Cassandra''s key
    space for `Chef`. This is done in the usual way in `application.conf`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的最后一部分配置是定义Cassandra的键空间用于`Chef`。这通常在`application.conf`中完成：
- en: '[PRE28]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The definition of the service reflects the fact that the communication is synchronous
    on the request side and message based on the response side:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 服务的定义反映了请求端通信是同步的，而响应端基于消息的事实：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `mix` call accepts `Groceries` and returns `Done` (compare this with the
    return type of the commands we''ve just defined). The implementation of the service
    is also reasonably concise because it delegates state management to `ChefPersistentEntity`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`mix`调用接受`Groceries`并返回`Done`（与我们所定义的命令的返回类型进行比较）。服务实现也很简洁，因为它将状态管理委托给`ChefPersistentEntity`：'
- en: '[PRE30]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: First, we need to pass two dependencies, `PersistentEntityRegistry` and `ActorSystem`.
    We pass the actor system, `as`, to `ChefPersistentEntity` at the moment of wiring
    and use the persistent entity registry to register our, well, persistent entity
    as required by Lagom. The `mix` call then just uses the registry to look up a
    reference to the entity and uses an `ask` pattern to send it an incoming command
    and get a response the same way we did with actors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要传递两个依赖项，`PersistentEntityRegistry`和`ActorSystem`。我们在连接`ChefPersistentEntity`时传递actor系统`as`，并使用持久化实体注册表根据Lagom的要求注册我们的持久化实体。然后`mix`调用仅使用注册表查找对实体的引用，并使用`ask`模式发送传入的命令并获取响应，就像我们使用actor一样。
- en: We're omitting the implementation of `resultsTopic` for now to focus on the
    persistence aspect of the service.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在省略`resultsTopic`的实现，以专注于服务的持久性方面。
- en: '`ChefPersistentEntity` is a bit longer, so let''s take a look at it in smaller
    chunks. We start with overriding Lagom''s `PersistentEntity`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChefPersistentEntity`有点长，所以让我们分块查看它。我们首先从覆盖Lagom的`PersistentEntity`开始：'
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The persistent entity can be accessed from anywhere in the cluster. Because
    of this, using persistence in Lagom automatically means using clustering (which
    is definitely a good idea). The persistent entity needs to override a few fields:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化实体可以从集群中的任何地方访问。正因为如此，在Lagom中使用持久性自动意味着使用集群（这绝对是一个好主意）。持久化实体需要覆盖一些字段：
- en: '[PRE32]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `Command`, `Event`, and `State` types refer to those we defined earlier.
    We also define an initial state to be empty `MixingState`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`Command`、`Event`和`State`类型指的是我们之前定义的类型。我们还定义了一个初始状态为空的`MixingState`。'
- en: 'For simplicity, we won''t implement the mixing behavior in its full complexity
    as we already did this three times in previous chapters. Instead, we''ll mock
    it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我们不会实现完整的混合行为，因为我们已经在之前的章节中这样做过三次。相反，我们将模拟它：
- en: '[PRE33]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Now we can finally define the behavior of our entity which will accept commands,
    persist events, and modify states. Again, this is done similarly to how we did
    in the previous chapter, but Lagom adds its five cents by providing an `Actions`
    constructor, which allows us to define command and event handlers in a builder-like
    manner:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们最终可以定义我们实体的行为，该实体将接受命令、持久化事件和修改状态。同样，这是按照我们在上一章中做的方式进行的，但Lagom通过提供一个`Actions`构造函数来增加其价值，该构造函数允许我们以构建器类似的方式定义命令和事件处理器：
- en: '[PRE34]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The command handler must return a `Persist` directive, which describes what
    should be persisted with an optional callback for side-effecting code, which should
    be executed after an event was successfully written to the storage.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理器必须返回一个`Persist`指令，该指令描述了应该持久化什么内容，并可选地提供一个回调函数，用于执行副作用代码，该代码应在事件成功写入存储后执行。
- en: In the preceding snippet, we're handling two commands. `MixCommand` with a negative
    amount of `Dough` is marked as invalid (which is modelled by sending `InvalidCommandException`
    to the caller), and calling `ctx.done` returns `PersistNone` with the meaning
    that nothing needs to be persisted.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们处理了两个命令。带有负`Dough`数量的`MixCommand`被标记为无效（这是通过向调用者发送`InvalidCommandException`来建模的），调用`ctx.done`返回`PersistNone`，表示不需要持久化任何内容。
- en: The second handler is for valid commands. With it, we first generate random
    `id` for the event we're going to persist, then we construct the event and return `PersistOne`
    with the event and a callback. The callback schedules send a command to the persistent
    entity itself meaning the mixing is done and sends `Done` back to the caller.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个处理器是用于有效命令的。使用它，我们首先为将要持久化的事件生成随机的`id`，然后构建事件并返回`PersistOne`，其中包含事件和回调。回调安排向持久化实体本身发送命令，意味着混合已完成，并将`Done`发送回调用者。
- en: 'In order to be able to dereference an entity, we need to use a registry as
    we did in the service earlier:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够解引用一个实体，我们需要使用一个注册表，就像我们在服务中之前所做的那样：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Please note that our persistence callbacks are only executing side effects
    and not modifying the state. For the state modifications, another constructor,
    `onEvent`, should be used. This separation is done in order to gain the possibility
    to reconstruct the state during the recovery as many times as required, but to
    have side effects executed only once after the actual event had happened and was
    persisted:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们的持久化回调仅执行副作用，而不修改状态。对于状态修改，应使用另一个构造函数`onEvent`。这种分离是为了在恢复期间能够根据需要多次重建状态，但副作用代码只在实际事件发生后并已持久化后才执行一次：
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here, we''ve just put new mixing jobs into the queue and we remove them from
    the queue after they are complete. Now we have to define how to react to the `DoneCommand`
    our entity sends to itself:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将新的混合作业放入队列，并在它们完成后从队列中删除。现在我们必须定义实体发送给自身的`DoneCommand`的响应方式：
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We're looking in the current state for `MixingCommand`, which we created before
    by using `id` as an equality criteria, just to have a reference to `groceries`.
    The groceries will be required later; at the moment we will read the event on
    the read side. Then we construct and persist an event and return `Done` to make
    the compiler happy. You probably noticed that we haven't defined any side-effects
    for the `MixingDone` event. We don't need to because these events will be streamed
    to `resultsTopic` we specified earlier.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在当前状态中寻找我们之前通过使用`id`作为相等标准创建的`MixingCommand`，只是为了有一个对`groceries`的引用。这些杂货将在以后需要；目前我们将在读取端读取事件。然后我们构建并持久化一个事件，并返回`Done`以使编译器满意。你可能已经注意到，我们没有为`MixingDone`事件定义任何副作用。我们不需要这样做，因为这些事件将流式传输到我们之前指定的`resultsTopic`。
- en: 'To conclude the implementation of `Chef`, we need to wire all components together.
    `ChefLoader` is not any different from other loaders we''ve defined so far. In
    contrast, `ChefApplication` deviates a bit:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成`Chef`的实现，我们需要将所有组件连接起来。`ChefLoader`与我们之前定义的其他加载器没有太大区别。相比之下，`ChefApplication`有一些不同：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We need to provide an implementation of `JsonSerializerRegistry` for Lagom to
    be able to pick up our serializers. Our application also needs to extend `CassandraPersistenceComponents`
    as we're using persistence and also `LagomKafkaComponents`—by publishing our events
    we're effectively using messaging as well. Unfortunately, currently Lagom can't
    check at compile time whether messaging is used by the application, so it is easy
    to forget to extend Kafka components, which will lead to runtime errors at the
    moment the application is started.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要提供一个`JsonSerializerRegistry`的实现，以便Lagom能够拾取我们的序列化器。我们的应用程序还需要扩展`CassandraPersistenceComponents`，因为我们使用了持久化，并且也扩展了`LagomKafkaComponents`——通过发布我们的事件，我们实际上也在使用消息。不幸的是，目前Lagom无法在编译时检查应用程序是否使用了消息传递，因此很容易忘记扩展Kafka组件，这将在应用程序启动时导致运行时错误。
- en: We have defined the persistent side of the `Chef` service' `MixingDone` events,
    so let's turn to the messaging side.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了`Chef`服务`MixingDone`事件的持久化部分，现在让我们转向消息部分。
- en: Message Broker API
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息代理API
- en: 'When we implemented persistence in `Chef` we skipped the definition of `resultsTopic`
    we provided in the API definition. Let''s take a look at the definition of `resultsTopic`
    now:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在`Chef`中实现持久化时，我们跳过了在API定义中提供的`resultsTopic`的定义。现在让我们看看`resultsTopic`的定义：
- en: '[PRE39]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We're using the `singleStreamWithOffset` constructor of the `TopicProducer`
    factory to construct a topic to which all of the events marked with `ChefModel.EventTag`
    will get published. Before publishing happens, we convert `ChefEvent` into `Dough`
    as expected by the downstream services. This is done in the `convertEvent` method.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`TopicProducer`工厂的`singleStreamWithOffset`构造函数来构建一个主题，所有标记为`ChefModel.EventTag`的事件都将发布到这个主题。在发布之前，我们将`ChefEvent`转换为下游服务期望的`Dough`。这是在`convertEvent`方法中完成的。
- en: 'The receiving side is `Manager`. Lagom provides all of the infrastructure so
    that the consumption of the events boils down to the following one-liner:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 接收方是`Manager`。Lagom提供了所有基础设施，使得事件的消费简化为以下一行代码：
- en: '[PRE40]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Here, we're using `chefService` `resultsTopic` to subscribe to the events. We
    provide `cookChefFlow` as a callback which will be called at least once for each
    of the published events. The `atLeastOnce` method expects `akka.stream.scaladsl.Flow[Payload,
    Done, _]` as a parameter with Payload referring to the type of the message. We'll
    define our flow of the `Flow[Dough, Done, _]` type in a moment.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`chefService` `resultsTopic`来订阅事件。我们提供`cookChefFlow`作为回调，该回调将至少为每个发布的事件调用一次。`atLeastOnce`方法期望`akka.stream.scaladsl.Flow[Payload,
    Done, _]`作为参数，其中Payload指的是消息的类型。我们将在稍后定义我们的`Flow[Dough, Done, _]`类型的流。
- en: Service API from the client side
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 客户端服务API
- en: 'We have defined all of our worker services so let''s take a look at `Manager`
    and how it drives the baking process by calling other services in the right order.
    Let''s start with the service definition:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了所有的工人服务，让我们看看`Manager`以及它是如何通过调用其他服务按正确顺序驱动烘焙过程的。让我们从服务定义开始：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We define three methods:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个方法：
- en: '`bake`, for initiating a baking process for a number of cookies'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bake`，用于启动多个饼干的烘焙过程'
- en: '`sell`, for selling cookies if there is enough stock'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sell`，如果库存足够，用于出售饼干'
- en: '`report`, for checking the number of cookies currently in stock'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`report`，用于检查当前库存中饼干的数量'
- en: We map them to two rest calls and a path call. We're using one path and one
    query parameter just to demonstrate the possibilities offered by the Lagom's descriptor
    DSL.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将它们映射到两个REST调用和一个路径调用。我们使用一个路径和一个查询参数只是为了展示Lagom的描述符DSL提供的可能性。
- en: 'Let''s get on with the service implementation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续进行服务实现：
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: We have to provide all of the services we're about to call as constructor parameters
    so that we can wire them together later in the definition of the application.
    We also define `logger` and `count`, which will hold the current number of cookies.
    In a real project, we would implement an event-sourced approach to the internal
    state of the Manager, but here we're just keeping it in memory for simplicity.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须提供所有即将调用的服务作为构造函数参数，这样我们可以在应用程序定义中稍后将它们连接起来。我们还定义了`logger`和`count`，它们将保存当前的饼干数量。在实际项目中，我们会实现一个基于事件源的方法来处理Manager的内部状态，但在这里我们只是为了简单起见将其保存在内存中。
- en: 'The `report` and `sell` methods are implemented by checking the internal state
    and modifying it if appropriate:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`report`和`sell`方法通过检查内部状态并在适当的情况下修改它来实现：'
- en: '[PRE43]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `bake` method is implemented by actually calling other services:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`bake`方法通过实际调用其他服务来实现：'
- en: '[PRE44]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Here, we generate a shopping list based on the number of cookies we requested
    to be baked. Then, in a for-comprehension, we're calling `boyService` and `chefService`.
    With the call of the chef service, we need to return because it is going to take
    some time for the chef to make the dough.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们根据请求烘焙的饼干数量生成购物清单。然后，在 for-comprehension 中，我们调用 `boyService` 和 `chefService`。在调用厨师服务时，我们需要返回，因为厨师制作面团需要一些时间。
- en: 'We already defined the listener for `Dough`, which is sent back by `Chef` via
    the message topic, so we just need to define the flow to handle the incoming messages:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了 `Dough` 的监听器，这是 `Chef` 通过消息主题发送回来的，所以我们只需要定义处理传入消息的流程：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Here again, we''re representing the possible one-liner as a couple of statements
    so that it is easy to spot what is going on: we define `Flow`, which transforms
    dough into `Future[RawCookies]` by calling `cookService`. `bakerService` is a
    streaming one so it expects `Source[RawCookies, _]` and we create it from `Future`.
    The invocation of `bakerService` returns `Future[Source[ReadyCookies, _]]` so
    we convert `Future` into `Source` again and then flatten `Source[Source[ReadyCookies,
    _]]` with `flatMapConcat`. Finally, we change the service''s internal state and
    return `Done` as expected by the subscription method.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们再次将可能的单行表示为几个语句，以便容易发现正在发生的事情：我们定义 `Flow`，通过调用 `cookService` 将面团转换为 `Future[RawCookies]`。`bakerService`
    是一个流式服务，它期望 `Source[RawCookies, _]`，我们从 `Future` 中创建它。调用 `bakerService` 返回 `Future[Source[ReadyCookies,
    _]]`，所以我们再次将 `Future` 转换为 `Source`，然后使用 `flatMapConcat` 平滑 `Source[Source[ReadyCookies,
    _]]`。最后，我们更改服务的内部状态，并返回 `Done`，这是订阅方法所期望的。
- en: 'It''s time to build `ManagerApplication` together! We need to provide references
    to all of the services we''ve used in `ManagerImpl`. Of course, we''ll use `serviceClient`
    for this:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候一起构建 `ManagerApplication` 了！我们需要为在 `ManagerImpl` 中使用过的所有服务提供引用。当然，我们将使用 `serviceClient`
    来完成这项工作：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ManagerServiceImpl` itself is constructed using the Macwire as before.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagerServiceImpl` 本身仍然使用 Macwire 构建。'
- en: Running the application
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'Now, we have all of our services built together and can run the project as
    a whole using the `runAll` command as before. We also need to have an `Akka-HTTP`
    example from the previous chapter running and have enough inventory so that the
    boy can get some groceries from it:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经构建了所有服务，并可以使用之前的 `runAll` 命令作为一个整体运行项目。我们还需要运行上一章中的 `Akka-HTTP` 示例，并确保有足够的库存，以便男孩可以从其中获取一些杂货：
- en: '![](img/0ef0fdde-c76b-4aca-bef1-fc8d76476ad8.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0ef0fdde-c76b-4aca-bef1-fc8d76476ad8.png)'
- en: 'The previous screenshot shows two Terminal windows: on the right the Akka HTTP
    shop from Chapter 14 is running and on the left the `runAll` command is ready
    to be executed. The `runAll` command takes some time to start all of the subsystems
    and produces a lot of output in the console.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了两个终端窗口：在右侧是第14章中的 Akka HTTP 商店正在运行，在左侧 `runAll` 命令准备执行。`runAll` 命令需要一些时间来启动所有子系统，并在控制台产生大量输出。
- en: At the moment of this writing the processing pipeline stopped just before returning
    baked cookies to the manager. We reported this issue as a Lagom bug ([https://github.com/lagom/lagom/issues/1616](https://github.com/lagom/lagom/issues/1616))
    but unfortunately got no feedback from Lagom team yet. We left the example as
    it is with the hope that the issue will be fixed in upcoming version of the framework.
    In the unlikely case if this is not a but we will update the example immediately
    after getting corresponding reaction to the bug report.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，处理管道在返回烘焙的饼干给经理之前停止了。我们将此问题报告为 Lagom 的一个错误 ([https://github.com/lagom/lagom/issues/1616](https://github.com/lagom/lagom/issues/1616))，但不幸的是，我们还没有收到
    Lagom 团队的反馈。我们保留了示例，希望问题将在框架的下一个版本中得到修复。在不太可能的情况下，如果这不是一个错误，我们将在收到对错误报告的相应反应后立即更新示例。
- en: 'After everything settles down, we can call our `Manager` service with an `http`
    client from another window:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一切都平静下来后，我们可以从另一个窗口使用 `http` 客户端调用我们的 `Manager` 服务：
- en: '[PRE47]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This should produce output similar to the following in the Lagom Terminal:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在 Lagom 终端产生类似于以下输出：
- en: '![](img/a345a2a0-7eb0-4bce-9f76-fce0df3f02e3.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a345a2a0-7eb0-4bce-9f76-fce0df3f02e3.png)'
- en: Looks like it is time to enjoy the cookies! Well, not quite yet!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来是时候享受饼干了！嗯，还不完全是时候！
- en: Testing
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试
- en: As before, we would like to conclude our journey by testing the implementation
    we came up with. Luckily, Lightbend follows the same approach to testing as it
    did with other libraries. There is a test kit that allows us to test services
    and persistent entities easily. We'll demonstrate how to test services in this
    section and leave testing persistent entities as an exercise for the reader.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，我们希望通过测试我们提出的实现来结束我们的旅程。幸运的是，Lightbend遵循与其他库相同的测试方法。有一个测试套件允许我们轻松地测试服务和持久化实体。我们将在本节中演示如何测试服务，并将测试持久化实体留给读者作为练习。
- en: 'It makes sense to start by testing the simplest service we defined—`CookService`.
    Here is a test for it, placed in the test scope of the `cook-impl` module:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有道理从测试我们定义的最简单的服务——`CookService`开始。这里是对它的测试，放置在`cook-impl`模块的测试范围内：
- en: '[PRE48]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Lagom provides a `ServiceTest` object whose purpose is to support testing of
    a single service. Its `withServer` constructor takes two parameters: an application
    constructor and a block of test code. It looks similar to the approach we used
    while testing the `Akka-HTTP` implementation in the previous chapter, but it behaves
    differently. `ServiceTest` actually starts the real server with the service. In
    our example, we mix it with `LocalServiceLocator`, so that we can get a service
    implementation from it in the test block. Here, we can invoke the service and
    verify that it works as expected.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom提供了一个`ServiceTest`对象，其目的是支持单个服务的测试。它的`withServer`构造函数接受两个参数：一个应用程序构造函数和一个测试代码块。它看起来与我们之前在测试第12章中的`Akka-HTTP`实现时使用的方法类似，但行为不同。`ServiceTest`实际上启动了带有服务的真实服务器。在我们的例子中，我们将其与`LocalServiceLocator`混合，这样我们就可以在测试块中从中获取服务实现。在这里，我们可以调用服务并验证它是否按预期工作。
- en: Our specification extends `AsyncWordSpec`, which gives us the freedom to formulate
    our expectations by mapping over `Future` returned by the service.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的规范扩展了`AsyncWordSpec`，这使我们能够通过映射服务返回的`Future`来制定我们的期望。
- en: 'Testing a synchronous service such as `CookService` is very easy. But how about
    testing the asynchronous (streaming) service? We''ve built an example using `BakerService`.
    Here is one possible implementation of the unit test for it:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 测试像`CookService`这样的同步服务非常简单。但是，如何测试异步（流式）服务呢？我们已经使用`BakerService`构建了一个示例。以下是该单元测试的一个可能的实现：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The definition of the test, the test server, and the client is the same as before.
    The only difference is that, instead of our normal domain types we need to provide `Source`
    and get `Source` back. So we reach out for the Akka-Streams test kit and use our
    knowledge gained in [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams* to formulate the expectations against the streams. We create
    an input `Source` from `List` and use `TestSink` to confirm that the output of
    the service meets our expectations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的定义、测试服务器和客户端与之前相同。唯一不同的是，我们需要提供`Source`而不是我们正常的领域类型，并返回`Source`。因此，我们求助于Akka-Streams测试套件，并利用我们在[第13章](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml)，“Akka
    Streams基础”中学到的知识来制定对流的期望。我们从`List`创建一个输入`Source`，并使用`TestSink`来确认服务的输出符合我们的期望。
- en: Now it's the time to enjoy the cookies!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是享受饼干的时候了！
- en: Summary
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Lagom framework is a Lightbend's solution aiming to streamline and simplify
    building microservices with Scala and Java. It is build on top of existing libraries
    and frameworks such as SBT, Akka, and Play and provides additional functionalities
    such as a rich development environment with hot code reload, a service registry
    and service locator, an embedded database, and a message broker.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom框架是Lightbend提供的一种解决方案，旨在简化使用Scala和Java构建微服务的过程。它建立在现有的库和框架之上，如SBT、Akka和Play，并提供了额外的功能，例如具有热代码重载的丰富开发环境、服务注册和服务定位器、嵌入式数据库和消息代理。
- en: 'Lagom has three useful APIs:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom有三个有用的API：
- en: Service APIs, which allow you to represent remote service calls as local function
    calls
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务API，允许您将远程服务调用表示为本地函数调用
- en: Persistence API, which provides additional structure and some useful defaults
    for `Akka-Persistence`
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持久化API，为`Akka-Persistence`提供额外的结构和一些有用的默认值
- en: Message broker API, which makes public/subscribe communication and working with
    the read-side of the journal a breeze
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息代理API，使公共/订阅通信和与日志的读取端交互变得容易
- en: Lagom comes with a test kit that helps to test services or persistent entities
    in isolation. Combining Lagom's test kit with the `Akka-Streams` test kit and
    `AsyncWordSpec` from `ScalaTest` makes it possible to write concise and expressive
    test expectations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: Lagom 随附一个测试套件，可以帮助独立测试服务或持久化实体。将 Lagom 的测试套件与 `Akka-Streams` 测试套件和来自 `ScalaTest`
    的 `AsyncWordSpec` 结合使用，使得编写简洁且表达性强的测试期望成为可能。
- en: In this chapter, we just touched briefly upon possibilities provided by Lagom
    for development of microservice-based systems. This area of software engineering
    is still quite immature and Lagom is one of the first attempts to address the
    new challenges.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只是简要地提到了 Lagom 为基于微服务系统的开发提供的可能性。这个软件工程领域仍然相当不成熟，而 Lagom 是解决这些新挑战的第一次尝试之一。
- en: We hope with our example project we could spark your interest in Lagom and highly
    recommend you look at the official Lagom documentation at [https://www.lagomframework.com/documentation/1.4.x/scala/Home.html](https://www.lagomframework.com/documentation/1.4.x/scala/Home.html)
    for further inspiration.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过我们的示例项目能够激发你对 Lagom 的兴趣，并强烈推荐你查看官方 Lagom 文档[https://www.lagomframework.com/documentation/1.4.x/scala/Home.html](https://www.lagomframework.com/documentation/1.4.x/scala/Home.html)以获取更多灵感。
- en: Questions
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How do you map an endpoint with a query parameter to a REST call?
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何将带有查询参数的端点映射到 REST 调用？
- en: What is the recommended serialization format for persistent entities?
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于持久化实体，推荐使用哪种序列化格式？
- en: Can you explain why clustering is required in order to use persistence in Lagom?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能解释为什么在 Lagom 中使用持久化需要聚类吗？
- en: Describe one possible data model which could be used to make the Manager a persistent
    entity.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述一个可能的数据模型，该模型可用于使管理器成为一个持久化实体。
- en: Outline an alternative way to implement the Baker service.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 概述一种实现 Baker 服务的替代方法。
- en: Can you identify a design bug in current implementation of the Chef?
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你能否在 Chef 当前实现中识别出一个设计错误？
- en: The Manager implementation stores a number of cookies in memory and this number
    will be lost at the moment the service restarts. Can you name another reason why
    it is a bad idea to hold the number of cookies in a local variable?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理器实现将多个 cookie 存储在内存中，而这个数字在服务重启时将会丢失。你能说出另一个为什么将 cookie 的数量保存在局部变量中是一个坏主意的原因吗？
- en: Further reading
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Rambabu Posa, *Scala Reactive Programming: Build fault-tolerant, robust, and
    distributed applications in Scala*
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Rambabu Posa，*《Scala 反应式编程：在 Scala 中构建容错、健壮和分布式应用程序》*
- en: Jatin Puri and Selvam Palanimalai, *Scala Microservices: Design, build, and
    run Microservices using Scala elegantly*
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jatin Puri 和 Selvam Palanimalai，*《Scala 微服务：优雅地使用 Scala 设计、构建和运行微服务》*
