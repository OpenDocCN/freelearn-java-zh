- en: Project 2 - Building Microservices with Lagom
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final part of this book goes into the details of the Lagom framework by
    discussing its philosophy, the way Lagom applications are structured, and available
    APIs and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build, once again, our bakery project, this time structured
    as a number of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'After reading this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the advantages of using Lagom
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up Lagom and use it to create projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Structure an application as required by the framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Efficiently use provided APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit test Lagom services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we begin, make sure you have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: JDK 8+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SBT 1.2+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code for this chapter is available at GitHub: [https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: Why Lagom?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the benefits and downsides of a microservices-based
    approach. We named the main architectural properties of microservices such as
    autonomy, isolation, and data ownership. We also noted that, compared to the traditional
    monolithic approach, microservices reduce the complexity of a single service but
    the complexity of the system as a whole does not disappear. In a sense, it just
    moves from the internals of a single microservice into the space between them.
    We looked at the implementation of the shop as a RESTful microservice, and we
    admitted that we would avoid this additional complexity by focusing on a single
    service.
  prefs: []
  type: TYPE_NORMAL
- en: As we worked through the Akka-based solution, we also chose the proper database
    to store events as well as defining and applying migrations to have a proper database
    schema. The choice of the configuration mechanism was predetermined by Akka but
    we still had to read and verify the configuration manually. We also needed to
    decide how to pass dependencies as we constructed runnable applications and properly implemented
    this passing.
  prefs: []
  type: TYPE_NORMAL
- en: The Lagom framework builds on top of a few existing technologies and utilizes
    the "convention over configuration" approach to reduce the burden of these repetitive
    mechanical tasks and to deliver some additional functionality specific to the
    microservice systems. It does so by providing a kind of "template" for projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preconfigured features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use of event sourcing as a mechanism for distributed persistence. The recommended
    database is Apache Cassandra because of its exceptional scalability and natural
    support for the read side of the CQRS principle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for asynchronous communications by making use of reactive streams with
    Akka Streams as an implementation and message-passing style with Apache Kafka
    as a broker.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transparent support for different communication protocols, which allows you
    to abstract complex API calls behind simple method calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expressive-service-description DSL, which allows you to define APIs in a flexible
    and concise way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamic scalability with Akka Cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A choice of dependency injection frameworks to wire the application at compile
    or runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development mode with hot code reload and an ability to start all services and
    required infrastructure components, including a special development service registry
    and a service gateway with a single command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default configuration for the infrastructure and preconfigured logging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's see how these features will help us to re-implement our bakery project.
  prefs: []
  type: TYPE_NORMAL
- en: Project overview and setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already implemented our bakery project three times using different technologies
    in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An Introduction
    to the Akka and Actor Models,* to [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams*. Let's recap what this is about for the readers who aren't familiar
    with the third section of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The bakery project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The bakery contains a few employees working together to produce delicious cookies.
    The structure of their communication is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7494c8d3-8fed-453e-ba0c-fb322b2db773.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Each of the employees is skilled in a specific area:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Manager** drives the process by taking the results of the work of each
    of the participants and giving them to the next step in the flow. They also create
    initial shopping lists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Boy**, if given a shopping list, will run to the grocery store and return
    with groceries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Chef**, if given groceries, will make dough. They do so by creating a
    couple of **Mixers** of limited capacity so that bigger amounts of groceries can
    be processed in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Cook**, if given dough, makes some raw cookies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Baker**, if given raw cookies, will bake them for some time using the
    **Oven**, hence producing delicious cookies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This time we're going to model each worker as a microservice. The **Mixers**
    and the **Oven** will become implementation details of the owning service.
  prefs: []
  type: TYPE_NORMAL
- en: Project setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It goes without saying that we'll implement our microservices using the Lagom
    framework. Lagom supports both Maven and SBT as build tools but SBT provides a
    much better user experience so we will ignore Maven as it is less relevant for
    Scala projects.
  prefs: []
  type: TYPE_NORMAL
- en: Further, in this section we're going to create a Lagom project from scratch.
    We could utilize a slightly different approach by creating an example project
    with Giter8 and then modifying and extending it as needed. The command is similar
    to the one we mentioned in [Chapter 11](87c2e446-3730-49ae-b86b-fc8269678399.xhtml), *An
    Introduction to the Akka and Actor Models*: `sbt new lagom/lagom-scala.g8`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, our SBT setup will contain a number of files describing different
    aspects of the project. For the following, assume we''ve created a project folder
    and navigated to it in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define that our project requires a Lagom SBT plugin, the version of
    SBT to be used, as well as few SBT options in the `.sbtopts` file. The first two
    lines define the initial and maximum amount of memory SBT is allowed to consume.
    We're going to start quite a lot of microservices and supporting infrastructure
    components so it is necessary to have enough memory available. The `-Xss` parameter
    defines a stack size of `2M` per thread. It is generally useful in Scala projects
    to prevent non-tail-recursive functions from overflowing the stack too soon. The
    last parameter, `-XX:MaxMetaspaceSize`, defines the size of the metaspace that
    is used (starting from the JVM 8) to store class metadata. Because of the Lagom's
    hot reloading, we're going to create and load many classes during development
    so we need to have a metaspace of significant size.
  prefs: []
  type: TYPE_NORMAL
- en: '`build.sbt` will contain a number of submodules so it is easier to create with
    a text editor. This is what the (partial) final result looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We've cut the repetitive definitions so please refer to the GitHub repository ([https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15](https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter15))
    for the full source code. Here, we define general properties of the project, a
    shared model, and five microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Each microservice consists of two modules, an API definition, and an implementation.
    Most of the API definitions in our case require just a single `lagomScaladslApi`
    dependency and the implementation—just `macwire` in the main scope. We've defined
    `defaultDependencies` including the test scope to keep further definitions concise.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `chef-impl`, we include three other compile-time dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lagomScaladslPersistenceCassandra`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lagomScaladslPubSub`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lagomScaladslKafkaBroker`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chef will take some time to mix the dough and because of this we aim to
    implement communication with the Manager via a message broker to decouple both
    from each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another deviation is the definition of `manager-impl`. The Manager will communicate
    with each of the other services, so it needs to know the API definitions of other
    workers. We also created a folder for each of the defined microservices in the
    filesystem. This is what our file structure with multiple modules looks like in
    the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we go on with the implementation, we''ll define a project structure as required
    by SBT for each of the modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: By having this structure, we're done with the preparation of the project infrastructure
    and can move on to implementing the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next diagram outlines the communication flow between modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a64ca8a-8335-4bb2-9b30-d29998a4b34a.png)'
  prefs: []
  type: TYPE_IMG
- en: In order to simplify our example a bit, we will violate the rule that each microservice
    should own the definition of its model. We'll define a module containing definitions
    of all of the case classes used by the services we're going to build. We will
    add this module as a dependency to every other module we've defined before.
  prefs: []
  type: TYPE_NORMAL
- en: 'The module itself will contain definitions already known to us from previous
    chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Our objects will be sent in serialized form between services. This means we
    also need to define serialization rules for them. We''ll do this by relying on
    Play''s macros, similar to Circe, which we used in the `http4s` example project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These formats go into the same `object model` instance along the case classes.
  prefs: []
  type: TYPE_NORMAL
- en: Lagom's APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, we will start with an implementation of the simplest of our workers,
    which just performs basic mathematical operations in order to do its work with `Cook`,
    which makes `RawCookies` out of `Dough`.
  prefs: []
  type: TYPE_NORMAL
- en: Service API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to define our Cook as a service we need to implement a special interface
    called a service descriptor. The service descriptor defines two aspects of a Lagom
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The service signature: How the service should be called and its return type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service meta data: How the service call is mapped to the transport layer,
    for example to the REST call'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The service descriptor extends Lagom''s `Service` trait and in its simplest
    form just needs to override the `descriptor` method. This is what it looks like
    in our `Cook` definition, which we place into the `cook-api` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we define a descriptor that connects the single call of the service, the
    `cook` method, to the service identifier `"CookService"` which will be needed
    for the routing later. For the call, we use the simplest identifier which just
    takes the name of the method. The configuration will result in the call mapped
    to the `/cook` REST URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The call itself is defined to be of the `ServiceCall[Dough, RawCookies]` type.
    Let''s take a look at `ServiceCall` in more detail. The definition in the Lagom''s
    source code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`ServiceCall` is typed by the request and response and can be invoked at the
    moment the request is issued by the client producing a response asynchronously.'
  prefs: []
  type: TYPE_NORMAL
- en: The request and response types in Lagom can be strict or streamed. There are
    four possible combinations ranging from both sides being strict to both sides
    being streamed. Strict means that the request or response is fully buffered in
    the memory at the method boundary. The combination of both the strict request
    and response results in the synchronous semantics of the call. A streamed request
    or response is of the `Source` type, which is known to us from [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams* where we looked at Akka streams. For the streaming calls, Lagom
    will try its best to choose the appropriate semantics. Typically, this will be
    WebSockets, and we will see how it works later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Cook` instance is very quick so it is appropriate to define the service
    in synchronous terms.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `Cook` goes in another module, `cook-impl`. This separation
    is essential in order to give microservices a possibility to refer to the definitions
    of each other without having any knowledge about implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is somewhat more involving, but not because of the service
    definition itself. The code should be very familiar by now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The only new part here is the definition of the service call wrapper. It is
    done by using the constructor defined in the `ServiceCall` companion object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We provide a function that converts `Dough` (request) into `Future[RawCookies]`
    (response) and the constructor builds a proper `ServiceCall` from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previously mentioned complexity is related to the fact that we also need
    to wire together and start our service. For those who read [Chapter 14](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml),
    *Project 1 - Building Microservices with Scala, *the approach will look very much
    like a combination of both approaches we looked at there: mixing traits and providing
    concrete implementations for abstract members and passing dependencies as constructor
    parameters. But this time, we''ll get the Lagom''s help for this task. First,
    we define `LagomApplication`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The application extends `LagomApplication` and needs `LagomApplicationContext`,
    which is just passed over via a constructor. No doubt you recognize the thin-cake
    pattern we used to connect together the components of our `Akka-HTTP` example.
    `lagomServer` is an overridden method, which is used by Lagom to provide correct
    wiring for the service calls. Another wiring happening here is the binding of `CookServiceImpl`
    to `CookService` with the help of Macwire.
  prefs: []
  type: TYPE_NORMAL
- en: Macwire ([https://github.com/adamw/macwire](https://github.com/adamw/macwire))
    is a dependency injection framework that implements constructor-based DI. It does
    so by generating calls to the class constructors with appropriate parameters found
    in scope. In a sense, it provides proper constructor calls behind the scenes the
    same way Circe or Play provide proper mapping to JSON structures. It would be
    very useful in projects of significant size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now our application can be used in the application loader, which does the real
    work of starting the service in a development or production environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`CookLoader` can be started by Lagom as needed. It overrides two `load` methods
    for respective environments. Please note how we extended `CookApplication` with `AhcWSComponents`.
    The latter is needed in order to provide `wsClient`, which in turn is required
    by `LagomApplication` we defined as a base class for our `CookApplication`. For
    the development mode, we also mix in `LagomDevModeComponents`, which gives us
    a development mode service locator.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to configure the application loader by providing a corresponding
    play setting in the well-known by now `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'And that is it—now we are ready to start our application. The easiest way to
    do this is by using Lagom''s `runAll` command in the SBT console. It will try
    to start all of the services we''ve defined so far as well as the components of
    the underlying infrastructure—the development mode service locator, Cassandra
    database, and Kafka message broker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The logs witness that the logging is working alongside other infrastructure
    components.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the log will contain a lots of stacktraces (not shown here) because
    of missing loader configurations for all but the `boy-impl` modules. We will fix
    this during this chapter, as we will implement the services one after another.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see that our service is running on port `57733` and can try to
    communicate with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Congratulations, we just talked to our first Lagom microservice!
  prefs: []
  type: TYPE_NORMAL
- en: We communicated to the service directly without using a service registry and
    service locator. It is safe to put the port number into the code listing for reference
    because despite their random appearance, ports are assigned to the services by
    Lagom in a deterministic manner (basically by using a hash of a project name).
    Hence, the services are assigned the same port numbers (with respect to port conflicts) in
    any environment.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can move on to the implementation of the `Boy` service, which is similarly
    simple in its functionality. It is expected to forward incoming shopping lists
    to external services and forward groceries it will get in return to the initial
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of the service should look familiar, except that we''re using
    the `namedCall` method to map the `shop` call to the `go-shopping` name in order
    to have a nicer URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation is a bit more complex then the `Cook` service because the
    `Boy` service needs to call an external HTTP service to make an order. The following
    template should not raise any questions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How do we call the external API though? We could, of course, use an HTTP client
    library and do the call the same way as before, issuing the HTTP request, getting
    the HTTP response, and handling marshalling and unmarshalling. But this would
    lower the abstraction level of our solution and hard-wire the implementation to
    the external service's location.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will do the following instead. First, we will register our externally running
    service with the service locator by adding the service''s URL to `build.sbt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will define an API for the grocery store as if we were about to implement
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we specify a service descriptor for the service with the same name as
    we just registered with the service locator. The API call is registered with a
    `restCall` descriptor to be sure that both the HTTP method and the path are correctly
    mapped to the existing service. We also need to wrap and unwrap `ShoppingList`
    and `Groceries` into proper `Order` and `Purchase` as expected with the existing
    shop service. Luckily, the JSON representation of our case classes is the same
    as for `Map[String, Int]` so we can safely just reuse the existing model along
    with serializers and add the wrappers on top of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to provide an implementation for `ShopService`; we just want Lagom
    to apply all existing machinery to represent an existing `REST` service as if
    it were one made with Lagom.
  prefs: []
  type: TYPE_NORMAL
- en: 'The shop service is ready to use with `Boy` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we provide the `shopService` client and an execution context. The
    latter will be used to transform the future result we''ll get from the service
    invocation. The `callExtApi` function shows how this is done: we refer to the
    `order` method from the `ShopService` definition, which returns `ServiceCall`,
    which we happily invoke with `Order` we created from the shopping list. The result
    is `Future[Purchase]` so we unwrap an order out of it. Finally, we define that,
    if anything wrong happens with the external service, for example, the service
    is not available or there is insufficient inventory to fulfill the order, the
    Boy should just return back with empty hands.'
  prefs: []
  type: TYPE_NORMAL
- en: Now `Boy` is able to communicate with `ShopService` we built in [Chapter 14](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml), *Project
    1 - Building Microservices with Scala* using `Akka-HTTP`.
  prefs: []
  type: TYPE_NORMAL
- en: The shop service must be running and must have sufficient inventory in order
    for further examples from this chapter to work properly.
  prefs: []
  type: TYPE_NORMAL
- en: Our `Boy` and `Cook` services are stateless. The `Cook` service just returns
    the result immediately so there is no point having any state in it. `Boy` is unsophisticated
    and just comes back for instructions if anything unexpected happens. But `Chef`
    and `Baker` are different because they are supposed to represent processes taking
    some time. For this reason we can't implement them in a synchronous manner.
  prefs: []
  type: TYPE_NORMAL
- en: The Baker has `m:n` semantics in the sense that it can respond with zero, one,
    or many response messages to a single incoming message. Let's use Lagom's possibility
    to define asynchronous services to implement it. This will allow us to reuse the
    flow definition for `Baker` we constructed in [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml),
    *Basics of Akka Streams*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first need to define the service as we already did, but this time with asynchronous
    semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we define `BakerService` to have a request of the `Source[RawCookies,
    NotUsed]` type and the response of the `Future[Source[ReadyCookies, NotUsed]]` type.
    This should allow us to just write `RawCookies` at the moment they are available
    and get `ReadyCookies` back after they are baked.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation is straightforward because it is literally wrapping the
    flow taken from [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We reuse the definition of the `Baker` and `Oven` flows and return the combined
    flow as the result of the call. In this snippet, we also demonstrate the use of `Logger`
    available from the underlying Play framework.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Chef` in our scenario takes some time to complete the mix process. Because
    of this, we would like to store the work in progress so that, in case the service
    is restarted, it does not get lost and the process just continues from where it
    was interrupted after recovery.'
  prefs: []
  type: TYPE_NORMAL
- en: We will use persistence facilities provided by the framework in order to implement
    this. The recommended way to persist data in Lagom is by utilizing an event sourcing
    approach, which we already used to implement an example project in [Chapter 14](be906843-d478-43fa-8d77-6f6b64b4a8e2.xhtml),* Project
    1 - Building Microservices with Scala*. Lagom automates data schema creation with
    Cassandra and also provides a Cassandra instance for development purposes. Therefore,
    we can start directly with the definition of the data model. As in the previous
    chapter, we need to provide a set of commands and events and also have an internal
    representation of the state. The following few snippets show one of the possible
    ways to represent these parts. As this model is just an implementation detail
    of `Chef`, it goes into the `chef-impl` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to have a bunch of imports in scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Having these, we can define our commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`MixCommand` represents an incoming request to mix some groceries. Commands
    in Lagom define the expected response type and we are using Akka''s `Done` for
    the response. The reason for this is that we''ll always accept `MixCommand` (because
    there is no reason not to), but at the moment the command is accepted it is not
    possible to predict which effect it will have.'
  prefs: []
  type: TYPE_NORMAL
- en: '`DoneCommand` represents a state transition from "mixing in progress" to "mixing
    done". It will be an internal command sent by `Chef` to itself. Technically we
    don''t need a response type here but we have to use `Done` again in order to make
    the compiler happy. `id` represents the unique identifier of the mixing job. Where
    does it come from? It is generated at the moment we''re creating an event from
    the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Mixing` event is created in response to the `MixCommand` and the `MixingDone` event—in
    response to the `DoneCommand`. Both events relate to each other via the `id` property.
    At the recovery time both events with same `id` will annihilate: presence of both
    events means that in the past a mixing job was started and then finished. In contrast,
    if there is only single event we can conclude that the job was not finished. Having
    unbalanced `Mixing` events after the recovery will mean we need to restart the
    mixing processes for them. Having unbalanced `MixingDone` events can only mean
    programming errors.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide this functionality, we''ll define the state as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll take a look at how it is used in the service implementation in a moment,
    after discussing the final bit of the model definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, we provide serializers for our events and commands the same way we did
    in the previous chapter. The Lagom's recommended serialization format is JSON
    so we're utilizing the same approach we already used for the shared model definition.
  prefs: []
  type: TYPE_NORMAL
- en: We also define `EventTag` which we'll need to implement the read-side of the
    event journal in order to notify `Manager` about the completed mixing jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final piece of configuration we need is a definition of Cassandra''s key
    space for `Chef`. This is done in the usual way in `application.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The definition of the service reflects the fact that the communication is synchronous
    on the request side and message based on the response side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mix` call accepts `Groceries` and returns `Done` (compare this with the
    return type of the commands we''ve just defined). The implementation of the service
    is also reasonably concise because it delegates state management to `ChefPersistentEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to pass two dependencies, `PersistentEntityRegistry` and `ActorSystem`.
    We pass the actor system, `as`, to `ChefPersistentEntity` at the moment of wiring
    and use the persistent entity registry to register our, well, persistent entity
    as required by Lagom. The `mix` call then just uses the registry to look up a
    reference to the entity and uses an `ask` pattern to send it an incoming command
    and get a response the same way we did with actors.
  prefs: []
  type: TYPE_NORMAL
- en: We're omitting the implementation of `resultsTopic` for now to focus on the
    persistence aspect of the service.
  prefs: []
  type: TYPE_NORMAL
- en: '`ChefPersistentEntity` is a bit longer, so let''s take a look at it in smaller
    chunks. We start with overriding Lagom''s `PersistentEntity`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The persistent entity can be accessed from anywhere in the cluster. Because
    of this, using persistence in Lagom automatically means using clustering (which
    is definitely a good idea). The persistent entity needs to override a few fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The `Command`, `Event`, and `State` types refer to those we defined earlier.
    We also define an initial state to be empty `MixingState`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For simplicity, we won''t implement the mixing behavior in its full complexity
    as we already did this three times in previous chapters. Instead, we''ll mock
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can finally define the behavior of our entity which will accept commands,
    persist events, and modify states. Again, this is done similarly to how we did
    in the previous chapter, but Lagom adds its five cents by providing an `Actions`
    constructor, which allows us to define command and event handlers in a builder-like
    manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The command handler must return a `Persist` directive, which describes what
    should be persisted with an optional callback for side-effecting code, which should
    be executed after an event was successfully written to the storage.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding snippet, we're handling two commands. `MixCommand` with a negative
    amount of `Dough` is marked as invalid (which is modelled by sending `InvalidCommandException`
    to the caller), and calling `ctx.done` returns `PersistNone` with the meaning
    that nothing needs to be persisted.
  prefs: []
  type: TYPE_NORMAL
- en: The second handler is for valid commands. With it, we first generate random
    `id` for the event we're going to persist, then we construct the event and return `PersistOne`
    with the event and a callback. The callback schedules send a command to the persistent
    entity itself meaning the mixing is done and sends `Done` back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be able to dereference an entity, we need to use a registry as
    we did in the service earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that our persistence callbacks are only executing side effects
    and not modifying the state. For the state modifications, another constructor,
    `onEvent`, should be used. This separation is done in order to gain the possibility
    to reconstruct the state during the recovery as many times as required, but to
    have side effects executed only once after the actual event had happened and was
    persisted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we''ve just put new mixing jobs into the queue and we remove them from
    the queue after they are complete. Now we have to define how to react to the `DoneCommand`
    our entity sends to itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We're looking in the current state for `MixingCommand`, which we created before
    by using `id` as an equality criteria, just to have a reference to `groceries`.
    The groceries will be required later; at the moment we will read the event on
    the read side. Then we construct and persist an event and return `Done` to make
    the compiler happy. You probably noticed that we haven't defined any side-effects
    for the `MixingDone` event. We don't need to because these events will be streamed
    to `resultsTopic` we specified earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conclude the implementation of `Chef`, we need to wire all components together.
    `ChefLoader` is not any different from other loaders we''ve defined so far. In
    contrast, `ChefApplication` deviates a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We need to provide an implementation of `JsonSerializerRegistry` for Lagom to
    be able to pick up our serializers. Our application also needs to extend `CassandraPersistenceComponents`
    as we're using persistence and also `LagomKafkaComponents`—by publishing our events
    we're effectively using messaging as well. Unfortunately, currently Lagom can't
    check at compile time whether messaging is used by the application, so it is easy
    to forget to extend Kafka components, which will lead to runtime errors at the
    moment the application is started.
  prefs: []
  type: TYPE_NORMAL
- en: We have defined the persistent side of the `Chef` service' `MixingDone` events,
    so let's turn to the messaging side.
  prefs: []
  type: TYPE_NORMAL
- en: Message Broker API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we implemented persistence in `Chef` we skipped the definition of `resultsTopic`
    we provided in the API definition. Let''s take a look at the definition of `resultsTopic`
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: We're using the `singleStreamWithOffset` constructor of the `TopicProducer`
    factory to construct a topic to which all of the events marked with `ChefModel.EventTag`
    will get published. Before publishing happens, we convert `ChefEvent` into `Dough`
    as expected by the downstream services. This is done in the `convertEvent` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The receiving side is `Manager`. Lagom provides all of the infrastructure so
    that the consumption of the events boils down to the following one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, we're using `chefService` `resultsTopic` to subscribe to the events. We
    provide `cookChefFlow` as a callback which will be called at least once for each
    of the published events. The `atLeastOnce` method expects `akka.stream.scaladsl.Flow[Payload,
    Done, _]` as a parameter with Payload referring to the type of the message. We'll
    define our flow of the `Flow[Dough, Done, _]` type in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Service API from the client side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have defined all of our worker services so let''s take a look at `Manager`
    and how it drives the baking process by calling other services in the right order.
    Let''s start with the service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We define three methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bake`, for initiating a baking process for a number of cookies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sell`, for selling cookies if there is enough stock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`report`, for checking the number of cookies currently in stock'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We map them to two rest calls and a path call. We're using one path and one
    query parameter just to demonstrate the possibilities offered by the Lagom's descriptor
    DSL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get on with the service implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We have to provide all of the services we're about to call as constructor parameters
    so that we can wire them together later in the definition of the application.
    We also define `logger` and `count`, which will hold the current number of cookies.
    In a real project, we would implement an event-sourced approach to the internal
    state of the Manager, but here we're just keeping it in memory for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `report` and `sell` methods are implemented by checking the internal state
    and modifying it if appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The `bake` method is implemented by actually calling other services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Here, we generate a shopping list based on the number of cookies we requested
    to be baked. Then, in a for-comprehension, we're calling `boyService` and `chefService`.
    With the call of the chef service, we need to return because it is going to take
    some time for the chef to make the dough.
  prefs: []
  type: TYPE_NORMAL
- en: 'We already defined the listener for `Dough`, which is sent back by `Chef` via
    the message topic, so we just need to define the flow to handle the incoming messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Here again, we''re representing the possible one-liner as a couple of statements
    so that it is easy to spot what is going on: we define `Flow`, which transforms
    dough into `Future[RawCookies]` by calling `cookService`. `bakerService` is a
    streaming one so it expects `Source[RawCookies, _]` and we create it from `Future`.
    The invocation of `bakerService` returns `Future[Source[ReadyCookies, _]]` so
    we convert `Future` into `Source` again and then flatten `Source[Source[ReadyCookies,
    _]]` with `flatMapConcat`. Finally, we change the service''s internal state and
    return `Done` as expected by the subscription method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to build `ManagerApplication` together! We need to provide references
    to all of the services we''ve used in `ManagerImpl`. Of course, we''ll use `serviceClient`
    for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '`ManagerServiceImpl` itself is constructed using the Macwire as before.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, we have all of our services built together and can run the project as
    a whole using the `runAll` command as before. We also need to have an `Akka-HTTP`
    example from the previous chapter running and have enough inventory so that the
    boy can get some groceries from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ef0fdde-c76b-4aca-bef1-fc8d76476ad8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous screenshot shows two Terminal windows: on the right the Akka HTTP
    shop from Chapter 14 is running and on the left the `runAll` command is ready
    to be executed. The `runAll` command takes some time to start all of the subsystems
    and produces a lot of output in the console.'
  prefs: []
  type: TYPE_NORMAL
- en: At the moment of this writing the processing pipeline stopped just before returning
    baked cookies to the manager. We reported this issue as a Lagom bug ([https://github.com/lagom/lagom/issues/1616](https://github.com/lagom/lagom/issues/1616))
    but unfortunately got no feedback from Lagom team yet. We left the example as
    it is with the hope that the issue will be fixed in upcoming version of the framework.
    In the unlikely case if this is not a but we will update the example immediately
    after getting corresponding reaction to the bug report.
  prefs: []
  type: TYPE_NORMAL
- en: 'After everything settles down, we can call our `Manager` service with an `http`
    client from another window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce output similar to the following in the Lagom Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a345a2a0-7eb0-4bce-9f76-fce0df3f02e3.png)'
  prefs: []
  type: TYPE_IMG
- en: Looks like it is time to enjoy the cookies! Well, not quite yet!
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As before, we would like to conclude our journey by testing the implementation
    we came up with. Luckily, Lightbend follows the same approach to testing as it
    did with other libraries. There is a test kit that allows us to test services
    and persistent entities easily. We'll demonstrate how to test services in this
    section and leave testing persistent entities as an exercise for the reader.
  prefs: []
  type: TYPE_NORMAL
- en: 'It makes sense to start by testing the simplest service we defined—`CookService`.
    Here is a test for it, placed in the test scope of the `cook-impl` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Lagom provides a `ServiceTest` object whose purpose is to support testing of
    a single service. Its `withServer` constructor takes two parameters: an application
    constructor and a block of test code. It looks similar to the approach we used
    while testing the `Akka-HTTP` implementation in the previous chapter, but it behaves
    differently. `ServiceTest` actually starts the real server with the service. In
    our example, we mix it with `LocalServiceLocator`, so that we can get a service
    implementation from it in the test block. Here, we can invoke the service and
    verify that it works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Our specification extends `AsyncWordSpec`, which gives us the freedom to formulate
    our expectations by mapping over `Future` returned by the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Testing a synchronous service such as `CookService` is very easy. But how about
    testing the asynchronous (streaming) service? We''ve built an example using `BakerService`.
    Here is one possible implementation of the unit test for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The definition of the test, the test server, and the client is the same as before.
    The only difference is that, instead of our normal domain types we need to provide `Source`
    and get `Source` back. So we reach out for the Akka-Streams test kit and use our
    knowledge gained in [Chapter 13](8b5e55e4-de37-4ab1-8baa-7e0c3ad3a6ed.xhtml), *Basics
    of Akka Streams* to formulate the expectations against the streams. We create
    an input `Source` from `List` and use `TestSink` to confirm that the output of
    the service meets our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's the time to enjoy the cookies!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lagom framework is a Lightbend's solution aiming to streamline and simplify
    building microservices with Scala and Java. It is build on top of existing libraries
    and frameworks such as SBT, Akka, and Play and provides additional functionalities
    such as a rich development environment with hot code reload, a service registry
    and service locator, an embedded database, and a message broker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lagom has three useful APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Service APIs, which allow you to represent remote service calls as local function
    calls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence API, which provides additional structure and some useful defaults
    for `Akka-Persistence`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message broker API, which makes public/subscribe communication and working with
    the read-side of the journal a breeze
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lagom comes with a test kit that helps to test services or persistent entities
    in isolation. Combining Lagom's test kit with the `Akka-Streams` test kit and
    `AsyncWordSpec` from `ScalaTest` makes it possible to write concise and expressive
    test expectations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we just touched briefly upon possibilities provided by Lagom
    for development of microservice-based systems. This area of software engineering
    is still quite immature and Lagom is one of the first attempts to address the
    new challenges.
  prefs: []
  type: TYPE_NORMAL
- en: We hope with our example project we could spark your interest in Lagom and highly
    recommend you look at the official Lagom documentation at [https://www.lagomframework.com/documentation/1.4.x/scala/Home.html](https://www.lagomframework.com/documentation/1.4.x/scala/Home.html)
    for further inspiration.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you map an endpoint with a query parameter to a REST call?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the recommended serialization format for persistent entities?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you explain why clustering is required in order to use persistence in Lagom?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe one possible data model which could be used to make the Manager a persistent
    entity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Outline an alternative way to implement the Baker service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you identify a design bug in current implementation of the Chef?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Manager implementation stores a number of cookies in memory and this number
    will be lost at the moment the service restarts. Can you name another reason why
    it is a bad idea to hold the number of cookies in a local variable?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rambabu Posa, *Scala Reactive Programming: Build fault-tolerant, robust, and
    distributed applications in Scala*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jatin Puri and Selvam Palanimalai, *Scala Microservices: Design, build, and
    run Microservices using Scala elegantly*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
