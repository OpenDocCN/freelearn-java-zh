- en: Tuning the Configuration of Your Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to configure your Swarm services. We will
    show you practical examples of different configuration tools that are available
    and how you can use them to steer the behavior of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying Swarm configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fractions available in Swarm come with reasonable defaults. In the examples
    that we have seen so far, we didn't touch any configuration and yet we were able
    to see the applications working. Now, we will show you how you can tune the configuration
    of Swarm-created services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Swarm provides a set of tools that allows you to modify the configuration of
    your applications. In the following section, we will introduce them one by one
    and show their usage in different scenarios. Let''s start with the simplest one:
    system properties.'
  prefs: []
  type: TYPE_NORMAL
- en: System properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You are able to modify the configuration by specifying system properties. Let's
    return to our catalog-service. As you saw in the catalog-service examples from
    the last chapter, the JAX-RS application was listening for HTTP requests on port
    8080, which is the default configuration. Let's suppose that we want to change
    that port.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we have to do is specify the `swarm.http.port` property during the application
    execution, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the web browser, we can see that, indeed, the port on which the
    application runs has been changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6f977254-4fb7-47db-9127-8c3f3a389086.png)'
  prefs: []
  type: TYPE_IMG
- en: What has just happened here then? The undertow fraction has discovered that
    there is a configuration property that overrides the standard HTTP port, and it
    modifies the socket's configuration accordingly. As a result, the running application
    is using the specified port.
  prefs: []
  type: TYPE_NORMAL
- en: Each fraction contains a group of properties that can be used to configure it.
    You will be able to find them in Swarm documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The method of editing the properties is very simple and can be sufficient in
    many cases, but the entry point to the more complex programmatic configurations
    may be more feasible let's learn how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing your own main class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each Swarm service contains the `main` class which is responsible for creating
    and configuring a runtime for the service and running service code on it. Swarm
    creates the default implementation of the `main` class (in fact, the default class
    was used in all the examples till now), but you are able to provide your own implementation
    of the `Main` class if you want to modify the default behavior. An example of
    such modification may be providing an additional configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to the catalog-service. Let''s recall its current operation:
    we created a `jaxrs` resource and injected the service providing the invitation
    message using CDI. Now, let''s modify this example to provide our own `main` class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter4/catalog-service-first-main`'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to do it, we have to modify the `pom.xml` of the catalog-service in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We have to modify the Swarm plugin so that its configuration contains the class
    with our `main` method (1). When using your own `main` method, you have to specify
    manually on which fractions your service depends (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at the `org.packt.swarm.petstore.Main` class, which
    implements the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We created the instance of the `org.wildfly.swarm.Swarm` class (1). The `start`
    method has created the container, and the `deploy` method has deployed the created
    archive on it. We have also created (2) the log output to prove that the class
    is indeed working. We will look at the `Swarm` class in greater detail in just
    a moment, but before that here is the mentioned proof:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13651764-af24-43ea-8d63-93743ab53505.png)'
  prefs: []
  type: TYPE_IMG
- en: The message is there, and the method has been executed.
  prefs: []
  type: TYPE_NORMAL
- en: The Swarm class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the preceding section, if you are implementing your own `main`
    method, you will interact with the `org.wildfly.swarm.Swarm` class. This class
    is responsible for instantiating the container based on the provided configuration
    and creating and deploying the archive with your application. Both of those steps
    can be modified by operations on the `Swarm` class. Let's learn more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Providing the configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Swarm` class provides a group of methods that allow you to modify the configuration
    using the Java API, such as `fraction`, `socketBinding`, and `outboundSocketBinding`.
    The latter two methods, as their names imply, allow you to create your own socket
    binding and outbound socket binding groups. The method that is the most interesting
    to us is the `fraction` method. It takes one argument for the `org.wildfly.swarm.spi.api.Fraction`
    class implementations—the `fraction`. You will be able to modify and reconfigure
    all the fractions and provide them to Swarm. Let's get a first grasp of this functionality
    on our favorite example, that is, changing the HTTP port of the `CatalogService`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter4/catalog-service-config-main`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we have to add the `UndertowFraction` dependency to our `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Secondly, let''s reimplement the `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run the preceding code, you will indeed see the same result as in the
    property example: the application is running on the `12345` port. So, what has
    just happened?'
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning of the preceding code, we created the `UndertowFraction` (1)
    and run the `applyDefaults` method (2). If the `fraction` is automatically created
    by Swarm, the default configuration is applied to it. On the other hand, if you
    create the `fraction` manually, you are creating the empty `fraction` object with
    no configuration. That's what the `applyDefaults`method is for. It applies the
    default configuration to the `fraction` object. As a result, whenever you don't
    want to create the configuration from scratch and just modify it, you have to
    invoke the `applyDefaults`method first and apply your configuration changes after
    that. That's exactly the scenario in our simple example. We didn't want to create
    the full configuration manually. Instead, we only wanted to change the one configuration
    parameter—the listening port. As a result, we applied the default configuration
    to the `fraction` object, and after that, we only changed the HTTP port.
  prefs: []
  type: TYPE_NORMAL
- en: We created the `UndertowFraction` object that represents the configuration of
    the Undertow fraction. We have to provide this configuration to the container
    that will run the service. In order to do it, we used Swarm's `fraction` method
    (4). It is worth mentioning here that the application still consists of many `fraction`s
    but we have provided only the `Undertowfraction` configuration. If we don't add
    a customized `fraction` configuration to the `Swarm` class, then the default configuration
    is used. Swarm is still going to bootstrap CDI and JAX-RS among others, but their
    configuration will be created automatically, just as it was in our first example.
    On the other hand, the `Undertowconfiguration` object is provided by us manually
    and Swarm will use it.
  prefs: []
  type: TYPE_NORMAL
- en: After the application is configured, we are ready to start and deploy (5) it,
    just as we did in the previous example. If we run our application, we will see
    the same result that we obtained in the example that used the system property—the
    application runs on port `12345`.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the property example, we have to add only one configuration parameter,
    and, here, we have to do quite a lot of stuff. You may ask whether you can use
    the Java API to provide a more elaborate configuration but still resort to the
    properties in cases such as an HTTP port; that's a good question. Let's find out.
  prefs: []
  type: TYPE_NORMAL
- en: Using your own main along with properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s modify the `Main` class to the simplest possible form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run it with the HTTP port property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we will check in in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b021482-ea66-41f4-8e21-6820b71ea03a.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, it didn't work. So, as it just turned out, you are not able to do it,
    sorry.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am kidding, of course. You can do it, but as it turned out, we have, completely
    accidentally, made a small mistake in our code from the last listing. What is
    wrong with it? The system properties with which the `main` method was executed
    were not propagated to Swarm in any way. Consider that, on the other hand, we
    have written our code in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The application will use specified properties and present the application behavior
    we will be able to see that it is working correctly.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, you are now able to mix the Java API with a properties-based configuration,
    but you have to remember to create Swarm with `main` function arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Java API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's return to the `Swarm` class. We have already seen that we are able to
    create the fraction class with our own configuration and hand it on to the `Swarm`
    class. In fact, we are able to steer the whole Swarm configuration programmatically.
    To create a more elaborate example, let's extend our `CatalogService` so that
    it stores its data in a database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter4/catalog-service-database`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with editing the `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have added four new Maven dependencies. In order to configure our own `datasource`,
    we have to add the `datasource`s fraction (1). As we will use the Java Persistence
    API, we will need both the `jpa` fraction and the JPA API (2). We will also use
    `h2` in-memory database, and we need its `dependency` too (3). Finally, we provide
    the `dependency` to `h2` database (4).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are going to persist the data about pets available in the store, we have
    to modify the `Item` class so that it is an entity, a JPA object representing
    a state that will be persisted in the relational database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple `jpa` entity (1) with the corresponding table named `"ITEM"`
    (2). We have created the `NamedQuery` (3) to find pets by `name`. We have added
    the database ID field (4). Furthermore, we have added the `@Column` annotations
    so that `name` and `quantity` fields are persisted to the database (5).
  prefs: []
  type: TYPE_NORMAL
- en: 'We would also need to modify our `CatalogService` class so that it can load
    pet data from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We referenced the `CatalogPU`persistence context (we will configure it in a
    moment) and used a named query defined in an `Item` class to find pets by `id`
    (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, let''s move to the interesting part. We will create and use in-memory `h2`
    `datasource`; The following is the code to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The configuration of the `datasourcesFraction` is a bit more complex than the
    simple port change—let's look at it in greater detail. In (1), we defined the
    **Java Database Connectivity** (**JDBC**) driver named `"h2"` and provided lambda
    expression implementing the `org.wildfly.swarm.config.JDBCDriverConsumer` class—this
    is basically the acceptor that allows you to apply the additional configuration
    to the created JDBC driver. The analogous situation happens in (2). Here, we created
    the `CatalogDS` datasource and applied an additional configuration using the `org.wildfly.swarm.config.DatasourcesConsumer`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding code, this configuration is not as trivial as
    the `Undertowport` change, but don't worry. Swarm comes with the current Java
    API library with each release, and as all the configuration options are described
    there, you don't have to rely on guesswork while configuring your application
    using this method [1].
  prefs: []
  type: TYPE_NORMAL
- en: We still have to do more things to make our example work, such as provide `persistence.xml`
    and fill our database with a group of messages on startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the first thing. The following is our `persistence.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding configuration, we created the persistent-unit named `CatalogPU`,
    which uses `JTA` transactions (1), made the persistent-unit use the `CatalogDS`
    datasource created earlier (2), provided a configuration that will make the database
    create the new database on the deployment and delete it on undeployment using
    entity classes metadata (3), and, finally, provided the load script (4).
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that we don''t have it yet; let''s add it then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After all that is finally done, we should be able to see our application working.
    Let''s try it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/648bbecc-8f5c-49dd-a3df-6bbe60bcc966.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Oops! Instead of the browser page with a message, an awful red log appears.
    What went wrong? Let''s take a look at the first read message: `"WFLYJCA0041:
    Failed to load module for driver [com.h2database.h2]"`. True, as this is a custom
    driver module, we have to add it to our application manually. How are we able
    to do that? That is simple too.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an additional custom module to our application, we have to add it to
    the `resources` directory of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8972de7-bbec-4945-92dc-149c1ccd599e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the preceding screenshot, the `modules` directory has to be placed
    inside the Maven''s `resources` directory inside our application, and the directory
    structure has to match the module name. Let''s look at the module descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: To recall, this is the same kind of descriptor that we presented in [Chapter
    2](c00cfc93-f395-446e-9132-242f02216783.xhtml), *Getting Familiar with WildFly
    Swarm*, where we described the concept of modular classloading. In the preceding
    file, we are creating a module with the `"com.h2database.h2"` name (1), specifying
    that the only resource is the `h2` database artifact. Note that we are referencing
    the artifact using Maven coordinates. Finally, we have to specify all the module
    dependencies (3).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build and run the application again. We are indeed able to look up our
    pets now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62112f99-add2-46fd-a8aa-b14e34aaf609.png)'
  prefs: []
  type: TYPE_IMG
- en: We are indeed, able to search pets by `id` now.
  prefs: []
  type: TYPE_NORMAL
- en: Let's continue with the `Swarm` class usage. The next thing that we will look
    at is its `deploy` method.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying your archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our previous examples, each time we created the `Swarm` instance and applied
    some configuration on top of it, we used the no-argument `deploy` method. This
    method takes the archive generated by the standard Maven build and deploys it
    on the previously configured container. This is not the only version of the `deploy`
    method, though. You are able to create your own archive (or archives) and deploy
    them to the Swarm container. How? It is possible using the `ShrinkWrap` API.
  prefs: []
  type: TYPE_NORMAL
- en: The ShrinkWrap API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have ever worked with WildFly AS, and, especially, its testing framework
    Arquillian, you are probably also familiar with the `ShrinkWrap` API, which is
    used to build application archives before they are deployed in the test environment.
    However, if you have never used it, don't worry—the API is very simple and straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: The central class in the API is the `org.jboss.shrinkwrap.api.Archive`instance.
    It is an abstract class that represents the archive. The concrete implementations
    that interest us the most are `org.jboss.shrinkwrap.api.spec.JavaArchive` and
    `org.jboss.shrinkwrap.api.spec.WebArchive` that represent JARs and WARs as you
    probably have guessed. The API is simple; it contains a bunch of methods that
    allow you to add resources to the archive. Let's see its operation in practice.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of this example, let's return to the first `CatalogService` version,
    which contained only the `jaxrs` resource and application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter4/catalog-service-shrinkwrap`'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the `ShrinkWrap` in action, we have to modify the `pom.xml`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As we are providing our own `main`, we have to explicitly add the dependency
    on the `jaxrs` fraction (1). We also have to add the method to the Swarm plugin
    configuration (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `ShrinkWrap` API usage in the `org.packt.swarm.petstore.Main`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We created the web archive (1), added the classes that our example consists
    of (2), and deployed them on the created container (3). As a result, we have manually
    done the same thing that Swarm does for us automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We have used the `addClass` method to add created classes to the archive. In
    a similar way, you are able to use other `ShrinkWrap` API methods. The `org.jboss.shrinkwrap.api.spec.JavaArchive`class
    apart from the native archive methods (`add` and `addDirectory)`) contains the
    methods that make it easy to work with classes (`addClass` and `addPackage`),
    resources (`addResource`), and manifests (`setManifest` and `addManifestResource`).
    The `org.jboss.shrinkwrap.api.spec.WebArchive`class additionally adds web resource
    methods (`addWebResource` and `setWebXML`). As in the preceding example, using
    those methods is usually straightforward, but in the case of any doubts, you can
    take advantage of the `ShrinkWrap` Java API.
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining the default archive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Isn''t `ShrinkWrap` too tedious to be useful in any real-life circumstances?
    After all, we don''t want to manually add all classes and resources from our application
    to the archive. You don''t have to worry about it—you will be able to obtain default
    deployment from the Swarm instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you see in the preceding example, we were able to obtain the default deployment
    by invoking the `createDefaultDeployment()` method. After we have it, we can only
    additional needed resources to it.
  prefs: []
  type: TYPE_NORMAL
- en: Swarm ShrinkWrap extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Swarm adds its own classes to complement the `ShripWrap` API. Let's introduce
    them.
  prefs: []
  type: TYPE_NORMAL
- en: JARArchive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `org.wildfly.swarm.spi.api.JARArchive` is an alternative to the `JavaArchive`.
    Apart from all functions provided by it, the `JARArchive` adds an API to easily
    add modules, Maven dependencies, and service provider implementations.
  prefs: []
  type: TYPE_NORMAL
- en: WARArchive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the `WebArchive` adds a functionality on top of `JavaArchive`, the `WARArchive`
    adds new features on top of the `JARArchive`. Apart from an interface that allows
    working with web resources, it adds the possibility to easily add the static web
    content. Let's look at this for an example.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, we need the `pom.xml:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we are using our own `main`, we will need to add an `undertow` fraction dependency
    (1) and configure the `main` method (2).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our static content will be a simple Hello World page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add this class to the `webpage` directory inside our application''s
    resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ab8d6a54-6b03-42d0-9369-61741ae8b6a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `main` class looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created the `WARArchive` and invoked the `staticContent` method. When
    we open the web browser, we will see the Hello World page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a42fac63-e643-4e5c-a393-d0a77453b151.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What has happened? The static content method has copied all non-Java files from
    the `webpage` directory (one file in our example) to the created archive so that
    they can be seen by `undertow`.
  prefs: []
  type: TYPE_NORMAL
- en: JAXRSArchive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last type of Swarm archive that we want to look at right now is the `org.wildfly.swarm.JAXRSArchive`.
    This archive adds the ability to create a default JAX-RS application with the
    application path set to `"/"`. Till now, we have been doing this manually in all
    our examples. With the JAX-RS Archive, this class will be added automatically.
  prefs: []
  type: TYPE_NORMAL
- en: XML configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although Java API is convenient, this is not the only option that we have. If
    you are familiar with the WildFly XML configuration, or if you are migrating your
    application to Swarm and have a working XML file, you don't have to translate
    it to Java API as you can use it directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter4/catalog-service-xmlconfig`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s return to our database example. You may configure the datasource using
    XML. In such a case, the XML configuration will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to add this configuration file to the `resources` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b7410646-ea8f-4454-aef5-44462e54287d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, we also have to tell Swarm to use the configuration file. The following
    is the modified `Main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have obtained the classloader to be able to locate the configuration file(1).
    After reading the file, we instructed Swarm to use the configuration from it (2).
  prefs: []
  type: TYPE_NORMAL
- en: However, we have used the whole configuration file—will Swarm use all the subsystems
    now? The answer is no; only the fractions, whose dependencies have been specified
    will be added to the container. Swarm, given the XML file, will read only the
    configuration of those subsystems whose fractions constitute it. You are also
    able to provide a file with only those subsystems that you want to configure using
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: YAML configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way in which you can provide Swarm configuration is YAML data serialization
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Once more, let's start with the port-change example. We will start again with
    JAX-RS example and modify it to use the YAML configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create the HTTP-`port.yml` configuration file inside the `resources`
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The nested properties are translated to flat properties by Swarm. So, the property
    specified by the preceding file is translated to `swarm.http.port`, which we know
    well already.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the following configuration, we have to modify our `Main` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After obtaining the configuration from the `classpath` (1), we informed Swarm
    to use it using the `withConfig` method. That's it; now, Swarm will use the `12345`
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Project stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strength of the YAML configuration is its ability to provide different groups
    properties for different project stages. Again, let's take a look at the example
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new configuration file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The different parts of the file gather the configuration for different project
    stages. The first group is the default configuration. It is used when no stage
    name is provided. The other two specify the configurations for test and `QA` stages.
    However, how do you know the stage in which the application currently runs? You
    have to provide the `swarm.project.stage` property. So, consider that, for example,
    we run the preceding example with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Then, we will be able to access our application on the `12346` port.
  prefs: []
  type: TYPE_NORMAL
- en: As you will have noticed in the preceding code, the YAML configuration makes
    it easy to create the configuration for different environments and choose what
    group of properties should be used using a simple command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: YAML database configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As an another YAML config example, we are going to show you how to configure
    the datasources with the YAML configuration file. Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples reference: `chapter 4/catalog-service-database-ymlconfig`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example is very similar to the XML configuration example. We have to exchange
    the configuration file for its YAML equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And also need to make the `Main` class use it (1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are going to use such configurations a lot in the examples throughout the
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing the configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, what about mixing configurations? Are you allowed to do this? Yup. Let''s
    look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: It is another variation of our database example, and you already know what is
    happening in the whole code. Just to recall, we loaded the configuration file
    and informed Swarm to use it (1), created the `UndertowFraction` and configured
    it to use the `12345` port (2), added the driver module to the application (3),
    and, finally, started the application and deployed the created archive on it (4).
  prefs: []
  type: TYPE_NORMAL
- en: What would be the result of such code? As you probably have guessed, after running
    the application, we will be able to see the random messages on `localhost:12345/hello`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you are able to mix XML and Java API configurations. Can you use
    the properties too? Sure. Let''s add `swarm.http.port` with the `12346` port to
    the command line, and we will be able to see our messages on the address. Yeah,
    we have a conflict here. Is this an error? It is not an error. Swarm attaches
    different priorities to different configuration methods. The precedence is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Java API overrides the configuration specified by XML
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML overrides the configuration specified by Java API
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the system properties override the YAML configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a result, in our last example, we will see our messages on the `12346` port
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to configure services created using Swarm.
    You learned how to modify the Swarm behavior using the system properties, provide
    your own `main` method and use it to provide the Swarm configuration using either
    Java API or XML, and, finally, how to modify the content of the deployed application.
  prefs: []
  type: TYPE_NORMAL
- en: After the three initial chapters, you are now able to use WildFly Swarm to build
    microservices. In the next chapters, you will learn OpenShift so you are able
    to deploy your services in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[http://wildfly-swarm.io/documentation/](http://wildfly-swarm.io/documentation/)'
  prefs: []
  type: TYPE_NORMAL
