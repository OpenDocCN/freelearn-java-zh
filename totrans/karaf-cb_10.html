<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Testing Apache Karaf with Pax Exam"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Testing Apache Karaf with Pax Exam</h1></div></div></div><p>In this chapter, we will cover the following recipes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up a Pax Exam test environment</li><li class="listitem" style="list-style-type: disc">Testing Apache Karaf features</li><li class="listitem" style="list-style-type: disc">Testing commands with Apache Karaf</li><li class="listitem" style="list-style-type: disc">Coverage with Apache Karaf Pax exam tests</li><li class="listitem" style="list-style-type: disc">Testing Apache Camel with Blueprint and Apache Karaf</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec77"/>Introduction</h1></div></div></div><p>This chapter explains how to set up a test environment for Apache Karaf. As developing OSGi applications for Apache Karaf also needs thorough testing, an environment for integration testing is needed. Pax Exam is a powerful tool for developing integration tests and can be combined with Apache Karaf.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip38"/>Tip</h3><p>More <a id="id664" class="indexterm"/>details about Pax Exam can be found at the OPS4j community website at <a class="ulink" href="https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam">https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam</a>. If help is needed, you can find a working community at <a class="ulink" href="https://groups.google.com/forum/#!forum/ops4j">https://groups.google.com/forum/#!forum/ops4j</a>.</p></div></div></div></div>
<div class="section" title="Setting up a Pax Exam test environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec78"/>Setting up a Pax Exam test environment</h1></div></div></div><p>This<a id="id665" class="indexterm"/> recipe will guide you through the basic setup of a Pax Exam test environment using the Felix framework as the core OSGi container. The next recipe will cover how to combine Pax Exam and Apache Karaf.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec224"/>Getting ready</h2></div></div></div><p>As usual, the sources can be found at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe1</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec225"/>How to do it…</h2></div></div></div><a id="id666" class="indexterm"/><p>To perform integration tests with Pax Exam, the POM configuration is essential, since it is already part of the build environment. For example, use the <code class="literal">pax-exam-container-native</code> artifact and of course it is mandatory to connect JUnit with Pax Exam. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">…
&lt;properties&gt;
  &lt;version.pax-exam&gt;3.4.0&lt;/version.pax-exam&gt;
  &lt;junit.version&gt;4.11&lt;/junit.version&gt;
&lt;/properties&gt;
…
&lt;dependency&gt;
  &lt;groupId&gt;org.ops4j.pax.exam&lt;/groupId&gt;
  &lt;artifactId&gt;pax-exam-junit4&lt;/artifactId&gt;
  &lt;version&gt;${version.pax-exam}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.ops4j.pax.exam&lt;/groupId&gt;
  &lt;artifactId&gt;pax-exam-invoker-junit&lt;/artifactId&gt;
  &lt;version&gt;${version.pax-exam}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.ops4j.pax.exam&lt;/groupId&gt;
  &lt;artifactId&gt;pax-exam-container-native&lt;/artifactId&gt;
  &lt;version&gt;${version.pax-exam}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
…</pre></div><p>Besides this, it is required to define the OSGi framework in which to run this test scenario. This can either be the Felix framework, Equinox, or any other framework available as a Maven dependency.</p><p>Now that we are done with the important parts of the POM configuration, let's focus on the JUnit integration test.</p><p>This <a id="id667" class="indexterm"/>test class only consists of two major methods: the test method itself where we have a minor test setup for the container to work properly, and the far more important method at this point—the configuration. Consider the following code snippet:</p><div class="informalexample"><pre class="programlisting">@ExamReactorStrategy(PerClass.class)
@RunWith(PaxExam.class)
public class TestOsgiServices {

  @Inject
  protected BundleContext bundleContext;

  @Configuration
  public static Option[] configuration() throws Exception {
    return options(
      workingDirectory("target/paxexam/"),
      cleanCaches(true),
      junitBundles(),
      frameworkProperty("osgi.console").value("6666"),
      frameworkProperty("osgi.console.enable.builtin").value("true"),
      frameworkProperty("felix.bootdelegation.implicit").value("false"),
      systemProperty("org.ops4j.pax.logging.DefaultServiceLog.level").value("DEBUG"));
  }

  @Test
  public void test() {
    assertNotNull(bundleContext);
  }
}</pre></div><p>The unit test class needs the <code class="literal">@RunWith(PaxExam.class)</code> annotation to make clear it is a Pax <a id="id668" class="indexterm"/>Exam test. The <code class="literal">@ExamReactorStrategy</code> annotation lets you define a strategy for testing, either <code class="literal">PerClass</code>, <code class="literal">PerMethod</code>, or <code class="literal">PerSuite</code>, where you also need to define the test classes to run with. In our test, it is sufficient to run with the <code class="literal">PerClass</code> strategy as it starts the container only once per class, whereas the <code class="literal">PerMethod</code> strategy starts the test and its setup for each method invocation. The <code class="literal">PerSuite</code> strategy starts and configures the test setup for a suite of tests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>For details <a id="id669" class="indexterm"/>about the test strategies, refer to the Pax Exam documentation at <a class="ulink" href="https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam">https://ops4j1.jira.com/wiki/display/PAXEXAM3/Pax+Exam</a>.</p></div></div><p>A Pax Exam test class always needs a <code class="literal">configuration</code> method annotated with the <code class="literal">@Configuration</code> annotation. This is needed for Pax Exam to know the configuration needed to run the test. For example, it is best to give a <code class="literal">workingDirectory</code> method, otherwise<a id="id670" class="indexterm"/> the working directory is placed in the temporary directory of the system. With the <code class="literal">junitBundles</code> method, the JUnit bundles are included so Pax Exam is capable of running JUnit tests. To run the tests with TestNG, it is required to add the dependencies of TestNG to the <code class="literal">configuration</code> method as follows:</p><div class="informalexample"><pre class="programlisting">mavenBundle("org.testng", "testng", "6.3.1")</pre></div><p>With the <code class="literal">frameworkProperty("osgi.console")</code> property, you're able to add an OSGi console to the test; if you run the test in debug mode, you're able to access this console via port <code class="literal">6666</code>. This completes the basic setup of a Pax Exam test where we already have one test method that checks whether the injected (<code class="literal">@Inject</code>) bundle context is available.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec226"/>How it works…</h2></div></div></div><p>As Pax Exam finds its own modules on the classpath through Maven, it starts the container by itself. This is true for either a Felix or Equinox or any other kind of container supplied to Pax Exam by the POM configuration. Everything else needs to be specified using the <code class="literal">configuration</code> method. If you are using other bundles in your test scenario, you also need to specify their Maven coordinates. It's usually best to specify the version of the bundle in question in your POM configuration, and reuse this version in your configuration. You'll find more on this in the upcoming recipes.</p><p>So how does Pax Exam compare with a standard unit test? While testing on a unit level, maybe even with mocks, the tests are about the unit alone. Integration tests usually cover a wider range or a bigger scope with more units under test. Integration tests might be run as external tests against an externally available API. This is a bit hard if your APIs are services within a container. Pax Exam works with and within the container. The test class will be part of the deployed artifacts. In an OSGi environment, Pax Exam builds a dynamical bundle containing your test class, even with package imports. These bundle manifest headers can also be manipulated by the test; more details are available in the next recipe.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec227"/>There's more…</h2></div></div></div><p>An integration test usually tests an already built artifact, but sometimes it is essential to either alter the artifact or to test not after the artifact is built but when building this artifact. For this scenario, it is possible to build a <span class="emphasis"><em>dynamic</em></span> bundle on the fly by configuring a <code class="literal">streamBundle</code>. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">streamBundle(bundle().add(Calculator.class)
  .add(CalculatorImpl.class)
  .add(CalcActivator.class)
  .set(Constants.BUNDLE_SYMBOLICNAME,"com.packt.IntegrationTest")
  .set(Constants.DYNAMICIMPORT_PACKAGE, "*")
  .set(Constants.BUNDLE_ACTIVATOR, CalcActivator.class.getName())
  .set(Constants.EXPORT_PACKAGE, "com.packt")
  .build()).start());</pre></div><p>This <a id="id671" class="indexterm"/>example shows how to build a dynamic bundle including an activator and exporting the right packages and other manifest header entries. The registered service can be directly imported into the test and used.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>You might also be interested in using Pax Exam with other environments; it also supports Tomcat, Jetty, or JEE servers as backend for the runtime.</p></div></div></div></div>
<div class="section" title="Testing Apache Karaf features"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec79"/>Testing Apache Karaf features</h1></div></div></div><p>After <a id="id672" class="indexterm"/>going through the <span class="emphasis"><em>Setting up a Pax Exam test environment</em></span> recipe, you should be ready to test OSGi applications in general. Now, let's take a closer look at what is needed to run a test with Apache Karaf as the container.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec228"/>Getting ready</h2></div></div></div><p>As in the previous chapters, the sources are available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe2</a>. To fully understand this recipe, it is best to have gone through the previous recipe.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec229"/>How to do it…</h2></div></div></div><p>In the <span class="emphasis"><em>Setting up a Pax Exam test environment</em></span> recipe, we defined the Felix framework as the runtime container. Now, we need to change this to Apache Karaf, so the first changes need to be done to the POM configuration. Pax Exam needs to know that it needs to run with Apache Karaf as the container; this is configured using the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The <code class="literal">pax-exam-container-karaf</code> dependency as a replacement dependency for the Felix framework.</li><li class="listitem">The <code class="literal">apache-karaf</code> ZIP artifact to be used as the runtime container.</li><li class="listitem">The standard features file for installing the standard features.</li></ol></div><p>Consider<a id="id673" class="indexterm"/> the following code:</p><div class="informalexample"><pre class="programlisting">…
&lt;dependency&gt;
  &lt;groupId&gt;org.ops4j.pax.exam&lt;/groupId&gt;
<span class="strong"><strong>  &lt;artifactId&gt;pax-exam-container-karaf&lt;/artifactId&gt;</strong></span>
  &lt;version&gt;${version.pax-exam}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
…
&lt;!-- framework to test with --&gt;
&lt;dependency&gt;
<span class="strong"><strong>  &lt;groupId&gt;org.apache.karaf.features&lt;/groupId&gt;</strong></span>
<span class="strong"><strong>  &lt;artifactId&gt;standard&lt;/artifactId&gt;</strong></span>
<span class="strong"><strong>  &lt;version&gt;${karaf.version}&lt;/version&gt;</strong></span>
<span class="strong"><strong>  &lt;type&gt;xml&lt;/type&gt;</strong></span>
<span class="strong"><strong>  &lt;classifier&gt;features&lt;/classifier&gt;</strong></span>
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.apache.karaf.features&lt;/groupId&gt;
  &lt;artifactId&gt;org.apache.karaf.features.core&lt;/artifactId&gt;
  &lt;version&gt;${karaf.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.apache.karaf.system&lt;/groupId&gt;
  &lt;artifactId&gt;org.apache.karaf.system.core&lt;/artifactId&gt;
  &lt;version&gt;${karaf.version}&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.apache.karaf&lt;/groupId&gt;
<span class="strong"><strong>  &lt;artifactId&gt;apache-karaf&lt;/artifactId&gt;</strong></span>
  &lt;version&gt;${karaf.version}&lt;/version&gt;
  &lt;type&gt;zip&lt;/type&gt;
  &lt;scope&gt;test&lt;/scope&gt;
  &lt;exclusions&gt;
    &lt;exclusion&gt;
      &lt;groupId&gt;org.apache.karaf.shell&lt;/groupId&gt;
      &lt;artifactId&gt;org.apache.karaf.shell.dev&lt;/artifactId&gt;
    &lt;/exclusion&gt;
  &lt;/exclusions&gt;
&lt;/dependency&gt;
…</pre></div><p>After<a id="id674" class="indexterm"/> these changes are made to the POM configuration, the test itself needs to be reconfigured as follows:</p><div class="informalexample"><pre class="programlisting">@ExamReactorStrategy(PerClass.class)
@RunWith(PaxExam.class)
public class IntegrationTestKaraf {

  @Inject
  protected BundleContext bundleContext;
  
  @Inject
  protected FeaturesService featuresService;

  @Configuration
  public static Option[] configuration() throws Exception {
    return new Option[] {
      karafDistributionConfiguration().frameworkUrl(maven().groupId("org.apache.karaf").artifactId("apache-karaf").type("zip").versionAsInProject()).unpackDirectory(new File("target/paxexam/unpack/")).useDeployFolder(false),configureConsole().ignoreLocalConsole(),logLevel(LogLevel.INFO),keepRuntimeFolder(),features(maven().groupId("org.apache.karaf.features").artifactId("standard").type("xml").classifier("features").versionAsInProject(),"eventadmin")
    };
  }

  @Test
  public void test() {
    assertNotNull(bundleContext);
  }

  @Test
  public void featuresAvailable() throws Exception {
    assertTrue(featuresService.isInstalled(featuresService.getFeature("eventadmin")));
  }

}</pre></div><p>The first major change should jump out at you right away: the Apache Karaf configuration, which has the <code class="literal">karafDistributionConfiguration</code> function with the Maven coordinates to an Apache Karaf ZIP file. As it is already defined in the POM configuration, the <code class="literal">versionAsInProject()</code> configuration can be used. Besides this, a feature is installed right <a id="id675" class="indexterm"/>away from the configuration and is available as soon as the container is up and running. The tests make sure the expected feature is installed.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec230"/>How it works…</h2></div></div></div><p>Pax Exam uses Karaf as container instead of a given OSGi framework. Some extra configuration is needed because the container is assembled as a ZIP file and needs to be unwrapped first. After this is done, the Apache Karaf container is started at the given location with the configured constraints, for example, to turn off the <code class="literal">Deploy</code> folder. The <code class="literal">versionAsInProject()</code> configuration needs some extra handling. For this to work, you need to make sure a Maven dependency file is generated. This can be done by configuring <code class="literal">depends-maven-plugin</code> from the ServiceMix project. This will generate a file containing all dependency information contained in the POM configuration readable by Pax Exam. Consider the following code:</p><div class="informalexample"><pre class="programlisting">&lt;plugin&gt;
  &lt;groupId&gt;org.apache.servicemix.tooling&lt;/groupId&gt;
  &lt;artifactId&gt;depends-maven-plugin&lt;/artifactId&gt;
  &lt;version&gt;1.2&lt;/version&gt;
  &lt;executions&gt;
    &lt;execution&gt;
      &lt;id&gt;generate-depends-file&lt;/id&gt;
      &lt;phase&gt;generate-resources&lt;/phase&gt;
      &lt;goals&gt;
        &lt;goal&gt;generate-depends-file&lt;/goal&gt;
      &lt;/goals&gt;
    &lt;/execution&gt;
  &lt;/executions&gt;
&lt;/plugin&gt;</pre></div><p>With these configurations done, your tests are set. In the given test sample, we used an internal feature descriptor; if you want to test any other kind of custom feature, you just need to add it to the configuration and tell it which feature should be deployed. In the previous sample, it is the <code class="literal">eventadmin</code> feature.</p><p>Besides the already known simple injection of the <code class="literal">bundlecontext</code> object, it is also possible to inject any kind of service to the test that is available in the container. In the previous <a id="id676" class="indexterm"/>sample, we injected <code class="literal">featuresService</code>.</p></div></div>
<div class="section" title="Testing commands with Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>Testing commands with Apache Karaf</h1></div></div></div><p>After <a id="id677" class="indexterm"/>you've gone through the first two recipes, you <a id="id678" class="indexterm"/>should be set for thorough testing of OSGi bundles, either standalone or in Apache Karaf. When working with Apache Karaf, it is sometimes necessary to also have new commands. This recipe will cover how to test with commands and make sure these commands are executed inside the Apache Karaf shell.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec231"/>Getting ready</h2></div></div></div><p>It's best to have gone through the <span class="emphasis"><em>Testing Apache Karaf features</em></span> recipe before starting this recipe, as this one is a follow up. The sources can be found at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe3</a>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec232"/>How to do it...</h2></div></div></div><p>To test the execution of an Apache Karaf shell command, you need to tweak the test class. First, you need to alter the way the test is run. For this, we add the probe builder which configures the way the test bundle is built. Consider the following code:</p><div class="informalexample"><pre class="programlisting">@ProbeBuilder
public TestProbeBuilder probeConfiguration(TestProbeBuilder probe) {
  //make sure the needed imports are there. 
  probe.setHeader(Constants.DYNAMICIMPORT_PACKAGE, "*,org.apache.felix.service.*;status=provisional");
  return probe;
}</pre></div><p>The following lines of code make sure the injection for the <code class="literal">CommandProcessor</code> interface works properly:</p><div class="informalexample"><pre class="programlisting">@Inject
protected CommandProcessor commandProcessor;</pre></div><p>For the actual testing of commands, we add a convenience method that sends the command to the Karaf shell and receives the output from it. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">protected String executeCommand(final String command) {
  String response;
  final ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
  final PrintStream printStream = new PrintStream(byteArrayOutputStream);
  final CommandSession commandSession = commandProcessor.createSession(System.in, printStream, System.err);
  FutureTask&lt;String&gt; commandFuture = new FutureTask&lt;String&gt;(
    new Callable&lt;String&gt;() {
      public String call() {
        try {
          System.err.println(command);
          commandSession.execute(command);
        } catch (Exception e) {
          e.printStackTrace(System.err);
        }
        printStream.flush();
        return byteArrayOutputStream.toString();
      }
    });

  try {
    executor.submit(commandFuture);
    response = commandFuture.get(10000L, TimeUnit.MILLISECONDS);
  } catch (Exception e) {
    e.printStackTrace(System.err);
    response = "SHELL COMMAND TIMED OUT: ";
  }

  return response;
}</pre></div><p>This string containing the response is testable for the expected output.</p></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec233"/>How it works…</h2></div></div></div><p>The<a id="id679" class="indexterm"/> essential part of this test is the addition <a id="id680" class="indexterm"/>of the <code class="literal">ProbeBuilder</code> annotation. The <a id="id681" class="indexterm"/>
<code class="literal">ProbeBuilder</code> annotation alters the way the bundle containing the test class is built. In our case, it alters the <code class="literal">Package-Import</code> header of the generated bundle. It is not only possible to alter or add manifest headers, but also to add additional classes or test classes.</p></div></div>
<div class="section" title="Coverage with Apache Karaf Pax Exam tests"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec81"/>Coverage with Apache Karaf Pax Exam tests</h1></div></div></div><p>Apart <a id="id682" class="indexterm"/>from testing the application, it is usually also a requirement to know how well the unit and integration tests actually cover the code. For code coverage, a couple of technologies are available. This recipe will cover how to set up your test environment to find the coverage of the test.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec234"/>Getting ready</h2></div></div></div><p>It's best to have gone through the <span class="emphasis"><em>Testing Apache Karaf features</em></span> recipe before starting this follow-up recipe. The sources of this recipe are available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe4</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec235"/>How to do it…</h2></div></div></div><p>To find out about the coverage of the test, a code coverage tool is needed. We will take the Java Code Coverage Library as it has a Maven plugin for automated coverage analysis. At first, the Maven coordinates for the plugin are added as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;groupId&gt;org.jacoco&lt;/groupId&gt;
&lt;artifactId&gt;jacoco-maven-plugin&lt;/artifactId&gt;
&lt;version&gt;0.7.0.201403182114&lt;/version&gt;</pre></div><p>We need to prepare the code first so it can be covered by the agent as follows:</p><div class="informalexample"><pre class="programlisting">&lt;execution&gt;
  &lt;id&gt;prepare-agent-integration&lt;/id&gt;
  &lt;goals&gt;
<span class="strong"><strong>    &lt;goal&gt;prepare-agent-integration&lt;/goal&gt;</strong></span>
  &lt;/goals&gt;
  &lt;phase&gt;pre-integration-test&lt;/phase&gt;
  &lt;configuration&gt;
    &lt;propertyName&gt;jcoverage.command&lt;/propertyName&gt;
    &lt;includes&gt;
      &lt;include&gt;com.packt.*&lt;/include&gt;
    &lt;/includes&gt;
    &lt;append&gt;true&lt;/append&gt;
  &lt;/configuration&gt;
&lt;/execution&gt;</pre></div><p>This will include the <code class="literal">com.packt</code> package, including subpackages. After the integration tests are done, the test report needs to be generated as follows:</p><div class="informalexample"><pre class="programlisting">&lt;execution&gt;
  &lt;id&gt;report&lt;/id&gt;
  &lt;goals&gt;
    &lt;goal&gt;report-integration&lt;/goal&gt;
  &lt;/goals&gt;
&lt;/execution&gt;</pre></div><p>Besides <a id="id683" class="indexterm"/>these additions to the POM configuration, you need to add the VM options to the configuration of the Apache Karaf test. Without setting these options to the virtual machine, which executes the test, the executing environment doesn't know of the coverage and, therefore, no coverage is done. This can be done as follows:</p><div class="informalexample"><pre class="programlisting">private static Option addCodeCoverageOption() {
  String coverageCommand = System.getProperty(COVERAGE_COMMAND);
  if (coverageCommand != null) {
    return CoreOptions.vmOption(coverageCommand);
  }
  return null;
}</pre></div><p>The resulting report of this coverage looks like the following screenshot. It shows the coverage of the <code class="literal">CalculatorImpl</code> class and its methods. While the <code class="literal">add</code> method has been called by the test, the <code class="literal">sub</code> method wasn't. This results in zero coverage for that method.</p><div class="mediaobject"><img src="graphics/5081OS_10_01.png.jpg" alt="How to do it…"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec236"/>How it works…</h2></div></div></div><p>First, you need to prepare the agent for covering, this will be inserted into the <code class="literal">jcoverage.command</code> property. This property is passed to the test by adding the <code class="literal">vmOption</code> directory. This way the coverage agent is added to the Java Virtual Machine and it tracks the coverage of the test execution. After the test is run successfully, the report is generated by the <code class="literal">jacoco-maven-plugin</code>. All of this works fine with a single Maven module. A multimodule project setup will require additional work, especially if you want to combine unit and integration test coverage. More details can be found at <a class="ulink" href="http://www.eclemma.org/jacoco/index.html">http://www.eclemma.org/jacoco/index.html</a>.</p></div></div>
<div class="section" title="Testing Apache Camel with Blueprint and Apache Karaf"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec82"/>Testing Apache Camel with Blueprint and Apache Karaf</h1></div></div></div><p>This <a id="id684" class="indexterm"/>recipe will cover how to test a Camel Blueprint <a id="id685" class="indexterm"/>definition. The focus of this recipe<a id="id686" class="indexterm"/> will be on the test and how it differs from<a id="id687" class="indexterm"/> the <span class="emphasis"><em>Testing Apache Karaf features</em></span> recipe.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec237"/>Getting ready</h2></div></div></div><p>It's best to have gone through the <span class="emphasis"><em>Testing Apache Karaf features</em></span> recipe and the <span class="emphasis"><em>Creating a Blueprint-based Camel Router for deployment in Apache Karaf</em></span> recipe before starting this follow-up recipe. The sources of this chapter are available at <a class="ulink" href="https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5">https://github.com/jgoodyear/ApacheKarafCookbook/tree/master/chapter10/chapter10-recipe5</a>.</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec238"/>How to do it…</h2></div></div></div><p>Since we have based this recipe on the <span class="emphasis"><em>Testing Apache Karaf features</em></span> recipe, we already have a basic setup containing the setup of the Apache Karaf container. Additionally, we need the Apache Camel feature for Karaf. This way all the bundles required for testing a Camel route are present. The test itself requires the Camel Context of the <code class="literal">blueprint.xml</code> definition to attach itself to its mock object. This can be done as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">The test class itself inherits from the <code class="literal">CamelTestSupport</code> class for easier testing of Camel:<div class="informalexample"><pre class="programlisting">…
@RunWith(PaxExam.class)
public class TestCamelInKaraf extends CamelTestSupport {

  @Inject
  protected FeaturesService featuresService;

  @Inject
  protected BundleContext bundleContext;

  @Inject
  @Filter(value="(camel.context.name=blueprintContext)", timeout=10000)
  protected CamelContext testContext;
…</pre></div><p>To have access to the mock contained in the Camel route, we make sure the Camel Context is injected. The <code class="literal">@Filter</code> annotation makes sure only the desired Camel Context is injected within the given timeout.</p></li><li class="listitem">The<a id="id688" class="indexterm"/> configuration contains the<a id="id689" class="indexterm"/> targeted Karaf runtime <a id="id690" class="indexterm"/>and installs the required <code class="literal">camel-blueprint</code> and <code class="literal">camel-test</code> features as shown in the following <a id="id691" class="indexterm"/>code:<div class="informalexample"><pre class="programlisting">@Configuration
public static Option[] configure() throws Exception {
  return new Option[] {
  karafDistributionConfiguration().frameworkUrl(
  maven().groupId("org.apache.karaf")
.artifactId("apache-karaf")
.type("zip").versionAsInProject()).useDeployFolder(false)
.karafVersion("3.0.1")
  .unpackDirectory(new File("target/paxexam/unpack/")),
  logLevel(LogLevel.WARN),
  features(
maven().groupId("org.apache.camel.karaf")
.artifactId("apache-camel").type("xml")
.classifier("features")
.versionAsInProject(), 
"camel-blueprint", "camel-test"),keepRuntimeFolder(),
  streamBundle(
    bundle().add(HelloBean.class)
  .add("OSGI-INF/blueprint/blueprint.xml",
  new File("src/main/resources/OSGI-INF/blueprint/blueprint.xml")
  .toURL())
.set(Constants.BUNDLE_SYMBOLICNAME, "com.packt.camel-test")
  .set(Constants.DYNAMICIMPORT_PACKAGE, "*").build())
  .start() };
}</pre></div></li><li class="listitem">Additionally, the <code class="literal">HelloBean</code> class and <code class="literal">blueprint.xml</code> file are wrapped up in a streamed bundle so the test is runnable inside the same module. As the last specialty to the test, we make sure the Camel Context is only created once per class creation. This can be done as follows:<div class="informalexample"><pre class="programlisting">@Override
public boolean isCreateCamelContextPerClass() {
  return true;
}</pre></div><p>This completes the setup for testing a Camel route with Pax Exam inside the Karaf container.</p></li><li class="listitem">In the <code class="literal">Test</code> method, we make sure that the required features are installed, the Camel <a id="id692" class="indexterm"/>Context has been injected, and<a id="id693" class="indexterm"/> that the mock<a id="id694" class="indexterm"/> is satisfied. Consider the <a id="id695" class="indexterm"/>following code:<div class="informalexample"><pre class="programlisting">@Test
public void test() throws Exception {
  assertTrue(featuresService.isInstalled(featuresService.getFeature("camel-core")));
  assertTrue(featuresService.isInstalled(featuresService.getFeature("camel-blueprint")));

  assertNotNull(testContext);

  MockEndpoint mockEndpoint = (MockEndpoint) testContext.getEndpoint("mock:result");
  mockEndpoint.expectedMessageCount(1);

  assertMockEndpointsSatisfied(10000l, TimeUnit.MILLISECONDS);

}</pre></div></li></ol></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec239"/>How it works…</h2></div></div></div><p>As in the previous recipes, Pax Exam makes sure Apache Karaf is run as the basic container. With the feature configuration inside the <code class="literal">@Configuration</code> method, we install the <code class="literal">camel-blueprint</code> and <code class="literal">camel-test</code> features. The test makes sure those features are indeed installed and running. To verify that the <code class="literal">HelloBean</code> class has actually sent a message to the mock endpoint, the test gets the mock endpoint from the injected Camel Context and expects at least a message count of one. Pax Exam injects the Camel Context used by the <code class="literal">blueprint.xml</code> file into the test class. To make sure it is the context that is actually needed, the <code class="literal">@Filter</code> annotation given with the LDAP filter syntax for OSGi services is used. While the <code class="literal">blueprint.xml</code> file containing the Camel Context is started, the Camel Context itself is registered as a service in the OSGi registry with the Camel Context ID registered as the <code class="literal">camel.context.name</code> property.</p><p>Because of the inheritance and the overridden <code class="literal">isCreateCamelContextPerClass</code> method, the Camel Context is only created once during the test execution. This is essential for running the Camel tests with Pax Exam because the container is only created once in the test. Otherwise, the Camel Context would be created a couple of times resulting in various errors.</p><p>To assert the successful execution of the test and to verify the expected message count, you are required to call the <code class="literal">assertIsSatisfied</code> method on the mock instead of calling the <code class="literal">assertMockEndpointsSatisfied</code> method. The latter method asserts all mock endpoints of the Camel Context bound to the test itself, while the former one asserts the mock that is contained in the Camel Context created by the Blueprint handler.</p></div></div></body></html>