- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding Quarkus to a Modularized Hexagonal Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will expand our horizons by exploring the concepts and technologies
    to turn our hexagonal application into a cloud-native one. To support us in our
    journey to the cloud, we have Quarkus as the key technology, which is a prominent
    Java cloud-native framework. To understand Quarkus and learn how to leverage its
    features to enhance a hexagonal system, we need to revisit some fundamental knowledge
    related to the inner workings of the **Java Virtual Machine** (**JVM**). By understanding
    the main JVM characteristics and how they work, we can better understand the problems
    Quarkus aims to solve.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll also conduct a brief tour of Quarkus’s main features
    to get an idea of what we can do with such a fine piece of software. Once we’re
    acquainted with Quarkus, we’ll take our first step in transforming our hexagonal
    system into a cloud-native one. To accomplish that, we’ll create a brand-new Java
    module and configure Quarkus dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the topics that we’ll cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the JVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Quarkus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Quarkus to a modularized hexagonal application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know how to configure Quarkus to work with
    a hexagonal application. That’s the first step in preparing a system to receive
    all the cloud-native features that Quarkus has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java Standard Edition (SE) Development Kit** and **Maven 3.8** installed
    on your computer. They are all available for Linux, Mac, and Windows operating
    systems. You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10).
  prefs: []
  type: TYPE_NORMAL
- en: Revisiting the JVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Virtual Machine** (**VM**) concept wasn’t something new when Java arrived
    back in 1995\. Before that time, many other languages used VMs, although they
    weren’t so popular among developers. Java architects decided to use VMs because
    they wanted a mechanism to create platform independence to improve developer productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Before elaborating on the VM concept, let’s first check what we can run inside
    a VM for Java. In languages such as C or C++, we compile source code into native
    code tailored for a specific operating system and CPU architecture. When programming
    in Java, we compile the source code into bytecode. The JVM understands the instructions
    contained in bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: The VM idea comes from the concept of running programs in an intermediate or
    virtual environment sitting atop a real machine. In such an arrangement, the program
    does not need to communicate directly with the underlying operating system – the
    program deals only with a VM. The VM then converts bytecode instructions into
    native-code ones.
  prefs: []
  type: TYPE_NORMAL
- en: We can express one of the JVM’s advantages with a well-known Java motto – *write
    once, run anywhere*. Back in the day, and I think even now, it was very appealing
    to use a language that allowed you to develop software that, without recompilation,
    could run on different operating systems and CPU architectures. For other languages
    such as C++, you’d need to adjust your code for every targeted operating system
    and CPU architecture, prompting more effort to make your program compatible with
    different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: In today’s world of cloud computing, we have services such as Docker and Kubernetes
    that make software units more portable than ever. To achieve portability in Java,
    we have the prerogative to execute the same compiled bytecode into different JVMs
    running on different operating systems and CPU architectures. Portability is possible
    because every JVM implementation must comply with the JVM specification, no matter
    where or how it’s implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, we can use container virtualization to achieve portability by packing
    the compiled software with its runtime environment and dependencies into a container
    image. A container engine running on different operating systems and CPU architectures
    can create containers based on container images.
  prefs: []
  type: TYPE_NORMAL
- en: The JVM’s appeal in making portable software at the expense of converting bytecode
    into native code is no longer attractive when you have faster and cheaper alternatives.
    Today, you can pack your application – without the need for a JVM and also recompilation
    – into a Docker image and distribute it across different operating systems and
    CPU architectures. However, we should not forget how robust and time-tested a
    piece of software such as the JVM is. We’ll return to our discussion on Docker
    and Kubernetes soon, but for now, let’s examine some more interesting JVM characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: Another important JVM aspect is related to memory management. With Java, a developer
    doesn’t need to worry about how the program deals with memory release and allocation.
    Such responsibility is transferred to the JVM, so the developer can focus more
    on their program’s functional details than on the technical ones. Ask any C++
    developer how much fun it is to debug memory leaks on large systems.
  prefs: []
  type: TYPE_NORMAL
- en: The feature responsible for managing memory inside the JVM is called a **garbage
    collector**. Its purpose is to automatically check when an object is no longer
    used or referenced so that the program can free the unused memory. A JVM can use
    algorithms that trace object references and mark for releasing those that no longer
    reference any object. Different garbage collector algorithms exist, such as the
    **Concurrent Mark and Sweep** (**CMS**) and the **Garbage First Garbage Collector**
    (**G1 GC**). Since the JDK7 Update 4, the G1 GC has superseded the CMS due to
    its emphasis on first identifying and releasing the mostly empty Java object heap
    regions, making more memory available, and doing it faster than the CMS approach.
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collectors are not required to exist in every JVM implementation, but
    as long as memory resources remain a constraint in computation, we’ll often see
    JVM implementations with garbage collectors.
  prefs: []
  type: TYPE_NORMAL
- en: JVM is also in charge of the whole life cycle of an application. It all starts
    with the loading of a Java class file into the VM. When we compile a Java source
    file, the compiler generates a Java class file containing bytecode. Bytecode is
    a format recognizable by the JVM. A VM’s primary goal is to load and process this
    bytecode through algorithms and data structures that implement and respect a JVM
    specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates what it takes to execute a Java program:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Java compilation and class loading on JVM](img/B19777_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – Java compilation and class loading on JVM
  prefs: []
  type: TYPE_NORMAL
- en: It all starts with the Java source code file that is compiled into a Java class
    file (bytecode) by the Java compiler. This bytecode is read by the JVM and translated
    into instructions that are understood by the **native OS**.
  prefs: []
  type: TYPE_NORMAL
- en: This bytecode thing has been an object of relentless work for people trying
    to find faster ways to deal with it.
  prefs: []
  type: TYPE_NORMAL
- en: As time went on, the JVM received good improvements and enhanced techniques
    that considerably improved the bytecode loading performance. Among these techniques,
    we can quote **Just-in-Time** (**JIT**) and **Ahead-of-Time** (**AOT**) compilations.
    Let’s examine both of them.
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up runtime performance with JIT compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JIT compilers** arose from the idea that certain program instructions can
    be optimized for better performance while a program is running. So, to accomplish
    such optimization, the JIT compiler seeks program instructions with the potential
    to be optimized. In general, these instructions are the ones most executed by
    the program.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because these instructions are executed so often, they consume a significant
    amount of computer time and resources. Remember that these instructions are in
    the bytecode format. A traditional compiler would compile all the bytecode into
    native code before running the program. With a JIT compiler, things are different,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – How JIT works](img/B19777_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – How JIT works
  prefs: []
  type: TYPE_NORMAL
- en: A JIT compiler selects, by using its dynamic optimization algorithms, some parts
    of the bytecode. Then, it compiles and applies optimizations to these bytecode
    parts. The result is optimized native code that is tweaked to provide better performance
    for the system. The term *JIT* is used because the optimizations are made right
    before the code is executed.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is no such thing as a free lunch when using JIT compilers. One
    of the most well-known drawbacks of JIT compilers is the increased startup time
    of an application because of the initial optimizations a JIT compiler does before
    running the program. In order to overcome this startup problem, there is another
    technique called AOT compilation. Various cloud-native frameworks, including Quarkus,
    have used this technique. Let’s see how AOT compilation works.
  prefs: []
  type: TYPE_NORMAL
- en: Improving startup time with AOT compilation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AOT** is so appealing on the Java scene because traditional Java systems
    – mainly those based on enterprise application servers such as **JBoss** and **WebLogic**
    – take too much time to initiate. In addition to slower startup times, we have
    to consider the amount of computer power those application servers consume. These
    characteristics are a deal-breaker for anyone who wants to migrate Java workloads
    to the cloud, where instances and Kubernetes Pods are brought up and down frantically.
    So, by employing AOT in Java, we give up the cross-platform capability provided
    by the JVM and its bytecode for a better performance provided by AOT and its native
    code. The cross-platform problem is mitigated to some extent with the usage of
    container technologies such as Docker and Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have a representation showing how straightforward the AOT compilation
    process is to transform Java bytecode into **m****achine code**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – How AOT works](img/B19777_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.3 – How AOT works
  prefs: []
  type: TYPE_NORMAL
- en: Not everything is an advantage with AOT in Java. An AOT compiler spends more
    time generating a native binary than a Java compiler needs to create bytecode
    classes. So, AOT compilation can have a considerable impact on **Continuos Integration**
    (**CI**) pipelines. Also, the developer needs to do some additional work to get
    things working properly to use reflection. **GraalVM** is the AOT compiler used
    to provide a native binary for Java and other JVM-based languages.
  prefs: []
  type: TYPE_NORMAL
- en: With Quarkus, we have the prerogative to create applications using either JIT
    or AOT compilation methods. It’s up to us to decide which technique suits our
    needs better.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we gained some background knowledge about the inner workings
    of the JVM and how it tries to improve bytecode loading with JIT and AOT compilation.
    Such knowledge is important to understand how Quarkus works under the hood and
    achieves considerable performance improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are acquainted with some JVM fundamentals and essential compilation
    techniques, let’s dive in and learn more about Quarkus’ main features.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you develop enterprise Java applications, you have already worked with Spring
    Boot. Time-tested and widely used in the industry, Spring Boot is a robust piece
    of software with a vibrant community. Its libraries increase developed productivity
    by providing out-of-the-box solutions for security, persistence, APIs, and many
    more things that a typical enterprise application requires. You may wonder why
    this book does not discuss Spring Boot but Quarkus. There are two reasons. First,
    more material is available covering Spring Boot than Quarkus, which is understandable,
    as Spring Boot has been around longer and has a bigger community. The second reason
    is that Quarkus was built with cloud-native development at its core, while Spring
    Boot has been adapted to it. And since this book focuses on cloud-native development
    with hexagonal architecture, Quarkus was chosen because it is a cloud-first framework.
  prefs: []
  type: TYPE_NORMAL
- en: Focused on performance, Quarkus comes with built-in support for native executables
    based on GraalVM, making it possible to achieve swift startup times.
  prefs: []
  type: TYPE_NORMAL
- en: To attract developers, it offers valuable things such as live development, a
    feature that enhances productivity by avoiding the need to restart an application
    whenever something changes in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Targeting cloud-native environments, Quarkus comes equipped with the proper
    tooling, allowing you to deal with constraints and leverage the benefits that
    come when developing software to run on container-based environments, such as
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Borrowing good ideas from enterprise development, Quarkus is built on top of
    well-established standards such as the **Contexts and Dependency Injection** (**CDI**)
    framework, the **Jakarta Persistence API** (**JPA**) specification with Hibernate
    ORM implementation, and the **Jakarta RESTful Web Services** (**JAX-RS**) specification
    implemented by RESTEasy. For those immersed in the Java **Enterprise Edition**
    (**EE**) world, this means the learning curve to master Quarkus is shallow because
    much of their already acquired enterprise development knowledge can be reused
    to develop Quarkus applications.
  prefs: []
  type: TYPE_NORMAL
- en: Created by Red Hat, Quarkus sets itself apart from its competitors by being
    a software development framework designed from scratch to deal with cloud technologies.
    Contrary to other more aged frameworks that bring boilerplate code and features
    from an older era, Quarkus presents itself as a fresh and modern piece of software.
  prefs: []
  type: TYPE_NORMAL
- en: Built upon other well-established open source projects, Quarkus is the cloud-native
    framework we’ll use to prepare our hexagonal system for the cloud. Before that,
    though, we’ll explore some of the main features this framework provides. Let’s
    get started by looking first at how to create REST endpoints with Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: Creating REST endpoints with JAX-RS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s very straightforward to create REST endpoints using Quarkus. In order
    to do so, the framework relies on a JAX-RS implementation called RESTEasy. This
    implementation is available in the following Maven dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the following example, which shows how to use RESTEasy to create REST
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We set the endpoint address with the `@Path` annotation. With `@GET`, we set
    the HTTP method supported by that endpoint. With `@Produces`, we define the return
    type for the request.
  prefs: []
  type: TYPE_NORMAL
- en: In this same `RestExample` class, we can inject dependencies to be used together
    with the REST endpoints. Let’s see how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Employing dependency injection with Quarkus DI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quarkus has its own dependency injection mechanism based on **Quarkus ArC**,
    which, in turn, comes from the CDI specification, which has its roots back in
    **Java EE 6**. With CDI, we no longer need to control the creation and life cycle
    of dependency objects we provide to a system. Without a dependency injection framework,
    you have to create objects this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When using CDI, you just have to annotate the `class` attribute with the `@Inject`
    annotation, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `@Inject` annotation to work, we first need to declare the dependency
    as a managed bean. Take a look at the example here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `@ApplicationScoped` annotation states that this bean will be available
    as long as the application is not terminated. Also, this bean is accessible from
    different requests and calls across the entire system. Let’s update our `RestExample`
    to inject this bean, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Right at the top, we inject the `BeanExample` dependency with the `@Inject`
    annotation. Then, we call the `simpleBean` method from the injected `BeanExample`
    dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s see how to validate objects that are created when the system receives
    an HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: Validating objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We learned how to create REST endpoints and also how to inject dependencies
    in the application. *But how about object validation?* *How can we ensure that
    the data provided by a given request is valid?* Quarkus can help us in that matter.
    The Quarkus validation mechanism is available in the following Maven dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The Quarkus validation mechanism is based on **Hibernate Validator**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see how it works, let’s first create a sample object containing the fields
    we expect in a request, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `@NotBlank` annotation, we state that the `field` variable should
    never be empty. Then, by using the `@Min` annotation, we ensure that the `value`
    variable should always contain a number equal to or higher than `10`. Let’s return
    to the `RestExample` class and create a new REST endpoint to validate the request,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: When `ConstraintViolationException` is caught, the system returns an `HTTP 400
    Bad Request` failure response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the `@Valid` annotation just before `SampleObject`. By using that annotation,
    we trigger a validation check whenever a request hits the `/app/request-validation`
    endpoint. Check out the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the previous `POST` request, the field is empty, which results in a failure
    response with an `HTTP 400 Bad` `Request` code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next request, we set `value` to a number less than `10`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, the constraint was violated, and the result showed that the validation
    had failed. The failure was caused because we sent the number `9`, and the minimum
    value accepted is `10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a proper request with valid data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `field` parameter is not `null`, nor is `value` less than `10`. So, the
    request returns a valid response.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a data source and using Hibernate ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quarkus allows you to connect to a data source in two ways. The first and traditional
    way is based on a JDBC connection. To connect using this method, you need the
    `agroal` library and the JDBC driver of the specific database type you want to
    connect. The second – and reactive – way allows you to treat the database connection
    like a stream of data. For that mode, you need `Vert.x` reactive drivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following steps, we’ll set up a data source connection using the traditional
    JDBC method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, we need the following dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`quarkus-hibernate-orm` refers to the Hibernate ORM implementation of JPA.
    It is this dependency that provides the capability to map Java objects to database
    entities.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to configure the data source settings in the `application.properties`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`quarkus.datasource.db-kind` is optional, but we use that to emphasize that
    the application uses an H2 in-memory database. We use `quarkus.datasource.jdbc.url`
    to inform the connection string. The `quarkus.hibernate-orm.dialect` option sets
    the dialect used for the data source communication, and `quarkus.hibernate-orm.database.generation=drop-and-create`
    forces the creation of a database structure at startup.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If there is an `import.sql` file in `classpath`, this `drop-and-create` option
    enables the use of that file to load data into the database. Something very interesting
    about this `drop-and-create` option is that every change on application entities
    or in the `import.sql` file is picked automatically and applied to the database
    without restarting the system. For this to work, a system needs to run in live
    development mode.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let’s create a `SampleEntity` class to persist in the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `SampleEntity` class corresponds to the `SampleObject` class we created
    earlier. The requirement to use the `SampleEntity` class as a database entity
    is to annotate it with the `@Entity` annotation. Following that annotation, we
    have `@NamedQuery`, which we’ll use later to retrieve all entities from the database.
    To automatically generate ID values, we will use `GenerationType.AUTO`. The `field`
    and `value` variables from `SampleEntity` are mapped to the same variables that
    exist in the `SampleObject` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create a new bean called `PersistenceExample` to assist us in creating
    and retrieving database entities. Here’s how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To interact with the database, the first thing we have to do is to inject `EntityManager`.
    Quarkus will take care of retrieving an `EntityManager` object with all the database
    connection settings we provided in the `application.properties` file. Continuing
    the `PersistenceExample` implementation, let’s create a method to persist entities,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `createEntity` method persists an entity in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@Transactional` annotation above the method declaration will make the
    `EntityManager` object flush the transaction once the database operation is committed.
    This is illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `getAllEntities` method retrieves all entities from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s return to `RestExample` to create REST endpoints to trigger the
    creation and retrieval of database entities. We will start by injecting `PersistenceExample`
    so that we can use this bean to begin operations on the database. The code is
    illustrated in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a `/create-entity` endpoint, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We pass `SampleObject` as the parameter. This object represents the body of
    the `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we create a `/get-all-entities` endpoint to retrieve all entities
    from the database, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `retrieveAllEntities` method calls on `getAllEntities` from the `PersistenceExample`
    bean. The result is a list of `SampleEntity` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see what we get when we hit `/create-entity` to create a new entity.
    You can see the output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the entities we’ve created, we send a request to `/get-all-entities`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As expected, we received all the entities we persisted previously in the database
    in a JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: Quarkus is a vast and continuously growing framework that’s absorbing more and
    more capabilities. The features we have seen cover some of the basic things required
    to develop modern applications.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be able to use RESTEasy when reimplementing input adapters to support
    REST on our hexagonal application. Quarkus DI will enable us to better manage
    the life cycle of objects from the Framework and Application hexagons. The Quarkus
    validation mechanisms will contribute to validating the data entering the hexagonal
    system. The data source configuration and Hibernate ORM will support the restructuring
    of output adapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to tweak the `application.properties` file to
    configure a database connection on Quarkus, and we briefly explored Hibernate’s
    ORM capabilities that help map Java classes to database entities. We’ll explore
    this subject further in [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting
    Data with Output Adapters and* *Hibernate Reactive*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now see how to integrate Quarkus into the hexagonal system.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Quarkus to a modularized hexagonal application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To recap, we structured the topology and inventory system in three modularized
    hexagons: **Domain**, **Application**, and **Framework**. A question that may
    arise is, *which module should be responsible for starting the Quarkus engine?*
    Well, to avoid blurring the responsibilities of each module in the topology and
    inventory system, we’ll create a dedicated module whose sole purpose is to aggregate
    the other hexagonal system modules and bootstrap the Quarkus engine. We will name
    this new module **Bootstrap**, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – The Bootstrap aggregator module](img/B19777_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.4 – The Bootstrap aggregator module
  prefs: []
  type: TYPE_NORMAL
- en: The `bootstrap` module is an aggregator module that provides, from one side,
    the dependencies required to initialize Quarkus and, from the other side, the
    `hexagonal` module dependencies for use in conjunction with Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this new `bootstrap` module in the topology and inventory system,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Maven root project of the topology and inventory system, you can execute
    the following Maven command to create this `bootstrap` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 10.5 – The topology and inventory high-level directory structure](img/B19777_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.5 – The topology and inventory high-level directory structure
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to set up Quarkus dependencies in the project’s root `pom.xml`
    file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `quarkus-universe-bom` dependency makes all the Quarkus extensions available.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Because we’re working with a multi-module application, we need to configure
    Quarkus to discover CDI beans in different modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, we need to configure `jandex-maven-plugin` in the Maven project’s root
    `pom.xml` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Without the preceding plugin, we’d have a problem setting up and using CDI beans
    on both the Framework and Application hexagons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now comes the most crucial part – the configuration of `quarkus-maven-plugin`.
    To make the `bootstrap` module the one that will start the Quarkus engine, we
    need to configure `quarkus-maven-plugin` in that module properly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is how we should configure `quarkus-maven-plugin` on `bootstrap/pom.xml`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The important part here is the line containing `<goal>build</goal>`. By setting
    this build goal for the `bootstrap` module, we make this module responsible for
    starting the Quarkus engine.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we need to add the Maven dependencies from the topology and inventory
    system’s hexagons. We do that in the `bootstrap/pom.xml` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, we create a `module-info.java` Java module descriptor with the
    `requires` directives for Quarkus and the topology and inventory hexagon modules,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To aggregate the three hexagon modules into one deployment unit, we’ll configure
    Quarkus to generate an uber `.jar` file. This kind of JAR groups up all dependencies
    required to run an application in one single JAR. To accomplish that, we need
    to set the following configuration in the project’s root `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’re ready to compile the application by running the following Maven
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This Maven command will compile the entire application and create an uber `.jar`
    file that we can use to start the application by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the artifact we use is generated from the `bootstrap` module, which
    aggregates all the other modules. The following screenshot shows us what a running
    Quarkus application should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – A running Quarkus application](img/B19777_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.6 – A running Quarkus application
  prefs: []
  type: TYPE_NORMAL
- en: The application seen in the preceding screenshot is running in the `prod` profile.
    In that profile, some features are deactivated for security purposes. We can also
    see the installed features running in the application. These features are activated
    when we add Quarkus extension dependencies on `pom.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: The `bootstrap` module acts as a bridge, allowing us to connect the external
    development framework to the hexagon modules that comprise the hexagonal system.
    For the topology and inventory application, we used Quarkus, but we could also
    use other development frameworks. We cannot say that we are totally decoupling
    the system logic from the development framework; after all, there will be some
    system logic that benefits from framework features. However, the approach presented
    in this chapter shows that part of that system can be developed first and the
    development framework introduced later.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we revisited the fundamentals of JVM, assessing some of its
    features related to JIT compilation and AOT compilation. We learned that JIT improves
    runtime performance, whereas AOT helps boost application startup time, which proves
    to be an essential feature for frameworks targeting cloud environments, as in
    this case with Quarkus.
  prefs: []
  type: TYPE_NORMAL
- en: After getting acquainted with some JVM concepts, we moved on to learn about
    Quarkus and some important features it offers. Finally, we integrated Quarkus
    into our already-developed hexagonal system topology and inventory. In order to
    accomplish such an integration, we created a new `bootstrap` module to act as
    a bridge between the hexagonal system modules and the development framework. We
    now know what it takes to integrate Quarkus into a modularized hexagonal application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we dive deeper into the integration between Quarkus and
    hexagonal architecture. We will learn how to refactor use cases and ports from
    the Application hexagon to leverage Quarkus DI features.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the advantage of using the JIT compilation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which benefit do we get by using the AOT compilation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quarkus is a development framework specially designed for which kind of environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the role of the `bootstrap` module in hexagonal architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIT improves the runtime performance of an application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AOT boosts the startup time of an application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Quarkus was designed to develop applications for cloud environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Its role is to integrate the Quarkus framework with the hexagonal system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
