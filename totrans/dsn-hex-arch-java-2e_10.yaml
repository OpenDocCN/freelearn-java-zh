- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Adding Quarkus to a Modularized Hexagonal Application
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Quarkus添加到模块化六边形应用中
- en: This chapter will expand our horizons by exploring the concepts and technologies
    to turn our hexagonal application into a cloud-native one. To support us in our
    journey to the cloud, we have Quarkus as the key technology, which is a prominent
    Java cloud-native framework. To understand Quarkus and learn how to leverage its
    features to enhance a hexagonal system, we need to revisit some fundamental knowledge
    related to the inner workings of the **Java Virtual Machine** (**JVM**). By understanding
    the main JVM characteristics and how they work, we can better understand the problems
    Quarkus aims to solve.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过探索将我们的六边形应用转变为云原生应用的概念和技术来拓宽我们的视野。为了支持我们走向云端的旅程，我们有Quarkus作为关键技术，它是一个突出的Java云原生框架。为了理解Quarkus以及如何利用其特性来增强六边形系统，我们需要重新审视与Java虚拟机（**JVM**）内部工作原理相关的某些基本知识。通过理解JVM的主要特性和它们的工作方式，我们可以更好地理解Quarkus旨在解决的问题。
- en: In this chapter, we’ll also conduct a brief tour of Quarkus’s main features
    to get an idea of what we can do with such a fine piece of software. Once we’re
    acquainted with Quarkus, we’ll take our first step in transforming our hexagonal
    system into a cloud-native one. To accomplish that, we’ll create a brand-new Java
    module and configure Quarkus dependencies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们还将简要浏览Quarkus的主要特性，以了解我们可以用这样一款优秀的软件做什么。一旦我们熟悉了Quarkus，我们就会迈出将我们的六边形系统转变为云原生系统的第一步。为了实现这一点，我们将创建一个新的Java模块并配置Quarkus依赖项。
- en: 'These are the topics that we’ll cover in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们将在本章中讨论的主题：
- en: Revisiting the JVM
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视JVM
- en: Introducing Quarkus
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Quarkus
- en: Adding Quarkus to a modularized hexagonal application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Quarkus添加到模块化六边形应用中
- en: By the end of this chapter, you’ll know how to configure Quarkus to work with
    a hexagonal application. That’s the first step in preparing a system to receive
    all the cloud-native features that Quarkus has to offer.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解如何配置Quarkus与六边形应用一起工作。这是准备一个系统以接收Quarkus提供的所有云原生特性的第一步。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To compile and run the code examples presented in this chapter, you need the
    latest **Java Standard Edition (SE) Development Kit** and **Maven 3.8** installed
    on your computer. They are all available for Linux, Mac, and Windows operating
    systems. You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要编译和运行本章中展示的代码示例，你需要在你的计算机上安装最新的**Java标准版（SE）开发工具包**和**Maven 3.8**。它们都适用于Linux、Mac和Windows操作系统。你可以在GitHub上找到本章的代码文件，网址为[https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter10)。
- en: Revisiting the JVM
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视JVM
- en: The **Virtual Machine** (**VM**) concept wasn’t something new when Java arrived
    back in 1995\. Before that time, many other languages used VMs, although they
    weren’t so popular among developers. Java architects decided to use VMs because
    they wanted a mechanism to create platform independence to improve developer productivity.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当Java在1995年回归时，**虚拟机**（**VM**）的概念并不是什么新鲜事物。在此之前，许多其他语言都使用了虚拟机，尽管它们在开发者中并不那么受欢迎。Java架构师决定使用虚拟机，因为他们想要一个机制来创建平台独立性，以提高开发者的生产力。
- en: Before elaborating on the VM concept, let’s first check what we can run inside
    a VM for Java. In languages such as C or C++, we compile source code into native
    code tailored for a specific operating system and CPU architecture. When programming
    in Java, we compile the source code into bytecode. The JVM understands the instructions
    contained in bytecode.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细阐述虚拟机概念之前，让我们首先检查Java可以在虚拟机中运行什么。在C或C++等语言中，我们将源代码编译成针对特定操作系统和CPU架构定制的本地代码。当用Java编程时，我们将源代码编译成字节码。JVM理解字节码中的指令。
- en: The VM idea comes from the concept of running programs in an intermediate or
    virtual environment sitting atop a real machine. In such an arrangement, the program
    does not need to communicate directly with the underlying operating system – the
    program deals only with a VM. The VM then converts bytecode instructions into
    native-code ones.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机的想法来源于在真实机器之上运行的程序在中间或虚拟环境中的概念。在这种安排中，程序不需要直接与底层操作系统通信——程序只与虚拟机打交道。然后虚拟机将字节码指令转换为本地代码指令。
- en: We can express one of the JVM’s advantages with a well-known Java motto – *write
    once, run anywhere*. Back in the day, and I think even now, it was very appealing
    to use a language that allowed you to develop software that, without recompilation,
    could run on different operating systems and CPU architectures. For other languages
    such as C++, you’d need to adjust your code for every targeted operating system
    and CPU architecture, prompting more effort to make your program compatible with
    different platforms.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用一个著名的Java格言来表达JVM的一个优点——“一次编写，到处运行”。在过去，我想现在也是如此，使用一种允许你开发无需重新编译就能在不同的操作系统和CPU架构上运行的软件的语言是非常吸引人的。对于其他语言，如C++，你需要为每个目标操作系统和CPU架构调整你的代码，这促使你付出更多努力以使你的程序与不同的平台兼容。
- en: In today’s world of cloud computing, we have services such as Docker and Kubernetes
    that make software units more portable than ever. To achieve portability in Java,
    we have the prerogative to execute the same compiled bytecode into different JVMs
    running on different operating systems and CPU architectures. Portability is possible
    because every JVM implementation must comply with the JVM specification, no matter
    where or how it’s implemented.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在今天的云计算世界中，我们有像Docker和Kubernetes这样的服务，使软件单元比以往任何时候都更加可移植。为了在Java中实现可移植性，我们有执行相同编译字节码到不同操作系统和CPU架构上运行的JVM的特权。可移植性是可能的，因为每个JVM实现都必须遵守JVM规范，无论它在何处或如何实现。
- en: Conversely, we can use container virtualization to achieve portability by packing
    the compiled software with its runtime environment and dependencies into a container
    image. A container engine running on different operating systems and CPU architectures
    can create containers based on container images.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以通过将编译好的软件及其运行时环境和依赖项打包到容器镜像中来使用容器虚拟化以实现可移植性。在不同的操作系统和CPU架构上运行的容器引擎可以根据容器镜像创建容器。
- en: The JVM’s appeal in making portable software at the expense of converting bytecode
    into native code is no longer attractive when you have faster and cheaper alternatives.
    Today, you can pack your application – without the need for a JVM and also recompilation
    – into a Docker image and distribute it across different operating systems and
    CPU architectures. However, we should not forget how robust and time-tested a
    piece of software such as the JVM is. We’ll return to our discussion on Docker
    and Kubernetes soon, but for now, let’s examine some more interesting JVM characteristics.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有更快、更便宜的替代方案时，JVM在将字节码转换为本地代码以制作可移植软件方面的吸引力不再那么吸引人。今天，你可以将应用程序打包——无需JVM和重新编译——到一个Docker镜像中，并在不同的操作系统和CPU架构上分发。然而，我们不应忘记像JVM这样的软件是多么的健壮和经得起时间的考验。我们很快将回到关于Docker和Kubernetes的讨论，但就目前而言，让我们来探讨一些更有趣的JVM特性。
- en: Another important JVM aspect is related to memory management. With Java, a developer
    doesn’t need to worry about how the program deals with memory release and allocation.
    Such responsibility is transferred to the JVM, so the developer can focus more
    on their program’s functional details than on the technical ones. Ask any C++
    developer how much fun it is to debug memory leaks on large systems.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的JVM方面与内存管理相关。在使用Java时，开发者无需担心程序如何处理内存释放和分配。这种责任转移给了JVM，因此开发者可以更多地关注程序的功能细节，而不是技术细节。问问任何C++开发者，在大型系统上调试内存泄漏有多有趣。
- en: The feature responsible for managing memory inside the JVM is called a **garbage
    collector**. Its purpose is to automatically check when an object is no longer
    used or referenced so that the program can free the unused memory. A JVM can use
    algorithms that trace object references and mark for releasing those that no longer
    reference any object. Different garbage collector algorithms exist, such as the
    **Concurrent Mark and Sweep** (**CMS**) and the **Garbage First Garbage Collector**
    (**G1 GC**). Since the JDK7 Update 4, the G1 GC has superseded the CMS due to
    its emphasis on first identifying and releasing the mostly empty Java object heap
    regions, making more memory available, and doing it faster than the CMS approach.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 负责在JVM内部管理内存的功能被称为**垃圾回收器**。其目的是自动检查对象是否不再被使用或引用，以便程序可以释放未使用的内存。JVM可以使用跟踪对象引用并标记不再引用任何对象的算法。存在不同的垃圾回收器算法，例如**并发标记清除**（**CMS**）和**垃圾优先垃圾回收器**（**G1
    GC**）。自JDK7更新4以来，G1 GC已经取代了CMS，因为它强调首先识别和释放大部分为空的Java对象堆区域，从而释放更多内存，并且比CMS方法更快。
- en: Garbage collectors are not required to exist in every JVM implementation, but
    as long as memory resources remain a constraint in computation, we’ll often see
    JVM implementations with garbage collectors.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾收集器并非在每一个JVM实现中都是必需的，但只要内存资源在计算中仍然是限制因素，我们经常会看到带有垃圾收集器的JVM实现。
- en: JVM is also in charge of the whole life cycle of an application. It all starts
    with the loading of a Java class file into the VM. When we compile a Java source
    file, the compiler generates a Java class file containing bytecode. Bytecode is
    a format recognizable by the JVM. A VM’s primary goal is to load and process this
    bytecode through algorithms and data structures that implement and respect a JVM
    specification.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: JVM还负责应用程序的整个生命周期。一切始于将Java类文件加载到虚拟机中。当我们编译Java源文件时，编译器会生成一个包含字节码的Java类文件。字节码是JVM能识别的格式。虚拟机的主要目标是加载并处理这种字节码，通过实现和遵守JVM规范的算法和数据结构。
- en: 'The following diagram illustrates what it takes to execute a Java program:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表说明了执行Java程序所需的步骤：
- en: '![Figure 10.1 – Java compilation and class loading on JVM](img/B19777_10_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图10.1 – JVM上的Java编译和类加载](img/B19777_10_01.jpg)'
- en: Figure 10.1 – Java compilation and class loading on JVM
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – JVM上的Java编译和类加载
- en: It all starts with the Java source code file that is compiled into a Java class
    file (bytecode) by the Java compiler. This bytecode is read by the JVM and translated
    into instructions that are understood by the **native OS**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切都始于Java源代码文件，该文件由Java编译器编译成Java类文件（字节码）。这个字节码由JVM读取，并转换为**本地操作系统**所能理解的指令。
- en: This bytecode thing has been an object of relentless work for people trying
    to find faster ways to deal with it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种字节码问题一直是那些试图找到更快处理方法的人不懈工作的对象。
- en: As time went on, the JVM received good improvements and enhanced techniques
    that considerably improved the bytecode loading performance. Among these techniques,
    we can quote **Just-in-Time** (**JIT**) and **Ahead-of-Time** (**AOT**) compilations.
    Let’s examine both of them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，JVM得到了良好的改进和增强技术，这些技术大大提高了字节码加载性能。在这些技术中，我们可以引用**即时编译**（**JIT**）和**提前编译**（**AOT**）。让我们来考察这两个。
- en: Speeding up runtime performance with JIT compilation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过即时编译加速运行时性能
- en: '**JIT compilers** arose from the idea that certain program instructions can
    be optimized for better performance while a program is running. So, to accomplish
    such optimization, the JIT compiler seeks program instructions with the potential
    to be optimized. In general, these instructions are the ones most executed by
    the program.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**JIT编译器**起源于这样的想法：某些程序指令可以在程序运行时进行优化以获得更好的性能。因此，为了完成这种优化，JIT编译器寻找具有优化潜力的程序指令。一般来说，这些指令是程序执行最频繁的指令。'
- en: 'Because these instructions are executed so often, they consume a significant
    amount of computer time and resources. Remember that these instructions are in
    the bytecode format. A traditional compiler would compile all the bytecode into
    native code before running the program. With a JIT compiler, things are different,
    as shown in the following diagram:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些指令执行频率很高，它们消耗了大量的计算机时间和资源。记住这些指令是以字节码格式存在的。传统的编译器会在运行程序之前将所有字节码编译成本地代码。与JIT编译器不同，如下图表所示：
- en: '![Figure 10.2 – How JIT works](img/B19777_10_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – JIT工作原理](img/B19777_10_02.jpg)'
- en: Figure 10.2 – How JIT works
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – JIT工作原理
- en: A JIT compiler selects, by using its dynamic optimization algorithms, some parts
    of the bytecode. Then, it compiles and applies optimizations to these bytecode
    parts. The result is optimized native code that is tweaked to provide better performance
    for the system. The term *JIT* is used because the optimizations are made right
    before the code is executed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: JIT编译器通过使用其动态优化算法选择字节码的一部分。然后，它编译并应用优化到这些字节码部分。结果是经过优化的本地代码，经过调整以提供更好的系统性能。使用*JIT*这个术语是因为优化是在代码执行之前进行的。
- en: However, there is no such thing as a free lunch when using JIT compilers. One
    of the most well-known drawbacks of JIT compilers is the increased startup time
    of an application because of the initial optimizations a JIT compiler does before
    running the program. In order to overcome this startup problem, there is another
    technique called AOT compilation. Various cloud-native frameworks, including Quarkus,
    have used this technique. Let’s see how AOT compilation works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在使用即时编译器（JIT compilers）时，并没有免费的午餐。即时编译器最著名的缺点之一是应用程序启动时间的增加，这是因为即时编译器在运行程序之前进行的初始优化。为了克服这个启动问题，存在另一种称为AOT编译的技术。包括Quarkus在内的各种云原生框架都使用了这种技术。让我们看看AOT编译是如何工作的。
- en: Improving startup time with AOT compilation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用AOT编译提高启动时间
- en: '**AOT** is so appealing on the Java scene because traditional Java systems
    – mainly those based on enterprise application servers such as **JBoss** and **WebLogic**
    – take too much time to initiate. In addition to slower startup times, we have
    to consider the amount of computer power those application servers consume. These
    characteristics are a deal-breaker for anyone who wants to migrate Java workloads
    to the cloud, where instances and Kubernetes Pods are brought up and down frantically.
    So, by employing AOT in Java, we give up the cross-platform capability provided
    by the JVM and its bytecode for a better performance provided by AOT and its native
    code. The cross-platform problem is mitigated to some extent with the usage of
    container technologies such as Docker and Kubernetes.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**AOT**在Java领域如此吸引人，因为传统的Java系统——主要是基于企业应用服务器，如**JBoss**和**WebLogic**——启动时间太长。除了较慢的启动时间外，我们还需要考虑这些应用服务器消耗的计算机资源。这些特性对于想要将Java工作负载迁移到云中的人来说是一个致命的缺点，在云中，实例和Kubernetes
    Pods疯狂地被创建和销毁。因此，通过在Java中使用AOT，我们放弃了JVM及其字节码提供的跨平台能力，以换取AOT及其本地代码提供的更好性能。通过使用Docker和Kubernetes等容器技术，跨平台问题在一定程度上得到了缓解。'
- en: 'Here, we have a representation showing how straightforward the AOT compilation
    process is to transform Java bytecode into **m****achine code**:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个表示如何将Java字节码转换为**机器代码**的AOT编译过程直观表示：
- en: '![Figure 10.3 – How AOT works](img/B19777_10_03.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – AOT的工作原理](img/B19777_10_03.jpg)'
- en: Figure 10.3 – How AOT works
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – AOT的工作原理
- en: Not everything is an advantage with AOT in Java. An AOT compiler spends more
    time generating a native binary than a Java compiler needs to create bytecode
    classes. So, AOT compilation can have a considerable impact on **Continuos Integration**
    (**CI**) pipelines. Also, the developer needs to do some additional work to get
    things working properly to use reflection. **GraalVM** is the AOT compiler used
    to provide a native binary for Java and other JVM-based languages.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中使用AOT并不总是有利。AOT编译器生成本地二进制文件所需的时间比Java编译器创建字节码类所需的时间要多。因此，AOT编译可能会对**持续集成（CI**）管道产生相当大的影响。此外，开发者需要做一些额外的工作来确保使用反射时一切正常。**GraalVM**是用于为Java和其他基于JVM的语言提供本地二进制文件的AOT编译器。
- en: With Quarkus, we have the prerogative to create applications using either JIT
    or AOT compilation methods. It’s up to us to decide which technique suits our
    needs better.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Quarkus，我们有权利选择使用JIT或AOT编译方法来创建应用程序。选择哪种技术更适合我们的需求取决于我们。
- en: In this section, we gained some background knowledge about the inner workings
    of the JVM and how it tries to improve bytecode loading with JIT and AOT compilation.
    Such knowledge is important to understand how Quarkus works under the hood and
    achieves considerable performance improvements.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们了解了一些关于JVM内部工作原理以及它是如何通过JIT和AOT编译来尝试改进字节码加载的背景知识。这种知识对于理解Quarkus在底层是如何工作以及如何实现显著的性能提升非常重要。
- en: Now that we are acquainted with some JVM fundamentals and essential compilation
    techniques, let’s dive in and learn more about Quarkus’ main features.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了一些JVM基础和基本的编译技术，让我们深入探讨并了解Quarkus的主要特性。
- en: Introducing Quarkus
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Quarkus
- en: If you develop enterprise Java applications, you have already worked with Spring
    Boot. Time-tested and widely used in the industry, Spring Boot is a robust piece
    of software with a vibrant community. Its libraries increase developed productivity
    by providing out-of-the-box solutions for security, persistence, APIs, and many
    more things that a typical enterprise application requires. You may wonder why
    this book does not discuss Spring Boot but Quarkus. There are two reasons. First,
    more material is available covering Spring Boot than Quarkus, which is understandable,
    as Spring Boot has been around longer and has a bigger community. The second reason
    is that Quarkus was built with cloud-native development at its core, while Spring
    Boot has been adapted to it. And since this book focuses on cloud-native development
    with hexagonal architecture, Quarkus was chosen because it is a cloud-first framework.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开发企业级Java应用程序，你已经使用过Spring Boot了。经过时间考验且在业界广泛使用，Spring Boot是一款功能强大且社区活跃的软件。它的库通过提供现成的解决方案，如安全性、持久性、API等，大大提高了开发效率，这些都是典型企业级应用程序所必需的。你可能想知道为什么这本书没有讨论Spring
    Boot而是Quarkus。有两个原因。首先，关于Spring Boot的资料比Quarkus多，这是可以理解的，因为Spring Boot存在的时间更长，拥有更大的社区。第二个原因是Quarkus的核心是云原生开发，而Spring
    Boot则是适应了这一趋势。由于这本书专注于云原生开发和六边形架构，因此选择了Quarkus，因为它是一个以云为先的框架。
- en: Focused on performance, Quarkus comes with built-in support for native executables
    based on GraalVM, making it possible to achieve swift startup times.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 专注于性能，Quarkus内置了对基于GraalVM的本地可执行文件的支持，这使得快速启动成为可能。
- en: To attract developers, it offers valuable things such as live development, a
    feature that enhances productivity by avoiding the need to restart an application
    whenever something changes in your code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为了吸引开发者，它提供了诸如实时开发等有价值的特性，该特性通过避免在代码中发生更改时需要重新启动应用程序来提高生产力。
- en: Targeting cloud-native environments, Quarkus comes equipped with the proper
    tooling, allowing you to deal with constraints and leverage the benefits that
    come when developing software to run on container-based environments, such as
    Kubernetes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 面向云原生环境，Quarkus配备了适当的工具，让你能够处理约束并利用在基于容器环境（如Kubernetes）上开发软件时带来的好处。
- en: Borrowing good ideas from enterprise development, Quarkus is built on top of
    well-established standards such as the **Contexts and Dependency Injection** (**CDI**)
    framework, the **Jakarta Persistence API** (**JPA**) specification with Hibernate
    ORM implementation, and the **Jakarta RESTful Web Services** (**JAX-RS**) specification
    implemented by RESTEasy. For those immersed in the Java **Enterprise Edition**
    (**EE**) world, this means the learning curve to master Quarkus is shallow because
    much of their already acquired enterprise development knowledge can be reused
    to develop Quarkus applications.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从企业级开发中借鉴了优秀思想，Quarkus建立在诸如**上下文和依赖注入**（**CDI**）框架、Hibernate ORM实现的**Jakarta
    Persistence API**（**JPA**）规范以及RESTEasy实现的**Jakarta RESTful Web Services**（**JAX-RS**）规范等成熟标准之上。对于那些沉浸在Java
    **企业版**（**EE**）世界的人来说，这意味着掌握Quarkus的学习曲线很浅，因为他们已经获得的大部分企业级开发知识可以重新用于开发Quarkus应用程序。
- en: Created by Red Hat, Quarkus sets itself apart from its competitors by being
    a software development framework designed from scratch to deal with cloud technologies.
    Contrary to other more aged frameworks that bring boilerplate code and features
    from an older era, Quarkus presents itself as a fresh and modern piece of software.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 由红帽公司创建的Quarkus，通过作为一个从头开始设计的软件开发框架来处理云技术，将自己与竞争对手区分开来。与那些带来过时代码和功能的更老框架不同，Quarkus展示了自己作为一个新鲜现代的软件产品。
- en: Built upon other well-established open source projects, Quarkus is the cloud-native
    framework we’ll use to prepare our hexagonal system for the cloud. Before that,
    though, we’ll explore some of the main features this framework provides. Let’s
    get started by looking first at how to create REST endpoints with Quarkus.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在其他成熟的开源项目之上，Quarkus是我们用来为云原生系统准备六边形系统的云原生框架。在此之前，我们将探索这个框架提供的一些主要功能。让我们首先看看如何使用Quarkus创建REST端点。
- en: Creating REST endpoints with JAX-RS
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用JAX-RS创建REST端点
- en: 'It’s very straightforward to create REST endpoints using Quarkus. In order
    to do so, the framework relies on a JAX-RS implementation called RESTEasy. This
    implementation is available in the following Maven dependency:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Quarkus 创建 REST 端点非常简单。为了做到这一点，该框架依赖于一个名为 RESTEasy 的 JAX-RS 实现。此实现可在以下 Maven
    依赖项中找到：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Look at the following example, which shows how to use RESTEasy to create REST
    services:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下示例，它展示了如何使用 RESTEasy 创建 REST 服务：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We set the endpoint address with the `@Path` annotation. With `@GET`, we set
    the HTTP method supported by that endpoint. With `@Produces`, we define the return
    type for the request.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `@Path` 注解设置端点地址。使用 `@GET`，我们设置该端点支持的 HTTP 方法。使用 `@Produces`，我们定义请求的返回类型。
- en: In this same `RestExample` class, we can inject dependencies to be used together
    with the REST endpoints. Let’s see how to accomplish this.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一个 `RestExample` 类中，我们可以注入与 REST 端点一起使用的依赖项。让我们看看如何完成这个任务。
- en: Employing dependency injection with Quarkus DI
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Quarkus DI 进行依赖注入
- en: 'Quarkus has its own dependency injection mechanism based on **Quarkus ArC**,
    which, in turn, comes from the CDI specification, which has its roots back in
    **Java EE 6**. With CDI, we no longer need to control the creation and life cycle
    of dependency objects we provide to a system. Without a dependency injection framework,
    you have to create objects this way:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 有自己的基于 **Quarkus ArC** 的依赖注入机制，该机制反过来又来自 CDI 规范，其根源可以追溯到 **Java EE 6**。使用
    CDI，我们不再需要控制提供给系统的依赖对象创建和生命周期。如果没有依赖注入框架，你必须这样创建对象：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When using CDI, you just have to annotate the `class` attribute with the `@Inject`
    annotation, like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 CDI 时，你只需将 `class` 属性注解为 `@Inject` 注解即可，如下所示：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For the `@Inject` annotation to work, we first need to declare the dependency
    as a managed bean. Take a look at the example here:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 `@Inject` 注解生效，我们首先需要将依赖项声明为托管豆。请看以下示例：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `@ApplicationScoped` annotation states that this bean will be available
    as long as the application is not terminated. Also, this bean is accessible from
    different requests and calls across the entire system. Let’s update our `RestExample`
    to inject this bean, as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`@ApplicationScoped` 注解表示只要应用程序没有终止，这个豆就会可用。此外，这个豆在整个系统中可以从不同的请求和调用中访问。让我们更新我们的
    `RestExample` 以注入这个豆，如下所示：'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Right at the top, we inject the `BeanExample` dependency with the `@Inject`
    annotation. Then, we call the `simpleBean` method from the injected `BeanExample`
    dependency.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶部，我们使用 `@Inject` 注解注入 `BeanExample` 依赖项。然后，我们调用注入的 `BeanExample` 依赖项中的 `simpleBean`
    方法。
- en: Next, let’s see how to validate objects that are created when the system receives
    an HTTP request.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看当系统接收到 HTTP 请求时如何验证创建的对象。
- en: Validating objects
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证对象
- en: 'We learned how to create REST endpoints and also how to inject dependencies
    in the application. *But how about object validation?* *How can we ensure that
    the data provided by a given request is valid?* Quarkus can help us in that matter.
    The Quarkus validation mechanism is available in the following Maven dependency:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何创建 REST 端点以及如何在应用程序中注入依赖项。*但是关于对象验证呢？* *我们如何确保给定请求提供的数据是有效的呢？* Quarkus
    可以帮助我们解决这个问题。Quarkus 验证机制在以下 Maven 依赖项中可用：
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The Quarkus validation mechanism is based on **Hibernate Validator**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 验证机制基于 **Hibernate Validator**。
- en: 'To see how it works, let’s first create a sample object containing the fields
    we expect in a request, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解它是如何工作的，让我们首先创建一个包含我们期望在请求中出现的字段的示例对象，如下所示：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With the `@NotBlank` annotation, we state that the `field` variable should
    never be empty. Then, by using the `@Min` annotation, we ensure that the `value`
    variable should always contain a number equal to or higher than `10`. Let’s return
    to the `RestExample` class and create a new REST endpoint to validate the request,
    as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `@NotBlank` 注解，我们声明 `field` 变量永远不应该为空。然后，通过使用 `@Min` 注解，我们确保 `value` 变量应该始终包含一个等于或高于
    `10` 的数字。让我们回到 `RestExample` 类并创建一个新的 REST 端点来验证请求，如下所示：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: When `ConstraintViolationException` is caught, the system returns an `HTTP 400
    Bad Request` failure response.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当捕获到 `ConstraintViolationException` 时，系统返回一个 `HTTP 400 Bad Request` 失败响应。
- en: 'Note the `@Valid` annotation just before `SampleObject`. By using that annotation,
    we trigger a validation check whenever a request hits the `/app/request-validation`
    endpoint. Check out the following results:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `SampleObject` 之前使用的 `@Valid` 注解。通过使用该注解，每当请求击中 `/app/request-validation`
    端点时，都会触发验证检查。查看以下结果：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the previous `POST` request, the field is empty, which results in a failure
    response with an `HTTP 400 Bad` `Request` code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的 `POST` 请求中，字段为空，导致返回了一个带有 `HTTP 400 Bad Request` 代码的失败响应。
- en: 'In the next request, we set `value` to a number less than `10`, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个请求中，我们将 `value` 设置为一个小于 `10` 的数字，如下所示：
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, the constraint was violated, and the result showed that the validation
    had failed. The failure was caused because we sent the number `9`, and the minimum
    value accepted is `10`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，违反了约束，结果显示验证失败。失败的原因是我们发送了数字 `9`，而接受的最低值是 `10`。
- en: 'Here is a proper request with valid data:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个带有有效数据的正确请求：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `field` parameter is not `null`, nor is `value` less than `10`. So, the
    request returns a valid response.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`field` 参数不是 `null`，`value` 也不是小于 `10`。因此，请求返回了一个有效的响应。'
- en: Configuring a data source and using Hibernate ORM
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置数据源和使用 Hibernate ORM
- en: Quarkus allows you to connect to a data source in two ways. The first and traditional
    way is based on a JDBC connection. To connect using this method, you need the
    `agroal` library and the JDBC driver of the specific database type you want to
    connect. The second – and reactive – way allows you to treat the database connection
    like a stream of data. For that mode, you need `Vert.x` reactive drivers.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus 允许您以两种方式连接到数据源。第一种是传统的基于 JDBC 连接的方式。要使用此方法连接，您需要 `agroal` 库以及您想要连接的特定数据库类型的
    JDBC 驱动程序。第二种是反应式的方式，允许您将数据库连接视为数据流。为此模式，您需要 `Vert.x` 反应式驱动程序。
- en: 'In the following steps, we’ll set up a data source connection using the traditional
    JDBC method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将使用传统的 JDBC 方法设置数据源连接：
- en: 'To get started, we need the following dependencies:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，我们需要以下依赖项：
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`quarkus-hibernate-orm` refers to the Hibernate ORM implementation of JPA.
    It is this dependency that provides the capability to map Java objects to database
    entities.'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`quarkus-hibernate-orm` 指的是 JPA 的 Hibernate ORM 实现。正是这个依赖项提供了将 Java 对象映射到数据库实体的能力。'
- en: 'Next, we need to configure the data source settings in the `application.properties`
    file, as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `application.properties` 文件中配置数据源设置，如下所示：
- en: '[PRE13]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`quarkus.datasource.db-kind` is optional, but we use that to emphasize that
    the application uses an H2 in-memory database. We use `quarkus.datasource.jdbc.url`
    to inform the connection string. The `quarkus.hibernate-orm.dialect` option sets
    the dialect used for the data source communication, and `quarkus.hibernate-orm.database.generation=drop-and-create`
    forces the creation of a database structure at startup.'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`quarkus.datasource.db-kind` 是可选的，但我们使用它来强调应用程序使用 H2 内存数据库。我们使用 `quarkus.datasource.jdbc.url`
    来提供连接字符串。`quarkus.hibernate-orm.dialect` 选项设置用于数据源通信的方言，而 `quarkus.hibernate-orm.database.generation=drop-and-create`
    强制在启动时创建数据库结构。'
- en: If there is an `import.sql` file in `classpath`, this `drop-and-create` option
    enables the use of that file to load data into the database. Something very interesting
    about this `drop-and-create` option is that every change on application entities
    or in the `import.sql` file is picked automatically and applied to the database
    without restarting the system. For this to work, a system needs to run in live
    development mode.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 `classpath` 中存在 `import.sql` 文件，这个 `drop-and-create` 选项允许使用该文件将数据加载到数据库中。关于这个
    `drop-and-create` 选项的一个非常有趣的特点是，应用程序实体或 `import.sql` 文件上的每次更改都会自动检测并应用到数据库中，而无需重新启动系统。为了实现这一点，系统需要以实时开发模式运行。
- en: 'Let’s create a `SampleEntity` class to persist in the database, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个 `SampleEntity` 类以持久化到数据库中，如下所示：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `SampleEntity` class corresponds to the `SampleObject` class we created
    earlier. The requirement to use the `SampleEntity` class as a database entity
    is to annotate it with the `@Entity` annotation. Following that annotation, we
    have `@NamedQuery`, which we’ll use later to retrieve all entities from the database.
    To automatically generate ID values, we will use `GenerationType.AUTO`. The `field`
    and `value` variables from `SampleEntity` are mapped to the same variables that
    exist in the `SampleObject` class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`SampleEntity` 类对应于我们之前创建的 `SampleObject` 类。使用 `SampleEntity` 类作为数据库实体的要求是使用
    `@Entity` 注解对其进行标注。在该注解之后，我们有 `@NamedQuery`，我们稍后会使用它从数据库中检索所有实体。为了自动生成 ID 值，我们将使用
    `GenerationType.AUTO`。`SampleEntity` 中的 `field` 和 `value` 变量映射到 `SampleObject`
    类中存在的相同变量。'
- en: 'Let’s now create a new bean called `PersistenceExample` to assist us in creating
    and retrieving database entities. Here’s how to do this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个新的名为 `PersistenceExample` 的 Bean，以帮助我们创建和检索数据库实体。以下是这样做的方法：
- en: '[PRE15]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To interact with the database, the first thing we have to do is to inject `EntityManager`.
    Quarkus will take care of retrieving an `EntityManager` object with all the database
    connection settings we provided in the `application.properties` file. Continuing
    the `PersistenceExample` implementation, let’s create a method to persist entities,
    as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要与数据库交互，我们首先要做的是注入`EntityManager`。Quarkus将负责检索一个`EntityManager`对象，该对象包含我们在`application.properties`文件中提供的所有数据库连接设置。继续`PersistenceExample`实现，让我们创建一个持久化实体的方法，如下所示：
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `createEntity` method persists an entity in the database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`createEntity`方法将实体持久化到数据库中。'
- en: 'The `@Transactional` annotation above the method declaration will make the
    `EntityManager` object flush the transaction once the database operation is committed.
    This is illustrated in the following code snippet:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 方法声明上方的`@Transactional`注解将使`EntityManager`对象在数据库操作提交时刷新事务。这如下面的代码片段所示：
- en: '[PRE17]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `getAllEntities` method retrieves all entities from the database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAllEntities`方法从数据库中检索所有实体。'
- en: 'Now, let’s return to `RestExample` to create REST endpoints to trigger the
    creation and retrieval of database entities. We will start by injecting `PersistenceExample`
    so that we can use this bean to begin operations on the database. The code is
    illustrated in the following snippet:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到`RestExample`来创建REST端点以触发数据库实体的创建和检索。我们将首先注入`PersistenceExample`，这样我们就可以使用这个豆来开始对数据库的操作。代码如下所示：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, we create a `/create-entity` endpoint, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`/create-entity`端点，如下所示：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We pass `SampleObject` as the parameter. This object represents the body of
    the `POST` request.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递`SampleObject`作为参数。这个对象代表了`POST`请求的主体。
- en: 'Finally, we create a `/get-all-entities` endpoint to retrieve all entities
    from the database, as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`/get-all-entities`端点来从数据库中检索所有实体，如下所示：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `retrieveAllEntities` method calls on `getAllEntities` from the `PersistenceExample`
    bean. The result is a list of `SampleEntity` objects.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`retrieveAllEntities`方法在`PersistenceExample`豆中调用`getAllEntities`。结果是`SampleEntity`对象的一个列表。'
- en: 'Let’s see what we get when we hit `/create-entity` to create a new entity.
    You can see the output here:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看当我们点击`/create-entity`来创建一个新实体时我们会得到什么。你可以在这里看到输出：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'To see the entities we’ve created, we send a request to `/get-all-entities`,
    as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看我们创建的实体，我们向`/get-all-entities`发送请求，如下所示：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As expected, we received all the entities we persisted previously in the database
    in a JSON format.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，我们以JSON格式收到了之前在数据库中持久化的所有实体。
- en: Quarkus is a vast and continuously growing framework that’s absorbing more and
    more capabilities. The features we have seen cover some of the basic things required
    to develop modern applications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Quarkus是一个庞大且持续增长的框架，它吸收了越来越多的功能。我们看到的特性涵盖了开发现代应用程序所需的一些基本功能。
- en: We’ll be able to use RESTEasy when reimplementing input adapters to support
    REST on our hexagonal application. Quarkus DI will enable us to better manage
    the life cycle of objects from the Framework and Application hexagons. The Quarkus
    validation mechanisms will contribute to validating the data entering the hexagonal
    system. The data source configuration and Hibernate ORM will support the restructuring
    of output adapters.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在重新实现输入适配器以支持我们六边形应用程序的REST时使用RESTEasy。Quarkus DI将使我们能够更好地管理框架和应用六边形对象的生命周期。Quarkus验证机制将有助于验证进入六边形系统的数据。数据源配置和Hibernate
    ORM将支持输出适配器的重构。
- en: In this section, we learned how to tweak the `application.properties` file to
    configure a database connection on Quarkus, and we briefly explored Hibernate’s
    ORM capabilities that help map Java classes to database entities. We’ll explore
    this subject further in [*Chapter 13*](B19777_13.xhtml#_idTextAnchor263), *Persisting
    Data with Output Adapters and* *Hibernate Reactive*.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何调整`application.properties`文件以在Quarkus上配置数据库连接，并简要探讨了Hibernate的ORM功能，这些功能有助于将Java类映射到数据库实体。我们将在[*第13章*](B19777_13.xhtml#_idTextAnchor263)中进一步探讨这个主题，*使用输出适配器和Hibernate
    Reactive持久化数据*。
- en: Let’s now see how to integrate Quarkus into the hexagonal system.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将Quarkus集成到六边形系统中。
- en: Adding Quarkus to a modularized hexagonal application
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Quarkus添加到模块化的六边形应用程序中
- en: 'To recap, we structured the topology and inventory system in three modularized
    hexagons: **Domain**, **Application**, and **Framework**. A question that may
    arise is, *which module should be responsible for starting the Quarkus engine?*
    Well, to avoid blurring the responsibilities of each module in the topology and
    inventory system, we’ll create a dedicated module whose sole purpose is to aggregate
    the other hexagonal system modules and bootstrap the Quarkus engine. We will name
    this new module **Bootstrap**, as illustrated in the following diagram:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了总结，我们将拓扑和库存系统结构化为三个模块化的六角：**领域**、**应用**和**框架**。可能出现的疑问是，*哪个模块应该负责启动Quarkus引擎？*
    好吧，为了避免模糊拓扑和库存系统中每个模块的责任，我们将创建一个专门的模块，其唯一目的是聚合其他六角系统模块并启动Quarkus引擎。我们将把这个新模块命名为**Bootstrap**，如下面的图所示：
- en: '![Figure 10.4 – The Bootstrap aggregator module](img/B19777_10_04.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图10.4 – Bootstrap聚合器模块](img/B19777_10_04.jpg)'
- en: Figure 10.4 – The Bootstrap aggregator module
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 – Bootstrap聚合器模块
- en: The `bootstrap` module is an aggregator module that provides, from one side,
    the dependencies required to initialize Quarkus and, from the other side, the
    `hexagonal` module dependencies for use in conjunction with Quarkus.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootstrap`模块是一个聚合器模块，它从一方面提供初始化Quarkus所需的依赖项，从另一方面提供与Quarkus一起使用的`hexagonal`模块依赖项。'
- en: 'Let’s create this new `bootstrap` module in the topology and inventory system,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在拓扑和库存系统中创建这个新的`bootstrap`模块，如下所示：
- en: 'In the Maven root project of the topology and inventory system, you can execute
    the following Maven command to create this `bootstrap` module:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在拓扑和库存系统的Maven根项目中，你可以执行以下Maven命令来创建这个`bootstrap`模块：
- en: '[PRE23]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Figure 10.5 – The topology and inventory high-level directory structure](img/B19777_10_05.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图10.5 – 拓扑和库存系统高级目录结构](img/B19777_10_05.jpg)'
- en: Figure 10.5 – The topology and inventory high-level directory structure
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 – 拓扑和库存系统高级目录结构
- en: 'Next, we need to set up Quarkus dependencies in the project’s root `pom.xml`
    file, as follows:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在项目的根`pom.xml`文件中设置Quarkus依赖项，如下所示：
- en: '[PRE24]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `quarkus-universe-bom` dependency makes all the Quarkus extensions available.
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`quarkus-universe-bom`依赖项使所有Quarkus扩展可用。'
- en: Because we’re working with a multi-module application, we need to configure
    Quarkus to discover CDI beans in different modules.
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们正在处理一个多模块应用程序，我们需要配置Quarkus以在不同的模块中查找CDI豆。
- en: 'So, we need to configure `jandex-maven-plugin` in the Maven project’s root
    `pom.xml` file, as follows:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，我们需要在Maven项目的根`pom.xml`文件中配置`jandex-maven-plugin`，如下所示：
- en: '[PRE25]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Without the preceding plugin, we’d have a problem setting up and using CDI beans
    on both the Framework and Application hexagons.
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果没有前面的插件，我们将在框架和应用六角上设置和使用CDI豆时遇到问题。
- en: Now comes the most crucial part – the configuration of `quarkus-maven-plugin`.
    To make the `bootstrap` module the one that will start the Quarkus engine, we
    need to configure `quarkus-maven-plugin` in that module properly.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是至关重要的部分——配置`quarkus-maven-plugin`。为了使`bootstrap`模块成为启动Quarkus引擎的模块，我们需要在该模块中正确配置`quarkus-maven-plugin`。
- en: 'Here is how we should configure `quarkus-maven-plugin` on `bootstrap/pom.xml`:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们在`bootstrap/pom.xml`上应该如何配置`quarkus-maven-plugin`：
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The important part here is the line containing `<goal>build</goal>`. By setting
    this build goal for the `bootstrap` module, we make this module responsible for
    starting the Quarkus engine.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里重要的是包含`<goal>build</goal>`的行。通过为`bootstrap`模块设置此构建目标，我们使该模块负责启动Quarkus引擎。
- en: 'Next, we need to add the Maven dependencies from the topology and inventory
    system’s hexagons. We do that in the `bootstrap/pom.xml` file, as follows:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加拓扑和库存系统六角中的Maven依赖项。我们在`bootstrap/pom.xml`文件中这样做，如下所示：
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And finally, we create a `module-info.java` Java module descriptor with the
    `requires` directives for Quarkus and the topology and inventory hexagon modules,
    as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建一个带有Quarkus和拓扑及库存六角模块的`requires`指令的`module-info.java` Java模块描述符，如下所示：
- en: '[PRE28]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To aggregate the three hexagon modules into one deployment unit, we’ll configure
    Quarkus to generate an uber `.jar` file. This kind of JAR groups up all dependencies
    required to run an application in one single JAR. To accomplish that, we need
    to set the following configuration in the project’s root `pom.xml` file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将三个六角模块聚合为一个部署单元，我们将配置Quarkus生成一个uber `.jar`文件。这种JAR将所有运行应用程序所需的依赖项组合在一个单一的JAR中。为了实现这一点，我们需要在项目的根`pom.xml`文件中设置以下配置：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we’re ready to compile the application by running the following Maven
    command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过运行以下Maven命令来编译应用程序：
- en: '[PRE30]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This Maven command will compile the entire application and create an uber `.jar`
    file that we can use to start the application by executing the following command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此Maven命令将编译整个应用程序并创建一个可以执行以下命令以启动应用程序的uber `.jar`文件：
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Note that the artifact we use is generated from the `bootstrap` module, which
    aggregates all the other modules. The following screenshot shows us what a running
    Quarkus application should look like:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用的工件是由`bootstrap`模块生成的，该模块聚合了所有其他模块。以下截图展示了运行中的Quarkus应用程序应该看起来是什么样子：
- en: '![Figure 10.6 – A running Quarkus application](img/B19777_10_06.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图10.6 – 运行中的Quarkus应用程序](img/B19777_10_06.jpg)'
- en: Figure 10.6 – A running Quarkus application
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 – 运行中的Quarkus应用程序
- en: The application seen in the preceding screenshot is running in the `prod` profile.
    In that profile, some features are deactivated for security purposes. We can also
    see the installed features running in the application. These features are activated
    when we add Quarkus extension dependencies on `pom.xml`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中看到的程序正在`prod`配置文件下运行。在该配置文件中，出于安全考虑，一些功能被禁用。我们还可以看到应用程序中运行的功能。当我们向`pom.xml`添加Quarkus扩展依赖项时，这些功能被激活。
- en: The `bootstrap` module acts as a bridge, allowing us to connect the external
    development framework to the hexagon modules that comprise the hexagonal system.
    For the topology and inventory application, we used Quarkus, but we could also
    use other development frameworks. We cannot say that we are totally decoupling
    the system logic from the development framework; after all, there will be some
    system logic that benefits from framework features. However, the approach presented
    in this chapter shows that part of that system can be developed first and the
    development framework introduced later.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`bootstrap`模块充当桥梁，使我们能够将外部开发框架连接到构成六边形系统的六边形模块。对于拓扑和库存应用程序，我们使用了Quarkus，但也可以使用其他开发框架。我们无法说我们已经完全解耦了系统逻辑和开发框架；毕竟，仍有一些系统逻辑可以从框架功能中受益。然而，本章中提出的方法表明，该系统的一部分可以先开发，然后再引入开发框架。'
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we revisited the fundamentals of JVM, assessing some of its
    features related to JIT compilation and AOT compilation. We learned that JIT improves
    runtime performance, whereas AOT helps boost application startup time, which proves
    to be an essential feature for frameworks targeting cloud environments, as in
    this case with Quarkus.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了JVM的基本原理，评估了一些与其JIT编译和AOT编译相关的功能。我们了解到JIT可以提高运行时性能，而AOT有助于提高应用程序的启动时间，这证明了对目标云环境框架（如本例中的Quarkus）来说是一个基本功能。
- en: After getting acquainted with some JVM concepts, we moved on to learn about
    Quarkus and some important features it offers. Finally, we integrated Quarkus
    into our already-developed hexagonal system topology and inventory. In order to
    accomplish such an integration, we created a new `bootstrap` module to act as
    a bridge between the hexagonal system modules and the development framework. We
    now know what it takes to integrate Quarkus into a modularized hexagonal application.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在熟悉了一些JVM概念之后，我们继续学习Quarkus及其提供的一些重要功能。最后，我们将Quarkus集成到我们已开发的六边形系统拓扑和库存中。为了完成这样的集成，我们创建了一个新的`bootstrap`模块，作为六边形系统模块和开发框架之间的桥梁。我们现在知道将Quarkus集成到模块化六边形应用程序需要什么。
- en: In the next chapter, we dive deeper into the integration between Quarkus and
    hexagonal architecture. We will learn how to refactor use cases and ports from
    the Application hexagon to leverage Quarkus DI features.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入了解Quarkus和六边形架构之间的集成。我们将学习如何重构用例和端口从应用程序六边形到利用Quarkus DI功能。
- en: Questions
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the advantage of using the JIT compilation?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用JIT编译的优势是什么？
- en: Which benefit do we get by using the AOT compilation?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用AOT编译，我们能获得哪些好处？
- en: Quarkus is a development framework specially designed for which kind of environment?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quarkus是为哪种环境专门设计的开发框架？
- en: What is the role of the `bootstrap` module in hexagonal architecture?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`bootstrap`模块在六边形架构中扮演什么角色？'
- en: Answers
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: JIT improves the runtime performance of an application.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: JIT提高了应用程序的运行时性能。
- en: AOT boosts the startup time of an application.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: AOT提高了应用程序的启动时间。
- en: Quarkus was designed to develop applications for cloud environments.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Quarkus是为开发云环境中的应用程序而设计的。
- en: Its role is to integrate the Quarkus framework with the hexagonal system.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其作用是将 Quarkus 框架与六边形系统集成。
