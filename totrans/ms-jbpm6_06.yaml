- en: Chapter 6. Core Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Chapter 1](ch01.html "Chapter 1. Business Process Modeling – Bridging Business
    and Technology"), *Business Process Modeling – Bridging Business and Technology*,
    provided you with an overview of the new KIE platform and the jBPM tool stack
    components. This chapter will show you how jBPM is built and what its components
    and subsystems are, and it will take you through the source code of jBPM, illustrating,
    with examples, how to leverage the flexibility provided by its modular system.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of topics that we will cover in this chapter is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Core API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Human Task service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistence and transaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: History logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The KIE API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The new KIE API stems from the need for providing both a new common software
    service layer and an integrated IDE (Workbench) for well-assessed Red Hat projects,
    mainly Drools and jBPM. With the KIE API, several features have been added to
    ease the integration of these platforms with several environments: JMS, Rest,
    SOAP, CDI, Spring, Seam, OSGi, and plain Java applications.'
  prefs: []
  type: TYPE_NORMAL
- en: The **droolsjbpm-integration** additional project (hosted at [https://github.com/droolsjbpm/droolsjbpm-integration](https://github.com/droolsjbpm/droolsjbpm-integration))
    features integration packages for various environments and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: We previewed some of the new KIE concepts in [Chapter 4](ch04.html "Chapter 4. Operation
    Management"), *Operation Management* (new Maven-based deployments, KieModule,
    the `kmodule.xml` file, and KieScanner), so you should be ready to go deeper into
    the subject. You will also find, as a companion support for our examples, class
    diagrams of specific KIE component relationships, which should help you to have
    a clearer picture of the internal KIE organization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[http://www.kiegroup.org](http://www.kiegroup.org) is the portal for all KIE
    technologies.'
  prefs: []
  type: TYPE_NORMAL
- en: KieServices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: KieServices is a thread-safe singleton, which acts as a service factory. It
    gives high-level access to main KIE components and services.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to obtain a KieServices reference via its factory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The main KIE API services are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**KieContainer**: This is essentially a wrapper for KieModule and KieBase(s)
    that it defines; it can compile and verify KieBase and generate new KieSession(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KieRepository**: This is a repository that manages KieModules abstracting
    away from the module source; it can be a module installed in a Maven repository
    or a module programmatically created and added by the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KieScanner**: This is a Maven repository artifacts scanner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KieBuilder**: This is a helper for compiling and building a KieModule starting
    from its set of source files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KieResources**: This is a factory for creating specialized resources from
    various I/O sources (Classpath, URL, and so on).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KieLoggers**: This is a logger configurator for the session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KieStoreServices**: This is a store service that manages the persistency
    of the jBPM and Drools runtime state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KieMarshallers**: Marshalling provides a customizable serialization architecture,
    utility classes, and strategies. We will describe the jBPM flexible marshalling
    architecture in [Chapter 7](ch07.html "Chapter 7. Customizing and Extending jBPM"),
    *Customizing and Extending jBPM*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us start by discussing the KIE API components whose duties are related to
    the jBPM runtime configuration and setup, since all your knowledge artifacts represent,
    at runtime, the engine's building ground for your business process execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The upcoming sections are not logically grouped under this KieServices section
    since they all are KIE first class citizens (classes) and can be used and created
    irrespective of the KieServices factory class. You can find the complete source
    code examples for this chapter in the `jbpm-misc` project.
  prefs: []
  type: TYPE_NORMAL
- en: KieContainer – KIE modules and KieBase(s)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`KieContainer` has been specifically designed to handle a KIE module and resolve
    its dependencies (other KIE modules or Mavenized JARs), even through remote Maven
    repositories. This is a huge improvement in terms of knowledge module sharing
    and management capabilities, compared to older jBPM versions. While a KIE module
    is an assembly that collects a set (archive) of business artifacts and static
    resources, it is the responsibility of KieContainer to organize the KieBase and
    KieSession definitions and to give the user the tools to obtain new ready-to-use
    references for them.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the examples in the `KieContainerTest` class.
  prefs: []
  type: TYPE_NORMAL
- en: '`KieContainer` can use the Java Classpath or the user-provided ClassLoader
    to detect, load, and wrap an existing `KieModule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `getKieClasspathContainer()` function returns `KieContainer` that wraps
    `KieBase` found in your current Classpath (created by parsing the available `kmodule.xml`
    files).
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.html "Chapter 4. Operation Management") *Operation Management*,
    we talked about the new Maven repository integration feature. `KieContainer` is
    able to load KieModule from a Maven repository, given its Maven **GroupId-ArtifactId-Version**
    (**GAV**); use the `ReleaseId` class as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The container, by putting the KIE client repository service at work, is also
    able to dynamically update its definitions starting from a different KIE module,
    given its Maven GAV. As a result, all its existing KieBase assets and KieSession
    definition will be incrementally updated (and the cached class definitions will
    be replaced with newer ones).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'KieBase (KnowledgeBase) is the building block of KieModule. The `KieBase` class
    works as the store for the KieModule knowledge definitions and serves as a dictionary
    for your KIE session. It contains Drools rules, processes, models, and so on.
    By default, these artifacts are searched in the KIE project `resources` root folder,
    but you can set the `packages` attribute to search in a different folder, for
    example (an excerpt of a `kmodule.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This will load artifacts from the `resources/com/packt/masterjbpm6/event` project
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Your KieModule must always have at least one named KieBase (that is, its `name`
    attribute must be set); alternatively, if you decide to use a `default` (that
    is, created without knowing its name) KieBase, omit the `<kbase>` element definition
    altogether in your `kmodule.xml` or leave the `kmodule.xml` empty.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: KieSession does not make much sense without an underlying KieBase. The KIE runtime,
    in case the user is not specifying one, provides you with a default KieBase. This
    default KieBase is KieBase with the attribute `packages="*"`, meaning that it
    is defined with all assets contained in all module packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'KieBase is created by KieContainer and supports inheritance (inclusion) and
    multiple definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Inclusion**: All knowledge artifacts belonging to "included KieBase" are
    added to "including KieBase"; for example, all `kbaseold` resources are added
    to the `kbasenew` KieBase:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The included KieBase must be already available (the KieModule within which it
    is defined has to be deployed) or defined locally (the same `kmodule.xml` file).
    In [Chapter 4](ch04.html "Chapter 4. Operation Management"), *Operation Management*
    (the ManagedVesuvio repository example), the Napoli KieModule's kbase is included
    the Vesuvio's kbase in order to reuse its external process definition as a subprocess;
    let us clarify by looking at their Kie module definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Napoli `kbase` definition (relevant part only) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The Vesuvio `kbase` definition is (relevant part only) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in order to have KIE pick up the main kbase (`kbase-napoli`), we
    set `kbase-vesuvio` kbase's `default` attribute to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multiple definitions**: Multiple KieBase (and KieSession) can be defined
    inside a single KieModule:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the KieBase is defined, you can create a stateful KieSession (the default
    one or a named one, by passing its `name` attribute).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Each KieSession is always paired with a single KieBase: KieContainer actually
    delegates the session creation to its KieBase.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: KieBase and KieSession support a number of declarative configuration settings
    that you can add to your `kmodule.xml` file; please consult the jBPM 6.2 reference
    documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The following class diagram shows the main classes that you have to deal with
    when working with containers (sessions will be discussed in a forthcoming section).
  prefs: []
  type: TYPE_NORMAL
- en: '![KieContainer – KIE modules and KieBase(s)](img/9578OS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The KIE builder API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s very likely that you might have already used `KnowledgeBuilderFactory`
    and `KnowledgeBuilder` to set up `KnowledgeBase`: KnowledgeBuilder parses the
    knowledge source files (process `bpmn` files, Drools `.drl` rule, and so on),
    and turns them into KnowledgePackage that KnowledgeBase can use. The resources
    are identified and added by type (`ResourceType` enum). KnowledgeBase is deprecated,
    but `KieBase` is actually implemented by `KnowledgeBaseImpl`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The KIE API gives you tools specialized in managing KieModule: file creation
    and resource assembling, module dependency management, and building and deployment
    to Maven repositories. The following class diagram shows the main builder related
    classes (for a quick reference purpose only).'
  prefs: []
  type: TYPE_NORMAL
- en: '![The KIE builder API](img/9578OS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the examples in the `KieBuilderTest` and `KieResourceTest` classes.
  prefs: []
  type: TYPE_NORMAL
- en: KieResources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The resource is a contract representation of a knowledge element (process,
    rule, and so on) or a resource that indirectly can be used to load a Kie module
    (for example: a path to `kmodule.xml`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `KieResources` factory eases the task of handling objects in the forms
    of `org.kie.api.io.Resource`; for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This resource represents the path that contains a KIE module.
  prefs: []
  type: TYPE_NORMAL
- en: KieModule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While KieContainer represents an abstraction, the very nature of KieModule
    is based on business asset files (resources): KieModule is a container of all
    the resources needed to define a set of KieBase classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The module project source structure must be compliant with the standard layout
    for a Maven project (such as `src/main/resources`).
  prefs: []
  type: TYPE_NORMAL
- en: '`pom.xml` defining the KieModule Maven GAV'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kmodule.xml` declaring KieBase, KieSession, and their properties'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: knowledge artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KieModule tracks the module dependencies from other Kie modules and from other
    plain JAR archives thanks to the `pom.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: KieBuilder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'KieBuilder allows you to build KieModule by adding resources and configuration
    files through a set of model classes (metamodels), which represent the key KieModule
    components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`KieModuleModel`: A KieModule abstraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KieBaseModel`: A KieBase abstraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`KieSessionModel`: A KieSession abstraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The memory-based filesystem class (`KieFileSystem`) helps you with the creation/writing
    of the KIE module files (`pom.xml` and `kmodule.xml`). The following class diagram
    shows `KieBuilder` and the related classes (details ahead).
  prefs: []
  type: TYPE_NORMAL
- en: '![KieBuilder](img/9578OS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let us see a practical example of KIE metamodel creation and usage in order
    to set up and install a KIE module (with dependencies) from scratch into a Maven
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the complete example in the `KieBuilderTest` class (`testBuilderWithModels`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When your file set is ready, pass `KileFileSystem` (content) to the builder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now perform the "build." The build compiles all module knowledge packages
    and Java classes, validates the configuration files (pom.xml and kmodule.xml),
    and finally, installs the module in the local KIE repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmatically creating KieModule means you have to create the object in
    a file-oriented way, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The runtime will create the file following your KieModule filesystem structure.
  prefs: []
  type: TYPE_NORMAL
- en: Repositories and scanners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Maven repositories, as we already pointed out, are an important piece of the
    new Kie architecture: the repository service allows you to manage module installation
    and dependency resolution with the internal KIE repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a module to the KIE repository store, you must provide the path to the
    `kmodule.xml` file or the path to the built KIE module JAR file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `addKieModule` method accepts the optional module resource dependencies
    (again, in the form of a `kmodule.xml` path or a path to a JAR archive).
  prefs: []
  type: TYPE_NORMAL
- en: 'To load a module from the repository is as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The repository service wraps the internal Maven KIE repository services as well
    as the `KieScanner` service that we are now going to see.
  prefs: []
  type: TYPE_NORMAL
- en: KieScanner
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**KieScanner** is a monitor for Maven repositories (both local and remote)
    used for automatically detecting whether there are updated releases for a given
    KieModule: in case, a new deployed artifact for the module is found, the scanner
    updates KieContainer to reflect the changed definitions (KieBase, KieSession,
    and so on). The KIE module KieBase(s) is rebuilt, and all the new KieSessions
    created from KieContainer will use the updated KIE module definitions.'
  prefs: []
  type: TYPE_NORMAL
- en: The scanner can perform a blocking scan update (the `scanNow()` method), which
    returns after the (eventual) update process is completed, or a background scanning
    process (the `start(long pollingInterval)` and `stop()` methods).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The scanner works only when the paired KieContainer's module Maven version (the
    V from its GAV) is not a FIXED version. Only modules with a version with the qualifier
    SNAPSHOT, LATEST, or RELEASE, or ranged versions are processed. See Maven versions
    reference for additional help.
  prefs: []
  type: TYPE_NORMAL
- en: 'The scan operation performs the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: Build the new Kie module, searching for errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update old module dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the old module assets, compile them, and rebuild the module knowledge
    bases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no build error is detected, the updated module is added to the KIE module
    repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are new or updated classes in use by the knowledge base, then this
    is fully recreated; otherwise, its resources are incrementally updated. Obsolete
    knowledge bases and sessions (whose definition has been removed) are deleted from
    the Kie container. The general advice with the scanner is to be very cautious
    and to evaluate its impacts on a case-by-case basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example `KieScannerTest` class provides you with two test methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`testScannerUpdateNewSession`: This verifies whether a Kie module process definition
    gets updated after the scan process by creating a new session and verifying that
    the update process variable returns a different value from the original definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`testScannerSameSessionAfterUpdate`: This verifies whether after the scan,
    the existing session continues using its old process definition, while a new KIE
    session picks up the updated process definition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The scanner is a nice improvement over the previous jBPM knowledge base update
    mechanism (KnowledgeAgent) since it works in tight integration with Maven and
    provides the implementer with an asset-oriented programming style in handling
    KIE modules, Kie project sources, and assets. This great addition makes jBPM fit
    a lot better in the typical agile, lean development environment. Just think about
    the possibilities you have when integrating with **Continuous Integration** (**CI**),
    deployment, and automated test tools. You may have a scanner process that checks
    your nightly build Maven repo trunk, updates your KIE module with the latest development
    version of your assets, and triggers your automated test suite.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The KieScanner API implementation and utility classes belong to the `kie-ci`
    project ([https://github.com/droolsjbpm/drools/tree/master/kie-ci](https://github.com/droolsjbpm/drools/tree/master/kie-ci)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The Scanner API also provides a Maven helper class, which manages artifact
    lookup and deployment to the system Maven repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `KieScannerTest` jUnit test class exercises the scanner and the builder
    API. It creates and deploys a new release for the `pizzadelivery` KieModule (the
    `buildModuleForScannerUpdate` method) and then, starts the scanner update process
    (the `testScannerUpdate()` method).
  prefs: []
  type: TYPE_NORMAL
- en: KieLoggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The KieLoggers factory allows you to create audit loggers that produce log
    traces of all the events occurring during the execution of a specific KIE session.
    The following types of loggers are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**File based logger**: Logger to file with a default `.log` extension; it traces
    the event in an XML serialized format:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the `KieLoggersTest.testLoggers` method for the complete example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Console based logger**: Traces the log to the standard output:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here you have an example when running the `testRuleWithConsoleLogger` method;
    you can see the insertion of the Drools fact and the Drool rule triggering:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Threaded logger: Same as the file-based logger but executes writes to the file
    in an asynchronous fashion; it features an option to set the write (flush) interval
    period in milliseconds, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the `testRuleWithThreadedLogger` example for the complete example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Logger classes extend `WorkingMemoryLogger`, which implements all the available
    event listener interfaces: `Process`, `Agenda`, `Rule`, and (KIE) KnowledgeBase.
    Since several events are generated, you''re given the ability to control event
    filtering with the following methods: `addFilter`, `removeFilter`, and passing
    an `ILogEventFilter` implementing class. We can declare and configure the KieSession
    loggers directly in the `kmodule.xml` file, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following class diagram shows the loggers and the event listener interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![KieLoggers](img/9578OS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: KieStoreServices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`org.kie.api.persistence.jpa.KieStoreServices` is an interface that defines
    the contract for the KIE session persistence service. Its default implementation
    is the `org.drools.persistence.jpa.KnowledgeStoreServiceImpl` class. Let us have
    a look at how `KieStoreServices` can be used to restore KIE sessions by using
    the session ID. The following example is an excerpt of the `StorageTest.testRuleWithStorageServer`
    method. It demonstrates how you can load your Kie session safely from the persistence
    store and execute the business process consistently.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: RuntimeManager service and the engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`RuntimeManager` has been introduced to simplify the configuration of `KieBase`
    (`KnowledgeBase`) and `KieSession` (`KnowledgeSession`). Its main duty is to manage
    and create instances of `RuntimeEngine` according to predefined strategies (see
    the *Runtime strategy* section).'
  prefs: []
  type: TYPE_NORMAL
- en: '`org.kie.api.runtime.manager.RuntimeEngine` is the entry point to the engine
    services; its main purpose is to provide the user with pre-configured and ready-to-use
    engine components:'
  prefs: []
  type: TYPE_NORMAL
- en: KieSession
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TaskService
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AuditService
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`org.kie.api.runtime.manager.RuntimeManager` unburdens the user from the development
    of a typical boilerplate code; it sets up the execution environment for processes
    (wrapping the KieSession and the task service into the RuntimeEngine) and manages
    the following Drools services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scheduler service**: The scheduler service manages timer-based jobs for execution
    (we have seen it in [Chapter 4](ch04.html "Chapter 4. Operation Management"),
    *Operation Management*, and [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"),
    *BPMN Constructs* with *Async task*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TimerService**: Implements timer services for the sessions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The runtime manager registers the following items on the session:'
  prefs: []
  type: TYPE_NORMAL
- en: Process workitem handlers (also the default `human task` workitem handler which
    is responsible for managing task nodes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RuntimeManager` implements a runtime strategy that lets you choose how to
    manage your KieSession life cycle; let us see the available strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Singleton (default jBPM strategy for a Kie module)**: The runtime manages
    only one shared `RuntimeEngine` instance (only one Kie session is active and shared)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PerProcessInstance**: The manager uses a dedicated Kie session for each process
    instance; the Kie session life cycle spans the process instance duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PerRequest**: Invoking the `getRuntimeEngine()` method returns a new `RuntimeEngine`
    instance (creating a new Kie session and task service each time)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RuntimeManager` must be created from `RuntimeManagerFactory`, calling one
    of its specialized factory methods according to the chosen runtime strategy (`newSingletonRuntimeManager()`,
    `newPerRequestRuntimeManager()`, or `newPerProcessInstanceRuntimeManager()`) and
    passing an instance of `org.kie.api.runtime.manager.RuntimeEnvironment`.'
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right strategy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You shall choose the right runtime strategy mainly depending on your business
    and system specifications. Requirements may constrain you to keep isolated jBPM
    session working memories (for example, one session per process instance); in other
    words, each session owns its rules, facts, and objects. This could be the case
    for short-lived processes in a heavily concurrent system where you need low resource
    contention and high throughput.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton strategy, on the other hand, manages a single-thread safe session
    (with synchronized access). This could lead to performance issues in highly concurrent
    environments (web) but would also allow for all jBPM sharing capabilities (facts
    and globals shared among all processes, scope of signals across your entire working
    memory, and so on). These are just general insights into the matter, and you should
    aim at evaluating your own strategy pros and cons according to your system and
    functional requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The RuntimeEnvironment class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This class encapsulates the environment configuration required by `RuntimeManager`;
    we instantiate it by using the `RuntimeEnvironmentBuilder` helper class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`RuntimeEnvironmentBuilderFactory` has several helper methods targeted to create
    preconfigured specialized `RuntimeEnvironmentBuilder` enabled for persistence,
    based on the classpath KIE container (`kmodule.xml`), based on a KIE module (JAR
    file), and so on. Since the builder wraps all the configuration details, it exposes
    methods to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add an asset (a BPMN process, Drools rule, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set custom `UsergroupCallback`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set a Knowledge Base (in case your `RuntimeEnvironmentBuilder` is not a KIE
    module classpath builder)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set Entity Manager Factory to enable JPA persistence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'RuntimeManagers are identified by unique identifiers. The runtime won''t accept
    the creation of `RuntimeManager` with the same id of another active `RuntimeManager`.
    The following diagram shows the interactions that take place during the runtime
    initialization and that involve the main KIE components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The RuntimeEnvironment class](img/9578OS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Runtime Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`RuntimeManager` can handle contextual information to look up a specific `RuntimeEngine`
    implementation, depending on the chosen strategy; the context is passed as a `org.kie.api.runtime.manager.Context`
    generic interface implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EmptyContext`: Context used with Singleton or PerRequest RuntimeManager; no
    specific information is used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CorrelationKeyContext`: Used with PerProcessInstance RuntimeManager to find
    `RuntimeEngine` by using a process instance correlation key'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessInstanceIdContext`: Used with PerProcessInstance RuntimeManager to
    find `RuntimeEngine` (and the Kie session) by using a process instance ID'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To avoid resource leakage, it is strongly recommended to dispose `RuntimeManager`
    at the end of a work session, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: KieSession
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KieSession is a stateful session that maintains its conversational state with
    the engine, across multiple interactions. It is the best way to interact with
    the engine. Sessions are created starting from KieContainer, KieBase, or configured
    RuntimeEngine, which always delegates to KieBase but gives you the flexibility
    of choosing a session runtime policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the enabling of persistence, the session is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**In-memory session**: All data related to session and the engine status is
    kept in memory and lost on engine restart'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JTA session**: Session persisted through a JPA EntityManager and a JTA transaction
    manager'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a new (stateful) KieSession, we configure the environment and we
    use `JPAKnowledgeService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The example uses **Bitronix Transaction Manager** (**BTM**) (more on this in
    the *Persistence and transaction* section).
  prefs: []
  type: TYPE_NORMAL
- en: The returned `StatefulKnowledgeSession` is of type `CommandBaseStatefulKnowledgeSession`,
    which decorates the session implementation (`StatefulKnowldgeSessionImpl`) with
    a command service of type `SingleSessionCommandService` (see the following class
    diagram).
  prefs: []
  type: TYPE_NORMAL
- en: '`SingleSessionCommandService` transparently manages, through the `TransactionInterceptor`
    class, the persistence of the stateful session by the JPA `SessionInfo` entity
    class.'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless KieSession
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The stateless KIE session is a wrapper to a stateful session, which the runtime
    creates and disposes for the duration of a single command execution so that it
    does not maintain a conversational state and cannot persist.
  prefs: []
  type: TYPE_NORMAL
- en: Globals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'KieSession manages `globals`; globals are objects used to pass information
    into the engine that can be used in processes or rules. Globals are shared across
    all processes and rule instances. Let us see what KieSession methods can handle
    them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`getGlobals()`: Returns the internal globals resolver'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getGlobal (String)`: Returns the global object given its identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setGlobal(String, Object)`: Sets the global object assigning it an identifier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following class diagram shows details for the Session classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Globals](img/9578OS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The CommandExecutor interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All KIE sessions (both stateless and stateful) implement the `CommandExecutor`
    interface, a service that lets you execute a single command or a batch of commands.
    Let us look at some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process/Task**: `CompleteWorkItemCommand`, `AbortWorkItemCommand`, `StartProcessCommand`,
    and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Drools Rules**: `FireAllRulesCommand`, `GetFactHandleCommand`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: `GetGlobalCommand`, `SetGlobalCommand`, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, you would call the higher-level jBPM API methods (using the session
    or the task service reference), but sometimes, it could be handy to use the command
    classes for batching, scheduling purposes, or management operations. All the command
    classes support XML binding thanks to standard annotations (`@XmlRootElement`,
    `@XmlAttribute`, `@XmlElement`, and so on) and so, can be easily serialized or
    passed remotely. Commands can be created using `CommandFactory` or by simply instantiating
    a specific command class, which is then executed by invoking the session `execute`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now have a look at how these commands can be created and executed from
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can instantiate the command on your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Batch execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The session supports the execution of a batch of commands by a specialized
    `BatchExecutionCommand`. Here, we rewrite the `RuleTaskTest` test class of [Chapter
    5](ch05.html "Chapter 5. BPMN Constructs"), *BPMP Constructs*, by using three
    different commands (see the `CommandsTaskTest.testRuleWithCommand` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`BatchExecutionCommand` executes the enlisted commands in the exact order that
    they have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that `BatchExecutionCommand`, like all Command classes, supports serialization,
    so you can pass it remotely for execution or easily persist it for scheduled processing.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even `CompositeCommand` can execute multiple commands sequentially, but it supports
    human task commands only (inheriting from `TaskCommand`). This command is used
    internally by the task service (see the *Human Task service* section).
  prefs: []
  type: TYPE_NORMAL
- en: Event listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'KIE session can register multiple specialized listeners for different kinds
    of event notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Process**: `ProcessEventListener` is related to process instance execution
    (we saw ProcessEventListener in the *KieLoggers* section).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule**: `RuleRuntimeEventListener` for events related to facts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agenda**: `AgendaEventListener` for events related to Drools Agenda. Agenda
    is a Drools component that keeps track of rule activations (rule matching) and
    rule action execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By providing a custom implementation of one of these interfaces, you can get
    the filtered session events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All the logger classes obtained from the `KieLoggers` service extend the abstract
    `WorkingMemoryLogger` class, which implements the preceding three interfaces.
    We will see more on event and auditing in the *Audit and history logs* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can declaratively register listeners inside the `kmodule.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Channels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Channels are communication hoses that can be established between your jBPM application
    and the engine, through your KIE working session. Their main purpose is to allow
    sending objects from the session working memory to a generic external process
    or function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see the basics: You must implement the `org.kie.api.runtime.Channel`
    interface and register it with the session, assigning a name to the channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The channel can be used to notify the jBPM application, for instance, of a
    rule execution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The list of existing channels can be retrieved from the session by calling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Check the `ChannelsTaskTest.testRuleWithChannel()` method for a working example.
  prefs: []
  type: TYPE_NORMAL
- en: Human Task service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced the human tasks in the previous chapter; we described the human
    task state transitions, task rule assignments, and task operations performed by
    the stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the `org.kie.api.task.TaskService` task service from `RuntimeEngine`
    (the `getTaskService()` method), which is a wrapper for the service; the task
    service is created and wrapped into `RuntimeEngine` (and the underlying session)
    by `RuntimeManager`, which uses `TakServiceFactory`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The factory used to instantiate `TaskService` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LocalTaskServiceFactory`: To be used in non-CDI environments'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The factory configures the task service with the following references:'
  prefs: []
  type: TYPE_NORMAL
- en: '`EntityManagerFactory` instance (taken from `RuntimeEnvironment`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UserGroupCallback` (taken from `RuntimeEnvironment`). If no custom `UserGroupCallback`
    implementation is provided, a default `MvelUserGroupCallbackImpl` is used; this
    loads the `UserGroupsAssignmentsOne.mvel` file from `jbpm-human-task-core-6.2.0.Final.jar`
    (the `org\jbpm\services\task\identity` package).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Register task event listeners (instances of the `TaskLifeCycleEventListener`
    interface).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TaskDeadlinesService`: This service is responsible for the management of the
    deadlines defined for a task and for triggering notifications (we talked about
    escalations and notifications in [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"),
    *BPMN Constructs*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The factory also shares, at the environmental level, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Default `DefaultUserInfo` instance (loaded with data from a `userinfo.properties`
    file in the classpath, if any)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The task service leverages Commands to execute all common task operations; commands
    are executed via `CommandService`. Let us look at this service class and its inner
    working details.
  prefs: []
  type: TYPE_NORMAL
- en: CommandService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RuntimeManager creates two different types of TaskService:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CommandBasedTaskService`: The default task service implementation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SynchronizedTaskService`: A synchronized task service instance that wraps
    `CommandBasedTaskService`. It is created using the Singleton runtime strategy'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommandBaseTaskService` delegates the API executions to its internal `CommandService`
    executor. This is CommandExecutor and performs all the task API calls as in the
    KIE session (see the dedicated *The CommandExecutor interface* section), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The start (task) method, for instance, is executed as `CompositeCommand` built
    with two TaskCommand specializations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`StartTaskCommand`: It performs the task start operation by changing the state,
    triggering events on listeners, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CancelDeadlineCommand`: Cancel the matching deadline (if any) for this task''s
    Start event (see the *Deadlines and escalations* and the *Notifications* sections
    in [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN*)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompositeCommand` first executes the command from the varying argument `commands`
    and then, the `mainCommand` command. Its constructor signature is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: TaskCommand and UserGroupCallback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All task commands inherit from the `UserGroupCallbackTaskCommand` class; they
    call specific parent class methods on their `execute` method in order to trigger
    updates to the `ORGANIZATIONALENTITY` database table.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskContext command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Upon instantiation, each task command is given `TaskContext` from `CommandExecutor`;
    the context duties are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides a `JPATaskPersistenceContext` instance, which handles all the database-related
    operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Triggers task lifecycle-related events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides the core task-related services to the command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main task services provided are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instance service** (`TaskInstanceService`): The core service that implements
    the WS Human Task specification with respect to the task life cycle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query service** (`TaskQueryService`): It returns read-only task instance
    information such as a list of tasks assigned to a user, potential owners for a
    given task, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Content service** (`TaskContentService)`: It manages task content data (input
    and output)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deadline service** (`TaskDeadlineService`): It manages the scheduling of
    task deadlines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Attachment service** (`TaskAttachmentService`): It deals with task attachment
    management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin service** (`TaskAdminService`): It provides out-of-the-standard task
    life cycle operations such as task removal and task archival'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks can be removed (literally deleted from the jBPM persistent store, making
    them unavailable for user assignments) but only after they have been marked as
    "archived."
  prefs: []
  type: TYPE_NORMAL
- en: Transactions and interceptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TaskService CommandService is implemented by a `TaskCommandExecutorImpl` class,
    which, during initialization, is decorated with an `org.jbpm.services.task.persistence.TaskTransactionInterceptor`
    interceptor. The interceptor wraps each `execute` method invocation of the command
    service between transaction boundaries managed by the Drools `JtaTransactionManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Notification service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"), *BPMN Constructs*,
    we talked about the human task escalations and notifications features. The jBPM
    notification service relies on email messaging; thus, to work successfully, it
    requires the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A mail session properly configured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `UserInfo` class instance defined; this provides the user's e-mail address
    to notify
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: jBPM loads the mail session by a **Java Naming and Directory Interface** (**JNDI**)
    lookup; you can set the JNDI name through the `org.kie.mail.session` system property
    or, alternatively, provide the JNDI name `mail/jbpmMailSession` in your application
    server.
  prefs: []
  type: TYPE_NORMAL
- en: If no JNDI resource is found, jBPM fallbacks to a plain `email.properties` file
    loaded from the classpath.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file defines the following properties (example values are provided):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We covered the `UserInfo` class in [Chapter 5](ch05.html "Chapter 5. BPMN Constructs"),
    *BPMN Constructs*.
  prefs: []
  type: TYPE_NORMAL
- en: The TaskFluent class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `TaskFluent` class is a helper class that lets you conveniently configure
    and create a new `Task` instance and add it to the persistent store through the
    task service (see the `FluentTest` test class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The WS-HumanTask specification defines the role of the administrator as the
    one who can manage the life cycle of the task, even though he might not be enlisted
    among the task potential owners. With releases older than jBPM 6, an "Administrator"
    user was created by default by jBPM.
  prefs: []
  type: TYPE_NORMAL
- en: The `addTask` operation requires you to add at least one potential business
    administrator for the task (by the `setAdminUser()` or `setAdminGroup()` method).
    The business administrator entity (user or group) is verified by the runtime with
    the current `UserGroupCallback` to check whether it exists. To check whether business
    administrators are task potential owners search the `PEOPLEASSIGNMENTS_BAS` jBPM
    database table.
  prefs: []
  type: TYPE_NORMAL
- en: To ease the test configuration, all our jUnit test classes are configured with
    a custom user callback, which lets all users pass (see the `MyUserCallback` class),
    so that "Administrator," "boss," or whatever makes no difference.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime will evaluate the task assignments and their deadlines, and will
    store the task data; the engine assigns to the task, the initial state `CREATED`.
  prefs: []
  type: TYPE_NORMAL
- en: The `FluentTest` example shows how it is possible to programmatically create,
    add, assign, start, and complete new tasks outside the scope of a process definition
    (ad hoc tasks).
  prefs: []
  type: TYPE_NORMAL
- en: '`TaskFluent` lets you attach a new task to a given process instance. Since
    the new task has no incoming/outgoing connections, this could be of limited use,
    but it fits very well with ad hoc processes (see [Chapter 5](ch05.html "Chapter 5. BPMN
    Constructs"), *BPMN Constructs*), for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Audit and history logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Auditing is the ability of the engine to let the user configure the collection
    and the retrieval of events relative to the runtime process execution. We introduced
    auditing and BAM in [Chapter 4](ch04.html "Chapter 4. Operation Management"),
    *Operation Management*, and now, we are going to see how to leverage the engine
    services to implement auditing at various levels.
  prefs: []
  type: TYPE_NORMAL
- en: When persistence is enabled, ready-to-use preconfigured `AuditService` (implemented
    by `JPAAuditLogService`) can be borrowed from `RuntimeEngine`; it returns process,
    node, and variable runtime audit data (see the class diagram) from the three standard
    jBPM auditing database tables (`ProcessInstanceLog`, `NodeInstanceLog`, and `VariableInstanceLog`).
    The audit service stamps each log entry with an `OwnerID` attribute, which matches
    the unique identifier of its RuntimeManager.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This AuditService usage approach (basically as a query service) is a solution
    that can be good for BAM or history analysis; however, if we want to collect audit
    data in real-time, we have to register a listener with the KIE session (see the
    *Event listeners* section or the next section).
  prefs: []
  type: TYPE_NORMAL
- en: AuditLoggerFactory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This factory can create ready-to-use JPA- or JMS-enabled audit loggers (see
    the following class diagram):'
  prefs: []
  type: TYPE_NORMAL
- en: '**JPA**: A synchronous logger that by default persists the audit events between
    engine JTA transaction boundaries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JMS**: Asynchronous logger aimed at JMS queue integration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember that the logger has to be bound to KieSession to start logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set a different EntityManager on the JPA logger by providing custom
    EntityManagerFactory to a directly instantiated (no factory) `JPAAuditLogService`
    and, optionally, choosing an auditing strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows us to adapt the engine logging service to our persistence layer
    configuration and transaction management: local entity manager and JTA. The main
    purpose of the strategy is to instruct jBPM to manage transactions when auditing
    in different application environments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The KIE auditing strategies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**KIE_SESSION**: Select this strategy when you use the entity manager only
    with KieSession (default behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STANDALONE_LOCAL**: Choose this strategy when your application uses the entity
    manager outside the scope of KieSession'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**STANDALONE_JTA**: Same as the previous strategy but uses `java:comp/UserTransaction`
    or `java:jboss/UserTransaction` to resolve the transaction (application servers
    only)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We show the relevant classes in the following class diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AuditLoggerFactory](img/9578OS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Custom logger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To implement custom logging of audit events, you have to extend the `AbstractAuditLogger`
    class or provide a new implementation for the `ProcessEventListener` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The supported audit events are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Events are delivered as the following `ProcessEvent` implementation classes:
    `ProcessNodeEvent`, `ProcessStartedEvent`, `ProcessCompletedEvent`, and `ProcessVariableChangedEvent`.
    In order to convert the incoming typed events to Log JPA entity classes (that
    is, `VariableInstanceLog`), you can use a helper class (`DefaultAuditEventBuilderImpl)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Persistence and transactions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default persistence mechanism of the jBPM engine is based on the JPA 2/Hibernate
    implementation. Each engine operation (start process, start task, complete task,
    and so on) is run inside the scope of a transaction. `TransactionInterceptor`
    demarcates each command execution and eventually, depending on the transaction
    management used (**Container Managed Transactions** (**CMT**) or UserTransaction
    **Bean Managed Transactions** (**BMT**)), enlists the EntityManager engine in
    the ongoing transaction. We have seen how both session and task persistence works
    through `CommandService` and the interceptor architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The default engine persistence configuration boils down to the engine persistence
    unit (defined in a `persistence.xml` file configuration) and, usually, to a JTA
    datasource definition at the application server level. jBPM imposes no constraints
    on the number of entity managers defined; you can obviously have a number of persistence
    units defined in your application and make multiple entity managers coexist with
    jBPM Entity Manager. You can have a single database (single Entity Manager) for
    both jBPM and your application persistence layer or a dedicated jBPM database
    (and Entity Manager) and make the engine participate in your business application
    transactions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Chapter 8](ch08.html "Chapter 8. Integrating jBPM with Enterprise Architecture"),
    *Integrating jBPM with Enterprise Architecture*, of the jBPM 6.2 user guide explains
    the detailed configuration and usage of transactions.'
  prefs: []
  type: TYPE_NORMAL
- en: Local transactions with Bitronix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are going to see a complete jBPM persistence example configuration using
    local transactions. Bitronix is an open source Transaction Manager framework;
    it supports JTA API and the **Extended Architecture** (**XA**) protocol and perfectly
    fits all cases where a straightforward persistence configuration is needed. The
    required configuration steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the datasource (pooled): The datasource will be bound to the `jdbc/localjbpm-ds`
    JNDI name as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `jndi.properties` file in your classpath resources, which includes
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This lets Bitronix context factory initialize the environment and bind transaction
    service objects to default JNDI names, notably the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: User transaction manager at `java:comp/UserTransaction`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tx synchronization registry at `java:comp/TransactionSynchronizationRegistry`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Edit your `persistence.xml` file, specifying the Bitronix datasource name as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can create your `EntityManagerFactory` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Managing transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: jBPM provides an out-of-the-box transactional service to an enterprise application,
    which is able to participate in the existing transaction right from the calling
    application, so in case of an error (for example, a custom workitem handler throws
    an exception or a process node script fails), the engine transaction is marked
    for rollback and the exception is sent to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us now see a common example of **Entity Manager** (**EM**) and jBPM (managed
    by Bitronix) working together (please refer to the `AuditTxTest` test class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Locking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default JPA transaction locking scheme used is optimistic. If you need
    to switch to a pessimistic locking mode, set the following parameter to `TRUE`
    in your `org.kie.api.runtime.Environment` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This forces the engine to hold the lock on an entity (locking of type `LockModeType.PESSIMISTIC_FORCE_INCREMENT`)
    to ensure that the object is not modified.
  prefs: []
  type: TYPE_NORMAL
- en: '![Locking](img/9578OS_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, we took an extensive tour to the core engine components and
    services, not disregarding some of the engine inner implementation details. You
    should now be able to understand how the engine works and what happens "behind
    the curtains" when you use a specific engine feature.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will deal with the engine customization and extension process
    in order to tailor the jBPM system features to your solution.
  prefs: []
  type: TYPE_NORMAL
