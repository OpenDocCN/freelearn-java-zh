<html><head></head><body>
		<div id="_idContainer064">
			<h1 class="chapter-number" id="_idParaDest-115"><a id="_idTextAnchor123"/>7</h1>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor124"/>Adding Spring Boot Security with JWT</h1>
			<p>In the previous chapter, we learned mainly how to generate automated documentation for our created APIs in our Spring Boot project. We learned how to add and use  the features and properties of <strong class="source-inline">springdoc-openapi</strong>, configure the plugin on the project, and access the generated JSON and YAML documentation. We also learned how to implement the Swagger UI to make our documentation interactive and allow us to test endpoints directly on <span class="No-Break">the browser.</span></p>
			<p>This chapter <a id="_idIndexMarker441"/>will now focus on the security side of our application. We will discuss the concept of <strong class="bold">Cross-Origin Resource Sharing</strong> (<strong class="bold">CORS</strong>) and how it can secure our application. We will also be discussing the features <a id="_idIndexMarker442"/>and implementation of Spring Security in Spring Boot, the <a id="_idIndexMarker443"/>concept of <strong class="bold">JSON Web Token</strong> (<strong class="bold">JWT</strong>), and <strong class="bold">Identity as a </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IDaaS</strong></span><span class="No-Break">).</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li><span class="No-Break">Understanding CORS</span></li>
				<li>Adding a <span class="No-Break">CORS policy</span></li>
				<li>Understanding <span class="No-Break">Spring Security</span></li>
				<li>Authentication and authorization in <span class="No-Break">Spring Boot</span></li>
				<li><span class="No-Break">IDaaS</span></li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor125"/>Technical requirements</h1>
			<p>The link to the finished version of this chapter’s code is <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-07/superheroes"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-07/superheroes</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor126"/>Understanding CORS</h1>
			<p>We might have already encountered the term CORS several times when creating our applications as developers. Still, we may ask questions such as what does CORS do? Or what is the <a id="_idIndexMarker444"/>advantage of implementing CORS in our application? With these questions in mind, we will dive deeply, in this section, into the concepts and features of CORS and understand how it is used to secure <span class="No-Break">our applications.</span></p>
			<p>CORS is a header-based mechanism that allows a server to define a set of domains, schemes, or ports permitted to access the application’s resources. CORS is commonly used in REST APIs. Different frontend applications can access the APIs under our backend applications, especially in complex architectures. We don’t want our APIs to be accessed by unknown applications, and CORS is responsible for securing <span class="No-Break">this part.</span></p>
			<p>Let’s see a simple example of a cross-origin request. Say we have a frontend application with a domain of <strong class="source-inline">https://domain-one.com</strong> and a backend application served with a domain of <a href="https://domain-two.com">https://domain-two.com</a>. We can see that our application is served with different domains, and once the frontend application sends a request to the backend, this is considered a <span class="No-Break">cross-origin request.</span></p>
			<p>We should never forget that browsers restrict cross-origin requests by default, and same-origin requests are the only ones allowed for requesting resources unless the origin requesting the resources includes the proper CORS headers and is permitted on the backend application. This is just a simple example of how CORS works. Let’s look at a more detailed overview of the concept <span class="No-Break">of CORS.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor127"/>How CORS works</h2>
			<p>CORS is a <a id="_idIndexMarker445"/>header-based mechanism, which means that the first step to achieving cross-origin sharing is to add new HTTP headers that will describe the list of origins that are permitted to access resources. These headers can be described as our key to communication. The HTTP headers are divided into two categories, which are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break">Request headers</span></li>
				<li><span class="No-Break">Response headers</span></li>
			</ul>
			<h3>Request headers</h3>
			<p>Request <a id="_idIndexMarker446"/>headers are the headers required for the client to <a id="_idIndexMarker447"/>make use of the CORS mechanism. They are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">Origin</strong>: This indicates the origin of the requesting client or simply the host of your <span class="No-Break">frontend application.</span></li>
				<li><strong class="source-inline">Access-Control-Request-Method</strong>: This header is used on a preflight request to indicate the HTTP method used to make <span class="No-Break">the request.</span></li>
				<li><strong class="source-inline">Access-Control-Request-Headers</strong>: This header is used on a preflight request to indicate the list of HTTP headers used for <span class="No-Break">the request.</span></li>
			</ul>
			<p>Let’s see an example of what a request would look like using the <span class="No-Break">request headers:</span></p>
			<pre class="console">
curl -i -X OPTIONS localhost:8080/api/v1 \
-H 'Access-Control-Request-Method: GET' \
-H 'Access-Control-Request-Headers: Content-Type, Accept' \
-H 'Origin: http://localhost:4200</pre>
			<h3>Response headers</h3>
			<p>Response <a id="_idIndexMarker448"/>headers are the headers that the servers send back with the <a id="_idIndexMarker449"/>response. They are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">Access-Control-Allow-Origin</strong>: This is a header used to specify the origin of accessing the resource on <span class="No-Break">the server.</span></li>
				<li><strong class="source-inline">Access-Control-Expose-headers</strong>: This header indicates the headers that the browser <span class="No-Break">can access.</span></li>
				<li><strong class="source-inline">Access-Control-Max-Age</strong>: This is a header that indicates the information of preflight <span class="No-Break">request expiration.</span></li>
				<li><strong class="source-inline">Access-Control-Allow-Credentials</strong>: This is a header that indicates that a browser can access the response when the request has <span class="No-Break">valid credentials.</span></li>
				<li><strong class="source-inline">Access-Control-Allow-Headers</strong>: This header indicates the list of headers allowed to be used in <span class="No-Break">a request.</span></li>
				<li><strong class="source-inline">Access-Control-Allow-Methods</strong>: This is a header that indicates the list of request methods that are allowed to be used in <span class="No-Break">the server.</span></li>
			</ul>
			<p>Let’s see <a id="_idIndexMarker450"/>an example of what <a id="_idIndexMarker451"/>response we would like with the <span class="No-Break">given headers:</span></p>
			<pre class="console">
HTTP/1.1 204 No Content
Access-Control-Allow-Origin: *
Access-Control-Allow-Methods: GET,HEAD,PUT,PATCH,POST,DELETE
Vary: Access-Control-Request-Headers
Access-Control-Allow-Headers: Content-Type, Accept
Content-Length: 0
Date: Sun, 16 Nov 2022 3:41:08 GMT+8
Connection: keep-alive</pre>
			<p>These are the standard headers that we will use to allow the CORS mechanism, but there are several different scenarios in which cross-origin <span class="No-Break">sharing works.</span></p>
			<h4>Simple requests</h4>
			<p>These are <a id="_idIndexMarker452"/>requests that don’t trigger CORS preflight <a id="_idIndexMarker453"/>requests and, having no initial request, will be sent to the server for validation. To consider a request to be simple, it should satisfy the <span class="No-Break">following conditions:</span></p>
			<ul>
				<li>Uses the <strong class="source-inline">POST</strong> and <span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break"> methods.</span></li>
				<li>Contains headers that can be manually set, such as <strong class="source-inline">Accept</strong>, <strong class="source-inline">Accept-Language</strong>, <strong class="source-inline">Content-Language</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Content-Type</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">Content-Type</strong> should have one of the following types: <strong class="source-inline">text/plain</strong>, <strong class="source-inline">multipart/form-data</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">application/x-www-form-urlencoded</strong></span><span class="No-Break">.</span></li>
				<li>No <strong class="source-inline">ReadableStream</strong> object is used in <span class="No-Break">the request.</span></li>
			</ul>
			<p>Let’s see an example of a <span class="No-Break">simple request:</span></p>
			<pre class="console">
GET /content/test-data/ HTTP/1.1
Host: example.host
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://frontend.com</pre>
			<p>This request <a id="_idIndexMarker454"/>will perform a simple exchange between <a id="_idIndexMarker455"/>the client and the server. In response, the server returns the header with <strong class="source-inline">Access-Control-Allow-Origin: *</strong>, which means that the resource or endpoint can be accessed by <span class="No-Break">any origin.</span></p>
			<h4>Preflight requests</h4>
			<p>The browser <a id="_idIndexMarker456"/>sends a test or first HTTP request using the <strong class="source-inline">OPTIONS</strong> method to validate that the request is permitted or safe. Preflight <a id="_idIndexMarker457"/>requests will always occur on cross-origin requests as preflight requests check whether a different origin is allowed or permitted to access <span class="No-Break">the resource.</span></p>
			<p>Let’s see an example of a <span class="No-Break">preflight request:</span></p>
			<pre class="console">
OPTIONS /content/test-data/ HTTP/1.1
Host: example.host
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Connection: keep-alive
Origin: https://frontend.com
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-PINGOTHER, Content-Type</pre>
			<p>The preceding example shows that the preflight request uses the <strong class="source-inline">OPTIONS</strong> request method to <a id="_idIndexMarker458"/>execute the preflight request. The <strong class="source-inline">OPTIONS</strong> method is <a id="_idIndexMarker459"/>used to identify more information from the servers to know whether the actual request <span class="No-Break">is permitted.</span></p>
			<p>We can also see that <strong class="source-inline">Access-Control-Request-Method</strong> and <strong class="source-inline">Access-Control-Request-Headers</strong> are identified. This indicates the request headers and request method to be used in the <span class="No-Break">actual request.</span></p>
			<p>Here is the <span class="No-Break">header info:</span></p>
			<pre class="console">
HTTP/1.1 204 No Content
Date: Sun, 16 Nov 2022 3:41:08 GMT+8
Server: Apache/2
Access-Control-Allow-Origin: https://frontend.com
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive</pre>
			<p>Now, in the <a id="_idIndexMarker460"/>preceding example, this is an example <a id="_idIndexMarker461"/>response returned after the preflight request. <strong class="source-inline">Access-Control-Allow-Origin</strong> indicates that access to resources is only allowed on the specified domain (<strong class="source-inline">https://frontend.com</strong> in the example). <strong class="source-inline">Access-Control-Allow-Methods</strong> confirms that <strong class="source-inline">POST</strong> and <strong class="source-inline">GET</strong> are valid methods. <strong class="source-inline">Access-Control-Allow-Headers</strong> ensures that <strong class="source-inline">X-PINGOTHER</strong> and <strong class="source-inline">Content-Type</strong> are proper headers for the <span class="No-Break">actual request.</span></p>
			<p>We have learned the basic concepts of CORS; now, we will implement CORS in our Spring Boot application in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor128"/>Adding a CORS policy</h1>
			<p>We have <a id="_idIndexMarker462"/>learned how CORS works and the advantage it brings to the security of our applications. Now, we will configure and implement a CORS policy in our Spring <span class="No-Break">Boot project.</span></p>
			<p>There are several ways to configure CORS on our project. We will discuss them one <span class="No-Break">by one.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor129"/>CORS applications for each method</h2>
			<p>We can <a id="_idIndexMarker463"/>enable CORS on a single endpoint; this <a id="_idIndexMarker464"/>means that we can specify different permitted origins for other endpoints. Let’s have a look at the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
@CrossOrigin
@GetMapping
public List&lt;AntiHeroDto&gt; getAntiHeroes(Pageable pageable) {
  ..code implementation
}</pre>
			<p>In our Spring Boot project, we have the <strong class="source-inline">getAntiHeroes()</strong> method. To enable CORS on a specific method, we will use the <strong class="source-inline">@CrossOrigin</strong> annotation. We can see that we have not configured any other settings, and this applies <span class="No-Break">the following:</span></p>
			<ul>
				<li>All origins <span class="No-Break">are permitted.</span></li>
				<li>HTTP methods that are allowed are the ones configured for the method (in this method, the allowed HTTP method <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">GET</strong></span><span class="No-Break">).</span></li>
				<li>The time of the preflight response is cached at <span class="No-Break">30 minutes.</span></li>
			</ul>
			<p>We can <a id="_idIndexMarker465"/>also specify the configuration of the CORS <a id="_idIndexMarker466"/>policy by adding the values of the origin, methods, <strong class="source-inline">allowedHeaders</strong>, <strong class="source-inline">exposedHeaders</strong>, <strong class="source-inline">allowedCredentials</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">maxAge</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
@CrossOrigin(origin = "origin.example")
@GetMapping
public List&lt;AntiHeroDto&gt; getAntiHeroes(Pageable pageable) {
  ..code implementation
}</pre>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor130"/>CORS applications at the controller level</h2>
			<p>In the <a id="_idIndexMarker467"/>previous configuration, we <a id="_idIndexMarker468"/>were adding CORS to each method. Now, we will add the CORS policy at the controller level. Let’s have a look at the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
@CrossOrigin
@AllArgsConstructor
@RestController
@RequestMapping("api/v1/anti-heroes")
public class AntiHeroController {
.. methods
}</pre>
			<p>We can see that <strong class="source-inline">@CrossOrigin</strong> is added at the class level. This means that the CORS policy will be added to all the methods <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">AntiHeroController</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor131"/>CORS application at the controller and method levels</h2>
			<p>We can <a id="_idIndexMarker469"/>combine the application of CORS at both the <a id="_idIndexMarker470"/>controller and method levels in our application. Let’s have a look at the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
@CrossOrigin(allowedHeaders = "Content-type")
@AllArgsConstructor
@RestController
@RequestMapping("api/v1/anti-heroes")
public class AntiHeroController {
    private final AntiHeroService service;
    private final ModelMapper mapper;
    @CrossOrigin(origins = "http://localhost:4200")
    @GetMapping
    public List&lt;AntiHeroDto&gt; getAntiHeroes(Pageable   pageable) {
… code implementation
     }</pre>
			<p>We can see in our example that we have applied the <strong class="source-inline">@CrossOrigin</strong> annotation at both the controller and method levels, <strong class="source-inline">@CrossOrigin(allowedHeaders = "Content-type")</strong> will be used on all the methods under <strong class="source-inline">AntiHeroController</strong>, and <strong class="source-inline">@CrossOrigin(origins = http://localhost:4200)</strong> will be applied only on the <strong class="source-inline">getAntiHeroes()</strong> method, thus other methods will allow <span class="No-Break">all origins.</span></p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor132"/>Global CORS configuration</h2>
			<p>The last <a id="_idIndexMarker471"/>way we can implement a CORS policy is by using <strong class="bold">global configuration</strong>, which <a id="_idIndexMarker472"/>means that our CORS policy applies to all the existing methods in our project. There are several ways to implement global CORS configuration, and we will see how to implement CORS by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">CorsFilter</strong></span><span class="No-Break">:</span></p>
			<ol>
				<li>The first step is to add a configuration class for our CORS policy. To accomplish this, go to the <strong class="source-inline">config</strong> folder of our project and create a new class named <strong class="source-inline">CorsConfig</strong>. We will add the <strong class="source-inline">@Configuration</strong> annotation to identify this class as a configuration upon starting the application, and we should have the <span class="No-Break">following code:</span><pre class="console">
@Configuration</pre><pre class="console">
public class CorsConfig {</pre><pre class="console">
}</pre></li>
				<li>The next step is to create our <strong class="source-inline">CorsFilter Bean</strong>. We will just create a new method with <strong class="source-inline">@Bean</strong> that returns a <span class="No-Break"><strong class="source-inline">CorsFilter</strong></span><span class="No-Break"> object:</span><pre class="console">
@Bean</pre><pre class="console">
CorsFilter corsFilter() {</pre><pre class="console">
CorsConfiguration corsConfiguration =</pre><pre class="console">
  new CorsConfiguration();</pre><pre class="console">
}</pre></li>
				<li>Under the <strong class="source-inline">corsFilter()</strong> method, we will place all of our CORS settings. We will instantiate a <strong class="source-inline">CorsConfiguration</strong> object that we will use to set the attributes by calling several methods. The methods that we will use are <span class="No-Break">as follows:</span><ul><li>The <strong class="source-inline">setAllowCredentials()</strong> method indicates whether the browser should send credentials such as cookies with cross-origin requests. This means that we want to set this option to <strong class="source-inline">true</strong> if we retrieve cookies and <strong class="bold">Cross-Site Request Forgery</strong> (<span class="No-Break"><strong class="bold">CSRF</strong></span><span class="No-Break">) tokens:</span><pre class="console">
corsConfiguration.setAllowCredentials(true);</pre></li><li>The <strong class="source-inline">setAllowedOrigins()</strong> method allows us to set the permitted origins that can access our endpoints. These are the domains for the trusted frontend applications. In the following example, we have set <strong class="source-inline">http://localhost:4200</strong>, which will be the development server of our <span class="No-Break">frontend application:</span><pre class="console">
corsConfiguration.setAllowedOrigins(Arrays.asList("http://localhost:4200"));</pre></li><li>The <strong class="source-inline">setAllowedHeaders()</strong> method allows us to configure the list of headers <a id="_idIndexMarker473"/>permitted in the HTTP requests. In the preceding example, we have set several headers that can be used in <span class="No-Break">the requests:</span><pre class="console">
corsConfiguration.setAllowedHeaders(</pre><pre class="console">
        Arrays.asList(</pre><pre class="console">
                "Origin",</pre><pre class="console">
                "Access-Control-Allow-Origin",</pre><pre class="console">
                "Content-Type",</pre><pre class="console">
                "Accept",</pre><pre class="console">
                "Authorization",</pre><pre class="console">
                "Origin, Accept",</pre><pre class="console">
                "X-Requested-With",</pre><pre class="console">
                "Access-Control-Request-Method",</pre><pre class="console">
                "Access-Control-Request-Headers"</pre><pre class="console">
        )</pre><pre class="console">
);</pre></li><li>The <strong class="source-inline">setExposedHeaders()</strong> method allows us to specify the list of response headers from the server. We can use this method to limit the headers <a id="_idIndexMarker474"/>on the response for <span class="No-Break">security measures:</span><pre class="console">
corsConfiguration.setExposedHeaders(</pre><pre class="console">
        Arrays.asList(</pre><pre class="console">
                "Origin",</pre><pre class="console">
                "Content-Type",</pre><pre class="console">
                "Accept",</pre><pre class="console">
                "Authorization",</pre><pre class="console">
                "Access-Control-Allow-Origin",</pre><pre class="console">
                "Access-Control-Allow-Origin",</pre><pre class="console">
                "Access-Control-Allow-Credentials"</pre><pre class="console">
        )</pre><pre class="console">
);</pre></li><li>The <strong class="source-inline">setAllowedMethods()</strong> method will allow us to add the HTTP request methods that are authorized to be used to access the endpoints. In the following example, we have configured <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, <strong class="source-inline">PUT</strong>, <strong class="source-inline">DELETE</strong>, and <strong class="source-inline">OPTIONS</strong> as the <a id="_idIndexMarker475"/>allowed methods since we are only building a simple <strong class="bold">Create, Read, Update, and Delete</strong> (<span class="No-Break"><strong class="bold">CRUD</strong></span><span class="No-Break">) application:</span><pre class="console">
corsConfiguration.setAllowedMethods(</pre><pre class="console">
        Arrays.asList("GET", "POST", "PUT", "DELETE",</pre><pre class="console">
                      "OPTIONS")</pre><pre class="console">
);</pre></li></ul></li>
				<li>The last step we need to do is register the CORS configuration. We will instantiate a new <strong class="source-inline">urlBasedCorsConfigurarationSource()</strong> and use the <strong class="source-inline">registerCorsConfiguration()</strong> method for the registration. The first parameter is <strong class="source-inline">"/**"</strong>, which indicates that the configuration applies to all the methods <a id="_idIndexMarker476"/>found in the application, and the second parameter is <strong class="source-inline">corsConfiguration</strong>, which is the configuration we <span class="No-Break">have created:</span><pre class="console">
var urlBasedCorsConfigurationSource =</pre><pre class="console">
  new UrlBasedCorsConfigurationSource();</pre><pre class="console">
urlBasedCorsConfigurationSource.registerCorsConfiguration(</pre><pre class="console">
        "/**",</pre><pre class="console">
        corsConfiguration</pre><pre class="console">
);</pre><pre class="console">
return new CorsFilter(urlBasedCorsConfigurationSource);</pre></li>
				<li>After the registration, we will use the configuration source as a parameter for <strong class="source-inline">CorsFilter</strong>, and this is how our <strong class="source-inline">corsFilter()</strong> method would look after successfully configuring the <span class="No-Break">CORS settings:</span><pre class="console">
@Bean</pre><pre class="console">
CorsFilter corsFilter() {</pre><pre class="console">
    CorsConfiguration corsConfiguration =</pre><pre class="console">
      new CorsConfiguration();</pre><pre class="console">
    corsConfiguration.setAllowCredentials(true);</pre><pre class="console">
    corsConfiguration.setAllowedOrigins(</pre><pre class="console">
      Arrays.asList("http://localhost:4200"));</pre><pre class="console">
    corsConfiguration.setAllowedHeaders(</pre><pre class="console">
      Arrays.asList("Origin",</pre><pre class="console">
        "Access-Control-Allow-Origin",</pre><pre class="console">
        "Content-Type","Accept","Authorization",</pre><pre class="console">
        "Origin, Accept","X-Requested-With",</pre><pre class="console">
        "Access-Control-Request-Method",</pre><pre class="console">
        "Access-Control-Request-Headers"));</pre><pre class="console">
    corsConfiguration.setExposedHeaders(</pre><pre class="console">
      Arrays.asList( "Origin","Content-Type",</pre><pre class="console">
      "Accept","Authorization",</pre><pre class="console">
      "Access-Control-Allow-Origin",</pre><pre class="console">
      "Access-Control-Allow-Origin",</pre><pre class="console">
      "Access-Control-Allow-Credentials"));</pre><pre class="console">
    corsConfiguration.setAllowedMethods(</pre><pre class="console">
       Arrays.asList("GET", "POST", "PUT", "DELETE",</pre><pre class="console">
                     "OPTIONS")</pre><pre class="console">
    );</pre><pre class="console">
    var urlBasedCorsConfigurationSource =</pre><pre class="console">
      new UrlBasedCorsConfigurationSource();</pre><pre class="console">
    urlBasedCorsConfigurationSource</pre><pre class="console">
      .registerCorsConfiguration(</pre><pre class="console">
            "/**",</pre><pre class="console">
            corsConfiguration</pre><pre class="console">
    );</pre><pre class="console">
    return new CorsFilter(</pre><pre class="console">
      urlBasedCorsConfigurationSource);</pre><pre class="console">
}</pre></li>
			</ol>
			<p>Having started <a id="_idIndexMarker477"/>our application, we will now apply the CORS configuration to all the methods in our project. We have successfully implemented a CORS policy in our application, but this is just part of how we secure <span class="No-Break">our application.</span></p>
			<p>In the next section, we will discuss the concept of Spring Security and how to implement it in a Spring <span class="No-Break">Boot project.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor133"/>Understanding Spring Security</h1>
			<p><strong class="bold">Spring Security</strong> is an <a id="_idIndexMarker478"/>application-level security framework widely used in Spring Boot applications. It is a flexible authentication framework that provides most of the standard security requirements for Java applications. Spring Security is popular owing to the fact that it allows developers to integrate different authorization and authentication providers on the fly with the other <span class="No-Break">modules available.</span></p>
			<p>As we’re using Spring Security in our application, we do not need to code security-related tasks from scratch as Spring Security has these features under <span class="No-Break">the hood.</span></p>
			<p>Let’s discuss the concepts of Spring <span class="No-Break">Security further.</span></p>
			<h2 id="_idParaDest-126"><a id="_idTextAnchor134"/>Features of Spring Security</h2>
			<p>Spring Security <a id="_idIndexMarker479"/>mainly focuses on integrating authentication and authorization into applications. To compare the two, <strong class="bold">authentication</strong> refers to <a id="_idIndexMarker480"/>validating that a user can access your application and identifying who the user is. This mainly refers to the login page itself. On the other hand, <strong class="bold">authorization</strong> is used <a id="_idIndexMarker481"/>for more complex applications; this relates to the operations or actions that a specific user can do inside <span class="No-Break">your applications.</span></p>
			<p>Authorization can be accomplished by integrating roles to implement user access controls. Spring Security also provides different password encoders – one-way transformation passwords – which are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">BCryptPasswordEncoder</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Argon2PasswordEncoder</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Pbkdf2PasswordEncoder</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">SCryptPasswordEncoder</strong></span></li>
			</ul>
			<p>The preceding list is of the most commonly used password encoders and can be accessed directly when using Spring Security. It also provides different features that will help you to <a id="_idIndexMarker482"/>meet security requirements, which are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">Lightweight Directory Access Protocol</strong> (<strong class="bold">LDAP</strong>): A protocol for containing and accessing distributed directory information services over an <span class="No-Break">internet protocol.</span></li>
				<li><strong class="bold">Remember me</strong>: This feature provides a capability to remember a user from a single machine to prevent logging <span class="No-Break">in again.</span></li>
				<li><strong class="bold">Single Sign-On</strong> (<strong class="bold">SSO</strong>): This feature allows users to access multiple applications with a single account, centralizing <span class="No-Break">user information.</span></li>
				<li><strong class="bold">Software localization</strong>: This feature gives the capability to develop a user interface with our <span class="No-Break">preferred language.</span></li>
				<li><strong class="bold">HTTP authorization</strong>: This feature <span class="No-Break">provides authorization.</span></li>
				<li><strong class="bold">Basic access authentication</strong>: This feature provides the base authentication process, which requires a username and password <span class="No-Break">for requests.</span></li>
				<li><strong class="bold">Digest access authentication</strong>: This feature provides more secure authentication that confirms the user’s identity before <span class="No-Break">accessing resources.</span></li>
				<li><strong class="bold">Web form authentication</strong>: A form will be generated that will authenticate the user <a id="_idIndexMarker483"/>credentials directly from the <span class="No-Break">web browser.</span></li>
			</ul>
			<p>Spring Security offers a wide range of features for the application. In this case, the design of Spring Security is <a id="_idIndexMarker484"/>divided into separate <strong class="bold">Java Archive</strong> (<strong class="bold">JAR</strong>) files based on its functionality, only requiring the installation of the needed part for <span class="No-Break">our development.</span></p>
			<p>The following <a id="_idIndexMarker485"/>is a list of JAR files that are included in the Spring <span class="No-Break">Security module:</span></p>
			<ul>
				<li><strong class="source-inline">spring-security-core</strong>: The standard requirement for an application to use Spring Security. <strong class="source-inline">Spring-security-core</strong> consists of the core authentication classes <span class="No-Break">and interfaces.</span></li>
				<li><strong class="source-inline">spring-security-web</strong>: This JAR file is used for web authentication and URL-based access control. It is found <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">org.springframework.security.web</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">spring-security-config</strong>: This JAR file is used for implementing Spring Security configuration, using XML and Java. All classes and interfaces are found <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">org.springframework.security.config</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">spring-security-ldap</strong>: This JAR file is required for implementing LDAP in our application. All classes and interfaces are found <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">org.springframework.security.ldap</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">spring-security-oauth2-core</strong>: This JAR file is used to implement the OAuth 2.0 authorization framework and OpenID Connect Core. The classes are located <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">org.springframework.security.oauth2.core</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">spring-security-oauth2-client</strong>: This JAR file provides the OAuth login and OpenID client support. All classes and interfaces are located <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">org.springframework.security.oauth2.client</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">spring-security-openid</strong>: This JAR file is used for OpenID web authentication support to validate users with an external <span class="No-Break">OpenID server.</span></li>
				<li><strong class="source-inline">spring-security-test</strong>: This JAR file is used to support testing for the Spring <span class="No-Break">Security application.</span></li>
				<li><strong class="source-inline">spring-security-cas</strong>: This JAR file implements web authentication with a CAS SSO <a id="_idIndexMarker486"/>server. All classes and interfaces are found <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">org.springframewok.security.cas</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">spring-security-acl</strong>: This JAR file is used to integrate security into the application’s domain object. We can access the classes and interfaces <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">org.springframework.security.acls</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>We have now learned about the different features and modules that Spring Security offers. In the next section, we will learn how to implement authentication and authorization using Spring Security in our Spring <span class="No-Break">Boot application.</span></p>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor135"/>Authentication and authorization in Spring Boot</h1>
			<p>We have already discussed the concepts of Spring Security in the previous section; now, we will <a id="_idIndexMarker487"/>learn how to integrate Spring Security into our Spring Boot application. As we move on to the examples, we will be using all the modules <a id="_idIndexMarker488"/>and features  of Spring <span class="No-Break">Boot Security.</span></p>
			<p>Authentication and authorization are the most common concepts that we come across when we implement security in our applications. These are the two validations we apply for our application to <span class="No-Break">be secure.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor136"/>Configuring Spring Boot and implementing authentication</h2>
			<p>We will <a id="_idIndexMarker489"/>first implement authentication in our application. We first need to add the Spring Boot Security dependency to our project. To add the <a id="_idIndexMarker490"/>dependency, we will add the following <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>
			<p>Reload the project to install the new dependency and run the server. Let’s try to visit <strong class="source-inline">localhost:8080</strong> to open the Spring Boot application project in the browser. As we can see, a login page is now applied to our project as we’ve installed Spring <span class="No-Break">Boot Security:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer059">
					<img alt="Figure 7.1 – Login page integrated from Spring Boot Security" src="image/B18159_07_01.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – Login page integrated from Spring Boot Security</p>
			<p>To create <a id="_idIndexMarker491"/>credentials for the login, we can configure the username <a id="_idIndexMarker492"/>and password under the <strong class="source-inline">application.properties</strong> file by placing the <span class="No-Break">following setting:</span></p>
			<pre class="source-code">
spring.security.user.name=admin
spring.security.user.password=test</pre>
			<p>In the preceding example, we have used <strong class="source-inline">admin</strong> as the username and <strong class="source-inline">test</strong> as the password for our Spring Boot Security login, which will allow us to log in successfully to <span class="No-Break">our application.</span></p>
			<p>We have now successfully set up Spring Boot Security for our project, and this automatically applies authentication to our endpoints. The next step we need to do is add a configuration for our security; we would want to override the default configuration and implement a customized login endpoint for our application to give access to our other <span class="No-Break">endpoints provided.</span></p>
			<p>To start with the configuration, let’s first create a new class named <strong class="source-inline">SecurityConfig</strong> under the config file. We will extend our new <strong class="source-inline">SecurityConfig</strong> class with <strong class="source-inline">WebSecurityConfigurerAdapter</strong>. This adapter allows us to override and customize the configuration of <strong class="source-inline">WebSecurity</strong> and <strong class="source-inline">HttpSecurity</strong>, and after extending <a id="_idIndexMarker493"/>the class, we will override the first <span class="No-Break">two methods:</span></p>
			<pre class="source-code">
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    //We will place the customized userdetailsservice here in the following steps
}
@Bean(name = BeanIds.AUTHENTICATION_MANAGER)
@Override
public AuthenticationManager authenticationManagerBean() throws Exception {
    return super.authenticationManagerBean();
}</pre>
			<p>The first <a id="_idIndexMarker494"/>method that we will override on <strong class="source-inline">WebSecurityConifigurerAdapter</strong> is the <strong class="source-inline">configure(AuthenticationManagerBuilder auth)</strong> method, which accepts <strong class="source-inline">AuthenticationManagerBuilder</strong>, which is used to build LDAP authentication, JDBC-based authentication, adding a custom <strong class="source-inline">UserDetailsService</strong>, and adding <strong class="source-inline">AuthenticationProviders</strong>. In this case, we will use this to access <strong class="source-inline">userDetailsServiceMethod()</strong> to customize our authentication. We will do that in the following steps as we have not yet created our <span class="No-Break">modified </span><span class="No-Break"><strong class="source-inline">UseDetailsService</strong></span><span class="No-Break">.</span></p>
			<p>The second method is <strong class="source-inline">authenticationManagerBean()</strong>; we override this method to expose <strong class="source-inline">AuthenticationManager</strong> as a bean in our application, which we will later use in <strong class="source-inline">AuthenticateController</strong>. The next step is to implement the configuration we want for our HTTP requests. To achieve this, we will override the <strong class="source-inline">configure(HttpSecurity </strong><span class="No-Break"><strong class="source-inline">http)</strong></span><span class="No-Break"> method.</span></p>
			<p><strong class="source-inline">HttpSecurity</strong> allows us to call methods that will implement configuration for web-based security requests for the HTTP requests. By default, the security configuration will be applied <a id="_idIndexMarker495"/>to all HTTP requests, but we can also set only specific <a id="_idIndexMarker496"/>requests by using the <strong class="source-inline">requestMatcher()</strong> methods. <strong class="source-inline">HttpSecurity</strong> is the same as the Spring Security <span class="No-Break">XML configuration.</span></p>
			<p>Let’s discuss <a id="_idIndexMarker497"/>the standard methods <span class="No-Break">under </span><span class="No-Break"><strong class="source-inline">HttpSecurity</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">csrf()</strong>: Enables <a id="_idIndexMarker498"/>the <strong class="bold">CSRF</strong> protections. This is enabled <span class="No-Break">by default.</span></li>
				<li><strong class="source-inline">disable()</strong>: Disables the initial configurations; a new version can be applied after calling <span class="No-Break">the method.</span></li>
				<li><strong class="source-inline">antMatcher("/**")</strong>: By default, our configuration will be applied to all HTTP requests. We can use the <strong class="source-inline">antMatcher()</strong> method to specify the URL patterns where we want to apply <span class="No-Break">the configuration.</span></li>
				<li><strong class="source-inline">antMatchers("/**")</strong>: Similar to the <strong class="source-inline">antMatcher()</strong> method, but accepts a list of patterns where we want to apply <span class="No-Break">the configuration.</span></li>
				<li><strong class="source-inline">permitAll()</strong>: Specifies that access to any URL endpoints are allowed <span class="No-Break">by anyone.</span></li>
				<li><strong class="source-inline">anyRequest()</strong>: Applies to any type of <span class="No-Break">HTTP request.</span></li>
				<li><strong class="source-inline">authenticated()</strong>: Specifies that any URL endpoints are allowed by any <span class="No-Break">authenticated user.</span></li>
				<li><strong class="source-inline">exceptionHandling()</strong>: Exception <span class="No-Break">handling configuration.</span></li>
				<li><strong class="source-inline">sessionManagement()</strong>: This method is commonly used to manage how many allowed sessions for a user can be active; for example, we configure <strong class="source-inline">sessionManagement().maximumSessions(1).expiredUrl("/login?expired")</strong>, which indicates that when the user is logged in to another terminal and attempts to log in to another instance, it will automatically log them out of the <span class="No-Break">other instance.</span></li>
				<li><strong class="source-inline">sessionCreationPolicy()</strong>: Allows us to create a policy for when a session should <a id="_idIndexMarker499"/>get created; the possible values are <strong class="source-inline">ALWAYS</strong>, <strong class="source-inline">IF_REQUIRED</strong>, <strong class="source-inline">NEVER</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">STATELESS</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>In our <a id="_idIndexMarker500"/>code, let’s configure a basic configuration for our security. Let’s <a id="_idIndexMarker501"/>place the following code inside the <strong class="source-inline">configure(HttpSecurity </strong><span class="No-Break"><strong class="source-inline">http)</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
@Override
protected void configure(HttpSecurity http) throws Exception {
    http
        // first chain
        .csrf()
        .disable()
        // second chain
        .antMatcher("/**")
        .authorizeRequests()
        // third chain
        .antMatchers("/**")
        .permitAll()
        // fourth chain
        .and()
        .sessionManagement()
        .sessionCreationPolicy(
          SessionCreationPolicy.STATELESS);
}</pre>
			<p>In the preceding example configuration, we have implemented several configurations for our application. You can notice that we have divided the methods into chains. This is to show the methods are related to <span class="No-Break">each other.</span></p>
			<p>The first chain, with <strong class="source-inline">.csrf().disable()</strong>, disables the use of CSRF protection. This is just an example, and disabling CSRF is not recommended when building your application. The second chain, with <strong class="source-inline">.antMatcher("/**").authorizedRequests()</strong>, states that any requests are authorized to be accessed by any users regardless of <span class="No-Break">the role.</span></p>
			<p>This can <a id="_idIndexMarker502"/>be modified by specifying the role in the <strong class="source-inline">hasRole()</strong> method by restricting the users based on the assigned roles. The third chain is <strong class="source-inline">.antMatchers("/**").permitAll()</strong>, which indicates that any users can <a id="_idIndexMarker503"/>access all the URLs, and lastly, <strong class="source-inline">sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)</strong> indicates that no session should be created by <span class="No-Break">Spring Security.</span></p>
			<p>We have successfully created <strong class="source-inline">SecurityConfig</strong>, which contains all of our configurations for Spring Security; our code should look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
@AllArgsConstructor
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig extends WebSecurityConfigurerAdapter {
     // removed some code for brevety
    @Override
    protected void configure(HttpSecurity http) throws
      Exception {
        http
                // first chain
                .csrf()
                .disable()
                // second chain
                .antMatcher("/**")
                .authorizeRequests()
                // third chain
                .antMatchers("/**")
                .permitAll()
                // fourth chain
                .and()
                .sessionManagement()
                .sessionCreationPolicy(
                  SessionCreationPolicy.STATELESS);
    }
}</pre>
			<p>Now, we will <a id="_idIndexMarker504"/>move on to the next step, where we will create <a id="_idIndexMarker505"/>our endpoints for our <span class="No-Break">user entity.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor137"/>Creating user endpoints</h2>
			<p>When <a id="_idIndexMarker506"/>implementing CRUD, we need to create our user endpoints. We need to develop these endpoints such that they will be used for the <a id="_idIndexMarker507"/>registration of a new user in our database. In this example, we will repeat the steps on how to develop endpoints discussed in <em class="italic">w</em>, <em class="italic">Documenting APIs with OpenAPI Specification</em>, but we will also create a whole CRUD capability for the <span class="No-Break">user entity.</span></p>
			<p>Let’s create a new user package and make the controller, data, entity, repository, and service packages under the <span class="No-Break">user package.</span></p>
			<h3>Creating the user entity</h3>
			<p>Let’s create <a id="_idIndexMarker508"/>the user entity first by creating a new class <a id="_idIndexMarker509"/>named <strong class="source-inline">UserEntity</strong> under the entity package, and we will place the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserEntity {
  @Id
  @GeneratedValue(strategy = GenerationType.AUTO,
                  generator = "UUID")
  @Column(nullable = false, updatable = false)
  private UUID id;
  @Column(unique = true)
  private String email;
  private String mobileNumber;
  private byte[] storedHash;
  private byte[] storedSalt;
  public UserEntity(String email, String mobileNumber) {
    this.email = email;
    this.mobileNumber = mobileNumber;
  }
}</pre>
			<p>In the <a id="_idIndexMarker510"/>preceding example, we have assigned several <a id="_idIndexMarker511"/>properties for <strong class="source-inline">UserEntity</strong>. We have annotated it with <strong class="source-inline">@Entity</strong> to indicate <a id="_idIndexMarker512"/>that this is a <strong class="bold">Java Persistence API</strong> (<strong class="bold">JPA</strong>) entity. We have configured it with an email address, mobile number, <strong class="source-inline">storedHash</strong>, and a <strong class="source-inline">storedSalt</strong> property. <strong class="source-inline">storedHash</strong> and <strong class="source-inline">storedSalt</strong> will be used for hashing and verifying the <span class="No-Break">user’s password.</span></p>
			<h3>Creating the user DTO</h3>
			<p>After creating <a id="_idIndexMarker513"/>the user entity, we will make the <strong class="bold">Data Transfer Object</strong> (<strong class="bold">DTO</strong>). The DTO is <a id="_idIndexMarker514"/>an object that we <a id="_idIndexMarker515"/>commonly use for responses or to hide unnecessary properties. We will create a new class named <strong class="source-inline">UserDto</strong> under the data package, and we will place the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Data
@AllArgsConstructor
@NoArgsConstructor
public class UserDto {
  private UUID id;
  private String email;
  private String mobileNumber;
  private String password;
}</pre>
			<h3>Creating the user repository</h3>
			<p>The next thing we need to do is create the repository for our user. Under the repository package, create <a id="_idIndexMarker516"/>a new class named <strong class="source-inline">UserRepository</strong>, and we <a id="_idIndexMarker517"/>will extend the class with <strong class="source-inline">JPARepository</strong> by adding the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Repository
public interface UserRepository extends JpaRepository&lt;UserEntity, UUID&gt; {
  @Query(
    "" +
    "SELECT CASE WHEN COUNT(u) &gt; 0 THEN " +
    "TRUE ELSE FALSE END " +
    "FROM UserEntity u " +
    "WHERE u.email = ?1"
  )
  Boolean selectExistsEmail(String email);
  UserEntity findByEmail(String email);
}</pre>
			<p>In the preceding example, we extended <strong class="source-inline">UserRepository</strong> with <strong class="source-inline">JPARepository</strong>, which grants all the CRUD capabilities to our repository. We have also created two methods with an <strong class="source-inline">@Query</strong> annotation, which checks whether the email address <span class="No-Break">already exists.</span></p>
			<h3>Creating the user service</h3>
			<p>The next <a id="_idIndexMarker518"/>step is now to create our user service where we will implement <a id="_idIndexMarker519"/>the business logic of the application. Under the service package, we will create a new class named <strong class="source-inline">UserService</strong>, after the creation of <span class="No-Break">the service.</span></p>
			<p>We will place <strong class="source-inline">@AllArgsConstructor</strong> for the constructor injecting the dependencies and the <strong class="source-inline">@Service</strong> annotation to let Spring know that this is a service layer, and we will also inject <strong class="source-inline">ModelMapper</strong> and <strong class="source-inline">UserRepository</strong> into our service after the annotations and <span class="No-Break">dependency injection.</span></p>
			<p>We can <a id="_idIndexMarker520"/>create two methods that allow us to convert an entity into <a id="_idIndexMarker521"/>a DTO and vice versa by placing the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
private UserDto convertToDto(UserEntity entity) {
  return mapper.map(entity, UserDto.class);
}
private UserEntity convertToEntity(UserDto dto) {
  return mapper.map(dto, UserEntity.class);
}</pre>
			<p>Now, we will <a id="_idIndexMarker522"/>create the code for the basic <span class="No-Break">CRUD functionalities:</span></p>
			<ul>
				<li><strong class="bold">Getting all users</strong>: To get all of the users, we will place the <span class="No-Break">following code:</span><pre class="console">
public List&lt;UserDto&gt; findAllUsers() {</pre><pre class="console">
  var userEntityList =</pre><pre class="console">
    new ArrayList&lt;&gt;(repo.findAll());</pre><pre class="console">
  return userEntityList</pre><pre class="console">
    .stream()</pre><pre class="console">
    .map(this::convertToDto)</pre><pre class="console">
    .collect(Collectors.toList());</pre><pre class="console">
}</pre></li>
			</ul>
			<p>The example code returns all the list of users converted into <span class="No-Break">a DTO.</span></p>
			<ul>
				<li><strong class="bold">Getting users by ID</strong>: To get a specific user by ID, we will place the <span class="No-Break">following code:</span><pre class="console">
public UserDto findUserById(final UUID id) {</pre><pre class="console">
  var user = repo</pre><pre class="console">
    .findById(id)</pre><pre class="console">
    .orElseThrow(</pre><pre class="console">
      () -&gt; new NotFoundException("User by id " + id +</pre><pre class="console">
                                  " was not found")</pre><pre class="console">
    );</pre><pre class="console">
  return convertToDto(user);</pre><pre class="console">
}</pre></li>
			</ul>
			<p>This <a id="_idIndexMarker523"/>example method retrieves a specific user using the <strong class="source-inline">findByID()</strong> method of the <span class="No-Break">user repository.</span></p>
			<ul>
				<li><strong class="bold">Creating a new user</strong>: The creation of a user is the most important method as this will be the registration method for the credentials. We will divide this into three methods – the first one is the <strong class="source-inline">createSalt()</strong> method, which will allow us to create a salt for the <span class="No-Break">user’s password.</span></li>
			</ul>
			<p>Let’s place the code for the <span class="No-Break"><strong class="source-inline">createSalt()</strong></span><span class="No-Break"> method:</span></p>
			<pre class="console">
private byte[] createSalt() {
  var random = new SecureRandom();
  var salt = new byte[128];
  random.nextBytes(salt);
  return salt;
}</pre>
			<p>The next method is <strong class="source-inline">createPasswordHash()</strong>, which will allow us to hash the user’s password. We use the SHA-512 hashing algorithm and the provided salt to create the method. The following code is for the <span class="No-Break"><strong class="source-inline">createPasswordHash()</strong></span><span class="No-Break"> implementation:</span></p>
			<pre class="console">
private byte[] createPasswordHash(String password, byte[] salt)
  throws NoSuchAlgorithmException {
  var md = MessageDigest.getInstance("SHA-512");
  md.update(salt);
  return md.digest(
    password.getBytes(StandardCharsets.UTF_8));
}</pre>
			<p>The last <a id="_idIndexMarker524"/>method is the <strong class="source-inline">createUser()</strong> method itself. We will first check whether a password is provided and then whether the email address already exists using the <strong class="source-inline">selectExistsEmail()</strong> method we have created. Next, after all the validations have passed, make a salt using the <strong class="source-inline">createSalt()</strong> method and hash the password using <strong class="source-inline">createPasswordHash()</strong>. Lastly, save the new user in the database. The following code is for the <span class="No-Break"><strong class="source-inline">createUser()</strong></span><span class="No-Break"> implementation:</span></p>
			<pre class="console">
public UserDto createUser(UserDto userDto, String password)
  throws NoSuchAlgorithmException {
  var user = convertToEntity(userDto);
  if (password.isBlank()) throw new
    IllegalArgumentException(
    "Password is required."
  );
  var existsEmail =
    repo.selectExistsEmail(user.getEmail());
  if (existsEmail) throw new   BadRequestException(
    "Email " + user.getEmail() + " taken"
  );
  byte[] salt = createSalt();
  byte[] hashedPassword =
    createPasswordHash(password, salt);
  user.setStoredSalt(salt);
  user.setStoredHash(hashedPassword);
  repo.save(user);
  return convertToDto(user);
}</pre>
			<ul>
				<li><strong class="bold">Updating and deleting a user</strong>: The last two methods we need to add are <strong class="source-inline">updateUser()</strong> and <strong class="source-inline">deleteUser()</strong>. This is a different method we can implement <a id="_idIndexMarker525"/>to give us the capability to edit the details of the user or delete the user in <span class="No-Break">the database.</span></li>
			</ul>
			<p>Let’s see the following <span class="No-Break">code implementation:</span></p>
			<pre class="console">
public void updateUser(UUID id, UserDto userDto, String password)
  throws NoSuchAlgorithmException {
  var user = findOrThrow(id);
  var userParam = convertToEntity(userDto);
  user.setEmail(userParam.getEmail());
  user.setMobileNumber(userParam.getMobileNumber());
  if (!password.isBlank()) {
    byte[] salt = createSalt();
    byte[] hashedPassword =
      createPasswordHash(password, salt);
    user.setStoredSalt(salt);
    user.setStoredHash(hashedPassword);
  }
  repo.save(user);
}
public void removeUserById(UUID id) {
  findOrThrow(id);
  repo.deleteById(id);
}
private UserEntity findOrThrow(final UUID id) {
  return repo
    .findById(id)
    .orElseThrow(
      () -&gt; new NotFoundException("User by id " + id +
                                  " was not found")
    );
}</pre>
			<p>We have <a id="_idIndexMarker526"/>already created the services needed for our user entity. Now, the last step is to make <span class="No-Break">our controller.</span></p>
			<h3>Creating the user controller</h3>
			<p>The last <a id="_idIndexMarker527"/>requirement for the user is to create the <a id="_idIndexMarker528"/>controller. We will create a method for <strong class="source-inline">findAllUsers()</strong>, <strong class="source-inline">findUserById()</strong>, <strong class="source-inline">deleteUserById()</strong>, <strong class="source-inline">createUser()</strong>, and <strong class="source-inline">putUser()</strong> under the annotated services with specific <span class="No-Break">HTTP requests.</span></p>
			<p>Let’s see the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
@AllArgsConstructor
@RestController
public class UserController {
  private final UserService userService;
  @GetMapping("/api/v1/users")
  public Iterable&lt;UserDto&gt; getUsers() {
    return userService.findAllUsers();
  }
  @GetMapping("/api/v1/users/{id}")
  public UserDto getUserById(@PathVariable("id") UUID id) {
    return userService.findUserById(id);
  }
  @DeleteMapping("/api/v1/users/{id}")
  @ResponseStatus(HttpStatus.NO_CONTENT)
  public void deleteUserById(@PathVariable("id") UUID id) {
    userService.removeUserById(id);
  }
  @PostMapping("/register")
  @ResponseStatus(HttpStatus.CREATED)
  public UserDto postUser(@Valid @RequestBody UserDto
                          userDto)
    throws NoSuchAlgorithmException {
    return userService.createUser(userDto,
                                  userDto.getPassword());
  }
  @PutMapping("/api/v1/users/{id}")
  public void putUser(
    @PathVariable("id") UUID id,
    @Valid @RequestBody UserDto userDto
  ) throws NoSuchAlgorithmException {
    userService.updateUser(id, userDto,
                           userDto.getPassword());
  }</pre>
			<p>We have <a id="_idIndexMarker529"/>successfully created our endpoints <a id="_idIndexMarker530"/>for our user entity; we can now use the <strong class="source-inline">/register</strong> endpoint to create a new user for a valid authentication. Now, we will make the login endpoint <span class="No-Break">using JWT.</span></p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor138"/>JWT</h2>
			<p>JWT is a <a id="_idIndexMarker531"/>URL-safe method for communicating data. A JWT can be seen as an encrypted string containing a JSON object with a lot of information. It includes <a id="_idIndexMarker532"/>an additional structure consisting of a header <a id="_idIndexMarker533"/>payload that uses JSON format. JWTs can be encrypted or signed with a <strong class="bold">Message Authentication Code</strong> (<strong class="bold">MAC</strong>). A JWT is created by combining the header and payload JSON, and the whole token <span class="No-Break">is Base64-URL-encoded.</span></p>
			<h3>When to use JWT</h3>
			<p>JWT is used <a id="_idIndexMarker534"/>chiefly on RESTful web services that cannot maintain a client state since JWT holds some information connected to the user. It can provide state information to the server for each request. JWT is utilized in applications that require client authentication <span class="No-Break">and authorization.</span></p>
			<h3>JWT example</h3>
			<p>Let’s have <a id="_idIndexMarker535"/>a look at the following <span class="No-Break">JWT example:</span></p>
			<pre class="source-code">
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIi wibmFtZSI6IlNlaWppIFZpbGxhZnJhbmNhIiwiaWF0IjoxNTE2MjM5MDIyfQ.uhmdFM4ROwnerVam-zdYojURqrgL7WQRBRj-P8kVv6s</pre>
			<p>The JWT in the given example is composed of three parts – we can notice that it is divided with a dot (<em class="italic">.</em>) character. The first string is the encoded header, the second string is the encoded payload, and the last string is the signature of <span class="No-Break">the JWT.</span></p>
			<p>The following block is an example of the <span class="No-Break">decoded structure:</span></p>
			<pre class="source-code">
// Decoded header
{
  "alg": "HS256",
  "typ": "JWT"
}
// Decoded Payload
{
  "sub": "1234567890",
  "name": "Seiji Villafranca",
  "iat": 1516239022
}
// Signature
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret-key
)</pre>
			<p>We can see <a id="_idIndexMarker536"/>in the preceding example that the three parts are JSON objects, the headers, which contain the algorithm used for signing the JWT, the payload, which holds information that can be used to define the state, and the signature, which encodes both the headers and the payload appended by the <span class="No-Break">secret key.</span></p>
			<h3>JWT implementation</h3>
			<p>We already <a id="_idIndexMarker537"/>know the concept and use of JWT; now, we will implement JWT generation in our Spring Boot project. We want to create an authentication endpoint that will return a valid JWT when a valid credential <span class="No-Break">is submitted.</span></p>
			<p>The first step is to add the JWT dependencies to our Spring <span class="No-Break">Boot project.</span></p>
			<p>Let’s add the following XML code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;dependency&gt;
   &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
   &lt;artifactId&gt;jjwt-impl&lt;/artifactId&gt;
   &lt;version&gt;0.11.2&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
   &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;
   &lt;artifactId&gt;jjwt-jackson&lt;/artifactId&gt;
   &lt;version&gt;0.11.2&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>Next, we need <a id="_idIndexMarker538"/>to create a package named <strong class="source-inline">jwt</strong> under our project package, and after its creation, create packages called <strong class="source-inline">controllers</strong>, <strong class="source-inline">filters</strong>, <strong class="source-inline">models</strong>, <strong class="source-inline">services</strong>, and <strong class="source-inline">util</strong>. We will start making the necessary models for our <span class="No-Break">authentication endpoint.</span></p>
			<h4>Creating the authentication models</h4>
			<p>We <a id="_idIndexMarker539"/>need to create three models for our authentication. The first model is for the request, the next is for the response, and lastly, we have a model containing the user information and one to implement <strong class="source-inline">UserDetails</strong> from <span class="No-Break">Spring Security.</span></p>
			<p>For the request model, create a new class named <strong class="source-inline">AuthenticationRequest</strong> under the models’ package. The implementation of the model is shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationRequest implements Serializable {
  private String email;
  private String password;
}</pre>
			<p>The <a id="_idIndexMarker540"/>request only needs the email address and the password, since these are the credentials we need <span class="No-Break">to validate.</span></p>
			<p>Then, for the response model, create a new class named <strong class="source-inline">AuthenticationResponse</strong>; the implementation of the model is shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AuthenticationResponse implements Serializable {
  private String token;
}</pre>
			<p>The response model only contains the token; the JWT is returned once the credentials <span class="No-Break">are validated.</span></p>
			<p>Lastly, for the user principal model, create a new class named <strong class="source-inline">UserPrincipal</strong>; the implementation of the model is shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@AllArgsConstructor
public class UserPrincipal implements UserDetails {
  private final UserEntity userEntity;
  @Override
  public Collection&lt;? extends GrantedAuthority&gt;
    getAuthorities() {
    return null;
  }
  @Override
  public String getPassword() {
    return null;
  }
  @Override
  public String getUsername() {
    return this.userEntity.getEmail();
  }
  // Code removed for brevity. Please refer using the
  // GitHub repo.
  @Override
  public boolean isEnabled() {
    return false;
  }
}</pre>
			<p>The use principal model implements <strong class="source-inline">UserDetails</strong> as this will be our custom user for Spring Security. We have overridden several methods, such as <strong class="source-inline">getAuthorities()</strong>, which <a id="_idIndexMarker541"/>retrieves the list of authorizations of the user, <strong class="source-inline">isAccountNonLocked()</strong>, which checks whether the user is locked, <strong class="source-inline">isAccountNonExpired()</strong>, which validates that the user is valid and not yet expired, and <strong class="source-inline">isEnabled()</strong>, which checks whether the user <span class="No-Break">is active.</span></p>
			<h4>Creating the authentication utilities</h4>
			<p>We <a id="_idIndexMarker542"/>need to create the utilities for our authentication; the utilities will be responsible for the JWT creation, validation and expiration checks, and extraction of the information. These are the methods we will use to validate <span class="No-Break">our token.</span></p>
			<p>We will create a class named <strong class="source-inline">JwtUtil</strong> under the <strong class="source-inline">util</strong> package, and we will annotate this with an <strong class="source-inline">@Service</strong> annotation. Let’s start with the methods needed <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">util</strong></span><span class="No-Break">.</span></p>
			<p>Let’s create the first two methods that we need to create a <span class="No-Break">valid token:</span></p>
			<pre class="source-code">
private String createToken(Map&lt;String, Object&gt; claims, String subject) {
  Keys.
  return Jwts
    .builder()
    .setClaims(claims)
    .setSubject(subject)
    .setIssuedAt(new Date(System.currentTimeMillis()))
    .setExpiration(new Date(System.currentTimeMillis() +
                            1000 * 60 * 60 * 10))
          .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
    .compact();
}
public String generateToken(UserDetails userDetails) {
  Map&lt;String, Object&gt; claims = new HashMap&lt;&gt;();
  return createToken(claims, userDetails.getUsername());
}</pre>
			<p>The preceding <a id="_idIndexMarker543"/>implementation calls several methods from the <span class="No-Break">JWT extension:</span></p>
			<ul>
				<li>The <strong class="source-inline">builder()</strong> method, which is responsible for the building of <span class="No-Break">the JWT.</span></li>
				<li>The <strong class="source-inline">setClaims()</strong> method, which sets the claims of <span class="No-Break">the JWT.</span></li>
				<li>The <strong class="source-inline">setSubject()</strong> method, which sets the subject; in this case, the value is the email address of <span class="No-Break">the user.</span></li>
				<li>The <strong class="source-inline">setIssuedAt()</strong> method, which sets the date when the JWT <span class="No-Break">is created.</span></li>
				<li>The <strong class="source-inline">setExpiration()</strong> method, which sets the expiration date of <span class="No-Break">the JWT.</span></li>
				<li>The <strong class="source-inline">signWith()</strong> method, which signs the JWT with the provided key <span class="No-Break">and algorithm.</span></li>
			</ul>
			<p>The <a id="_idIndexMarker544"/>next method we need to implement is the claims extraction. We will use this method mainly to get useful information, such as the subject and the expiration of <span class="No-Break">the token.</span></p>
			<p>Let’s have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
public &lt;T&gt; T extractClaim(String token, Function&lt;Claims, T&gt; claimsResolver) {
  final Claims claims = extractAllClaims(token);
  return claimsResolver.apply(claims);
}
private Claims extractAllClaims(String token) {
  return Jwts
    .parserBuilder()
    .setSigningKey(SECRET_KEY)
     .build()
    .parseClaimsJws(token)
    .getBody();
}</pre>
			<p>The <strong class="source-inline">extractAllClaims()</strong> method <a id="_idIndexMarker545"/>receives the token and uses the secret key provided by the application. We have called the <strong class="source-inline">parseClaimsJWS()</strong> method <a id="_idIndexMarker546"/>to extract the claims from <span class="No-Break">the JWT.</span></p>
			<p>Now, we will create the methods to extract and check whether the token is expired and extract the username using the <strong class="source-inline">extractClaims()</strong> method we <span class="No-Break">have created.</span></p>
			<p>Let’s <a id="_idIndexMarker547"/>have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
public Date extractExpiration(String token) {
  return extractClaim(token, Claims::getExpiration);
}
private Boolean isTokenExpired(String token) {
  return extractExpiration(token).before(new Date());
}
public String extractUsername(String token) {
  return extractClaim(token, Claims::getSubject);
}</pre>
			<p>We have used the <strong class="source-inline">getExpiration</strong> and <strong class="source-inline">getSubject</strong> built-in functions to get the expiration date and subject from <span class="No-Break">the claims.</span></p>
			<p>Lastly, we will create a method to validate that the token is not yet expired or a valid user is using <span class="No-Break">the token.</span></p>
			<p>Let’s <a id="_idIndexMarker548"/>have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
public Boolean validateToken(String token,
                             UserDetails userDetails) {
  final String username = extractUsername(token);
  return (
    username.equals(userDetails.getUsername()) &amp;&amp;
      !isTokenExpired(token)
  );
}</pre>
			<h4>Creating the authentication service</h4>
			<p>Now, we will create the service for our authentication, as we know that services are responsible for the logic of our application. We will make the following methods, which will <a id="_idIndexMarker549"/>verify whether the password is correct using the hash, check whether the user has valid credentials, and provide a method that will override the <span class="No-Break">default authentication.</span></p>
			<p>The first step is to create a new class named <strong class="source-inline">ApplicationUserDetailsService</strong> under the service package, and we will implement the class using <strong class="source-inline">UserDetailsService</strong> from Spring Security. We will override the <strong class="source-inline">loadUserByUsername()</strong> method and execute the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
@Override
public UserDetails loadUserByUsername(String email)
  throws UsernameNotFoundException {
  return new UserPrincipal(
    userService.searchByEmail(email));
}</pre>
			<p>The preceding code calls the <strong class="source-inline">searchByEmail()</strong> method, which is our custom implementation for checking whether a user exists, and we will return the user as a <span class="No-Break"><strong class="source-inline">UserPrincipal</strong></span><span class="No-Break"> object.</span></p>
			<p>The next step is to create the <strong class="source-inline">verifyPasswordHash()</strong> method, which will validate the <span class="No-Break">user’s password.</span></p>
			<p>Let’s <a id="_idIndexMarker550"/>have a look at the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
private Boolean verifyPasswordHash(
  String password,
  byte[] storedHash,
  byte[] storedSalt
) throws NoSuchAlgorithmException {
  // Code removed for brevety. Please refer to the GitHub
  // repo
  for (int i = 0; i &lt; computedHash.length; i++) {
    if (computedHash[i] != storedHash[i]) return false;
  }
  // The above for loop is the same as below
  return MessageDigest.isEqual(computedHash, storedHash);
}</pre>
			<p>The method we have created accepts the password, the stored salt, and the user’s hash. We will first check whether <strong class="source-inline">storedHash</strong> has a length of 64 and <strong class="source-inline">storedSalt</strong> has a size of 128 to validate whether it is 64 bytes. We will get the computed hash by using the stored salt and message digest for the password, and lastly, we will check whether the passwords match by seeing whether the calculated hash and stored hash <span class="No-Break">are equal.</span></p>
			<p>The last method we need to implement is the <strong class="source-inline">authenticate()</strong> method. This is the primary method that our authenticate endpoint <span class="No-Break">will call.</span></p>
			<p>Let’s <a id="_idIndexMarker551"/>have a look the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
public UserEntity authenticate(String email, String password)
  throws NoSuchAlgorithmException {
  if (
    email.isEmpty() || password.isEmpty()
  ) throw new BadCredentialsException("Unauthorized");
  var userEntity = userService.searchByEmail(email);
  if (userEntity == null) throw new
      BadCredentialsException("Unauthorized");
  var verified = verifyPasswordHash(
    password,
    userEntity.getStoredHash(),
    userEntity.getStoredSalt()
  );
  if (!verified) throw new
      BadCredentialsException("Unauthorized");
  return userEntity;
}</pre>
			<p>The <a id="_idIndexMarker552"/>method first checks whether the user exists using the <strong class="source-inline">searchByEmail()</strong> method and checks whether the password is valid using the <strong class="source-inline">verifyPasswordHash()</strong> method that we <span class="No-Break">have created.</span></p>
			<h4>Creating the authentication controller</h4>
			<p>Now, we <a id="_idIndexMarker553"/>will create the controllers of our authentication. This would create the primary endpoint for our login. The first step is to create a class named <strong class="source-inline">AuthenticateController</strong> under the controllers’ package, and next, we will make <strong class="source-inline">authenticate()</strong> with the <span class="No-Break">following implementation:</span></p>
			<pre class="source-code">
@RestController
@AllArgsConstructor
class AuthenticateController {
  private final AuthenticationManager
    authenticationManager;
  private final JwtUtil jwtTokenUtil;
  private final ApplicationUserDetailsService
    userDetailsService;
  @RequestMapping(value = "/authenticate")
  @ResponseStatus(HttpStatus.CREATED)
  public AuthenticationResponse authenticate(
    @RequestBody AuthenticationRequest req
  ) throws Exception {
    UserEntity user;
    try {
      user = userDetailsService.authenticate(
        req.getEmail(), req.getPassword());
    } catch (BadCredentialsE<a id="_idTextAnchor139"/><a id="_idTextAnchor140"/>xception e) {
      throw new Exception("Incorrect username or password",
                           e);
    }</pre>
			<p>Then, we <a id="_idIndexMarker554"/>get the details of the user by calling <strong class="source-inline">loadUserByUsername</strong> from <strong class="source-inline">userDetailsService</strong> but don’t forget to pass the email address of the user <span class="No-Break">like so:</span></p>
			<pre class="source-code">
    var userDetails = userDetailsService.loadUserByUsername(user.getEmail());
    System.out.println(userDetails);
    var jwt = jwtTokenUtil.generateToken(userDetails);
    return new AuthenticationResponse(jwt);
  }
}</pre>
			<p>The <strong class="source-inline">authenticate()</strong> method accepts an <strong class="source-inline">AuthenticationRequest</strong> body, which requires an email address and password. We will use <strong class="source-inline">service.authenticate()</strong> we previously created to check whether the credentials are valid. Once this is confirmed, we can generate the token using <strong class="source-inline">generateToken()</strong> from our utilities and return an <span class="No-Break"><strong class="source-inline">AuthenticationResponse</strong></span><span class="No-Break"> object.</span></p>
			<h4>Creating the authentication filters</h4>
			<p>The <a id="_idIndexMarker555"/>last step we need to accomplish is to create the filter for our authentication. We will use filters to validate each HTTP request with a valid JWT in the request headers. We need to make sure that a filter is invoked only once for each request. We can achieve this by using <strong class="source-inline">OncePerRequestFilter</strong>. We will extend our filter class with the filter to ensure that the filter is only executed once for a <span class="No-Break">specific request.</span></p>
			<p>Now, let’s create our authentication filter; first, let’s create a class named <strong class="source-inline">JwtRequestFilter</strong> under the <strong class="source-inline">filters</strong> package, and we will extend this class with <strong class="source-inline">OncePerRequestFilter</strong>, then we will override the <strong class="source-inline">doFilterInternal()</strong> method, which has parameters of <strong class="source-inline">HttpServletRequest</strong>, <strong class="source-inline">HttpServletResponse</strong>, and <strong class="source-inline">FilterChain</strong>. We will also inject <strong class="source-inline">ApplicationUserDetailsService</strong> and <strong class="source-inline">JwtUtil</strong> for the credentials and <span class="No-Break">token validation.</span></p>
			<p>Our code will look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
@AllArgsConstructor
@Component
public class JwtRequestFilter extends OncePerRequestFilter {
  private final ApplicationUserDetailsService
    userDetailsService;
  private final JwtUtil jwtUtil;
  @Override
  protected void doFilterInternal(
    HttpServletRequest request,
    HttpServletResponse response,
    FilterChain chain
  ) throws ServletException, IOException {
  }
}</pre>
			<p>Now, for the implementation of the method, the first thing we need to do is extract the JWT <a id="_idIndexMarker556"/>from the request header. Let’s implement the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
//JWT Extraction
final String authorizationHeader =
  request.getHeader("Authorization");
    String username = null;
    String token = null;
    if (
      authorizationHeader != null &amp;&amp;
        authorizationHeader.startsWith("Bearer ")
    ) {
      token = authorizationHeader.substring(7);
      username = jwtUtil.extractUsername(token);
    }</pre>
			<p>The preceding code retrieves the JWT on the header with an <em class="italic">authorization</em> key, and when a token is retrieved, we will extract the username to check whether the <span class="No-Break">user exists.</span></p>
			<p>Then, the next step is to load the user’s details using the retrieved username and check that the token is valid and not yet expired. If the token is good, we will create a <strong class="source-inline">UsernamePasswordAuthenticationToken</strong> from the user details and the list of the <span class="No-Break">authorized users.</span></p>
			<p>We <a id="_idIndexMarker557"/>will set the new authenticated principal in our security context; let’s have a look the following <span class="No-Break">code implementation:</span></p>
			<pre class="source-code">
//JWT Extraction section
// JWT Validation and Creating the new
// UsernamePasswordAuthenticationToken
if (
      username != null &amp;&amp;
      SecurityContextHolder.getContext()
        .getAuthentication() == null
    ) {
      UserDetails userDetails =
        this.userDetailsService
         .loadUserByUsername(username);
      if (jwtUtil.validateToken(token, userDetails)) {
        var usernamePasswordAuthenticationToken =
          new UsernamePasswordAuthenticationToken(
          userDetails,
          null,
          userDetails.getAuthorities()
        );
        usernamePasswordAuthenticationToken.setDetails(
          new WebAuthenticationDetailsSource()
            .buildDetails(request)
        );
        SecurityContextHolder
          .getContext()
          .setAuthentication(
            usernamePasswordAuthenticationToken);
      }
    }
    chain.doFilter(request, response);
  }</pre>
			<p>We <a id="_idIndexMarker558"/>have successfully created a filter for our requests, and our authentication endpoints are all configured. The only thing we need to do is finalize our configuration. We would want to modify <strong class="source-inline">UserDetailsService</strong> with our <span class="No-Break">custom authentication.</span></p>
			<p>To achieve this, we will go back to our <strong class="source-inline">SecurityConfig</strong> file and place the following code implementation on our <strong class="source-inline">configure(AuthenticationManagerBuilder </strong><span class="No-Break"><strong class="source-inline">auth)</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
private final ApplicationUserDetailsService userDetailsService;
@Override
protected void configure(AuthenticationManagerBuilder auth) throws Exception {
    auth.userDetailsService(userDetailsService);
}</pre>
			<p>The next step is we need to add the filter we have created; under the <strong class="source-inline">configure(HttpSecurity http)</strong> method, we will place the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
private final JwtRequestFilter jwtFilter;
@Override
protected void configure(HttpSecurity http) throws Exception {
   …. Http security configurations
   http.addFilterBefore(jwtFilter,
     UsernamePasswordAuthenticationFilter.class);
}</pre>
			<p>Now <a id="_idIndexMarker559"/>that our security configuration is complete, our final step is to add authentication to our anti-hero endpoints. A valid JWT is required upon making a request to the <span class="No-Break">anti-hero endpoints.</span></p>
			<p>To achieve this, we will annotate <strong class="source-inline">AntiHeroController</strong> with <strong class="source-inline">@PreAuthorize("isAuthenticated()")</strong> to configure the endpoints with the <span class="No-Break">authentication process:</span></p>
			<pre class="source-code">
@PreAuthorize("isAuthenticated()")
public class AntiHeroController {
… methods
}</pre>
			<p>We have successfully implemented Spring Security and JWT on our application; let’s simulate the <span class="No-Break">endpoints created.</span></p>
			<p>We will send an HTTP <strong class="source-inline">GET</strong> request for the anti-hero controller to get the list of <span class="No-Break">all anti-heroes:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer060">
					<img alt="Figure 7.2 – 403 Forbidden on getting﻿ the anti-heroes list" src="image/B18159_07_02.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – 403 Forbidden on getting the anti-heroes list</p>
			<p>When <a id="_idIndexMarker560"/>we send a sample request to one of the anti-heroes, this will now return a 403 error since it requires a valid token from our request headers. In this case, we need to create a new user using the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">register</strong></span><span class="No-Break"> endpoint:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer061">
					<img alt="Figure 7.3 – User registration" src="image/B18159_07_03.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – User registration</p>
			<p>After successfully creating our user, this is now a valid credential, and we can log in using the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">authenticate</strong></span><span class="No-Break"> endpoint:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer062">
					<img alt="Figure 7.4 – New credential login" src="image/B18159_07_04.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – New credential login</p>
			<p>We <a id="_idIndexMarker561"/>can see in the preceding example that our login is successful and the <strong class="source-inline">/authenticate</strong> endpoint returned a valid token. We can now use the token in the request header to send a request to <span class="No-Break">anti-hero endpoints:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer063">
					<img alt="Figure 7.5 – Anti-hero endpoint returns the list successfully" src="image/B18159_07_05.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Anti-hero endpoint returns the list successfully</p>
			<p>We can see in the preceding example that we have used the generated token in our authorization header, and we have received a 200 response and returned the list <span class="No-Break">of anti-heroes.</span></p>
			<p>We <a id="_idIndexMarker562"/>have now successfully created the custom authentication and authorization for our Spring Boot application using Spring Security. In the next section, we will discuss an additional topic relating to security, <span class="No-Break">called IDaaS.</span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor141"/>IDaaS</h1>
			<p>In the <a id="_idIndexMarker563"/>previous section, we created our custom login authentication using Spring Security. We utilized some of the features of Spring Security and also used JWT to store user states and validate credentials. However, this example is not enough of a reliable and secure way of implementing authentication for <span class="No-Break">our application.</span></p>
			<p>Large and enterprise applications nowadays demand several security features to be able to prevent possible vulnerabilities that can occur. These features can include the architecture <a id="_idIndexMarker564"/>and the implementation of other services, such as SSO and <strong class="bold">Multi-Factor Authentication</strong> (<strong class="bold">MFA</strong>). These features can be cumbersome to work with and can require several sprints to modify, leading to a longer time to develop. This is where IDaaS comes to <span class="No-Break">the rescue.</span></p>
			<p>IDaaS is a delivery model that allows users to connect, authenticate, and use identity management services from the cloud. IDaaS helps speed up the development process as all authentication and authorization processes are provided under <span class="No-Break">the hood.</span></p>
			<p>It is commonly used by large and enterprise applications because of the advantages and features it offers. IDaaS <a id="_idIndexMarker565"/>systems utilize the power of cloud computing to handle <strong class="bold">Identity Access Management</strong> (<strong class="bold">IAM</strong>), which ensures that the right users access the resources. It is very helpful as companies do not need to worry about security and IAM responsibilities, which are very demanding due to the adaptation of <span class="No-Break">cybersecurity threats.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor142"/>Types of IDaaS</h2>
			<p>There are <a id="_idIndexMarker566"/>several types of IDaaS available on the market; some providers only provide clients with a directory, others offer several sets of features, which include SSO and MFA, but we will split IDaaS into <span class="No-Break">two categories:</span></p>
			<ul>
				<li><span class="No-Break">Basic IDaaS</span></li>
				<li><span class="No-Break">Enterprise IDaaS</span></li>
			</ul>
			<h3>Basic IDaaS</h3>
			<p>Small- and medium-sized businesses commonly use basic IDaaS. It usually provides SSO and MFA <a id="_idIndexMarker567"/>and a cloud directory for <span class="No-Break">storing credentials.</span></p>
			<p>Basic IDaaS providers <a id="_idIndexMarker568"/>are also packaged with a more straightforward interface that gives users the capability to handle configuration and <span class="No-Break">administrative tasks.</span></p>
			<h3>Enterprise IDaaS</h3>
			<p>Enterprise IDaaS, compared to basic IDaaS, is more complex and used by large and enterprise <a id="_idIndexMarker569"/>businesses. This is commonly <a id="_idIndexMarker570"/>used to extend the IAM infrastructure of the organization and provide access management to web, mobile, and <span class="No-Break">API environments.</span></p>
			<p>There are <a id="_idIndexMarker571"/>five requirements that an IDaaS <span class="No-Break">should possess:</span></p>
			<ul>
				<li><strong class="bold">SSO</strong>: Gives users the capability to access all platforms and applications using a <span class="No-Break">single authentication</span></li>
				<li><strong class="bold">MFA</strong>: Increases the layers of security, requiring the user to present two valid pieces of evidence to prove <span class="No-Break">their identity</span></li>
				<li><strong class="bold">Cloud directory</strong>: Provides a cloud directory where data and credentials can <span class="No-Break">be stored</span></li>
				<li><strong class="bold">Access security</strong>: Policy-based management for applications for <span class="No-Break">increasing security</span></li>
				<li><strong class="bold">Provisioning</strong>: Provides capabilities to automate the exchange of user identities <a id="_idIndexMarker572"/>between applications and service providers <a id="_idIndexMarker573"/>using <strong class="bold">System for Cross-Domain Identity </strong><span class="No-Break"><strong class="bold">Management</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">SCIM</strong></span><span class="No-Break">)</span></li>
			</ul>
			<p>Those are the five characteristics required of <span class="No-Break">an IDaaS.</span></p>
			<p>If you <a id="_idIndexMarker574"/>are wondering about any examples of an IDaaS that you can use, here are some <span class="No-Break">service providers:</span></p>
			<ul>
				<li><strong class="bold">Google Cloud Identity</strong>: Google Cloud Identity provides a wide range of security <a id="_idIndexMarker575"/>features for users to enable authentication, access management, and authorization. It is an enterprise IDaaS with several security features, such as SSO, MFA, automated user provisioning, and <span class="No-Break">context-aware access.</span></li>
			</ul>
			<p>To learn <a id="_idIndexMarker576"/>more about Google Cloud Identity, you can <span class="No-Break">visit </span><a href="https://cloud.google.com/identity"><span class="No-Break">https://cloud.google.com/identity</span></a><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Okta Workforce Identity</strong>: Okta is one of the top IDaaS providers on the market. It is <a id="_idIndexMarker577"/>also an enterprise IDaaS provider that has several basic and advanced features, such as SSO, MFA, Universal Directory, B2B integration, and API <span class="No-Break">Access Management.</span></li>
			</ul>
			<p>Okta and Auth0 joined forces around 2021, providing identity platforms and solutions such as universal login, password-less authentication, and <span class="No-Break">machine-to-machine communication.</span></p>
			<p>To learn <a id="_idIndexMarker578"/>more about Auth0 and Okta, you can visit the following links: <a href="https://auth0.com/">https://auth0.com/</a> <span class="No-Break">and </span><a href="https://www.okta.com/workforce-identity/"><span class="No-Break">https://www.okta.com/workforce-identity/</span></a><span class="No-Break">.</span></p>
			<ul>
				<li><strong class="bold">Azure Active Directory</strong>: Azure Active Directory is also an enterprise-grade IDaaS solution, the <a id="_idIndexMarker579"/>same as the other providers. It offers a wide range of security solutions, has several features, such as identity governance, unified identity management, and password-less authentication, for users, and best of all has a basic tier that is free <span class="No-Break">to use.</span></li>
			</ul>
			<p>To learn <a id="_idIndexMarker580"/>more about Azure Active Directory, you can <span class="No-Break">visit </span><a href="https://azure.microsoft.com/en-us/services/active-directory/"><span class="No-Break">https://azure.microsoft.com/en-us/services/active-directory/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor143"/>Summary</h1>
			<p>With this, we have reached the end of this chapter. Let’s have a recap of the valuable things you have learned. You have learned about the concept and importance of CORS and how it can provide security for accessing resources. We have discussed the different ways that we can implement CORS in our Spring Boot applications, which are at the method level, at the controller level, and a combination of <span class="No-Break">both approaches.</span></p>
			<p>We have also learned about the concept and features of Spring Security and discussed the implementation of custom authentication and authorization in our application. Lastly, we have also learned about IDaaS, a delivery model that allows users to connect, authenticate, and use identity management services from <span class="No-Break">the cloud.</span></p>
			<p>In the next chapter, we will be learning about the integration of event loggers into our Spring <span class="No-Break">Boot application.</span></p>
		</div>
	</body></html>