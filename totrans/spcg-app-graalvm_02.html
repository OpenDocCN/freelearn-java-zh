<html><head></head><body>
		<div id="_idContainer016">
			<h1 id="_idParaDest-15"><em class="italic"><a id="_idTextAnchor014"/>Chapter 1</em>: Evolution of Java Virtual Machine<a id="_idTextAnchor015"/></h1>
			<p><a id="_idTextAnchor016"/>This chapter will walk you through the evolution of <strong class="bold">Java Virtual Machine</strong> (<strong class="bold">JVM</strong>), and how it optimized the interpreter and compiler. We will learn about C1 and C2 compilers and various types of code optimizations that the JVM performs to run Java programs faster.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Introduction to GraalVM</li>
				<li>Learning how JVM works</li>
				<li>Understanding the JVM architecture</li>
				<li>Understanding the kind of optimizations JVM performs with <strong class="bold">Just-In-Time</strong> (<strong class="bold">JIT</strong>) compilers</li>
				<li>Learning the pros and cons of the JVM approach</li>
			</ul>
			<p>By the end of this chapter, you will have a clear understanding of the JVM architecture. This is critical in understanding the GraalVM architecture and how GraalVM further optimizes and builds on top of JVM best practices.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor017"/>Technical requirements</h1>
			<p>This chapter does not require any specific software/hardware.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>Introduction to GraalVM</h1>
			<p>GraalVM is a high-performance VM that <a id="_idIndexMarker000"/>provides the runtime for modern cloud-native applications. Cloud-native applications are built based on the service architecture. The microservice architecture changes the paradigm of building micro applications, which challenges the fundamental way we build and run applications. The microservices runtimes demand a different set of requirements.</p>
			<p>Here are some of the <a id="_idIndexMarker001"/>key requirements of a cloud-native application built on the microservice architecture:</p>
			<ul>
				<li><strong class="bold">Smaller footprint</strong>: Cloud-native applications run on the "pay for what we use" model. This means that the cloud-native runtimes need to have a smaller memory footprint and should run with the optimum CPU cycles. This will help run more workloads with fewer cloud resources.</li>
				<li><strong class="bold">Quicker bootstrap</strong>: Scalability is one of the most important aspects of container-based microservices architecture. The faster the application's bootup, the faster it can scale the clusters. This is even more important for serverless architectures, where the code is initialized and run and then shut down on request.</li>
				<li><strong class="bold">Polyglot and interoperability</strong>: Polyglot is the reality; each language has its strengths and will continue to. Cloud-native microservices are being built with different languages. It's very important to have an architecture that embraces the polyglot requirements and provides interoperability across languages. As we move to modern architectures, it's important to reuse as much code and logic as possible, that is time-tested and critical for business.</li>
			</ul>
			<p>GraalVM provides a <a id="_idIndexMarker002"/>solution to all these requirements and provides a common platform to embed and run polyglot cloud-native applications. It is built on JVM and brings in further optimizations. Before understanding how GraalVM works, it's important to understand the internal workings of JVM.</p>
			<p>Traditional JVM (before GraalVM) has evolved into the most mature runtime implementation. While it has some of the previously listed requirements, it is not built for cloud-native applications, and it comes with its baggage of monolith design principles. It is not an ideal runtime for cloud-native applications.</p>
			<p>This chapter will walk you through in detail how JVM works and the key components of the JVM architecture.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor019"/>Learning how JVM works</h1>
			<p>Java is one of the <a id="_idIndexMarker003"/>most successful and widely used languages. Java has been very successful because of its <em class="italic">write once, run anywhere</em> design principle. JVM realizes this design principle by sitting between the application code and the machine code and interpreting the application code to machine code.</p>
			<p>Traditionally, there two ways of running application code:</p>
			<ul>
				<li><strong class="bold">Compilers</strong>: Application code is <a id="_idIndexMarker004"/>directly compiled to machine code (in C, C++). Compilers go through a build process of <a id="_idIndexMarker005"/>converting the application code to machine code. Compilers generate the most optimized code for a specific target architecture. The application code has to be compiled to target architectures. In general, the compiled code always runs faster than interpreted code, and issues with code semantics can be identified during compilation time rather than runtime.</li>
				<li><strong class="bold">Interpreters</strong>: Application code is <a id="_idIndexMarker006"/>interpreted to machine code line by line (JavaScript and so on). Since interpreters run line by line, the <a id="_idIndexMarker007"/>code may not be optimized to the target architecture, and run slowly, compared to the compiled code. Interpreters have the flexibility of writing once and running anywhere. A good example is the JavaScript code that is predominantly used for web applications. This runs pretty much on different target browsers with minimal or no changes in the application code. Interpreters are generally slow and are good for running small applications.</li>
			</ul>
			<p>JVM has taken the best of both interpreters and compilers. The following diagram illustrates how JVM runs the Java code using both the interpreter and compiler approaches:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="image/B16878_Figure_1.1.jpg" alt="Figure 1.1 – Java compiler and interpreter&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Java compiler and interpreter</p>
			<p>Let's see <a id="_idIndexMarker008"/>how this works:</p>
			<ul>
				<li>Java Compiler (<strong class="bold">javac</strong>) compiles the <a id="_idIndexMarker009"/>Java application <a id="_idIndexMarker010"/>source code to <strong class="bold">bytecode</strong> (intermediate format). </li>
				<li>JVM interprets the bytecode to machine code line by line at runtime. This helps in translating the optimized bytecode to target machine code, helping in running the same application code on different target machines, without re-programming or re-compiling.</li>
				<li>JVM also has a Just-In-Time (<strong class="bold">JIT)</strong> compiler to further optimize the code at runtime by profiling the code. </li>
			</ul>
			<p>In this section, we looked at how Java Compiler and JIT work together to run Java code on JVM at a higher level. In the next section, we will learn about the architecture of JVM.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor020"/>Understanding the JVM architecture</h1>
			<p>Over the years, JVM has <a id="_idIndexMarker011"/>evolved into the most mature VM runtime. It has a very structured and sophisticated implementation of a runtime. This is one of the <a id="_idIndexMarker012"/>reasons why GraalVM is built to utilize all the best features of the JVM and provide further optimizations required for the cloud-native world. To better appreciate the GraalVM architecture and optimizations that it brings on top of the JVM, it's important to understand the JVM architecture.</p>
			<p>This section walks you through the JVM architecture in detail. The following diagram shows the high-level architecture of various subsystems in JVM:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/B16878_Figure_1.2.jpg" alt="Figure 1.2 – High-level architecture of JVM&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – High-level architecture of JVM</p>
			<p>The rest of this <a id="_idIndexMarker013"/>section will <a id="_idIndexMarker014"/>walk you through each of these subsystems in detail.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor021"/>Class loader subsystem</h2>
			<p>The class loader subsystem is <a id="_idIndexMarker015"/>responsible for <a id="_idIndexMarker016"/>allocating all the relevant <strong class="source-inline">.class</strong> files and loading these classes to the memory. The class loader subsystem is also responsible for linking and verifying the schematics of the <strong class="source-inline">.class</strong> file before the classes are initialized and loaded to memory. The class loader subsystem has the following three key functionalities:</p>
			<ul>
				<li>Loading</li>
				<li>Linking</li>
				<li>Initializing</li>
			</ul>
			<p>The following diagram shows the various components of the class loader subsystem:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/B16878_Figure_1.3.jpg" alt="Figure 1.3 – Components of the class loader subsystem&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Components of the class loader subsystem</p>
			<p>Let's now look at <a id="_idIndexMarker017"/>what each <a id="_idIndexMarker018"/>of these components does.</p>
			<h3>Loading</h3>
			<p>In traditional compiler-based languages such as C/C++, the source code is <a id="_idIndexMarker019"/>compiled to object code, and then all the dependent object code is linked by a linker before the final executable is built. All this is part of the build process. Once the final executable is built, it is then loaded into the memory by the loader. Java works differently.</p>
			<p>Java source code (<strong class="source-inline">.java</strong>) is compiled by Java Compiler (<strong class="source-inline">javac</strong>) to bytecode (<strong class="source-inline">.class</strong>) files. Class loader is one of the key subsystems of the JVM, which is responsible for loading all the dependent classes that are required to run the application. This includes the classes that are <a id="_idIndexMarker020"/>written by the application developer, the libraries, and the <strong class="bold">Java Software Development Kit</strong> (<strong class="bold">SDK</strong>) classes.</p>
			<p>There are three types of class loaders as part of this system:</p>
			<ul>
				<li><strong class="bold">Bootstrap</strong>: Bootstrap is the <a id="_idIndexMarker021"/>first classloader that loads <strong class="source-inline">rt.jar</strong>, which <a id="_idIndexMarker022"/>contains all the Java Standard Edition JDK classes, such as <strong class="source-inline">java.lang</strong>, <strong class="source-inline">java.net</strong>, <strong class="source-inline">java.util</strong>, and <strong class="source-inline">java.io</strong>. Bootstrap is responsible for loading all the classes that are required to run any Java application. This is a core part of the JVM and is implemented in the native language.</li>
				<li><strong class="bold">Extensions</strong>: Extension class loaders <a id="_idIndexMarker023"/>load all the <a id="_idIndexMarker024"/>extensions to the JDK found in the <strong class="source-inline">jre</strong>/<strong class="source-inline">lib</strong>/<strong class="source-inline">ext</strong> directory. Extension class loader classes are typically extension classes of the bootstrap implemented in Java. The extension class loader is implemented in Java (<strong class="source-inline">sun.misc.Launcher$ExtClassLoader.class</strong>).</li>
				<li><strong class="bold">Application</strong>: The <a id="_idIndexMarker025"/>application class loader (also referred to as a system class loader) is a child class of the <a id="_idIndexMarker026"/>extension class loader. The application class loader is responsible for loading the application classes in the application class path (<strong class="source-inline">CLASSPATH</strong> env variable). This is also implemented in Java (<strong class="source-inline">sun.misc.Launcher$AppClassLoader.class</strong>).</li>
			</ul>
			<p>Bootstrap, extension, and application class loaders are <a id="_idIndexMarker027"/>responsible for loading all the classes that are required to run the application. In the event where the class loaders do not find the required classes, <strong class="source-inline">ClassNotFoundException</strong> is thrown.</p>
			<p>Class loaders implement the delegation hierarchy algorithm. The following diagram shows how the class loader implements the delegation hierarchy algorithm to load all the required classes:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/B16878_Figure_1.4.jpg" alt="Figure 1.4 – Class loader delegation hierarchy algorithm implementation flowchart&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Class loader delegation hierarchy algorithm implementation flowchart</p>
			<p>Let's understand how this <a id="_idIndexMarker028"/>algorithm works:</p>
			<ol>
				<li>JVM looks for the class in the method area (this will be discussed in detail later in this section). If it does not find the class, it will ask the application class loader to load the class into memory.</li>
				<li>The application class loader delegates the call to the extension class loader, which in turn delegates to the bootstrap class loader.</li>
				<li>The bootstrap class loader looks for the class in the bootstrap <strong class="source-inline">CLASSPATH</strong>. If it finds the class, it will load to the memory. If it does not find the class, control is delegated to the extension class loader.</li>
				<li>The extension class loader <a id="_idIndexMarker029"/>will try to find the class in the extension <strong class="source-inline">CLASSPATH</strong>. If it finds the class, it will load to the memory. If it does not find the class, control is delegated to the application class loader.</li>
				<li>The application class loader will try to look for the class in <strong class="source-inline">CLASSPATH</strong>. If it does not find it, it will raise <strong class="source-inline">ClassNotFoundException</strong>, otherwise, the class is loaded into the method area, and the JVM will start using it.</li>
			</ol>
			<h3>Linking</h3>
			<p>Once the classes are loaded into the <a id="_idIndexMarker030"/>memory (into the method area, discussed further in the <em class="italic">Memory subsystem</em> section), the class loader subsystem will perform linking. The linking process consists of the following steps:</p>
			<ul>
				<li><strong class="bold">Verification</strong>: The loaded <a id="_idIndexMarker031"/>classes are verified for their adherence to the semantics of the language. The binary representation of the class that is loaded is parsed into the internal data structure, to ensure that the method runs properly. This might require the class loader to load recursively the hierarchy of inherited classes all the way to <strong class="source-inline">java.lang.Object</strong>. The verification phase validates and ensures that the methods run without any issues.</li>
				<li><strong class="bold">Preparation</strong>: Once all the classes are loaded and verified, JVM allocates memory for class variables (static variables). This also includes calling static initializations (static blocks).</li>
				<li><strong class="bold">Resolution</strong>: JVM then resolves by locating the classes, interfaces, fields, and methods referenced in the symbol table. The JVM might resolve the symbol during initial verification (static resolution) or may resolve when the class is being verified (lazy resolution).</li>
			</ul>
			<p>The class loader subsystem raises <a id="_idIndexMarker032"/>various exceptions, including the following:</p>
			<ul>
				<li><strong class="source-inline">ClassNotFoundException</strong></li>
				<li><strong class="source-inline">NoClassDefFoundError</strong></li>
				<li><strong class="source-inline">ClassCastException</strong> </li>
				<li><strong class="source-inline">UnsatisfiedLinkError</strong></li>
				<li><strong class="source-inline">ClassCircularityError</strong></li>
				<li><strong class="source-inline">ClassFormatError</strong></li>
				<li><strong class="source-inline">ExceptionInInitializerError</strong></li>
			</ul>
			<p>You can refer to the Java specifications for more details: <a href="https://docs.oracle.com/en/java/javase">https://docs.oracle.com/en/java/javase</a>.</p>
			<h3>Initializing</h3>
			<p>Once all the classes are loaded and symbols are resolved, the initialization phase starts. During this phase, the <a id="_idIndexMarker033"/>classes are initialized (new). This includes initializing the static variables, executing static blocks, and invocating reflective methods (<strong class="source-inline">java.lang.reflect</strong>). This might also result in loading those classes.</p>
			<p>Class loaders load all the classes into the memory before the application can run. Most of the time, the class loader has to load the full hierarchy of classes and dependent classes (though there is lazy resolution) to validate the schematics. This is time-consuming and also takes up a lot of memory footprint. It's even slower if the application uses reflection and the reflected classes need to be loaded.</p>
			<p>After learning about the class loader subsystem, let's now understand how the memory subsystem works.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor022"/>Memory subsystem</h2>
			<p>The memory subsystem is one of the <a id="_idIndexMarker034"/>most critical <a id="_idIndexMarker035"/>subsystems of the JVM. The memory subsystem, as the name suggests, is responsible for managing the allocated memory of method variables, heaps, stacks, and registers. The following diagram shows the architecture of the memory subsystem:</p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/B16878_Figure_1.5.jpg" alt="Figure 1.5 – Memory subsystem architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Memory subsystem architecture</p>
			<p>The memory subsystem has two areas: JVM level and thread level. Let's discuss each in detail.</p>
			<h3>JVM level</h3>
			<p>JVM-level memory, as the <a id="_idIndexMarker036"/>name suggests, is <a id="_idIndexMarker037"/>where the objects are stored at the JVM level. This is not thread-safe, as multiple threads might be accessing these objects. This explains why programmers are recommended to code thread-safe (synchronization) when they update the objects in this area. There are two areas of JVM-level memory:</p>
			<ul>
				<li><strong class="bold">Method</strong>: The <a id="_idIndexMarker038"/>method area is where all the class-level <a id="_idIndexMarker039"/>data is stored. This includes the class names, hierarchy, methods, variables, and static variables.</li>
				<li><strong class="bold">Heap</strong>: The heap is <a id="_idIndexMarker040"/>where all the <a id="_idIndexMarker041"/>objects and the instance variables are stored.</li>
			</ul>
			<h3>Thread level</h3>
			<p>Thread-level memory is <a id="_idIndexMarker042"/>where all the <a id="_idIndexMarker043"/>thread-local objects are stored. This is accessible/visible to the respective threads, hence it is thread-safe. There are three areas of the thread-level memory:</p>
			<ul>
				<li><strong class="bold">Stack</strong>: For each method call, a stack <a id="_idIndexMarker044"/>frame is created, which stores all the <a id="_idIndexMarker045"/>method-level data. The stack frame consists of all the variables/objects that are created within the method scope, operand stack (used to perform intermediate operations), the frame data (which stores all the symbols corresponding to the method), and exception catch block information.</li>
				<li><strong class="bold">Registers</strong>: PC registers <a id="_idIndexMarker046"/>keep track of the instruction <a id="_idIndexMarker047"/>execution and point to the current instruction that is being executed. This is maintained for each thread that is executing.</li>
				<li><strong class="bold">Native Method Stack</strong>: The native method stack is a <a id="_idIndexMarker048"/>special type of stack that stores the native method information, which is <a id="_idIndexMarker049"/>useful when calling and executing the native methods.</li>
			</ul>
			<p>Now that the classes are loaded into the memory, let's look at how the JVM execution engine works.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor023"/>JVM execution engine subsystem</h2>
			<p>The JVM execution engine is the <a id="_idIndexMarker050"/>core of the JVM, where <a id="_idIndexMarker051"/>all the execution happens. This is where the bytecodes are interpreted and executed. The JVM execution engine uses the memory subsystem to store and retrieve the objects. There are three key components of the JVM execution engine, as shown:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/B16878_Figure_1.6.jpg" alt="Figure 1.6 – JVM execution engine architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – JVM execution engine architecture</p>
			<p>We will talk about each component in detail in the following sections.</p>
			<h3>Bytecode interpreter</h3>
			<p>As mentioned earlier in this chapter, bytecode (<strong class="source-inline">.class</strong>) is the input to the JVM. The JVM bytecode interpreter <a id="_idIndexMarker052"/>picks each instruction from the <strong class="source-inline">.class</strong> file and converts it to machine code and executes it. The <a id="_idIndexMarker053"/>obvious disadvantage of interpreters is that they are not optimized. The instructions are executed in sequence, and even if the same method is called several times, it goes through each instruction, interprets it, and then executes.</p>
			<h3>JIT compiler</h3>
			<p>The JIT compiler saves the <a id="_idIndexMarker054"/>day by profiling the code that is <a id="_idIndexMarker055"/>being executed by interpreters, identifies areas where the code can be optimized and compiles them to target machine code, so that they can be executed faster. A combination of bytecode and compiled code snippets provide the optimum way to execute the class files. </p>
			<p>The following diagram illustrates the detailed workings of JVM, along with the various types of JIT compilers that the JVM uses to optimize the code:</p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/B16878_Figure_1.7.jpg" alt="Figure 1.7 – The detailed working of JVM with JIT compilers&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – The detailed working of JVM with JIT compilers</p>
			<p>Let's understand the <a id="_idIndexMarker056"/>workings shown in the previous diagram:</p>
			<ol>
				<li value="1">The JVM interpreter steps through each bytecode and interprets it with machine code, using the bytecode to machine code mapping.</li>
				<li>JVM profiles the code consistently using a counter, to count the number of times a code is executed, and if the counter reaches a threshold, it uses the JIT compiler to compile that code for optimization and stores it in the code cache.</li>
				<li>JVM then checks whether that compilation unit (block) is already compiled. If JVM finds a compiled code in the code cache, it will use the compiled code for faster execution.</li>
				<li>JVM uses two types of compilers, the C1 compiler and the C2 compiler, to compile the code. </li>
			</ol>
			<p>As illustrated in <em class="italic">Figure 1.7</em>, the JIT compiler brings in optimizations by profiling the code that is running and, over a period of time, it identifies the code that can be compiled. The <a id="_idIndexMarker057"/>JVM runs the compiled snippets of code instead of interpreting the code. It is a hybrid method of running interpreted code and compiled code.</p>
			<p>JVM introduced two types of compilers, C1 (client) and C2 (server), and the recent versions of JVM use the best of both for optimizing and compiling the code at runtime. Let's understand these types better:</p>
			<ul>
				<li><strong class="bold">C1 compiler</strong>: A performance <a id="_idIndexMarker058"/>counter was introduced, which counted the number of times a particular method/snippet of code is executed. Once a <a id="_idIndexMarker059"/>method/code snippet is used a particular number of times (threshold), then that particular code snippet is compiled, optimized, and cached by the C1 compiler. The next time that code snippet is called, it directly executes the compiled machine instructions from the cache, rather than going through the interpreter. This brought in the first level of optimization.</li>
				<li><strong class="bold">C2 compiler</strong>: While the code is <a id="_idIndexMarker060"/>getting executed, the JVM will <a id="_idIndexMarker061"/>perform runtime code profiling and come up with code paths and hotspots. It then runs the C2 compiler to further optimize the hot code paths. This is <a id="_idIndexMarker062"/>also known as a hotspot.</li>
			</ul>
			<p>C1 is faster and good for short-running applications, while C2 is slower and heavy, but is ideal for long-running <a id="_idIndexMarker063"/>processes such as daemons and servers, so the code performs better over time.</p>
			<p>In Java 6, there is a command-line option to use either C1 or C2 methods (with the command-line arguments <strong class="source-inline">-client</strong> (for C1) and <strong class="source-inline">-server</strong> (for C2)). In Java 7, there is a command-line option to use both. Since Java 8, both C1 and C2 compilers are used for optimization as the default behavior.</p>
			<p>There are five tiers/levels of <a id="_idIndexMarker064"/>compilation. Compilation logs can be generated to understand which Java method is compiled using which compiler tier/level. The following are the five tiers/levels of compilation:</p>
			<ul>
				<li>Interpreted code (level 0)</li>
				<li>Simple C1 compiled code (level 1)</li>
				<li>Limited C1 compiled code (level 2)</li>
				<li>Full C1 compiled code (level 3)</li>
				<li>C2 compiled code (level 4)</li>
			</ul>
			<p>Let's now look at the various types of code optimizations that the JVM applies during compilation.</p>
			<h3>Code optimizations</h3>
			<p>The JIT compiler <a id="_idIndexMarker065"/>generates the internal representation of the code that is being compiled to understand the semantics and syntax. These internal <a id="_idIndexMarker066"/>representations are tree data structures, on which the JIT will then run the code optimization (as multiple threads, which can be controlled with the <strong class="source-inline">XcompilationThreads</strong> options from the command line).</p>
			<p>The following are some of the optimizations that the JIT compilers perform on the code:</p>
			<ul>
				<li><strong class="bold">Inlining</strong>: One of the most common <a id="_idIndexMarker067"/>programming practices in object-oriented programming is to access the member <a id="_idIndexMarker068"/>variables through getter and setter methods. Inlining optimization replaces these getter/setter methods with actual variables. The JVM also profiles the code and identifies other small method calls that can be inlined to reduce the number of method calls. These are <a id="_idIndexMarker069"/>known as hot methods. A decision is taken based on the number of times that the method is called and the size of the method. The size threshold used by JVM to decide inlining can be modified using the <strong class="source-inline">-XX:MaxFreqInlineSize</strong> flag (by default, it is 325 bytes).</li>
				<li><strong class="bold">Escape analysis</strong>: The JVM profiles the <a id="_idIndexMarker070"/>variables to analyze the scope of the usage of the variables. If the variables don't escape the local scope, it then performs local optimization. Lock Elision is <a id="_idIndexMarker071"/>one such optimization, where the JVM decided whether a synchronization lock is really required for the variable. Synchronization locks are very expensive to the processor. The JVM also decides to move the object from the heap to the stack. This has a positive impact on memory usage and garbage collection, as the objects are destroyed once the method is executed.</li>
				<li><strong class="bold">DeOptimization</strong>: DeOptimization is another <a id="_idIndexMarker072"/>critical optimization technique. The JVM profiles the code after optimization and may <a id="_idIndexMarker073"/>decide to deoptimize the code. Deoptimizations will have a momentary impact on performance. The JIT compiler decides to deoptimize in two cases:<p>a. <strong class="bold">Not Entrant Code</strong>: This is very <a id="_idIndexMarker074"/>prominent in inherited classes or interface implementations. JIT may have optimized, assuming a <a id="_idIndexMarker075"/>particular class in the hierarchy, but over time when it learns otherwise, it will deoptimize and profile for further optimization of more specific class implementations.</p><p>b. <strong class="bold">Zombie Code</strong>: During Not Entrant code <a id="_idIndexMarker076"/>analysis, some of the objects <a id="_idIndexMarker077"/>get garbage collected, leading into code that may never be called. This code is marked as zombie code. This code is removed from the code cache.</p></li>
			</ul>
			<p>Apart from this, the JIT compiler <a id="_idIndexMarker078"/>performs other optimizations, such as <a id="_idIndexMarker079"/>control flow optimization, which includes rearranging code paths to improve efficiency and native code generation to the target machine code for faster execution.</p>
			<p>JIT compiler optimizations are performed over a period of time, and they are good for long-running processes. We will be going into a detailed explanation on JIT compilation in <a href="B16878_02_Final_SK_ePub.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a><em class="italic">, JIT, Hotspot, and GraalVM</em>.</p>
			<h4>Java ahead-of-time compilation</h4>
			<p>The ahead-of-time compilation option <a id="_idIndexMarker080"/>was introduced with Java 9 with <strong class="source-inline">jaotc</strong>, where a Java application code can be directly compiled to <a id="_idIndexMarker081"/>generate final machine code. The code is compiled to a target architecture, so it is not portable.</p>
			<p>Java supports running both Java bytecode and AOT compiled code together in an x86 architecture. The following diagram illustrates how it works. This is the most optimum code that Java can generate:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/B16878_Figure_1.8.jpg" alt="Figure 1.8 – The detailed workings of JVM JIT time compilers along with the ahead-of-time compiler&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – The detailed workings of JVM JIT time compilers along with the ahead-of-time compiler</p>
			<p>The bytecode will go <a id="_idIndexMarker082"/>through the approach that was explained previously (C1, C2). <strong class="source-inline">jaotc</strong> compiles the most used java code (like libraries) into machine code, ahead of time, and this is directly loaded into the code cache. This will reduce the load on JVM. The Java byte code goes through the usual interpreter, and uses the code from the code cache, if available. This reduces a lot of load on JVM to compile the code at runtime. Typically, the most frequently used libraries can be AOT compiled for faster responses.</p>
			<h3>Garbage collector</h3>
			<p>One of the sophistication of Java is its in-built memory management. In languages such as C/C++, the programmer is <a id="_idIndexMarker083"/>expected to allocate and de-allocate the memory. In Java, JVM takes care of cleaning up the unreferenced <a id="_idIndexMarker084"/>objects and reclaims the memory. The garbage collector is a daemon thread that performs the cleanup either automatically or can also be invoked by the programmer (<strong class="source-inline">System.gc()</strong> and <strong class="source-inline">Runtime.getRuntime().gc()</strong>).</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor024"/>Native subsystem</h2>
			<p>Java allows <a id="_idIndexMarker085"/>programmers to access <a id="_idIndexMarker086"/>native libraries. Native libraries are typically those libraries that are built (using languages such as C/C++) and used for a specific <a id="_idIndexMarker087"/>target architecture. <strong class="bold">Java Native Interface</strong> (<strong class="bold">JNI</strong>) provides an abstraction layer and interface <a id="_idIndexMarker088"/>specification for <a id="_idIndexMarker089"/>implementing the bridge to access the <a id="_idIndexMarker090"/>native libraries. Each JVM implements JNI for the specific target system. Programmers can also use JNI to call the native methods. The following diagram illustrates the components of the native subsystem:</p>
			<p class="figure-caption"> </p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B16878_Figure_1.9.jpg" alt="Figure 1.9 – Native subsystem architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Native subsystem architecture</p>
			<p>The native subsystem <a id="_idIndexMarker091"/>provides the <a id="_idIndexMarker092"/>implementation to <a id="_idIndexMarker093"/>access and manage the <a id="_idIndexMarker094"/>native libraries.</p>
			<p>JVM has evolved and has <a id="_idIndexMarker095"/>one of the <a id="_idIndexMarker096"/>most sophisticated implementations of a language VM runtime.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor025"/>Summary</h1>
			<p>In this chapter, we started by learning what GraalVM is, followed by understanding how JVM works and its architecture, along with its various subsystems and components. Later on, we also learned how JVM combines the best of interpreters and the compiler approach to run Java code on various target architectures, along with how a code is compiled just-in-time with C1 and C2 compilers. Lastly, we learned about various types of code optimizations that the JVM performs.</p>
			<p>This chapter provided a good understanding of the architecture of JVM, which will help us understand how the GraalVM architecture works and how it is built on top of JVM.</p>
			<p>The next chapter will cover the details of how JIT compilers work and help you understand how Graal JIT builds on top of JVM JIT.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor026"/>Questions</h1>
			<ol>
				<li value="1">Why is Java code interpreted to bytecode and later compiled at runtime?</li>
				<li>How does JVM load the appropriate class files and link them?</li>
				<li>What are the various types of memory areas in JVM?</li>
				<li>What is the difference between the C1 compiler and the C2 compiler?</li>
				<li>What is a code cache in JVM?</li>
				<li>What are the various types of code optimizations that are performed just in time?</li>
			</ol>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor027"/>Further reading</h1>
			<ul>
				<li><em class="italic">Introduction to JVM Languages</em>, by Vincent van der Leun, Packt Publishing (<a href="https://www.packtpub.com/product/introduction-to-jvm-languages/9781787127944">https://www.packtpub.com/product/introduction-to-jvm-languages/9781787127944</a>)</li>
				<li><em class="italic">Java Documentation and Specification</em>, by Oracle (<a href="https://docs.oracle.com/en/java/">https://docs.oracle.com/en/java/</a>)</li>
			</ul>
		</div>
	</body></html>