- en: '*Chapter 10*: Reactive Cloud-Native Applications'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have mainly talked about traditional cloud-native applications
    that adopt **imperative programming** with clearly defined input and output. Imperative
    programming is the oldest programming paradigm. Applications using this paradigm
    are built using a clearly defined sequence of instructions making it easier to
    understand. Its architecture requires that the connection services are predefined.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes, a cloud-native application does not know which services
    it should call. Its purpose might be just sending or receiving messages or events
    and staying responsive and reactive. Thus, imperative programming no longer applies
    to these kinds of applications. Under such circumstances, you will need to rely
    on **reactive programing** and use an event-driven architecture to achieve reactive,
    responsive, and message-driven applications. We will discuss reactive cloud-native
    applications in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: First, you will learn the difference between imperative and reactive applications.
    Then we will talk about how to create reactive cloud-native applications using
    **MicroProfile Reactive Messaging 2.0**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between imperative and reactive applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **MicroProfile Context Propagation** to improve asynchronous programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing reactive cloud-native applications using **MicroProfile Reactive
    Messaging**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To fully understand this chapter, you should have Java knowledge on multithreading,
    the `CompletableFuture` class, and `CompletionStage` interface from Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be able to understand what reactive cloud-native
    applications are, how you can create reactive cloud-native applications that avoid
    block I/O problems, and be able to utilize messaging libraries such as Apache
    Kafka.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between imperative and reactive applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing imperative applications, the application developers define how
    to perform a task. You may design a synchronous application to start with. However,
    to deal with heavy loads and improve performance, you might think about switching
    from synchronous programming to asynchronous programming to speed up by performing
    multiple tasks in parallel. When using synchronous programming, on hitting block
    I/O, a thread has to wait, and no other tasks can be performed on that thread.
    However, in the case of asynchronous programming, multiple threads can be dispatched
    to perform other tasks if one thread is blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous programming dispatches multiple threads but it does not fix the
    blocking I/O issues. If there are blockages, eventually the application will consume
    all threads. Consequently, the application will run out of resources. One of the
    characteristics of imperative programming is that one application needs to know
    which services to interact with. Under some circumstances, it might not know nor
    care about the downstream services. Therefore, imperative programming is not applicable
    in this kind of situation. Here, reactive programming comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is a paradigm concerned with data streams and the propagation
    of changes. This paradigm is used to build a cloud-native application that is
    message-driven, resilient, and responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'A reactive application adopts the design principle from the **Reactive Manifesto**.
    The Reactive Manifesto ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))
    outlines the following four characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Responsive**: The application responds in a timely manner under all conditions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Elastic**: The system stays responsive under various amounts of load, and
    can scale up or down based on demand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilient**: The system is resilient in all situations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message Driven**: The system relies on asynchronous messaging as a communication
    channel among the components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive applications use asynchronous programming to achieve temporal decoupling.
    As we mentioned previously, asynchronous programming involves dispatching more
    threads. Each thread normally requires some `java.util.concurrent.ForkJoinPool`
    class for creating new threads, no context will be associated with the new thread
    that is dispatched. Therefore, to continue an unfinished task from one thread
    on a different new thread, you will need to push some context from the previous
    thread to the new threads for continued task execution. MicroProfile Context Propagation
    can be used to achieve this, which we will discuss next.
  prefs: []
  type: TYPE_NORMAL
- en: Using MicroProfile Context Propagation to manage context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MicroProfile Context Propagation ([https://download.eclipse.org/microprofile/microprofile-context-propagation-1.2/](https://download.eclipse.org/microprofile/microprofile-context-propagation-1.2/))
    defines a mechanism for propagating context from the current thread to a new thread.
    The types of context include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`java:comp`, `java:module`, and `java:app`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SessionScoped` and `ConversationScoped`, is still active in the new unit of
    work, such as a new `CompeletionStage`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: This includes the credentials that are associated with the current
    thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transaction**: This is the active transaction scope that is associated with
    the current thread. This context is not normally expected to be propagated, but
    cleared instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from the aforementioned context, an application can introduce custom context
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To propagate the aforementioned context, this specification introduces two
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ManagedExecutor`: This interface provides an asynchronous execution mechanism
    for defining thread context propagation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ThreadContext`: This interface enables finer control over the capture and
    propagation of thread context. You can associate this interface with a particular
    function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following subsections, we will briefly discuss how to use the two aforementioned
    interfaces to propagate the context that was associated with the current thread
    across various types of units of work such as `CompletionStage`, `CompletableFuture`,
    `Function`, and `Runnable`.
  prefs: []
  type: TYPE_NORMAL
- en: Using ManagedExecutor to propagate context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ManagedExecutor` differs from other known executors, such as `ForkJoinPool`,
    which do not have the facilities to propagate contexts. To use `ManagedExecutor`
    to propagate contexts, you will need to create an instance of `ManagedExecutor`,
    which can be achieved via the builder pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned code snippet is used to create an executor object of `ManagedExecutor`
    that cleared `Transaction` context and propagated all the other remaining contexts.
    This executor supports a maximum of `10` concurrent executions. You can then invoke
    some method of the executor to create an object of `CompletableFuture` for asynchronous
    programming as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates using the `executor` object to create
    an incomplete `CompletableFuture` `stage1`, which then executes `function1`. After
    `function1` completes, `function2` will then be executed. Finally, the future
    `stage1` will be completed with the given `supplier` function.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from `ManagedExecutor`, another way to propagate context is to use the
    `ThreadContext` interface. Let's discuss it in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using ThreadContext to propagate context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ThreadContext` offers a fine-grained control for capturing and restoring context.
    To use `ThreadContext`, you need to create an instance of `ThreadContext`, which
    can be constructed via the builder pattern as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The aforementioned code snippet creates an instance of `ThreadContext` that
    propagates the application and security context from the current thread and clears
    other contexts. Afterward, you can create a `CompletionStage` instance by calling
    the `threadContext.withContextCapture()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the aforementioned code snippet, both the `function1` and `aConsumer` functions
    will inherit the application and security context from the current thread.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can create a contextual function from a `threadContext`
    object and then provide this contextual function to `CompletableFuture`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code snippet, when `aFunction` is executed, the thread that
    runs this `aFunction` will inherit the application and security context from its
    parent thread, which means the thread will be able to perform similar functions
    as the thread that creates the `aFunction` object, while the `aConsumer` function
    will not inherit the application and security context from its parent thread.
    In order to use Context Propagation, you need to make the APIs available to your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Making the MicroProfile Context Propagation API available
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MicroProfile Context Propagation API JARs can be made available for Maven and
    Gradle projects. If you create a Maven project, you can directly add the following
    to your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternative, if you create a Gradle project, you need to add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have briefly discussed how to capture and restore contexts as part of asynchronous
    programming. As mentioned previously, asynchronous programming does not solve
    the blocking I/O issue but works around it by dispatching new threads if a thread
    is blocked. To solve the blocking I/O issue, you will need to consider building
    a reactive application. In the next section, we discuss using MicroProfile Reactive
    Messaging to help you build a reactive application.
  prefs: []
  type: TYPE_NORMAL
- en: Using MicroProfile Reactive Messaging to build a reactive application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`@Outgoing` annotation for publishing messages and `@Incoming` for consuming
    messages. The following figure illustrates how messages travel from the publisher
    (**Method A**) to the consumer (**Method B**). The message can be sent to a messaging
    store, such as Apache Kafka, MQ, and so on, and will then be delivered to a consumer
    such as **Method B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Messaging flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Messaging flow
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reactive Messaging, CDI beans are used to produce, process, and consume
    messages. These messages can be sent and received via remote brokers or various
    message transport layers such as Apache Kafka, MQ, and so on. Let''s discuss a
    few key elements of MicroProfile Reactive Messaging: messages, message acknowledgment,
    channels, message consumption, message production, message processing, and `Emitter`.'
  prefs: []
  type: TYPE_NORMAL
- en: Message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **message** is a piece of information wrapped in an envelope. Additionally,
    this piece of information can include an acknowledgment logic, which can be either
    positive or negative. The following are a few ways to produce a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message.of(P p)`: This method wraps the given payload `p` without any acknowledgment
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message.of(P p, Supplier<CompletionStage<Void>> ack)`: This method wraps the
    given payload `p` and provides the `ack` acknowledgment logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message.of(P p, Supplier<CompletionStage<Void>> ack, Function<Throwable, CompletionSTage<<Void>>
    nack)`: This method wraps the given payload `p`, provides the `ack` acknowledgment
    logic and the `nack` negative acknowledgment logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Alternatively, if you have a `Message` object, you can create a new `Message`
    object from it by getting its payload and then optionally supplying a new positive
    or negative acknowledgment, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The aforementioned code snippet creates `newMessage` from `aMessage` and provides
    new payload, positive acknowledgment, and negative acknowledgment logic.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering how to perform message acknowledgment and negative acknowledgment.
    We will discuss them in more detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Message acknowledgment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All messages must be acknowledged either positively or negatively, and can be
    acknowledged either explicitly or implicitly using the MicroProfile Reactive Messaging
    implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different types of acknowledgment: **positive acknowledgment**
    and **negative acknowledgment**. Positive acknowledgment means messages were processed
    successfully whereas negative acknowledgment means messages were unsuccessfully
    processed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Acknowledgment can be explicitly specified by the `@Acknowlegment` annotation.
    This annotation is used in conjunction with the `@Incoming` annotation. You can
    specify one of the following three acknowledgment policies:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Message#ack()` to acknowledge the message being received.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Acknowledgment(PRE_PROCESSING)**: A Reactive Messaging implementation that
    acknowledges the message before the annotated method is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**@Acknowledgment(POST_PROCESSING)**: A Reactive Messaging implementation that
    acknowledges the message once the method completes if the method does not emit
    data or the emitted data is acknowledged.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of a manual acknowledgment. The `consume()` method
    acknowledges the message consumption manually via calling the `msg.ack()` method
    on the `msg` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If the `@Acknowledgment` annotation is absent, what acknowledgment policy do
    you think should then be used? The answer to this is, it depends on the method
    signature where the `@Incoming` annotation is applied. The default acknowledgment
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If the method parameter or return type contains the type of `message`, the default
    acknowledgment is `MANUAL`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, if the method is only annotated with `@Incoming`, the default acknowledgment
    is `POST_PROCESSING`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if the method is annotated with both `@Incoming` and `@Outgoing`, the
    default acknowledgment is `PRE_PROCESSING`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have covered the necessary concepts of messages and their acknowledgment
    policies. You might be wondering where the message will be sent to or consumed
    from, meaning its destination or source respectively. These are called channels,
    which we will discuss in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Channel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A **channel** is a string representing the source or destination of messages.
    MicroProfile Reactive Messaging has two types of channels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Internal channels**: These channels are local to the application and allow
    for multi-step processing between the message source and message destination.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**External channels**: These channels connect to remote brokers or various
    message transport layers such as Apache Kafka, an AMQP broker, or other messaging
    technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Messages flow from an upstream channel and then to a downstream channel till
    they reach the consumer to have the messages consumed. Next, we discuss how these
    messages are consumed.
  prefs: []
  type: TYPE_NORMAL
- en: Message consumption using @Incoming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A message can be consumed by a method with the `@Incoming` annotation on a
    CDI bean. The following example consumes messages from the `channel-a` channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This method is called whenever a message is sent to the `channel-a` channel.
    This method acknowledges the received messages. The supported method signatures
    for consuming data are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Subscriber<Message<I>> consume(); Subscriber<I> consume();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SubscriberBuilder<Message<I>, Void> consume(); SubscriberBuilder<I, Void>
    consume();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`void consum(I payload);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<Void> consume(Message<I> msg); CompletionStage<?> consume(I
    payload);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceeding list, `I` is the incoming payload type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to receive messages is to inject either `org.reactivestreams.Publisher`
    or `org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder` and
    use the `@Channel` annotation, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet means a `publisher` instance will be connected to
    the `channel-d` channel. Then a consumer can directly receive messages from the
    publisher.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the messaging flows and message consumption. Next, we look
    at how a message is generated.
  prefs: []
  type: TYPE_NORMAL
- en: Message production using @Outgoing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A method on a CDI bean with the `@Outgoing` annotation is a message producer.
    The following code snippet demonstrates message production:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the aforementioned code snippet, the `publish()` method is called for every
    consumer request and it publishes the `123` message to the `channel-b` channel.
    Only one publisher can use `@Outgoing` with a specified channel name per application,
    which means only one publisher can publish messages to a particular channel. Otherwise,
    an error will occur during application deployment. After messages are published
    to a channel, consumers can consume messages from the specified channel. The supported
    method signatures for producing data are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Publisher<Message<O>> produce(); Publisher <O> produce();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<Message<O>> produce (); Publisher Builder<O> produce();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message<O> produce(); O produce();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<Message<O>> produce(); CompletionStage<O> produce();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceeding list, `O` is the outgoing payload class type.
  prefs: []
  type: TYPE_NORMAL
- en: A method can act as a message consumer and a message producer. This kind of
    method is called a **message processor**.
  prefs: []
  type: TYPE_NORMAL
- en: Message processing using both @Incoming and @Outgoing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A message processor is a message producer as well as a consumer, which means
    it has both `@Incoming` and `@Outgoing` annotations. Let''s look at this method
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `process()` method receives messages, which are integers, from the `channel-a`
    channel and then adds `100`. Afterward, it publishes the new integer to the `channel-b`
    channel. The supported method signatures for processing data are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Processor<Message<I>, Message<O>> process(); Processor<I, O> process();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ProcessorBuilder<Message<I>, Message<O>> process(); ProcessorBuilder<I, O>
    process();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<Message<O>> process(Message<I> msg); PublisherBuilder<O>
    process(I payload);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PublisherBuilder<Message<O>> process(PublisherBuilder<Message<I>> publisherBuilder);
    PublisherBuilder<O> process(PublisherBuilder<I> publisherBuilder);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Publisher<Message<O>> method(Publisher<Message<I>> publisher); Publisher<O>
    method(Publisher<I> publisher);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Message<O> process(Message<I> msg); O process(I payload);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompletionStage<Message<O>> process(Message<I> msg); CompletionStage<O> process(I
    payload);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceeding list, `I` is the incoming payload class type and `O` is the
    outgoing payload class type.
  prefs: []
  type: TYPE_NORMAL
- en: So far, message consumption and production are methods on CDI beans. These CDI
    beans can be `Dependent` or `ApplicationScoped`. We have already covered CDI in
    [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068)*, Developing Cloud-Native
    Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered message publication and message consumption via methods on CDI
    beans, which will be automatically triggered by the Reactive Messaging implementation
    when your application is up and running. You might be wondering what to do if
    you want to publish some messages whenever an endpoint is triggered. We will discuss
    how to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Emitter to publish messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to publish messages from a JAX-RS resource, you can inject an `Emitter`
    object and then call the `send()` method. Let''s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the aforementioned code snippet, first you can inject an `Emitter` with
    the target channel. Then, you can send messages by calling the `emitter.send()`
    method. This example directly sends a message payload. You can send a message
    by wrapping up the payload, as detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Often, the speed of message publication may not be the same as that of message
    consumption. `@OnOverflow` annotation to handle back pressure when using `Emitter`
    to publish messages. Here is an example demonstrating how to use a buffering strategy
    to handle back pressure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code snippet, an `Emitter` object `emitter` was connected
    to `channel-d` with the back pressure strategy of using a buffer with the capacity
    of `100` elements. The `emitter` object sent two messages and completed them.
    The `@OnOverflow` annotation supports the following configuration, as shown in
    the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1 – Back pressure strategies
  prefs: []
  type: TYPE_NORMAL
- en: We have learned how message production and consumption use the `@Outgoing` and
    `@Incoming` annotations. MicroProfile Reactive Messaging connects outgoing and
    incoming channels to external technologies such as Apache Kafka, Web Socket, AMQP,
    JMS, and MQTT. The connection is achieved via a reactive messaging connector.
    We are going to discuss the connector in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using a connector to bridge to an external messaging technology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A connector can act as a publisher, consumer, or processor. It is a CDI bean,
    which implements the two MicroProfile Reactive Messaging interfaces `IncomingConnectorFactory`
    and `OutgoingConnectorFactory` to receive messages and dispatch messages respectively.
    Reactive Messaging implementations provide out-of-the-box connectors for supported
    message technologies, such as Kafka, MQTT, MQ, and so on. However, you can create
    a connector yourself if the connector you need was not provided by the implementor.
    Here is an example of a connector that connects to Apache Kafka:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a connector is defined, further configurations shown next are required
    to match the channels from your cloud-native application to the external messaging
    technologies bridged by the connector. In the following configurations, the `channel-name`
    must match the value in the `@Incoming` or `@Outgoing` annotations while `attribute`
    can be any kind of string:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mp.messaging.incoming.[channel-name].[attribute]`: The property is used to
    map the channel with the annotation of `@Incoming` to the external destination
    provided by the corresponding messaging technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mp.messaging.outgoing.[channel-name].[attribute]`: This property is to map
    the channel with the annotation of `@Outgoing` to the external destination provided
    by the corresponding messaging technology.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mp.messaging.connector.[connector-name].[attribute]`: This property is to
    specify the connector details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If your cloud-native application connects to Apache Kafka, you might supply
    the following configuration for the following consumer method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following configuration, the `mp.messaging.incoming.order.connector`
    property specifies the connector name as `liberty-kafka` and then specifies further
    configuration for that connector with the `mp.messaging.connector.liberty-kafkabootstrap.servers`
    property. Then it specifies the channel `order` by mapping the `topic-order` Kafka
    topic via the `mp.messaging.incoming.order.topic` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We have covered MicroProfile Reactive Messaging. Let's put it all together.
    If you need to create a consumer that consumes messages from an event streaming
    system such as Apache Kafka, you just need to create a CDI bean and write a method
    with the `@Incoming` annotation to connect a particular channel. Similarly, if
    you need to produce messages, you will need to create a CDI bean and write a method
    with the `@Outging` annotation to connect with a producer channel. Finally, you
    configure the channel as shown in the preceding configuration to state the channel
    is connected to the Apache Kafka connector. Open Liberty provides the `liberty-kafka`
    Kafka connector. This Open Liberty guide ([https://openliberty.io/guides/microprofile-reactive-messaging.html](https://openliberty.io/guides/microprofile-reactive-messaging.html))
    demonstrates how to create Java microservices.
  prefs: []
  type: TYPE_NORMAL
- en: To use the APIs from MicroProfile Reactive Messaging, you need to specify the
    Maven or Gradle dependencies as covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Making the MicroProfile Reactive Messaging API available
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MicroProfile Reactive Messaging API JARs can be made available for Maven and
    Gradle projects. If you create a Maven project, you can directly add the following
    to your `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternative, if you create a Gradle project, you need to add the following
    dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You have now learned how to create a reactive cloud-native application for when
    you need to interact with messaging technologies and require a message-driven
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned the differences between imperative and reactive
    applications. We discussed briefly how to use MicroProfile Context Propagation
    to propagate contexts for asynchronous programming and then covered MicroProfile
    Reactive Messaging concepts to discuss how to use Reactive Messaging to create
    a reactive cloud-native application. Through this chapter, you will now be able
    to connect the built application with your chosen messaging technologies such
    as Apache Kafka. You also now understand that whenever you need to create a message-driven
    application, you should consider using MicroProfile Reactive Messaging.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover MicroProfile GraphQL to learn how to use
    GraphQL in your cloud-native applications to improve performance if you need to
    frequently execute queries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1 – Back pressure strategies'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_01.png)'
  prefs: []
  type: TYPE_NORMAL
