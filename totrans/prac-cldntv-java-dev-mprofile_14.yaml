- en: '*Chapter 10*: Reactive Cloud-Native Applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：响应式云原生应用程序'
- en: Up until now, we have mainly talked about traditional cloud-native applications
    that adopt **imperative programming** with clearly defined input and output. Imperative
    programming is the oldest programming paradigm. Applications using this paradigm
    are built using a clearly defined sequence of instructions making it easier to
    understand. Its architecture requires that the connection services are predefined.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了采用具有明确定义的输入和输出的**命令式编程**的传统云原生应用程序。命令式编程是最古老的编程范式。使用这种范式的应用程序是通过一个明确定义的指令序列构建的，这使得它更容易理解。其架构要求连接服务是预定义的。
- en: However, sometimes, a cloud-native application does not know which services
    it should call. Its purpose might be just sending or receiving messages or events
    and staying responsive and reactive. Thus, imperative programming no longer applies
    to these kinds of applications. Under such circumstances, you will need to rely
    on **reactive programing** and use an event-driven architecture to achieve reactive,
    responsive, and message-driven applications. We will discuss reactive cloud-native
    applications in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时，云原生应用程序不知道它应该调用哪些服务。它的目的可能只是发送或接收消息或事件，保持响应性和反应性。因此，命令式编程不再适用于这些类型的应用程序。在这种情况下，你需要依赖**响应式编程**并使用事件驱动架构来实现响应式、响应性和消息驱动的应用程序。我们将在本章中讨论响应式云原生应用程序。
- en: First, you will learn the difference between imperative and reactive applications.
    Then we will talk about how to create reactive cloud-native applications using
    **MicroProfile Reactive Messaging 2.0**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你将学习命令式和响应式应用程序之间的区别。然后我们将讨论如何使用**MicroProfile Reactive Messaging 2.0**创建响应式云原生应用程序。
- en: 'We will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将涵盖以下主题：
- en: Differentiating between imperative and reactive applications
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区分命令式和响应式应用程序
- en: Using **MicroProfile Context Propagation** to improve asynchronous programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**MicroProfile Context Propagation**来改进异步编程
- en: Developing reactive cloud-native applications using **MicroProfile Reactive
    Messaging**
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**MicroProfile Reactive Messaging**开发响应式云原生应用程序
- en: To fully understand this chapter, you should have Java knowledge on multithreading,
    the `CompletableFuture` class, and `CompletionStage` interface from Java 8.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全理解本章，你应该具备Java多线程、`CompletableFuture`类和Java 8的`CompletionStage`接口的知识。
- en: By the end of this chapter, you should be able to understand what reactive cloud-native
    applications are, how you can create reactive cloud-native applications that avoid
    block I/O problems, and be able to utilize messaging libraries such as Apache
    Kafka.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够理解什么是响应式云原生应用程序，如何创建避免阻塞I/O问题的响应式云原生应用程序，以及如何利用像Apache Kafka这样的消息库。
- en: Differentiating between imperative and reactive applications
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 区分命令式和响应式应用程序
- en: When developing imperative applications, the application developers define how
    to perform a task. You may design a synchronous application to start with. However,
    to deal with heavy loads and improve performance, you might think about switching
    from synchronous programming to asynchronous programming to speed up by performing
    multiple tasks in parallel. When using synchronous programming, on hitting block
    I/O, a thread has to wait, and no other tasks can be performed on that thread.
    However, in the case of asynchronous programming, multiple threads can be dispatched
    to perform other tasks if one thread is blocked.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发命令式应用程序时，应用程序开发者定义如何执行任务。你可能一开始设计一个同步应用程序。然而，为了处理重负载和提高性能，你可能会考虑从同步编程切换到异步编程，通过并行执行多个任务来加速。在使用同步编程时，一旦遇到阻塞I/O，线程必须等待，并且在该线程上无法执行其他任务。然而，在异步编程的情况下，如果有一个线程被阻塞，可以调度多个线程来执行其他任务。
- en: Asynchronous programming dispatches multiple threads but it does not fix the
    blocking I/O issues. If there are blockages, eventually the application will consume
    all threads. Consequently, the application will run out of resources. One of the
    characteristics of imperative programming is that one application needs to know
    which services to interact with. Under some circumstances, it might not know nor
    care about the downstream services. Therefore, imperative programming is not applicable
    in this kind of situation. Here, reactive programming comes to the rescue.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程可以调度多个线程，但它并不能解决阻塞I/O问题。如果有阻塞，最终应用程序将消耗所有线程。因此，应用程序将耗尽资源。命令式编程的一个特点是，一个应用程序需要知道要与之交互的服务。在某些情况下，它可能不知道也不关心下游服务。因此，命令式编程不适用于这种情况。在这里，反应式编程就派上用场了。
- en: Reactive programming is a paradigm concerned with data streams and the propagation
    of changes. This paradigm is used to build a cloud-native application that is
    message-driven, resilient, and responsive.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式编程是一种关注数据流和变化传播的范式。这种范式用于构建一个消息驱动、弹性且响应式的云原生应用程序。
- en: 'A reactive application adopts the design principle from the **Reactive Manifesto**.
    The Reactive Manifesto ([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))
    outlines the following four characteristics:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式应用程序采用了**反应式宣言**的设计原则。反应式宣言([https://www.reactivemanifesto.org/](https://www.reactivemanifesto.org/))概述了以下四个特性：
- en: '**Responsive**: The application responds in a timely manner under all conditions.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**响应性**：应用程序在所有条件下都能及时响应。'
- en: '**Elastic**: The system stays responsive under various amounts of load, and
    can scale up or down based on demand.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统在各种负载下保持响应性，可以根据需求进行扩展或缩减。'
- en: '**Resilient**: The system is resilient in all situations.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性**：系统在所有情况下都具有弹性。'
- en: '**Message Driven**: The system relies on asynchronous messaging as a communication
    channel among the components.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息驱动**：该系统依赖于异步消息作为组件之间的通信渠道。'
- en: Reactive applications use asynchronous programming to achieve temporal decoupling.
    As we mentioned previously, asynchronous programming involves dispatching more
    threads. Each thread normally requires some `java.util.concurrent.ForkJoinPool`
    class for creating new threads, no context will be associated with the new thread
    that is dispatched. Therefore, to continue an unfinished task from one thread
    on a different new thread, you will need to push some context from the previous
    thread to the new threads for continued task execution. MicroProfile Context Propagation
    can be used to achieve this, which we will discuss next.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式应用程序使用异步编程来实现时间解耦。正如我们之前提到的，异步编程涉及调度更多线程。每个线程通常需要一个`java.util.concurrent.ForkJoinPool`类来创建新线程，新调度线程不会关联任何上下文。因此，为了在不同的新线程上继续一个未完成的任务，你需要从先前的线程将一些上下文推送到新线程以继续任务执行。MicroProfile上下文传播可以用来实现这一点，我们将在下一节中讨论。
- en: Using MicroProfile Context Propagation to manage context
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile上下文传播来管理上下文
- en: 'MicroProfile Context Propagation ([https://download.eclipse.org/microprofile/microprofile-context-propagation-1.2/](https://download.eclipse.org/microprofile/microprofile-context-propagation-1.2/))
    defines a mechanism for propagating context from the current thread to a new thread.
    The types of context include the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile上下文传播([https://download.eclipse.org/microprofile/microprofile-context-propagation-1.2/](https://download.eclipse.org/microprofile/microprofile-context-propagation-1.2/))定义了一种从当前线程传播上下文到新线程的机制。上下文类型包括以下几种：
- en: '`java:comp`, `java:module`, and `java:app`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`java:comp`、`java:module`和`java:app`。'
- en: '`SessionScoped` and `ConversationScoped`, is still active in the new unit of
    work, such as a new `CompeletionStage`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SessionScoped`和`ConversationScoped`，在新工作单元中（如新的`CompeletionStage`）仍然有效。'
- en: '**Security**: This includes the credentials that are associated with the current
    thread.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：这包括与当前线程关联的凭证。'
- en: '**Transaction**: This is the active transaction scope that is associated with
    the current thread. This context is not normally expected to be propagated, but
    cleared instead.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事务**：这是与当前线程关联的活跃事务作用域。通常不期望传播此上下文，而是清除它。'
- en: Apart from the aforementioned context, an application can introduce custom context
    if needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述上下文之外，如果需要，应用程序可以引入自定义上下文。
- en: 'To propagate the aforementioned context, this specification introduces two
    interfaces:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 为了传播上述上下文，本规范引入了两个接口：
- en: '`ManagedExecutor`: This interface provides an asynchronous execution mechanism
    for defining thread context propagation.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ManagedExecutor`：此接口提供了一种异步执行机制，用于定义线程上下文的传播。'
- en: '`ThreadContext`: This interface enables finer control over the capture and
    propagation of thread context. You can associate this interface with a particular
    function.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ThreadContext`：此接口允许更精细地控制线程上下文的捕获和传播。您可以将此接口与特定的函数关联。'
- en: In the following subsections, we will briefly discuss how to use the two aforementioned
    interfaces to propagate the context that was associated with the current thread
    across various types of units of work such as `CompletionStage`, `CompletableFuture`,
    `Function`, and `Runnable`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下小节中，我们将简要讨论如何使用上述两个接口将当前线程关联的上下文传播到各种工作单元，例如`CompletionStage`、`CompletableFuture`、`Function`和`Runnable`。
- en: Using ManagedExecutor to propagate context
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ManagedExecutor`传播上下文
- en: '`ManagedExecutor` differs from other known executors, such as `ForkJoinPool`,
    which do not have the facilities to propagate contexts. To use `ManagedExecutor`
    to propagate contexts, you will need to create an instance of `ManagedExecutor`,
    which can be achieved via the builder pattern:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`ManagedExecutor`与其他已知执行器（如`ForkJoinPool`）不同，后者没有传播上下文的设施。要使用`ManagedExecutor`传播上下文，您需要创建一个`ManagedExecutor`实例，这可以通过构建器模式实现：'
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The aforementioned code snippet is used to create an executor object of `ManagedExecutor`
    that cleared `Transaction` context and propagated all the other remaining contexts.
    This executor supports a maximum of `10` concurrent executions. You can then invoke
    some method of the executor to create an object of `CompletableFuture` for asynchronous
    programming as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段用于创建一个`ManagedExecutor`的执行器对象，该对象清除`Transaction`上下文并传播所有其他剩余的上下文。此执行器支持最多`10`个并发执行。然后，您可以调用执行器的一些方法来创建一个`CompletableFuture`对象，用于异步编程，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code snippet demonstrates using the `executor` object to create
    an incomplete `CompletableFuture` `stage1`, which then executes `function1`. After
    `function1` completes, `function2` will then be executed. Finally, the future
    `stage1` will be completed with the given `supplier` function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段演示了使用`executor`对象创建一个不完整的`CompletableFuture` `stage1`，然后执行`function1`。`function1`完成后，将执行`function2`。最后，将使用给定的`supplier`函数完成未来的`stage1`。
- en: Apart from `ManagedExecutor`, another way to propagate context is to use the
    `ThreadContext` interface. Let's discuss it in more detail in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ManagedExecutor`之外，另一种传播上下文的方式是使用`ThreadContext`接口。让我们在下一节中更详细地讨论它。
- en: Using ThreadContext to propagate context
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ThreadContext`传播上下文
- en: '`ThreadContext` offers a fine-grained control for capturing and restoring context.
    To use `ThreadContext`, you need to create an instance of `ThreadContext`, which
    can be constructed via the builder pattern as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThreadContext`提供了对捕获和恢复上下文的精细控制。要使用`ThreadContext`，您需要创建一个`ThreadContext`实例，该实例可以通过以下方式通过构建器模式创建：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The aforementioned code snippet creates an instance of `ThreadContext` that
    propagates the application and security context from the current thread and clears
    other contexts. Afterward, you can create a `CompletionStage` instance by calling
    the `threadContext.withContextCapture()` method:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段创建了一个`ThreadContext`实例，它从当前线程传播应用程序和安全性上下文，并清除其他上下文。之后，您可以通过调用`threadContext.withContextCapture()`方法创建一个`CompletionStage`实例：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the aforementioned code snippet, both the `function1` and `aConsumer` functions
    will inherit the application and security context from the current thread.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`function1`和`aConsumer`函数都将从当前线程继承应用程序和安全性上下文。
- en: 'Alternatively, you can create a contextual function from a `threadContext`
    object and then provide this contextual function to `CompletableFuture`, as shown
    here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以从一个`threadContext`对象创建一个上下文函数，然后将此上下文函数提供给`CompletableFuture`，如下所示：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code snippet, when `aFunction` is executed, the thread that
    runs this `aFunction` will inherit the application and security context from its
    parent thread, which means the thread will be able to perform similar functions
    as the thread that creates the `aFunction` object, while the `aConsumer` function
    will not inherit the application and security context from its parent thread.
    In order to use Context Propagation, you need to make the APIs available to your
    application.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，当`aFunction`执行时，运行此`aFunction`的线程将从其父线程继承应用程序和安全上下文，这意味着该线程将能够执行与创建`aFunction`对象的线程类似的功能，而`aConsumer`函数将不会从其父线程继承应用程序和安全上下文。为了使用上下文传播，你需要使API对你的应用程序可用。
- en: Making the MicroProfile Context Propagation API available
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使MicroProfile上下文传播API可用
- en: 'MicroProfile Context Propagation API JARs can be made available for Maven and
    Gradle projects. If you create a Maven project, you can directly add the following
    to your `pom.xml` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile上下文传播API JAR可以为Maven和Gradle项目提供。如果你创建了一个Maven项目，你可以直接将以下内容添加到你的`pom.xml`文件中：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Alternative, if you create a Gradle project, you need to add the following
    dependency:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你创建了一个Gradle项目，你需要添加以下依赖项：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have briefly discussed how to capture and restore contexts as part of asynchronous
    programming. As mentioned previously, asynchronous programming does not solve
    the blocking I/O issue but works around it by dispatching new threads if a thread
    is blocked. To solve the blocking I/O issue, you will need to consider building
    a reactive application. In the next section, we discuss using MicroProfile Reactive
    Messaging to help you build a reactive application.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了如何捕获和恢复上下文作为异步编程的一部分。如前所述，异步编程并不解决阻塞I/O问题，而是通过调度新线程来绕过这个问题。为了解决阻塞I/O问题，你需要考虑构建一个响应式应用程序。在下一节中，我们将讨论使用MicroProfile响应式消息传递来帮助你构建响应式应用程序。
- en: Using MicroProfile Reactive Messaging to build a reactive application
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MicroProfile响应式消息传递构建响应式应用程序
- en: '`@Outgoing` annotation for publishing messages and `@Incoming` for consuming
    messages. The following figure illustrates how messages travel from the publisher
    (**Method A**) to the consumer (**Method B**). The message can be sent to a messaging
    store, such as Apache Kafka, MQ, and so on, and will then be delivered to a consumer
    such as **Method B**:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Outgoing`注解用于发布消息，`@Incoming`用于消费消息。以下图示说明了消息如何从发布者（**方法A**）传输到消费者（**方法B**）。消息可以被发送到消息存储，例如Apache
    Kafka、MQ等，然后将被传递到消费者，如**方法B**：'
- en: '![Figure 10.1 – Messaging flow'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 消息流](Figure 10.1 – Messaging flow)'
- en: '](img/B17377_10_01.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图10.1 – 消息流](img/B17377_10_01.jpg)'
- en: Figure 10.1 – Messaging flow
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 – 消息流
- en: 'In Reactive Messaging, CDI beans are used to produce, process, and consume
    messages. These messages can be sent and received via remote brokers or various
    message transport layers such as Apache Kafka, MQ, and so on. Let''s discuss a
    few key elements of MicroProfile Reactive Messaging: messages, message acknowledgment,
    channels, message consumption, message production, message processing, and `Emitter`.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应式消息传递中，CDI豆用于产生、处理和消费消息。这些消息可以通过远程代理或Apache Kafka、MQ等各种消息传输层进行发送和接收。让我们讨论MicroProfile响应式消息传递的一些关键元素：消息、消息确认、通道、消息消费、消息生产、消息处理和`Emitter`。
- en: Message
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息
- en: 'A **message** is a piece of information wrapped in an envelope. Additionally,
    this piece of information can include an acknowledgment logic, which can be either
    positive or negative. The following are a few ways to produce a message:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息**是包裹在信封中的信息片段。此外，此信息片段可以包括确认逻辑，可以是正面的或负面的。以下是一些产生消息的方法：'
- en: '`Message.of(P p)`: This method wraps the given payload `p` without any acknowledgment
    logic.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message.of(P p)`: 此方法包装给定的有效负载`p`，不提供任何确认逻辑。'
- en: '`Message.of(P p, Supplier<CompletionStage<Void>> ack)`: This method wraps the
    given payload `p` and provides the `ack` acknowledgment logic.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message.of(P p, Supplier<CompletionStage<Void>> ack)`: 此方法包装给定的有效负载`p`并提供`ack`确认逻辑。'
- en: '`Message.of(P p, Supplier<CompletionStage<Void>> ack, Function<Throwable, CompletionSTage<<Void>>
    nack)`: This method wraps the given payload `p`, provides the `ack` acknowledgment
    logic and the `nack` negative acknowledgment logic.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message.of(P p, Supplier<CompletionStage<Void>> ack, Function<Throwable, CompletionSTage<Void>>>
    nack)`: 此方法包装给定的有效负载`p`，提供`ack`确认逻辑和`nack`否定确认逻辑。'
- en: 'Alternatively, if you have a `Message` object, you can create a new `Message`
    object from it by getting its payload and then optionally supplying a new positive
    or negative acknowledgment, as shown here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你有一个`Message`对象，你可以通过获取其有效载荷并可选地提供新的积极或消极确认来从它创建一个新的`Message`对象，如下所示：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The aforementioned code snippet creates `newMessage` from `aMessage` and provides
    new payload, positive acknowledgment, and negative acknowledgment logic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段从`aMessage`创建`newMessage`，并提供了新的有效载荷、积极确认和消极确认逻辑。
- en: You might be wondering how to perform message acknowledgment and negative acknowledgment.
    We will discuss them in more detail in the next section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何执行消息确认和消极确认。我们将在下一节中更详细地讨论它们。
- en: Message acknowledgment
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消息确认
- en: All messages must be acknowledged either positively or negatively, and can be
    acknowledged either explicitly or implicitly using the MicroProfile Reactive Messaging
    implementation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有消息都必须进行积极或消极的确认，可以使用MicroProfile Reactive Messaging实现显式或隐式地进行确认。
- en: 'There are two different types of acknowledgment: **positive acknowledgment**
    and **negative acknowledgment**. Positive acknowledgment means messages were processed
    successfully whereas negative acknowledgment means messages were unsuccessfully
    processed.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种不同的确认类型：**积极确认**和**消极确认**。积极确认表示消息已成功处理，而消极确认表示消息处理失败。
- en: 'Acknowledgment can be explicitly specified by the `@Acknowlegment` annotation.
    This annotation is used in conjunction with the `@Incoming` annotation. You can
    specify one of the following three acknowledgment policies:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过`@Acknowledgment`注解显式指定确认。此注解与`@Incoming`注解一起使用。你可以指定以下三种确认策略之一：
- en: '`Message#ack()` to acknowledge the message being received.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message#ack()`用于确认接收到的消息。'
- en: '**@Acknowledgment(PRE_PROCESSING)**: A Reactive Messaging implementation that
    acknowledges the message before the annotated method is executed.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Acknowledgment(PRE_PROCESSING)**：Reactive Messaging实现，在执行注解方法之前确认消息。'
- en: '**@Acknowledgment(POST_PROCESSING)**: A Reactive Messaging implementation that
    acknowledges the message once the method completes if the method does not emit
    data or the emitted data is acknowledged.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**@Acknowledgment(POST_PROCESSING)**：Reactive Messaging实现，在方法完成且方法不发出数据或发出的数据被确认后确认消息。'
- en: 'The following is an example of a manual acknowledgment. The `consume()` method
    acknowledges the message consumption manually via calling the `msg.ack()` method
    on the `msg` object:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个手动确认的示例。`consume()`方法通过在`msg`对象上调用`msg.ack()`方法手动确认消息消费：
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If the `@Acknowledgment` annotation is absent, what acknowledgment policy do
    you think should then be used? The answer to this is, it depends on the method
    signature where the `@Incoming` annotation is applied. The default acknowledgment
    is as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果缺少`@Acknowledgment`注解，你认为应该使用哪种确认策略？这个答案取决于应用`@Incoming`注解的方法签名。默认的确认策略如下：
- en: If the method parameter or return type contains the type of `message`, the default
    acknowledgment is `MANUAL`.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法参数或返回类型包含`message`类型，则默认确认策略为`MANUAL`。
- en: Otherwise, if the method is only annotated with `@Incoming`, the default acknowledgment
    is `POST_PROCESSING`.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果方法仅注解了`@Incoming`，则默认确认策略为`POST_PROCESSING`。
- en: Finally, if the method is annotated with both `@Incoming` and `@Outgoing`, the
    default acknowledgment is `PRE_PROCESSING`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果方法同时注解了`@Incoming`和`@Outgoing`，则默认确认策略为`PRE_PROCESSING`。
- en: Now that we have covered the necessary concepts of messages and their acknowledgment
    policies. You might be wondering where the message will be sent to or consumed
    from, meaning its destination or source respectively. These are called channels,
    which we will discuss in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了消息及其确认策略的必要概念。你可能想知道消息将被发送到何处或从何处消费，即其目的地或源。这些被称为通道，我们将在下一节中讨论。
- en: Channel
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通道
- en: 'A **channel** is a string representing the source or destination of messages.
    MicroProfile Reactive Messaging has two types of channels:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**通道**是一个表示消息源或目的地的字符串。MicroProfile Reactive Messaging有两种类型的通道：'
- en: '**Internal channels**: These channels are local to the application and allow
    for multi-step processing between the message source and message destination.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内部通道**：这些通道是应用本地的，允许在消息源和消息目的地之间进行多步处理。'
- en: '**External channels**: These channels connect to remote brokers or various
    message transport layers such as Apache Kafka, an AMQP broker, or other messaging
    technologies.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**外部通道**：这些通道连接到远程代理或各种消息传输层，如Apache Kafka、AMQP代理或其他消息传递技术。'
- en: Messages flow from an upstream channel and then to a downstream channel till
    they reach the consumer to have the messages consumed. Next, we discuss how these
    messages are consumed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 消息从上游通道流向下游通道，直到达到消费者进行消息消费。接下来，我们将讨论这些消息是如何被消费的。
- en: Message consumption using @Incoming
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`@Incoming`进行消息消费
- en: 'A message can be consumed by a method with the `@Incoming` annotation on a
    CDI bean. The following example consumes messages from the `channel-a` channel:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一个带有`@Incoming`注解的CDI bean上的方法可以消费消息。以下示例从`channel-a`通道消费消息：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This method is called whenever a message is sent to the `channel-a` channel.
    This method acknowledges the received messages. The supported method signatures
    for consuming data are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息发送到`channel-a`通道时，将调用此方法。此方法确认接收到的消息。支持的数据消费方法签名如下：
- en: '`Subscriber<Message<I>> consume(); Subscriber<I> consume();`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Subscriber<Message<I>> consume(); Subscriber<I> consume();`'
- en: '`SubscriberBuilder<Message<I>, Void> consume(); SubscriberBuilder<I, Void>
    consume();`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SubscriberBuilder<Message<I>, Void> consume(); SubscriberBuilder<I, Void>
    consume();`'
- en: '`void consum(I payload);`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void consum(I payload);`'
- en: '`CompletionStage<Void> consume(Message<I> msg); CompletionStage<?> consume(I
    payload);`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<Void> consume(Message<I> msg); CompletionStage<?> consume(I
    payload);`'
- en: In the preceeding list, `I` is the incoming payload type.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中，`I`是传入的有效负载类型。
- en: 'Another way to receive messages is to inject either `org.reactivestreams.Publisher`
    or `org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder` and
    use the `@Channel` annotation, as shown here:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接收消息的另一种方式是注入`org.reactivestreams.Publisher`或`org.eclipse.microprofile.reactive.streams.operators.PublisherBuilder`，并使用`@Channel`注解，如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The preceding code snippet means a `publisher` instance will be connected to
    the `channel-d` channel. Then a consumer can directly receive messages from the
    publisher.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段意味着一个`publisher`实例将被连接到`channel-d`通道。然后消费者可以直接从发布者接收消息。
- en: We have discussed the messaging flows and message consumption. Next, we look
    at how a message is generated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了消息流和消息消费。接下来，我们将看看消息是如何生成的。
- en: Message production using @Outgoing
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`@Outgoing`进行消息生产
- en: 'A method on a CDI bean with the `@Outgoing` annotation is a message producer.
    The following code snippet demonstrates message production:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`@Outgoing`注解的CDI bean上的方法是一个消息生产者。以下代码片段演示了消息生产：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the aforementioned code snippet, the `publish()` method is called for every
    consumer request and it publishes the `123` message to the `channel-b` channel.
    Only one publisher can use `@Outgoing` with a specified channel name per application,
    which means only one publisher can publish messages to a particular channel. Otherwise,
    an error will occur during application deployment. After messages are published
    to a channel, consumers can consume messages from the specified channel. The supported
    method signatures for producing data are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，对于每个消费者请求都会调用`publish()`方法，并将`123`消息发布到`channel-b`通道。每个应用程序中只能有一个发布者使用指定通道名的`@Outgoing`，这意味着只能有一个发布者可以向特定通道发布消息。否则，在应用程序部署期间将发生错误。消息发布到通道后，消费者可以从中消费消息。支持的数据生产方法签名如下：
- en: '`Publisher<Message<O>> produce(); Publisher <O> produce();`'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<O>> produce(); Publisher <O> produce();`'
- en: '`PublisherBuilder<Message<O>> produce (); Publisher Builder<O> produce();`'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<O>> produce (); Publisher Builder<O> produce();`'
- en: '`Message<O> produce(); O produce();`'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message<O> produce(); O produce();`'
- en: '`CompletionStage<Message<O>> produce(); CompletionStage<O> produce();`'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<Message<O>> produce(); CompletionStage<O> produce();`'
- en: In the preceeding list, `O` is the outgoing payload class type.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述列表中，`O`是传出有效负载类类型。
- en: A method can act as a message consumer and a message producer. This kind of
    method is called a **message processor**.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一个方法可以作为消息消费者和消息生产者。这种类型的方法被称为**消息处理器**。
- en: Message processing using both @Incoming and @Outgoing
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`@Incoming`和`@Outgoing`进行消息处理
- en: 'A message processor is a message producer as well as a consumer, which means
    it has both `@Incoming` and `@Outgoing` annotations. Let''s look at this method
    here:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 消息处理器既是消息生产者也是消费者，这意味着它具有`@Incoming`和`@Outgoing`注解。让我们看看这个方法：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `process()` method receives messages, which are integers, from the `channel-a`
    channel and then adds `100`. Afterward, it publishes the new integer to the `channel-b`
    channel. The supported method signatures for processing data are as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`process()`方法从`channel-a`通道接收整数消息，然后加上`100`。之后，它将新的整数发布到`channel-b`通道。处理数据支持的方法签名如下：'
- en: '`Processor<Message<I>, Message<O>> process(); Processor<I, O> process();`'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Processor<Message<I>, Message<O>> process(); Processor<I, O> process();`'
- en: '`ProcessorBuilder<Message<I>, Message<O>> process(); ProcessorBuilder<I, O>
    process();`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProcessorBuilder<Message<I>, Message<O>> process(); ProcessorBuilder<I, O>
    process();`'
- en: '`PublisherBuilder<Message<O>> process(Message<I> msg); PublisherBuilder<O>
    process(I payload);`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<O>> process(Message<I> msg); PublisherBuilder<O>
    process(I payload);`'
- en: '`PublisherBuilder<Message<O>> process(PublisherBuilder<Message<I>> publisherBuilder);
    PublisherBuilder<O> process(PublisherBuilder<I> publisherBuilder);`'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublisherBuilder<Message<O>> process(PublisherBuilder<Message<I>> publisherBuilder);
    PublisherBuilder<O> process(PublisherBuilder<I> publisherBuilder);`'
- en: '`Publisher<Message<O>> method(Publisher<Message<I>> publisher); Publisher<O>
    method(Publisher<I> publisher);`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Publisher<Message<O>> method(Publisher<Message<I>> publisher); Publisher<O>
    method(Publisher<I> publisher);`'
- en: '`Message<O> process(Message<I> msg); O process(I payload);`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Message<O> process(Message<I> msg); O process(I payload);`'
- en: '`CompletionStage<Message<O>> process(Message<I> msg); CompletionStage<O> process(I
    payload);`'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CompletionStage<Message<O>> process(Message<I> msg); CompletionStage<O> process(I
    payload);`'
- en: In the preceeding list, `I` is the incoming payload class type and `O` is the
    outgoing payload class type.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，`I`是传入负载类类型，`O`是传出负载类类型。
- en: So far, message consumption and production are methods on CDI beans. These CDI
    beans can be `Dependent` or `ApplicationScoped`. We have already covered CDI in
    [*Chapter 4*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068)*, Developing Cloud-Native
    Applications*.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，消息消费和生产是CDI豆上的方法。这些CDI豆可以是`Dependent`或`ApplicationScoped`。我们已经在[*第4章*](B17377_04_Final_SB_epub.xhtml#_idTextAnchor068)*，开发云原生应用*中介绍了CDI。
- en: We have covered message publication and message consumption via methods on CDI
    beans, which will be automatically triggered by the Reactive Messaging implementation
    when your application is up and running. You might be wondering what to do if
    you want to publish some messages whenever an endpoint is triggered. We will discuss
    how to do that in the next section.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了通过CDI豆上的方法进行消息发布和消息消费，当你的应用程序启动并运行时，这些方法将由Reactive Messaging实现自动触发。你可能想知道，如果你想在端点被触发时发布一些消息，应该怎么做。我们将在下一节讨论如何做到这一点。
- en: Using Emitter to publish messages
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Emitter发布消息
- en: 'In order to publish messages from a JAX-RS resource, you can inject an `Emitter`
    object and then call the `send()` method. Let''s look at the following example:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从JAX-RS资源发布消息，你可以注入一个`Emitter`对象，然后调用`send()`方法。让我们看看以下示例：
- en: '[PRE13]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the aforementioned code snippet, first you can inject an `Emitter` with
    the target channel. Then, you can send messages by calling the `emitter.send()`
    method. This example directly sends a message payload. You can send a message
    by wrapping up the payload, as detailed here:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，首先你可以注入一个带有目标通道的`Emitter`。然后，你可以通过调用`emitter.send()`方法发送消息。本例直接发送一个消息负载。你可以通过包装负载来发送消息，具体细节如下：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Often, the speed of message publication may not be the same as that of message
    consumption. `@OnOverflow` annotation to handle back pressure when using `Emitter`
    to publish messages. Here is an example demonstrating how to use a buffering strategy
    to handle back pressure:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，消息发布的速度可能不会与消息消费的速度相同。使用`Emitter`发布消息时，`@OnOverflow`注解用于处理反压。以下是一个示例，演示如何使用缓冲策略来处理反压：
- en: '[PRE15]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding code snippet, an `Emitter` object `emitter` was connected
    to `channel-d` with the back pressure strategy of using a buffer with the capacity
    of `100` elements. The `emitter` object sent two messages and completed them.
    The `@OnOverflow` annotation supports the following configuration, as shown in
    the following table:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，一个`Emitter`对象`emitter`使用容量为`100`个元素的缓冲区反压策略连接到`channel-d`。`emitter`对象发送了两个消息并完成了它们。`@OnOverflow`注解支持以下配置，如下表所示：
- en: Table 10.1 – Back pressure strategies
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 表10.1 – 反压策略
- en: We have learned how message production and consumption use the `@Outgoing` and
    `@Incoming` annotations. MicroProfile Reactive Messaging connects outgoing and
    incoming channels to external technologies such as Apache Kafka, Web Socket, AMQP,
    JMS, and MQTT. The connection is achieved via a reactive messaging connector.
    We are going to discuss the connector in detail in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用`@Outgoing`和`@Incoming`注解进行消息的生产和消费。MicroProfile Reactive Messaging通过反应式消息连接器将出站和入站通道连接到外部技术，如Apache
    Kafka、WebSocket、AMQP、JMS和MQTT。连接是通过反应式消息连接器实现的。我们将在下一节详细讨论连接器。
- en: Using a connector to bridge to an external messaging technology
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用连接器桥接到外部消息技术
- en: 'A connector can act as a publisher, consumer, or processor. It is a CDI bean,
    which implements the two MicroProfile Reactive Messaging interfaces `IncomingConnectorFactory`
    and `OutgoingConnectorFactory` to receive messages and dispatch messages respectively.
    Reactive Messaging implementations provide out-of-the-box connectors for supported
    message technologies, such as Kafka, MQTT, MQ, and so on. However, you can create
    a connector yourself if the connector you need was not provided by the implementor.
    Here is an example of a connector that connects to Apache Kafka:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 连接器可以作为发布者、消费者或处理器。它是一个CDI bean，实现了MicroProfile Reactive Messaging的两个接口`IncomingConnectorFactory`和`OutgoingConnectorFactory`，分别用于接收消息和分发消息。Reactive
    Messaging实现为支持的消息技术（如Kafka、MQTT、MQ等）提供开箱即用的连接器。但是，如果您需要的连接器未由实现者提供，您可以自己创建一个连接器。以下是一个连接到Apache
    Kafka的连接器示例：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once a connector is defined, further configurations shown next are required
    to match the channels from your cloud-native application to the external messaging
    technologies bridged by the connector. In the following configurations, the `channel-name`
    must match the value in the `@Incoming` or `@Outgoing` annotations while `attribute`
    can be any kind of string:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了连接器，接下来显示的进一步配置是必需的，以便将您的云原生应用程序中的通道与连接器桥接的外部消息技术相匹配。在以下配置中，`channel-name`必须与`@Incoming`或`@Outgoing`注解中的值相匹配，而`attribute`可以是任何类型的字符串：
- en: '`mp.messaging.incoming.[channel-name].[attribute]`: The property is used to
    map the channel with the annotation of `@Incoming` to the external destination
    provided by the corresponding messaging technology.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.messaging.incoming.[channel-name].[attribute]`: 该属性用于将带有`@Incoming`注解的通道映射到由相应消息技术提供的外部目标。'
- en: '`mp.messaging.outgoing.[channel-name].[attribute]`: This property is to map
    the channel with the annotation of `@Outgoing` to the external destination provided
    by the corresponding messaging technology.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.messaging.outgoing.[channel-name].[attribute]`: 这个属性用于将带有`@Outgoing`注解的通道映射到由相应消息技术提供的外部目标。'
- en: '`mp.messaging.connector.[connector-name].[attribute]`: This property is to
    specify the connector details.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mp.messaging.connector.[connector-name].[attribute]`: 这个属性用于指定连接器的详细信息。'
- en: 'If your cloud-native application connects to Apache Kafka, you might supply
    the following configuration for the following consumer method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的云原生应用程序连接到Apache Kafka，您可能需要为以下消费者方法提供以下配置：
- en: '[PRE17]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the following configuration, the `mp.messaging.incoming.order.connector`
    property specifies the connector name as `liberty-kafka` and then specifies further
    configuration for that connector with the `mp.messaging.connector.liberty-kafkabootstrap.servers`
    property. Then it specifies the channel `order` by mapping the `topic-order` Kafka
    topic via the `mp.messaging.incoming.order.topic` property:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下配置中，`mp.messaging.incoming.order.connector`属性指定了连接器名称为`liberty-kafka`，然后使用`mp.messaging.connector.liberty-kafkabootstrap.servers`属性进一步指定该连接器的配置。然后通过`mp.messaging.incoming.order.topic`属性将`topic-order`
    Kafka主题映射到通道`order`：
- en: '[PRE18]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We have covered MicroProfile Reactive Messaging. Let's put it all together.
    If you need to create a consumer that consumes messages from an event streaming
    system such as Apache Kafka, you just need to create a CDI bean and write a method
    with the `@Incoming` annotation to connect a particular channel. Similarly, if
    you need to produce messages, you will need to create a CDI bean and write a method
    with the `@Outging` annotation to connect with a producer channel. Finally, you
    configure the channel as shown in the preceding configuration to state the channel
    is connected to the Apache Kafka connector. Open Liberty provides the `liberty-kafka`
    Kafka connector. This Open Liberty guide ([https://openliberty.io/guides/microprofile-reactive-messaging.html](https://openliberty.io/guides/microprofile-reactive-messaging.html))
    demonstrates how to create Java microservices.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了 MicroProfile Reactive Messaging。现在让我们将其全部整合起来。如果您需要创建一个从事件流系统（如 Apache
    Kafka）消费消息的消费者，您只需创建一个 CDI 实例，并编写一个带有 `@Incoming` 注解的方法来连接特定的通道。同样，如果您需要发送消息，您将需要创建一个
    CDI 实例，并编写一个带有 `@Outging` 注解的方法来连接到生产者通道。最后，您配置通道，如前所述，以声明通道连接到 Apache Kafka 连接器。Open
    Liberty 提供了 `liberty-kafka` Kafka 连接器。本 Open Liberty 指南 ([https://openliberty.io/guides/microprofile-reactive-messaging.html](https://openliberty.io/guides/microprofile-reactive-messaging.html))
    展示了如何创建 Java 微服务。
- en: To use the APIs from MicroProfile Reactive Messaging, you need to specify the
    Maven or Gradle dependencies as covered next.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 MicroProfile Reactive Messaging 的 API，您需要指定如后所述的 Maven 或 Gradle 依赖项。
- en: Making the MicroProfile Reactive Messaging API available
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使 MicroProfile Reactive Messaging API 可用
- en: 'MicroProfile Reactive Messaging API JARs can be made available for Maven and
    Gradle projects. If you create a Maven project, you can directly add the following
    to your `pom.xml` file:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Reactive Messaging API JAR 可以用于 Maven 和 Gradle 项目。如果您创建了一个 Maven
    项目，您可以直接将以下内容添加到您的 `pom.xml` 文件中：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternative, if you create a Gradle project, you need to add the following
    dependency:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果您创建了一个 Gradle 项目，您需要添加以下依赖项：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You have now learned how to create a reactive cloud-native application for when
    you need to interact with messaging technologies and require a message-driven
    architecture.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在已经学会了如何在需要与消息传递技术交互并需要消息驱动架构时创建响应式云原生应用程序。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned the differences between imperative and reactive
    applications. We discussed briefly how to use MicroProfile Context Propagation
    to propagate contexts for asynchronous programming and then covered MicroProfile
    Reactive Messaging concepts to discuss how to use Reactive Messaging to create
    a reactive cloud-native application. Through this chapter, you will now be able
    to connect the built application with your chosen messaging technologies such
    as Apache Kafka. You also now understand that whenever you need to create a message-driven
    application, you should consider using MicroProfile Reactive Messaging.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了命令式和响应式应用程序之间的区别。我们简要讨论了如何使用 MicroProfile Context Propagation 来传播异步编程的上下文，然后介绍了
    MicroProfile Reactive Messaging 概念，讨论了如何使用 Reactive Messaging 来创建一个响应式云原生应用程序。通过本章，你现在将能够将构建的应用程序与您选择的如
    Apache Kafka 之类的消息传递技术连接起来。你现在也理解了，每当您需要创建一个消息驱动应用程序时，您应该考虑使用 MicroProfile Reactive
    Messaging。
- en: In the next chapter, we will cover MicroProfile GraphQL to learn how to use
    GraphQL in your cloud-native applications to improve performance if you need to
    frequently execute queries.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍 MicroProfile GraphQL，学习如何在您的云原生应用程序中使用 GraphQL 来提高性能，如果您需要频繁执行查询。
- en: '![Table 10.1 – Back pressure strategies'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 10.1 – 反压策略'
- en: '](img/Table_01.png)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Table_01.png]'
