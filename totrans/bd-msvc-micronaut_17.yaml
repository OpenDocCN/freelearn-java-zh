- en: '*Chapter 11*: Building Enterprise-Grade Microservices'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：构建企业级微服务'
- en: 'We have reached the last stage of learning about hands-on microservices with
    Micronaut. Our journey is now in its final stage; we gained a lot of knowledge
    of being hands-on in Micronaut in the previous chapters. Now, we must connect
    all the pieces to build our enterprise-grade microservices with Micronaut. As
    we already know from our previous chapters, the following are some of the benefits
    of using Micronaut:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了使用 Micronaut 学习动手微服务的最后阶段。我们的旅程现在已进入最终阶段；在前几章中，我们在 Micronaut 的动手实践方面获得了大量知识。现在，我们必须将所有这些知识串联起来，使用
    Micronaut 构建我们企业级的微服务。正如我们从前面的章节中已经了解到的，以下是一些使用 Micronaut 的好处：
- en: Modern JVM-based full-stack framework
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 JVM 的现代全栈框架
- en: Easily testable microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于测试的微服务
- en: Built for serverless applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为无服务器应用程序构建
- en: Reactive stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式堆栈
- en: Minimal memory footprint and startup time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小内存占用和启动时间
- en: Cloud-native framework
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生框架
- en: Multi-language support (Java, Groovy, Kotlin)
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多语言支持（Java、Groovy、Kotlin）
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Bringing it all together
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: Architecting enterprise microservices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构企业级微服务
- en: Understanding Micronaut's OpenAPI
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Micronaut 的 OpenAPI
- en: Implementing Micronaut's microservices
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实施 Micronaut 的微服务
- en: By the end of this chapter, you will be well-versed in building, architecting,
    and scaling enterprise-grade microservices.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将熟练掌握构建、设计和扩展企业级微服务。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the commands and technical instructions in this chapter can be run on Windows
    10 and Mac OS X. The code examples in this chapter are available in this book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有命令和技术说明都可以在 Windows 10 和 Mac OS X 上运行。本章中的代码示例可以在本书的 GitHub 仓库中找到，地址为
    [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic)。
- en: 'The following tools need to be installed and set up in your development environment:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下工具需要在您的开发环境中安装和设置：
- en: '**Java SDK**: Version 8 or above (we used Java 13).'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Java SDK**：版本 8 或更高（我们使用了 Java 13）。'
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as your build system. However, we recommend having Maven set up on any development
    machine. The instructions for downloading and installing Maven can be found at
    [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven**：这是可选的，仅当您希望使用 Maven 作为构建系统时才需要。然而，我们建议在所有开发机器上设置 Maven。下载和安装 Maven
    的说明可以在 [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi)
    找到。'
- en: '**Development IDE**: Based on your preference, any Java-based IDE can be used,
    but in this chapter, IntelliJ was used.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发 IDE**：根据您的偏好，可以使用任何基于 Java 的 IDE，但在这章中，我们使用了 IntelliJ。'
- en: '**Git**: The instructions for downloading and installing Git can be found at
    [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：下载和安装 Git 的说明可以在 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    找到。'
- en: '**PostgreSQL**: The instructions for downloading and installing PostgreSQL
    can be found at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL**：下载和安装 PostgreSQL 的说明可以在 [https://www.postgresql.org/download/](https://www.postgresql.org/download/)
    找到。'
- en: '**MongoDB**: MongoDB Atlas provides a free online Database-as-a-Service and
    up to 512 MB of storage. However, if you would prefer to use a local database,
    then the instructions for downloading and installing MongoDB can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation while writing this chapter.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：MongoDB Atlas 提供免费的在线数据库即服务，最多 512 MB 的存储空间。但是，如果您希望使用本地数据库，则可以在
    [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/)
    找到下载和安装 MongoDB 的说明。我们在编写本章时使用了本地安装。'
- en: '**REST client**: Any HTTP REST client can be used. We used the Advanced REST
    Client Chrome plugin in this chapter.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**REST 客户端**：可以使用任何 HTTP REST 客户端。在本章中，我们使用了 Advanced REST Client Chrome 插件。'
- en: '**Docker**: The instructions for downloading and installing Docker can be found
    at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker**：下载和安装Docker的说明可以在[https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/)找到。'
- en: '**Amazon**: An Amazon account for Alexa: [https://developer.amazon.com/alexa](https://developer.amazon.com/alexa).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Amazon**：为Alexa创建一个Amazon账户：[https://developer.amazon.com/alexa](https://developer.amazon.com/alexa)。'
- en: Bringing it all together
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: 'Let''s recap everything we learned about in all the chapters so far. In [*Chapter
    1*](B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015), *Getting Started with Microservices
    Using the Micronaut Framework*, we started by looking at microservices while using
    the Micronaut framework. There, we learned about microservices and their evolution:
    microservices design patterns. We learned about why Micronaut is the best choice
    for developing microservices and created our first Micronaut application. In [*Chapter
    2*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Working on Data Access,*
    we learned about working on data access.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止所有章节中学到的内容。在[*第1章*](B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015)《使用Micronaut框架开始微服务之旅》中，我们开始使用Micronaut框架来探讨微服务。在那里，我们学习了微服务及其演变：微服务设计模式。我们学习了为什么Micronaut是开发微服务的最佳选择，并创建了我们的第一个Micronaut应用程序。在[*第2章*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033)《数据访问工作》中，我们学习了如何进行数据访问。
- en: We started our first pet clinic, pet owner, and pet clinic review Micronaut
    project. We learned about integrating the persistence layer using the Micronaut
    framework, as well as about integrating with a relational database using an object-relational
    mapping Hibernate framework. We created our Micronaut backend database in PostgreSQL,
    defined relationships among entities, mapped the relationship between entities,
    and created data access repositories. We also created basic CRUD operations by
    inserting/creating, reading/fetching, updating, and deleting in the database using
    Micronaut. After, we integrated the relational database using the MyBatis framework.
    We also explored NoSQL database functionalities with MongoDB and Micronaut.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开始了我们的第一个宠物诊所、宠物主人以及宠物诊所评论的Micronaut项目。我们学习了如何使用Micronaut框架集成持久化层，以及如何使用对象关系映射Hibernate框架与关系型数据库集成。我们在PostgreSQL中创建了我们的Micronaut后端数据库，定义了实体之间的关系，映射了实体之间的关系，并创建了数据访问存储库。我们还通过在数据库中使用Micronaut进行插入/创建、读取/检索、更新和删除操作来创建了基本的CRUD操作。之后，我们使用MyBatis框架集成了关系型数据库。我们还探索了MongoDB和Micronaut的NoSQL数据库功能。
- en: In [*Chapter 3*](B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065), *Working on
    RESTful Web Services*, we learned about working on RESTful web services using
    Micronaut. We added RESTful web service capabilities to our pet clinic, pet owner,
    and pet clinic review Micronaut projects. We learned about data transfer objects,
    endpoint payloads, map structs, RESTful endpoints, the HTTP server API, validating
    data, handling errors, versioning the APIs, and the HTTP client API. We performed
    a RESTful operation on the service with GET, POST, PUT, and DELETE. In [*Chapter
    4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090), *Securing Microservices*,
    we learned about securing microservices. We created a working example of a RESTful
    microservice by enabling security aspects. We learned about the basics of Micronaut
    security by using session authentication for securing the service endpoints, implementing
    a basic authentication provider, configuring authorizations, granting unauthorized
    and secure access, using JWT authentication, setting up Keycloak in Docker, using
    OAuth, setting up the Okta identity provider, and enabling SSL in the Micronaut
    framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065)《使用Micronaut进行RESTful
    Web服务开发》中，我们学习了如何使用Micronaut进行RESTful Web服务的开发。我们为宠物诊所、宠物主人以及宠物诊所评论的Micronaut项目添加了RESTful
    Web服务功能。我们学习了数据传输对象、端点有效负载、映射结构、RESTful端点、HTTP服务器API、验证数据、处理错误、API版本控制和HTTP客户端API。我们使用GET、POST、PUT和DELETE在服务上执行了RESTful操作。在[*第4章*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090)《保护微服务》中，我们学习了如何保护微服务。通过启用安全方面，我们创建了一个具有安全功能的RESTful微服务的工作示例。我们通过使用会话认证来保护服务端点、实现基本认证提供者、配置授权、授予未经授权和安全的访问、使用JWT认证、在Docker中设置Keycloak、使用OAuth、设置Okta身份提供者以及启用Micronaut框架中的SSL，学习了Micronaut安全的基础知识。
- en: In [*Chapter 5*](B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106), *Integrating
    Microservices Using the Event-Driven Architecture*, we learned about integrating
    microservices using the event-driven architecture. We learned about the basics
    of the event-driven architecture, event streaming with Apache Kafka, and implementing
    an event producer and event consumer client in the pet clinic reviews microservice.
    In [*Chapter 6*](B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120), *Testing Microservices*,
    we mastered testing our microservices with Micronaut. We learned about the basics
    of unit testing in the Micronaut framework with JUnit 5, mock testing, service
    testing, the test suite that's available, and integration testing using test Docker
    containers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 5 章*](B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106)《使用事件驱动架构集成微服务》中，我们学习了如何使用事件驱动架构集成微服务。我们学习了事件驱动架构的基础知识、Apache
    Kafka 的事件流以及如何在宠物诊所评论微服务中实现事件生产者和事件消费者客户端。在第 [*第 6 章*](B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120)《测试微服务》中，我们掌握了使用
    Micronaut 测试微服务。我们学习了在 Micronaut 框架中使用 JUnit 5 进行单元测试的基础知识、模拟测试、服务测试、可用的测试套件以及使用测试
    Docker 容器进行的集成测试。
- en: In [*Chapter 7*](B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132), *Handling
    Microservices Concerns*, we learned about handling microservices concerns. We
    learned about externalizing application configurations, distributed configuration
    management, documenting the Service API using Swagger, implementing service discovery,
    creating service discovery using Consul, implementing the API gateway service,
    and implementing fault tolerance mechanisms using circuit breakers and fallbacks.
    In [*Chapter 8*](B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146), *Deploying Microservices*,
    we learned about deploying microservices. We learned about building container
    artifacts, containerizing using Jib, deploying container artifacts, using `docker-compose`,
    and deploying a multi-service application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 7 章*](B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132)《处理微服务问题》中，我们学习了如何处理微服务问题。我们学习了外部化应用程序配置、分布式配置管理、使用
    Swagger 记录服务 API、实现服务发现、使用 Consul 创建服务发现、实现 API 网关服务以及使用断路器和回退实现容错机制。在第 [*第 8
    章*](B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146)《部署微服务》中，我们学习了如何部署微服务。我们学习了构建容器工件、使用
    Jib 容器化、部署容器工件、使用 `docker-compose` 以及部署多服务应用程序。
- en: In [*Chapter 9*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155), *Distributed
    Logging, Tracing, and Monitoring*, we learned about distributed logging, tracing,
    and monitoring. We also learned about the log producer, dispatcher, storage, and
    visualizer. We implemented Elasticsearch, Logstash, and Kibana. After, we set
    up ELK in Docker, integrated with some Micronaut microservices, and implemented
    distributed tracing in Micronaut. Finally, we set up Prometheus and Grafana in
    Docker. In [*Chapter 10*](B16585_10_Final_VK_ePub.xhtml#_idTextAnchor172), *IoT
    with Micronaut*, we learned about IoT with Micronaut. We learned about IoT, Alexa
    skills, space facts, utterances, intents, your first Alexa skills, the voice interaction
    model, integrating Micronaut with Alexa, AWS, AlexaFunction, and testing your
    AlexaFunction with Micronaut.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 9 章*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155)《分布式日志、跟踪和监控》中，我们学习了分布式日志、跟踪和监控。我们还学习了日志生产者、调度器、存储和可视化器。我们实现了
    Elasticsearch、Logstash 和 Kibana。之后，我们在 Docker 中设置了 ELK，与一些 Micronaut 微服务集成，并在
    Micronaut 中实现了分布式跟踪。最后，我们在 Docker 中设置了 Prometheus 和 Grafana。在第 [*第 10 章*](B16585_10_Final_VK_ePub.xhtml#_idTextAnchor172)《使用
    Micronaut 的物联网》中，我们学习了使用 Micronaut 的物联网。我们学习了物联网、Alexa 技能、太空事实、话语、意图、您的第一个 Alexa
    技能、语音交互模型、将 Micronaut 与 Alexa、AWS、AlexaFunction 集成以及使用 Micronaut 测试 AlexaFunction。
- en: To summarize, we learned about all the building blocks that are required to
    create an enterprise application using databases, web services, containers, deployments,
    testing, configuration, monitoring, event-driven architecture, security, and IoT.
    All the working examples we covered are available in this book's GitHub repository.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们学习了创建企业应用程序所需的所有构建块，包括数据库、Web 服务、容器、部署、测试、配置、监控、事件驱动架构、安全和物联网。本书中涵盖的所有工作示例都可在本书的
    GitHub 仓库中找到。
- en: 'The following diagram provides a summary of all the chapters in this book:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表提供了本书所有章节的总结：
- en: '![Figure 11.1 – Bringing it all together – chapters roadmap'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – 整合所有内容 – 章节路线图'
- en: '](img/Figure_11.1_B16585.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.1_B16585.jpg)'
- en: Figure 11.1 – Bringing it all together – chapters roadmap
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – 整合所有内容 – 章节路线图
- en: With that, we have learned about the foundations of creating Micronaut microservices.
    Now that we are familiar with Micronaut, the necessary development tools, testing,
    databases, the event-driven architecture, distributed logging, tracing, monitoring,
    and IoT, we have all the necessary knowledge and skills to create enterprise microservices.
    We will learn about architecting enterprise microservices in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经了解了创建Micronaut微服务的基础。现在，我们已经熟悉了Micronaut、必要的开发工具、测试、数据库、事件驱动架构、分布式日志、跟踪、监控和物联网，我们拥有了创建企业级微服务所需的所有知识和技能。我们将在下一节学习如何架构企业级微服务。
- en: Architecting enterprise microservices
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构企业级微服务
- en: Implementing enterprise microservices requires understanding and motivation
    from multiple stakeholders in the organization. You need to plan and analyze whether
    a microservice is the right fit for the problem at hand. If it is a fit, then
    you must design, develop, deploy, manage, and maintain the service.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 实施企业级微服务需要组织内多个利益相关者的理解和动力。你需要计划和分析微服务是否适合当前的问题。如果是的话，那么你必须设计、开发、部署、管理和维护该服务。
- en: 'Before you start using microservices, let''s understand when not to use them.
    Ask yourself the following questions:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用微服务之前，让我们了解一下何时不应使用它们。问问自己以下问题：
- en: Does your team know about microservices?
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的团队是否了解微服务？
- en: Is your business mature enough to adopt microservices?
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的业务是否足够成熟以采用微服务？
- en: Do you have an Agile DevOps practice and infrastructure?
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有敏捷的DevOps实践和基础设施？
- en: Do you have a scalable on-premises or cloud infrastructure?
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有可扩展的本地或云基础设施？
- en: Do you have support to use modern tools and technology?
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否有使用现代工具和技术的支持？
- en: Is your database ready to be decentralized?
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的数据库是否准备好去中心化？
- en: Do you have support from all the stakeholders?
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否得到了所有利益相关者的支持？
- en: 'If your answer is yes to each of these questions, you can adapt and roll out
    microservices. The hardest part about rolling out microservices is your data and
    infrastructure. Traditionally, applications are designed to be big monolithic
    apps compared to decentralized, loosely coupled microservices. When you architect
    a microservice, you need to apply multiple techniques during the various phases.
    The following diagram illustrates the stages of rolling out enterprise microservices:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些问题中的每一个都回答“是”，那么你可以适应并部署微服务。部署微服务最困难的部分是你的数据和基础设施。传统上，应用程序被设计成大型的单体应用，与去中心化、松散耦合的微服务相比。当你架构微服务时，你需要在各个阶段应用多种技术。以下图表展示了部署企业级微服务的阶段：
- en: '![Figure 11.2 – Phases of architecting and rolling out enterprise microservices'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2 – 架构和部署企业级微服务的阶段'
- en: '](img/Figure_11.2_B16585.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B16585.jpg)'
- en: Figure 11.2 – Phases of architecting and rolling out enterprise microservices
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2 – 架构和部署企业级微服务的阶段
- en: We'll look at each of these stages in the following sections.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下各节中查看这些各个阶段。
- en: Planning and analysis
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规划和分析
- en: Before you can create an architecture for an enterprise microservice, you need
    to analyze whether it is a good fit based on your requirements. You can also implement
    microservices for just a part of the application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在你可以为企业的微服务创建架构之前，你需要分析它是否符合你的要求。你也可以只为应用程序的一部分实现微服务。
- en: Transitioning from a traditional monolithic architecture to microservices can
    be a time-consuming and complex process. However, if it is planned well, it can
    be rolled out seamlessly. Getting all stakeholders to support this is crucial,
    and this can be accomplished in the planning and analysis phase. Team members
    having knowledge of microservices is also vital and a critical success factor.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从传统的单体架构过渡到微服务可能是一个耗时且复杂的过程。然而，如果规划得当，它可以无缝部署。让所有利益相关者支持这一点至关重要，这可以在规划和分析阶段实现。团队成员对微服务的了解也是至关重要的，并且是成功的关键因素。
- en: Design
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'During the design phase, you can use design patterns, as we learned in [*Chapter
    1*](B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015), *Getting Started with Microservices
    Using Micronaut Framework*. Design patterns are reusable proven solutions for
    recurring business or technology problems. The following are the design patterns
    that we have explored so far in this book:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计阶段，你可以使用我们在[*第一章*](B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015)“使用Micronaut框架开始微服务之旅”中学到的设计模式。设计模式是针对重复出现的业务或技术问题的可重用和经过验证的解决方案。以下是我们在这本书中迄今为止探索的设计模式：
- en: Decomposition by business capability
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按业务能力分解
- en: Decomposing by domains/subdomains
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按领域/子领域分解
- en: API gateway pattern
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API网关模式
- en: Chained microservices pattern
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链式微服务模式
- en: Database per service
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个服务一个数据库
- en: Command query responsibility segregation pattern
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令查询责任分离模式
- en: Service discovery pattern
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务发现模式
- en: Circuit breaker pattern
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断路器模式
- en: Log aggregation pattern
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日志聚合模式
- en: Design patterns are continuously evolving. Always check for new patterns in
    the industry and evaluate whether they are a good fit for your solution. The next
    important area to consider when designing a microservice is security. We learned
    about securing microservices in [*Chapter 4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090),
    *Securing Microservices*. Here, we learned about evaluating authentication strategies,
    security rules, privilege-based access, OAuth, and SSL.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是持续演进的。始终检查行业中的新模式，并评估它们是否适合您的解决方案。在设计微服务时，下一个重要的考虑领域是安全性。我们在[*第4章*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090)“保护微服务”中学习了关于保护微服务的内容。在这里，我们学习了评估身份验证策略、安全规则、基于权限的访问、OAuth和SSL。
- en: Other factors to consider when designing are to check for privacy-specific standards
    in the application such as **HIPAA** (short for **Health Insurance Portability
    and Accountability Act**), **General Data Protection Regulation** (**GDPR**),
    **Personal Information Protection and Electronic Documents Act** (**PIPEDA**),
    Bank Act, and so on. Check for encryption standards such as encryption at rest
    and encryption in transit, whether your data is encrypted before transmission,
    or whether your data has been stored and encrypted. Check for the security protocol
    version currently being used and apply the latest stable, supported version patches.
    The data retention strategy is another area to think about while designing a microservice.
    How long do you need to store the data for, and what is the archival strategy
    for data and log files? Also, some countries have regulations where you can store
    the data, check the requirements, and consider them while designing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计时需要考虑的其他因素包括检查应用程序中的隐私特定标准，例如**HIPAA**（即**健康保险可携带性和责任法案**）、**通用数据保护条例**（**GDPR**）、**个人信息保护与电子文件法案**（**PIPEDA**）、银行法等。检查加密标准，例如静态加密和传输加密，您的数据在传输前是否加密，或者您的数据是否已存储并加密。检查当前使用的安全协议版本，并应用最新稳定、受支持的版本补丁。数据保留策略是设计微服务时需要考虑的另一个领域。您需要存储数据多长时间，数据存档策略是什么？此外，一些国家有关于数据存储的法规，请检查要求，并在设计时考虑它们。
- en: Develop
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发
- en: Development is an essential phase in implementing microservices. Always use
    the latest stable, supported version for development. Use the Micronaut framework
    to perform automated testing. Test at various levels, such as unit testing, service
    testing, and integration testing. In [*Chapter 6*](B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120)*,
    Testing the Microservices*, we learned about testing microservices. Here, we learned
    that you should always emulate a real-world environment using containers or a
    cloud infrastructure, as well as using mocking and spying concepts during testing.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 开发是实现微服务的一个重要阶段。始终使用最新稳定、受支持的版本进行开发。使用Micronaut框架进行自动化测试。在各个级别进行测试，例如单元测试、服务测试和集成测试。在[*第6章*](B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120)“测试微服务”中，我们学习了关于测试微服务的内容。在这里，我们了解到您应该始终使用容器或云基础设施来模拟真实世界环境，以及在测试期间使用模拟和监视概念。
- en: If you create a separate version control strategy for each service, the service
    can be stored in separate repositories with the required configuration and logs.
    Make sure that you synchronize your development, QA, UAT, and PROD environments
    and that you have an identical infrastructure across various stages of development.
    During development, think about backward compatibility for the microservices if
    you would like to support older versions of the microservices. Have a separate
    database for each microservice to attain their fullest potential.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为每个服务创建单独的版本控制策略，则可以将服务存储在具有所需配置和日志的单独存储库中。确保您同步开发、QA、UAT和PROD环境，并在开发的不同阶段拥有相同的基础设施。在开发过程中，如果您想支持旧版本的微服务，请考虑向后兼容性。为每个微服务保留单独的数据库以发挥其最大潜力。
- en: Deploy
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署
- en: When it comes to deployment, you should use automated tools and techniques and
    leverage rapid application deployment strategies. We learned about deploying microservices
    in [*Chapter 8*](B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146), *Deploying Microservices*.
    Use tools such as containers, virtual machines, the cloud, Jib, and Jenkins, and
    use infrastructure efficiently – don't overallocate. Finally, ensure that you
    have a dedicated microservices DevOps strategy to facilitate **continuous integration**
    and **continuous delivery** (**CI/CD**).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到部署时，你应该使用自动化工具和技术，并利用快速应用部署策略。我们在[*第8章*](B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146)“部署微服务”中学习了如何部署微服务。使用容器、虚拟机、云、Jib和Jenkins等工具，并高效地使用基础设施——不要过度分配。最后，确保你有一个专门的微服务DevOps策略，以促进**持续集成**和**持续交付**（**CI/CD**）。
- en: Manage and maintain
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理和维护
- en: Maintaining multiple microservices is crucial and complex. You should monitor
    your application with distributed logging, tracing, and monitoring, as we learned
    in [*Chapter 9*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155), *Distributed
    Logging, Tracing, and Monitoring*. Use tools such as Elasticsearch, Logstash,
    Kibana, Prometheus, and Grafana to do so. Monitor the code base's health using
    Sonar DevSecOps and check for security vulnerabilities in the code periodically.
    You should always update the technology's version, operating system, and tools
    frequently. Also, monitor your CPU usage, memory footprint, and storage space
    in real time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 维护多个微服务至关重要且复杂。你应该使用分布式日志、跟踪和监控来监控你的应用程序，正如我们在[*第9章*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155)“分布式日志、跟踪和监控”中学到的。使用Elasticsearch、Logstash、Kibana、Prometheus和Grafana等工具来做到这一点。使用Sonar
    DevSecOps监控代码库的健康状况，并定期检查代码中的安全漏洞。你应该经常更新技术的版本、操作系统和工具。此外，实时监控你的CPU使用率、内存占用和存储空间。
- en: Finally, scale your infrastructure at runtime to avoid hardware overuse. We
    will discuss how to scale Micronaut in the upcoming sections.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在运行时扩展你的基础设施以避免硬件过度使用。我们将在接下来的章节中讨论如何扩展Micronaut。
- en: Now that we know how to architect the microservices, let's understand more about
    Micronaut's OpenAPI.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何架构微服务，让我们更深入地了解Micronaut的OpenAPI。
- en: Understanding Micronaut's OpenAPI
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Micronaut的OpenAPI
- en: APIs are generic languages for machines to interact with each other. Having
    an API definition ensures there is a formalized specification in place. All APIs
    should have a specification, which improves development efficiency and reduces
    interaction problems. The specifications act as documentation that helps third-party
    developers or systems to understand the service easily. Micronaut supports OpenAPI
    (Swagger) YAML at compile time. We learned about this in [*Chapter 7*](B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132),
    *Handling Microservices Concerns*. The **OpenAPI Initiative** (**OAI**) was previously
    known as the **Swagger Specification**. It is used to create machine-readable
    interface files for describing, producing, consuming, and visualizing RESTful
    web services. The **OAI** is now a consortium that promotes a vendor-neutral description
    format. OpenAPI is also called a *public API*, which is publicly made available
    to software developers and companies. Open APIs can be implemented with REST APIs
    or SOAP APIs. RESTful APIs are the most popular trending API format used in the
    industry. OpenAPI must have strong encryption and security in place. These APIs
    can be public or private (closed). A public OpenAPI can be accessed over the internet;
    however, a private OpenAPI can only be accessed in the intranet within a firewall
    or VPN service. Open APIs generate accurate documentation, such as all the required
    meta-information, reusable components, and endpoint details. There are several
    versions of the **OpenAPI Specification** (**OAS**); the current version is 3.1.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: API是机器之间相互交互的通用语言。拥有API定义确保了存在一个正式的规范。所有API都应该有一个规范，这可以提高开发效率并减少交互问题。规范充当文档，帮助第三方开发人员或系统轻松理解服务。Micronaut在编译时支持OpenAPI（Swagger）YAML。我们曾在[*第7章*](B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132)中了解到这一点，*处理微服务关注点*。**OpenAPI倡议**（**OAI**）之前被称为**Swagger规范**。它用于创建描述、生成、消费和可视化RESTful
    Web服务的机器可读接口文件。**OAI**现在是一个促进供应商中立描述格式的联盟。OpenAPI也被称为*公共API*，它公开发布给软件开发人员和公司。Open
    API可以用REST API或SOAP API实现。RESTful API是行业中最流行的API格式。OpenAPI必须具备强大的加密和安全措施。这些API可以是公开的或私有的（封闭的）。公开的OpenAPI可以通过互联网访问；然而，私有的OpenAPI只能在防火墙或VPN服务内的内网中访问。Open
    API生成准确的文档，例如所有必需的元信息、可重用组件和端点详细信息。**OpenAPI规范**（**OAS**）有几个版本；当前版本是3.1。
- en: You can learn more about OpenAPI at [https://www.openapis.org/](https://www.openapis.org/).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.openapis.org/](https://www.openapis.org/)了解更多关于OpenAPI的信息。
- en: Now that we have learned about Micronaut's OpenAPI, lets, understand scaling
    Micronaut in the enterprise.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Micronaut的OpenAPI，让我们来了解如何在企业中扩展Micronaut。
- en: Scaling Micronaut
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Micronaut的扩展
- en: When designing and implementing an enterprise application, the ability to scale
    needs to be planned. One of the biggest advantages of using microservices is scalability.
    Scaling Micronaut services is a crucial factor by design. It is more than just
    handling volume – it is about scaling with minimal effort involved. Micronaut
    makes it easier to identify scaling problems and then resolve challenges at each
    microservice level. Micronaut microservices are single-purpose applications that
    can be assembled to build large enterprise-scale software systems. Scaling at
    runtime is a vital factor in modernizing the enterprise.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计和实施企业应用程序时，需要规划扩展能力。使用微服务的最大优点之一是可扩展性。Micronaut服务的扩展是设计中的一个关键因素。这不仅仅是处理量的问题——它还涉及到以最小的努力进行扩展。Micronaut使得识别扩展问题并解决每个微服务级别的挑战变得更加容易。Micronaut微服务是单一用途的应用程序，可以组合起来构建大型企业级软件系统。运行时扩展是现代化企业的一个关键因素。
- en: 'There are three types of scaling: *x*-axis, *y*-axis, and *z*-axis scaling.
    The following diagram illustrates the x-axis (horizontal scaling) and y-axis (vertical
    scaling):'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种扩展类型：*x*轴、*y*轴和*z*轴扩展。以下图表说明了x轴（水平扩展）和y轴（垂直扩展）：
- en: '![Figure 11.3 – Vertical scaling versus horizontal scaling'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3 – 垂直扩展与水平扩展'
- en: '](img/Figure_11.3_B16585.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.3_B16585.jpg)'
- en: Figure 11.3 – Vertical scaling versus horizontal scaling
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3 – 垂直扩展与水平扩展
- en: Horizontal scaling is also called x-axis scaling. In horizontal scaling, we
    scale by creating new servers or virtual machines; the entire infrastructure for
    the service is scaled. For example, if 10 services are running in a virtual machine,
    we need to add a virtual machine with 10 services if one service requires additional
    capacity. If you analyze this scenario, there will be unused server capacity as
    only one service required an additional CPU instead of 10\. However, this type
    of scaling provides unlimited scaling of the infrastructure.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 水平扩展也称为x轴扩展。在水平扩展中，我们通过创建新的服务器或虚拟机来扩展；服务的整个基础设施都会进行扩展。例如，如果有10个服务在一个虚拟机中运行，如果其中一个服务需要额外的容量，我们需要添加一个包含10个服务的虚拟机。如果你分析这个场景，你会看到会有未使用的服务器容量，因为只有一个服务需要额外的CPU，而不是10个。然而，这种扩展类型提供了基础设施的无限制扩展。
- en: 'Vertical scaling is also called y-axis scaling. In vertical scaling, we scale
    by adding capacity to the existing servers. Capacity is scaled by adding additional
    CPU, storage, and RAM. For example, if 10 services are running in a virtual machine,
    if one service requires additional capacity such as RAM and CPU, we need to add
    extra RAM and CPU to the same virtual machine. This is the fundamental difference
    between horizontal and vertical scaling. However, vertical scaling has a limitation:
    it cannot scale beyond a specific limit. The following diagram illustrates the
    x-axis (horizontal scaling) and z-axis (microservices horizontal scaling):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直扩展也称为y轴扩展。在垂直扩展中，我们通过向现有服务器添加容量来扩展。容量通过添加额外的CPU、存储和RAM来扩展。例如，如果有10个服务在一个虚拟机中运行，如果其中一个服务需要额外的容量，如RAM和CPU，我们需要向同一个虚拟机添加额外的RAM和CPU。这是水平扩展和垂直扩展之间的基本区别。然而，垂直扩展有一个限制：它不能超过特定的限制。以下图表展示了x轴（水平扩展）和z轴（微服务水平扩展）：
- en: '![Figure 11.4 – Traditional horizontal scaling versus microservices horizontal
    scaling'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4 – 传统水平扩展与微服务水平扩展对比'
- en: '](img/Figure_11.4_B16585.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_11.4_B16585.jpg)'
- en: Figure 11.4 – Traditional horizontal scaling versus microservices horizontal
    scaling
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4 – 传统水平扩展与微服务水平扩展对比
- en: Microservices horizontal scaling is also known as z-axis scaling. This is almost
    the same as traditional horizontal scaling. For example, if 10 services are running
    in a microservice container environment, if one service requires additional capacity,
    we need to add one microservice container environment instead of 10\. If you analyze
    this scenario, you will see that this is the most optimal use of the available
    capacity. This type of scaling allows you to scale the infrastructure as many
    times as you like and is the most cost-efficient method. Its performance is a
    lot better than in a non-scaled environment. You can scale with containers and
    also with cloud infrastructure. The capabilities of autoscaling are very powerful
    and come in handy for microservices.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务水平扩展也称为z轴扩展。这几乎与传统水平扩展相同。例如，如果有10个服务在一个微服务容器环境中运行，如果其中一个服务需要额外的容量，我们需要添加一个微服务容器环境，而不是10个。如果你分析这个场景，你会看到这是对可用容量的最优化使用。这种扩展类型允许你按需多次扩展基础设施，并且是最具成本效益的方法。它的性能比非扩展环境要好得多。你可以使用容器和云基础设施进行扩展。自动扩展的功能非常强大，对于微服务来说非常实用。
- en: Now we have learned about scaling microservices, let's implement the enterprise
    microservices with all the features we have learned.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了微服务的扩展，接下来让我们实现具有我们所学所有功能的的企业级微服务。
- en: Implementing Micronaut's microservices
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Micronaut的微服务
- en: Now, let's implement what we have learned so far in this chapter. You can use
    the code in this chapter's GitHub repository. We will use the four projects we've
    covered in this book – pet clinic, pet owner, pet reviews, and concierge. We will
    also be using a Zipkin container image for distributed tracing, Prometheus for
    metrics and monitoring, and the `elk` container image for Elasticsearch, Logstash,
    and Kibana.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现本章所学的内容。你可以使用本章GitHub仓库中的代码。我们将使用本书中涵盖的四个项目——宠物诊所、宠物主人、宠物评论和礼宾服务。我们还将使用Zipkin容器镜像进行分布式跟踪、Prometheus进行指标和监控，以及`elk`容器镜像用于Elasticsearch、Logstash和Kibana。
- en: 'The following screenshot illustrates the list of projects in this book''s GitHub
    repository that we will be using:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了本书GitHub仓库中我们将要使用的项目列表：
- en: '![Figure 11.5 – GitHub projects for our implementation'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 – 我们实现所用的GitHub项目'
- en: '](img/Figure_11.5_B16585.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_11.5_B16585.jpg)'
- en: Figure 11.5 – GitHub projects for our implementation
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to set up Keycloak. Please refer to [*Chapter 4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090),
    *Securing Microservices*, the *Setting up Keycloak as the identity provider* and
    *Creating a client on the Keycloak server* sections.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command can be run to create the Keycloak Docker image:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Once Keycloak is up and running, the client secret key needs to be copied from
    the `pet clinic` user and clients should be set up already. Please refer to [*Chapter
    4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090), *Securing Microservices*,
    for more information.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the timeout settings in Keycloak. Go to the **Keycloak** console | **Clients**
    | **Settings** | **Advanced Settings**. **15 Minutes** is recommended for testing
    the sample code.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screen illustrates the Keycloak **Access** **Token Lifespan**
    location:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Keycloak Access Token Lifespan'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.8_B16585.jpg)'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.8 – Keycloak Access Token Lifespan
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The secret needs to be copied so that it can be replaced in the `pet-clinic`,
    `pet-owner`, `pet-clinic-reviews`, and `pet-clinic-concierge` projects. The YAML
    application configuration file, `client-secret`, needs to be updated from the
    Keycloak secret, as shown in the preceding screenshot. The following are the files
    that must be updated:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot illustrates a sample `.yaml` file configuration where
    the client secret ID needs to be replaced:'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Keycloak portal – client secret in the application YAML file'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.9_B16585.jpg)'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.9 – Keycloak portal – client secret in the application YAML file
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once every client secret has been updated, execute the Maven Docker build in
    all four projects (`pet-clinic-concierge`, `pet-clinic-reviews`, `pet-clinic`,
    and `pet-owner`). The following Maven command creates a Docker image for each
    project:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Check the Docker setting resources. You need four CPUs and at least 6 GB of
    memory. Go to the **Docker** settings | **Resources** | **Advanced**:![Figure
    11.10 – Docker CPU and memory settings
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_11.10_B16585.jpg)'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.10 – Docker CPU and memory settings
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step, after creating the Docker images, is to create `docker-compose`
    for Kafka, Zipkin, Prometheus, and ELK. Execute the following command in a terminal
    or console to create the Docker image:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is how the file works:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Docker Compose – Zipkin'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.12_B16585.jpg)'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This is how the file works:'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Docker Compose – Prometheus'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.13_B16585.jpg)'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is how the file works:'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Docker Compose – ELK'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.14_B16585.jpg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, this is how the file works:'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Docker Compose Micronaut pet clinic'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.15_B16585.jpg)'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.15 – Docker Compose Micronaut pet clinic
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the security configuration protects all the projects using Keycloak,
    except `pet-clinic-reviews`:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pet-clinic-concierge`: Protected using Keycloak'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic`: Protected using Keycloak'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-owner`: Protected using Keycloak'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-reviews`: Unprotected'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before testing the applications, check whether all the applications are running
    in the Docker container. The following screenshot illustrates the application
    running in a Docker container successfully:![Figure 11.16 – Docker container running
    all required applications
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_11.16_B16585.jpg)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.16 – Docker container running all required applications
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that all the projects are running in Docker, let''s test the URL''s integration.
    You can call all the services from the API gateway, as follows:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pet-owner`: `http://localhost:32584/api/owners`'
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic`: `http://localhost:32584/api/vets`'
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-reviews`: `http://localhost:32584/api/vet-reviews `'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have the apps running in Docker, you need to obtain the security token
    by invoking the following API on Keycloak:'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PUT_CLIENT_SECRET_HERE` must be replaced with the Keycloak credentials secret.'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, this is what the request in the console looks like:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.17 – curl request to get the JWT'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.17_B16585.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.17 – curl request to get the JWT
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then check that the `curl` request returns an access token:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – curl response JWT'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.18_B16585.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.18 – curl response JWT
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Copy and format the JSON response using a JSON formatter. The `access_token`
    attribute value from the formatter response must be copied, and this value will
    be passed as a JWT, shown as follows:![Figure 11.19 – curl response JWT
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_11.19_B16585.jpg)'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.19 – curl response JWT
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you receive a response from `curl`, you can copy the `access_token` value.
    `access_token` can be passed to call the services in the request header, as shown
    in the following screenshot:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.20 – REST response for the vets API'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.20_B16585.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.20 – REST response for the vets API
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must test all the application URLs and their integration using the
    following links:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:32584/`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8500/ui/dc1/services`. This will launch Consul as shown in
    the screenshot:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.21 – REST response for the vets API'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.21_B16585.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.21 – REST response for the vets API
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5601/app/kibana`. This will launch the Kibana logging portal
    as shown in the following screenshot:'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Kibana logging portal'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.22_B16585.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.22 – Kibana logging portal
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The Kibana default username is `elastic` and password is `changeme`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:3000/?orgId=1`. This will launch the Grafana monitoring tool.
    Detailed steps to configure the dashboard can be found in [*Chapter 9*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155),
    *Distributed Logging, Tracing, and Monitoring*:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Distributed monitoring using Grafana'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.23_B16585.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.23 – Distributed monitoring using Grafana
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.23 – 使用 Grafana 进行分布式监控
- en: Note
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: Prometheus, default username is `admin` and password is `pass`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Prometheus，默认用户名为 `admin`，密码为 `pass`。
- en: '`http://localhost:9411/zipkin/`. The following screenshot illustrates the Zipkin
    user interface for distributed tracing:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:9411/zipkin/`。以下截图展示了 Zipkin 分布式跟踪的用户界面：'
- en: '![Figure 11.24 – Distributed tracing using Zipkin'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.24 – 使用 Zipkin 进行分布式跟踪'
- en: '](img/Figure_11.24_B16585.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.24_B16585.jpg]'
- en: Figure 11.24 – Distributed tracing using Zipkin
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.24 – 使用 Zipkin 进行分布式跟踪
- en: '`http://localhost:8888/auth/` is the identity provider that will launch Keycloak
    which is the identity provider.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:8888/auth/` 是将启动 Keycloak 的身份提供者，而 Keycloak 是身份提供者。'
- en: '`http://localhost:9100/`. Here you can view the cluster with Kafdrop:'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`http://localhost:9100/`。在这里，你可以使用 Kafdrop 查看集群：'
- en: '![Figure 11.25 – Kafdrop Cluster view'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.25 – Kafdrop 集群视图'
- en: '](img/Figure_11.25_B16585.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.25_B16585.jpg]'
- en: Figure 11.25 – Kafdrop Cluster view
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.25 – Kafdrop 集群视图
- en: Overall, we have tested all the features of the integration from the gateway
    to distributed monitoring, tracking, logging, and searching. With this, we have
    completed this chapter. In this section, we learned how to implement microservices
    in Micronaut while in production.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，我们已经测试了从网关到分布式监控、跟踪、日志记录和搜索的集成所有功能。有了这些，我们就完成了这一章。在本节中，我们学习了如何在生产中实现微服务。
- en: Summary
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we brought everything we'd learned about in the previous chapters
    together. Then, we dived into architecting enterprise-grade microservices. We
    also learned about scaling microservices, the different types of scaling, and
    their advantages.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将前几章所学的内容综合起来。然后，我们深入探讨了构建企业级微服务的架构。我们还学习了微服务的扩展、不同类型的扩展及其优势。
- en: This chapter enhanced your Micronaut microservices knowledge so that you can
    make production-ready applications. It has equipped you with all the necessary
    skills and expertise. We started the journey with the basics of microservices,
    and now we have the knowledge to create enterprise-grade microservices with Micronaut.
    We hope you enjoyed the journey of learning with us.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 本章增强了你的 Micronaut 微服务知识，以便你可以创建生产就绪的应用程序。它为你提供了所有必要的技能和专业知识。我们从微服务的基础开始，现在我们有了使用
    Micronaut 创建企业级微服务的知识。我们希望你喜欢与我们一起学习的旅程。
- en: Questions
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name a few factors you should consider when architecting microservices.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设计微服务时，你应该考虑哪些因素？
- en: Name a few design patterns.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些设计模式。
- en: What factors should you consider during the design phase of microservices?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务的设计阶段，你应该考虑哪些因素？
- en: What factors should you consider during the development phase of microservices?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务的开发阶段，你应该考虑哪些因素？
- en: Name a few tools that are used in the deployment phase.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些在部署阶段使用的工具。
- en: Name a few tools that are used in the manage and maintain phase.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举一些在管理和维护阶段使用的工具。
- en: What are the different types of scaling?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有哪些不同的扩展类型？
- en: What type of scaling is used in a microservices architecture?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在微服务架构中使用了哪种类型的扩展？
