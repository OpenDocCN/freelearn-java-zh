- en: '*Chapter 11*: Building Enterprise-Grade Microservices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have reached the last stage of learning about hands-on microservices with
    Micronaut. Our journey is now in its final stage; we gained a lot of knowledge
    of being hands-on in Micronaut in the previous chapters. Now, we must connect
    all the pieces to build our enterprise-grade microservices with Micronaut. As
    we already know from our previous chapters, the following are some of the benefits
    of using Micronaut:'
  prefs: []
  type: TYPE_NORMAL
- en: Modern JVM-based full-stack framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily testable microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Built for serverless applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimal memory footprint and startup time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-native framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-language support (Java, Groovy, Kotlin)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Bringing it all together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Architecting enterprise microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Micronaut's OpenAPI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Micronaut's microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be well-versed in building, architecting,
    and scaling enterprise-grade microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All the commands and technical instructions in this chapter can be run on Windows
    10 and Mac OS X. The code examples in this chapter are available in this book's
    GitHub repository at [https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic](https://github.com/PacktPublishing/Building-Microservices-with-Micronaut/tree/master/Chapter11/micronaut-petclinic).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following tools need to be installed and set up in your development environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java SDK**: Version 8 or above (we used Java 13).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven**: This is optional and only required if you would like to use Maven
    as your build system. However, we recommend having Maven set up on any development
    machine. The instructions for downloading and installing Maven can be found at
    [https://maven.apache.org/download.cgi](https://maven.apache.org/download.cgi).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development IDE**: Based on your preference, any Java-based IDE can be used,
    but in this chapter, IntelliJ was used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: The instructions for downloading and installing Git can be found at
    [https://git-scm.com/downloads](https://git-scm.com/downloads).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PostgreSQL**: The instructions for downloading and installing PostgreSQL
    can be found at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MongoDB**: MongoDB Atlas provides a free online Database-as-a-Service and
    up to 512 MB of storage. However, if you would prefer to use a local database,
    then the instructions for downloading and installing MongoDB can be found at [https://docs.mongodb.com/manual/administration/install-community/](https://docs.mongodb.com/manual/administration/install-community/).
    We used a local installation while writing this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**REST client**: Any HTTP REST client can be used. We used the Advanced REST
    Client Chrome plugin in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: The instructions for downloading and installing Docker can be found
    at [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon**: An Amazon account for Alexa: [https://developer.amazon.com/alexa](https://developer.amazon.com/alexa).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s recap everything we learned about in all the chapters so far. In [*Chapter
    1*](B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015), *Getting Started with Microservices
    Using the Micronaut Framework*, we started by looking at microservices while using
    the Micronaut framework. There, we learned about microservices and their evolution:
    microservices design patterns. We learned about why Micronaut is the best choice
    for developing microservices and created our first Micronaut application. In [*Chapter
    2*](B16585_02_Final_VK_ePub.xhtml#_idTextAnchor033), *Working on Data Access,*
    we learned about working on data access.'
  prefs: []
  type: TYPE_NORMAL
- en: We started our first pet clinic, pet owner, and pet clinic review Micronaut
    project. We learned about integrating the persistence layer using the Micronaut
    framework, as well as about integrating with a relational database using an object-relational
    mapping Hibernate framework. We created our Micronaut backend database in PostgreSQL,
    defined relationships among entities, mapped the relationship between entities,
    and created data access repositories. We also created basic CRUD operations by
    inserting/creating, reading/fetching, updating, and deleting in the database using
    Micronaut. After, we integrated the relational database using the MyBatis framework.
    We also explored NoSQL database functionalities with MongoDB and Micronaut.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B16585_03_Final_VK_ePub.xhtml#_idTextAnchor065), *Working on
    RESTful Web Services*, we learned about working on RESTful web services using
    Micronaut. We added RESTful web service capabilities to our pet clinic, pet owner,
    and pet clinic review Micronaut projects. We learned about data transfer objects,
    endpoint payloads, map structs, RESTful endpoints, the HTTP server API, validating
    data, handling errors, versioning the APIs, and the HTTP client API. We performed
    a RESTful operation on the service with GET, POST, PUT, and DELETE. In [*Chapter
    4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090), *Securing Microservices*,
    we learned about securing microservices. We created a working example of a RESTful
    microservice by enabling security aspects. We learned about the basics of Micronaut
    security by using session authentication for securing the service endpoints, implementing
    a basic authentication provider, configuring authorizations, granting unauthorized
    and secure access, using JWT authentication, setting up Keycloak in Docker, using
    OAuth, setting up the Okta identity provider, and enabling SSL in the Micronaut
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B16585_05_Final_VK_ePub.xhtml#_idTextAnchor106), *Integrating
    Microservices Using the Event-Driven Architecture*, we learned about integrating
    microservices using the event-driven architecture. We learned about the basics
    of the event-driven architecture, event streaming with Apache Kafka, and implementing
    an event producer and event consumer client in the pet clinic reviews microservice.
    In [*Chapter 6*](B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120), *Testing Microservices*,
    we mastered testing our microservices with Micronaut. We learned about the basics
    of unit testing in the Micronaut framework with JUnit 5, mock testing, service
    testing, the test suite that's available, and integration testing using test Docker
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132), *Handling
    Microservices Concerns*, we learned about handling microservices concerns. We
    learned about externalizing application configurations, distributed configuration
    management, documenting the Service API using Swagger, implementing service discovery,
    creating service discovery using Consul, implementing the API gateway service,
    and implementing fault tolerance mechanisms using circuit breakers and fallbacks.
    In [*Chapter 8*](B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146), *Deploying Microservices*,
    we learned about deploying microservices. We learned about building container
    artifacts, containerizing using Jib, deploying container artifacts, using `docker-compose`,
    and deploying a multi-service application.
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 9*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155), *Distributed
    Logging, Tracing, and Monitoring*, we learned about distributed logging, tracing,
    and monitoring. We also learned about the log producer, dispatcher, storage, and
    visualizer. We implemented Elasticsearch, Logstash, and Kibana. After, we set
    up ELK in Docker, integrated with some Micronaut microservices, and implemented
    distributed tracing in Micronaut. Finally, we set up Prometheus and Grafana in
    Docker. In [*Chapter 10*](B16585_10_Final_VK_ePub.xhtml#_idTextAnchor172), *IoT
    with Micronaut*, we learned about IoT with Micronaut. We learned about IoT, Alexa
    skills, space facts, utterances, intents, your first Alexa skills, the voice interaction
    model, integrating Micronaut with Alexa, AWS, AlexaFunction, and testing your
    AlexaFunction with Micronaut.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we learned about all the building blocks that are required to
    create an enterprise application using databases, web services, containers, deployments,
    testing, configuration, monitoring, event-driven architecture, security, and IoT.
    All the working examples we covered are available in this book's GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides a summary of all the chapters in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Bringing it all together – chapters roadmap'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – Bringing it all together – chapters roadmap
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have learned about the foundations of creating Micronaut microservices.
    Now that we are familiar with Micronaut, the necessary development tools, testing,
    databases, the event-driven architecture, distributed logging, tracing, monitoring,
    and IoT, we have all the necessary knowledge and skills to create enterprise microservices.
    We will learn about architecting enterprise microservices in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Architecting enterprise microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing enterprise microservices requires understanding and motivation
    from multiple stakeholders in the organization. You need to plan and analyze whether
    a microservice is the right fit for the problem at hand. If it is a fit, then
    you must design, develop, deploy, manage, and maintain the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you start using microservices, let''s understand when not to use them.
    Ask yourself the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Does your team know about microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is your business mature enough to adopt microservices?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have an Agile DevOps practice and infrastructure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have a scalable on-premises or cloud infrastructure?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have support to use modern tools and technology?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is your database ready to be decentralized?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you have support from all the stakeholders?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If your answer is yes to each of these questions, you can adapt and roll out
    microservices. The hardest part about rolling out microservices is your data and
    infrastructure. Traditionally, applications are designed to be big monolithic
    apps compared to decentralized, loosely coupled microservices. When you architect
    a microservice, you need to apply multiple techniques during the various phases.
    The following diagram illustrates the stages of rolling out enterprise microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Phases of architecting and rolling out enterprise microservices'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Phases of architecting and rolling out enterprise microservices
  prefs: []
  type: TYPE_NORMAL
- en: We'll look at each of these stages in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Planning and analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can create an architecture for an enterprise microservice, you need
    to analyze whether it is a good fit based on your requirements. You can also implement
    microservices for just a part of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Transitioning from a traditional monolithic architecture to microservices can
    be a time-consuming and complex process. However, if it is planned well, it can
    be rolled out seamlessly. Getting all stakeholders to support this is crucial,
    and this can be accomplished in the planning and analysis phase. Team members
    having knowledge of microservices is also vital and a critical success factor.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'During the design phase, you can use design patterns, as we learned in [*Chapter
    1*](B16585_01_Final_VK_ePub.xhtml#_idTextAnchor015), *Getting Started with Microservices
    Using Micronaut Framework*. Design patterns are reusable proven solutions for
    recurring business or technology problems. The following are the design patterns
    that we have explored so far in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Decomposition by business capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decomposing by domains/subdomains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API gateway pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chained microservices pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database per service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command query responsibility segregation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaker pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log aggregation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design patterns are continuously evolving. Always check for new patterns in
    the industry and evaluate whether they are a good fit for your solution. The next
    important area to consider when designing a microservice is security. We learned
    about securing microservices in [*Chapter 4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090),
    *Securing Microservices*. Here, we learned about evaluating authentication strategies,
    security rules, privilege-based access, OAuth, and SSL.
  prefs: []
  type: TYPE_NORMAL
- en: Other factors to consider when designing are to check for privacy-specific standards
    in the application such as **HIPAA** (short for **Health Insurance Portability
    and Accountability Act**), **General Data Protection Regulation** (**GDPR**),
    **Personal Information Protection and Electronic Documents Act** (**PIPEDA**),
    Bank Act, and so on. Check for encryption standards such as encryption at rest
    and encryption in transit, whether your data is encrypted before transmission,
    or whether your data has been stored and encrypted. Check for the security protocol
    version currently being used and apply the latest stable, supported version patches.
    The data retention strategy is another area to think about while designing a microservice.
    How long do you need to store the data for, and what is the archival strategy
    for data and log files? Also, some countries have regulations where you can store
    the data, check the requirements, and consider them while designing.
  prefs: []
  type: TYPE_NORMAL
- en: Develop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Development is an essential phase in implementing microservices. Always use
    the latest stable, supported version for development. Use the Micronaut framework
    to perform automated testing. Test at various levels, such as unit testing, service
    testing, and integration testing. In [*Chapter 6*](B16585_06_Final_VK_ePub.xhtml#_idTextAnchor120)*,
    Testing the Microservices*, we learned about testing microservices. Here, we learned
    that you should always emulate a real-world environment using containers or a
    cloud infrastructure, as well as using mocking and spying concepts during testing.
  prefs: []
  type: TYPE_NORMAL
- en: If you create a separate version control strategy for each service, the service
    can be stored in separate repositories with the required configuration and logs.
    Make sure that you synchronize your development, QA, UAT, and PROD environments
    and that you have an identical infrastructure across various stages of development.
    During development, think about backward compatibility for the microservices if
    you would like to support older versions of the microservices. Have a separate
    database for each microservice to attain their fullest potential.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to deployment, you should use automated tools and techniques and
    leverage rapid application deployment strategies. We learned about deploying microservices
    in [*Chapter 8*](B16585_08_Final_VK_ePub.xhtml#_idTextAnchor146), *Deploying Microservices*.
    Use tools such as containers, virtual machines, the cloud, Jib, and Jenkins, and
    use infrastructure efficiently – don't overallocate. Finally, ensure that you
    have a dedicated microservices DevOps strategy to facilitate **continuous integration**
    and **continuous delivery** (**CI/CD**).
  prefs: []
  type: TYPE_NORMAL
- en: Manage and maintain
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Maintaining multiple microservices is crucial and complex. You should monitor
    your application with distributed logging, tracing, and monitoring, as we learned
    in [*Chapter 9*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155), *Distributed
    Logging, Tracing, and Monitoring*. Use tools such as Elasticsearch, Logstash,
    Kibana, Prometheus, and Grafana to do so. Monitor the code base's health using
    Sonar DevSecOps and check for security vulnerabilities in the code periodically.
    You should always update the technology's version, operating system, and tools
    frequently. Also, monitor your CPU usage, memory footprint, and storage space
    in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, scale your infrastructure at runtime to avoid hardware overuse. We
    will discuss how to scale Micronaut in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to architect the microservices, let's understand more about
    Micronaut's OpenAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Micronaut's OpenAPI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: APIs are generic languages for machines to interact with each other. Having
    an API definition ensures there is a formalized specification in place. All APIs
    should have a specification, which improves development efficiency and reduces
    interaction problems. The specifications act as documentation that helps third-party
    developers or systems to understand the service easily. Micronaut supports OpenAPI
    (Swagger) YAML at compile time. We learned about this in [*Chapter 7*](B16585_07_Final_VK_ePub.xhtml#_idTextAnchor132),
    *Handling Microservices Concerns*. The **OpenAPI Initiative** (**OAI**) was previously
    known as the **Swagger Specification**. It is used to create machine-readable
    interface files for describing, producing, consuming, and visualizing RESTful
    web services. The **OAI** is now a consortium that promotes a vendor-neutral description
    format. OpenAPI is also called a *public API*, which is publicly made available
    to software developers and companies. Open APIs can be implemented with REST APIs
    or SOAP APIs. RESTful APIs are the most popular trending API format used in the
    industry. OpenAPI must have strong encryption and security in place. These APIs
    can be public or private (closed). A public OpenAPI can be accessed over the internet;
    however, a private OpenAPI can only be accessed in the intranet within a firewall
    or VPN service. Open APIs generate accurate documentation, such as all the required
    meta-information, reusable components, and endpoint details. There are several
    versions of the **OpenAPI Specification** (**OAS**); the current version is 3.1.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about OpenAPI at [https://www.openapis.org/](https://www.openapis.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned about Micronaut's OpenAPI, lets, understand scaling
    Micronaut in the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling Micronaut
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When designing and implementing an enterprise application, the ability to scale
    needs to be planned. One of the biggest advantages of using microservices is scalability.
    Scaling Micronaut services is a crucial factor by design. It is more than just
    handling volume – it is about scaling with minimal effort involved. Micronaut
    makes it easier to identify scaling problems and then resolve challenges at each
    microservice level. Micronaut microservices are single-purpose applications that
    can be assembled to build large enterprise-scale software systems. Scaling at
    runtime is a vital factor in modernizing the enterprise.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of scaling: *x*-axis, *y*-axis, and *z*-axis scaling.
    The following diagram illustrates the x-axis (horizontal scaling) and y-axis (vertical
    scaling):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Vertical scaling versus horizontal scaling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Vertical scaling versus horizontal scaling
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal scaling is also called x-axis scaling. In horizontal scaling, we
    scale by creating new servers or virtual machines; the entire infrastructure for
    the service is scaled. For example, if 10 services are running in a virtual machine,
    we need to add a virtual machine with 10 services if one service requires additional
    capacity. If you analyze this scenario, there will be unused server capacity as
    only one service required an additional CPU instead of 10\. However, this type
    of scaling provides unlimited scaling of the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vertical scaling is also called y-axis scaling. In vertical scaling, we scale
    by adding capacity to the existing servers. Capacity is scaled by adding additional
    CPU, storage, and RAM. For example, if 10 services are running in a virtual machine,
    if one service requires additional capacity such as RAM and CPU, we need to add
    extra RAM and CPU to the same virtual machine. This is the fundamental difference
    between horizontal and vertical scaling. However, vertical scaling has a limitation:
    it cannot scale beyond a specific limit. The following diagram illustrates the
    x-axis (horizontal scaling) and z-axis (microservices horizontal scaling):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Traditional horizontal scaling versus microservices horizontal
    scaling'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Traditional horizontal scaling versus microservices horizontal
    scaling
  prefs: []
  type: TYPE_NORMAL
- en: Microservices horizontal scaling is also known as z-axis scaling. This is almost
    the same as traditional horizontal scaling. For example, if 10 services are running
    in a microservice container environment, if one service requires additional capacity,
    we need to add one microservice container environment instead of 10\. If you analyze
    this scenario, you will see that this is the most optimal use of the available
    capacity. This type of scaling allows you to scale the infrastructure as many
    times as you like and is the most cost-efficient method. Its performance is a
    lot better than in a non-scaled environment. You can scale with containers and
    also with cloud infrastructure. The capabilities of autoscaling are very powerful
    and come in handy for microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have learned about scaling microservices, let's implement the enterprise
    microservices with all the features we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Micronaut's microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's implement what we have learned so far in this chapter. You can use
    the code in this chapter's GitHub repository. We will use the four projects we've
    covered in this book – pet clinic, pet owner, pet reviews, and concierge. We will
    also be using a Zipkin container image for distributed tracing, Prometheus for
    metrics and monitoring, and the `elk` container image for Elasticsearch, Logstash,
    and Kibana.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the list of projects in this book''s GitHub
    repository that we will be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – GitHub projects for our implementation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.5_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – GitHub projects for our implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to set up Keycloak. Please refer to [*Chapter 4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090),
    *Securing Microservices*, the *Setting up Keycloak as the identity provider* and
    *Creating a client on the Keycloak server* sections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following command can be run to create the Keycloak Docker image:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once Keycloak is up and running, the client secret key needs to be copied from
    the `pet clinic` user and clients should be set up already. Please refer to [*Chapter
    4*](B16585_04_Final_VK_ePub.xhtml#_idTextAnchor090), *Securing Microservices*,
    for more information.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the timeout settings in Keycloak. Go to the **Keycloak** console | **Clients**
    | **Settings** | **Advanced Settings**. **15 Minutes** is recommended for testing
    the sample code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following screen illustrates the Keycloak **Access** **Token Lifespan**
    location:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Keycloak Access Token Lifespan'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.8_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.8 – Keycloak Access Token Lifespan
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The secret needs to be copied so that it can be replaced in the `pet-clinic`,
    `pet-owner`, `pet-clinic-reviews`, and `pet-clinic-concierge` projects. The YAML
    application configuration file, `client-secret`, needs to be updated from the
    Keycloak secret, as shown in the preceding screenshot. The following are the files
    that must be updated:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following screenshot illustrates a sample `.yaml` file configuration where
    the client secret ID needs to be replaced:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Keycloak portal – client secret in the application YAML file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.9_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.9 – Keycloak portal – client secret in the application YAML file
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once every client secret has been updated, execute the Maven Docker build in
    all four projects (`pet-clinic-concierge`, `pet-clinic-reviews`, `pet-clinic`,
    and `pet-owner`). The following Maven command creates a Docker image for each
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Check the Docker setting resources. You need four CPUs and at least 6 GB of
    memory. Go to the **Docker** settings | **Resources** | **Advanced**:![Figure
    11.10 – Docker CPU and memory settings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_11.10_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.10 – Docker CPU and memory settings
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step, after creating the Docker images, is to create `docker-compose`
    for Kafka, Zipkin, Prometheus, and ELK. Execute the following command in a terminal
    or console to create the Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is how the file works:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Docker Compose – Zipkin'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.12_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is how the file works:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Docker Compose – Prometheus'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.13_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is how the file works:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Docker Compose – ELK'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.14_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, this is how the file works:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Docker Compose Micronaut pet clinic'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/Figure_11.15_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.15 – Docker Compose Micronaut pet clinic
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the security configuration protects all the projects using Keycloak,
    except `pet-clinic-reviews`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`pet-clinic-concierge`: Protected using Keycloak'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic`: Protected using Keycloak'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-owner`: Protected using Keycloak'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-reviews`: Unprotected'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Before testing the applications, check whether all the applications are running
    in the Docker container. The following screenshot illustrates the application
    running in a Docker container successfully:![Figure 11.16 – Docker container running
    all required applications
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_11.16_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.16 – Docker container running all required applications
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that all the projects are running in Docker, let''s test the URL''s integration.
    You can call all the services from the API gateway, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pet-owner`: `http://localhost:32584/api/owners`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic`: `http://localhost:32584/api/vets`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pet-clinic-reviews`: `http://localhost:32584/api/vet-reviews `'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once you have the apps running in Docker, you need to obtain the security token
    by invoking the following API on Keycloak:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PUT_CLIENT_SECRET_HERE` must be replaced with the Keycloak credentials secret.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, this is what the request in the console looks like:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.17 – curl request to get the JWT'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.17_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.17 – curl request to get the JWT
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then check that the `curl` request returns an access token:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – curl response JWT'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.18_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.18 – curl response JWT
  prefs: []
  type: TYPE_NORMAL
- en: Copy and format the JSON response using a JSON formatter. The `access_token`
    attribute value from the formatter response must be copied, and this value will
    be passed as a JWT, shown as follows:![Figure 11.19 – curl response JWT
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_11.19_B16585.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 11.19 – curl response JWT
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you receive a response from `curl`, you can copy the `access_token` value.
    `access_token` can be passed to call the services in the request header, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.20 – REST response for the vets API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.20_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.20 – REST response for the vets API
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we must test all the application URLs and their integration using the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:32584/`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8500/ui/dc1/services`. This will launch Consul as shown in
    the screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.21 – REST response for the vets API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.21_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.21 – REST response for the vets API
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:5601/app/kibana`. This will launch the Kibana logging portal
    as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Kibana logging portal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.22_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.22 – Kibana logging portal
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Kibana default username is `elastic` and password is `changeme`.
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:3000/?orgId=1`. This will launch the Grafana monitoring tool.
    Detailed steps to configure the dashboard can be found in [*Chapter 9*](B16585_09_Final_VK_ePub.xhtml#_idTextAnchor155),
    *Distributed Logging, Tracing, and Monitoring*:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Distributed monitoring using Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.23_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.23 – Distributed monitoring using Grafana
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus, default username is `admin` and password is `pass`.
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:9411/zipkin/`. The following screenshot illustrates the Zipkin
    user interface for distributed tracing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Distributed tracing using Zipkin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.24_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.24 – Distributed tracing using Zipkin
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8888/auth/` is the identity provider that will launch Keycloak
    which is the identity provider.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:9100/`. Here you can view the cluster with Kafdrop:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.25 – Kafdrop Cluster view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.25_B16585.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.25 – Kafdrop Cluster view
  prefs: []
  type: TYPE_NORMAL
- en: Overall, we have tested all the features of the integration from the gateway
    to distributed monitoring, tracking, logging, and searching. With this, we have
    completed this chapter. In this section, we learned how to implement microservices
    in Micronaut while in production.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we brought everything we'd learned about in the previous chapters
    together. Then, we dived into architecting enterprise-grade microservices. We
    also learned about scaling microservices, the different types of scaling, and
    their advantages.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter enhanced your Micronaut microservices knowledge so that you can
    make production-ready applications. It has equipped you with all the necessary
    skills and expertise. We started the journey with the basics of microservices,
    and now we have the knowledge to create enterprise-grade microservices with Micronaut.
    We hope you enjoyed the journey of learning with us.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name a few factors you should consider when architecting microservices.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a few design patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What factors should you consider during the design phase of microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What factors should you consider during the development phase of microservices?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a few tools that are used in the deployment phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name a few tools that are used in the manage and maintain phase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the different types of scaling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What type of scaling is used in a microservices architecture?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
