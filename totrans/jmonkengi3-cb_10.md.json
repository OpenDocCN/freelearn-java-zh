["```java\nBulletAppState bulletAppState = new BulletAppState();\nstateManager.attach(bulletAppState);\n```", "```java\nPhysicsTestHelper.createPhysicsTestWorldSoccer(rootNode, assetManager, bulletAppState.getPhysicsSpace());\n```", "```java\nint numChannels = model.getControl(AnimControl.class).getNumChannels();\nfor(int i = 0; i < numChannels; i++){\n  ((HashMap<Integer, AnimChannel>)s).put(i, model.getControl(AnimControl.class).getChannel(i));\n}\n```", "```java\nIndex: AnimationEvent.java\n===================================================================\nâ€” AnimationEvent.java    (revision 11001)\n+++ AnimationEvent.java    (working copy)\n@@ -221,6 +221,24 @@\n initialDuration = model.getControl(AnimControl.class).getAnimationLength(animationName);\n this.channelIndex = channelIndex;\n}\n+\n+/**\n+ * creates an animation event\n+ *\n+ * @param model the model on which the animation will be played\n+ * @param animationName the name of the animation to play\n+ * @param channelIndex the index of the channel default is 0\\. Events on the\n+ * @param blendTime the time during the animation are going to be blended\n+ * same channelIndex will use the same channel.\n+ */\n+public AnimationEvent(Spatial model, String animationName, LoopMode loopMode, int channelIndex, float blendTime) {\n+this.model = model;\n+this.animationName = animationName;\n+this.loopMode = loopMode;\n+initialDuration = model.getControl(AnimControl.class).getAnimationLength(animationName);\n+this.channelIndex = channelIndex;\n+this.blendTime = blendTime;\n+}\n\n/**\n* creates an animation event\n@@ -264,11 +282,16 @@\nObject s = cinematic.getEventData(MODEL_CHANNELS, model);\nif (s == null) {\ns = new HashMap<integer , AnimChannel>();\n+int numChannels = model.getControl(AnimControl.class).getNumChannels();\n+for(int i = 0; i < numChannels; i++){\n+ ((HashMap<Integer, AnimChannel>)s).put(i, model.getControl(AnimControl.class).getChannel(i));\n+}\ncinematic.putEventData(MODEL_CHANNELS, model, s);\n }\n\nMap</integer><integer , AnimChannel> map = (Map</integer><integer , AnimChannel>) s;\nthis.channel = map.get(channelIndex);\n+\nif (this.channel == null) {\nif (model == null) {\n                     //the model is null we try to find it according to the name\n```", "```java\npublic class ImageGenerator {\n\n  public static void generateImage(float[][] terrain){\n    int size = terrain.length;\n    int grey;\n\n    BufferedImage img = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n    for(int y = 0; y < size; y++){\n      for(int x = 0; x < size; x++){\n        double result = terrain[x][y];\n\n        grey = (int) (result * 255);\n        int color = (grey << 16) | (grey << 8) | grey;\n        img.setRGB(x, y, color);\n\n      }\n    }\n\n    try {\n      ImageIO.write(img, \"png\", new File(\"assets/Textures/heightmap.png\"));\n    } catch (IOException ex) {\n          Logger.getLogger(NoiseMapGenerator.class.getName()).log(Level.SEVERE, null, ex);\n      }\n    }\n}\n```", "```java\npublic class CellUtil {\n\n  private static int[][] directions = new int[][]{{0,-1},{1,-1},{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1}};\n  public static int getDirection(int x, int y){\n    witch(x){\n      case 1:\n      switch(y){\n        case -1:\n        return 1;\n        case 0:\n        return 2;\n        case 1:\n        return 3;\n      }\n      break;\n      case -1:\n      switch(y){\n        case -1:\n        return 7;\n        case 0:\n        return 6;\n        case 1:\n        return 5;\n      }\n      break;\n      case 0:\n      switch(y){\n        case -1:\n        return 0;\n        case 0:\n        return -1;\n        case 1:\n        return 4;\n      }\n      break;\n    }\n    return -1;\n  }\n\n  public static int[] getDirection(int dir){\n   return directions[dir];\n  }\n}\n```"]