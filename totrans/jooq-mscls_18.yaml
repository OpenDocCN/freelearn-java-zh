- en: '*Chapter 14*: Derived Tables, CTEs, and Views'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第14章*：派生表、CTE和视图'
- en: Derived tables, **CTEs**, and views are important players in the SQL context.
    They're useful to organize and optimize the reuse of long and complex queries
    – typically, base queries and/or expensive queries (in performance terms), and
    to improve readability by breaking down the code into separate steps. Mainly,
    they link a certain query to a name, possibly stored in the schema. In other words,
    they hold the query text, which can be referenced and executed via the associated
    name when needed. If results materialize, then the database engine can reuse these
    cached results, otherwise, they have to be recomputed at each call.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 派生表、**CTE**和视图是SQL环境中的重要角色。它们有助于组织和优化长而复杂的查询的重用——通常是基查询和/或昂贵的查询（在性能方面），并通过将代码分解成单独的步骤来提高可读性。主要来说，它们将某个查询与一个名称链接起来，该名称可能存储在模式中。换句话说，它们持有查询文本，当需要时可以通过关联的名称引用和执行这些文本。如果结果具体化，那么数据库引擎可以重用这些缓存的查询结果，否则，每次调用时都必须重新计算。
- en: 'Derived tables, CTEs, and views have specific particularities (including database
    vendor-specific options), and choosing between them is a decision that strongly
    depends on the use case, the involved data and queries, the database vendor and
    optimizer, and so on. As usual, we handle this topic from the jOOQ perspective,
    so our agenda includes the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 派生表、CTE和视图具有特定的特性（包括数据库供应商特定的选项），选择它们取决于用例、涉及的数据和查询、数据库供应商和优化器等。像往常一样，我们从jOOQ的角度处理这个话题，因此我们的议程包括以下内容：
- en: Derived tables
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 派生表
- en: CTEs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CTE
- en: Views
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: Let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14)。
- en: Derived tables
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 派生表
- en: Have you ever used a nested `SELECT` (a `SELECT` in a table expression)? Of
    course, you have! Then, you've used a so-called *derived table* having the scope
    of the statement that creates it. Roughly, a derived table should be treated in
    the same way as a base table. In other words, it is advisable to give it and its
    columns meaningful names via the `AS` operator. This way, you can reference the
    derived table without ambiguity, and you'll respect the fact that most databases
    don't support unnamed (unaliased) derived tables.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经使用过嵌套的 `SELECT`（在表表达式中的 `SELECT`）？当然，你已经使用了！那么，你已经使用了所谓的*派生表*，其作用域是创建它的语句。大致来说，派生表应该像基表一样处理。换句话说，建议通过
    `AS` 操作符给它及其列赋予有意义的名称。这样，你可以无歧义地引用派生表，并且你会尊重这样一个事实：大多数数据库不支持未命名的（未别名的）派生表。
- en: 'jOOQ allows us to transform any `SELECT` in a derived table via `asTable()`,
    or its synonym `table()`. Let''s have a simple example starting from this `SELECT`:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ允许我们通过`asTable()`或其同义词`table()`将派生表中的任何`SELECT`转换为表。让我们从一个简单的`SELECT`开始：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is not a derived table, but it can become one as follows (these two are
    synonyms):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个派生表，但它可以按照以下方式成为派生表（这两个是同义词）：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In jOOQ, we can further refer to this derived table via the local variable `t`.
    It is convenient to declare `t` as `Table<?>` or to simply use `var`. But, of
    course, you can explicitly specify the data types as well. Here, `Table<Record1<Integer>>`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，我们可以通过局部变量`t`进一步引用这个派生表。将`t`声明为`Table<?>`或简单地使用`var`是很方便的。但当然，你也可以显式指定数据类型。这里，`Table<Record1<Integer>>`。
- en: Important Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `org.jooq.Table` type can reference a derived table.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`org.jooq.Table`类型可以引用派生表。'
- en: 'Now, the resulting `t` is an unnamed derived table since there is no explicit
    alias associated with it. Let''s see what happens when we select something from
    `t`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，结果`t`是一个未命名的派生表，因为它没有与它关联的显式别名。让我们看看当我们从`t`中选择某些内容时会发生什么：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'jOOQ generates the following SQL (we''ve arbitrarily chosen the PostgreSQL
    dialect):'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ生成了以下SQL（我们任意选择了PostgreSQL方言）：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: jOOQ detected the missing alias for the derived table, therefore it generated
    one (`alias_30260683`) on our behalf.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ检测到派生表缺少别名，因此它代表我们生成了一个别名（`alias_30260683`）。
- en: Important Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: We earlier iterated that most database vendors require an explicit alias for
    every derived table. But, as you just saw, jOOQ allows us to omit such aliases,
    and when we do, jOOQ will generate one on our behalf to guarantee that the generated
    SQL is syntactically correct. The generated alias is a random number suffixed
    by `alias_`. This alias should not be referenced explicitly. jOOQ will use it
    internally to render a correct/valid SQL.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，大多数数据库供应商要求每个派生表都有一个显式别名。但是，正如你所看到的，jOOQ允许我们省略这样的别名，并且当我们这样做时，jOOQ会代表我们生成一个以确保生成的SQL在语法上是正确的。生成的别名是一个以`alias_`后缀的随机数字。这个别名不应被显式引用。jOOQ将内部使用它来生成正确/有效的SQL。
- en: 'Of course, if we explicitly specify an alias then jOOQ will use it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果我们明确指定了一个别名，那么jOOQ将会使用它：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The SQL corresponding to PostgreSQL is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 对应PostgreSQL的SQL如下所示：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here is another example using the `values()` constructor:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`values()`构造函数的另一个示例：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Typically, we explicitly specify an alias when we also reference it explicitly,
    but there is nothing wrong in doing it every time. For instance, jOOQ doesn''t
    require an explicit alias for the following inlined derived table, but there is
    nothing wrong with adding it:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们明确引用它时，我们会明确指定一个别名，但每次都这样做也没有什么不妥。例如，jOOQ对于以下内联派生表不需要显式别名，但添加它也没有什么问题：
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: jOOQ relies on the `t` alias instead of generating one.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ依赖于`t`别名而不是生成一个。
- en: Extracting/declaring a derived table in a local variable
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在局部变量中提取/声明派生表
- en: jOOQ allows us to extract/declare a derived table outside the statement that
    used it, and, in such a case, its presence and role are better outlined than in
    the case of nesting it in a table expression.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ允许我们在使用它的语句之外提取/声明派生表，在这种情况下，它的存在和角色比在表表达式中嵌套它时更加清晰。
- en: Extracting/declaring a derived table in a local variable can be useful if we
    need to refer to the derived table in multiple statements, we need it as part
    of a dynamic query, or we just want to decongest a complex query.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在多个语句中引用派生表，或者需要将其作为动态查询的一部分，或者我们只是想减轻复杂查询的负担，那么在局部变量中提取/声明派生表可能很有用。
- en: 'For instance, consider the following query:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下查询：
- en: '[PRE18]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The highlighted subquery represents an inlined derived table. jOOQ automatically
    associates to it an alias and uses that alias to reference the columns `product_id`
    and `price_each` in the outer `SELECT`. Of course, we can provide an explicit
    alias as well, but this is not required:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的子查询代表一个内联派生表。jOOQ会自动为其关联一个别名，并使用该别名在外层`SELECT`中引用`product_id`和`price_each`列。当然，我们也可以提供显式别名，但这不是必需的：
- en: '[PRE25]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This time, jOOQ relies on the `t` alias instead of generating one. Next, let''s
    add this subquery to another query as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，jOOQ依赖于`t`别名而不是生成一个。接下来，让我们将这个子查询添加到另一个查询中，如下所示：
- en: '[PRE33]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This query fails at compilation time because the reference to the `product_id`
    column in `on(field(name("product_id")).eq(PRODUCT.PRODUCT_ID))` is ambiguous.
    jOOQ automatically associates a generated alias to the inlined derived table,
    but it cannot decide whether the `product_id` column comes from the derived table
    or from the `PRODUCT` table. Resolving this issue can be done explicitly by adding
    and using an alias for the derived table:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这个查询在编译时失败，因为`on(field(name("product_id")).eq(PRODUCT.PRODUCT_ID))`中对`product_id`列的引用是模糊的。jOOQ会自动将生成的别名关联到内联派生表，但它无法确定`product_id`列来自派生表还是来自`PRODUCT`表。可以通过显式添加和使用派生表的别名来解决这个问题：
- en: '[PRE41]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Now, jOOQ relies on the `t` alias, and the ambiguity issues have been resolved.
    Alternatively, we can explicitly associate a unique alias only to the `ORDERDETAIL.PRODUCT_ID`
    field as `select(ORDERDETAIL.PRODUCT_ID.as("pid")…`, and reference it via this
    alias as `field(name("pid"))…`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，jOOQ依赖于`t`别名，歧义问题已经解决。或者，我们可以仅将唯一的别名`ORDERDETAIL.PRODUCT_ID`字段显式关联为`select(ORDERDETAIL.PRODUCT_ID.as("pid")…`，并通过这个别名引用它作为`field(name("pid"))…`。
- en: 'At this point, we have two queries with the same inline derived table. We can
    avoid code repetition by extracting this derived table in a Java local variable
    before using it in these two statements. In other words, we declare the derived
    table in a Java local variable, and we refer to it in the statements via this
    local variable:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有两个具有相同内联派生表的查询。我们可以通过在两个语句中使用它之前在Java局部变量中提取这个派生表来避免代码重复。换句话说，我们在Java局部变量中声明派生表，并通过这个局部变量在语句中引用它：
- en: '[PRE51]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: So, `t` is our derived table. Running this snippet of code doesn't have an effect
    on and doesn't produce any SQL. jOOQ evaluates `t` only when we reference it in
    queries, but in order to be evaluated, `t` must be declared before the queries
    that use it. This is just Java; we can use a variable only if it was declared
    upfront. When a query uses `t` (for instance, via `t.field()`), jOOQ evaluates
    `t` and renders the proper SQL.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can use `t` to rewrite our queries as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: But, why this time do we need explicit types in `on(t.field(name("price_each"),
    BigDecimal.class)` and `.on(t.field(name("product_id"), Long.class)`? The answer
    is that the fields cannot be dereferenced from `t` in a type-safe way. Therefore
    it is our job to specify the proper data types. This is a pure Java issue, and
    has nothing to do with SQL!
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'But, there is a trick that can help us to keep type safety and reduce verbosity,
    and that trick consists of using the `<T> Field<T> field(Field<T> field)` method.
    The best explanation of this method is given by the jOOQ documentation itself.
    The following figure is a screenshot from the jOOQ official documentation:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The <T> Field<T> field(Field<T> field) method documentation'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_14.1.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – The <T> Field<T> field(Field<T> field) method documentation
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression `t.field(name("price_each"), …)` indirectly refers to the field
    `ORDERDETAIL.PRICE_EACH`, and `t.field(name("product_id"), …)` indirectly refers
    to the field `ORDERDETAIL.PRODUCT_ID`. Therefore, based on the previous figure,
    we can re-write our queries in a type-safe manner as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Cool! Now, we can reuse `t` in a "type-safe" manner! However, keep in mind that
    <T> Field<T> field(Field<T> field) just looks type safe. It's actually as good
    as an unsafe cast in Java, because the lookup only considers the identifier, not
    the type. Nor does it coerce the expression. This is why we have the quotes around
    type-safe.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that uses two extracted `Field` in the extracted derived
    table and the query itself:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Here, `ord` and `avg` are rendered unqualified (without being prefixed with
    the derived table alias). But, thanks to `<T> Field<T> field(Field<T> field)`,
    we can obtain the qualified version:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, let''s see an example that uses `fields()` and `asterisk()` to refer
    to all columns of a derived table extracted in a local variable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Notice that extracting a subquery is not mandatory for it to be transformed
    in a `Table`. There are cases when extracting it as a simple `SELECT` is all you
    need. For instance, when the subquery isn''t a derived table, we can do this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'This subquery (which is not a derived table) can be extracted locally and used
    like this:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'There is no need for an alias (jOOQ knows that this is not a derived table
    and no alias is needed therefore it will not generate one) and no need to transform
    it into a `Table`. Actually, jOOQ is so flexible that it allows us to do even
    this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Don''t worry, jOOQ will not ask you to transform `t` into a `Table`. jOOQ infers
    that this is a derived table and associates and references a generated alias as
    expected in the rendered SQL. So, as long as you don''t want to associate an explicit
    alias to the derived table and jOOQ doesn''t specifically require a `Table` instance
    in your query, there is no need to transform the extracted `SELECT` into a `Table`
    instance. When you need a `Table` instance but not an alias for it, just use the
    `asTable()` method without arguments:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 请放心，jOOQ 不会要求您将 `t` 转换为 `Table`。jOOQ 推断这是一个派生表，并按照预期在渲染的 SQL 中关联和引用一个生成的别名。因此，只要您不想将显式别名关联到派生表，并且
    jOOQ 在您的查询中不特别要求 `Table` 实例，就没有必要将提取的 `SELECT` 转换为 `Table` 实例。当您需要一个 `Table` 实例但不需要为其指定别名时，只需使用不带参数的
    `asTable()` 方法：
- en: '[PRE140]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: You can check out these examples along with others in *DerivedTable*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看这些示例以及其他在 *DerivedTable* 中的示例。
- en: Exploring Common Table Expressions (CTEs) in jOOQ
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 jOOQ 中的常见表表达式 (CTEs)
- en: CTEs are represented by the SQL-99 `WITH` clause. You already saw several examples
    of CTE in previous chapters, for instance, in [*Chapter 13*](B16833_13.xhtml#_idTextAnchor245),
    *Exploiting SQL Functions*, you saw a CTE for computing z-scores.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: CTEs 通过 SQL-99 的 `WITH` 子句来表示。您已经在之前的章节中看到了几个 CTE 的例子，例如，在 [*第 13 章*](B16833_13.xhtml#_idTextAnchor245)
    *利用 SQL 函数* 中，您看到了一个用于计算 z 分数的 CTE。
- en: Roughly, via CTEs, we factor out the code that otherwise should be repeated
    as derived tables. Typically, a CTE contains a list of derived tables placed in
    front of a `SELECT` statement in a certain order. The order is important because
    these derived tables are created conforming to this order and a CTE element can
    reference only prior CTE elements.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 大致来说，通过 CTEs，我们将本应作为派生表重复的代码提取出来。通常，一个 CTE 包含一系列派生表，这些表按照一定顺序放置在 `SELECT` 语句之前。顺序很重要，因为这些派生表是按照这个顺序创建的，并且一个
    CTE 元素只能引用之前的 CTE 元素。
- en: Basically, we distinguish between regular (non-recursive) CTEs and recursive
    CTEs.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们区分常规（非递归）CTEs 和递归 CTEs。
- en: Regular CTEs
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常规 CTEs
- en: A regular CTE associates a name to a temporary result set that has the scope
    of a statement such as `SELECT`, `INSERT`, `UPDATE`, `DELETE`, or `MERGE` (CTEs
    for DML statements are very useful vendor-specific extensions). But, a derived
    table or another type of subquery can have its own CTE as well, such as `SELECT
    x.a FROM (WITH t (a) AS (SELECT 1) SELECT a FROM t) x`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 常规 CTE 将名称与具有类似于 `SELECT`、`INSERT`、`UPDATE`、`DELETE` 或 `MERGE`（DML 语句的 CTE 是非常有用的特定供应商扩展）语句作用域的临时结果集相关联。但是，派生表或其他类型的子查询也可以有自己的
    CTE，例如 `SELECT x.a FROM (WITH t (a) AS (SELECT 1) SELECT a FROM t) x`。
- en: 'The basic syntax of a CTE (for the exact syntax of a certain database vendor,
    you should consult the documentation) is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: CTE 的基本语法如下（有关特定数据库供应商的确切语法，请参阅文档）：
- en: '[PRE144]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: In jOOQ, a CTE is represented by the `org.jooq.CommonTableExpression` class
    and extends the commonly used `org.jooq.Table`, therefore a CTE can be used everywhere
    a `Table` can be used. The `CTE_name` represents the name used later in the query
    to refer to the CTE and, in jOOQ, can be specified as the argument of the method
    `name()` or `with()`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在 jOOQ 中，CTE 由 `org.jooq.CommonTableExpression` 类表示，并扩展了常用的 `org.jooq.Table`，因此
    CTE 可以在任何可以使用 `Table` 的地方使用。`CTE_name` 表示在查询中稍后用于引用 CTE 的名称，在 jOOQ 中，可以作为 `name()`
    或 `with()` 方法的参数指定。
- en: The `column_name` marks the spot for a list of comma-separated columns that
    comes after the `CTE_name`. The number of columns specified here, and the number
    of columns defined in the `CTE_definition` must be equal. In jOOQ, when the `name()`
    method is used for `CTE_name`, this list can be specified via the `fields()` method.
    Otherwise, it can be specified as part of the `with()` arguments after the `CTE_name`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`column_name` 标记了 `CTE_name` 后跟的逗号分隔的列列表的位置。这里指定的列数必须与 `CTE_definition` 中定义的列数相等。在
    jOOQ 中，当使用 `name()` 方法为 `CTE_name` 时，此列表可以通过 `fields()` 方法指定。否则，它可以作为 `with()`
    参数的一部分在 `CTE_name` 之后指定。'
- en: The `AS` keyword is rendered in jOOQ via the `as(Select<?> select)` method.
    So, the argument of `as()` is the `CTE_definition`. Starting with jOOQ 3.15, the
    CTE `as(ResultQuery<?>)` method accepts a `ResultQuery<?>` to allow for using
    `INSERT ... RETURNING` and other `DML ... RETURNING` statements as CTEs in PostgreSQL.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`AS` 关键字通过 `as(Select<?> select)` 方法在 jOOQ 中表示。因此，`as()` 的参数是 `CTE_definition`。从
    jOOQ 3.15 版本开始，`as(ResultQuery<?>)` 方法接受一个 `ResultQuery<?>`，允许在 PostgreSQL 中将
    `INSERT ... RETURNING` 和其他 `DML ... RETURNING` 语句作为 CTE 使用。'
- en: Finally, we have the SQL that uses the CTE and references it via `CTE_name`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有使用CTE并通过`CTE_name`引用它的SQL。
- en: 'For instance, the following CTE named `cte_sales` computes the sum of sales
    per employee:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下名为`cte_sales`的CTE计算每个员工的销售额总和：
- en: '[PRE148]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: This is the CTE declaration that can be referenced via the local variable `t`
    in any future SQL queries expressed via jOOQ. Running this snippet of code now
    doesn't execute the `SELECT` and doesn't produce any effect. Once we use `t` in
    a SQL query, jOOQ will evaluate it to render the expected CTE. That CTE will be
    executed by the database.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以通过jOOQ中的局部变量`t`引用的CTE声明。现在运行此代码片段不会执行`SELECT`也不会产生任何效果。一旦我们在SQL查询中使用`t`，jOOQ将评估它以渲染预期的CTE。该CTE将由数据库执行。
- en: Exactly as in the case of declaring derived tables in local variables, in the
    case of CTE, the fields cannot be dereferenced from `t` in a type-safe way, therefore
    it is our job to specify the proper data types in the queries that use the CTE.
    Again, let me point out that this is a pure Java issue, and has nothing to do
    with SQL!
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在局部变量中声明派生表的情况下一样，在CTE的情况下，字段不能以类型安全的方式从`t`中解引用，因此我们需要在使用CTE的查询中指定适当的数据类型。再次强调，这是一个纯Java问题，与SQL无关！
- en: 'Lukas Eder shared this: *Regarding the lack of type safety when dereferencing
    CTE or derived table fields: This is often an opportunity to rewrite the SQL statement
    again to something that doesn''t use a CTE. On Stack Overflow, I''ve seen many
    cases of questions where the person tried to put *everything* in several layers
    of confusing CTE, when the actual factored-out query could have been *much* easier
    (for example, if they knew window functions, or the correct logical order of operations,
    and so on). Just because you can use CTEs, doesn''t mean you have to use them
    *everywhere**.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Lukas Eder分享了以下内容：*关于在解引用CTE或派生表字段时缺乏类型安全：这通常是重新编写SQL语句的机会，使其不再使用CTE。在Stack
    Overflow上，我看到了许多案例，其中人们试图将*所有内容*放入多层令人困惑的CTE中，而实际分解的查询可能要简单得多（例如，如果他们知道窗口函数，或正确的操作逻辑顺序等）。仅仅因为你可以使用CTE，并不意味着你必须在*每个地方*都使用它们。
- en: 'So, here is a usage of our CTE, `t`, for fetching the employee having the biggest
    sales:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里是一个使用我们的CTE（公用表表达式），`t`，来获取销售额最高的员工的例子：
- en: '[PRE152]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'By extracting the CTE fields as local variables, we can rewrite our CTE declaration
    like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将CTE字段提取为局部变量，我们可以将我们的CTE声明重写如下：
- en: '[PRE159]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'The SQL that uses this CTE is as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此CTE的SQL如下：
- en: '[PRE164]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'And, of course, relying on `<T> Field<T> field(Field<T> field)`, introduced
    in the previous section, can help us to write a type-safe CTE as follows:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，依靠上一节中引入的`<T> Field<T> field`，我们可以编写如下类型安全的CTE：
- en: '[PRE171]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'As an alternative to the previous explicit CTE, we can write an inline CTE
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 作为之前显式CTE的替代，我们可以编写如下内联CTE：
- en: '[PRE176]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'By arbitrarily choosing the PostgreSQL dialect, we have the following rendered
    SQL for all the previous CTEs:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过任意选择PostgreSQL方言，我们为所有之前的CTE渲染了以下SQL：
- en: '[PRE186]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: You can check these examples in the bundled code named *CteSimple*. So far,
    our CTE is used only in `SELECT` statements. But, CTE can be used in DML statements
    such as `INSERT`, `UPDATE`, `DELETE`, and `MERGE` as well.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在名为*CteSimple*的捆绑代码中检查这些示例。到目前为止，我们的CTE仅用于`SELECT`语句。但是，CTE也可以用于DML语句，如`INSERT`、`UPDATE`、`DELETE`和`MERGE`。
- en: CTE as SELECT and DML
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为SELECT和DML的CTE
- en: 'jOOQ supports using CTE in `INSERT`, `UPDATE`, `DELETE`, and `MERGE`. For instance,
    the following snippet of code inserts into a brand-new table a random part from
    the `SALE` table:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ支持在`INSERT`、`UPDATE`、`DELETE`和`MERGE`中使用CTE。例如，以下代码片段将随机部分从`SALE`表插入到一个全新的表中：
- en: '[PRE193]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'Here is another example that updates the prices of the products (`PRODUCT.BUY_PRICE`)
    to the maximum order prices (`max(ORDERDETAIL.PRICE_EACH)`) via a CTE used in
    `UPDATE`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个例子，它通过在`UPDATE`中使用CTE将产品的价格（`PRODUCT.BUY_PRICE`）更新为最大订单价格（`max(ORDERDETAIL.PRICE_EACH)`）：
- en: '[PRE203]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: You can practice these examples along with others including using CTE in `DELETE`
    and `MERGE` in *CteSelectDml*. Next, let's see how we can express a CTE as DML
    in PostgreSQL.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以练习这些示例，包括在*CteSelectDml*中使用CTE在`DELETE`和`MERGE`，以及其他示例。接下来，让我们看看如何在PostgreSQL中将CTE作为DML来表示。
- en: A CTE as DML
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 作为DML的CTE
- en: 'Starting with jOOQ 3.15, the CTE `as(ResultQuery<?>)` method accepts a `ResultQuery<?>`
    to allow for using `INSERT ... RETURNING` and other `DML … RETURNING` statements
    as CTE in PostgreSQL. Here is a simple CTE storing the returned `SALE_ID`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'Let''s write a CTE that updates the `SALE.REVENUE_GROWTH` of all employees
    having a null `EMPLOYEE.COMMISSION`. All the updated `SALE.EMPLOYEE_NUMBER` are
    stored in the CTE and used further to insert in `EMPLOYEE_STATUS` as follows:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: You can check out more examples in the bundled code named *CteDml* for PostgreSQL.
    Next, let's see how we can embed plain SQL in a CTE.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: CTEs and plain SQL
  id: totrans-317
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using plain SQL in CTE is straightforward as you can see in the following example:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: You can test this example in the bundled code named *CtePlainSql*. Next, let's
    tackle some common types of CTEs, and let's continue with a query that uses two
    or more CTEs.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Chaining CTEs
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, a query must exploit more than one CTE. For instance, let''s consider
    the tables `PRODUCTLINE`, `PRODUCT`, and `ORDERDETAIL`. Our goal is to fetch for
    each product line some info (for instance, the description), the total number
    of products, and the total sales. For this, we can write a CTE that joins `PRODUCTLINE`
    with `PRODUCT` and count the total number of products per product line, and another
    CTE that joins `PRODUCT` with `ORDERDETAIL` and computes the total sales per product
    line. Then, both CTEs are used in a `SELECT` to fetch the final result as in the
    following inlined CTE:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: '[PRE251]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: In the bundled code (*CteSimple*), you can see the explicit CTE version as well.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Nested CTEs
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CTEs can be nested as well. For instance, here we have a "base" CTE that computes
    the employees'' average salary per office. The next two CTEs fetch from the "base"
    CTE the minimum and maximum average respectively. Finally, our query cross-joins
    these CTEs:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'The potential output is shown in the next figure:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Output of nested CTEs example'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_14.2.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Output of nested CTEs example
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code (*CteSimple*), you can see the explicit CTE version as well.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Some databases (for instance, MySQL and PostgreSQL) allow you to nest CTEs
    via the `FROM` clause. Here is an example:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '[PRE303]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '[PRE304]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: '[PRE305]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'So, this is a three-step query: first, we compute the minimum salary per office;
    second, we compute the sum of salaries per minimum salary; and third, we compute
    the average of these sums.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Materialized CTEs
  id: totrans-403
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do you have an expensive CTE that fetches a relatively small result set and
    is used two or more times? Then most probably you have a CTE that you may want
    to materialize. The materialized CTE can then be referenced multiple times by
    the parent query without recomputing the results.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: 'In jOOQ, materializing a CTE can be done via `asMaterialized()`. Depending
    on the database, jOOQ will render the proper SQL. For instance, consider the following
    materialized CTE:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: '[PRE307]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: '[PRE308]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: '[PRE309]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: '[PRE310]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: '[PRE311]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '[PRE312]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[PRE313]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '[PRE314]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: '[PRE315]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[PRE316]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[PRE317]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: '[PRE318]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: '[PRE319]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: '[PRE320]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: '[PRE321]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: '[PRE322]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: '[PRE323]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: '[PRE324]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[PRE325]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: '[PRE326]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: '[PRE327]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: This CTE should be evaluated three times (denoted in code as //1, //2, and //3).
    Hopefully, thanks to `asMaterialized()`, the result of the CTE should be materialized
    and reused instead of being recomputed.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CTE 应该被评估三次（在代码中用 //1、//2 和 //3 表示）。希望借助 `asMaterialized()`，CTE 的结果应该被物化并重用，而不是重新计算。
- en: Some databases detect that a CTE is used more than once (the `WITH` clause is
    referenced more than once in the outer query) and automatically try to materialize
    the result set as an optimization fence. For instance, PostgreSQL will materialize
    the above CTE even if we don't use `asMaterialized()` and we simply use `as()`
    because the `WITH` query is called three times.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库会检测到一个 CTE 被多次使用（外层查询中多次引用 `WITH` 子句）并自动尝试将结果集物化为一个优化屏障。例如，即使我们没有使用 `asMaterialized()`，仅仅使用
    `as()`，PostgreSQL 也会物化上述 CTE，因为 `WITH` 查询被调用了三次。
- en: 'But, PostgreSQL allows us to control the CTE materialization and change the
    default behavior. If we want to force inlining the CTE instead of it being materialized,
    then we add the `NOT MATERIALIZED` hint to the CTE. In jOOQ, this is accomplished
    via `asNotMaterialized()`:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，PostgreSQL 允许我们控制 CTE 的物化并改变默认行为。如果我们想强制内联 CTE 而不是物化它，那么我们就在 CTE 中添加 `NOT
    MATERIALIZED` 提示。在 jOOQ 中，这是通过 `asNotMaterialized()` 实现的：
- en: '[PRE328]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: '[PRE329]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: '[PRE330]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: '[PRE331]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: On the other hand, in Oracle, we can control materialization via the `/*+ materialize
    */` and `/*+ inline */` hints. Using jOOQ's `asMaterialized()` renders the `/*+
    materialize */` hint, while `asNotMaterialized()` renders the `/*+ inline */`
    hint. Using jOOQ's `as()` doesn't render any hint, so Oracle's optimizer is free
    to act as the default.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在 Oracle 中，我们可以通过 `/*+ materialize */` 和 `/*+ inline */` 提示来控制物化。使用 jOOQ
    的 `asMaterialized()` 生成 `/*+ materialize */` 提示，而 `asNotMaterialized()` 生成 `/*+
    inline */` 提示。使用 jOOQ 的 `as()` 不会生成任何提示，因此 Oracle 的优化器可以自由地按照默认行为操作。
- en: 'However, Lukas Eder said: *Note that the Oracle hints aren''t documented, so
    they might change (though all possible Oracle guru blogs document their de facto
    functionality, so knowing Oracle, they won''t break easily). If not explicitly
    documented, there''s never any *guarantee* for any *materialization trick* to
    keep working.*'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Lukas Eder 说：*请注意，Oracle 的提示信息并未文档化，因此它们可能会改变（尽管所有可能的 Oracle 大师博客都记录了它们的实际功能，因此了解
    Oracle，它们不会轻易改变）。如果没有明确记录，任何 *物化技巧* 的 *保证* 都是不存在的。*
- en: 'Other databases don''t support materialization at all or use it only as an
    internal mechanism of the optimizer (for instance, MySQL). Using jOOQ''s `as()`,
    `asMaterialized()`, and `asNotMaterialized()` renders the same SQL for MySQL,
    therefore we cannot rely on explicit materialization. In such cases, we can attempt
    to rewrite our CTE to avoid recalls. For instance, the previous CTE can be optimized
    to not need materialization in MySQL via `LATERAL`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 其他数据库根本不支持物化，或者只将其用作优化器的内部机制（例如，MySQL）。使用 jOOQ 的 `as()`、`asMaterialized()` 和
    `asNotMaterialized()` 在 MySQL 中生成相同的 SQL，因此我们无法依赖于显式的物化。在这种情况下，我们可以尝试重写我们的 CTE
    以避免重复调用。例如，之前的 CTE 可以通过 `LATERAL` 优化，在 MySQL 中无需物化：
- en: '[PRE332]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: '[PRE334]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '[PRE335]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: '[PRE336]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: '[PRE337]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[PRE338]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '[PRE339]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: '[PRE340]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[PRE341]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[PRE342]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[PRE343]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: '[PRE344]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '[PRE345]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: '[PRE346]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: '[PRE347]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: '[PRE348]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: '[PRE349]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[PRE351]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: '[PRE352]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '[PRE353]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'Here is the alternative for SQL Server (like MySQL, SQL Server doesn''t expose
    any support for explicit materialization; however, there is a proposal for Microsoft
    to add a dedicated hint similar to what Oracle has) using `CROSS APPLY` and the
    `VALUES` constructor:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 SQL Server 的替代方案（类似于 MySQL，SQL Server 不公开任何对显式物化的支持；然而，有一个提案建议微软添加一个类似于
    Oracle 的专用提示），使用 `CROSS APPLY` 和 `VALUES` 构造函数：
- en: '[PRE354]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: '[PRE356]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: '[PRE357]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: '[PRE358]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '[PRE359]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: '[PRE360]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: '[PRE362]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: '[PRE363]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: '[PRE364]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: '[PRE365]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: '[PRE366]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: '[PRE367]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: '[PRE368]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[PRE370]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: '[PRE372]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: A good cost-based optimizer should always rewrite all SQL statements to the
    optimal execution plan, so what may work today, might not work tomorrow – such
    as this `LATERAL`/`CROSS APPLY` trick. If the optimizer is ever smart enough to
    detect that `LATERAL`/`CROSS APPLY` is unnecessary (for example, because of the
    lack of correlation), then it might be (should be) eliminated.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 一个优秀的基于成本的优化器应该始终将所有 SQL 语句重写为最优执行计划，因此今天可能有效的方法，明天可能就不适用了——例如这个 `LATERAL`/`CROSS
    APPLY` 的小技巧。如果优化器足够聪明，能够检测到 `LATERAL`/`CROSS APPLY` 是不必要的（例如，由于缺乏相关性），那么它可能（应该是）被消除。
- en: You can check out all these examples in *CteSimple*. Moreover, in the *CteAggRem*
    application, you can practice a CTE for calculating the top N items and aggregating
    (summing) the remainder in a separate row. Basically, while ranking items in the
    database is a common problem to compute top/bottom N items, another common requirement
    that is related to this one is to obtain all the other rows (that don't fit in
    top/bottom N) in a separate row. This is helpful to provide a complete context
    when presenting data.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*CteSimple*中查看所有这些示例。此外，在*CteAggRem*应用程序中，您可以练习一个CTE，用于计算前N项并汇总（求和）剩余项到单独的行中。基本上，虽然数据库中排名项以计算前N项或后N项是一个常见问题，但与此相关的一个常见要求是获取所有其他行（不包含在前N项或后N项中的行）到单独的行中。这在呈现数据时提供完整上下文很有帮助。
- en: In the *CteWMAvg* code, you can check out a statistics problem with the main
    goal being to highlight recent points. This problem is known as **Weighted Moving
    Average** (**WMA**). This is part of the moving average family ([https://en.wikipedia.org/wiki/Moving_average](https://en.wikipedia.org/wiki/Moving_average))
    and, in a nutshell, WMA is a moving average where the previous values (points)
    range in the sliding window are given different (fractional) weights.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在*CteWMAvg*代码中，您可以查看一个以突出显示最近点为主要目标的统计问题。这个问题被称为**加权移动平均**（**WMA**）。这是移动平均家族的一部分([https://en.wikipedia.org/wiki/Moving_average](https://en.wikipedia.org/wiki/Moving_average))，简而言之，WMA是一种移动平均，其中滑动窗口中的先前值（点）具有不同的（分数）权重。
- en: Recursive CTEs
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归CTE
- en: Besides regular CTEs, we have recursive CTEs.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 除了常规CTE之外，我们还有递归CTE。
- en: 'In a nutshell, recursive CTEs reproduce the concept of for-loops in programming.
    A recursive CTE can handle and explore hierarchical data by referencing themselves.
    Behind a recursive CTE, there are two main members:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，递归CTE重现了编程中for循环的概念。递归CTE可以通过引用自身来处理和探索层次数据。在递归CTE背后，有两个主要成员：
- en: The *anchor* member – Its goal is to select the starting rows of the involved
    recursive steps.
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*锚定*成员 – 其目标是选择涉及递归步骤的起始行。'
- en: The *recursive* member – Its goal is to generate rows for the CTE. The first
    iteration step acts against the anchor rows, while the second iteration step acts
    against the rows previously created in recursions steps. This member occurs after
    a `UNION ALL` in the CTE definition part. To be more accurate, `UNION ALL` is
    required by a few dialects, but others are capable of recurring with `UNION` as
    well, with slightly different semantics.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*递归*成员 – 其目标是生成CTE的行。第一次迭代步骤针对锚定行，而第二次迭代步骤针对递归步骤中先前创建的行。此成员出现在CTE定义部分的`UNION
    ALL`之后。更准确地说，`UNION ALL`是某些方言所必需的，但其他方言也可以使用`UNION`进行递归，语义略有不同。'
- en: In jOOQ, recursive CTEs can be expressed via the `withRecursive()` method.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在jOOQ中，递归CTE可以通过`withRecursive()`方法表达。
- en: 'Here''s a simple recursive CTE that computes the famous Fibonacci numbers.
    The *anchor* member is equal to 1, and the *recursive* member applies the Fibonacci
    formula up to the number 20:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的递归CTE，用于计算著名的斐波那契数。*锚定*成员等于1，*递归*成员应用斐波那契公式直到数字20：
- en: '[PRE373]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[PRE374]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: '[PRE376]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[PRE377]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: '[PRE378]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: '[PRE379]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '[PRE381]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Well, that was easy, wasn''t it? Next, let''s tackle a famous problem that
    can be solved via recursive CTE, known as the Travelling Salesman Problem. Consider
    reading more details here: [https://en.wikipedia.org/wiki/Travelling_salesman_problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem).
    In a nutshell, we interpret this problem to find the shortest private flight through
    several cities representing locations of our offices. Basically, in `OFFICE_FLIGHTS`,
    we have the routes between our offices as `OFFICE_FLIGHTS.DEPART_TOWN`, `OFFICE_FLIGHTS.ARRIVAL_TOWN`,
    and `OFFICE_FLIGHTS.DISTANCE_KM`. For instance, our CTE will use *Los Angeles*
    as its anchor city, and then recursively traverse every other city in order to
    reach *Tokyo*:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这很简单，不是吗？接下来，让我们解决一个可以通过递归CTE解决的问题，即著名的旅行商问题。更多详细信息请参阅：[https://en.wikipedia.org/wiki/Travelling_salesman_problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem)。简而言之，我们将这个问题解释为通过代表我们办公室位置的几个城市找到最短私人航班。基本上，在`OFFICE_FLIGHTS`中，我们有我们办公室之间的路线，作为`OFFICE_FLIGHTS.DEPART_TOWN`、`OFFICE_FLIGHTS.ARRIVAL_TOWN`和`OFFICE_FLIGHTS.DISTANCE_KM`。例如，我们的CTE将使用*洛杉矶*作为其锚定城市，然后递归遍历每个其他城市以到达*东京*：
- en: '[PRE383]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[PRE384]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[PRE385]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[PRE386]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '[PRE387]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: '[PRE388]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[PRE389]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[PRE390]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: '[PRE392]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: '[PRE393]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: '[PRE394]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: '[PRE395]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[PRE397]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: '[PRE399]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: '[PRE400]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: '[PRE401]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '[PRE402]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '[PRE403]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '[PRE404]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: '[PRE405]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: '[PRE406]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: '[PRE407]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: '[PRE408]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: '[PRE409]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: '[PRE410]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: '[PRE411]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: '[PRE412]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: 'Some possible output is in the next figure:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个图中显示了一些可能的输出：
- en: '![Figure 14.3 – Shortest private flight from Los Angeles to Tokyo, 18,983 km'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '![图14.3 – 从洛杉矶到东京的最短私人航班，18,983公里'
- en: '](img/B16833_Figure_14.3.jpg)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B16833_Figure_14.3.jpg)'
- en: Figure 14.3 – Shortest private flight from Los Angeles to Tokyo, 18,983 km
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: You can practice these examples in *CteRecursive*.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: CTEs and window functions
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let''s look at two examples that combine CTE and window functions,
    and let''s start with an example that computes the gaps in IDs. For instance,
    each `EMPLOYEE` has an associated `EMPLOYEE_NUMBER` and we want to find out how
    many values are missing from the data values (missing `EMPLOYEE_NUMBER`), and
    how many existing values are consecutive. This is a job for the `ROW_NUMBER()`
    window and the following CTE:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: '[PRE414]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: '[PRE415]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: '[PRE416]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: '[PRE417]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '[PRE418]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE418]'
- en: '[PRE419]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE419]'
- en: '[PRE420]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[PRE421]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[PRE422]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE422]'
- en: '[PRE423]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: '[PRE424]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: '[PRE425]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: '[PRE426]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: 'While you can see this example in the bundled code, let''s look at another
    one that finds the percentile rank of every product line by order values:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: '[PRE428]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: '[PRE429]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: '[PRE430]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[PRE431]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: '[PRE432]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: '[PRE433]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: '[PRE434]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: '[PRE435]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '[PRE436]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE436]'
- en: '[PRE437]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE437]'
- en: '[PRE438]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[PRE439]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[PRE440]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE440]'
- en: You can find these examples along with another one that finds the top three
    highest-valued orders each year in *CteWf*.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: Using CTEs to generate data
  id: totrans-568
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CTEs are quite handy for generating data – they act as the source of data for
    the SQL statement that uses a CTE. For instance, using a CTE and the `VALUES`
    constructor can be done as follows:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: '[PRE442]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: '[PRE443]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: '[PRE444]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: '[PRE445]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: '[PRE446]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: '[PRE447]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: 'Or, using a CTE to unnest an array can be done as follows:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: '[PRE449]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[PRE450]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: '[PRE451]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: '[PRE452]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: '[PRE453]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: 'Or, here is an example of unnesting an array to pick up a random value:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE454]'
- en: '[PRE455]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE455]'
- en: '[PRE456]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE456]'
- en: '[PRE457]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE457]'
- en: '[PRE458]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE458]'
- en: '[PRE459]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE459]'
- en: '[PRE460]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE460]'
- en: '[PRE461]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE461]'
- en: 'Or, maybe you need a random sample from the database (here, 10 random products):'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE462]'
- en: '[PRE463]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE463]'
- en: '[PRE464]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE464]'
- en: '[PRE465]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE465]'
- en: '[PRE466]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE466]'
- en: However, keep in mind that `ORDER BY RAND()` should be avoided for large tables,
    as `ORDER BY` performs with O(N log N).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need more sophisticated sources of data, then probably you''ll be interested
    in generating a series. Here is an example of generating the odd numbers between
    1 and 10:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE467]'
- en: '[PRE468]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE468]'
- en: '[PRE469]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE469]'
- en: '[PRE470]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE470]'
- en: '[PRE471]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE471]'
- en: 'Here is an example that associates grades between 1 and 100 with the letters
    A to F and counts them as well – in other words, custom binning of grades:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE472]'
- en: '[PRE473]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE473]'
- en: '[PRE474]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE474]'
- en: '[PRE475]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE475]'
- en: '[PRE476]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE476]'
- en: '[PRE477]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE477]'
- en: '[PRE478]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE478]'
- en: '[PRE479]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE479]'
- en: '[PRE480]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE480]'
- en: '[PRE481]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE481]'
- en: '[PRE482]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE482]'
- en: '[PRE483]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE483]'
- en: '[PRE484]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE484]'
- en: '[PRE485]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE485]'
- en: '[PRE486]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE486]'
- en: In the bundled code, you can see more binning examples including custom binning
    of grades via `PERCENT_RANK()`, equal height binning, equal-width binning, the
    PostgreSQL `width_bucket()` function, and binning with a chart.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
- en: 'After all these snippets, let''s tackle the following famous problem: Consider
    `p` student classes of certain sizes, and `q` rooms of certain sizes, where `q`>=
    `p`. Write a CTE for assigning as many classes as possible to rooms of proper
    size. Let''s assume that the given data is in the left-hand side figure and the
    expected result is in the right-hand side figure:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Input and expected output'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_14.4.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – Input and expected output
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this problem, we can generate the input data as follows:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE487]'
- en: '[PRE488]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE488]'
- en: '[PRE489]'
  id: totrans-630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE489]'
- en: '[PRE490]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE490]'
- en: '[PRE491]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE491]'
- en: '[PRE492]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE492]'
- en: '[PRE493]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE493]'
- en: '[PRE494]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE494]'
- en: '[PRE495]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE495]'
- en: '[PRE496]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE496]'
- en: '[PRE497]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE497]'
- en: The complete query is quite large to be listed here, but you can find it in
    the *CteGenData* application next to all the examples from this section.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic CTEs
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commonly, when we need to dynamically create a CTE, we plan to dynamically
    shape its name, derived table(s), and the outer query. For instance, the following
    method allows us to pass these components as arguments and return the result of
    executing the query:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE498]'
- en: '[PRE499]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE499]'
- en: '[PRE500]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE500]'
- en: '[PRE501]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE501]'
- en: '[PRE502]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE502]'
- en: '[PRE503]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE503]'
- en: '[PRE504]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE504]'
- en: '[PRE505]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE505]'
- en: '[PRE506]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE506]'
- en: '[PRE507]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE507]'
- en: '[PRE508]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE508]'
- en: '[PRE509]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE509]'
- en: '[PRE510]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE510]'
- en: '[PRE511]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE511]'
- en: '[PRE512]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE512]'
- en: '[PRE513]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE513]'
- en: '[PRE514]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE514]'
- en: '[PRE515]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE515]'
- en: 'Here is a calling sample for solving the problem presented earlier, in the
    *CTEs and window functions* section:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE516]'
- en: '[PRE517]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE517]'
- en: '[PRE518]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE518]'
- en: '[PRE519]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE519]'
- en: '[PRE520]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE520]'
- en: '[PRE521]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE521]'
- en: '[PRE522]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE522]'
- en: '[PRE523]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE523]'
- en: '[PRE524]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE524]'
- en: '[PRE525]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE525]'
- en: '[PRE526]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE526]'
- en: 'Whenever you try to implement a CTE, as here, consider this Lukas Eder note:
    *This example uses the DSL in a mutable way, which works but is discouraged. A
    future jOOQ version might turn to an immutable DSL API and this code will stop
    working. It''s unlikely to happen soon, because of the huge backward incompatibility,
    but the discouragement is real already today :) In IntelliJ, you should already
    get a warning in this code, because of the API''s* `@CheckReturnValue` *annotation
    usage, at least in jOOQ 3.15*.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you just need to pass a variable number of CTEs to the
    outer query, then you can do this:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE527]'
- en: '[PRE528]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE528]'
- en: '[PRE529]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE529]'
- en: '[PRE530]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE530]'
- en: 'Or, you can do this:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE531]'
- en: '[PRE532]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE532]'
- en: '[PRE533]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE533]'
- en: '[PRE534]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE534]'
- en: '[PRE535]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE535]'
- en: '[PRE536]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE536]'
- en: You can practice these examples in *CteDynamic*.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Expressing a query via a derived table, a temporary table, and a CTE
  id: totrans-686
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we prefer to express a query in several ways to compare their execution
    plans. For instance, we may have a query and express it via derived tables, temporary
    tables, and CTE to see which approach fits best. Since jOOQ supports these approaches,
    let''s try to express a query starting from the derived tables approach:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE537]'
- en: '[PRE538]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE538]'
- en: '[PRE539]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE539]'
- en: '[PRE540]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE540]'
- en: '[PRE541]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE541]'
- en: '[PRE542]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE542]'
- en: '[PRE543]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE543]'
- en: '[PRE544]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE544]'
- en: '[PRE545]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE545]'
- en: '[PRE546]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE546]'
- en: '[PRE547]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE547]'
- en: '[PRE548]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE548]'
- en: So, this query returns all employees with above-average sales. For each employee,
    we compare their average sales to the total average sales for all employees. Essentially,
    this query works on the `EMPLOYEE` and `SALE` tables, and we must know the total
    sales for all employees, the number of employees, and the sum of sales for each
    employee.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: 'If we extract what we must know in three temporary tables, then we obtain this:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE549]'
- en: '[PRE550]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE550]'
- en: '[PRE551]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE551]'
- en: '[PRE552]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE552]'
- en: '[PRE553]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE553]'
- en: '[PRE554]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE554]'
- en: '[PRE555]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE555]'
- en: '[PRE556]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE556]'
- en: '[PRE557]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE557]'
- en: '[PRE558]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE558]'
- en: '[PRE559]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE559]'
- en: '[PRE560]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE560]'
- en: '[PRE561]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE561]'
- en: '[PRE562]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE562]'
- en: 'Having these three temporary tables, we can rewrite our query as follows:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE563]'
- en: '[PRE564]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE564]'
- en: '[PRE565]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE565]'
- en: '[PRE566]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE566]'
- en: '[PRE567]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE567]'
- en: '[PRE568]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE568]'
- en: '[PRE569]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE569]'
- en: '[PRE570]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE570]'
- en: '[PRE571]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE571]'
- en: 'Finally, the same query can be expressed via CTE (by replacing `as()` with
    `asMaterialized()`, you can practice the materialization of this CTE):'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE572]'
- en: '[PRE573]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE573]'
- en: '[PRE574]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE574]'
- en: '[PRE575]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE575]'
- en: '[PRE576]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE576]'
- en: '[PRE577]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE577]'
- en: '[PRE578]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE578]'
- en: '[PRE579]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE579]'
- en: '[PRE580]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE580]'
- en: '[PRE581]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE581]'
- en: '[PRE582]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE582]'
- en: '[PRE583]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE583]'
- en: '[PRE584]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE584]'
- en: '[PRE585]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE585]'
- en: '[PRE586]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE586]'
- en: '[PRE587]'
  id: totrans-742
  prefs: []
  type: TYPE_PRE
  zh: '[PRE587]'
- en: '[PRE588]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE588]'
- en: '[PRE589]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE589]'
- en: '[PRE590]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE590]'
- en: '[PRE591]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE591]'
- en: '[PRE592]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE592]'
- en: '[PRE593]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE593]'
- en: Now you just have to run these queries against your database and compare their
    performances and execution plans. The bundled code contains one more example and
    is available as *ToCte*.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: Handling views in jOOQ
  id: totrans-750
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last section of this chapter is reserved for database views.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: A view acts as an actual physical table that can be invoked by name. They fit
    well for reporting tasks or integration with third-party tools that need a guided
    query API. By default, the database vendor decides to materialize the results
    of the view or to rely on other mechanisms to get the same effect. Most vendors
    (hopefully) don't default to materializing views! Views should behave just like
    CTE or derived tables and should be transparent to the optimizer. In most cases
    (in Oracle), we would expect a view to be inlined, even when selected several
    times, because each time, a different predicate might be pushed down into the
    view. Actual materialized views are supported only by a few vendors, while the
    optimizer can decide to materialize the view contents when a view is queried several
    times. The view's definition is stored in the schema tables so it can be invoked
    by name wherever a regular/base table could be used. If the view is updatable,
    then some additional rules come to sustain it.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: A view differs by a base, temporary, or derived table in several essential aspects.
    Base and temporary tables accept constraints, while a view doesn't (in most databases).
    A view has no presence in the database until it is invoked, whereas a temporary
    table is persistent. Finally, a derived table has the same scope as the query
    in which it is created. The view definition cannot contain a reference to itself,
    since it does not exist yet, but it can contain references to other views.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of a view is as follows (for the exact syntax of a certain
    database vendor, you should consult the documentation):'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE594]'
- en: '[PRE595]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE595]'
- en: '[PRE596]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE596]'
- en: '[PRE597]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE597]'
- en: 'Some RDBMS support constraints on views (for instance, Oracle), though with
    limitations: [https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/constraint.html](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/constraint.html).
    The documented `WITH CHECK OPTION` is actually a constraint.'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see some examples of views expressed via jOOQ.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: Updatable and read-only views
  id: totrans-761
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Views can be either updatable or read-only, but not both. In jOOQ, they can
    be created via the `createView()` and `createViewIfNotExists()` methods. Dropping
    a view can be done via `dropView()`, respectively `dropViewIfExists()`. Here is
    an example of creating a read-only view:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE598]'
- en: '[PRE599]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE599]'
- en: '[PRE600]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE600]'
- en: '[PRE601]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE601]'
- en: '[PRE602]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE602]'
- en: '[PRE603]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE603]'
- en: Roughly, in standard SQL, an updatable view is built on only one table; it cannot
    contain `GROUP BY`, `HAVING`, `INTERSECT`, `EXCEPT`, `SELECT DISTINCT`, or `UNION`
    (however, at least in theory, a `UNION` between two disjoint tables, neither of
    which has duplicate rows in itself, should be updatable), aggregate functions,
    calculated columns, and any columns excluded from the view must have `DEFAULT`
    in the base table or be null-able. However, according to the standard SQL T111
    optional feature, joins and unions aren't an impediment to updatability per se,
    so an updatable view doesn't have to be built "on only one table." Also (for the
    avoidance of any doubt), not all columns of an updatable view have to be updatable,
    but of course, only updatable columns can be updated.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: 'When the view is modified, the modifications pass through the view to the corresponding
    underlying base table. In other words, an updatable view has a 1:1 match between
    its rows and the rows of the underlying base table, therefore the previous view
    is not updatable. But we can rewrite it without `UNION ALL` to transform it into
    a valid updatable view:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE604]'
- en: '[PRE605]'
  id: totrans-772
  prefs: []
  type: TYPE_PRE
  zh: '[PRE605]'
- en: '[PRE606]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE606]'
- en: '[PRE607]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE607]'
- en: 'Some views are "partially" updatable. For instance, views that contain `JOIN`
    statements like this one:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE608]'
- en: '[PRE609]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE609]'
- en: '[PRE610]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE610]'
- en: '[PRE611]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE611]'
- en: '[PRE612]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE612]'
- en: '[PRE613]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE613]'
- en: '[PRE614]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE614]'
- en: '[PRE615]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE615]'
- en: While in PostgreSQL this view is not updatable at all, in MySQL, SQL Server,
    and Oracle, this view is "partially" updatable. In other words, as long as the
    modifications affect only one of the two involved base tables, the view is updatable,
    otherwise, it is not. If more base tables are involved in the update, then an
    error occurs. For instance, in SQL Server, we get an error of *View or function
    'employees_and_sales' is not updatable because the modification affects multiple
    base tables*, while in Oracle, we get *ORA-01776*.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: You can check out these examples in *DbViews*.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: Types of views (unofficial categorization)
  id: totrans-786
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let's define several common types of views depending on their
    usage, and let's start with views of the type single-table projection and restriction.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
- en: Single-table projection and restriction
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, for security reasons, we rely on projections/restrictions of a single
    base table to remove certain rows and/or columns that should not be seen by a
    particular group of users. For instance, the following view represents a projection
    of the `BANK_TRANSACTION` base table to restrict/hide the details about the involved
    banks:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE616]'
- en: '[PRE617]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE617]'
- en: '[PRE618]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE618]'
- en: '[PRE619]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE619]'
- en: '[PRE620]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE620]'
- en: '[PRE621]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE621]'
- en: '[PRE622]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE622]'
- en: '[PRE623]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE623]'
- en: '[PRE624]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE624]'
- en: '[PRE625]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE625]'
- en: Another type of view tackles computed columns.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: Calculated columns
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Providing summary data is another use case of views. For instance, we prefer
    to compute the columns in as meaningful a way as possible and expose them to the
    clients as views. Here is an example of computing the payroll of each employee
    as salary plus commission:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE626]'
- en: '[PRE627]'
  id: totrans-804
  prefs: []
  type: TYPE_PRE
  zh: '[PRE627]'
- en: '[PRE628]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE628]'
- en: '[PRE629]'
  id: totrans-806
  prefs: []
  type: TYPE_PRE
  zh: '[PRE629]'
- en: '[PRE630]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE630]'
- en: Another type of view tackles translated columns.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: Translated columns
  id: totrans-809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Views are also useful for translating codes into texts to increase the readability
    of the fetched result set. A common case is a suite of `JOIN` statements between
    several tables via one or more foreign keys. For instance, in the following view,
    we have a detailed report of customers, orders, and products by translating the
    `CUSTOMER_NUMBER`, `ORDER_ID`, and `PRODUCT_ID` codes (foreign keys):'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  id: totrans-811
  prefs: []
  type: TYPE_PRE
  zh: '[PRE631]'
- en: '[PRE632]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE632]'
- en: '[PRE633]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE633]'
- en: '[PRE634]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE634]'
- en: '[PRE635]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE635]'
- en: '[PRE636]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE636]'
- en: '[PRE637]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE637]'
- en: '[PRE638]'
  id: totrans-818
  prefs: []
  type: TYPE_PRE
  zh: '[PRE638]'
- en: '[PRE639]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE639]'
- en: '[PRE640]'
  id: totrans-820
  prefs: []
  type: TYPE_PRE
  zh: '[PRE640]'
- en: '[PRE641]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE641]'
- en: '[PRE642]'
  id: totrans-822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE642]'
- en: '[PRE643]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE643]'
- en: '[PRE644]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE644]'
- en: Next, let's tackle grouped views.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: Grouped views
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A grouped view relies on a query containing a `GROUP BY` clause. Commonly,
    such read-only views contain one or more aggregate functions and they are useful
    for creating different kinds of reports. Here is an example of creating a grouped
    view that fetches big sales per employee:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE645]'
- en: '[PRE646]'
  id: totrans-829
  prefs: []
  type: TYPE_PRE
  zh: '[PRE646]'
- en: '[PRE647]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE647]'
- en: '[PRE648]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE648]'
- en: '[PRE649]'
  id: totrans-832
  prefs: []
  type: TYPE_PRE
  zh: '[PRE649]'
- en: 'Here is another example that relies on a grouped view to "flatten out" a one-to-many
    relationship:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE650]'
- en: '[PRE651]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE651]'
- en: '[PRE652]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE652]'
- en: '[PRE653]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE653]'
- en: '[PRE654]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE654]'
- en: '[PRE655]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE655]'
- en: '[PRE656]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE656]'
- en: '[PRE657]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE657]'
- en: '[PRE658]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE658]'
- en: '[PRE659]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE659]'
- en: '[PRE660]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE660]'
- en: '[PRE661]'
  id: totrans-845
  prefs: []
  type: TYPE_PRE
  zh: '[PRE661]'
- en: '[PRE662]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE662]'
- en: '[PRE663]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE663]'
- en: '[PRE664]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE664]'
- en: Next, let's tackle `UNION`-ed views.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: UNION-ed views
  id: totrans-850
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `UNION`/`UNION ALL` in views is also a common usage case of views. Here
    is the previous query of flattening one-to-many relationships rewritten via `UNION`:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE665]'
- en: '[PRE666]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE666]'
- en: '[PRE667]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE667]'
- en: '[PRE668]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE668]'
- en: '[PRE669]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE669]'
- en: '[PRE670]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE670]'
- en: '[PRE671]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE671]'
- en: '[PRE672]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE672]'
- en: '[PRE673]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE673]'
- en: '[PRE674]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE674]'
- en: '[PRE675]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE675]'
- en: '[PRE676]'
  id: totrans-863
  prefs: []
  type: TYPE_PRE
  zh: '[PRE676]'
- en: '[PRE677]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE677]'
- en: '[PRE678]'
  id: totrans-865
  prefs: []
  type: TYPE_PRE
  zh: '[PRE678]'
- en: '[PRE679]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE679]'
- en: '[PRE680]'
  id: totrans-867
  prefs: []
  type: TYPE_PRE
  zh: '[PRE680]'
- en: '[PRE681]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE681]'
- en: '[PRE682]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE682]'
- en: Finally, let's see an example of nested views.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: Nested views
  id: totrans-871
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A view can be built on another view. Pay attention to avoid circular references
    in the query expressions of the views and don't forget that a view must be ultimately
    built on base tables. Moreover, pay attention if you have different updatable
    views that reference the same base table at the same time. Using such views in
    other views may cause ambiguity issues since it is hard to infer what will happen
    if the highest-level view is modified.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using nested views:'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE683]'
- en: '[PRE684]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE684]'
- en: '[PRE685]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE685]'
- en: '[PRE686]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE686]'
- en: '[PRE687]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE687]'
- en: '[PRE688]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE688]'
- en: '[PRE689]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE689]'
- en: '[PRE690]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE690]'
- en: '[PRE691]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE691]'
- en: '[PRE692]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE692]'
- en: '[PRE693]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE693]'
- en: '[PRE694]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE694]'
- en: '[PRE695]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE695]'
- en: '[PRE696]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE696]'
- en: '[PRE697]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE697]'
- en: The first view, `customer_orders_1`, counts the total orders per customer, and
    the second view, `customer_orders_2`, fetches the name of those customers.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: You can see these examples in *DbTypesOfViews*.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of views
  id: totrans-891
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we rely on views to solve several problems. For instance,
    the following view is used to compute the cumulative distribution values by the
    headcount of each office:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE698]'
- en: '[PRE699]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE699]'
- en: '[PRE700]'
  id: totrans-895
  prefs: []
  type: TYPE_PRE
  zh: '[PRE700]'
- en: '[PRE701]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE701]'
- en: '[PRE702]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE702]'
- en: '[PRE703]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE703]'
- en: '[PRE704]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE704]'
- en: '[PRE705]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE705]'
- en: '[PRE706]'
  id: totrans-901
  prefs: []
  type: TYPE_PRE
  zh: '[PRE706]'
- en: 'Next, the query that uses this view for computing the cumulative distribution
    is as follows:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE707]'
- en: '[PRE708]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE708]'
- en: '[PRE709]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE709]'
- en: '[PRE710]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE710]'
- en: '[PRE711]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE711]'
- en: '[PRE712]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE712]'
- en: '[PRE713]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE713]'
- en: 'Views can be combined with CTE. Here is an example that creates a view on top
    of the CTE for detecting gaps in IDs – a problem tackled earlier, in the *CTE
    and window functions* section:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE714]'
- en: '[PRE715]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE715]'
- en: '[PRE716]'
  id: totrans-913
  prefs: []
  type: TYPE_PRE
  zh: '[PRE716]'
- en: '[PRE717]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE717]'
- en: '[PRE718]'
  id: totrans-915
  prefs: []
  type: TYPE_PRE
  zh: '[PRE718]'
- en: '[PRE719]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE719]'
- en: '[PRE720]'
  id: totrans-917
  prefs: []
  type: TYPE_PRE
  zh: '[PRE720]'
- en: '[PRE721]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE721]'
- en: '[PRE722]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE722]'
- en: '[PRE723]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE723]'
- en: '[PRE724]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE724]'
- en: '[PRE725]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE725]'
- en: '[PRE726]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE726]'
- en: 'The query is straightforward:'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  id: totrans-925
  prefs: []
  type: TYPE_PRE
  zh: '[PRE727]'
- en: '[PRE728]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE728]'
- en: 'Finally, let''s see an example that attempts to optimize shipping costs in
    the future based on historical data from *2003*. Let''s assume that we are shipping
    orders with a specialized company that can provide us, on demand, the list of
    trucks with their available periods per year as follows:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE729]'
- en: '[PRE730]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE730]'
- en: '[PRE731]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE731]'
- en: '[PRE732]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE732]'
- en: '[PRE733]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE733]'
- en: Booking trucks in advance for certain periods takes advantage of certain discounts,
    therefore, based on the orders from 2003, we can analyze some queries that can
    tell us whether this action can optimize shipping costs.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a view named `order_truck`, which tells us which trucks are available
    for each order:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE734]'
- en: '[PRE735]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE735]'
- en: '[PRE736]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE736]'
- en: '[PRE737]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE737]'
- en: '[PRE738]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE738]'
- en: '[PRE739]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE739]'
- en: Based on this view, we can run several queries that provide important information.
    For instance, how many orders can be shipped by each truck?
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE740]'
- en: '[PRE741]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE741]'
- en: '[PRE742]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE742]'
- en: '[PRE743]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE743]'
- en: Or, how many trucks can ship the same order?
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE744]'
- en: '[PRE745]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE745]'
- en: '[PRE746]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE746]'
- en: '[PRE747]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE747]'
- en: '[PRE748]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE748]'
- en: 'Moreover, based on this view, we can create another view named `order_truck_all`
    that can tell us the earliest and latest points in both intervals:'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE749]'
- en: '[PRE750]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE750]'
- en: '[PRE751]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE751]'
- en: '[PRE752]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE752]'
- en: '[PRE753]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE753]'
- en: '[PRE754]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE754]'
- en: '[PRE755]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE755]'
- en: '[PRE756]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE756]'
- en: '[PRE757]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE757]'
- en: '[PRE758]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE758]'
- en: '[PRE759]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE759]'
- en: '[PRE760]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE760]'
- en: '[PRE761]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE761]'
- en: '[PRE762]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE762]'
- en: '[PRE763]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE763]'
- en: '[PRE764]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE764]'
- en: 'Getting the exact points in both intervals can be determined based on the previous
    view as follows:'
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE765]'
- en: '[PRE766]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE766]'
- en: '[PRE767]'
  id: totrans-972
  prefs: []
  type: TYPE_PRE
  zh: '[PRE767]'
- en: '[PRE768]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE768]'
- en: '[PRE769]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE769]'
- en: '[PRE770]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE770]'
- en: '[PRE771]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE771]'
- en: '[PRE772]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE772]'
- en: '[PRE773]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE773]'
- en: '[PRE774]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE774]'
- en: Depending on how deeply we want to analyze the data, we can continue adding
    more queries and views, but I think you've got the idea. You can check out these
    examples in the bundled code, named *DbViewsEx*.
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
- en: For those that expected to cover table-valued functions here (also called "parameterized
    views") as well, please consider the next chapter.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in this chapter, you saw at work several jOOQ methods useful
    to trigger DDL statements, such as `createView()`, `createTemporaryTable()`, and
    so on. Actually, jOOQ provides a comprehensive API for programmatically generating
    DDL that is covered by examples in the bundled code named *DynamicSchema*. Take
    your time to practice those examples and get familiar with them.
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-983
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to express derived tables, CTEs, and views
    in jOOQ. Since these are powerful SQL tools, it is very important to be familiar
    with them, therefore, besides the examples from this chapter, it is advisable
    to challenge yourself and try to solve more problems via jOOQ's DSL.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will tackle stored functions/procedures.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
