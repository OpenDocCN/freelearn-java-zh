- en: '*Chapter 14*: Derived Tables, CTEs, and Views'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Derived tables, **CTEs**, and views are important players in the SQL context.
    They're useful to organize and optimize the reuse of long and complex queries
    – typically, base queries and/or expensive queries (in performance terms), and
    to improve readability by breaking down the code into separate steps. Mainly,
    they link a certain query to a name, possibly stored in the schema. In other words,
    they hold the query text, which can be referenced and executed via the associated
    name when needed. If results materialize, then the database engine can reuse these
    cached results, otherwise, they have to be recomputed at each call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derived tables, CTEs, and views have specific particularities (including database
    vendor-specific options), and choosing between them is a decision that strongly
    depends on the use case, the involved data and queries, the database vendor and
    optimizer, and so on. As usual, we handle this topic from the jOOQ perspective,
    so our agenda includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Derived tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CTEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter14).
  prefs: []
  type: TYPE_NORMAL
- en: Derived tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever used a nested `SELECT` (a `SELECT` in a table expression)? Of
    course, you have! Then, you've used a so-called *derived table* having the scope
    of the statement that creates it. Roughly, a derived table should be treated in
    the same way as a base table. In other words, it is advisable to give it and its
    columns meaningful names via the `AS` operator. This way, you can reference the
    derived table without ambiguity, and you'll respect the fact that most databases
    don't support unnamed (unaliased) derived tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'jOOQ allows us to transform any `SELECT` in a derived table via `asTable()`,
    or its synonym `table()`. Let''s have a simple example starting from this `SELECT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not a derived table, but it can become one as follows (these two are
    synonyms):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In jOOQ, we can further refer to this derived table via the local variable `t`.
    It is convenient to declare `t` as `Table<?>` or to simply use `var`. But, of
    course, you can explicitly specify the data types as well. Here, `Table<Record1<Integer>>`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The `org.jooq.Table` type can reference a derived table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the resulting `t` is an unnamed derived table since there is no explicit
    alias associated with it. Let''s see what happens when we select something from
    `t`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'jOOQ generates the following SQL (we''ve arbitrarily chosen the PostgreSQL
    dialect):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: jOOQ detected the missing alias for the derived table, therefore it generated
    one (`alias_30260683`) on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: We earlier iterated that most database vendors require an explicit alias for
    every derived table. But, as you just saw, jOOQ allows us to omit such aliases,
    and when we do, jOOQ will generate one on our behalf to guarantee that the generated
    SQL is syntactically correct. The generated alias is a random number suffixed
    by `alias_`. This alias should not be referenced explicitly. jOOQ will use it
    internally to render a correct/valid SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, if we explicitly specify an alias then jOOQ will use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL corresponding to PostgreSQL is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example using the `values()` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Typically, we explicitly specify an alias when we also reference it explicitly,
    but there is nothing wrong in doing it every time. For instance, jOOQ doesn''t
    require an explicit alias for the following inlined derived table, but there is
    nothing wrong with adding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: jOOQ relies on the `t` alias instead of generating one.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting/declaring a derived table in a local variable
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: jOOQ allows us to extract/declare a derived table outside the statement that
    used it, and, in such a case, its presence and role are better outlined than in
    the case of nesting it in a table expression.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting/declaring a derived table in a local variable can be useful if we
    need to refer to the derived table in multiple statements, we need it as part
    of a dynamic query, or we just want to decongest a complex query.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, consider the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The highlighted subquery represents an inlined derived table. jOOQ automatically
    associates to it an alias and uses that alias to reference the columns `product_id`
    and `price_each` in the outer `SELECT`. Of course, we can provide an explicit
    alias as well, but this is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, jOOQ relies on the `t` alias instead of generating one. Next, let''s
    add this subquery to another query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This query fails at compilation time because the reference to the `product_id`
    column in `on(field(name("product_id")).eq(PRODUCT.PRODUCT_ID))` is ambiguous.
    jOOQ automatically associates a generated alias to the inlined derived table,
    but it cannot decide whether the `product_id` column comes from the derived table
    or from the `PRODUCT` table. Resolving this issue can be done explicitly by adding
    and using an alias for the derived table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now, jOOQ relies on the `t` alias, and the ambiguity issues have been resolved.
    Alternatively, we can explicitly associate a unique alias only to the `ORDERDETAIL.PRODUCT_ID`
    field as `select(ORDERDETAIL.PRODUCT_ID.as("pid")…`, and reference it via this
    alias as `field(name("pid"))…`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have two queries with the same inline derived table. We can
    avoid code repetition by extracting this derived table in a Java local variable
    before using it in these two statements. In other words, we declare the derived
    table in a Java local variable, and we refer to it in the statements via this
    local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: So, `t` is our derived table. Running this snippet of code doesn't have an effect
    on and doesn't produce any SQL. jOOQ evaluates `t` only when we reference it in
    queries, but in order to be evaluated, `t` must be declared before the queries
    that use it. This is just Java; we can use a variable only if it was declared
    upfront. When a query uses `t` (for instance, via `t.field()`), jOOQ evaluates
    `t` and renders the proper SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, we can use `t` to rewrite our queries as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: But, why this time do we need explicit types in `on(t.field(name("price_each"),
    BigDecimal.class)` and `.on(t.field(name("product_id"), Long.class)`? The answer
    is that the fields cannot be dereferenced from `t` in a type-safe way. Therefore
    it is our job to specify the proper data types. This is a pure Java issue, and
    has nothing to do with SQL!
  prefs: []
  type: TYPE_NORMAL
- en: 'But, there is a trick that can help us to keep type safety and reduce verbosity,
    and that trick consists of using the `<T> Field<T> field(Field<T> field)` method.
    The best explanation of this method is given by the jOOQ documentation itself.
    The following figure is a screenshot from the jOOQ official documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – The <T> Field<T> field(Field<T> field) method documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_14.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – The <T> Field<T> field(Field<T> field) method documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'The expression `t.field(name("price_each"), …)` indirectly refers to the field
    `ORDERDETAIL.PRICE_EACH`, and `t.field(name("product_id"), …)` indirectly refers
    to the field `ORDERDETAIL.PRODUCT_ID`. Therefore, based on the previous figure,
    we can re-write our queries in a type-safe manner as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Now, we can reuse `t` in a "type-safe" manner! However, keep in mind that
    <T> Field<T> field(Field<T> field) just looks type safe. It's actually as good
    as an unsafe cast in Java, because the lookup only considers the identifier, not
    the type. Nor does it coerce the expression. This is why we have the quotes around
    type-safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is another example that uses two extracted `Field` in the extracted derived
    table and the query itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `ord` and `avg` are rendered unqualified (without being prefixed with
    the derived table alias). But, thanks to `<T> Field<T> field(Field<T> field)`,
    we can obtain the qualified version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s see an example that uses `fields()` and `asterisk()` to refer
    to all columns of a derived table extracted in a local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that extracting a subquery is not mandatory for it to be transformed
    in a `Table`. There are cases when extracting it as a simple `SELECT` is all you
    need. For instance, when the subquery isn''t a derived table, we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This subquery (which is not a derived table) can be extracted locally and used
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need for an alias (jOOQ knows that this is not a derived table
    and no alias is needed therefore it will not generate one) and no need to transform
    it into a `Table`. Actually, jOOQ is so flexible that it allows us to do even
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Don''t worry, jOOQ will not ask you to transform `t` into a `Table`. jOOQ infers
    that this is a derived table and associates and references a generated alias as
    expected in the rendered SQL. So, as long as you don''t want to associate an explicit
    alias to the derived table and jOOQ doesn''t specifically require a `Table` instance
    in your query, there is no need to transform the extracted `SELECT` into a `Table`
    instance. When you need a `Table` instance but not an alias for it, just use the
    `asTable()` method without arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: You can check out these examples along with others in *DerivedTable*.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Common Table Expressions (CTEs) in jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CTEs are represented by the SQL-99 `WITH` clause. You already saw several examples
    of CTE in previous chapters, for instance, in [*Chapter 13*](B16833_13.xhtml#_idTextAnchor245),
    *Exploiting SQL Functions*, you saw a CTE for computing z-scores.
  prefs: []
  type: TYPE_NORMAL
- en: Roughly, via CTEs, we factor out the code that otherwise should be repeated
    as derived tables. Typically, a CTE contains a list of derived tables placed in
    front of a `SELECT` statement in a certain order. The order is important because
    these derived tables are created conforming to this order and a CTE element can
    reference only prior CTE elements.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, we distinguish between regular (non-recursive) CTEs and recursive
    CTEs.
  prefs: []
  type: TYPE_NORMAL
- en: Regular CTEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A regular CTE associates a name to a temporary result set that has the scope
    of a statement such as `SELECT`, `INSERT`, `UPDATE`, `DELETE`, or `MERGE` (CTEs
    for DML statements are very useful vendor-specific extensions). But, a derived
    table or another type of subquery can have its own CTE as well, such as `SELECT
    x.a FROM (WITH t (a) AS (SELECT 1) SELECT a FROM t) x`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of a CTE (for the exact syntax of a certain database vendor,
    you should consult the documentation) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: In jOOQ, a CTE is represented by the `org.jooq.CommonTableExpression` class
    and extends the commonly used `org.jooq.Table`, therefore a CTE can be used everywhere
    a `Table` can be used. The `CTE_name` represents the name used later in the query
    to refer to the CTE and, in jOOQ, can be specified as the argument of the method
    `name()` or `with()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `column_name` marks the spot for a list of comma-separated columns that
    comes after the `CTE_name`. The number of columns specified here, and the number
    of columns defined in the `CTE_definition` must be equal. In jOOQ, when the `name()`
    method is used for `CTE_name`, this list can be specified via the `fields()` method.
    Otherwise, it can be specified as part of the `with()` arguments after the `CTE_name`.
  prefs: []
  type: TYPE_NORMAL
- en: The `AS` keyword is rendered in jOOQ via the `as(Select<?> select)` method.
    So, the argument of `as()` is the `CTE_definition`. Starting with jOOQ 3.15, the
    CTE `as(ResultQuery<?>)` method accepts a `ResultQuery<?>` to allow for using
    `INSERT ... RETURNING` and other `DML ... RETURNING` statements as CTEs in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the SQL that uses the CTE and references it via `CTE_name`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, the following CTE named `cte_sales` computes the sum of sales
    per employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: This is the CTE declaration that can be referenced via the local variable `t`
    in any future SQL queries expressed via jOOQ. Running this snippet of code now
    doesn't execute the `SELECT` and doesn't produce any effect. Once we use `t` in
    a SQL query, jOOQ will evaluate it to render the expected CTE. That CTE will be
    executed by the database.
  prefs: []
  type: TYPE_NORMAL
- en: Exactly as in the case of declaring derived tables in local variables, in the
    case of CTE, the fields cannot be dereferenced from `t` in a type-safe way, therefore
    it is our job to specify the proper data types in the queries that use the CTE.
    Again, let me point out that this is a pure Java issue, and has nothing to do
    with SQL!
  prefs: []
  type: TYPE_NORMAL
- en: 'Lukas Eder shared this: *Regarding the lack of type safety when dereferencing
    CTE or derived table fields: This is often an opportunity to rewrite the SQL statement
    again to something that doesn''t use a CTE. On Stack Overflow, I''ve seen many
    cases of questions where the person tried to put *everything* in several layers
    of confusing CTE, when the actual factored-out query could have been *much* easier
    (for example, if they knew window functions, or the correct logical order of operations,
    and so on). Just because you can use CTEs, doesn''t mean you have to use them
    *everywhere**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, here is a usage of our CTE, `t`, for fetching the employee having the biggest
    sales:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'By extracting the CTE fields as local variables, we can rewrite our CTE declaration
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The SQL that uses this CTE is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'And, of course, relying on `<T> Field<T> field(Field<T> field)`, introduced
    in the previous section, can help us to write a type-safe CTE as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative to the previous explicit CTE, we can write an inline CTE
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'By arbitrarily choosing the PostgreSQL dialect, we have the following rendered
    SQL for all the previous CTEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: You can check these examples in the bundled code named *CteSimple*. So far,
    our CTE is used only in `SELECT` statements. But, CTE can be used in DML statements
    such as `INSERT`, `UPDATE`, `DELETE`, and `MERGE` as well.
  prefs: []
  type: TYPE_NORMAL
- en: CTE as SELECT and DML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'jOOQ supports using CTE in `INSERT`, `UPDATE`, `DELETE`, and `MERGE`. For instance,
    the following snippet of code inserts into a brand-new table a random part from
    the `SALE` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that updates the prices of the products (`PRODUCT.BUY_PRICE`)
    to the maximum order prices (`max(ORDERDETAIL.PRICE_EACH)`) via a CTE used in
    `UPDATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples along with others including using CTE in `DELETE`
    and `MERGE` in *CteSelectDml*. Next, let's see how we can express a CTE as DML
    in PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: A CTE as DML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting with jOOQ 3.15, the CTE `as(ResultQuery<?>)` method accepts a `ResultQuery<?>`
    to allow for using `INSERT ... RETURNING` and other `DML … RETURNING` statements
    as CTE in PostgreSQL. Here is a simple CTE storing the returned `SALE_ID`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write a CTE that updates the `SALE.REVENUE_GROWTH` of all employees
    having a null `EMPLOYEE.COMMISSION`. All the updated `SALE.EMPLOYEE_NUMBER` are
    stored in the CTE and used further to insert in `EMPLOYEE_STATUS` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: You can check out more examples in the bundled code named *CteDml* for PostgreSQL.
    Next, let's see how we can embed plain SQL in a CTE.
  prefs: []
  type: TYPE_NORMAL
- en: CTEs and plain SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using plain SQL in CTE is straightforward as you can see in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: You can test this example in the bundled code named *CtePlainSql*. Next, let's
    tackle some common types of CTEs, and let's continue with a query that uses two
    or more CTEs.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining CTEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, a query must exploit more than one CTE. For instance, let''s consider
    the tables `PRODUCTLINE`, `PRODUCT`, and `ORDERDETAIL`. Our goal is to fetch for
    each product line some info (for instance, the description), the total number
    of products, and the total sales. For this, we can write a CTE that joins `PRODUCTLINE`
    with `PRODUCT` and count the total number of products per product line, and another
    CTE that joins `PRODUCT` with `ORDERDETAIL` and computes the total sales per product
    line. Then, both CTEs are used in a `SELECT` to fetch the final result as in the
    following inlined CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code (*CteSimple*), you can see the explicit CTE version as well.
  prefs: []
  type: TYPE_NORMAL
- en: Nested CTEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CTEs can be nested as well. For instance, here we have a "base" CTE that computes
    the employees'' average salary per office. The next two CTEs fetch from the "base"
    CTE the minimum and maximum average respectively. Finally, our query cross-joins
    these CTEs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'The potential output is shown in the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Output of nested CTEs example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_14.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Output of nested CTEs example
  prefs: []
  type: TYPE_NORMAL
- en: In the bundled code (*CteSimple*), you can see the explicit CTE version as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some databases (for instance, MySQL and PostgreSQL) allow you to nest CTEs
    via the `FROM` clause. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: 'So, this is a three-step query: first, we compute the minimum salary per office;
    second, we compute the sum of salaries per minimum salary; and third, we compute
    the average of these sums.'
  prefs: []
  type: TYPE_NORMAL
- en: Materialized CTEs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do you have an expensive CTE that fetches a relatively small result set and
    is used two or more times? Then most probably you have a CTE that you may want
    to materialize. The materialized CTE can then be referenced multiple times by
    the parent query without recomputing the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'In jOOQ, materializing a CTE can be done via `asMaterialized()`. Depending
    on the database, jOOQ will render the proper SQL. For instance, consider the following
    materialized CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: This CTE should be evaluated three times (denoted in code as //1, //2, and //3).
    Hopefully, thanks to `asMaterialized()`, the result of the CTE should be materialized
    and reused instead of being recomputed.
  prefs: []
  type: TYPE_NORMAL
- en: Some databases detect that a CTE is used more than once (the `WITH` clause is
    referenced more than once in the outer query) and automatically try to materialize
    the result set as an optimization fence. For instance, PostgreSQL will materialize
    the above CTE even if we don't use `asMaterialized()` and we simply use `as()`
    because the `WITH` query is called three times.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, PostgreSQL allows us to control the CTE materialization and change the
    default behavior. If we want to force inlining the CTE instead of it being materialized,
    then we add the `NOT MATERIALIZED` hint to the CTE. In jOOQ, this is accomplished
    via `asNotMaterialized()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, in Oracle, we can control materialization via the `/*+ materialize
    */` and `/*+ inline */` hints. Using jOOQ's `asMaterialized()` renders the `/*+
    materialize */` hint, while `asNotMaterialized()` renders the `/*+ inline */`
    hint. Using jOOQ's `as()` doesn't render any hint, so Oracle's optimizer is free
    to act as the default.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, Lukas Eder said: *Note that the Oracle hints aren''t documented, so
    they might change (though all possible Oracle guru blogs document their de facto
    functionality, so knowing Oracle, they won''t break easily). If not explicitly
    documented, there''s never any *guarantee* for any *materialization trick* to
    keep working.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other databases don''t support materialization at all or use it only as an
    internal mechanism of the optimizer (for instance, MySQL). Using jOOQ''s `as()`,
    `asMaterialized()`, and `asNotMaterialized()` renders the same SQL for MySQL,
    therefore we cannot rely on explicit materialization. In such cases, we can attempt
    to rewrite our CTE to avoid recalls. For instance, the previous CTE can be optimized
    to not need materialization in MySQL via `LATERAL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the alternative for SQL Server (like MySQL, SQL Server doesn''t expose
    any support for explicit materialization; however, there is a proposal for Microsoft
    to add a dedicated hint similar to what Oracle has) using `CROSS APPLY` and the
    `VALUES` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: A good cost-based optimizer should always rewrite all SQL statements to the
    optimal execution plan, so what may work today, might not work tomorrow – such
    as this `LATERAL`/`CROSS APPLY` trick. If the optimizer is ever smart enough to
    detect that `LATERAL`/`CROSS APPLY` is unnecessary (for example, because of the
    lack of correlation), then it might be (should be) eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out all these examples in *CteSimple*. Moreover, in the *CteAggRem*
    application, you can practice a CTE for calculating the top N items and aggregating
    (summing) the remainder in a separate row. Basically, while ranking items in the
    database is a common problem to compute top/bottom N items, another common requirement
    that is related to this one is to obtain all the other rows (that don't fit in
    top/bottom N) in a separate row. This is helpful to provide a complete context
    when presenting data.
  prefs: []
  type: TYPE_NORMAL
- en: In the *CteWMAvg* code, you can check out a statistics problem with the main
    goal being to highlight recent points. This problem is known as **Weighted Moving
    Average** (**WMA**). This is part of the moving average family ([https://en.wikipedia.org/wiki/Moving_average](https://en.wikipedia.org/wiki/Moving_average))
    and, in a nutshell, WMA is a moving average where the previous values (points)
    range in the sliding window are given different (fractional) weights.
  prefs: []
  type: TYPE_NORMAL
- en: Recursive CTEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides regular CTEs, we have recursive CTEs.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, recursive CTEs reproduce the concept of for-loops in programming.
    A recursive CTE can handle and explore hierarchical data by referencing themselves.
    Behind a recursive CTE, there are two main members:'
  prefs: []
  type: TYPE_NORMAL
- en: The *anchor* member – Its goal is to select the starting rows of the involved
    recursive steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *recursive* member – Its goal is to generate rows for the CTE. The first
    iteration step acts against the anchor rows, while the second iteration step acts
    against the rows previously created in recursions steps. This member occurs after
    a `UNION ALL` in the CTE definition part. To be more accurate, `UNION ALL` is
    required by a few dialects, but others are capable of recurring with `UNION` as
    well, with slightly different semantics.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In jOOQ, recursive CTEs can be expressed via the `withRecursive()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a simple recursive CTE that computes the famous Fibonacci numbers.
    The *anchor* member is equal to 1, and the *recursive* member applies the Fibonacci
    formula up to the number 20:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that was easy, wasn''t it? Next, let''s tackle a famous problem that
    can be solved via recursive CTE, known as the Travelling Salesman Problem. Consider
    reading more details here: [https://en.wikipedia.org/wiki/Travelling_salesman_problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem).
    In a nutshell, we interpret this problem to find the shortest private flight through
    several cities representing locations of our offices. Basically, in `OFFICE_FLIGHTS`,
    we have the routes between our offices as `OFFICE_FLIGHTS.DEPART_TOWN`, `OFFICE_FLIGHTS.ARRIVAL_TOWN`,
    and `OFFICE_FLIGHTS.DISTANCE_KM`. For instance, our CTE will use *Los Angeles*
    as its anchor city, and then recursively traverse every other city in order to
    reach *Tokyo*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'Some possible output is in the next figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Shortest private flight from Los Angeles to Tokyo, 18,983 km'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_14.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Shortest private flight from Los Angeles to Tokyo, 18,983 km
  prefs: []
  type: TYPE_NORMAL
- en: You can practice these examples in *CteRecursive*.
  prefs: []
  type: TYPE_NORMAL
- en: CTEs and window functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, let''s look at two examples that combine CTE and window functions,
    and let''s start with an example that computes the gaps in IDs. For instance,
    each `EMPLOYEE` has an associated `EMPLOYEE_NUMBER` and we want to find out how
    many values are missing from the data values (missing `EMPLOYEE_NUMBER`), and
    how many existing values are consecutive. This is a job for the `ROW_NUMBER()`
    window and the following CTE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'While you can see this example in the bundled code, let''s look at another
    one that finds the percentile rank of every product line by order values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: You can find these examples along with another one that finds the top three
    highest-valued orders each year in *CteWf*.
  prefs: []
  type: TYPE_NORMAL
- en: Using CTEs to generate data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CTEs are quite handy for generating data – they act as the source of data for
    the SQL statement that uses a CTE. For instance, using a CTE and the `VALUES`
    constructor can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, using a CTE to unnest an array can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, here is an example of unnesting an array to pick up a random value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, maybe you need a random sample from the database (here, 10 random products):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: However, keep in mind that `ORDER BY RAND()` should be avoided for large tables,
    as `ORDER BY` performs with O(N log N).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need more sophisticated sources of data, then probably you''ll be interested
    in generating a series. Here is an example of generating the odd numbers between
    1 and 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example that associates grades between 1 and 100 with the letters
    A to F and counts them as well – in other words, custom binning of grades:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: In the bundled code, you can see more binning examples including custom binning
    of grades via `PERCENT_RANK()`, equal height binning, equal-width binning, the
    PostgreSQL `width_bucket()` function, and binning with a chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'After all these snippets, let''s tackle the following famous problem: Consider
    `p` student classes of certain sizes, and `q` rooms of certain sizes, where `q`>=
    `p`. Write a CTE for assigning as many classes as possible to rooms of proper
    size. Let''s assume that the given data is in the left-hand side figure and the
    expected result is in the right-hand side figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Input and expected output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16833_Figure_14.4.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – Input and expected output
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to solve this problem, we can generate the input data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: The complete query is quite large to be listed here, but you can find it in
    the *CteGenData* application next to all the examples from this section.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic CTEs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Commonly, when we need to dynamically create a CTE, we plan to dynamically
    shape its name, derived table(s), and the outer query. For instance, the following
    method allows us to pass these components as arguments and return the result of
    executing the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a calling sample for solving the problem presented earlier, in the
    *CTEs and window functions* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: 'Whenever you try to implement a CTE, as here, consider this Lukas Eder note:
    *This example uses the DSL in a mutable way, which works but is discouraged. A
    future jOOQ version might turn to an immutable DSL API and this code will stop
    working. It''s unlikely to happen soon, because of the huge backward incompatibility,
    but the discouragement is real already today :) In IntelliJ, you should already
    get a warning in this code, because of the API''s* `@CheckReturnValue` *annotation
    usage, at least in jOOQ 3.15*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if you just need to pass a variable number of CTEs to the
    outer query, then you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: You can practice these examples in *CteDynamic*.
  prefs: []
  type: TYPE_NORMAL
- en: Expressing a query via a derived table, a temporary table, and a CTE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we prefer to express a query in several ways to compare their execution
    plans. For instance, we may have a query and express it via derived tables, temporary
    tables, and CTE to see which approach fits best. Since jOOQ supports these approaches,
    let''s try to express a query starting from the derived tables approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: So, this query returns all employees with above-average sales. For each employee,
    we compare their average sales to the total average sales for all employees. Essentially,
    this query works on the `EMPLOYEE` and `SALE` tables, and we must know the total
    sales for all employees, the number of employees, and the sum of sales for each
    employee.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we extract what we must know in three temporary tables, then we obtain this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: 'Having these three temporary tables, we can rewrite our query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the same query can be expressed via CTE (by replacing `as()` with
    `asMaterialized()`, you can practice the materialization of this CTE):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: Now you just have to run these queries against your database and compare their
    performances and execution plans. The bundled code contains one more example and
    is available as *ToCte*.
  prefs: []
  type: TYPE_NORMAL
- en: Handling views in jOOQ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last section of this chapter is reserved for database views.
  prefs: []
  type: TYPE_NORMAL
- en: A view acts as an actual physical table that can be invoked by name. They fit
    well for reporting tasks or integration with third-party tools that need a guided
    query API. By default, the database vendor decides to materialize the results
    of the view or to rely on other mechanisms to get the same effect. Most vendors
    (hopefully) don't default to materializing views! Views should behave just like
    CTE or derived tables and should be transparent to the optimizer. In most cases
    (in Oracle), we would expect a view to be inlined, even when selected several
    times, because each time, a different predicate might be pushed down into the
    view. Actual materialized views are supported only by a few vendors, while the
    optimizer can decide to materialize the view contents when a view is queried several
    times. The view's definition is stored in the schema tables so it can be invoked
    by name wherever a regular/base table could be used. If the view is updatable,
    then some additional rules come to sustain it.
  prefs: []
  type: TYPE_NORMAL
- en: A view differs by a base, temporary, or derived table in several essential aspects.
    Base and temporary tables accept constraints, while a view doesn't (in most databases).
    A view has no presence in the database until it is invoked, whereas a temporary
    table is persistent. Finally, a derived table has the same scope as the query
    in which it is created. The view definition cannot contain a reference to itself,
    since it does not exist yet, but it can contain references to other views.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax of a view is as follows (for the exact syntax of a certain
    database vendor, you should consult the documentation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: 'Some RDBMS support constraints on views (for instance, Oracle), though with
    limitations: [https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/constraint.html](https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/constraint.html).
    The documented `WITH CHECK OPTION` is actually a constraint.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see some examples of views expressed via jOOQ.
  prefs: []
  type: TYPE_NORMAL
- en: Updatable and read-only views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Views can be either updatable or read-only, but not both. In jOOQ, they can
    be created via the `createView()` and `createViewIfNotExists()` methods. Dropping
    a view can be done via `dropView()`, respectively `dropViewIfExists()`. Here is
    an example of creating a read-only view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: Roughly, in standard SQL, an updatable view is built on only one table; it cannot
    contain `GROUP BY`, `HAVING`, `INTERSECT`, `EXCEPT`, `SELECT DISTINCT`, or `UNION`
    (however, at least in theory, a `UNION` between two disjoint tables, neither of
    which has duplicate rows in itself, should be updatable), aggregate functions,
    calculated columns, and any columns excluded from the view must have `DEFAULT`
    in the base table or be null-able. However, according to the standard SQL T111
    optional feature, joins and unions aren't an impediment to updatability per se,
    so an updatable view doesn't have to be built "on only one table." Also (for the
    avoidance of any doubt), not all columns of an updatable view have to be updatable,
    but of course, only updatable columns can be updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the view is modified, the modifications pass through the view to the corresponding
    underlying base table. In other words, an updatable view has a 1:1 match between
    its rows and the rows of the underlying base table, therefore the previous view
    is not updatable. But we can rewrite it without `UNION ALL` to transform it into
    a valid updatable view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: 'Some views are "partially" updatable. For instance, views that contain `JOIN`
    statements like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: While in PostgreSQL this view is not updatable at all, in MySQL, SQL Server,
    and Oracle, this view is "partially" updatable. In other words, as long as the
    modifications affect only one of the two involved base tables, the view is updatable,
    otherwise, it is not. If more base tables are involved in the update, then an
    error occurs. For instance, in SQL Server, we get an error of *View or function
    'employees_and_sales' is not updatable because the modification affects multiple
    base tables*, while in Oracle, we get *ORA-01776*.
  prefs: []
  type: TYPE_NORMAL
- en: You can check out these examples in *DbViews*.
  prefs: []
  type: TYPE_NORMAL
- en: Types of views (unofficial categorization)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, let's define several common types of views depending on their
    usage, and let's start with views of the type single-table projection and restriction.
  prefs: []
  type: TYPE_NORMAL
- en: Single-table projection and restriction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sometimes, for security reasons, we rely on projections/restrictions of a single
    base table to remove certain rows and/or columns that should not be seen by a
    particular group of users. For instance, the following view represents a projection
    of the `BANK_TRANSACTION` base table to restrict/hide the details about the involved
    banks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: Another type of view tackles computed columns.
  prefs: []
  type: TYPE_NORMAL
- en: Calculated columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Providing summary data is another use case of views. For instance, we prefer
    to compute the columns in as meaningful a way as possible and expose them to the
    clients as views. Here is an example of computing the payroll of each employee
    as salary plus commission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: Another type of view tackles translated columns.
  prefs: []
  type: TYPE_NORMAL
- en: Translated columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Views are also useful for translating codes into texts to increase the readability
    of the fetched result set. A common case is a suite of `JOIN` statements between
    several tables via one or more foreign keys. For instance, in the following view,
    we have a detailed report of customers, orders, and products by translating the
    `CUSTOMER_NUMBER`, `ORDER_ID`, and `PRODUCT_ID` codes (foreign keys):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's tackle grouped views.
  prefs: []
  type: TYPE_NORMAL
- en: Grouped views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A grouped view relies on a query containing a `GROUP BY` clause. Commonly,
    such read-only views contain one or more aggregate functions and they are useful
    for creating different kinds of reports. Here is an example of creating a grouped
    view that fetches big sales per employee:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another example that relies on a grouped view to "flatten out" a one-to-many
    relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's tackle `UNION`-ed views.
  prefs: []
  type: TYPE_NORMAL
- en: UNION-ed views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using `UNION`/`UNION ALL` in views is also a common usage case of views. Here
    is the previous query of flattening one-to-many relationships rewritten via `UNION`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: Finally, let's see an example of nested views.
  prefs: []
  type: TYPE_NORMAL
- en: Nested views
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A view can be built on another view. Pay attention to avoid circular references
    in the query expressions of the views and don't forget that a view must be ultimately
    built on base tables. Moreover, pay attention if you have different updatable
    views that reference the same base table at the same time. Using such views in
    other views may cause ambiguity issues since it is hard to infer what will happen
    if the highest-level view is modified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of using nested views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: The first view, `customer_orders_1`, counts the total orders per customer, and
    the second view, `customer_orders_2`, fetches the name of those customers.
  prefs: []
  type: TYPE_NORMAL
- en: You can see these examples in *DbTypesOfViews*.
  prefs: []
  type: TYPE_NORMAL
- en: Some examples of views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we rely on views to solve several problems. For instance,
    the following view is used to compute the cumulative distribution values by the
    headcount of each office:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the query that uses this view for computing the cumulative distribution
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'Views can be combined with CTE. Here is an example that creates a view on top
    of the CTE for detecting gaps in IDs – a problem tackled earlier, in the *CTE
    and window functions* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: 'The query is straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s see an example that attempts to optimize shipping costs in
    the future based on historical data from *2003*. Let''s assume that we are shipping
    orders with a specialized company that can provide us, on demand, the list of
    trucks with their available periods per year as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: Booking trucks in advance for certain periods takes advantage of certain discounts,
    therefore, based on the orders from 2003, we can analyze some queries that can
    tell us whether this action can optimize shipping costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with a view named `order_truck`, which tells us which trucks are available
    for each order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Based on this view, we can run several queries that provide important information.
    For instance, how many orders can be shipped by each truck?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: Or, how many trucks can ship the same order?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, based on this view, we can create another view named `order_truck_all`
    that can tell us the earliest and latest points in both intervals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: 'Getting the exact points in both intervals can be determined based on the previous
    view as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE769]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE770]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE771]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE772]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE773]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE774]'
  prefs: []
  type: TYPE_PRE
- en: Depending on how deeply we want to analyze the data, we can continue adding
    more queries and views, but I think you've got the idea. You can check out these
    examples in the bundled code, named *DbViewsEx*.
  prefs: []
  type: TYPE_NORMAL
- en: For those that expected to cover table-valued functions here (also called "parameterized
    views") as well, please consider the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, in this chapter, you saw at work several jOOQ methods useful
    to trigger DDL statements, such as `createView()`, `createTemporaryTable()`, and
    so on. Actually, jOOQ provides a comprehensive API for programmatically generating
    DDL that is covered by examples in the bundled code named *DynamicSchema*. Take
    your time to practice those examples and get familiar with them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to express derived tables, CTEs, and views
    in jOOQ. Since these are powerful SQL tools, it is very important to be familiar
    with them, therefore, besides the examples from this chapter, it is advisable
    to challenge yourself and try to solve more problems via jOOQ's DSL.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will tackle stored functions/procedures.
  prefs: []
  type: TYPE_NORMAL
