- en: Building Lightweight Solutions Using Microservices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用微服务构建轻量级解决方案
- en: 'This chapter covers the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下食谱：
- en: Building microservices from a monolith
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从单体应用构建微服务
- en: Building decoupled services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建解耦的服务
- en: Building an automated pipeline for microservices
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为微服务构建自动化流水线
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Microservices** are really one of the top buzzwords nowadays. It''s easy
    to understand why: in a growing software industry where the amount of services,
    data, and users increases crazily, we really need a way to build and deliver faster,
    decoupled, and scalable solutions.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务**确实是当今最热门的 buzzword 之一。很容易理解为什么：在一个不断增长的软件行业中，服务、数据和用户的数量疯狂增长，我们确实需要一种方法来构建和交付更快、解耦和可扩展的解决方案。'
- en: Why are microservices good? Why use them?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么微服务很好？为什么要使用它们？
- en: Actually, with growing demand, the need to deal with each module separately
    has increased. For example, in your customer application, maybe user information
    needs to be scaled in a different way from the address information.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，随着需求的增长，单独处理每个模块的需求也在增加。例如，在你的客户应用程序中，用户信息可能需要以不同于地址信息的方式扩展。
- en: 'In the monolith paradigm, you need to deal with it atomically: you build a
    cluster for the whole application or you scale up (or down) your entire host.
    The problem with this approach is that you can''t focus your effort and resources
    on a specific feature, module, or function: you are always guided by what is needed
    at that moment.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体范式下，你需要原子性地处理它：你为整个应用程序构建一个集群，或者你提升（或降低）整个主机的规模。这种方法的问题是你不能将精力和资源集中在特定的功能、模块或功能上：你总是被当时的需求所引导。
- en: In the microservice approach, you do it separately. Then you can not only scale
    (up or down) one single unit in your application, but you can also separate your
    data for each service (which you should do), separate technology (best tool for
    the best work), and more.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务方法中，你是分开处理的。然后你不仅可以扩展（提升或降低）应用程序中的一个单一单元，而且还可以为每个服务（你应该这样做）分离数据、分离技术（最适合的工具完成最适合的工作），等等。
- en: Other than scale technology, microservices are made to scale people. With a
    bigger application, bigger architecture, and bigger databases, also come bigger
    teams. And if you build your team like a monolith application, you are probably
    getting likely results.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 除了扩展技术，微服务旨在扩展人员。随着应用程序、架构和数据库的增大，团队也会变大。如果你像单体应用程序一样构建团队，你可能会得到类似的结果。
- en: So, as the application is split into a few (or a lot of) modules, you can also
    define cross-functional teams to take care of each module. This means that each
    team can have its own programmer, designer, database administrator, system administrator,
    network specialist, manager, and so on. Each team has responsibility over the
    module it is dealing with.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，随着应用程序被分割成几个（或很多）模块，你也可以定义跨职能团队来负责每个模块。这意味着每个团队都可以拥有自己的程序员、设计师、数据库管理员、系统管理员、网络专家、经理等等。每个团队对其处理的模块都有责任。
- en: It brings agility to the process of thinking about and delivering software,
    and then maintaining and evolving it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 它为思考、交付软件以及维护和演进软件的过程带来了敏捷性。
- en: In this chapter, there are some recipes to help you get started with microservices
    or go deeper into your ongoing project.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，有一些食谱可以帮助你开始使用微服务或更深入地进行你的现有项目。
- en: Building microservices from a monolith
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体应用构建微服务
- en: One common question that I have already heard dozens of times is, *"how do I
    break down my monolith into microservices?",* or, *"how do I migrate from a monolith
    approach to microservices?"*
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经听到过很多次的一个常见问题是，“我该如何将单体应用拆分成微服务？”，或者，“我该如何从单体方法迁移到微服务？”
- en: Well, that's what this recipe is all about.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这正是这个食谱的主题。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For both monolith and microservice projects, we will use the same dependency:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单体和微服务项目，我们将使用相同的依赖项：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's begin by building a monolith to split into microservices.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从构建一个可以拆分成微服务的单体应用开始。
- en: Building a monolith
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建单体应用
- en: First, we need the entities that will represent the data kept by the application.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要代表应用程序保存的数据的实体。
- en: 'Here is the `User` entity:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`User`实体：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here is the `UserAddress` entity:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UserAddress`实体：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we define one bean to deal with the transaction over each entity.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们定义一个bean来处理每个实体的交易。
- en: 'Here is the `UserBean` class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UserBean`类：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here is the `UserAddressBean` class:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UserAddressBean`类：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, we build two services to perform the communication between the client
    and the beans.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们构建两个服务以在客户端和bean之间进行通信。
- en: 'Here is the `UserService` class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UserService`类：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the `UserAddressService` class:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UserAddressService`类：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now let's break it down!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将其分解！
- en: Building microservices from the monolith
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从单体架构构建微服务
- en: 'Our monolith deals with `User` and `UserAddress`. So we will break it down
    into three microservices:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的单体架构处理`User`和`UserAddress`。因此，我们将它分解为三个微服务：
- en: A user microservice
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户微服务
- en: A user address microservice
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户地址微服务
- en: A gateway microservice
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网关微服务
- en: A gateway service is an API between the application client and the services.
    Using it allows you to simplify this communication, also giving you the freedom
    of doing whatever you like with your services without breaking the API contracts
    (or at least minimizing it).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 网关服务是应用程序客户端和服务之间的API。使用它可以使您简化这种通信，同时也给您提供了自由，可以随意处理您的服务，而不会破坏API合约（或者至少最小化它）。
- en: The user microservice
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户微服务
- en: The `User` entity, `UserBean`, and `UserService` will remain exactly as they
    are in the monolith. Only now they will be delivered as a separated unit of deployment.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`实体、`UserBean`和`UserService`将保持与单体架构中完全相同。但现在它们将作为一个独立的部署单元提供。'
- en: The user address microservice
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户地址微服务
- en: The `UserAddress` classes will suffer just a single change from the monolith
    version, but keep their original APIs (that is great from the point of view of
    the client).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserAddress`类将从单体版本中仅经历一个更改，但将保留其原始API（这对于客户端来说是非常好的）。'
- en: 'Here is the `UserAddress` entity:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UserAddress`实体：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that `User` is no longer a property/field in the `UserAddress` entity,
    but only a number (`idUser`). We will get into more details about it in the following
    section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`User`不再是`UserAddress`实体中的一个属性/字段，而只是一个数字（`idUser`）。我们将在下一节中更详细地介绍这一点。
- en: The gateway microservice
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网关微服务
- en: 'First, we create a class that helps us deal with the responses:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个帮助我们处理响应的类：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we create our gateway service:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建我们的网关服务：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we receive the `UserAddress` entity in the gateway, we have to have a version
    of it in the gateway project too. For brevity, we will omit the code, as it is
    the same as in the `UserAddress` project.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在网关中接收到`UserAddress`实体时，我们也要在网关项目中有一个它的版本。为了简洁，我们将省略代码，因为它与`UserAddress`项目中的代码相同。
- en: How it works...
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's understand how things work here.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这里的工作原理。
- en: The monolith
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构
- en: 'The monolith application couldn''t be simpler: just a project with two services
    using two beans to manage two entities. If you want to understand what is happening
    there regarding JAX-RS, CDI, and/or JPA, check the relevant recipes earlier in
    this book.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用程序的结构非常简单：只是一个包含两个服务、使用两个bean来管理两个实体的项目。如果您想了解有关JAX-RS、CDI和/或JPA的细节，请查看本书前面的相关食谱。
- en: The microservices
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: 'So we split the monolith into three projects (microservices): the user service,
    the user address service, and the gateway service.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将单体架构拆分为三个项目（微服务）：用户服务、用户地址服务和网关服务。
- en: The user service classes remained unchanged after the migration from the monolith
    version. So there's nothing to comment on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在从单体版本迁移后，用户服务类保持不变。因此，没有太多可评论的。
- en: The `UserAddress` class had to be changed to become a microservice. The first
    change was made on the entity.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserAddress`类必须更改才能成为微服务。第一个更改是在实体上进行的。'
- en: 'Here is the monolith version:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是单体版本的`UserAddress`：
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here is the microservice version:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是微服务版本的代码：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that in the monolith version, `user` was an instance of the `User` entity:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在单体版本中，`user`是`User`实体的一个实例：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the microservice version, it became a number:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务版本中，它变成了一个数字：
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This happened for two main reasons:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这主要是由于两个主要原因：
- en: In the monolith, we have the two tables in the same database `(User` and `UserAddress`),
    and they both have physical and logical relationships (foreign key). So it makes
    sense to also keep the relationship between both the objects.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单体架构中，我们有两个表位于同一个数据库中（`User`和`UserAddress`），并且它们都有物理和逻辑关系（外键）。因此，保持这两个对象之间的关系也是有意义的。
- en: The microservice should have its own database, completely independent from the
    other services. So we choose to keep only the user ID, as it is enough to load
    the address properly anytime the client needs.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 微服务应该有自己的数据库，完全独立于其他服务。因此，我们选择只保留用户ID，因为当客户端需要加载地址时，这已经足够了。
- en: This change also resulted in a change in the constructor.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改也导致了构造函数的变化。
- en: 'Here is the monolith version:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是单体版本：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here is the microservice version:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是微服务版本：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This could lead to a change of contract with the client regarding the change
    of the constructor signature. But thanks to the way it was built, it wasn't necessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能导致与客户端关于构造函数签名的更改的合同变更。但多亏了它的构建方式，这并不是必要的。
- en: 'Here is the monolith version:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是单体版本：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here is the microservice version:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是微服务版本：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Even if the method is changed, it could easily be solved with `@Path` annotation,
    or if we really need to change the client, it would be only the method name and
    not the parameters (which used to be more painful).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 即使方法被更改，也可以很容易地通过`@Path`注解来解决，或者如果我们真的需要更改客户端，那也仅仅是方法名而不是参数（这曾经更痛苦）。
- en: Finally, we have the gateway service, which is our implementation of the API
    gateway design pattern. Basically it is the one single point to access the other
    services.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有网关服务，这是我们实现的API网关设计模式。基本上，它是访问其他服务的唯一单一点。
- en: The nice thing about it is that your client doesn't need to care about whether
    the other services changed the URL, the signature, or even whether they are available.
    The gateway will take care of them.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好处在于你的客户端不需要关心其他服务是否更改了URL、签名，甚至它们是否可用。网关会处理这些。
- en: The bad part is that it is also on a single point of failure. Or, in other words,
    without the gateway, all services are unreachable. But you can deal with it using
    a cluster, for example.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 坏处在于它也只有一个故障点。或者换句话说，没有网关，所有服务都不可达。但你可以通过集群等方式来处理它。
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Though Java EE is perfect for microservices, there are other options using the
    same bases and that may be a little lighter in some scenarios.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Java EE非常适合微服务，但还有其他基于相同基础的选择，在某些场景下可能更轻量。
- en: One of them is KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/)).
    It's based on Java EE and has many microservice *must-have* features, such as
    service discovery. It won a Duke Choice Awards prize, which is huge!
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/))。它基于Java
    EE，具有许多微服务必备功能，如服务发现。它赢得了Duke Choice Awards奖项，这是一个巨大的成就！
- en: The other one is Payara Micro ([https://www.payara.fish/payara_micro](https://www.payara.fish/payara_micro)).
    Payara is the company that owns a commercial implementation of GlassFish, the
    Payara Server, and from the Payara Server, they created the Payara Fish. The cool
    thing about it is that it is just a 60 MB JAR file that you start using the command
    line and boom! Your microservice is running.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是Payara Micro ([https://www.payara.fish/payara_micro](https://www.payara.fish/payara_micro))。Payara是拥有GlassFish商业实现的Payara公司，从Payara
    Server中，他们创建了Payara Fish。酷的地方在于它只是一个60 MB的JAR文件，你通过命令行启动它，然后！你的微服务就运行起来了。
- en: Finally, the awesome thing about these two projects is that they are aligned
    with the Eclipse MicroProfile project ([http://microprofile.io/](http://microprofile.io/)).
    MicroProfile is defining the path and the standards for microservices in the Java
    EE ecosystem  right now, so it is worth following.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这两个项目的酷之处在于它们与Eclipse MicroProfile项目([http://microprofile.io/](http://microprofile.io/))保持一致。MicroProfile目前正在定义Java
    EE生态系统中微服务的路径和标准，所以值得关注。
- en: 'One last note about the code covered in this recipe: it would be nice in a
    real-world solution to use a DTO to separate the database representation from
    the service one.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个菜谱中涵盖的代码的最后一点：在现实世界的解决方案中使用DTO来分离数据库表示和服务表示会更好。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'The full source code of this recipe can be found in the following repositories:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的完整源代码可以在以下存储库中找到：
- en: '**Monolith**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono)'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单体**：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono)'
- en: '**User microservice**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user)'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户微服务**：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user)'
- en: '**UserAddress microservice**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户地址微服务**：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address)'
- en: '**Gateway microservice**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway)'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网关微服务**：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway)'
- en: Building decoupled services
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建解耦服务
- en: 'Maybe you have, at least heard something about building decoupled things in
    the software world: decoupled classes, decoupled modules, and also decoupled services.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你至少听说过在软件世界中构建解耦事物的概念：解耦的类、解耦的模块，以及解耦的服务。
- en: But what does it mean for a software unit being decoupled from another?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但一个软件单元从另一个解耦意味着什么呢？
- en: In a practical way, two things are coupled when any changes made to one of them
    requires you to also change the other one. For example, if you have a method that
    returns a String and changes it to return a Double, all the methods calling that
    one are required to be changed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 从实际的角度来看，当对其中一个进行任何更改时，需要你同时更改另一个，这两个事物就是耦合在一起的。例如，如果你有一个返回字符串的方法，并将其更改为返回双精度浮点数，那么调用该方法的全部方法都需要进行更改。
- en: There are levels of coupling. For example, you could have all your classes and
    methods very well designed for loose coupling, but they are all written in Java.
    If you change one of them to .NET and would like to keep all of them together
    (in the same deployment package), you need to change all the other ones to the
    new language.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合有层次之分。例如，你可以将所有类和方法设计得非常松散耦合，但它们都是用Java编写的。如果你将其中一个更改为.NET，并且希望将它们全部（在同一部署包中）保留在一起，你需要将其他所有方法更改为新语言。
- en: Another thing to mention about coupling is how much one unit *knows* about the
    other one. They are tightly coupled when they know a lot about each other and
    they are the opposite, loosely coupled, if they know a little or almost nothing
    about each other. This point of view is related mostly to the behavior of two
    (or more) parts.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于耦合的另一件事是，一个单元对另一个单元了解多少。当它们对彼此了解很多时，它们是紧密耦合的，反之，如果它们对彼此了解很少或几乎一无所知，它们就是松散耦合的。这种观点主要与两个（或更多）部分的行为相关。
- en: The last way to look at coupling is in terms of a contract. If changing the
    contract breaks the clients, they are tightly coupled. If not, they are loosely
    coupled. That's why the best way to promote loose coupling is using interfaces.
    As they create contracts for its implementers, using them for communication between
    classes promotes loose coupling.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑耦合的另一种方式是契约。如果更改契约会破坏客户端，那么它们是紧密耦合的。如果不是，它们是松散耦合的。这就是为什么使用接口来促进松散耦合是最好的方式。因为它们为其实施者创建契约，使用它们在类之间进行通信可以促进松散耦合。
- en: Well... what about services? In our case, microservices.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯...服务呢？在我们的案例中，是微服务。
- en: One service is loosely coupled from another one when changing it does not require
    changing the other. You can think about both in terms of behavior or contract.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当更改一个服务时不需要更改另一个服务时，一个服务与另一个服务是松散耦合的。你可以从行为或契约的角度来考虑这两个服务。
- en: This is especially important when talking about microservices, because you can
    have dozens, hundreds, or even thousands of them in your application and if changing
    one of them requires you to change the others, you could just ruin you entire
    application.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到微服务时，这一点尤为重要，因为你的应用程序中可能有成百上千个微服务，如果更改其中一个需要你更改其他所有服务，你可能会破坏整个应用程序。
- en: This recipe will show you how to avoid tight coupling in your microservices,
    from the first line of code, so you can avoid refactoring in the future (at least
    for this reason).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱将向你展示如何在微服务中避免紧密耦合，从第一行代码开始，这样你就可以避免未来的重构（至少出于这个原因）。
- en: Getting ready
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Let''s start by adding our Java EE 8 dependency:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先添加我们的Java EE 8依赖项：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How to do it...
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'First, we create a `User` POJO:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个`User` POJO：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we create a class with two methods (endpoints) for returning `User`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建一个包含两个方法（端点）的类来返回`User`：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we create another service (another project) to consume `UserService`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们创建另一个服务（另一个项目）来消费`UserService`：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As you may have already noticed, we created two situations in this code: one
    clearly coupled (`getUserCoupled`) and another decoupled (`getUserDecoupled`):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能已经注意到的，我们在代码中创建了两种情况：一种是明显耦合的（`getUserCoupled`）另一种是解耦的（`getUserDecoupled`）：
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Why is this a coupled method and thus a coupled service? Because it is highly
    attached to the method signature. Imagine it is a search service and `"name"`
    and `"email"` are filters. Now imagine that sometime in the future you need to
    add another filter. One more parameter in the signature.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这是一个耦合的方法，因此也是一个耦合的服务？因为它高度依赖于方法签名。想象它是一个搜索服务，`"name"`和`"email"`是过滤器。现在想象一下，在未来的某个时候，你需要添加另一个过滤器。签名中再增加一个参数。
- en: OK, you could keep the two methods alive at the same time, so that you wouldn't
    break the client and have to change the clients. How many are there? Mobile, services,
    web pages, and many more. All those need to be changed to support the new feature.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可以同时保留两个方法，这样你就不必打破客户端并更改客户端。有多少个？移动端、服务、网页等等。所有这些都需要更改以支持新功能。
- en: 'Now look at this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this `User` search method, what if you need to add a new parameter to the
    filter? OK, go ahead and add it! No changes in the contract, all clients are happy.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`User`搜索方法中，如果你需要向过滤器中添加一个新参数怎么办？好吧，继续添加！合同没有变化，所有客户端都很高兴。
- en: If your `User` POJO starts with only two properties and ends with a hundred
    after a year, no problem. Your service contract is left untouched and even your
    clients, who are not using the new fields, are still working. Sweet!
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`User` POJO最初只有两个属性，一年后增加到一百个，没问题。你的服务合同保持不变，甚至那些没有使用新字段客户端仍然可以正常工作。太棒了！
- en: 'The result of coupled/decoupled services can be seen in the calling service:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 耦合/解耦服务的结果可以在调用服务中看到：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The calling service is totally coupled to the called one: it has to *know*
    the called service properties'' names and needs to add/update each time it changes.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 调用服务完全耦合到被调用服务：它必须*知道*被调用服务属性的名称，并且每次它改变时都需要添加/更新。
- en: 'Now look at this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看这个：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this case, you only need to refer to the one and only service parameter (`"User"`)
    and it will never change, no matter how the `User` POJO is changed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你只需要引用唯一的服务参数（`"User"`）并且它永远不会改变，无论`User` POJO如何变化。
- en: See also
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: 'See the full source code at the following links:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下链接中查看完整源代码：
- en: '**UserService**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user)'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UserService**：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user)'
- en: '**DoSomethingService**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser)'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DoSomethingService**：[https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser)'
- en: Building an automated pipeline for microservices
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为微服务构建自动化管道
- en: Maybe you are wondering, *"why is there an automation recipe in a Java EE 8
    book?"*, or even, *"is there any specification under Java EE 8 that defines a
    pipeline automation?"*
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你在想，“为什么在Java EE 8书中会有自动化食谱？”或者甚至，“Java EE 8下是否有任何规范定义了管道自动化？”
- en: The answer to the second question is *no*. At least no at this very moment.
    The answer to the first one I'll explain here.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题的答案是*没有*。至少在现在这个时刻是这样的。第一个问题的答案我将在下面解释。
- en: Many times in conferences I am asked the question, *"how do I migrate my monolith
    to microservices?"* It comes in some variations, but at the end of the day the
    question is the same.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多会议上，我经常被问到这样的问题，“我该如何将我的单体应用迁移到微服务？”这个问题有一些变体，但最终问题都是一样的。
- en: 'People want to do it for different reasons:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 人们出于不同的原因想要这样做：
- en: They want to keep up with the trend
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们想要跟上潮流
- en: They want to work with something that looks like a new fashion
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们想要与看起来像新时尚的东西一起工作
- en: They want to scale an application
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们想要扩展应用程序
- en: They want to be able to use different stacks under the same solution
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们希望能够在同一个解决方案下使用不同的技术栈
- en: They want to look cool
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们希望看起来很酷
- en: Any of these reasons are OK and you can justify your migration to microservices
    with any of them, if you want. I would question the real motivation of some of
    them, but...
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 任何这些原因都是可以接受的，如果你想的话，你可以用任何一个理由来证明你的迁移到微服务的合理性。我可能会质疑其中一些人的真实动机，但...
- en: 'Instead of giving them advice, tips, guidelines, or any other tech talk, I
    usually ask a simple question: *"Do you already have an automated pipeline for
    your monolith?"*'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是给他们提供建议、技巧、指南或其他技术讲座，我通常问一个简单的问题：“你已经有了一个用于你的单体的自动化流水线吗？”
- en: Most of the time, the answer is a disappointed "*no"*, followed by a curious, *"why?"*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，答案是失望的“不”，然后是一个好奇的，“为什么？”
- en: 'Well the answer is simple: if you don''t automate the pipeline you, monolith,
    one single package, and sometimes you have problems with it, then what makes you
    think that it will be easier when you have dozens, hundreds, or even thousands
    of deployment files?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，答案很简单：如果你不自动化流水线，你，单体，一个单独的包，有时你会遇到问题，那么你为什么认为当你有几十、几百甚至几千个部署文件时，事情会更容易呢？
- en: 'Let me be more specific:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我更具体地说：
- en: Do you build your deployment artifact manually? Using an IDE or something?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是手动构建部署工件吗？使用IDE或其他工具？
- en: Do you deploy it manually?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是手动部署的吗？
- en: Did you ever have problems with the deployment for any reason such as errors,
    missing artifacts, or anything else?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否因为任何原因（如错误、缺失工件或其他任何原因）遇到过部署问题？
- en: Did you ever have problems due to the lack of tests?
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是否因为缺乏测试而遇到过问题？
- en: If you answered *yes* to at least one of these questions and don't have an automated
    pipeline, imagine these problems multiplied by... again, dozens, hundreds, or
    thousands.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你至少对这些问题中的一个问题回答了“是”，并且没有自动化流水线，想象一下这些问题被成倍放大……又是几十、几百或几千。
- en: Some people don't even write unit tests. Imagine those hidden errors going to
    production in a countless amount of artifacts called microservices. Your microservices
    project will probably fail even before going live.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有些人甚至不写单元测试。想象一下那些隐藏的错误在无数被称为微服务的工件中进入生产。你的微服务项目可能甚至在没有上线之前就会失败。
- en: So yes, you need to automate as many things as possible in your pipeline before
    even thinking of microservices. This is the only way to prevent the problems from
    spreading out.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 所以是的，在考虑微服务之前，你需要尽可能地在你的流水线中自动化尽可能多的东西。这是防止问题扩散的唯一方法。
- en: 'There are three maturity stages for an automation pipeline:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化流水线有三个成熟阶段：
- en: '**Continuous integration** (**CI**): Basically, this ensures that your new
    code will be merged into the main branch (for example, the `master` branch) as
    soon as possible. It is based on the fact that the less code you merge, the fewer
    errors you add to it. It is reached mostly by running unit tests during build
    time.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）：基本上，这确保了你的新代码将尽快合并到主分支（例如，`master`分支）。这是基于这样一个事实：你合并的代码越少，你添加的错误就越少。它主要通过在构建时运行单元测试来实现。'
- en: '**Continuous delivery**: This is one step further from CI, where you guarantee
    your artifact will be ready to be deployed just by a click of a button. This usually
    requires an artifact repository for your binaries and a tool to manage it. When
    using continuous delivery, you decide when you will do the deployment, but the
    best practice is to do it as soon as possible to avoid adding a lot of new code
    in production in just one shot.'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续交付**：这是CI的进一步发展，其中你只需点击一下按钮就可以保证你的工件准备好部署。这通常需要一个用于你的二进制文件的工件存储库和一个管理它的工具。在采用持续交付时，你决定何时进行部署，但最佳实践是尽可能快地进行部署，以避免一次性在生产中添加大量新代码。'
- en: '**Continuous deployment** (**CD**): This is the last, *state-of-the-art* part
    of automation. In CD, there''s no human interaction since the code is committed
    until it is deployed in production. The only thing that would prevent an artifact
    from being deployed is an error in any of the pipeline stages. All the major success
    cases of microservices worldwide use CD in their projects, doing hundreds or even
    thousands of deployments daily.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**持续部署**（**CD**）：这是自动化的最后一部分，也是最前沿的部分。在CD中，从代码提交到部署到生产中，没有人为的交互。唯一可能阻止工件部署的是流水线阶段中的任何错误。全球所有主要的微服务成功案例都在他们的项目中使用了CD，每天进行数百甚至数千次部署。'
- en: This recipe will show you how you can go from zero (no automation at all) to
    three (CD) in any Java EE project. It's little a conceptual recipe, but with also
    some code.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将向你展示你如何将任何Java EE项目从零（完全没有自动化）发展到三（CD）。这是一个概念性的配方，但也包含一些代码。
- en: Don't argue against concepts; they are the key to your career as a Java EE developer.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 不要反对概念；它们是你作为Java EE开发者的职业关键。
- en: '"Going microservices" is a huge thing and means lots of things both in your
    application and organization. Some people even say that microservices are all
    about scaling people, and not technology.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: “走向微服务”是一件大事，在应用程序和组织中意味着很多。有些人甚至说微服务完全是关于扩展人员，而不是技术。
- en: Here we will, of course, keep on the tech side of things.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将在技术方面继续前进。
- en: Getting ready
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Being a lot of things, microservices will also bring a lot of tools with them.
    This recipe doesn't intend to go deep into the setup of each tool, but shows you
    how it will work in a microservices-automated pipeline.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务涉及很多方面，它们也会带来很多工具。这个食谱并不打算深入到每个工具的设置，而是展示它们在微服务自动化管道中的工作方式。
- en: The tools chosen here are not the only option for the roles they perform. They
    are only my favorites for those roles.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这里选择的技术工具并不是执行这些角色的唯一选择。它们只是我在这些角色中的最爱。
- en: Preparing the application
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备应用程序
- en: 'To prepare your application—your microservices—for an automation, you will
    need:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备你的应用程序——你的微服务——进行自动化，你需要：
- en: '**Apache Maven**: This is mainly used to build the stage and it will also help
    you with many activities surrounding it. It manages the dependencies, runs unit
    tests, and many more.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Apache Maven**：这主要用于构建阶段，它还将帮助你处理与之相关的许多活动。它管理依赖项，运行单元测试，等等。'
- en: '**JUnit**: This is used to write unit tests that will be executed at the build
    stage.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JUnit**：这用于编写将在构建阶段执行的单元测试。'
- en: '**Git**: For the sake of the most sacred things you can imagine, use some version
    control for your source code. Here, I''ll base it on GitHub.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Git**：为了想象中最神圣的事物，请为你的源代码使用一些版本控制。在这里，我将基于GitHub。'
- en: Preparing the environment
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备环境
- en: 'To prepare the environment of your pipeline, you will need:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了准备你的管道环境，你需要：
- en: '**Sonatype Nexus**: This is a binary repository. In other words, when you build
    your artifact, it will be stored in Nexus and be ready to be deployed wherever
    you need/want.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sonatype Nexus**：这是一个二进制仓库。换句话说，当你构建你的工件时，它将被存储在Nexus中，并准备好部署到你需要/想要的地方。'
- en: '**Jenkins**: I used to say that Jenkins is an automator for everything. Actually
    I''ve worked in a project where we used it to build an automated pipeline (continuous
    delivery) for about 70 applications, with completely different technologies (languages,
    databases, operation systems, and so on). You will use it basically for building
    and deploying.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins**：我以前说过Jenkins是万能的自动化工具。实际上，我在一个项目中使用它为大约70个应用程序构建了自动化管道（持续交付），这些应用程序使用了完全不同的技术（语言、数据库、操作系统等）。你基本上会使用它来进行构建和部署。'
- en: How to do it...
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'You will be guided to reach each one of the three automation maturity stages:
    continuous integration, continuous delivery, and continuous deployment.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你将指导达到三个自动化成熟阶段：持续集成、持续交付和持续部署。
- en: Continuous integration
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: 'Here, you need to make your new code go to the main branch as soon as possible.
    You will achieve it by using:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要尽快让你的新代码合并到主分支。你可以通过以下方式实现：
- en: Git
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git
- en: Maven
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maven
- en: JUnit
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JUnit
- en: So, you will guarantee that your code is building properly and that the tests
    are planned and executed successfully.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将确保你的代码构建正确，测试计划并成功执行。
- en: Git
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git
- en: 'I''ll not get too deeply into how to use Git and its commands, as it''s not
    the focus of this book. If you are completely new to the Git world, get started
    by looking at this cheat sheet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会深入讲解如何使用Git及其命令，因为这不是本书的重点。如果你是Git世界的完全新手，可以从查看这张速查表开始：
- en: '[https://education.github.com/git-cheat-sheet-education.pdf](https://education.github.com/git-cheat-sheet-education.pdf)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://education.github.com/git-cheat-sheet-education.pdf](https://education.github.com/git-cheat-sheet-education.pdf)'
- en: Maven
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Maven
- en: 'Maven is one of the most powerful tools I''ve ever seen, and thus has a bunch
    of features embedded. If you are new to it, check out this reference:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Maven是我见过的最强大的工具之一，因此它内置了许多功能。如果你是新手，可以查看这个参考：
- en: '[https://maven.apache.org/guides/MavenQuickReferenceCard.pdf](https://maven.apache.org/guides/MavenQuickReferenceCard.pdf)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://maven.apache.org/guides/MavenQuickReferenceCard.pdf](https://maven.apache.org/guides/MavenQuickReferenceCard.pdf)'
- en: 'The most important file in a Maven-based project is the `pom.xml` (**POM**
    stands for **Project Object Model**). For example, when you create a new Java
    EE 8 project, it should look like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在基于Maven的项目中，最重要的文件是`pom.xml`（**POM**代表**项目对象模型**）。例如，当你创建一个新的Java EE 8项目时，它应该看起来像这样：
- en: '[PRE26]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then your project is ready for building using Maven like this (running in the
    same folder where `pom.xml` is located):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你的项目就准备好使用Maven构建了，如下所示（在`pom.xml`所在的同一文件夹中运行）：
- en: '[PRE27]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: JUnit
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JUnit
- en: You will use JUnit to run your unit tests. Let's check it.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用JUnit来运行你的单元测试。让我们检查一下。
- en: 'Here is a class to be tested:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个要测试的类：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is a testing class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个测试类：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Whenever you run the building process for this project, the preceding test will
    be executed and will ensure that those conditions are still valid.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你运行此项目的构建过程时，前面的测试将会执行，并确保这些条件仍然有效。
- en: Now you are ready for continuous integration. Just make sure to merge your new
    and working code into the main branch as soon as possible. Now let's move on to
    continuous delivery.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好进行持续集成。只需确保尽快将你的新代码和有效代码合并到主分支。现在让我们继续到持续交付。
- en: Continuous delivery
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付
- en: Now that you are a committer machine, let's go to the next level and make your
    application ready to deploy whenever you want.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成为一个提交者机器，让我们更进一步，让你的应用程序随时可以部署。
- en: First, you'll need your just-built artifact to be available in a proper repository.
    This is when we use Sonatype Nexus.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要确保你刚刚构建的工件可以在适当的存储库中可用。这就是我们使用Sonatype Nexus的时候。
- en: I won't go into the setup details in this book. One easy way to do it is by
    using Docker containers. You can see more information about it at, [https://hub.docker.com/r/sonatype/nexus/](https://hub.docker.com/r/sonatype/nexus/).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这本书中详细介绍设置细节。一种简单的方法是使用Docker容器。你可以在以下链接中了解更多信息，[https://hub.docker.com/r/sonatype/nexus/](https://hub.docker.com/r/sonatype/nexus/)。
- en: 'Once your Nexus is available, you need to go to the `pom.xml` file and add
    this configuration:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的Nexus可用，你需要转到`pom.xml`文件并添加以下配置：
- en: '[PRE30]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now instead of building, just use the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，不再构建，而是使用以下内容：
- en: '[PRE31]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You''ll do so like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你会这样做：
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: So once your artifact is built, Maven will upload it to Sonatype Nexus. Now
    it is properly stored for future deployment.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一旦你的工件构建完成，Maven将会将其上传到Sonatype Nexus。现在它已经适当地存储起来，以供未来的部署使用。
- en: Now you are almost ready to dance to the automation song. Let's bring Jenkins
    to the party.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你几乎准备好跳起自动化之舞了。让我们把Jenkins带到派对上。
- en: 'As mentioned for Nexus, I will not get into the details about setting up Jenkins.
    I also recommend you do it using Docker. See the following link for details:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如同Nexus所提到的，我不会深入介绍设置Jenkins的细节。我也建议你使用Docker进行设置。有关详细信息，请参阅以下链接：
- en: '[https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)'
- en: 'If you have absolutely no idea on how to use Jenkins, please refer to this
    official guide:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全不知道如何使用Jenkins，请参考此官方指南：
- en: '[https://jenkins.io/user-handbook.pdf](https://jenkins.io/user-handbook.pdf)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://jenkins.io/user-handbook.pdf](https://jenkins.io/user-handbook.pdf)'
- en: 'Once your Jenkins is up and running, you''ll create two jobs:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的Jenkins启动并运行，你将创建两个作业：
- en: '**Your-Project-Build**: This job will be used to build your project from the
    source code.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Your-Project-Build**：这个作业将用于从源代码构建你的项目。'
- en: '**Your-Project-Deploy**: This job will be used to deploy your artifact after
    being built and stored in Nexus.'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Your-Project-Deploy**：这个作业将在工件在Nexus构建和存储后用于部署。'
- en: You will configure the first one to download the source code of your project
    and build it using Maven. The second will download it from Nexus and deploy to
    the application server.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你将配置第一个作业下载你的项目源代码并使用Maven构建它。第二个将从中下载并部署到应用程序服务器。
- en: 'Remember that the deployment process involves some steps in most cases:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，部署过程在大多数情况下涉及一些步骤：
- en: Stop the application server.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止应用程序服务器。
- en: Remove the previous version.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除上一个版本。
- en: Download the new version from Nexus.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Nexus下载新版本。
- en: Deploy the new version.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署新版本。
- en: Start the application server.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序服务器。
- en: So you'd probably create a shell script to be executed by Jenkins. Remember,
    we are automating, so no manual processes.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可能需要创建一个shell脚本，由Jenkins执行。记住，我们正在自动化，所以没有手动过程。
- en: 'Downloading the artifact can be a little tricky, so maybe you could use something
    like this in your shell script:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下载工件可能有点棘手，所以你可能在你的shell脚本中使用类似以下的内容：
- en: '[PRE33]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If everything goes fine until this point, then you''ll have two buttons: one
    for building and another for deploying. You are ready and set to build with no
    need to use any IDE to deploy, and no need to touch the application server.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，那么你将有两个按钮：一个用于构建，另一个用于部署。你已经准备好，无需使用任何IDE进行部署，也无需触摸应用程序服务器。
- en: Now you are sure that both processes (build and deploy) will be executed exactly
    the same way every time. You can now plan them to be executed in a shorter period
    of time.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, now we will move to the next and best step: continuous deployment.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To move from delivery to deployment is a matter of maturity—you need a reliable
    process that ensures only the working code is going into production.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: You already have your code running unit tests on every build. Actually, you
    didn't forget to write unit tests, right?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: On every success, your built artifact is properly stored and you manage the
    right versioning for your application.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: You have mastered the deployment process for your application, dealing properly
    with any condition that might occur. Your application server is never going down
    again without your knowledge and you achieved it with the help of just two buttons!
    Build and deploy. You rock!
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: If you are at this point, your next move shouldn't be a big deal. You only need
    to automate the two jobs so you don't need to hit the button anymore.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In the build job, you'll set it to be executed whenever Jenkins finds any changes
    in the source code repository (check the documentation if you don't know how to
    do it).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is done, there is just one last configuration: make the build step
    on the build job call another job—the deploy job. So any time the build is executed
    successfully, the deploy is also executed right away.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Cheers! You've made it.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, you will not only perform unit tests or API tests. You also need
    to test your UI, if you have one.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: I'd recommend to do it using the Selenium Webdriver. You can find more information
    here, [http://www.seleniumhq.org/docs/03_webdriver.jsp](http://www.seleniumhq.org/docs/03_webdriver.jsp).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you would probably want to deploy your application to a QA environment,
    run the UI tests, and then go into production if everything is fine. So it's just
    a matter of adding some new jobs to your pipeline, now you know how to do it.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code of the JUnit example can be found at, [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-automation](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-automation).
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
