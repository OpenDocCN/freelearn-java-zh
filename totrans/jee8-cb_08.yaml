- en: Building Lightweight Solutions Using Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Building microservices from a monolith
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building decoupled services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an automated pipeline for microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microservices** are really one of the top buzzwords nowadays. It''s easy
    to understand why: in a growing software industry where the amount of services,
    data, and users increases crazily, we really need a way to build and deliver faster,
    decoupled, and scalable solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Why are microservices good? Why use them?
  prefs: []
  type: TYPE_NORMAL
- en: Actually, with growing demand, the need to deal with each module separately
    has increased. For example, in your customer application, maybe user information
    needs to be scaled in a different way from the address information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the monolith paradigm, you need to deal with it atomically: you build a
    cluster for the whole application or you scale up (or down) your entire host.
    The problem with this approach is that you can''t focus your effort and resources
    on a specific feature, module, or function: you are always guided by what is needed
    at that moment.'
  prefs: []
  type: TYPE_NORMAL
- en: In the microservice approach, you do it separately. Then you can not only scale
    (up or down) one single unit in your application, but you can also separate your
    data for each service (which you should do), separate technology (best tool for
    the best work), and more.
  prefs: []
  type: TYPE_NORMAL
- en: Other than scale technology, microservices are made to scale people. With a
    bigger application, bigger architecture, and bigger databases, also come bigger
    teams. And if you build your team like a monolith application, you are probably
    getting likely results.
  prefs: []
  type: TYPE_NORMAL
- en: So, as the application is split into a few (or a lot of) modules, you can also
    define cross-functional teams to take care of each module. This means that each
    team can have its own programmer, designer, database administrator, system administrator,
    network specialist, manager, and so on. Each team has responsibility over the
    module it is dealing with.
  prefs: []
  type: TYPE_NORMAL
- en: It brings agility to the process of thinking about and delivering software,
    and then maintaining and evolving it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, there are some recipes to help you get started with microservices
    or go deeper into your ongoing project.
  prefs: []
  type: TYPE_NORMAL
- en: Building microservices from a monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One common question that I have already heard dozens of times is, *"how do I
    break down my monolith into microservices?",* or, *"how do I migrate from a monolith
    approach to microservices?"*
  prefs: []
  type: TYPE_NORMAL
- en: Well, that's what this recipe is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For both monolith and microservice projects, we will use the same dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's begin by building a monolith to split into microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Building a monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need the entities that will represent the data kept by the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `UserAddress` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we define one bean to deal with the transaction over each entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `UserBean` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `UserAddressBean` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we build two services to perform the communication between the client
    and the beans.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `UserService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the `UserAddressService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now let's break it down!
  prefs: []
  type: TYPE_NORMAL
- en: Building microservices from the monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our monolith deals with `User` and `UserAddress`. So we will break it down
    into three microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: A user microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user address microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A gateway microservice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A gateway service is an API between the application client and the services.
    Using it allows you to simplify this communication, also giving you the freedom
    of doing whatever you like with your services without breaking the API contracts
    (or at least minimizing it).
  prefs: []
  type: TYPE_NORMAL
- en: The user microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `User` entity, `UserBean`, and `UserService` will remain exactly as they
    are in the monolith. Only now they will be delivered as a separated unit of deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The user address microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UserAddress` classes will suffer just a single change from the monolith
    version, but keep their original APIs (that is great from the point of view of
    the client).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the `UserAddress` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that `User` is no longer a property/field in the `UserAddress` entity,
    but only a number (`idUser`). We will get into more details about it in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The gateway microservice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a class that helps us deal with the responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create our gateway service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As we receive the `UserAddress` entity in the gateway, we have to have a version
    of it in the gateway project too. For brevity, we will omit the code, as it is
    the same as in the `UserAddress` project.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's understand how things work here.
  prefs: []
  type: TYPE_NORMAL
- en: The monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The monolith application couldn''t be simpler: just a project with two services
    using two beans to manage two entities. If you want to understand what is happening
    there regarding JAX-RS, CDI, and/or JPA, check the relevant recipes earlier in
    this book.'
  prefs: []
  type: TYPE_NORMAL
- en: The microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So we split the monolith into three projects (microservices): the user service,
    the user address service, and the gateway service.'
  prefs: []
  type: TYPE_NORMAL
- en: The user service classes remained unchanged after the migration from the monolith
    version. So there's nothing to comment on.
  prefs: []
  type: TYPE_NORMAL
- en: The `UserAddress` class had to be changed to become a microservice. The first
    change was made on the entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the monolith version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the microservice version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the monolith version, `user` was an instance of the `User` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the microservice version, it became a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This happened for two main reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: In the monolith, we have the two tables in the same database `(User` and `UserAddress`),
    and they both have physical and logical relationships (foreign key). So it makes
    sense to also keep the relationship between both the objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The microservice should have its own database, completely independent from the
    other services. So we choose to keep only the user ID, as it is enough to load
    the address properly anytime the client needs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This change also resulted in a change in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the monolith version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the microservice version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This could lead to a change of contract with the client regarding the change
    of the constructor signature. But thanks to the way it was built, it wasn't necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the monolith version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the microservice version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Even if the method is changed, it could easily be solved with `@Path` annotation,
    or if we really need to change the client, it would be only the method name and
    not the parameters (which used to be more painful).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have the gateway service, which is our implementation of the API
    gateway design pattern. Basically it is the one single point to access the other
    services.
  prefs: []
  type: TYPE_NORMAL
- en: The nice thing about it is that your client doesn't need to care about whether
    the other services changed the URL, the signature, or even whether they are available.
    The gateway will take care of them.
  prefs: []
  type: TYPE_NORMAL
- en: The bad part is that it is also on a single point of failure. Or, in other words,
    without the gateway, all services are unreachable. But you can deal with it using
    a cluster, for example.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though Java EE is perfect for microservices, there are other options using the
    same bases and that may be a little lighter in some scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: One of them is KumuluzEE ([https://ee.kumuluz.com/](https://ee.kumuluz.com/)).
    It's based on Java EE and has many microservice *must-have* features, such as
    service discovery. It won a Duke Choice Awards prize, which is huge!
  prefs: []
  type: TYPE_NORMAL
- en: The other one is Payara Micro ([https://www.payara.fish/payara_micro](https://www.payara.fish/payara_micro)).
    Payara is the company that owns a commercial implementation of GlassFish, the
    Payara Server, and from the Payara Server, they created the Payara Fish. The cool
    thing about it is that it is just a 60 MB JAR file that you start using the command
    line and boom! Your microservice is running.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the awesome thing about these two projects is that they are aligned
    with the Eclipse MicroProfile project ([http://microprofile.io/](http://microprofile.io/)).
    MicroProfile is defining the path and the standards for microservices in the Java
    EE ecosystem  right now, so it is worth following.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last note about the code covered in this recipe: it would be nice in a
    real-world solution to use a DTO to separate the database representation from
    the service one.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The full source code of this recipe can be found in the following repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monolith**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-mono)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User microservice**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-user)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UserAddress microservice**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-address)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gateway microservice**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-micro_x_mono-micro-gateway)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building decoupled services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maybe you have, at least heard something about building decoupled things in
    the software world: decoupled classes, decoupled modules, and also decoupled services.'
  prefs: []
  type: TYPE_NORMAL
- en: But what does it mean for a software unit being decoupled from another?
  prefs: []
  type: TYPE_NORMAL
- en: In a practical way, two things are coupled when any changes made to one of them
    requires you to also change the other one. For example, if you have a method that
    returns a String and changes it to return a Double, all the methods calling that
    one are required to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: There are levels of coupling. For example, you could have all your classes and
    methods very well designed for loose coupling, but they are all written in Java.
    If you change one of them to .NET and would like to keep all of them together
    (in the same deployment package), you need to change all the other ones to the
    new language.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing to mention about coupling is how much one unit *knows* about the
    other one. They are tightly coupled when they know a lot about each other and
    they are the opposite, loosely coupled, if they know a little or almost nothing
    about each other. This point of view is related mostly to the behavior of two
    (or more) parts.
  prefs: []
  type: TYPE_NORMAL
- en: The last way to look at coupling is in terms of a contract. If changing the
    contract breaks the clients, they are tightly coupled. If not, they are loosely
    coupled. That's why the best way to promote loose coupling is using interfaces.
    As they create contracts for its implementers, using them for communication between
    classes promotes loose coupling.
  prefs: []
  type: TYPE_NORMAL
- en: Well... what about services? In our case, microservices.
  prefs: []
  type: TYPE_NORMAL
- en: One service is loosely coupled from another one when changing it does not require
    changing the other. You can think about both in terms of behavior or contract.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially important when talking about microservices, because you can
    have dozens, hundreds, or even thousands of them in your application and if changing
    one of them requires you to change the others, you could just ruin you entire
    application.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show you how to avoid tight coupling in your microservices,
    from the first line of code, so you can avoid refactoring in the future (at least
    for this reason).
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by adding our Java EE 8 dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we create a `User` POJO:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we create a class with two methods (endpoints) for returning `User`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create another service (another project) to consume `UserService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have already noticed, we created two situations in this code: one
    clearly coupled (`getUserCoupled`) and another decoupled (`getUserDecoupled`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Why is this a coupled method and thus a coupled service? Because it is highly
    attached to the method signature. Imagine it is a search service and `"name"`
    and `"email"` are filters. Now imagine that sometime in the future you need to
    add another filter. One more parameter in the signature.
  prefs: []
  type: TYPE_NORMAL
- en: OK, you could keep the two methods alive at the same time, so that you wouldn't
    break the client and have to change the clients. How many are there? Mobile, services,
    web pages, and many more. All those need to be changed to support the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this `User` search method, what if you need to add a new parameter to the
    filter? OK, go ahead and add it! No changes in the contract, all clients are happy.
  prefs: []
  type: TYPE_NORMAL
- en: If your `User` POJO starts with only two properties and ends with a hundred
    after a year, no problem. Your service contract is left untouched and even your
    clients, who are not using the new fields, are still working. Sweet!
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of coupled/decoupled services can be seen in the calling service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The calling service is totally coupled to the called one: it has to *know*
    the called service properties'' names and needs to add/update each time it changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this case, you only need to refer to the one and only service parameter (`"User"`)
    and it will never change, no matter how the `User` POJO is changed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'See the full source code at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UserService**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-user)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DoSomethingService**: [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-decoupled-dosomethingwithuser)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an automated pipeline for microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Maybe you are wondering, *"why is there an automation recipe in a Java EE 8
    book?"*, or even, *"is there any specification under Java EE 8 that defines a
    pipeline automation?"*
  prefs: []
  type: TYPE_NORMAL
- en: The answer to the second question is *no*. At least no at this very moment.
    The answer to the first one I'll explain here.
  prefs: []
  type: TYPE_NORMAL
- en: Many times in conferences I am asked the question, *"how do I migrate my monolith
    to microservices?"* It comes in some variations, but at the end of the day the
    question is the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'People want to do it for different reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: They want to keep up with the trend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They want to work with something that looks like a new fashion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They want to scale an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They want to be able to use different stacks under the same solution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They want to look cool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any of these reasons are OK and you can justify your migration to microservices
    with any of them, if you want. I would question the real motivation of some of
    them, but...
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of giving them advice, tips, guidelines, or any other tech talk, I
    usually ask a simple question: *"Do you already have an automated pipeline for
    your monolith?"*'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, the answer is a disappointed "*no"*, followed by a curious, *"why?"*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well the answer is simple: if you don''t automate the pipeline you, monolith,
    one single package, and sometimes you have problems with it, then what makes you
    think that it will be easier when you have dozens, hundreds, or even thousands
    of deployment files?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me be more specific:'
  prefs: []
  type: TYPE_NORMAL
- en: Do you build your deployment artifact manually? Using an IDE or something?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do you deploy it manually?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you ever have problems with the deployment for any reason such as errors,
    missing artifacts, or anything else?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Did you ever have problems due to the lack of tests?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you answered *yes* to at least one of these questions and don't have an automated
    pipeline, imagine these problems multiplied by... again, dozens, hundreds, or
    thousands.
  prefs: []
  type: TYPE_NORMAL
- en: Some people don't even write unit tests. Imagine those hidden errors going to
    production in a countless amount of artifacts called microservices. Your microservices
    project will probably fail even before going live.
  prefs: []
  type: TYPE_NORMAL
- en: So yes, you need to automate as many things as possible in your pipeline before
    even thinking of microservices. This is the only way to prevent the problems from
    spreading out.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three maturity stages for an automation pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous integration** (**CI**): Basically, this ensures that your new
    code will be merged into the main branch (for example, the `master` branch) as
    soon as possible. It is based on the fact that the less code you merge, the fewer
    errors you add to it. It is reached mostly by running unit tests during build
    time.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous delivery**: This is one step further from CI, where you guarantee
    your artifact will be ready to be deployed just by a click of a button. This usually
    requires an artifact repository for your binaries and a tool to manage it. When
    using continuous delivery, you decide when you will do the deployment, but the
    best practice is to do it as soon as possible to avoid adding a lot of new code
    in production in just one shot.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous deployment** (**CD**): This is the last, *state-of-the-art* part
    of automation. In CD, there''s no human interaction since the code is committed
    until it is deployed in production. The only thing that would prevent an artifact
    from being deployed is an error in any of the pipeline stages. All the major success
    cases of microservices worldwide use CD in their projects, doing hundreds or even
    thousands of deployments daily.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This recipe will show you how you can go from zero (no automation at all) to
    three (CD) in any Java EE project. It's little a conceptual recipe, but with also
    some code.
  prefs: []
  type: TYPE_NORMAL
- en: Don't argue against concepts; they are the key to your career as a Java EE developer.
  prefs: []
  type: TYPE_NORMAL
- en: '"Going microservices" is a huge thing and means lots of things both in your
    application and organization. Some people even say that microservices are all
    about scaling people, and not technology.'
  prefs: []
  type: TYPE_NORMAL
- en: Here we will, of course, keep on the tech side of things.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being a lot of things, microservices will also bring a lot of tools with them.
    This recipe doesn't intend to go deep into the setup of each tool, but shows you
    how it will work in a microservices-automated pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The tools chosen here are not the only option for the roles they perform. They
    are only my favorites for those roles.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prepare your application—your microservices—for an automation, you will
    need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apache Maven**: This is mainly used to build the stage and it will also help
    you with many activities surrounding it. It manages the dependencies, runs unit
    tests, and many more.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JUnit**: This is used to write unit tests that will be executed at the build
    stage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Git**: For the sake of the most sacred things you can imagine, use some version
    control for your source code. Here, I''ll base it on GitHub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preparing the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To prepare the environment of your pipeline, you will need:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sonatype Nexus**: This is a binary repository. In other words, when you build
    your artifact, it will be stored in Nexus and be ready to be deployed wherever
    you need/want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins**: I used to say that Jenkins is an automator for everything. Actually
    I''ve worked in a project where we used it to build an automated pipeline (continuous
    delivery) for about 70 applications, with completely different technologies (languages,
    databases, operation systems, and so on). You will use it basically for building
    and deploying.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You will be guided to reach each one of the three automation maturity stages:
    continuous integration, continuous delivery, and continuous deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, you need to make your new code go to the main branch as soon as possible.
    You will achieve it by using:'
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, you will guarantee that your code is building properly and that the tests
    are planned and executed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ll not get too deeply into how to use Git and its commands, as it''s not
    the focus of this book. If you are completely new to the Git world, get started
    by looking at this cheat sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://education.github.com/git-cheat-sheet-education.pdf](https://education.github.com/git-cheat-sheet-education.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Maven is one of the most powerful tools I''ve ever seen, and thus has a bunch
    of features embedded. If you are new to it, check out this reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://maven.apache.org/guides/MavenQuickReferenceCard.pdf](https://maven.apache.org/guides/MavenQuickReferenceCard.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important file in a Maven-based project is the `pom.xml` (**POM**
    stands for **Project Object Model**). For example, when you create a new Java
    EE 8 project, it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then your project is ready for building using Maven like this (running in the
    same folder where `pom.xml` is located):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: JUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will use JUnit to run your unit tests. Let's check it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a class to be tested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a testing class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you run the building process for this project, the preceding test will
    be executed and will ensure that those conditions are still valid.
  prefs: []
  type: TYPE_NORMAL
- en: Now you are ready for continuous integration. Just make sure to merge your new
    and working code into the main branch as soon as possible. Now let's move on to
    continuous delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you are a committer machine, let's go to the next level and make your
    application ready to deploy whenever you want.
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need your just-built artifact to be available in a proper repository.
    This is when we use Sonatype Nexus.
  prefs: []
  type: TYPE_NORMAL
- en: I won't go into the setup details in this book. One easy way to do it is by
    using Docker containers. You can see more information about it at, [https://hub.docker.com/r/sonatype/nexus/](https://hub.docker.com/r/sonatype/nexus/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your Nexus is available, you need to go to the `pom.xml` file and add
    this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now instead of building, just use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll do so like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: So once your artifact is built, Maven will upload it to Sonatype Nexus. Now
    it is properly stored for future deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Now you are almost ready to dance to the automation song. Let's bring Jenkins
    to the party.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned for Nexus, I will not get into the details about setting up Jenkins.
    I also recommend you do it using Docker. See the following link for details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have absolutely no idea on how to use Jenkins, please refer to this
    official guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://jenkins.io/user-handbook.pdf](https://jenkins.io/user-handbook.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your Jenkins is up and running, you''ll create two jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Your-Project-Build**: This job will be used to build your project from the
    source code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Your-Project-Deploy**: This job will be used to deploy your artifact after
    being built and stored in Nexus.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You will configure the first one to download the source code of your project
    and build it using Maven. The second will download it from Nexus and deploy to
    the application server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that the deployment process involves some steps in most cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the application server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove the previous version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the new version from Nexus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the new version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the application server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So you'd probably create a shell script to be executed by Jenkins. Remember,
    we are automating, so no manual processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Downloading the artifact can be a little tricky, so maybe you could use something
    like this in your shell script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes fine until this point, then you''ll have two buttons: one
    for building and another for deploying. You are ready and set to build with no
    need to use any IDE to deploy, and no need to touch the application server.'
  prefs: []
  type: TYPE_NORMAL
- en: Now you are sure that both processes (build and deploy) will be executed exactly
    the same way every time. You can now plan them to be executed in a shorter period
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, now we will move to the next and best step: continuous deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To move from delivery to deployment is a matter of maturity—you need a reliable
    process that ensures only the working code is going into production.
  prefs: []
  type: TYPE_NORMAL
- en: You already have your code running unit tests on every build. Actually, you
    didn't forget to write unit tests, right?
  prefs: []
  type: TYPE_NORMAL
- en: On every success, your built artifact is properly stored and you manage the
    right versioning for your application.
  prefs: []
  type: TYPE_NORMAL
- en: You have mastered the deployment process for your application, dealing properly
    with any condition that might occur. Your application server is never going down
    again without your knowledge and you achieved it with the help of just two buttons!
    Build and deploy. You rock!
  prefs: []
  type: TYPE_NORMAL
- en: If you are at this point, your next move shouldn't be a big deal. You only need
    to automate the two jobs so you don't need to hit the button anymore.
  prefs: []
  type: TYPE_NORMAL
- en: In the build job, you'll set it to be executed whenever Jenkins finds any changes
    in the source code repository (check the documentation if you don't know how to
    do it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is done, there is just one last configuration: make the build step
    on the build job call another job—the deploy job. So any time the build is executed
    successfully, the deploy is also executed right away.'
  prefs: []
  type: TYPE_NORMAL
- en: Cheers! You've made it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, you will not only perform unit tests or API tests. You also need
    to test your UI, if you have one.
  prefs: []
  type: TYPE_NORMAL
- en: I'd recommend to do it using the Selenium Webdriver. You can find more information
    here, [http://www.seleniumhq.org/docs/03_webdriver.jsp](http://www.seleniumhq.org/docs/03_webdriver.jsp).
  prefs: []
  type: TYPE_NORMAL
- en: In this case, you would probably want to deploy your application to a QA environment,
    run the UI tests, and then go into production if everything is fine. So it's just
    a matter of adding some new jobs to your pipeline, now you know how to do it.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code of the JUnit example can be found at, [https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-automation](https://github.com/eldermoraes/javaee8-cookbook/tree/master/chapter08/ch08-automation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
