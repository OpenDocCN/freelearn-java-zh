["```java\n    String var = \"hello\"; \n    var = \"new\";\n\n```", "```java\n        public final NotSoImmutable implements Listener { \n          private final int x; \n          public NotSoImmutable(int x, Observable o) { \n            this.x = x; \n            o.registerListener(this); \n          } \n        }\n\n```", "```java\n    public class PersonMutable { \n      private String firstName; \n      private String lastName; \n      private Date birthDate; \n\n      public String getFirstName() { \n        return firstName; \n      } \n\n      public void setFirstName(String firstName) { \n        this.firstName = firstName; \n      } \n\n      public String getLastName() { \n        return lastName; \n      } \n\n      public void setLastName(String lastName) { \n        this.lastName = lastName; \n      } \n      public Date getBirthDate() { \n        return birthDate; \n      } \n\n      public void setBirthDate(Date birthDate) { \n        this.birthDate = birthDate; \n      } \n\n    }\n\n```", "```java\n    public final class PersonImmutable { \n\n      final private String firstName; \n      final private String lastName; \n      final private Date birthDate; \n\n      public PersonImmutable (String firstName, String lastName,\n                              String address, Date birthDate) { \n        this.firstName=firstName; \n        this.lastName=lastName; \n        this.birthDate=birthDate; \n      } \n\n      public String getFirstName() { \n        return firstName; \n      } \n\n      public String getLastName() { \n        return lastName; \n      }\n\n```", "```java\n      public Date getBirthDate() { \n        return new Date(birthDate.getTime()); \n      } \n\n    }\n\n```", "```java\n        public class BadLocks { \n\n          private Lock lock1, lock2; \n\n          public BadLocks(Lock lock1, Lock lock2) { \n            this.lock1=lock1; \n            this.lock2=lock2; \n          } \n\n          public void operation1(){ \n            lock1.lock(); \n            lock2.lock(); \n\n            try { \n              TimeUnit.SECONDS.sleep(2); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } finally { \n              lock2.unlock(); \n              lock1.unlock(); \n            } \n          } \n\n          public void operation2(){ \n            lock2.lock(); \n            lock1.lock(); \n\n            try { \n              TimeUnit.SECONDS.sleep(2); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } finally { \n              lock1.unlock(); \n              lock2.unlock(); \n            } \n          } \n\n        }\n\n```", "```java\n        public class TaskAtomic implements Runnable {\n\n```", "```java\n        private final AtomicInteger number;\n\n```", "```java\n        public TaskAtomic () { \n          this.number=new AtomicInteger(); \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<1000000; i++) { \n            number.set(i); \n          } \n        }\n\n```", "```java\n        public class TaskLock implements Runnable {\n\n```", "```java\n        private Lock lock; \n        private int number;\n\n```", "```java\n        public TaskLock() { \n          this.lock=new ReentrantLock(); \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<1000000; i++) { \n            lock.lock(); \n            number=i; \n            lock.unlock(); \n          } \n\n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        TaskAtomic atomicTask=new TaskAtomic();\n\n```", "```java\n        TaskLock lockTask=new TaskLock();\n\n```", "```java\n        int numberThreads=50; \n        Thread threads[]=new Thread[numberThreads]; \n        Date begin, end;\n\n```", "```java\n        begin=new Date(); \n        for (int i=0; i<numberThreads; i++) { \n          threads[i]=new Thread(lockTask); \n          threads[i].start(); \n        }\n\n```", "```java\n        for (int i=0; i<numberThreads; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } \n        end=new Date(); \n\n        System.out.printf(\"Main: Lock results: %d\\n\",\n                          (end.getTime()-begin.getTime()));\n\n```", "```java\n        begin=new Date(); \n        for (int i=0; i<numberThreads; i++) { \n          threads[i]=new Thread(atomicTask); \n          threads[i].start(); \n        } \n\n        for (int i=0; i<numberThreads; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } \n        end=new Date(); \n\n        System.out.printf(\"Main: Atomic results: %d\\n\",\n                          (end.getTime()-begin.getTime()));\n\n```", "```java\n        public class Operations {\n\n```", "```java\n        public static void readData(){ \n          try { \n            TimeUnit.MILLISECONDS.sleep(500); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        public static void writeData(){ \n          try { \n            TimeUnit.MILLISECONDS.sleep(500); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        public static void processData(){ \n          try { \n            TimeUnit.SECONDS.sleep(2); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        public class Task1 implements Runnable {\n\n```", "```java\n        private final Lock lock;\n\n```", "```java\n        public Task1 (Lock lock) { \n          this.lock=lock; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          lock.lock(); \n          Operations.readData(); \n          Operations.processData(); \n          Operations.writeData(); \n          lock.unlock(); \n        }\n\n```", "```java\n        public class Task2 implements Runnable {\n\n```", "```java\n        private final Lock lock;\n\n```", "```java\n        public Task2 (Lock lock) { \n          this.lock=lock; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          lock.lock(); \n          Operations.readData(); \n          lock.unlock(); \n          Operations.processData(); \n          lock.lock(); \n          Operations.writeData(); \n          lock.unlock(); \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) {\n\n```", "```java\n        Lock lock=new ReentrantLock(); \n        Task1 task1=new Task1(lock); \n        Task2 task2=new Task2(lock); \n        Thread threads[]=new Thread[10];\n\n```", "```java\n        Date begin, end; \n\n        begin=new Date(); \n        for (int i=0; i<threads.length; i++) { \n          threads[i]=new Thread(task1); \n          threads[i].start(); \n        } \n\n        for (int i=0; i<threads.length; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } \n        end=new Date(); \n        System.out.printf(\"Main: First Approach: %d\\n\",\n                          (end.getTime()-begin.getTime()));\n\n```", "```java\n        begin=new Date(); \n        for (int i=0; i<threads.length; i++) { \n          threads[i]=new Thread(task2); \n          threads[i].start(); \n        } \n\n        for (int i=0; i<threads.length; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } \n        end=new Date(); \n        System.out.printf(\"Main: Second Approach: %d\\n\",\n                          (end.getTime()-begin.getTime()));\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        @Override \n        public void run() { \n          int r; \n          for (int i=0; i<1000000; i++) { \n            r=0; \n            r++; \n            r++; \n            r*=r; \n          } \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) {\n\n```", "```java\n        Thread threads[]=new Thread[1000]; \n        Date start,end; \n\n        start=new Date(); \n        for (int i=0; i<threads.length; i++) { \n          Task task=new Task(); \n          threads[i]=new Thread(task); \n          threads[i].start(); \n        } \n\n        for (int i=0; i<threads.length; i++) { \n          try { \n            threads[i].join(); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        } \n        end=new Date(); \n        System.out.printf(\"Main: Threads: %d\\n\",\n                          (end.getTime()-start.getTime()));\n\n```", "```java\n        ThreadPoolExecutor executor=(ThreadPoolExecutor)Executors\n                                                .newCachedThreadPool(); \n\n        start=new Date();\n\n```", "```java\n        for (int i=0; i<threads.length; i++) { \n          Task task=new Task(); \n          executor.execute(task); \n        } \n        executor.shutdown(); \n        try { \n          executor.awaitTermination(1, TimeUnit.DAYS); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n        end=new Date(); \n        System.out.printf(\"Main: Executor: %d\\n\",\n                          (end.getTime()-start.getTime()));\n\n```", "```java\n    public static DBConnection getConnection(){ \n      if (connection==null) { \n        connection=new DBConnection(); \n      } \n      return connection; \n    }\n\n```", "```java\n        public class DBConnectionOK {\n\n```", "```java\n        private DBConnectionOK() { \n          System.out.printf(\"%s: Connection created.\\n\",\n                            Thread.currentThread().getName()); \n        }\n\n```", "```java\n        private static class LazyDBConnection { \n          private static final DBConnectionOK INSTANCE = new\n                                                   DBConnectionOK(); \n        }\n\n```", "```java\n        public static DBConnectionOK getConnection() { \n          return LazyDBConnection.INSTANCE; \n        }\n\n```", "```java\n        public class Task implements Runnable { \n\n          @Override \n          public void run() { \n\n            System.out.printf(\"%s: Getting the connection...\\n\",\n                              Thread.currentThread().getName()); \n            DBConnectionOK connection=DBConnectionOK.getConnection(); \n            System.out.printf(\"%s: End\\n\",\n                              Thread.currentThread().getName()); \n          } \n\n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n            for (int i=0; i<20; i++){ \n              Task task=new Task(); \n              Thread thread=new Thread(task); \n              thread.start(); \n            } \n          }\n\n```", "```java\n        public class TaskFJ extends RecursiveAction {\n\n```", "```java\n        private final int array[];\n\n```", "```java\n        private final int start, end;\n\n```", "```java\n        public TaskFJ(int array[], int start, int end) { \n          this.array=array; \n          this.start=start; \n          this.end=end; \n        }\n\n```", "```java\n        @Override \n        protected void compute() { \n          if (end-start>1000) { \n            int mid=(start+end)/2; \n            TaskFJ task1=new TaskFJ(array,start,mid); \n            TaskFJ task2=new TaskFJ(array,mid,end); \n            task1.fork(); \n            task2.fork(); \n            task1.join(); \n            task2.join();\n\n```", "```java\n        } else { \n          for (int i=start; i<end; i++) { \n            array[i]++; \n            try { \n              TimeUnit.MILLISECONDS.sleep(1); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } \n          } \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final int array[];\n\n```", "```java\n        public Task(int array[]) { \n          this.array=array; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          for (int i=0; i<array.length; i++ ){ \n            array[i]++; \n            try { \n              TimeUnit.MILLISECONDS.sleep(1); \n            } catch (InterruptedException e) { \n              e.printStackTrace(); \n            } \n          } \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main(String[] args) {\n\n```", "```java\n        int array[]=new int[100000];\n\n```", "```java\n        Task task=new Task(array); \n        ExecutorService executor=Executors.newCachedThreadPool(); \n\n        Date start,end; \n        start=new Date(); \n        executor.execute(task); \n        executor.shutdown(); \n        try { \n          executor.awaitTermination(1, TimeUnit.DAYS); \n        } catch (InterruptedException e) { \n          e.printStackTrace(); \n        } \n        end=new Date(); \n        System.out.printf(\"Main: Executor: %d\\n\",\n                          (end.getTime()-start.getTime()));\n\n```", "```java\n          TaskFJ taskFJ=new TaskFJ(array,1,100000); \n          ForkJoinPool pool=new ForkJoinPool(); \n          start=new Date(); \n          pool.execute(taskFJ); \n          pool.shutdown(); \n          try { \n            pool.awaitTermination(1, TimeUnit.DAYS); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n          end=new Date(); \n          System.out.printf(\"Core: Fork/Join: %d\\n\",\n                            (end.getTime()-start.getTime())); \n        }\n\n```", "```java\n        public class Task implements Runnable {\n\n```", "```java\n        private final Lock lock;\n\n```", "```java\n        public Task (Lock lock) { \n          this.lock=lock; \n        }\n\n```", "```java\n        @Override \n        public void run() { \n          System.out.printf(\"%s: Starting\\n\",\n                            Thread.currentThread().getName());\n\n```", "```java\n        lock.lock();\n\n```", "```java\n        try { \n          criticalSection();\n\n```", "```java\n          System.out.printf(\"%s: Press a key to continue: \\n\",\n                            Thread.currentThread().getName()); \n          InputStreamReader converter = new InputStreamReader\n                                                    (System.in); \n          BufferedReader in = new BufferedReader(converter); \n          String line=in.readLine(); \n        } catch (IOException e) { \n          e.printStackTrace();\n\n```", "```java\n          } finally {          \n            lock.unlock(); \n          } \n        }\n\n```", "```java\n        private void criticalSection() { \n          Random random=new Random(); \n          int wait=random.nextInt(10); \n          System.out.printf(\"%s: Wait for %d seconds\\n\",\n                            Thread.currentThread().getName(),wait); \n          try { \n            TimeUnit.SECONDS.sleep(wait); \n          } catch (InterruptedException e) { \n            e.printStackTrace(); \n          } \n        }\n\n```", "```java\n        public class Main { \n          public static void main(String[] args) {\n\n```", "```java\n        ReentrantLock lock=new ReentrantLock(); \n        for (int i=0; i<10; i++) { \n          Task task=new Task(lock); \n          Thread thread=new Thread(task); \n          thread.start(); \n        }\n\n```", "```java\n        public class Person { \n          private int id; \n          private String firstName; \n          private String lastName; \n          private Date birthDate; \n          private int salary; \n          private double coeficient;\n\n```", "```java\n        public class PersonGenerator { \n          public static List<Person> generatePersonList (int size) { \n            List<Person> ret = new ArrayList<>(); \n\n            String firstNames[] = {\"Mary\",\"Patricia\",\"Linda\",\n                                   \"Barbara\",\"Elizabeth\",\"James\",\n                                   \"John\",\"Robert\",\"Michael\",\"William\"}; \n            String lastNames[] = {\"Smith\",\"Jones\",\"Taylor\",\n                                  \"Williams\",\"Brown\",\"Davies\",\n                                  \"Evans\",\"Wilson\",\"Thomas\",\"Roberts\"}; \n\n            Random randomGenerator=new Random(); \n            for (int i=0; i<size; i++) { \n              Person person=new Person(); \n              person.setId(i); \n              person.setFirstName(firstNames\n                                       [randomGenerator.nextInt(10)]); \n              person.setLastName(lastNames\n                                     [randomGenerator.nextInt(10)]); \n              person.setSalary(randomGenerator.nextInt(100000)); \n              person.setCoeficient(randomGenerator.nextDouble()*10); \n              Calendar calendar=Calendar.getInstance(); \n              calendar.add(Calendar.YEAR, -randomGenerator\n                                                     .nextInt(30)); \n              Date birthDate=calendar.getTime(); \n              person.setBirthDate(birthDate); \n\n              ret.add(person); \n            } \n            return ret; \n          } \n        }\n\n```", "```java\n        public class PersonMapTask extends RecursiveAction {\n\n```", "```java\n        private List<Person> persons; \n        private ConcurrentHashMap<String, ConcurrentLinkedDeque\n                                                <Person>> personMap; \n\n        public PersonMapTask(List<Person> persons, ConcurrentHashMap\n                   <String, ConcurrentLinkedDeque<Person>> personMap) { \n          this.persons = persons; \n          this.personMap = personMap; \n        }\n\n```", "```java\n        protected void compute() { \n\n          if (persons.size() < 1000) { \n\n            for (Person person: persons) { \n              ConcurrentLinkedDeque<Person> personList=personMap\n                     .computeIfAbsent(person.getFirstName(), name -> { \n              return new ConcurrentLinkedDeque<>(); \n              }); \n\n```", "```java\n              personList.add(person); \n            } \n            return; \n          }\n\n```", "```java\n          PersonMapTask child1, child2; \n\n          child1=new PersonMapTask(persons.subList(0,persons.size()/2),\n                                   personMap); \n          child2=new PersonMapTask(persons.subList(persons.size()/2,\n                                                   persons.size()),\n                                   personMap); \n\n            invokeAll(child1,child2);   \n          } \n        }\n\n```", "```java\n        public class Main { \n\n          public static void main (String[] args) { \n            List<Person> persons=PersonGenerator\n                                        .generatePersonList(100000);\n\n```", "```java\n        Date start, end; \n\n        start =  new Date(); \n        Map<String, List<Person>> personsByName = persons\n                                                  .parallelStream() \n        .collect(Collectors.groupingByConcurrent(p -> p\n                                                   .getFirstName())); \n        end = new Date(); \n        System.out.printf(\"Collect: %d - %d\\n\", personsByName.size(),\n                          end.getTime()-start.getTime());\n\n```", "```java\n            start = new Date(); \n            ConcurrentHashMap<String, ConcurrentLinkedDeque<Person>>\n                          forkJoinMap=new ConcurrentHashMap<>(); \n            PersonMapTask personMapTask=new PersonMapTask\n                                            (persons,forkJoinMap); \n            ForkJoinPool.commonPool().invoke(personMapTask); \n            end = new Date(); \n\n            System.out.printf(\"Collect ForkJoinPool: %d - %d\\n\",\n                              forkJoinMap.size(),\n                              end.getTime()-start.getTime()); \n          } \n        }\n\n```"]