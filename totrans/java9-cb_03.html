<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Modular Programming</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Using jdeps to find dependencies in a Java application</li>
<li>Creating a simple modular application</li>
<li>Creating a modular JAR</li>
<li>Using a module JAR with pre-JDK 9 applications</li>
<li>Bottom-up migration</li>
<li>Top-down migration</li>
<li>Using services to create loose coupling between consumer and provider modules</li>
<li>Creating a custom modular runtime image using jlink</li>
<li>Compiling for older platform versions</li>
<li>Creating multirelease JARs</li>
<li>Using Maven to develop a modular application</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Modular programming enables one to organize code into independent, cohesive modules, which can be combined together to achieve the desired functionality. This allows in creating code that is:</p>
<ul>
<li>More cohesive because the modules are built with a specific purpose, so the code that resides there tends to cater to that specific purpose.</li>
<li>Encapsulated because modules can interact with only those APIs that have been made available by the other modules.</li>
<li>Reliable because the discoverability is based on the modules and not on the individual types. This means that if a module is not present, then the dependent module cannot be executed until it is discoverable by the dependent module. This helps in preventing runtime errors.</li>
<li>Loosely coupled. If you use service interfaces, then the module<span> interface</span><span> </span>and the service interface implementation can be loosely coupled. </li>
</ul>
<p>So, the thought process in designing and organizing the code will now involve identifying the modules, code, and configuration files, which go into the module and the packages in which the code is organized within the module. After that, we have to decide the public APIs of the module, thereby making them available for use by dependent modules.</p>
<p>Coming to the development of the Java Platform Module System, it is being governed by <strong>Java Specification Request</strong> (<strong>JSR</strong>) 376 (<a href="https://www.jcp.org/en/jsr/detail?id=376">https://www.jcp.org/en/jsr/detail?id=376</a>). The JSR mentions the need for a module system is to address the following fundamental issues:</p>
<ul>
<li><strong>Reliable configuration</strong>: Developers have long suffered from the brittle, error-prone classpath mechanism for configuring program components. The classpath cannot express relationships between components, so if a necessary component is missing, then that will not be discovered until an attempt is made to use it. The classpath also allows classes in the same package to be loaded from different components, leading to unpredictable behavior and difficult-to-diagnose errors. The proposed specification will allow a component to declare that it depends upon other components as other components depend upon it.</li>
<li><strong>Strong encapsulation</strong>: The access-control mechanism of the Java programming language and the JVM provides no way for a component to prevent other components from accessing its internal packages. The proposed specification will allow a component to declare its packages that are accessible by other components and those that are not.</li>
</ul>
<p>The JSR further goes to list the advantages that result from addressing the preceding issues, as follows:</p>
<ul>
<li><strong>A scalable platform</strong>: The ever-increasing size of the Java SE platform has made it increasingly difficult to use in small devices, despite the fact that many such devices are capable of running an SE-class JVM. The compact profiles introduced in Java SE 8 (JSR 337) help in this regard, but they are not nearly flexible enough. The proposed specification will allow the Java SE platform and its implementations to be decomposed into a set of components that can be assembled by developers into custom configurations that contain only the functionality actually required by an application.</li>
<li><strong>Greater platform integrity</strong>: Casual use of APIs that are internal to Java SE platform implementations is both a security risk and a maintenance burden. The strong encapsulation provided by the proposed specification will allow components that implement the Java SE platform to prevent access to their internal APIs.</li>
<li><strong>Improved performance</strong>: Many ahead-of-time, whole-program optimization techniques can be more effective when it is known that a class can refer only to classes in a few other specific components rather than to any class loaded at runtime. Performance is especially enhanced when the components of an application can be optimized in conjunction with the components that implement the Java SE platform.</li>
</ul>
<p>In this chapter, we will look at few important recipes that will help you get started with modular programming.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using jdeps to find dependencies in a Java application</h1>
                </header>
            
            <article>
                
<p>The first step in modularizing your application is to identify its dependencies. A static analysis tool called <kbd>jdeps</kbd> was introduced in JDK 8 to enable developers to find the dependencies of their applications. There are multiple options supported in the command, which enables developers to check for dependencies to the JDK internal APIs, show the dependencies at the package level, show the dependencies at the class level, and filter the dependencies, among other options. </p>
<p>In this recipe, we will look at how to make use of the <kbd>jdeps</kbd> tool by exploring its functionality and using the multiple command-line options it supports. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We need a sample application, which we can run against the <kbd>jdeps</kbd> command to find its dependencies. So, we thought of creating a very simple application that uses the Jackson API to consume JSON from the REST API: <a href="http://jsonplaceholder.typicode.com/users">http://jsonplaceholder.typicode.com/users</a>.</p>
<p>In the sample code, we also added a call to the deprecated JDK internal API, called <kbd>sun.reflect.Reflection.getCallerClass()</kbd>. This way, we can see how <kbd>jdeps</kbd> helps in finding dependencies to the JDK internal APIs.</p>
<p>The following steps will help you to set up the prerequisites for this recipe:</p>
<ol>
<li>You can get the complete code for the sample from the location, <kbd>chp3/1_json-jackson-sample</kbd>. We have built this code against Java 9 and it compiles well. So, you need not install something other than Java 9 to compile it.</li>
<li>Once you have the code, compile it by using the following:</li>
</ol>
<pre><strong>      #On Linux</strong><br/><strong>      javac -cp 'lib/*' -d classes -sourcepath src $(find src -name *.java)</strong><br/><br/><strong>      #On Windows</strong><br/><strong>      javac -cp lib\*;classes -d classes src\com\packt\model\*.java<br/>      src\com\packt\*.java</strong></pre>
<p style="padding-left: 60px">You will see a warning for the use of an internal API, which you can safely ignore. We added this with a purpose to demonstrate the capability of <kbd>jdeps</kbd>. Now, you should have your compiled class files in the classes directory.</p>
<ol start="3">
<li>You can run the sample program by using the following:</li>
</ol>
<pre><strong>      #On Linux:</strong><br/><strong>      java -cp lib/*:classes/ com.packt.Sample</strong><br/><strong>      #On Windows:</strong><br/><strong>      java -cp lib\*;classes com.packt.Sample</strong></pre>
<ol start="4">
<li>We have provided the <kbd>run.bat</kbd> and <kbd>run.sh</kbd> scripts at <kbd>chp3/1_json-jackson-sample</kbd>. You can compile and run using these scripts as well.</li>
<li>Let's also create a JAR file for this sample so that we can run <kbd>jdeps</kbd> on the JAR file as well:</li>
</ol>
<pre><strong>      jar cvfm sample.jar manifest.mf -C classes .</strong></pre>
<p>A <kbd>sample.jar</kbd> file gets created in the current directory. You can also run the JAR by issuing this command: <kbd>java -jar sample.jar</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>The simplest way to use <kbd>jdeps</kbd> is as follows:</li>
</ol>
<pre> <strong>     jdeps -cp classes/:lib/* classes/com/packt/Sample.class</strong></pre>
<p style="padding-left: 60px">The preceding command is equivalent to the following:</p>
<pre>   <strong>   jdeps -verbose:package -cp classes/:lib/*<br/>      classes/com/packt/Sample.class</strong></pre>
<p style="padding-left: 60px">The output for the preceding code is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="170" width="514" class="alignnone size-full wp-image-1546 image-border" src="assets/b28ed050-3259-48b4-9335-39711bd29a8d.png"/></div>
<p style="padding-left: 60px">In the preceding command, we use <kbd>jdeps</kbd> to list the dependencies for the class file, <span><kbd>Sample.class</kbd>, at the package level</span>. We have to provide <kbd>jdeps</kbd> with the path to search for the dependencies of the code being analyzed. This can be done by setting the <kbd>-classpath</kbd>, <kbd>-cp</kbd>, or <kbd>--class-path</kbd> option of the <kbd>jdeps</kbd> command.</p>
<div class="packt_tip packt_infobox">The <kbd>-verbose:package</kbd> option lists the dependencies at the package level.</div>
<ol start="2">
<li>Let's list the dependencies at the class level:</li>
</ol>
<pre><strong>      jdeps -verbose:class -cp classes/:lib/* <br/></strong><strong>      classes/com/packt/Sample.class</strong></pre>
<p style="padding-left: 60px">The output of the preceding command is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="281" width="497" class="alignnone size-full wp-image-1547 image-border" src="assets/c0bab155-4237-4b6f-ab35-4e24fdbc749d.png"/></div>
<p style="padding-left: 60px">In this case, we make use of the <span><kbd>-verbose:class</kbd> option to list the dependencies at the class level, </span>which is why you can see that the <kbd>com.packt.Sample</kbd> class depends on <kbd>com.packt.model.Company</kbd>, <kbd>java.lang.Exception</kbd>, <kbd>com.fasterxml.jackson.core.type.TypeReference</kbd>, and so on.</p>
<ol start="3">
<li>Let's get the summary of the dependencies:</li>
</ol>
<pre>     <strong> jdeps -summary -cp classes/:lib/* classes/com/packt/Sample.class</strong></pre>
<p style="padding-left: 60px">The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="52" width="283" class="alignnone size-full wp-image-1548 image-border" src="assets/96d306f0-8b73-49b2-8e09-abb1bee38ace.png"/></div>
<ol start="4">
<li>Let's check for the dependency on the JDK internal API:</li>
</ol>
<pre>        <strong>jdeps -jdkinternals -cp classes/:lib/*</strong><br/><strong>        classes/com/packt/Sample.class</strong></pre>
<p style="padding-left: 60px">The following is the output of the preceding command:</p>
<div class="CDPAlignCenter CDPAlign"><img height="189" width="926" class="image-border" src="assets/a4248c94-c0d2-4812-b7db-6b580e43f99a.png"/></div>
<div class="packt_infobox">The StackWalker API is the new API for traversing the call stack, introduced in Java 9. This is the replacement for the <kbd>sun.reflect.Reflection.getCallerClass()</kbd> method. We will discuss this API in <a href="01ba0219-7bd3-4ad9-a856-ac2f81e98057.xhtml">Chapter<span> </span>12</a>,<span> </span><em>Memory Management and Debugging</em>.</div>
<ol start="5">
<li>Let's run the <kbd>jdeps</kbd> on the JAR file, <kbd>sample.jar</kbd>:</li>
</ol>
<pre><strong>      jdeps -s -cp lib/* sample.jar</strong></pre>
<p style="padding-left: 60px">The output we get is the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="161" width="410" class="alignnone size-full wp-image-1549 image-border" src="assets/b60e2fc2-67c7-4bcf-8d66-a89bada43ac1.png"/></div>
<p style="padding-left: 60px">The preceding information obtained after investigating the <kbd>sample.jar</kbd> using <kbd>jdeps</kbd> is quite useful. It clearly states the dependencies of our JAR files and is very useful when we try to migrate this application to a modular application.</p>
<ol start="6">
<li>Let's find if there are any dependencies to a given package name:</li>
</ol>
<pre><strong>      jdeps -p java.util sample.jar</strong></pre>
<p style="padding-left: 60px">The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="27" width="741" class="alignnone size-full wp-image-1550 image-border" src="assets/447a9356-a643-4601-bd92-8a274416237a.png"/></div>
<p style="padding-left: 60px">The <kbd>-p</kbd> option is used to find dependencies on the given package name. So, we get to know that our code depends on the <kbd>java.util</kbd> package. Let's try with some other package name:</p>
<pre><strong>      jdeps -p java.util.concurrent sample.jar</strong></pre>
<p style="padding-left: 60px">There is no output, which means that our code doesn't depend on the <kbd>java.util.concurrent</kbd> package.</p>
<ol start="7">
<li>We would want to run the dependency check only for our code. Yes, this is possible. Suppose we run <kbd>jdeps -cp lib/* sample.jar</kbd>, you will see even the library JARs being analyzed. We wouldn't want that, right? Let's just include the classes of the <kbd>com.packt</kbd> package:</li>
</ol>
<pre><strong>      jdeps -include 'com.packt.*' -cp lib/* sample.jar</strong></pre>
<p style="padding-left: 60px">The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="192" width="932" class="alignnone size-full wp-image-1551 image-border" src="assets/c8431335-f5b2-41ea-b850-f08cdd1e2994.png"/></div>
<ol start="8">
<li>Let's check whether our code is dependent on a specific package:</li>
</ol>
<pre><strong>      jdeps -p 'com.packt.model' sample.jar</strong></pre>
<p style="padding-left: 60px">The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="34" width="879" class="alignnone size-full wp-image-1552 image-border" src="assets/6c967f34-94fb-4550-b88f-8576d8d48846.png"/></div>
<ol start="9">
<li>We can use <kbd>jdeps</kbd> on analyzing the JDK modules. Let's pick the <kbd>java.httpclient</kbd> module for analysis:</li>
</ol>
<pre><strong>      jdeps -m java.httpclient</strong></pre>
<p style="padding-left: 60px">Here is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="416" width="829" class="alignnone size-full wp-image-1553 image-border" src="assets/1cc0e943-a761-4690-befb-24426ef45fb6.png"/></div>
<p style="padding-left: 60px">We can also find whether a given module is dependent on another module by using the <kbd>--require</kbd> option, as follows:</p>
<pre><strong>      jdeps --require java.logging -m java.sql</strong></pre>
<p style="padding-left: 60px">Here is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="113" width="800" class="image-border" src="assets/a8a641e8-d651-4838-9303-c697f5e10bcd.png"/></div>
<p style="padding-left: 60px">In the preceding command, we tried to find out whether the <kbd>java.sql</kbd> module is dependent on the <kbd>java.logging</kbd> module. The output we get is the dependency summary of the <kbd>java.sql</kbd> module and the packages in the <kbd>java.sql</kbd> module, which make use of the code from the <kbd>java.logging</kbd> module.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The <kbd>jdeps</kbd> command<span> </span>is a static class dependency analyzer and is used to analyze the static dependencies of the application and its libraries. The <kbd>jdeps</kbd> command<span> </span>by default shows the package-level dependencies of the input files, which can be <kbd>.class</kbd> files, a directory, or a JAR file. This is configurable and can be changed to show class-level dependencies. There are multiple options available to filter out the dependencies and to specify the class files to be analyzed. We have seen a regular use of the <kbd>-cp</kbd> command-line option. This option is used to provide the locations to search for the analyzed code's dependencies. </p>
<p>We have analyzed the class file, JAR files, and the JDK modules, and we also tried out different options of the <kbd>jdeps</kbd> command. There are a few options, such as <kbd>-e</kbd>, <kbd>-regex</kbd>, <kbd>--regex</kbd>, <kbd>-f</kbd>, <kbd>--filter</kbd>, and <kbd>-include</kbd>, which accept a regular expression (regex). It's important to understand the output of the <kbd>jdeps</kbd> command. There are two parts of information for every class/JAR file being analyzed:</p>
<ol>
<li>The summary of the dependency for the analyzed file (JAR or class file). This consists of the name of the class or the JAR file on the left and the name of the dependent entity on the right. The dependent entity can be a directory, a JAR file, or a JDK module, as follows:</li>
</ol>
<pre><strong>      Sample.class -&gt; classes
      Sample.class -&gt; lib/jackson-core-2.8.4.jar
      Sample.class -&gt; lib/jackson-databind-2.8.4.jar
      Sample.class -&gt; java.base
      Sample.class -&gt; jdk.unsupported</strong></pre>
<ol start="2">
<li>A more verbose dependency information of the contents of the analyzed file at the package or class level ( depending on the command-line options). This consists of three columns: column 1 contains the name of the package/class, column 2 contains the name of the dependent package, and column 3 contains the name of the module/JAR where the dependency is found. A sample output looks like the following:</li>
</ol>
<pre><strong>      com.packt  -&gt; com.fasterxml.jackson.core.type  jackson-core-2.8.4.jar
      com.packt  -&gt; com.fasterxml.jackson.databind   jackson-databind-<br/>                                                     2.8.4.jar
      com.packt  -&gt; com.packt.model                  sample.jar</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>We have seen quite a few options of the <kbd>jdeps</kbd> command. There are a few more related to filtering the dependencies and filtering the classes to be analyzed. Apart from that, there are a few options that deal with module paths.</p>
<p>The following are the options that can be tried out:</p>
<ul>
<li><kbd>-e</kbd>, <kbd>-regex</kbd>, <kbd>--regex</kbd>: These find dependencies matching the given pattern.</li>
<li><kbd>-f</kbd>, <kbd>-filter</kbd>: These exclude dependencies matching the given pattern.</li>
<li><kbd>-filter:none</kbd>: This allows no filtering applied via <kbd>filter:package</kbd> or <kbd>filter:archive</kbd>.</li>
<li><kbd>-filter:package</kbd>: This excludes dependencies within the same package. This is the default option. For example, if we added <kbd>-filter:none</kbd> to <kbd>jdeps sample.jar</kbd>, it would print the dependency of the package to itself.</li>
<li><kbd>-filter:archive</kbd>: This excludes dependencies within the same archive.</li>
<li><kbd>-filter:module</kbd>: This excludes dependencies in the same module.</li>
<li><kbd>-P</kbd>, <kbd>-profile</kbd>: This is used to show the profile of the package, whether it is in compact1, compact2, compact3, or Full JRE.</li>
<li><kbd>-R</kbd>, <kbd>-recursive</kbd>: These recursively traverse all the runtime dependencies; they are equivalent to the <kbd>-filter:none</kbd> option.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a simple modular application</h1>
                </header>
            
            <article>
                
<p>You should be wondering what this modularity is all about and how to create a modular application in Java. In this recipe, we will try to clear the mystery around creating modular applications in Java by walking you through a simple example. Our goal is to show you how to create a modular application; hence, we picked a simple example so as to focus on our goal. </p>
<p>Our example is a simple advanced calculator, which checks whether a number is prime, calculates the sum of prime numbers, checks whether a number is even, and calculates the sum of even and odd numbers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will divide our application into two modules:</p>
<ul>
<li>The <kbd>math.util</kbd> module, which contains the APIs for performing the mathematical calculations</li>
<li>The <kbd>calculator</kbd> module, which launches an advanced calculator</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's implement the APIs in the <kbd>com.packt.math.MathUtil</kbd> <span>class, </span>starting with the <kbd>isPrime(Integer number)</kbd> API:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static Boolean isPrime(Integer number){
     <span> </span><span> </span><span> </span><span> </span><span> </span>if ( number == 1 ) { return false; }
     <span> </span><span> </span><span> </span><span> </span><span> </span>return IntStream.range(2,num).noneMatch(i -&gt; num % i == 0 );
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="2">
<li>The next step is to implement the <kbd>sumOfFirstNPrimes(Integer count)</kbd> API:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static Integer sumOfFirstNPrimes(Integer count){
     <span> </span><span> </span><span> </span><span> </span><span> </span>return IntStream.iterate(1,i -&gt; i+1)
                 <span> </span><span> </span><span> </span><span> </span><span> </span>    .filter(j -&gt; isPrime(j))
                 <span> </span><span> </span><span> </span><span> </span><span> </span>    .limit(count).sum();
 <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="3">
<li>Let's write a function to check whether the number is even:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static Boolean isEven(Integer number){
     <span> </span><span> </span><span> </span><span> </span><span> </span>return number % 2 == 0;
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="4">
<li>The negation of <kbd>isEven</kbd> tells us whether the number is odd. We can have functions to find the sum of the first <em>N</em> even numbers and the first <em>N</em> odd numbers, as shown here:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static Integer sumOfFirstNEvens(Integer count){
     <span> </span><span> </span><span> </span><span> </span><span> </span>return IntStream.iterate(1,i -&gt; i+1)
           <span> </span><span> </span><span> </span><span> </span><span> </span>          .filter(j -&gt; isEven(j))
             <span> </span><span> </span><span> </span><span> </span><span> </span>        .limit(count).sum();
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}<br/><br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static Integer sumOfFirstNOdds(Integer count){
     <span> </span><span> </span><span> </span><span> </span><span> </span>return IntStream.iterate(1,i -&gt; i+1)
          <span> </span><span> </span><span> </span><span> </span><span> </span>           .filter(j -&gt; !isEven(j))
               <span> </span><span> </span><span> </span><span> </span><span> </span>      .limit(count).sum();
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p>We can see in the preceding APIs that the following operations are repeated:</p>
<ul>
<li>An infinite sequence of numbers starting from 1</li>
<li>Filtering the numbers based on some condition</li>
<li>Limiting the stream of numbers to a given count</li>
<li>Finding the sum of numbers thus obtained</li>
</ul>
<p>Based on our observation, we can refactor the preceding APIs and extract these operations into a method, as follows:</p>
<pre>private static Integer computeFirstNSum(Integer count, IntPredicate filter){
  return IntStream.iterate(1,i -&gt; i+1)
                  .filter(filter)
                  .limit(count).sum();
 }</pre>
<p>Here, <span><kbd>count</kbd> is the limit of numbers we need to find the sum of and </span><span><kbd>filter</kbd> is the condition for picking the numbers for summing.</span></p>
<p>Let's rewrite the APIs based on the refactoring we just did:</p>
<pre>public static Integer sumOfFirstNPrimes(Integer count){
  return computeFirstNSum(count, (i -&gt; isPrime(i)));
}<br/><br/>public static Integer sumOfFirstNEvens(Integer count){
  return computeFirstNSum(count, (i -&gt; isEven(i)));
}<br/><br/>public static Integer sumOfFirstNOdds(Integer count){
  return computeFirstNSum(count, (i -&gt; !isEven(i)));
}</pre>
<p>You must be wondering about the following:</p>
<ul>
<li>The <kbd>IntStream</kbd> class and the related chaining of the methods</li>
<li>The use of <kbd>-&gt;</kbd> in the code base</li>
<li>The use of the <kbd>IntPredicate</kbd> class</li>
</ul>
<p>If you are indeed wondering, then you need not worry, as we will cover these things in <a href="039b783d-d283-4205-b3d7-e8ba0baf1c76.xhtml">Chapter</a><span> 4,</span> <em>Going Functional</em> and <a href="ae1e93e7-8167-44cc-98dc-c87cede6e5df.xhtml">Chapter</a><span> 5, <em>Stream Operations and Pipelines</em></span>.</p>
<p>So far, we have seen a few APIs around mathematical computations. These APIs are part of our <kbd>com.packt.math.MathUtil</kbd> class. The complete code for this class can be found at the location, <kbd>chp3/2_simple-modular-math-util/math.util/com/packt/math</kbd>, in the code base downloaded for this book.</p>
<p>Let's make this small utility class part of a module named <kbd>math.util</kbd>. The following are some conventions we use to create a module:</p>
<ol>
<li>Place all the code related to the module under a directory named <kbd>math.util</kbd> and treat this as our module root directory.</li>
<li>In the root folder, place a file by the name <kbd>module-info.java</kbd>.</li>
<li>We then place the packages and the code files under the root directory.</li>
</ol>
<p>What does <kbd>module-info.java</kbd> contain?</p>
<ul>
<li>The name of the module</li>
<li>The packages it exports, that is, makes available for other modules to use</li>
<li>The modules it depends on</li>
<li>The services it uses</li>
<li>The service for which it provides implementation</li>
</ul>
<p>As mentioned in <a href="5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml">Chapter 1</a>, <em>Installation and a Sneak Peek into Java 9</em>,<span> </span>the JDK comes bundled with a lot of modules, that is, the existing Java SDK has been modularized! One of those modules is a module named <kbd>java.base</kbd>. All the user-defined modules implicitly depend (or require) the <kbd>java.base</kbd> module (think of every class implicitly extending the <kbd>Object</kbd> class ).</p>
<p>Our <kbd>math.util</kbd> module doesn't depend on any other module (except, of course, on the <kbd>java.base</kbd> module). However, it makes its API available for other modules (if not, then this module's existence is questionable). Let's go ahead and put this statement into code:</p>
<pre>module math.util{
  exports com.packt.math;
}</pre>
<p>We are telling the Java compiler and runtime that our <kbd>math.util</kbd> module is <em>exporting</em> the code in the <kbd>com.packt.math</kbd> <span>package </span>to any module that depends on <kbd>math.util</kbd>.</p>
<div class="packt_infobox">The code for this module can be found at the location, <kbd>chp3/2_simple-modular-math-util/math.util</kbd>.</div>
<p>Now, let's create another module calculator that uses the <kbd>math.util</kbd> module. This module has a <kbd>Calculator</kbd> class whose work is to accept the user's choice for which mathematical operation to execute and then the inputs required to execute the operation. The user can choose from five available mathematical operations:</p>
<ol>
<li>Prime number check</li>
<li>Even number check</li>
<li>Sum of <em>N</em> primes</li>
<li>Sum of <em>N</em> evens</li>
<li>Sum of <em>N</em> odds</li>
</ol>
<p>Let's see this in code:</p>
<pre>private static Integer acceptChoice(Scanner reader){
  System.out.println("************Advanced Calculator************");
  System.out.println("1. Prime Number check");
  System.out.println("2. Even Number check");
  System.out.println("3. Sum of N Primes");
  System.out.println("4. Sum of N Evens");
  System.out.println("5. Sum of N Odds");
  System.out.println("6. Exit");
  System.out.println("Enter the number to choose operation");
  return reader.nextInt();
}</pre>
<p>Then, for each of the choice, we accept the required inputs and invoke the corresponding <kbd>MathUtil</kbd> API, as follows:</p>
<pre>switch(choice){
  case 1:
    System.out.println("Enter the number");
    Integer number = reader.nextInt();
    if (MathUtil.isPrime(number)){
      System.out.println("The number " + number +" is prime");
    }else{
      System.out.println("The number " + number +" is not prime");
    }
  break;
  case 2:
    System.out.println("Enter the number");
    Integer number = reader.nextInt();
    if (MathUtil.isEven(number)){
      System.out.println("The number " + number +" is even");
    }
  break;
  case 3:
    System.out.println("How many primes?");
    Integer count = reader.nextInt();
    System.out.println(String.format("Sum of %d primes is %d", 
          count, MathUtil.sumOfFirstNPrimes(count)));
  break;
  case 4:
    System.out.println("How many evens?");
    Integer count = reader.nextInt();
    System.out.println(String.format("Sum of %d evens is %d", 
          count, MathUtil.sumOfFirstNEvens(count)));
  break;
  case 5: 
    System.out.println("How many odds?");
    Integer count = reader.nextInt();
    System.out.println(String.format("Sum of %d odds is %d", 
          count, MathUtil.sumOfFirstNOdds(count)));
  break;
}</pre>
<p>The complete code for the <kbd>Calculator</kbd> class can be found at <kbd>chp3/2_simple-modular-math-util/calculator/com/packt/calculator/Calculator.java</kbd>.</p>
<p>Let's create the module definition for our <kbd>calculator</kbd> module in the same way we created for the <kbd>math.util</kbd> module:</p>
<pre>module calculator{
  requires math.util;
}</pre>
<p>In the preceding module definition, we mention that the <kbd>calculator</kbd> module depends on the <kbd>math.util</kbd> module by using the keyword, <kbd>required</kbd>.</p>
<div class="packt_infobox">The code for this module can be found at <kbd>chp3/2_simple-modular-math-util/calculator</kbd>.</div>
<p>Let's now compile the code:</p>
<pre><strong>javac -d mods --module-source-path . $(find . -name "*.java")</strong></pre>
<p>The preceding command has to be executed from <kbd>chp3/2_simple-modular-math-util</kbd>.</p>
<p>Also, you should have the compiled code from across both the modules, <kbd>math.util</kbd> and <kbd>calculator</kbd> in the <kbd>mods</kbd> directory. Was it not quite simple? Just a single command and everything including the dependency between the modules is taken care of by the compiler. We didn't require build tools such as <kbd>ant</kbd> to manage the compilation of modules.</p>
<p>The <kbd>--module-source-path</kbd> command is the new command-line option to <kbd>javac</kbd>, specifying the location of our module source code.</p>
<p>Let's now execute the preceding code: </p>
<pre><strong>java --module-path mods -m calculator/com.packt.calculator.Calculator</strong></pre>
<p>The <kbd>--module-path</kbd> command, similar to <kbd>--classpath</kbd>, is the new command-line option to <kbd>java</kbd>, specifying the location of the compiled modules.</p>
<p>After running the preceding command, you will see the calculator in action:</p>
<div class="CDPAlignCenter CDPAlign"><img height="356" width="235" class="image-border" src="assets/e5375502-61aa-4aa0-9674-3da9489d9171.png"/></div>
<p>Congratulations! With this, we have a simple modular application up and running. </p>
<p>We have provided scripts to test out the code on both Windows and Linux platforms. Please use <kbd>run.bat</kbd> for Windows and <kbd>run.sh</kbd> for Linux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Now that you have been through the example, we will look at how to generalize it so that we can apply the same pattern in all our modules. We followed a particular convention to create the modules:</p>
<pre><strong>|application_root_directory
|--module1_root
|----module-info.java
|----com
|------packt
|--------sample
|----------MyClass.java
|--module2_root
|----module-info.java
|----com
|------packt
|--------test
|----------MyAnotherClass.java</strong></pre>
<p>We place the module-specific code within its folders with a corresponding <kbd>module-info.java</kbd> at the root of the folder. This way, the code is organized well.</p>
<p>Let's look into what <kbd>module-info.java</kbd> can contain. From the Java language specification (<a href="http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html">http://cr.openjdk.java.net/~mr/jigsaw/spec/lang-vm.html</a>), a module declaration is of the following form:</p>
<pre>{Annotation} [open] module ModuleName { {ModuleStatement} }</pre>
<p>Here's the syntax, explained: </p>
<ul>
<li><kbd>{Annotation}</kbd>: This is any annotation of the form <kbd>@Annotation(2)</kbd>.</li>
<li><kbd>open</kbd>: This keyword is optional. An open module makes all its components accessible at runtime via reflection. However, at compile time and runtime, only those components that are explicitly exported are accessible.</li>
<li><kbd>module</kbd>: This is keyword used to declare a module.</li>
<li><kbd>ModuleName</kbd>: This is the name of the module that is a valid Java identifier with a permissible dot (<kbd>.</kbd>) between the identifier names--similar to <kbd>math.util</kbd>.</li>
<li><span><span><kbd>{ModuleStatement}</kbd>: This is a collection of the permissible statements within a module definition. Let's expand this next.</span></span></li>
</ul>
<p>A module statement is of the following form: </p>
<pre>ModuleStatement:
  requires {RequiresModifier} ModuleName ;
  exports PackageName [to ModuleName {, ModuleName}] ;
  opens PackageName [to ModuleName {, ModuleName}] ;
  uses TypeName ;
  provides TypeName with TypeName {, TypeName} ;</pre>
<p>The module statement is decoded here:</p>
<ul>
<li><kbd>requires</kbd>: This is used to declare a dependency on a module. <kbd>{<span>RequiresModifier</span>}</kbd> can be <strong>transitive</strong>, <strong>static</strong>, or both. Transitive means that any module that depends on the given module also implicitly depends on the module that is required by the given module transitively. Static means that the module dependence is mandatory at compile time, but optional at runtime. Some examples are <kbd>requires math.util</kbd>, <kbd>requires transitive math.util</kbd>, and <kbd>requires static math.util</kbd>.</li>
<li><kbd>exports</kbd>: This is used to make the given packages accessible to the dependent modules. Optionally, we can force the package accessibility to specific modules by specifying the module name, such as <kbd>exports com.package.math to claculator</kbd>. </li>
<li><span><kbd>opens</kbd>: This is used to open a specific package. We saw earlier that we can open a module by specifying the <kbd>open</kbd> keyword with the module declaration. But this can be less restrictive. So, to make it more restrictive, we can open a specific package for reflective access at runtime by using the <kbd>opens</kbd> keyword: <kbd>opens com.packt.math</kbd>.</span></li>
<li><kbd>uses</kbd>: This is used to declare a dependency on a service interface that is accessible via <kbd>java.util.ServiceLoader</kbd>. The service interface can be in the current module or in any module that the current module depends on.</li>
<li><kbd>provides</kbd>: This is used to declare a service interface and provide it with at least one implementation. The service interface can be declared in the current module or in any other dependent module. However, the service implementation must be provided in the same module; otherwise, a compile-time error would occur.</li>
</ul>
<p>We will look at the <kbd>uses</kbd> and <kbd>provides</kbd> clauses in more detail in our recipe, <em>Using services to create loose coupling between consumer and provider modules</em>.</p>
<p>The module source of all modules can be compiled at once using the <kbd>--module-source-path</kbd> command-line option. This way, all the modules will be compiled and placed in their corresponding directories under the directory provided by the <kbd>-d</kbd> option. For example, <kbd>javac -d mods --module-source-path . $(find . -name "*.java")</kbd>  compiles the code in the current directory into a <kbd>mods</kbd> directory.</p>
<p>Running the code is equally simple. We specify the path where all our modules are compiled into, using the command-line option, <kbd>--module-path</kbd>. Then, we mention the module name along with the fully qualified main class name using the command-line option, <kbd>-m</kbd>, for example, <kbd>java --module-path mods -m calculator/com.packt.calculator.Calculator</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>Look at the recipe, <em>Compiling and running a Java application</em> from <a href="5cd0711b-a2f8-4129-9ec2-e80e4a0cf8db.xhtml">Chapter 1</a>, <em>Installation and a Sneak Peek into Java 9</em>,<span> </span>where we try out another modular application. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a modular JAR</h1>
                </header>
            
            <article>
                
<p>Compiling modules into a class is good, but it is not suitable for sharing binaries and deployment. JARs are better formats for sharing and deployment. We can package the compiled module into JARs, and the JARs that contain <kbd>module-info.class</kbd> at its top level are called <strong>modular JARs</strong>. In this recipe, we will look at how to create modular JARs, and we'll also look at how to execute the application, which is composed of multiple modular JARs</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We have seen and created a simple modular application in the recipe, <em>Creating a simpler modular application</em>. In order to build a modular JAR, we will make use of the sample code available at <kbd>chp3/3_modular_jar</kbd>. This sample code contains two modules: <kbd>math.util</kbd> and <kbd>calculator</kbd>. We will create modular JARs for both the modules. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Compile the code and place the compiled classes in a directory, say <kbd>mods</kbd>:</li>
</ol>
<pre><strong>      javac -d mods --module-source-path . $(find . -name *.java)</strong></pre>
<ol start="2">
<li>Build a modular JAR for the <kbd>math.util</kbd> module:</li>
</ol>
<pre><span> </span><span> </span><span> </span><strong>   jar --create --file=mlib/math.util@1.0.jar --module-version 1.0<br/><span> </span><span> </span><span> </span><span> </span><span> </span> -C mods/math.util .</strong></pre>
<div class="packt_tip packt_infobox">Do not forget the dot (<kbd>.</kbd>) in the end in the preceding code. </div>
<ol start="3">
<li>Build a modular JAR for the <kbd>calculator</kbd> module, specifying the main class to make the JAR executable:</li>
</ol>
<pre><strong>      jar --create --file=mlib/calculator@1.0.jar --module-version 1.0 <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>--main-class com.packt.calculator.Calculator -C mods/calculator .</strong></pre>
<p style="padding-left: 60px">The critical piece in the preceding command is the <kbd>--main-class</kbd> option. This enables us to execute the JAR without providing the main class information during execution.</p>
<ol start="4">
<li>Now we have two JARs in the <kbd>mlib</kbd> <span>directory:</span> <kbd>math.util@1.0.jar</kbd> and <kbd>calculator@1.0.jar</kbd>. These JARs are called modular JARs. If you want to run the example, you can use the following command:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>java -p mlib -m calculator</strong></pre>
<p>A new command-line option for the JAR command has been introduced in Java 9, called <kbd>-d</kbd> or  <kbd>--describe-module</kbd>. This prints the information about the module that the modular JAR contains:</p>
<pre><strong>jar -d --file=mlib/calculator@1.0.jar</strong></pre>
<p>The output of <kbd>jar -d</kbd> for <kbd>calculator@1.0.jar</kbd> is as follows: </p>
<pre><strong>calculator@1.0
  requires mandated java.base
  requires math.util
  conceals com.packt.calculator
  main-class com.packt.calculator.Calculator</strong><br/><br/><strong>jar -d --file=mlib/math.util@1.0.jar</strong></pre>
<p>The output <span>of<span> </span></span><kbd>jar -d</kbd><span><span> </span>for <kbd>math.util@1.0.jar</kbd> is as follows:</span></p>
<pre><strong>math.util@1.0
  requires mandated java.base
  exports com.packt.math</strong></pre>
<p>We have provided the following scripts to try out the recipe code on Windows:</p>
<ul>
<li><kbd>compile-math.bat</kbd></li>
<li><kbd>compile-calculator.bat</kbd></li>
<li><kbd>jar-math.bat</kbd></li>
<li><kbd>jar-calculator.bat</kbd></li>
<li><kbd>run.bat</kbd></li>
</ul>
<p>We have provided the following scripts to try out the recipe code on Linux:</p>
<ul>
<li><kbd>compile.sh</kbd></li>
<li><kbd>jar-math.sh</kbd></li>
<li><kbd>jar-calculator.sh</kbd></li>
<li><kbd>run.sh</kbd></li>
</ul>
<p>You have to run the scripts in the order they have been listed.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using a module JAR with pre-JDK 9 applications</h1>
                </header>
            
            <article>
                
<p>It would be amazing if our modular JARs could be run with pre-JDK 9 applications. This way, we will not be concerned with writing another version of our API for pre-JDK 9 applications. The good news is that we can use our modular JARs just as if they were ordinary JARs, that is, JARs without <kbd>module-info.class</kbd> at its root. We will see how to do so in this recipe.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>For this recipe, we will need a modular jar and a non-modular application. Our modular code can be found at <kbd>chp3/4_modular_jar_with_pre_java9/math.util</kbd> (this is the same <kbd>math.util</kbd> module that we created in our recipe, <em>Creating<span> a</span> simple modular application</em>). Let's compile this modular code and create a modular JAR by using the following commands:</p>
<pre><strong>javac -d classes --module-source-path . $(find math.util -name *.java)
mkdir mlib
jar --create --file mlib/math.util.jar -C classes/math.util .</strong></pre>
<p>We have also provided a <kbd>jar-math.bat</kbd> <span>script </span>at <kbd>chp3/4_modular_jar_with_pre_java9</kbd>, which can be used to create modular JARs on Windows. We have our modular JAR. Let's verify by using the <kbd>-d</kbd> option of the <kbd>jar</kbd> command: </p>
<pre><strong>jar -d --file mlib/math.util@1.0.jar
math.util@1.0
  requires mandated java.base
  exports com.packt.math</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Let's now create a simple application, which is non-modular. Our application will consist of one class named <kbd>NonModularCalculator</kbd>, which borrows its code from the class, <kbd>Calculator</kbd>, in the recipe <em>Creating a simple modular application</em>.</p>
<p>You can find the <kbd>NonModularCalculator</kbd><span> class definition in the <kbd>com.packt.calculator</kbd> package under the directory, </span><kbd>chp3/4_modular_jar_with_pre_java9/calculator</kbd>. As it is non-modular, it doesn't need a <kbd>module-info.java</kbd> file. This application makes use of our modular JAR <span><kbd>math.util.jar</kbd> </span>to execute some mathematical calculations. </p>
<p>At this point, you should have the following:</p>
<ul>
<li>A modular JAR named <kbd>math.util@1.0.jar</kbd></li>
<li>A non-modular application consisting of the <kbd>NonModularCalculator</kbd> package</li>
</ul>
<p>Now we need to compile our <span><kbd>NonModularCalculator</kbd> class:</span></p>
<pre><strong>javac -d classes/ --source-path calculator $(find calculator -name *.java)</strong></pre>
<p>After running the previous command, you will see a list of errors saying that the <kbd>com.packt.math</kbd> package doesn't exist, the <kbd>MathUtil</kbd> <span>symbol cannot be found, </span>and so on. You guessed it right; we missed providing the location of our modular JAR for the compiler. Let's add the modular jar location using the <kbd>--class-path</kbd> option:</p>
<pre><strong>javac --class-path mlib/* -d classes/ --source-path calculator $(find calculator -name *.java)</strong></pre>
<p>Now, we have successfully compiled our non-modular code, which was dependent on the modular JAR. Let's run the compiled code:</p>
<pre><strong>java -cp classes:mlib/* com.packt.calculator.NonModularCalculator</strong></pre>
<p>Congratulations! You have successfully used your modular JAR with a non-modular application. Amazing, right!</p>
<p>We have provided the following scripts at <kbd>chp3/4_modular_jar_with_pre_java9</kbd>  to run the code on the Windows platform:</p>
<ul>
<li><kbd>compile-calculator.bat</kbd></li>
<li><kbd>run.bat</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">See also</h1>
                </header>
            
            <article>
                
<p>We recommend you to try out the following recipes:</p>
<ul>
<li>Creating a simple modular application</li>
<li>Creating a modular JAR</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Bottom-up migration</h1>
                </header>
            
            <article>
                
<p>Now that Java 9 is out of the door, the much-awaited modularity feature is now available to be adopted by developers. At some point or the other, you will be involved in migrating your application to Java 9 and, hence, trying to modularize it. A change of such magnitude, which involves third-party libraries and rethinking of the code structure, would require proper planning and implementation. The Java team has suggested two migration approaches:</p>
<ul>
<li>Bottom-up migration </li>
<li>Top-down migration</li>
</ul>
<p>Before going into learning about bottom-up migration, it's important to understand what unnamed module and automatic module are. Suppose you are accessing a type not available in any of the modules; in such a case, the module system will search for the type on the classpath, and if found, the type becomes part of an unnamed module. This is similar to the classes we write that do not belong to any package, but Java adds them to an unnamed package so as to simplify the creation of new classes. </p>
<p>So, an unnamed module is a catch-all module without a name, which contains all those types that are not part of any modules, but are found in the classpath. An unnamed module can access all the exported types of all the named modules (user-defined modules) and built-in modules (Java platform modules). On the other hand, a named module (user-defined module) will not be able to access the types in the unnamed module. In other words, a named module cannot declare dependency on an unnamed module. If at all you want to declare dependency, how would you do that? An unnamed module doesn't have a name!</p>
<div class="packt_tip">With the concept of unnamed modules, you can take your Java 8 application as is and run it on Java 9 (except for any deprecated internal APIs, which might not be available for user code in Java 9).</div>
<p>You may have seen this if you have tried out the <em>Using jdeps to find dependencies in a Java application</em> recipe, where we had a non-modular application and were able to run it on Java 9. However, running as is on Java 9 would defeat the purpose of introducing the modular system.</p>
<div class="packt_infobox">If a package is defined in both named and unnamed modules, the one in the named module would be given preference over the one in the unnamed module. This helps in preventing conflict of packages when they come from both named and unnamed modules. </div>
<p>Automatic modules are those that are automatically created by the JVM. These modules are created when we introduce the classes packaged in JARs in the module path instead of the classpath. The name of this module will be derived from the name of the JAR without the <kbd>.jar</kbd> extension and, hence, is different from unnamed modules. Alternatively, one can provide the name for these automatic modules by providing the module name against <span><kbd>Automatic-Module-Name</kbd> in the JAR manifest file. </span>These automatic modules export all the packages present in it and also depend on all the automatic and named (user/JDK) modules.</p>
<p>Based on this explanation, modules can be classified into the following:</p>
<div>
<ul>
<li><strong>Unnamed modules</strong>: The code available on classpath and not available on the module path is placed in an unnamed module</li>
<li><strong>Named modules</strong>: all those modules which have a name associated with it - this can be user defined modules and JDK modules.</li>
<li><strong>Automatic modules</strong>: all those modules which are implicitly created by JVM based on the jar files present in the module path</li>
<li><strong>Implicit modules</strong>: modules which are implicitly created. They are same as automatic modules</li>
<li><strong>Explicit modules</strong>: all modules which are created explicitly by user or JDK.</li>
</ul>
</div>
<p>But the unnamed module and automatic module are a good first step to start your migration. So let's get started!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We need a non-modular application which we will eventually modularize. We have already created a simple application whose source code is available at the location <kbd>chp3/6_bottom_up_migration_before</kbd>. This simple application has 3 parts to it:</p>
<ol>
<li>A math utility library which contains our favorite mathematical APIs namely: prime checker, even number checker, sum of primes, sum of evens and sum of odds. The code for this is available at the location <kbd>chp3/6_bottom_up_migration_before/math_util</kbd>.</li>
<li>A banking utility library which contains API to compute simple interest and compound interest. The code for this is available at the location <kbd>chp3/6_bottom_up_migration_before/banking_util</kbd>.</li>
<li>Our calculator app which helps us with our mathematical and banking calculations. To make this more interesting we will output the results in JSON and for this, we will make use of Jackson JSON API. The code for this is available at the location <kbd>chp3/6_bottom_up_migration_before/calculator</kbd>.</li>
</ol>
<p>After you have copied or downloaded the code, we will compile and build respective jars. So use the following commands to compile and build jars:</p>
<pre><strong>#Compiling math util</strong><br/><br/><strong>javac -d math_util/out/classes/ -sourcepath math_util/src $(find math_util/src -name *.java)</strong><br/><strong>jar --create --file=math_util/out/math.util.jar <br/>-C math_util/out/classes/ .</strong><br/><br/><strong>#Compiling banking util</strong><br/><br/><strong>javac -d banking_util/out/classes/ -sourcepath banking_util/src $(find banking_util/src -name *.java)<br/>jar --create --file=banking_util/out/banking.util.jar <br/>-C banking_util/out/classes/ .<br/><br/>#Compiling calculator<br/><br/>javac -cp calculator/lib/*:math_util/out/math.util.jar:banking_util/out/banking.util.jar -d calculator/out/classes/ -sourcepath calculator/src $(find calculator/src -name *.java)</strong></pre>
<p>Let's also create a JAR for this (we make use of the JAR to build the dependency graph but not for running the app)</p>
<pre><strong>jar --create --file=calculator/out/calculator.jar -C calculator/out/classes/ .</strong></pre>
<p>Please note that our Jackson JARs are in the calculator/lib so you need not worry about downloading them. Let's run our calculator using the command:</p>
<pre><strong>java -cp calculator/out/classes:calculator/lib/*:math_util/out/math.util.jar:banking_util/out/banking.util.jar com.packt.calculator.Calculator</strong></pre>
<p>You will see a menu asking for the choice of operation and then you can play around with different operations. Let's now modularize this application!</p>
<p>We have provided <kbd>package-*.bat</kbd> and run.bat to package and run the application on Windows. And <kbd>package-*.sh</kbd> and <kbd>run.sh</kbd> to package and run the application on Linux.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>The first step in modularizing your application is to understand its dependency graph. Let's create a dependency graph for our application. And for that, we make use of <kbd>jdeps</kbd> tool. If you are wondering what <kbd>jdeps</kbd> tool is, stop right away and read the recipe: <em>Using jdeps to find dependencies in a Java application</em>. OK so let's run the <kbd>jdeps</kbd> tool:</p>
<pre><strong>jdeps -summary -R -cp calculator/lib/*:math_util/out/*:banking_util/out/* calculator/out/calculator.jar</strong></pre>
<p>We are asking <kbd>jdeps</kbd> to give us a summary of the dependencies of our <kbd>calculator.jar</kbd> and then do this recursively for each dependency of <kbd>calculator.jar</kbd>. And the output we get is:</p>
<pre><strong>banking.util.jar -&gt; java.base
calculator.jar -&gt; banking_util/out/banking.util.jar
calculator.jar -&gt; calculator/lib/jackson-databind-2.8.4.jar
calculator.jar -&gt; java.base
calculator.jar -&gt; math_util/out/math.util.jar
jackson-annotations-2.8.4.jar -&gt; java.base
jackson-core-2.8.4.jar -&gt; java.base
jackson-databind-2.8.4.jar -&gt; calculator/lib/jackson-annotations-2.8.4.jar
jackson-databind-2.8.4.jar -&gt; calculator/lib/jackson-core-2.8.4.jar
jackson-databind-2.8.4.jar -&gt; java.base
jackson-databind-2.8.4.jar -&gt; java.logging
jackson-databind-2.8.4.jar -&gt; java.sql
jackson-databind-2.8.4.jar -&gt; java.xml
math.util.jar -&gt; java.base</strong></pre>
<p>The preceding<span> output</span> is not clear, hence we have put the same diagrammatically as shown which<span> is as follows</span>:</p>
<div class="CDPAlignCenter CDPAlign"> <img height="175" width="386" class="image-border" src="assets/1b8dc10e-8e36-4770-9d4d-d19a518440f3.png"/></div>
<p>In bottom-up migration, we start with modularizing the leaf nodes. In our graph the leaf nodes namely <kbd>java.xml</kbd>, <kbd>java.sql</kbd>, <kbd>java.base</kbd> and <kbd>java.logging</kbd> are already modularized. Let's pick to modularize <kbd>banking.util.jar</kbd>.</p>
<div class="packt_infobox">All the code for this recipe is available at the location <kbd>chp3/6_bottom_up_migration_after</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing banking.util.jar</h1>
                </header>
            
            <article>
                
<ol>
<li>Copy <kbd>BankUtil.java</kbd> from <kbd>chp3/6_bottom_up_migration_before/banking_util/src/com/packt/banking</kbd> to the location <kbd>chp3/6_bottom_up_migration_after/src/banking.util/com/packt/banking</kbd>. Two things to take a note of:
<ul>
<li>We have renamed the folder from <kbd>banking_util</kbd> to <kbd>banking.util</kbd>. This is to follow the convention of placing module related code under the folder bearing module name.</li>
<li>We have placed the package directly under the <kbd>banking.util</kbd> folder and not under <kbd>src</kbd>, again this is to follow the convention. And we would be placing all our modules under the <kbd>src</kbd> folder. </li>
</ul>
</li>
<li>Create the module definition file <kbd>module-info.java</kbd> under <kbd>chp3/6_bottom_up_migration_after/src/banking.util</kbd> with the following definition:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module banking.util{   <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>    exports com.packt.banking;
<span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="3">
<li>From within the folder <span><kbd>6_bottom_up_migration_after</kbd>, compile the java code of the modules by running the command:</span></li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>javac -d mods --module-source-path src $(find src -name *.java)</strong></pre>
<ol start="4">
<li>You will see that the java code in the module <kbd>banking.util</kbd> is compiled into the mods directory. </li>
<li>Let's create a modular JAR for this module: </li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>jar --create --file=mlib/banking.util.jar -C mods/banking.util .</strong></pre>
<p>If you are wondering what a modular JAR is, feel free to read through the recipe, <em>Creating a modular JAR</em><strong> </strong>in this chapter.</p>
<p>Now that we have modularized <kbd>banking.util.jar</kbd>, let's use this modular jar in place of the non-modular JAR used in <em>Getting ready</em> section earlier. You should execute the following from the <kbd>6_bottom_up_migration_before</kbd> folder because we haven't yet completely modularized the app.</p>
<pre><strong>java --add-modules ALL-MODULE-PATH --module-path ../6_bottom_up_migration_after/mods/banking.util -cp calculator/out/classes:calculator/lib/*:math_util/out/math.util.jar com.packt.calculator.Calculator</strong></pre>
<div class="packt_infobox">
<p><kbd>--add-modules</kbd> option tells the Java runtime to include the modules either by module name or by predefined constants namely: <kbd>ALL-MODULE-PATH</kbd>, <kbd>ALL-DEFAULT</kbd>, <kbd>ALL-SYSTEM</kbd>. We made use of <kbd>ALL-MODULE-PATH</kbd> to add module which is available on our module path</p>
<p><kbd>--module-path</kbd>  option tells the Java runtime the location of our modules.</p>
</div>
<p><span>You will see that our calculator is running as usual. Try out simple interest calculation, compound interest calculation to check if the <kbd>BankUtil</kbd> class is found. So our dependency graph now looks like:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="198" width="436" class="image-border" src="assets/a6e33359-f3ec-4f7d-b1bd-cff778e74833.png"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing math.util.jar</h1>
                </header>
            
            <article>
                
<ol>
<li>Copy <kbd>MathUtil.java</kbd> from <kbd>chp3/6_bottom_up_migration_before/math_util/src/com/packt/math</kbd> to the location <kbd>chp3/6_bottom_up_migration_after/src/math.util/com/packt/math</kbd>.</li>
<li>Create the module definition file <kbd>module-info.java</kbd> under <kbd>chp3/6_bottom_up_migration_after/src/math.util</kbd> with the following definition:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module math.util{<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>exports com.packt.math;<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="3">
<li>From within the folder <span><kbd>6_bottom_up_migration_after</kbd>, compile the Java code of the modules by running the command:</span></li>
</ol>
<pre><strong>      javac -d mods --module-source-path src $(find src -name *.java)</strong></pre>
<ol start="4">
<li>You will see that the Java code in the module <kbd>math.util</kbd> and <kbd>banking.util</kbd> is compiled into the <kbd>mods</kbd> directory. </li>
<li>Let's create a modular JAR for this module: </li>
</ol>
<pre><strong>      jar --create --file=mlib/math.util.jar -C mods/math.util .</strong></pre>
<p style="padding-left: 60px">If you are wondering what a modular jar is, feel free to read through the recipe, <em>Creating a modular JAR</em> in this chapter.</p>
<ol start="6">
<li>Now that we have modularized <kbd>math.util.jar</kbd>, let's use this modular jar in place of the non-modular jar used in <em>Getting ready</em> section earlier. You should execute the below from the <kbd>6_bottom_up_migration_before</kbd> folder because we haven't yet completely modularized the app:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span>  </span>java --add-modules ALL-MODULE-PATH --module-path<br/> <span> </span><span> </span><span> </span><span> </span><span> </span>../6_bottom_up_migration_after/mods/banking.util:<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>../6_bottom_up_migration_after/mods/math.util <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>-cp calculator/out/classes:calculator/lib/*<br/>      com.packt.calculator.Calculator</strong></pre>
<p>This time as well our app is running fine. And the dependency graph looks like:</p>
<div class="CDPAlignCenter CDPAlign"><img height="169" width="365" class="image-border" src="assets/171013b6-8812-4c30-b072-dfa719db87e4.png"/></div>
<p>We cannot modularize calculator.jar because it depends on one another non-modular code jackson-databind. And we cannot modularize <kbd>jackson-databind</kbd> as it is not maintained by us. So we cannot achieve 100% modularity for our application. We introduced you to Unnamed modules at the beginning of this recipe. All our non-modular code in the classpath are grouped in unnamed modules which means all jackson related code can still remain in the unnamed module and we can try to modularize <kbd>calculator.jar</kbd>. But we cannot do so because <kbd>calculator.jar</kbd> cannot declare dependency on <kbd>jackson-databind-2.8.4.jar</kbd> (because it is an unnamed module and named modules cannot declare dependency on unnamed modules). </p>
<p>A way to get around this is to make the jackson related code as automatic modules. We can do this by moving the jars related to jackson namely: </p>
<ul>
<li><kbd>jackson-databind-2.8.4.jar</kbd></li>
<li><kbd>jackson-annotations-2.8.4.jar</kbd></li>
<li><kbd>jackson-core-2.8.4.jar</kbd></li>
</ul>
<p>To our mods folder under the folder <kbd>6_bottom_up_migration_after</kbd> using the following commands:</p>
<pre><strong>$ pwd 
/root/java9-samples/chp3/6_bottom_up_migration_after
$ cp ../6_bottom_up_migration_before/calculator/lib/*.jar mlib/
$ mv mlib/jackson-annotations-2.8.4.jar mods/jackson.annotations.jar
$ mv mlib/jackson-core-2.8.4.jar mods/jackson.core.jar
$ mv mlib/jackson-databind-2.8.4.jar mods/jackson.databind.jar</strong></pre>
<p>The reason for renaming the jars is that the name of the module has to be a valid identifier (should not be only numeric, should not contain <kbd>-</kbd> and other rules) separated with <kbd>.</kbd> and as the names are derived from the name of the JAR files, we had to rename the JAR files to conform to Java identifier rules.</p>
<div class="packt_tip">Create a new <span><kbd>mlib</kbd> </span>directory if it is not present under <span><kbd>6_bottom_up_migration_after</kbd>.</span></div>
<p><span>Let's now run our calculator program again using the command: </span></p>
<pre><strong>java --add-modules ALL-MODULE-PATH --module-path ../6_bottom_up_migration_after/mods:../6_bottom_up_migration_after/mlib -cp calculator/out/classes com.packt.calculator.Calculator</strong></pre>
<p><span>The application will run as usual. You will notice that our <kbd>-cp</kbd> option value is getting smaller as all the dependent libraries have been moved as modules in the module path. The dependency graph now looks like:</span></p>
<div class="CDPAlignCenter CDPAlign"><img height="198" width="429" class="image-border" src="assets/ea7cc038-75e9-4a7e-b9c4-8c44c61a4367.png"/> </div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing calculator.jar</h1>
                </header>
            
            <article>
                
<p>The last step in the migration is to modularize <kbd>calculator.jar</kbd>. Follow the below steps to modularize it:</p>
<ol>
<li>Copy the folder <kbd>com</kbd> from <kbd>chp3/6_bottom_up_migration_before/calculator/src</kbd> to the location <kbd>chp3/6_bottom_up_migration_after/src/calculator</kbd>.</li>
<li>Create the module definition file <kbd>module-info.java</kbd> under <kbd>chp3/6_bottom_up_migration_after/src/calculator</kbd> with the following definition:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module calculator{ <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> requires math.util; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>requires banking.util; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>requires jackson.databind; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>requires jackson.core; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>requires jackson.annotations; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="3">
<li>From within the folder <span><kbd>6_bottom_up_migration_after</kbd>, compile the Java code of the modules by running the command:</span></li>
</ol>
<pre><strong>      javac -d mods --module-path mlib:mods --module-source-path src $(find src -name *.java)</strong></pre>
<ol start="4">
<li>You will see that the Java code in all our modules is compiled into the mods directory. Please note that you should have the automatic modules (that<span> </span>is, jackson related JARs) already placed  in <kbd>mlib</kbd> directory.</li>
<li>Let's create a modular JAR for this module and also mention which is the <kbd>main</kbd> class: </li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>jar --create --file=mlib/calculator.jar --main-<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>class=com.packt.calculator.Calculator -C mods/calculator .</strong></pre>
<ol start="6">
<li>Now we have a modular JAR for our calculator module which is our main module as it contains the <kbd>main</kbd> class. With this, we have also modularized our complete application. Let's run the following command from the folder: <kbd>6_bottom_up_migration_after</kbd>:</li>
</ol>
<pre><strong>      java -p mlib:mods -m calculator</strong></pre>
<p>So we have seen how we modularized a non-modular application using a bottom-up migration approach. The final dependency graph looks something like:</p>
<div class="CDPAlignCenter CDPAlign"><img height="194" width="409" class="image-border" src="assets/d2bbb80a-6a7b-477f-aa43-0a7dc543480d.png"/></div>
<p>The final code for this modular application can be found in the location: <kbd>chp3/6_bottom_up_migration_after</kbd>.</p>
<div class="packt_infobox">We could have done modification in line that<span> </span>is, modularize the code in the same directory <span><kbd>6_bottom_up_migration_before</kbd>. But we prefer to do it separately in a different directory <kbd>6_bottom_up_migration_after</kbd> so as to keep it clean and not disturb the existing code base.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The concept of unnamed modules helped us to run our non-modular application on Java 9. The use of both module path and classpath helped us to run the partly modular application while we were doing the migration. We started with modularizing those code base which were not dependent on any non-modular code. And any code base which we couldn't modularize, we converted them into automatic modules. And thereby enabling us to modularize the code which was dependent on such code base. Eventually, we ended up with a completely modular application.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Top-down migration</h1>
                </header>
            
            <article>
                
<p>The other technique for migration is the top-down migration. In this approach, we start with the root JAR in the dependency graph of the JARs.</p>
<div class="packt_infobox">JARs indicate a code base. We have assumed that the code base is available in the form of JARs and hence the dependency graph which we get has nodes which are JARs. </div>
<p>Modularizing the root of the dependency graph would mean that all other JARs on which this root depends have to be modular. Otherwise, this modular root cannot declare a dependency on unnamed modules. Let's consider the example non-modular application we introduced in our previous recipe. The dependency graph looks something like:</p>
<div class="CDPAlignCenter CDPAlign"><img height="189" width="416" class="image-border" src="assets/27abb22e-5ff1-4ecb-b9ad-5320522b7106.png"/></div>
<p>We extensively make use of automatic modules in top-down migration. Automatic modules are those modules which are implicitly created by the JVM. These are created based on the non-modular JARs available in the module path. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We will make use of the calculator example which we introduced in the previous recipe <em>Bottom-up migration</em>. Go ahead and copy the non-modular code from the location: <kbd>chp3/7_top_down_migration_before</kbd>. Use the following commands if you wish to run it and see if it's working:</p>
<pre><strong>$ javac -d math_util/out/classes/ -sourcepath math_util/src $(find math_util/src -name *.java)

$ jar --create --file=math_util/out/math.util.jar <br/>-C math_util/out/classes/ .

$ javac -d banking_util/out/classes/ -sourcepath banking_util/src $(find banking_util/src -name *.java)

$ jar --create --file=banking_util/out/banking.util.jar <br/>-C banking_util/out/classes/ .

$ javac -cp calculator/lib/*:math_util/out/math.util.jar:banking_util/out/banking.util.jar -d calculator/out/classes/ -sourcepath calculator/src $(find calculator/src -name *.java)

$ java -cp calculator/out/classes:calculator/lib/*:math_util/out/math.util.jar:banking_util/out/banking.util.jar com.packt.calculator.Calculator</strong></pre>
<div class="mce-root packt_infobox">We have provided <kbd>package-*.bat</kbd> and <kbd>run.bat</kbd> to package and run the code on Windows. And <kbd>package-*.sh</kbd> and <kbd>run.sh</kbd> to package and run the code on Linux.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We will be modularizing the application under the directory <kbd>chp3/7_top_down_migration_after</kbd>. Create two directories <kbd>src</kbd> and <kbd>mlib</kbd> under <kbd>chp3/7_top_down_migration_after</kbd>.<strong> </strong></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing the calculator</h1>
                </header>
            
            <article>
                
<ol>
<li>We cannot modularize the calculator until we have modularized all its dependencies. But modularizing its dependencies might be easier at times and not so at other times especially in cases where the dependency is from a third party. In such scenarios, we make use of automatic modules. We copy the non-modular JARs under the folder <kbd>mlib</kbd> and ensuring the name of the JAR is of the form <kbd>&lt;identifier&gt;(.&lt;identifier&gt;)*</kbd> where <kbd>&lt;identifier&gt;</kbd> is a valid Java identifier:</li>
</ol>
<pre><strong>      $ cp ../7_top_down_migration_before/calculator/lib/jackson-<br/>      annotations-</strong><br/><strong>      2.8.4.jar mlib/jackson.annotations.jar </strong><br/><br/><strong>      $ cp ../7_top_down_migration_before/calculator/lib/jackson-core-<br/>      2.8.4.jar</strong><br/><strong>      mlib/jackson.core.jar </strong><br/><br/><strong>      $ cp ../7_top_down_migration_before/calculator/lib/jackson-databind-</strong><br/><strong>      2.8.4.jar mlib/jackson.databind.jar </strong><br/><br/><strong>      $ cp ../7_top_down_migration_before/banking_util/out/banking.util.jar <br/>      mlib/ </strong><br/><br/><strong>      $ cp ../7_top_down_migration_before/math_util/out/math.util.jar mlib/</strong></pre>
<div class="packt_infobox">We have provided script <kbd>copy-non-mod-jar.bat</kbd> and <kbd>copy-non-mod-jar.sh</kbd> to copy the jars easily.</div>
<p style="padding-left: 60px">Let's see what all we copied into <kbd>mlib</kbd>:</p>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><strong> $ ls mlib
      banking.util.jar  jackson.annotations.jar  jackson.core.jar </strong><br/><strong>      jackson.databind.jar  math.util.jar</strong></pre>
<div class="packt_infobox">The <kbd>banking.util.jar</kbd> and <kbd>math.util.jar</kbd> will exist only if you have compiled and JAR'd the code in the <kbd>chp3/7_top_down_migration_before/banking_util</kbd> <span>and <kbd>chp3/7_top_down_migration_before/math_util</kbd> directories. We did this in the <em>Getting ready</em><strong> </strong>section earlier. </span></div>
<ol start="2">
<li>Create a new folder <kbd>calculator</kbd> under <kbd>src</kbd>. This will contain the code for the <kbd>calculator</kbd> module.</li>
<li>Create <kbd>module-info.java</kbd> under the <kbd>chp3/7_top_down_migration_after/src/calculator</kbd> <span>directory </span>that contains the following<strong>:</strong></li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module calculator{ <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>requires math.util; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>requires banking.util; <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> requires jackson.databind; <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> requires jackson.core; <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> requires jackson.annotations; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="4">
<li>Copy the directory <kbd>chp3/7_top_down_migration_before/calculator/src/com</kbd> and all the code under it to <kbd>chp3/7_top_down_migration_after/src/calculator</kbd>. </li>
</ol>
<p> </p>
<ol start="5">
<li>Compile the calculator module:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>#On Linux</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>javac -d mods --module-path mlib --module-source-path src $(find<br/>      src -name<span> </span>*.java)</strong><br/><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>#On Windows</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>javac -d mods --module-path mlib --module-source-path src <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>src\calculator\module-info.java <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>src\calculator\com\packt\calculator\Calculator.java <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>src\calculator\com\packt\calculator\commands\*.java</strong></pre>
<ol start="6">
<li>Create the modular JAR for <kbd>calculator</kbd> module:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>jar --create --file=mlib/calculator.jar --main-<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>class=com.packt.calculator.Calculator -C mods/calculator/ .</strong></pre>
<ol start="7">
<li>Run the <kbd>calculator</kbd> module :</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>java --module-path mlib -m calculator</strong></pre>
<p>We will see that our calculator is executing correctly. You can try out different operations to verify if all of them are executing correctly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing banking.util</h1>
                </header>
            
            <article>
                
<p>As this doesn't depend on other non-module code we can directly convert this into a module by following the steps:</p>
<ol>
<li>Create a new folder <kbd>banking.util</kbd> under <kbd>src</kbd>. This will contain the code for <kbd>banking.util</kbd> module.</li>
<li>Create <kbd>module-info.java</kbd> under the directory <kbd>chp3/7_top_down_migration_after/src/banking.util</kbd><strong> </strong>which contains the following<strong>:</strong></li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module banking.util{<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>exports com.packt.banking; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="3">
<li>Copy the directory <kbd>chp3/7_top_down_migration_before/banking_util/src/com</kbd> and all the code under it to <kbd>chp3/7_top_down_migration_after/src/banking.util</kbd>. </li>
</ol>
<p> </p>
<ol start="4">
<li>Compile the modules:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>#On Linux</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>javac -d mods --module-path mlib --module-source-path src $(find <br/>      src -name *.java)</strong><br/><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>#On Windows</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>javac -d mods --module-path mlib --module-source-path src <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>src\banking.util\module-info.java <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>src\banking.util\com\packt\banking\BankUtil.java</strong></pre>
<ol start="5">
<li>Create modular JAR for <kbd>banking.util</kbd> module. This will replace the non-modular <kbd>banking.util.jar</kbd> already present in <kbd>mlib</kbd>:</li>
</ol>
<pre><strong>      jar --create --file=mlib/banking.util.jar -C mods/banking.util/ .</strong></pre>
<ol start="6">
<li>Run the <kbd>calculator</kbd> module to test if the <kbd>banking.util</kbd> modular JAR has been created successfully:</li>
</ol>
<pre><strong>      java --module-path mlib -m calculator</strong></pre>
<ol start="7">
<li>You should see the calculator getting executed. Play around with different operations to ensure there is no class not found issues.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modularizing math.util</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a new folder <kbd>math.util</kbd> under <kbd>src</kbd>. This will contain the code for <kbd>math.util</kbd> module.</li>
<li>Create <kbd>module-info.java</kbd> under the directory <kbd>chp3/7_top_down_migration_after/src/math.util</kbd><strong> </strong>which contains the following<strong>:</strong></li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module math.util{ <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>exports com.packt.math; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="3">
<li>Copy the directory <kbd>chp3/7_top_down_migration_before/math_util/src/com</kbd> and all the code under it to <kbd>chp3/7_top_down_migration_after/src/math.util</kbd>. </li>
</ol>
<p> </p>
<ol start="4">
<li>Compile the modules:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>#On Linux</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>javac -d mods --module-path mlib --module-source-path src $(find <br/>      src -name *.java)</strong><br/><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>#On Windows</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>javac -d mods --module-path mlib --module-source-path src <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>src\math.util\module-info.java <br/>      src\math.util\com\packt\math\MathUtil.java</strong></pre>
<ol start="5">
<li>Create modular JAR for <kbd>banking.util</kbd> module. This will replace the non-modular <kbd>banking.util.jar</kbd> already present in <kbd>mlib</kbd>:</li>
</ol>
<pre><strong>      jar --create --file=mlib/math.util.jar -C mods/math.util/ .</strong></pre>
<ol start="6">
<li>Run the <kbd>calculator</kbd> module to test if the <kbd>math.util</kbd> modular JAR has been created successfully. </li>
</ol>
<pre><strong>      java --module-path mlib -m calculator</strong></pre>
<ol start="7">
<li>You should see the calculator getting executed. Play around with different operations to ensure there is no class not found issues.</li>
</ol>
<p>With this, we have completely modularized the application baring the Jackson libraries which we have converted to automatic modules.</p>
<p>We would prefer the top-down approach for migration. This is because we don't have to deal with classpath and module-path at the same time. We can make everything into automatic modules and then use the module-path as we keep migrating the non-modular JARs into modular JARs. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using services to create loose coupling between consumer and provider modules</h1>
                </header>
            
            <article>
                
<p>Generally, in our applications, we have some interfaces and multiple implementations of those interfaces. Then at runtime depending on some condition, we make use of some specific implementation. This principle is called <strong>Dependency Inversion</strong>. This principle is used by the dependency injection frameworks like Spring to create objects of concrete implementations and assign (or inject) into the references of type abstract interface. </p>
<p>Java has for long (since Java 6) supported service-provider loading facility via the <kbd>java.util.ServiceLoader</kbd> class. Using Service Loader you can have a <strong>service provider interface</strong> (<strong>SPI</strong>) and multiple implementations of the SPI simply called service provider. These service providers are located in the classpath and loaded at run time. When these service providers are located within modules and as we no longer depend on the classpath scanning to load the service provider, we need a mechanism to tell our modules about the service provider and the SPI for which it is providing. In this recipe, we will look at that mechanism using a simple example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>There is nothing specific we need to set up for this recipe. In this recipe, we will take a simple example. We have one <kbd>BookService</kbd> abstract class which supports CRUD operations. Now, these CRUD operations can work on a SQL DB or on MongoDB or on file system and so on. This flexibility can be provided by using service provider interface and <kbd>ServiceLoader</kbd> class to load the required service provider implementation. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>We have four modules in this recipe:</p>
<ol>
<li><kbd>book.service</kbd>: This is the module which contains our service provider interface that<span> </span>is, the service</li>
<li><kbd>mongodb.book.service</kbd>: This is one of the service provider module</li>
<li><kbd>sqldb.book.service</kbd>: This is the other service provider module</li>
<li><kbd>book.manage</kbd>: This is the service consumer module</li>
</ol>
<p>The following steps demonstrate how to make use of <kbd>ServiceLoader</kbd> to achieve loose coupling:</p>
<ol>
<li>Create a folder <kbd>book.service</kbd> under the directory <kbd>chp3/8_services/src</kbd>. All our code for <kbd>book.service</kbd> module will be under this folder. </li>
<li>Create a new package <kbd>com.packt.model</kbd> and a new class <kbd>Book</kbd> under the new package. This is our model class which contains the following properties:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public String id; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public String title; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public String author;</pre>
<ol start="3">
<li>Create a new package <kbd>com.packt.service</kbd> and a new class <kbd>BookService</kbd> under the new package. This is our main service interface and the service providers will provide an implementation for this service. Apart from the abstract methods for CRUD operations, one method worth mentioning is the <kbd>getInstance()</kbd>. This method uses the <kbd>ServiceLoader</kbd> class to load any one service provider (the last one to be specific) and then use that service provider to get an implementation of the <kbd>BookService</kbd>. Let's see the following<span> </span>code:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static BookService getInstance(){ <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>ServiceLoader&lt;BookServiceProvider&gt; sl = <br/>        <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>ServiceLoader.load(BookServiceProvider.class);<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Iterator&lt;BookServiceProvider&gt; iter = sl.iterator(); <br/>    <span> </span><span> </span><span> </span><span>   </span>if (!iter.hasNext()) <br/>        <span> </span><span>   </span>throw new RuntimeException("No service providers found!");<br/>    <br/>    <span> </span><span> </span><span> </span><span>   </span>BookServiceProvider provider = null; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>while(iter.hasNext()){ <br/>        <span> </span><span> </span><span> </span><span> </span>provider = iter.next(); <br/>        <span> </span><span> </span><span> </span><span> </span>System.out.println(provider.getClass()); <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>} <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> return provider.getBookService(); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px">The first <kbd>while</kbd> loop is just for the demonstration that the <kbd>ServiceLoader</kbd> loads all the service providers and we pick one of the service providers. You can conditionally return the service provider as well, but that all depends on the requirements.</p>
<ol start="4">
<li>The other important part is the actual service provider interface. The responsibility of this is to return an appropriate instance of the service implementation. In our recipe, <kbd>BookServiceProvider</kbd> in the package <kbd>com.packt.spi</kbd> is a service provider interface.</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public interface BookServiceProvider{ <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public BookService getBookService(); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="5">
<li>Next is the main part which is module definition. We create <kbd>module-info.java</kbd> under the directory <kbd>chp3/8_services/src/book.service</kbd> which contains:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module book.service{ <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>exports com.packt.model; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>exports com.packt.service; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>exports com.packt.spi; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>uses com.packt.spi.BookServiceProvider; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<p style="padding-left: 60px">The <kbd>uses</kbd> statement in the preceding module definition specifies the service interface which the module discovers using the <kbd>ServiceLoader</kbd>.</p>
<ol start="6">
<li>Let's now create a service provider module called <kbd>mongodb.book.service</kbd>. This will provide an implementation for our <kbd>BookService</kbd> and <kbd>BookServiceProvider</kbd> interface in <kbd>book.service</kbd> module. Our idea is that this service provider will implement the CRUD operations using MongoDB datastore. </li>
<li>Create a folder <span><kbd>mongodb.book.service</kbd> under the directory <kbd>chp3/8_services/src</kbd>. </span></li>
<li>Create a class <kbd>MongoDbBookService</kbd> in the package <kbd>com.packt.mongodb.service</kbd> which extends <kbd>BookService</kbd> abstract class and provides an implementation for our abstract CRUD operation methods. </li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public void create(Book book){ <br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println("Mongodb Create book ... " + book.title); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>} <br/><br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public Book read(String id){ <br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> System.out.println("Mongodb Reading book ... " + id); <br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>return new Book(id, "Title", "Author"); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>} <br/><br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public void update(Book book){ <br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println("Mongodb Updating book ... " + book.title); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}<br/><br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public void delete(String id){ <br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println("Mongodb Deleting ... " + id); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="9">
<li>Create a class <kbd>MongoDbBookServiceProvider</kbd> in the package <kbd>com.packt.mongodb</kbd> which implements the <kbd>BookServiceProvider</kbd> interface. This is our service discovery, class. Basically, it returns a relevant instance of <kbd>BookService</kbd> implementation. It overrides the method in <span><kbd>BookServiceProvider</kbd> interface as follows:</span></li>
</ol>
<pre><span>        @Override <br/>        public BookService getBookService(){ <br/>          return new MongoDbBookService(); <br/>        }</span></pre>
<ol start="10">
<li>The module definition is quite interesting. We have to declare in the module definition that this module is a service provider for the interface <span><kbd>BookServiceProvider</kbd> and that can be done as follows:</span></li>
</ol>
<pre><span>        module mongodb.book.service{ <br/>          requires book.service; <br/>          provides com.packt.spi.BookServiceProvider <br/>                   with com.packt.mongodb.MongoDbBookServiceProvider; <br/>        }</span></pre>
<p style="padding-left: 60px"><span><kbd>provides .. with ..</kbd> statement is used to specify the service interface and one of the service provider. </span></p>
<ol start="11">
<li>Let's now create a service consumer module called <kbd>book.manage</kbd>.</li>
<li>Create a new folder <kbd>book.manage</kbd> under <kbd>chp3/8_services/src</kbd> which will contain the code for the module.</li>
<li>Create a new class called <kbd>BookManager</kbd> in package <kbd>com.packt.manage</kbd>. The main aim of this class is to get an instance of <kbd>BookService</kbd> and then execute its CRUD operations. The instance returned is decided by the service providers loaded by the <kbd>ServiceLoader</kbd>. The <kbd>BookManager</kbd> class looks something like:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public class BookManager{ <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static void main(String[] args){ <br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>BookService service = BookService.getInstance();<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println(service.getClass()); <br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Book book = new Book("1", "Title", "Author"); <br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>service.create(book); <br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>service.read("1"); <br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> service.update(book); <br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> service.delete("1"); <br/>    <span> </span><span> </span><span> </span><span>  </span><span> </span>}<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="14">
<li>Let's now compile and run our main module by using the following commands:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>$ javac -d mods --module-source-path src $(find src -name *.java) </strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>$ java --module-path mods -m book.manage/com.packt.manage.BookManager </strong><br/><strong><span> </span><span> </span><span> </span><span>  </span><span> </span>class com.packt.mongodb.MongoDbBookServiceProvider</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>class com.packt.mongodb.service.MongoDbBookService</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Create book ... Title</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Reading book ... 1</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Updating book ... Title</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Deleting ... 1</strong></pre>
<p style="padding-left: 60px">In the preceding output, the first line says the service providers available and the second line says which <kbd>BookService</kbd> implementation we are using. </p>
<ol start="15">
<li>With one service provider, it looks simple. Let's go ahead and add another module <kbd>sqldb.book.service</kbd> whose module definition would be:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>module sqldb.book.service{ <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>requires book.service; <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>provides com.packt.spi.BookServiceProvider <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  with com.packt.sqldb.SqlDbBookServiceProvider; <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="16">
<li>The <span><span><kbd>SqlDbBookServiceProvider</kbd> class in the <kbd>com.packt.sqldb</kbd> package is an implementation of the interface <kbd>BookServiceProvider</kbd> as follows:</span></span></li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>@Override <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public BookService getBookService(){     <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> return new SqlDbBookService(); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre>
<ol start="17">
<li>The implementation of CRUD operations is done by the class <kbd>SqlDbBookService</kbd> in the package <kbd>com.packt.sqldb.service</kbd>.</li>
<li>Let's compile and run the main module, this time with two service providers:</li>
</ol>
<pre><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>$ javac -d mods --module-source-path src $(find src -name *.java) </strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>$ java --module-path mods -m book.manage/com.packt.manage.BookManager </strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>class com.packt.sqldb.SqlDbBookServiceProvider</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>class com.packt.mongodb.MongoDbBookServiceProvider</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>class com.packt.mongodb.service.MongoDbBookService</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Create book ... Title</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Reading book ... 1</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Updating book ... Title</strong><br/><strong><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>Mongodb Deleting ... 1</strong></pre>
<p>The first two lines print the class names of the available service providers and the third line prints which <kbd>BookService</kbd> implementation we are using. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a custom modular runtime image using jlink</h1>
                </header>
            
            <article>
                
<p>Java comes in two flavors:</p>
<ul>
<li>Java runtime only also called as JRE - this supports execution of Java applications</li>
<li>Java development kit with Java run time also called as JDK - this supports development and execution of Java applications.</li>
</ul>
<p>Apart from this, there were 3 compact profiles introduced in Java 8 with the aim of providing runtimes with a smaller footprint in order to run on embedded and smaller devices. </p>
<div class="CDPAlignCenter CDPAlign"><img height="309" width="423" class="image-border" src="assets/1157ca16-9696-454f-93f2-1a7f43cd9264.png"/></div>
<p>The preceding image shows the different profiles and the features supported by them.</p>
<p>A new tool called <kbd>jLink</kbd> is introduced in Java 9 which enables the creation of modular run time images. These run time images are nothing but a collection of a set of modules and their dependencies. There is a Java enhancement proposal, JEP 220, governing the structure of this run time image.</p>
<p>In this recipe, we will use <kbd>jLink</kbd> to create a run time image consisting of our modules <kbd>math.util</kbd>, <kbd>banking.util</kbd>, and <kbd>calculator</kbd> along with the Jackson automatic modules. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In the recipe <em>Creating a simple modular application</em> we created a simple modular application consisting of the following modules:</p>
<ul>
<li><kbd>math.util</kbd></li>
<li><kbd>calculator</kbd> - consists of the main class</li>
</ul>
<p>We will reuse the same set of modules and code to demonstrate the use of jLink tool. For the convenience of our readers the code can be found at the location: <kbd>chp3/9_jlink_modular_run_time_image</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Let's compile the modules:</li>
</ol>
<pre><strong>      $ javac -d mods --module-path mlib --module-source-path src $(find <br/>      src - </strong><strong>name *.java)</strong></pre>
<ol start="2">
<li>Let's create the modular JAR for all the modules:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><strong> $ jar --create --file mlib/math.util.jar -C mods/math.util . </strong><br/><br/><strong>      $ jar --create --file=mlib/calculator.jar --main-</strong><br/><strong>      class=com.packt.calculator.Calculator -C mods/calculator/ .</strong></pre>
<ol start="3">
<li> Let's use <kbd>jlink</kbd> to create a run time image consisting of the modules: <kbd>calculator</kbd>, <kbd>math.util</kbd> and its dependencies:</li>
</ol>
<pre><strong>      $ jlink --module-path mlib:$JAVA_HOME/jmods --add-modules </strong><br/><strong>      calculator,math.util --output image --launcher </strong><br/><strong>      launch=calculator/com.packt.calculator.Calculator</strong></pre>
<p style="padding-left: 60px">The run time image gets created at the location specified with <kbd>--output</kbd> command line option. </p>
<ol start="4">
<li>The run time image created under the directory image contains <kbd>bin</kbd> directory among other directories. This <kbd>bin</kbd> directory consists of a shell script by name <kbd>calculator</kbd>. This can be used to launch our application:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><strong>  $ ./image/bin/launch </strong><br/><br/><strong>      ************Advanced Calculator************</strong><br/><strong>      1. Prime Number check</strong><br/><strong>      2. Even Number check</strong><br/><strong>      3. Sum of N Primes</strong><br/><strong>      4. Sum of N Evens</strong><br/><strong>      5. Sum of N Odds</strong><br/><strong>      6. Exit</strong><br/><strong>      Enter the number to choose operation</strong></pre>
<div class="packt_infobox">We cannot create run time image of modules which contain automatic modules. jLink gives an error if the JAR files are not modular or if there is no <kbd>module-info.class</kbd>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiling for older platform versions</h1>
                </header>
            
            <article>
                
<p>We have at some point used options <kbd>-source</kbd> and <kbd>-target</kbd> to create a java build. The <kbd>-source</kbd> option is used to indicate the version of java language accepted by the compiler and the <kbd>-target</kbd> option is used to indicate the version supported by the class files. Often we forget to use <kbd>-source</kbd> option and by default, <kbd>javac</kbd> compiles against the latest available Java version and due to this there are chances of newer APIs being used and as a result, the resultant build doesn't run as expected on the target version. </p>
<p>So as to overcome the confusion of providing two different command line options, a new command line option <kbd>--release</kbd> is introduced in Java 9. This acts as a substitute to <kbd>-source</kbd>, <kbd>-target</kbd> and <kbd>-bootclasspath</kbd><span> options. The <kbd>-bootclasspath</kbd> is used to provide the location of the bootstrap class files for a given version <em>N</em>. </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We have created a simple module called demo which contains a very simple class called <kbd>CollectionsDemo</kbd> which just puts a few values in the map and iterate over them as follows: </p>
<pre>public class CollectionsDemo{
  public static void main(String[] args){
    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();
    map.put("key1", "value1");
    map.put("key2", "value3");
    map.put("key3", "value3");
    map.forEach((k,v) -&gt; System.out.println(k + ", " + v));
  }
}</pre>
<p>Let's compile and run it to see its output:</p>
<pre><strong>$ javac -d mods --module-source-path src src\demo\module-info.java src\demo\com\packt\CollectionsDemo.java
$ java --module-path mods -m demo/com.packt.CollectionsDemo</strong></pre>
<p>The output we get is:</p>
<pre><strong>key1, value1
key2, value3
key3, value3</strong></pre>
<p>Let's now compile this to run on Java 8 and then run it on Java 8.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>As the older version of Java that<span> is,</span> Java 8 and before don't support modules, we would have to get rid of the <kbd>module-info.java</kbd> while compiling on an older version. So what we did was to not include <kbd>module-info.java</kbd> during our compilation. So we compiled using the following code:</li>
</ol>
<pre><strong>      $ javac --release 8 -d mods src\demo\com\packt\CollectionsDemo.java</strong></pre>
<p style="padding-left: 60px">You can see that we are using the <kbd>--release</kbd> option targeting Java 8 and not compiling the <kbd>module-info.java</kbd>.</p>
<ol start="2">
<li>Let's create a JAR file because it becomes easier to transport the java build instead of copying all the class files:</li>
</ol>
<pre><strong>      $jar --create --file mlib/demo.jar --main-class <br/>      com.packt.CollectionsDemo </strong><strong>-C mods/ .</strong></pre>
<ol start="3">
<li>Let's run the preceding JAR in Java 9:</li>
</ol>
<pre><strong>      $ java -version</strong><br/><strong>      java version "9"</strong><br/><strong>      Java(TM) SE Runtime Environment (build 9+179)</strong><br/><strong>      Java HotSpot(TM) 64-Bit Server VM (build 9+179, mixed mode)</strong><br/><br/><strong>      $ java -jar mlib/demo.jar</strong><br/><strong>      key1, value1</strong><br/><strong>      key2, value3</strong><br/><strong>      key3, value3</strong></pre>
<ol start="4">
<li>Let's run the JAR in Java 8 :</li>
</ol>
<pre><span> </span><strong>     $ "%JAVA8_HOME%"\bin\java -version </strong><br/><strong>      java version "1.8.0_121"</strong><br/><strong>      Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</strong><br/><strong>      Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</strong><br/><br/><strong>      $ "%JAVA8_HOME%"\bin\java -jar mlib\demo.jar</strong><br/><strong>      key1, value1</strong><br/><strong>      key2, value3</strong><br/><strong>      key3, value3</strong></pre>
<p>What if we did not use the <kbd>-release</kbd> option while building on Java 9? Let's try that as well.</p>
<ol>
<li>Compile without using <kbd>--release</kbd> option and create a JAR out of the resulting class files:</li>
</ol>
<pre><strong>      $ javac -d mods src\demo\com\packt\CollectionsDemo.java </strong><br/><strong>      $ jar --create --file mlib/demo.jar --main-class <br/>      com.packt.CollectionsDemo </strong><strong>-C mods/ .</strong></pre>
<ol start="2">
<li>Let's run the JAR on Java 9:</li>
</ol>
<pre><strong>      $ java -jar mlib/demo.jar </strong><br/><strong>      key1, value1</strong><br/><strong>      key2, value3</strong><br/><strong>      key3, value3</strong></pre>
<p style="padding-left: 60px">Works as expected</p>
<ol start="3">
<li>Let's run the JAR on Java 8:</li>
</ol>
<pre><strong>      $ "%JAVA8_HOME%"\bin\java -version</strong><br/><strong>      java version "1.8.0_121"</strong><br/><strong>      Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</strong><br/><strong>      Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</strong></pre>
<p>The output is:</p>
<pre class="mce-root"><strong>$ java -jar mlib\demo.jar</strong><br/><br/><strong>Exception in thread "main" java.lang.UnsupportedClassVersionError:</strong><br/><br/><strong>com/packt/CollectionsDemo has been compiled by a more recent version of the Java Runtime (class file version 53.0), this version of the Java Runtime only recognizes class file versions up to 52.0</strong></pre>
<p>It is clearly stating that there is a mismatch in the version of the class file. As it was compiled for Java 9 (version 53.0), it doesn't run on Java 8 (version 52.0)</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The data required for compiling to a target older version is stored in the <span><kbd>$JDK_ROOT/lib/ct.sym</kbd> file. This information is used by the <kbd>--release</kbd> option to locate the <kbd>bootclasspath</kbd>. The <kbd>ct.sym</kbd> file is a ZIP file containing stripped-down class files corresponding to class files from the target platform versions (taken verbatim from <a href="http://openjdk.java.net/jeps/247">http://openjdk.java.net/jeps/247</a>). </span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating multirelease JARs</h1>
                </header>
            
            <article>
                
<p>Prior to Java 9, it was hard for the developers of a library to adopt the new features introduced in the language without releasing a new library version. But in Java 9 multirelease JARs provide such a functionality where you can bundle certain class files to run when a higher version of Java is being used. </p>
<p>In this recipe, we will show you how to create such a multirelease JAR.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create the required Java code for Java 8 platform. We will add two classes <kbd>CollectionUtil.java</kbd> and <kbd>FactoryDemo.java</kbd> in the directory <kbd>src\8\com\packt</kbd>:</li>
</ol>
<div>
<pre><span>        public</span><span> </span><span>class</span><span> </span><span>CollectionUtil</span><span>{<br/></span><span>          public</span><span> </span><span>static</span><span> </span><span>List&lt;String&gt;</span><span> </span><span>list</span><span>(</span><span>String</span><span> ... </span><span>args</span><span>){<br/></span><span>            System</span><span>.</span><span>out</span><span>.</span><span>println(</span><span>"Using Arrays.asList"</span><span>);<br/></span><span>            return</span><span> </span><span>Arrays</span><span>.</span><span>asList(args);<br/></span><span>          }<br/><br/></span><span>          public</span><span> </span><span>static</span><span> </span><span>Set&lt;String&gt;</span><span> </span><span>set</span><span>(</span><span>String</span><span> ... </span><span>args</span><span>){<br/></span><span>            System</span><span>.</span><span>out</span><span>.</span><span>println(</span><span>"Using Arrays.asList and set.addAll"</span><span>);<br/></span><span>            Set&lt;String&gt;</span><span> set </span><span>=</span><span> </span><span>new</span><span> </span><span>HashSet&lt;&gt;</span><span>();<br/></span><span>            set</span><span>.</span><span>addAll(list(args));<br/></span><span>            return</span><span> set;<br/></span><span>          }<br/></span><span>        }<br/><br/></span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public<span> </span><span>class</span><span> </span><span>FactoryDemo</span><span>{<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>public static void main(String[] args){<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println(CollectionUtil.list("element1", <br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>"element2", "element3"));<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>System.out.println(CollectionUtil.set("element1", <br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>"element2", "element3"));<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>  </span>}<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</span></pre></div>
<ol start="2">
<li>We wish to make use of the <kbd>Collection</kbd> factory methods introduced in Java 9. So what we can do is create another sub directory under <kbd>src</kbd> to place our Java 9 related code: <kbd>src\9\com\packt</kbd> where we will add another <kbd>CollectionUtil</kbd> class:</li>
</ol>
<div>
<pre><span>        public</span><span> </span><span>class</span><span> </span><span>CollectionUtil</span><span>{<br/></span><span>          public</span><span> </span><span>static</span><span> </span><span>List&lt;String&gt;</span><span> </span><span>list</span><span>(</span><span>String</span><span> ... </span><span>args</span><span>){<br/></span><span>            System</span><span>.</span><span>out</span><span>.</span><span>println(</span><span>"Using factory methods"</span><span>);<br/></span><span>            return</span><span> </span><span>List</span><span>.</span><span>of(args);<br/></span><span>          }<br/></span><span>          public</span><span> </span><span>static</span><span> </span><span>Set&lt;String&gt;</span><span> </span><span>set</span><span>(</span><span>String</span><span> ... </span><span>args</span><span>){<br/></span><span>            System</span><span>.</span><span>out</span><span>.</span><span>println(</span><span>"Using factory methods"</span><span>);<br/></span><span>            return</span><span> </span><span>Set</span><span>.</span><span>of(args);<br/></span><span>          }<br/></span><span>        }</span></pre></div>
<ol start="3">
<li>The preceding code uses the Java 9 collection factory methods. Compile the source code using the following commands:</li>
</ol>
<div>
<div>
<pre><strong>      javac -d mods --release 8 src\8\com\packt\*.java<br/>      javac -d mods9 --release 9 src\9\com\packt\*.java</strong></pre></div>
</div>
<p style="padding-left: 60px">Make a note of the <kbd>--release</kbd> option used to compile the code for different java versions.</p>
<ol start="4">
<li>Let's now create the multirelease JAR:</li>
</ol>
<div>
<pre><strong>      jar --create --file mr.jar --main-class=com.packt.FactoryDemo <br/>      -C mods . --release 9 -C mods9 .</strong></pre></div>
<p style="padding-left: 60px">While creating the JAR we have also mentioned that when running on Java 9 make use of the Java 9 specific code.</p>
<ol start="5">
<li>We will run the <kbd>mr.jar</kbd> on Java 9:</li>
</ol>
<pre><strong>      java -jar mr.jar</strong><br/><strong>      [element1, element2, element3]</strong><br/><strong>      Using factory methods</strong><br/><strong>      [element2, element3, element1]</strong></pre>
<ol start="6">
<li>We will run the <kbd>mr.jar</kbd> on Java 8:</li>
</ol>
<p> </p>
<pre><span> </span><span> </span><span> </span><strong>   #Linux</strong><br/><strong>      $ /usr/lib/jdk1.8.0_144/bin/java -version</strong><br/><strong>      java version "1.8.0_144"</strong><br/><strong>      Java(TM) SE Runtime Environment (build 1.8.0_144-b01)</strong><br/><strong>      Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</strong><br/><strong>      $ /usr/lib/jdk1.8.0_144/bin/java -jar mr.jar</strong><br/><strong>      Using Arrays.asList</strong><br/><strong>      [element1, element2, element3]</strong><br/><strong>      Using Arrays.asList and set.addAll</strong><br/><strong>      Using Arrays.asList</strong><br/><strong>      [element1, element2, element3]</strong><br/><br/><strong>      #Windows</strong><br/><strong>      $ "%JAVA8_HOME%"\bin\java -version </strong><br/><strong>      java version "1.8.0_121"</strong><br/><strong>      Java(TM) SE Runtime Environment (build 1.8.0_121-b13)</strong><br/><strong>      Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)</strong><br/><strong>      $ "%JAVA8_HOME%"\bin\java -jar mr.jar</strong><br/><strong>      Using Arrays.asList</strong><br/><strong>      [element1, element2, element3]</strong><br/><strong>      Using Arrays.asList and set.addAll</strong><br/><strong>      Using Arrays.asList</strong><br/><strong>      [element1, element2, element3]</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>Let's look at the layout of the content in <kbd>mr.jar</kbd>: </p>
<pre><strong>jar -tvf mr.jar</strong></pre>
<p>The contents of the JAR is as shown in the following:</p>
<div class="CDPAlignCenter CDPAlign"><img height="132" width="519" class="alignnone size-full wp-image-1554 image-border" src="assets/c8a24d55-58f0-41d8-a6d8-c4b0d1d61727.png"/></div>
<p>The preceding layout we have <kbd>META-INF/versions/9</kbd> which contains the Java 9 specific code. Another important thing to note is the contents of the <kbd>META-INF/MANIFEST.MF</kbd> file. Let's extract the JAR and view its contents:</p>
<pre><strong>jar -xvf mr.jar</strong><br/><br/><strong>$ cat META-INF/MANIFEST.MF</strong><br/><strong>Manifest-Version: 1.0</strong><br/><strong>Created-By: 9 (Oracle Corporation)</strong><br/><strong>Main-Class: com.packt.FactoryDemo</strong><br/><strong>Multi-Release: true</strong></pre>
<p>The new manifest attribute <kbd>Multi-Release</kbd> is used to indicate if the JAR is a multirelease JAR or not.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Maven to develop a modular application</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will look at using Maven, most popular build tool in Java ecosystem, to develop a simple modular application. We will reuse the idea we had introduced in the Services recipe in this chapter. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>We have the following modules in our example:</p>
<ul>
<li><kbd>book.manage</kbd>: This is the main module which interacts with the data source</li>
<li><kbd>book.service</kbd>: This is the module which contains the service provider interface</li>
<li><kbd>mongodb.book.service</kbd>: This is the module which provides an implementation to the service provider interface</li>
<li><kbd>sqldb.book.service</kbd>: This is the module which provides another implementation to the service provider interface</li>
</ul>
<p>In the course of this recipe, we will create a maven project and include the preceding JDK modules as maven modules. So let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Create a folder to contain all the modules. We have called it <kbd>12_services_using_maven</kbd> with the following folder structure:</li>
</ol>
<pre><span> </span><strong>     12_services_using_maven</strong><br/><strong>            |---book-manage</strong><br/><strong>            |---book-service</strong><br/><strong>            |---mongodb-book-service</strong><br/><strong>            |---sqldb-book-service</strong><br/><strong>            |---pom.xml</strong></pre>
<ol start="2">
<li>The <kbd>pom.xml</kbd> for the parent is:</li>
</ol>
<pre class="mce-root"><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;project <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span> <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span> xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span> http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;groupId&gt;com.packt&lt;/groupId&gt;<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;artifactId&gt;services_using_maven&lt;/artifactId&gt;<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;version&gt;1.0&lt;/version&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;packaging&gt;pom&lt;/packaging&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;modules&gt;<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;module&gt;book-service&lt;/module&gt;<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;module&gt;mongodb-book-service&lt;/module&gt;<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;module&gt;sqldb-book-service&lt;/module&gt;<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;module&gt;book-manage&lt;/module&gt;<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span> </span><span> </span>&lt;/modules&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;build&gt;<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;plugins&gt;<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;plugin&gt;<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br/>     <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;version&gt;3.6.1&lt;/version&gt;<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;configuration&gt;<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  &lt;source&gt;9&lt;/source&gt;<br/>       <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;target&gt;9&lt;/target&gt;<br/>        <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;showWarnings&gt;true&lt;/showWarnings&gt;<br/>        <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;showDeprecation&gt;true&lt;/showDeprecation&gt;<br/>      <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;/configuration&gt;<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;/plugin&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>  </span>&lt;/plugins&gt;<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;/build&gt;<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;/project&gt;</pre>
<ol start="3">
<li>Let's create the structure for the <kbd>book-service</kbd> Maven module:</li>
</ol>
<pre><strong>      book-service</strong><br/><strong>       |---pom.xml</strong><br/><strong>       |---src</strong><br/><strong>         |---main</strong><br/><strong>           |---book.service</strong><br/><strong>             |---module-info.java</strong><br/><strong>             |---com</strong><br/><strong>               |---packt</strong><br/><strong>                 |---model</strong><br/><strong>                   |---Book.java</strong><br/><strong>                 |---service</strong><br/><strong>                   |---BookService.java</strong><br/><strong>                 |---spi</strong><br/><strong>                   |---BookServiceProvider.java</strong></pre>
<ol start="4">
<li>The content of <kbd>pom.xml</kbd> for <kbd>book-service</kbd> Maven module is:</li>
</ol>
<pre class="mce-root"><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;?xml version="1.0" encoding="UTF-8"?&gt;<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;project <br/>  <span> </span><span> </span><span> </span><span> </span>  <br/>    <span> </span><span> </span><span> </span><span> </span>xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 <br/>    <span> </span><span> </span><span> </span><span> </span>http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  &lt;parent&gt;<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>    <span> </span>&lt;groupId&gt;com.packt&lt;/groupId&gt;<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;artifactId&gt;services_using_maven&lt;/artifactId&gt;<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;version&gt;1.0&lt;/version&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;/parent&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;artifactId&gt;book-service&lt;/artifactId&gt;<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;version&gt;1.0&lt;/version&gt;<br/> <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;build&gt;<br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> &lt;sourceDirectory&gt;src/main/book.service&lt;/sourceDirectory&gt;<br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;/build&gt;<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>&lt;/project&gt;</pre>
<ol start="5">
<li>The <kbd>module-info.java</kbd> is:</li>
</ol>
<div>
<pre><span>        module book</span><span>.</span><span>service{<br/></span><span>          exports com</span><span>.</span><span>packt</span><span>.</span><span>model;<br/></span><span>          exports com</span><span>.</span><span>packt</span><span>.</span><span>service;<br/></span><span>          exports com</span><span>.</span><span>packt</span><span>.</span><span>spi;<br/></span><span>          uses </span><span>com.packt.spi</span><span>.</span><span>BookServiceProvider</span><span>;<br/></span><span>       }</span></pre></div>
<ol start="6">
<li>The <kbd>Book.java</kbd> is:</li>
</ol>
<div>
<div>
<pre><span>       public</span><span> </span><span>class</span><span> </span><span>Book</span><span>{<br/></span><span>         public</span><span> </span><span>Book</span><span>(</span><span>String</span><span> </span><span>id</span><span>, </span><span>String</span><span> </span><span>title</span><span>, </span><span>String</span><span> </span><span>author</span><span>){<br/></span><span>           this</span><span>.</span><span>id </span><span>=</span><span> id;<br/></span><span>           this</span><span>.</span><span>title </span><span>=</span><span> title<br/></span><span>           this</span><span>.</span><span>author </span><span>=</span><span> author;<br/></span><span>         }<br/></span><span>         public</span><span> </span><span>String</span><span> id;<br/></span><span>         public</span><span> </span><span>String</span><span> title;<br/></span><span>         public</span><span> </span><span>String</span><span> author;<br/></span><span>       }</span></pre></div>
<ol start="7">
<li>The <kbd>BookService.java</kbd> is:</li>
</ol>
<pre><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>   </span>public abstract class BookService{<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span> </span><span> </span> public abstract void create(Book book); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span> </span><span> </span> public abstract Book read(String id); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  <span> </span><span> </span>public abstract void update(Book book); <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  <span> </span><span> </span>public abstract void delete(String id);<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>  <span> </span><span> </span>public static BookService getInstance(){ <br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>    <span> </span><span> </span>ServiceLoader&lt;BookServiceProvider&gt; sl      <br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>    ServiceLoader.load(BookServiceProvider.class);          <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span> </span><span> </span>Iterator&lt;BookServiceProvider&gt; iter = sl.iterator();        <br/>   <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span> <span> </span><span> </span>if (!iter.hasNext())<br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>   <span> </span><span> </span> throw new RuntimeException("No service providers found!");              <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>   </span>BookServiceProvider provider = null;        <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span>   </span><span> </span>while(iter.hasNext()){<br/>        <span> </span><span> </span><span> </span><span>   </span><span> </span>provider = iter.next();<br/>        <span> </span><span> </span><span> </span><span> </span><span>   </span>System.out.println(provider.getClass());        <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span>   </span><span> </span>}        <br/>    <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span>   </span>return provider.getBookService(); <br/>  <span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}<br/><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span><span> </span>}</pre></div>
<ol start="8">
<li>The <kbd>BookServiceProvider.java</kbd> is:</li>
</ol>
<div>
<div>
<pre><span>        public</span><span> </span><span>interface</span><span> </span><span>BookServiceProvider</span><span>{<br/></span><span>          public</span><span> </span><span>BookService</span><span> </span><span>getBookService</span><span>();<br/></span><span>        }</span></pre></div>
<p>On similar lines, we define other three Maven modules namely <kbd>mongodb-book-service</kbd>, <kbd>sqldb-book-service</kbd> and <kbd>book-manager</kbd>. The code for this can be found at the location <kbd>chp3/12_services_using_maven</kbd>. </p>
</div>
<p>We can compile the classes and build the required JAR files using the command:</p>
<pre>mvn clean install</pre>
<p>We have provided <kbd>run-with-mongo.*</kbd> to use the <kbd>mongodb-book-service</kbd> as the service provider implementation and <kbd>run-with-sqldb.*</kbd> to use the <kbd>sqldb-book-service</kbd> as the service provider implementation.</p>
<p>The complete code for this recipe can be found at <kbd>chp3/12_services_using_maven</kbd>.</p>


            </article>

            
        </section>
    </body></html>