<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Testing Your Services with Arquillian</h1>
                </header>
            
            <article>
                
<p>In this chapter, you will learn how to test your microservices. For this purpose, we will use Arquillian, a test framework designed to test software components using their dedicated runtime, instead of creating mock-based unit tests. This is the framework developer to work seamlessly WildFly Swarm and, effectively, a framework of choice for it.</p>
<p>We will introduce Arquillian and present the purpose of the project and its main features. Later, you will learn how to develop, write, and configure tests for your services based on practical examples.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Arquillian</h1>
                </header>
            
            <article>
                
<p>We all know the benefits of unit testing. They are simple and run immediately. They isolate the components of your application and allow you to test them one by one, providing the coverage of each component's usage scenarios.<br/>
Unfortunately, unit tests have their shortcomings too. When you cover your application with unit tests, they will confirm that each component of your application works correctly. Obviously, based <span>only </span>on that information, you cannot deduce that your whole application works correctly—t<span>hat is a reason to have integration tests.</span> You have to test your components inside the environment in which they will operate to ensure that the application works correctly as a whole.<br/>
The problem with integration tests so far has been that they tend to be complicated to configure and took a long time to execute. Here is where Arquillian steps in. The aim of the project is to make integration tests as fast and simple to configure as unit tests.</p>
<p>As you may recall, in <a href="c00cfc93-f395-446e-9132-242f02216783.xhtml">Chapter 2</a>, <em>Getting Familiar with WildFly Swarm</em>, we emphasized how fast modern runtimes are. Arquillian takes advantage of that and lets you easily configure the tests that run on the<span> </span>same<span> </span>runtime <span>your application will run. If, for example, you are developing a Java EE application, you can configure Arquillian to run the test on the application server of your choice. Since modern applications servers are very fast, the test will run immediately. On the other hand, you will be able to test your application in its real environment with all its dependencies. </span></p>
<p>In our case, a runtime for each service is assembled by WildFly Swarm (as described in <a href="dd01a81c-3ad7-4b3b-80fa-a8af1b89581c.xhtml">Chapter 3</a>, <em>Right-Sizing Your Applications</em>). Arquillian allows you to configure the tests for such cases too. Let's find out how.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing Swarm microservices with Arquillian</h1>
                </header>
            
            <article>
                
<p>In this section, you will learn how Arquillian can be used to test microservices created with Swarm. As you learned in previous chapters, Swarm builds a runtime containing only fractions needed by a given service, starts it, and then deploys an archive on it, creating the microservice.</p>
<p>Arquillian, as we have just learned, tests an application on its dedicated runtime. It starts the runtime, deploys the tested code on it, and performs the test. Let's configure such a test for our JAX-RS and the CDI catalog service example, and explain what we are doing step by step. </p>
<div class="packt_infobox">For examples: refer to<span> </span><kbd><span>chapter 5/</span>catalog-service-simple-test</kbd><span>.</span></div>
<p>First of all, we have to provide all the necessary dependencies:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencyManagement&gt;<br/></span><span>        &lt;dependencies&gt;</span><span><br/><strong>            &lt;!-- 1 --&gt;</strong><br/></span><strong>            &lt;dependency&gt;<br/>                &lt;groupId&gt;org.jboss.arquillian&lt;/groupId&gt;<br/>                &lt;artifactId&gt;arquillian-bom&lt;/artifactId&gt;<br/>                &lt;version&gt;${version.arquillian}&lt;/version&gt;<br/>                &lt;type&gt;pom&lt;/type&gt;<br/>                &lt;scope&gt;import&lt;/scope&gt;<br/></strong><span><strong>            &lt;/dependency&gt;</strong><br/></span><span>        &lt;/dependencies&gt;<br/></span><span>    &lt;/dependencyManagement&gt;<br/></span><span><br/></span><span>    &lt;dependencies&gt;</span><span><br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>jaxrs<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><span>        &lt;/dependency&gt;<br/></span><span>        &lt;dependency&gt;<br/></span><span>            &lt;groupId&gt;</span>org.wildfly.swarm<span>&lt;/groupId&gt;<br/></span><span>            &lt;artifactId&gt;</span>cdi<span>&lt;/artifactId&gt;<br/></span><span>            &lt;version&gt;</span>${version.wildfly.swarm}<span>&lt;/version&gt;<br/></span><span>        &lt;/dependency&gt;<br/><strong>        &lt;!-- 2 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;junit&lt;/groupId&gt;<br/>            &lt;artifactId&gt;junit&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.junit}&lt;/version&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/></strong><span><strong>        &lt;/dependency&gt;<br/>        &lt;!-- 3 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.jboss.arquillian.junit&lt;/groupId&gt;<br/>            &lt;artifactId&gt;arquillian-junit-container&lt;/artifactId&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/>        &lt;/dependency&gt;<br/>        &lt;!-- 4 --&gt;<br/>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;arquillian&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><span><br/></span><span>(...)<br/></span><span><br/></span><span>&lt;/project&gt;</span></pre>
<ol>
<li>Firstly, we added Arquillian to <kbd>dependencyManagement</kbd> (1).</li>
<li>Secondly, Arquillian can be integrated with various testing libraries. As we are going to use JUnit, we have to provide the dependency to it (2).</li>
</ol>
<ol start="3">
<li>To run the Arquillian test with JUnit, we have to provide JUnit integration artifact (3).</li>
<li>Thirdly, we have to tell Arquillian which runtime to use—we are doing this by providing a dependency to an adapter library. In our case, this obviously is a Swarm adapter (3).</li>
</ol>
<p><span>Now we are ready to take a look at the code. To recall, the service in this example contains only one item, which is added manually:</span></p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.enterprise.context.<span>ApplicationScoped</span><span>;<br/></span><span>import </span>java.util.HashMap<span>;<br/></span><span>import </span>java.util.Map<span>;<br/></span><span><br/></span><span>@ApplicationScoped<br/></span><span>public class </span>CatalogService {<br/><br/>    <span>private </span>Map&lt;String<span>, </span>Item&gt; <span>catalog </span>= <span>new </span>HashMap&lt;&gt;()<span>;<br/></span><span><br/></span><span>    public </span><span>CatalogService</span>(){<br/>        Item turtle = <span>new </span>Item()<span>;<br/></span><span>        </span>turtle.setItemId(<span>"turtle"</span>)<span>;<br/></span><span>        </span>turtle.setName(<span>"turtle"</span>)<span>;<br/></span><span>        </span>turtle.setQuantity(<span>5</span>)<span>;<br/></span><span>        </span>turtle.setDescription(<span>"Slow, friendly reptile. Let your busy self see how it spends 100 years of his life laying on sand and swimming."</span>)<span>;<br/></span><span>        </span><span>catalog</span>.put(<span>"turtle"</span><span>, </span>turtle)<span>;<br/></span><span>    </span>}<br/><br/>    <span>public </span>Item <span>searchById</span>(String itemId){<br/>        <span>return </span><span>catalog</span>.get(itemId)<span>;<br/></span><span>    </span>}<br/><br/>}</pre>
<p>Now it is time to write a <kbd>test</kbd> class. An Arquillian-based test runs in the following way: Arquillian looks for the static method annotated with the <kbd>org.jboss.arquillian.container.test.api.Deployment</kbd> annotation. The method has to return the <kbd>ShrinkWrap</kbd> archive.</p>
<p>Arquillian will start the container and deploy the returned archive on it. After that, the methods are annotated with <kbd>org.junit</kbd>. A test<span> </span>runs inside the container. Let's look<span> </span>at<span> </span>all this in our sample test:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.<span>jboss</span>.arquillian.container.test.api.<span>Deployment</span><span>;<br/></span><span>import </span>org.<span>jboss</span>.arquillian.junit.Arquillian<span>;<br/></span><span>import </span>org.<span>jboss</span>.shrinkwrap.api.ShrinkWrap<span>;<br/></span><span>import </span>org.<span>jboss</span>.shrinkwrap.api.asset.EmptyAsset<span>;<br/></span><span>import </span>org.<span>jboss</span>.shrinkwrap.api.spec.JavaArchive<span>;<br/></span><span>import </span>org.junit.Assert<span>;<br/></span><span>import </span>org.junit.<span>Test</span><span>;<br/></span><span>import </span>org.junit.runner.<span>RunWith</span><span>;<br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span><br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span><br/></span><strong>//1<br/>@RunWith(Arquillian.class)</strong><br/><span>public class </span>CatalogServiceTest {<br/><br/><strong>    //2<br/>    @Deployment<br/>    public static JavaArchive createDeployment() {</strong><br/><strong>        return ShrinkWrap.create(JavaArchive.class)</strong><br/><strong>                .addClasses(Item.class,CatalogService.class)</strong><br/><strong>                .addAsManifestResource(EmptyAsset.INSTANCE, "beans.xml");<br/>    }</strong><br/><br/><strong>    //3<br/>    @Inject<br/>    CatalogService catalogService;<br/></strong><span><br/></span><strong>    //4<br/>    @Test<br/>    public void testSearchById() {</strong><br/><strong>        Assert.assertEquals(catalogService.searchById("turtle").getName(),"turtle")</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>In the beginning, we told JUnit to run the test using Arquillian test controller. To do that, we annotated the test with the <kbd>@RunWith</kbd> annotation, specifying <kbd>Arquillian.class</kbd> as the test runner (1).</p>
<p>The <kbd>createDeployment</kbd> (2) method, as its name suggests, is responsible for creating the deployment archive, which will be deployed on the configured container. To inform Arquillian about it, we have to annotate this method with the <kbd>@Deployment</kbd> annotation. The method is static and returns the <kbd>ShrinkWrap</kbd> archive. As the test method is being run inside the container, we are able to inject its resources. In our example, we have to inject the <kbd>CatalogService</kbd> class that we are going to test (3) and the <kbd>Item</kbd> class on which it depends.</p>
<p>Finally, the <kbd>Test</kbd> method checks whether the <kbd>searchById</kbd> method works correctly (4).</p>
<p>Let's run the test now:</p>
<pre><strong>mvn clean wildfly-swarm:run</strong></pre>
<p>You will note that the test has been deployed inside the Swarm container:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/727118a6-1419-4f5c-bdcd-f7c758baad20.png" style=""/></div>
<p>It finishes successfully:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f9321cdb-a3c4-4d01-934e-35c20afb1006.png" style=""/></div>
<p>Finally, the Swarm microservice starts (because we used the <kbd>wildfly-swarm:run</kbd> command):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d03f92fc-a1b1-436f-8982-d1585fc913bf.png" style=""/></div>
<p class="mce-root">Note that Swarm, as in examples from the previous chapters, used the when-missing discovery mechanism and created the container with all the necessary fractions. That container was used for both testing and running the resulting microservices.</p>
<p class="mce-root">As you could notice in the preceding screenshot, the only file that we changed was the <kbd>pom.xml</kbd> file, so the switch from AS to Swarm was again very simple. However, this had drawbacks too: not changing the <kbd>CatalogTest</kbd> class meant that we were again creating the archive manually—Swarm can do it for us when the service is created so can't it create the deployment test too? It can—let's learn how.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The default deployment</h1>
                </header>
            
            <article>
                
<p>As we have just hinted, Swarm can create the default test deployment.</p>
<div class="packt_infobox"><span>For example, refer to <kbd>chapter 5/catalog-service-test-default-deployment</kbd></span><span>.</span></div>
<p>We will modify the <kbd>Test</kbd> class so that the archive is created automatically:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.jboss.arquillian.junit.Arquillian<span>;<br/></span><span>import </span>org.junit.Assert<span>;<br/></span><span>import </span>org.junit.<span>Test</span><span>;<br/></span><span>import </span>org.junit.runner.<span>RunWith</span><span>;<br/></span><span>import </span>org.wildfly.swarm.arquillian.<span>DefaultDeployment</span><span>;<br/></span><span><br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span><br/></span><span><br/></span><span>@RunWith</span>(Arquillian.<span>class</span>)<br/><strong>//1<br/></strong><span><strong>@DefaultDeployment</strong><br/></span><span>public class </span>CatalogServiceTest {<br/><br/>    <span>@Inject<br/></span><span>    </span>CatalogService <span>catalogService</span><span>;<br/></span><span><br/></span><span>    </span><span>@Test<br/></span><span>    </span><span>public void </span><span>testSearchById</span>() {<br/>        Assert.<span>assertEquals</span>(<span>catalogService</span>.searchById(<span>"turtle"</span>).getName()<span>,</span><span>"turtle"</span>)<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>In order to tell Swarm to create the test deployment automatically, we have to annotate the class with the <kbd>org.wildfly.swarm.arquillian.DefaultDeployment</kbd> annotation (1). That's just it. If you run the test now, you will see the same result as in the preceding paragraph. Note that we didn't use the <kbd>@Deployment</kbd> annotated static method as we did in the preceding example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Swarm configuration</h1>
                </header>
            
            <article>
                
<p>In the preceding chapter, we showed you how to modify the Swarm configuration. The example that we used to present that was a database configuration. In this section, we will show you how to provide analogous configuration for a Swarm test using the same example.  </p>
<div class="packt_infobox"><span>For examples, refer to <kbd>chapter 5/catalog-service-database-test</kbd>.</span></div>
<p>If you would like to create the Swarm container manually, you have to implement the static method annotated with the <kbd>org.wildfly.swarm.arquillian.CreateSwarm</kbd> annotation and return the instance of the <kbd>org.wildfly.swarm.Swarm</kbd> class from it. As you probably recall, we have already created a lot of Swarm containers inside the <kbd>main</kbd> functions that we created in <a href="d76eaa85-5053-41f6-bcd1-307db5a17f60.xhtml">Chapter 4</a>, <em>Tuning the Configuration of Your Services</em>. Swarm-creating methods that we will use in the tests work the same way. Let's take a look at the code:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.jboss.arquillian.container.test.api.<span>Deployment</span><span>;<br/></span><span>import </span>org.jboss.arquillian.junit.Arquillian<span>;<br/></span><span>import </span>org.jboss.shrinkwrap.api.ShrinkWrap<span>;<br/></span><span>import </span>org.jboss.shrinkwrap.api.asset.EmptyAsset<span>;<br/></span><span>import </span>org.jboss.shrinkwrap.api.spec.JavaArchive<span>;<br/></span><span>import </span>org.junit.Assert<span>;<br/></span><span>import </span>org.junit.<span>Test</span><span>;<br/></span><span>import </span>org.junit.runner.<span>RunWith</span><span>;<br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span>import </span>org.wildfly.swarm.arquillian.<span>CreateSwarm</span><span>;<br/></span><span><br/></span><span>import </span>javax.inject.<span>Inject</span><span>;<br/></span><span>import </span>java.net.URL<span>;<br/></span><span><br/></span><span>//1<br/></span><span>@RunWith</span>(Arquillian.<span>class</span>)<br/><span>public class </span>CatalogServiceTest {<br/><span><br/></span><span>    </span><span>@Deployment<br/></span><span>    </span><span>public static </span>JavaArchive <span>createDeployment</span>() {<br/>        <span>return </span>ShrinkWrap.<span>create</span>(JavaArchive.<span>class</span>)<br/>                .addClasses(Item.<span>class, </span>CatalogService.<span>class</span>)<br/><strong>                 //1</strong><br/><strong>                .addAsResource("datasources.yml")</strong><br/><strong>                .addAsResource("META-INF/persistence.xml")</strong><br/><strong>                .addAsResource("META-INF/load.sql")</strong><br/>                .addAsManifestResource(EmptyAsset.<span>INSTANCE</span><span>, </span><span>"beans.xml"</span>)<span>;<br/></span><span>    </span>}<br/><br/><strong>    //2<br/>    @CreateSwarm<br/>    public static Swarm createSwarm() throws Exception {</strong><br/><strong>        Swarm swarm = new Swarm();<br/>        //3<br/>        ClassLoader cl = CatalogServiceTest.class.getClassLoader();<br/>        URL dataSourcesConfig = cl.getResource("datasources.yml");<br/>        //4<br/>        swarm.withConfig(dataSourcesConfig);<br/>        return swarm;<br/>    }</strong><br/><br/>    <span>//4<br/></span><span>    </span><span>@Inject<br/></span><span>    </span>CatalogService <span>catalogService</span><span>;<br/></span><span><br/></span><span>    </span><span>//5<br/></span><span>    </span><span>@Test<br/></span><span>    </span><span>public void </span><span>testSearchById</span>() {<br/>        Assert.<span>assertEquals</span>(<span>catalogService</span>.searchById(<span>"turtle"</span>).getName()<span>,</span><span>"turtle"</span>)<span>;<br/></span><span>    </span>}<br/>}</pre>
<p>In the beginning, we created the deployment with all the necessary classes and configurations.</p>
<div class="packt_infobox">We have to add the datasource configuration, the persistence configuration, and the load file (1) so that they can be read from within the test.</div>
<p>The key part is the <kbd>createSwarm</kbd> method (2) mentioned previously. It creates the Swarm instance, reads the datasources configuration (3), and configures Swarm with it (4).</p>
<p>When the container and deployment are ready, we can start writing the test logic. We start by injecting the <kbd>CatalogService</kbd> to the test (4). Recall that this test runs inside the Swarm container, and as a result, the service can be injected into it. Finally, to ensure that our service indeed works correctly, we check whether the returned data is correct (5).<br/>
If you run the test now, you will see that it passes correctly.<br/>
However, currently, we are creating the microservices without any endpoints and testing them from inside the container. That's OK, but we would also like to test the whole microservice, using its external interface. Let's take a look at how to do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing from a standalone client</h1>
                </header>
            
            <article>
                
<p>This time, we would like to test the application from a standalone client. Let's learn how to do it.</p>
<div class="packt_infobox"><span>For examples, refer to <kbd>chapter 5/catalog-service-database-test-standalone</kbd>.</span></div>
<p>First of all, we have to add a bunch of dependencies to the <kbd>pom.xml</kbd> file:</p>
<pre><span>(...)<br/></span><span><br/></span><span>    &lt;dependencies&gt;<br/>    (...)<br/></span>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.wildfly.swarm&lt;/groupId&gt;<br/>            &lt;artifactId&gt;arquillian&lt;/artifactId&gt;<br/>            &lt;version&gt;${version.wildfly.swarm}&lt;/version&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/><span>        &lt;/dependency&gt;<br/></span><span><br/><strong>        &lt;!-- 1 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;<br/>            &lt;artifactId&gt;resteasy-client&lt;/artifactId&gt;<br/>            &lt;version&gt;${resteasy.version}&lt;/version&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span><br/><strong>        &lt;!-- 2 --&gt;</strong><br/></span><strong>        &lt;dependency&gt;<br/>            &lt;groupId&gt;org.jboss.resteasy&lt;/groupId&gt;<br/>            &lt;artifactId&gt;resteasy-jackson-provider&lt;/artifactId&gt;<br/>            &lt;version&gt;${resteasy.version}&lt;/version&gt;<br/>            &lt;scope&gt;test&lt;/scope&gt;<br/></strong><span><strong>        &lt;/dependency&gt;</strong><br/></span><span><br/></span><span>    &lt;/dependencies&gt;<br/></span><span>(...)</span></pre>
<p>We have to add a dependency to the JAX-RS client that we will use to make REST invocations on our service. As we will use the <kbd>resteasy</kbd> implementation, we will add its client (1). We would also need a library to parse the JSON response, hence the <kbd>resteasy-jackson-provider</kbd> is added (2).</p>
<p>Let's take a look at the code of the test that does it:</p>
<pre><span>package </span>org.packt.swarm.petstore.catalog<span>;<br/></span><span><br/></span><span>import </span>org.jboss.arquillian.container.test.api.<span>Deployment</span><span>;<br/></span><span>import </span>org.jboss.arquillian.container.test.api.<span>RunAsClient</span><span>;<br/></span><span>import </span>org.jboss.arquillian.junit.Arquillian<span>;<br/></span><span>import </span>org.jboss.arquillian.test.api.<span>ArquillianResource</span><span>;<br/></span><span>import </span>org.jboss.shrinkwrap.api.ShrinkWrap<span>;<br/></span><span>import </span>org.jboss.shrinkwrap.api.asset.EmptyAsset<span>;<br/></span><span>import </span>org.jboss.shrinkwrap.api.spec.WebArchive<span>;<br/></span><span>import </span>org.junit.Assert<span>;<br/></span><span>import </span>org.junit.<span>BeforeClass</span><span>;<br/></span><span>import </span>org.junit.<span>Test</span><span>;<br/></span><span>import </span>org.junit.runner.<span>RunWith</span><span>;<br/></span><span>import </span>org.packt.swarm.petstore.catalog.model.Item<span>;<br/></span><span>import </span>org.wildfly.swarm.Swarm<span>;<br/></span><span>import </span>org.wildfly.swarm.arquillian.<span>CreateSwarm</span><span>;<br/></span><span><br/></span><span>import </span>javax.ws.rs.client.Client<span>;<br/></span><span>import </span>javax.ws.rs.client.ClientBuilder<span>;<br/></span><span>import </span>javax.ws.rs.client.WebTarget<span>;<br/></span><span>import </span>java.net.URL<span>;<br/></span><span><br/></span><span>@RunWith</span>(Arquillian.<span>class</span>)<br/><span>public class </span>CatalogServiceTest {<br/><br/>    <span>@Deployment<br/></span><span>    </span><span>public static </span>WebArchive <span>createDeployment</span>() {<br/>        <span>return </span>ShrinkWrap.<span>create</span>(WebArchive.<span>class</span>)<br/><strong>                //1</strong><br/><strong>                .addClasses(Item.class, CatalogService.class, CatalogResource.class, CatalogApplication.class)</strong><br/>                .addAsResource(<span>"datasources.yml"</span>)<br/>                .addAsResource(<span>"META-INF/persistence.xml"</span>)<br/>                .addAsResource(<span>"META-INF/load.sql"</span>)<br/>                .addAsManifestResource(EmptyAsset.<span>INSTANCE</span><span>, </span><span>"beans.xml"</span>)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@CreateSwarm<br/></span><span>    </span><span>public static </span>Swarm <span>createSwarm</span>() <span>throws </span>Exception {<br/>        Swarm swarm = <span>new </span>Swarm()<span>;<br/></span><span>        </span>ClassLoader cl = CatalogServiceTest.<span>class</span>.getClassLoader()<span>;<br/></span><span>        </span>URL dataSourcesConfig = cl.getResource(<span>"datasources.yml"</span>)<span>;<br/></span><span>        </span>swarm.withConfig(dataSourcesConfig)<span>;<br/></span><span>        return </span>swarm<span>;<br/></span><span>    </span>}<br/><br/><strong>    //2<br/>    private static Client client</strong><span><strong>;</strong><br/></span><span><br/></span><strong>    //3<br/>    @BeforeClass<br/>    public static void setUpClient() {</strong><br/><strong>        client = ClientBuilder.newClient();<br/>    }</strong><br/><br/><strong>    //4<br/>    @ArquillianResource<br/>    private URL url</strong><span><strong>;</strong><br/></span><span><br/></span><strong>    //5<br/>    private Item testEndpoint(String itemId) {</strong><br/><strong>        WebTarget target = client.target(url + "item/"+itemId);<br/>        return target.request("application/json").get(Item.class);<br/>    }</strong><br/><br/>    <span>@Test<br/></span><strong>    //6<br/>    </strong><span><strong>@RunAsClient</strong><br/></span><span>    </span><span>public void </span><span>testSearchById</span>() {<br/><strong>        //7</strong><br/><strong>        Assert.assertEquals(testEndpoint("turtle").getName(),"turtle");<br/>        Assert.assertEquals(testEndpoint("hamster").getName(),"hamster")</strong><span><strong>;</strong><br/></span><span>    </span>}<br/>}</pre>
<p>There is quite a bit of stuff that we had to implement. Let's analyze it one by one.</p>
<p>As we are going to test the REST endpoint, we have to add classes that will expose it, that is, <kbd>CatalogResource</kbd> and <kbd>CatalogApplication</kbd> (1).</p>
<p>Arquillian is able to find out the URL of a created service and inject it into the test. To obtain such an object, we have to annotate the URL field with the <kbd>org.jboss.arquillian.test.api.ArquillianResource</kbd> annotation (4).</p>
<p>We have implemented the convenience test method, which makes invocations to the service and obtains item instances, based on the ID (5).</p>
<p>The most important addition to the test is annotating the <kbd>test</kbd> methods with the <kbd>org.jboss.arquillian.container.test.api.RunAsClient</kbd><em> </em><span>annotation. As a result, the test will run from Maven's JVM as a standalone client. We are using the test annotated in this way in order to create a test that will assert the correct behavior of our service, based on invocations from the test JVM (6).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned what Arquillian is and how you can use it to test Swarm microservices. You also learned how to configure Arquillian to automatically create a Swarm container, how to modify the container configuration, and how to test the created microservice from within the container and from a standalone client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="mce-root"><a href="http://arquillian.org/">http://arquillian.org/</a></p>


            </article>

            
        </section>
    </body></html>