<html><head></head><body>
  <div id="_idContainer130" class="Basic-Text-Frame">
    <h1 class="chapterNumber">4</h1>
    <h1 id="_idParaDest-163" class="chapterTitle">Records and Record Patterns</h1>
    <p class="normal">This chapter includes 19 problems that cover, in detail, the Java records introduced in JDK 16 (JEP 395), and record patterns introduced as a preview feature in JDK 19 (JEP 405), as a second preview feature in JDK 20 (JEP 432), and as a final feature in JDK 21 (JEP 440).</p>
    <p class="normal">We start by defining a simple Java record. We continue by analyzing a record’s internals, what it can and cannot contain, how to use records in streams, how they improve serialization, and so on. We are also interested in how we can use records in Spring Boot applications, including JPA and jOOQ technologies.</p>
    <p class="normal">Next, we focus on record patterns for <code class="inlineCode">instanceof</code> and <code class="inlineCode">switch</code>. We will talk about nested record patterns, guarded record patterns, handling <code class="inlineCode">null</code> values in record patterns, and so on.</p>
    <p class="normal">At the end of this chapter, you’ll have mastered Java records. This is great because records are a must-have for any Java developer who wants to adopt the coolest Java features.</p>
    <h1 id="_idParaDest-164" class="heading-1">Problems</h1>
    <p class="normal">Use the following problems to test your programming prowess on Java records. I strongly encourage you to give each problem a try before you turn to the solutions and download the example programs:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="88"><strong class="keyWord">Declaring a Java record</strong>: Write an application that exemplifies the creation of a Java record. Moreover, provide a short description of the artifacts generated by the compiler for a record behind the scenes.</li>
      <li class="numberedList"><strong class="keyWord">Introducing the canonical and compact constructors for records</strong>: Explain the role of the built-in record’s canonical and compact constructors. Provide examples of when it makes sense to provide such explicit constructors.</li>
      <li class="numberedList"><strong class="keyWord">Adding more artifacts in a record</strong>: Provide a meaningful list of examples about adding explicit artifacts in Java records (for instance, adding instance methods, static artifacts, and so on).</li>
      <li class="numberedList"><strong class="keyWord">Iterating what we cannot have in a record</strong>: Exemplify what we cannot have in a record (for instance, we cannot have explicit <code class="inlineCode">private</code> fields) and explain why.</li>
      <li class="numberedList"><strong class="keyWord">Defining multiple constructors in a record</strong>: Exemplify several approaches for declaring multiple constructors in a record.</li>
      <li class="numberedList"><strong class="keyWord">Implementing interfaces in records</strong>: Write a program that shows how to implement interfaces in records. </li>
      <li class="numberedList"><strong class="keyWord">Understanding record serialization</strong>: Explain in detail and exemplify how record serialization works behind the scenes.</li>
      <li class="numberedList"><strong class="keyWord">Invoking the canonical constructor via reflection</strong>: Write a program that exemplifies how to invoke, via reflection, the canonical constructor of a record.</li>
      <li class="numberedList"><strong class="keyWord">Using records in streams</strong>: Write several examples to highlight the usage of records for simplifying functional expressions relying on the Stream API.</li>
      <li class="numberedList"><strong class="keyWord">Introducing record patterns for instanceof</strong>: Write a bunch of examples that introduce <em class="italic">record patterns</em> for <code class="inlineCode">instanceof</code>, including <em class="italic">nested record patterns</em>. </li>
      <li class="numberedList"><strong class="keyWord">Introducing record patterns for switch</strong>: Write a bunch of examples that introduce <em class="italic">record patterns</em> for <code class="inlineCode">switch</code>.</li>
      <li class="numberedList"><strong class="keyWord">Tackling guarded record patterns</strong>: Write several snippets of code to exemplify <em class="italic">guarded record patterns</em> (guarded conditions based on the binding variables).</li>
      <li class="numberedList"><strong class="keyWord">Using generic records in record patterns</strong>: Write an application that highlights the declaration and usage of generic records.</li>
      <li class="numberedList"><strong class="keyWord">Handling nulls in nested record patterns</strong>: Explain and exemplify how to deal with <code class="inlineCode">null</code> values in record patterns (explain the edge case of <code class="inlineCode">null</code> values in nested record patterns as well).</li>
      <li class="numberedList"><strong class="keyWord">Simplifying expressions via record patterns</strong>: Imagine that you have an expression (arithmetic, string-based, Abstract Syntax Tree (AST), and so on). Write a program that uses record patterns to simplify the code for evaluating/transforming this expression.</li>
      <li class="numberedList"><strong class="keyWord">Hooking unnamed patterns and variables:</strong> Explain and exemplify the JDK 21 preview feature covering unnamed patterns and variables.</li>
      <li class="numberedList"><strong class="keyWord">Tackling records in Spring Boot</strong>: Write several applications for exemplifying different use cases of records in Spring Boot (for instance, using records in templates, using records for configurations, and so on).</li>
      <li class="numberedList"><strong class="keyWord">Tackling records in JPA</strong>: Write several applications for exemplifying different use cases of records in JPA (for instance, using records and constructor expressions, using records and result transformers, and so on).</li>
      <li class="numberedList"><strong class="keyWord">Tacking records in jOOQ</strong>: Write several applications for exemplifying different use cases of records in jOOQ (for instance, using records and the <code class="inlineCode">MULTISET</code> operator).</li>
    </ol>
    <p class="normal">The following sections describe solutions to the preceding problems. Remember that there usually isn’t a single correct way to solve a particular problem. Also, remember that the explanations shown here include only the most interesting and important details needed to solve the problems. Download the example solutions to see additional details and to experiment with the programs at <a href="https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04"><span class="url">https://github.com/PacktPublishing/Java-Coding-Problems-Second-Edition/tree/main/Chapter04</span></a>.</p>
    <h1 id="_idParaDest-165" class="heading-1">88. Declaring a Java record</h1>
    <p class="normal">Before diving into Java records, let’s think a little bit about how we commonly hold data within a Java application. You’re right … we define simple classes containing the needed instance fields populated with <a id="_idIndexMarker407"/>our data via the constructors of these classes. We also expose some specific getters, and the popular <code class="inlineCode">equals()</code>, <code class="inlineCode">hashCode()</code>, and <code class="inlineCode">toString()</code> methods. Further, we create instances of these classes that wrap our precious data and we pass them around to solve our tasks all over our application. For instance, the following class carries data about melons like the melon types and their weights:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Melon</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> float weight;
  <span class="hljs-keyword">public</span> <span class="hljs-title">Melon</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
    <span class="hljs-built_in">this</span>.type = type;
    <span class="hljs-built_in">this</span>.weight = weight;
  }
  <span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> type;
  }
  <span class="hljs-keyword">public</span> float<span class="hljs-title"> getWeight</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> weight;
  }
  <span class="hljs-comment">// hashCode(), equals(), and to String()</span>
}
</code></pre>
    <p class="normal">You should be pretty familiar with this kind of traditional Java class and this tedious ceremony, so there is no need to go over this code in detail. Now, let’s see how we can accomplish the exact same thing but using Java record syntactical sugar that drastically reduces the previous ceremony:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {}
</code></pre>
    <p class="normal">Java records were<a id="_idIndexMarker408"/> delivered as a feature preview starting with JDK 14, and it was released and closed in JDK 16 as JEP 395. This single line of code gives us the same behavior as the previous one, the <code class="inlineCode">Melon</code> class. Behind the scenes, the compiler provides all the artifacts, including two <code class="inlineCode">private</code> <code class="inlineCode">final</code> fields (<code class="inlineCode">type</code> and <code class="inlineCode">weight</code>), a constructor, two accessor methods having the same names as the fields (<code class="inlineCode">type()</code> and <code class="inlineCode">weight()</code>), and the trilogy containing <code class="inlineCode">hashCode()</code>, <code class="inlineCode">equals()</code>, and <code class="inlineCode">toString()</code>. We can easily see the code generated by the compiler by calling the <code class="inlineCode">javap</code> tool on the <code class="inlineCode">MelonRecord</code> class:</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_01.png" alt="Figure 4.1.png"/></figure>
    <p class="packt_figref">Figure 4.1: The code of a Java record</p>
    <p class="normal">Pay attention that these accessor’s names don’t follow the Java Bean convention, so there is no <code class="inlineCode">getType()</code> or <code class="inlineCode">getWeight()</code>. There is <code class="inlineCode">type()</code> and <code class="inlineCode">weight()</code>. However, you can explicitly write these accessors or explicitly add the <code class="inlineCode">getType()</code>/<code class="inlineCode">getWeight()</code> getters – for instance, for exposing defensive copies of fields.</p>
    <p class="normal">All these things are built based on the parameters given when we declare a record (<code class="inlineCode">type</code> and <code class="inlineCode">weight</code>). These parameters are also known as the components of the record and we say that a record is built on the given components.</p>
    <p class="normal">The compiler recognizes a Java record via the <code class="inlineCode">record</code> keyword. This is a special type of class (exactly like <code class="inlineCode">enum</code> is a special type of Java class) declared as <code class="inlineCode">final</code> and automatically extending <code class="inlineCode">java.lang.Record</code>.</p>
    <p class="normal">Instantiating <code class="inlineCode">MelonRecord</code> is the same as instantiating the <code class="inlineCode">Melon</code> class. The following code creates a <code class="inlineCode">Melon</code> instance and a <code class="inlineCode">MelonRecord</code> instance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">Melon</span> <span class="hljs-variable">melon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"Cantaloupe"</span>, <span class="hljs-number">2600</span>);
<span class="hljs-type">MelonRecord</span> <span class="hljs-variable">melonr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(<span class="hljs-string">"Cantaloupe"</span>, <span class="hljs-number">2600</span>);
</code></pre>
    <p class="normal">Java records are not an alternative to mutable Java Bean classes. Moreover, you may think that a Java record is just<a id="_idIndexMarker409"/> a plain transparent approach for carrying immutable data or an immutable state (we say “transparent” because it fully exposes its state, and we say “immutable” because the class is <code class="inlineCode">final</code>, it has only <code class="inlineCode">private</code> <code class="inlineCode">final</code> fields, and no setters). In this context, we may think that Java records are not quite useful because they just overlap the functionality that we can obtain via Lombok or Kotlin. But as you’ll see in this chapter, a Java record is more than that, and it provides several features that are not available in Lombok or Kotlin. Moreover, if you benchmark, you’ll notice that using records has significant advantages in the performance context.</p>
    <h1 id="_idParaDest-166" class="heading-1">89. Introducing the canonical and compact constructors for records</h1>
    <p class="normal">In the previous problem, we created the <code class="inlineCode">MelonRecord</code> Java record and we instantiated it via the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonRecord</span> <span class="hljs-variable">melonr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(<span class="hljs-string">"Cantaloupe"</span>, <span class="hljs-number">2600</span>);
</code></pre>
    <p class="normal">How is this possible (since we didn’t <a id="_idIndexMarker410"/>write any parameterized constructor in <code class="inlineCode">MelonRecord</code>)? The compiler just followed its internal protocol for Java records and created a default constructor based on the components that we provided in the record declaration (in this case, there are two components, <code class="inlineCode">type</code> and <code class="inlineCode">weight</code>). </p>
    <p class="normal">This constructor is known as the <em class="italic">canonical constructor</em> and it is always aligned with the given components. Every record has a canonical constructor that represents the only way to create instances of that record.</p>
    <p class="normal">But, we can redefine the canonical constructor. Here is an explicit canonical constructor similar to the default one – as you can see, the canonical constructor simply takes all the given components and sets the corresponding instance fields (also generated by the compiler as <code class="inlineCode">private</code> <code class="inlineCode">final</code> fields):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-built_in">this</span>.type = type;
  <span class="hljs-built_in">this</span>.weight = weight;
}
</code></pre>
    <p class="normal">Once the instance is created, it <a id="_idIndexMarker411"/>cannot be changed (it is immutable). It will only serve the purpose of carrying this data around your program. This explicit canonical constructor has a shortcut known as the <em class="italic">compact constructor </em>– this is specific to Java records. Since the compiler knows the list of given components, it can accomplish its job from this compact constructor, which is equivalent to the previous one:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> MelonRecord {}
</code></pre>
    <p class="normal">Pay attention to not confuse this compact constructor with the one without arguments. The following snippets are not equivalent:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> MelonRecord {}   <span class="hljs-comment">// compact constructor</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">()</span> {} <span class="hljs-comment">// constructor with no arguments</span>
</code></pre>
    <p class="normal">Of course, it doesn’t make sense to write an explicit canonical constructor just to mimic what the default one does. So, let’s examine several scenarios when redefining the canonical constructor makes sense.</p>
    <h2 id="_idParaDest-167" class="heading-2">Handling validation</h2>
    <p class="normal">At this moment, when we create a <code class="inlineCode">MelonRecord</code>, we can pass the type as <code class="inlineCode">null</code>, or the melon’s weight as a negative number. This<a id="_idIndexMarker412"/> leads to corrupted records containing non-valid data. Validating the record components can be handled in an explicit canonical constructor as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-comment">// explicit canonical constructor for validations</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">int</span><span class="hljs-params"> weight)</span> {
    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
        <span class="hljs-string">"The melon's type cannot be null"</span>);
    }
    <span class="hljs-keyword">if</span> (weight &lt; <span class="hljs-number">1000</span> || weight &gt; <span class="hljs-number">10000</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(<span class="hljs-string">"The melon's weight </span>
<span class="hljs-string">         must be between 1000 and 10000 grams"</span>);
    }
    <span class="hljs-built_in">this</span>.type = type;
    <span class="hljs-built_in">this</span>.weight = weight;
  }
}
</code></pre>
    <p class="normal">Or, via the compact <a id="_idIndexMarker413"/>constructor as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-comment">// explicit compact constructor for validations</span>
  <span class="hljs-keyword">public</span> MelonRecord {
    <span class="hljs-keyword">if</span> (type == <span class="hljs-literal">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
        <span class="hljs-string">"The melon's type cannot be null"</span>);
    }
    <span class="hljs-keyword">if</span> (weight &lt; <span class="hljs-number">1000</span> || weight &gt; <span class="hljs-number">10000</span>) { 
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(<span class="hljs-string">"The melon's weight </span>
<span class="hljs-string">        must be between 1000 and 10000 grams"</span>);
    }  
  }
}
</code></pre>
    <p class="normal">Validation handling is the most common use case for explicit canonical/compact constructors. Next, let’s see two more lesser-known use cases.</p>
    <h2 id="_idParaDest-168" class="heading-2">Reassigning components</h2>
    <p class="normal">Via an explicit canonical/compact constructor, we can reassign components. For instance, when we create a <code class="inlineCode">MelonRecord</code>, we provide its <a id="_idIndexMarker414"/>type (for instance, Cantaloupe) and its weight in grams (for instance, 2600 grams). But, if we want to use weight in kilograms (2600 g = 2.6 kg), then we can provide this conversion in an explicit canonical constructor as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// explicit canonical constructor for reassigning components</span>
<span class="hljs-keyword">public</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  weight = weight/<span class="hljs-number">1_000</span>; <span class="hljs-comment">// overwriting the component 'weight'</span>
  <span class="hljs-built_in">this</span>.type = type;
  <span class="hljs-built_in">this</span>.weight = weight; 
}
</code></pre>
    <p class="normal">As you can see, the <code class="inlineCode">weight</code> component is available and reassigned before the <code class="inlineCode">weight</code> field is initialized with the new reassigned value. In the end, the <code class="inlineCode">weight</code> component and the <code class="inlineCode">weight</code> field have the same value (2.6 kg). How about this snippet of code?</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-built_in">this</span>.type = type;
  <span class="hljs-built_in">this</span>.weight = weight/<span class="hljs-number">1_000</span>; 
}
</code></pre>
    <p class="normal">Well, in this case, in the end, the <code class="inlineCode">weight</code> field and the <code class="inlineCode">weight</code> component will have different values. The <code class="inlineCode">weight</code> field is 2.6 kg, while the <code class="inlineCode">weight</code> component is 2600 g. Pay attention that most probably this is not what you want. Let’s check another snippet:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-built_in">this</span>.type = type;
  <span class="hljs-built_in">this</span>.weight = weight; 
  weight = weight/<span class="hljs-number">1_000</span>;
}
</code></pre>
    <p class="normal">Again, in the end, the <code class="inlineCode">weight</code> field and the <code class="inlineCode">weight</code> component will have different values. The <code class="inlineCode">weight</code> field is 2600 g, while the <code class="inlineCode">weight</code> component is 2.6 kg. And again, pay attention—most probably this is not what you want. </p>
    <p class="normal">Of course, the cleanest and most simple approach relies on the compact constructor. This time, we cannot sneak in any accidental reassignments:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-comment">// explicit compact constructor for reassigning components</span>
  <span class="hljs-keyword">public</span> MelonRecord {
    weight = weight/<span class="hljs-number">1_000</span>; <span class="hljs-comment">// overwriting the component 'weight'</span>
  } 
}
</code></pre>
    <p class="normal">Finally, let’s tackle<a id="_idIndexMarker415"/> the third scenario.</p>
    <h2 id="_idParaDest-169" class="heading-2">Defensive copies of the given components</h2>
    <p class="normal">We know that a Java record is immutable. But this doesn’t mean that its components are immutable as well. Think of components such as arrays, lists, maps, dates, and so on. All these components are mutable. In order to restore total immutability, you’ll prefer to work on copies of these<a id="_idIndexMarker416"/> components rather than modify the given components. And, as you may have already intuited, this can be done via the explicit canonical constructor.</p>
    <p class="normal">For instance, let’s consider the following record that gets a single component representing the retail prices for a set of items as a <code class="inlineCode">Map</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MarketRecord</span><span class="hljs-params">(Map&lt;String, Integer&gt; retails)</span> {}
</code></pre>
    <p class="normal">This record shouldn’t modify this <code class="inlineCode">Map</code>, so it relies on an explicit canonical constructor for creating a defensive copy that will be used in subsequent tasks without any risks of modification (<code class="inlineCode">Map.copyOf()</code> returns an unmodifiable copy of the given <code class="inlineCode">Map</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MarketRecord</span><span class="hljs-params">(Map&lt;String, Integer&gt; retails)</span> {
  <span class="hljs-keyword">public</span> MarketRecord {
    retails = Map.copyOf(retails);
  }
}
</code></pre>
    <p class="normal">Basically, this is just a flavor of component reassignment.</p>
    <p class="normal">Moreover, we can return defensive copies via the accessor methods:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> Map&lt;String, Integer&gt; retails() {
  <span class="hljs-keyword">return</span> Map.copyOf(retails);
}
<span class="hljs-comment">// or, getter in Java Bean style</span>
<span class="hljs-keyword">public</span> Map&lt;String, Integer&gt; getRetails() {
  <span class="hljs-keyword">return</span> Map.copyOf(retails);
}
</code></pre>
    <p class="normal">You can practice all these <a id="_idIndexMarker417"/>examples in the bundled code.</p>
    <h1 id="_idParaDest-170" class="heading-1">90. Adding more artifacts in a record</h1>
    <p class="normal">So far, we know how to add an explicit canonical/compact constructor into a Java record. What else can we add? Well, for<a id="_idIndexMarker418"/> example, we can add instance methods as in any typical class. In the following code, we add an instance method that returns the <code class="inlineCode">weight</code> converted from grams to kilograms:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-type">float</span> <span class="hljs-title">weightToKg</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> weight / <span class="hljs-number">1_000</span>;
  }
}
</code></pre>
    <p class="normal">You can call <code class="inlineCode">weightToKg()</code> exactly as you call any other instance method of your classes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonRecord</span> <span class="hljs-variable">melon</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(<span class="hljs-string">"Cantaloupe"</span>, <span class="hljs-number">2600</span>);
<span class="hljs-comment">// 2600.0 g = 2.6 Kg</span>
System.out.println(melon.weight() + <span class="hljs-string">" g = "</span> 
  + melon.weightToKg() + <span class="hljs-string">" Kg"</span>); 
</code></pre>
    <p class="normal">Besides instance methods, we can add <code class="inlineCode">static</code> fields and methods as well. Check out this code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_MELON_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Crenshaw"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_MELON_WEIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MelonRecord <span class="hljs-title">getDefaultMelon</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(
      DEFAULT_MELON_TYPE, DEFAULT_MELON_WEIGHT);
  }
}
</code></pre>
    <p class="normal">Calling <code class="inlineCode">getDefaultMelon()</code> is done as usual via class name:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonRecord</span> <span class="hljs-variable">defaultMelon</span> <span class="hljs-operator">=</span> MelonRecord.getDefaultMelon();
</code></pre>
    <p class="normal">Adding nested classes is also<a id="_idIndexMarker419"/> possible. For example, here we add a <code class="inlineCode">static</code> nested class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Slicer</span> {
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">slice</span><span class="hljs-params">(MelonRecord mr, </span><span class="hljs-type">int</span><span class="hljs-params"> n)</span> {
      start();
      System.out.println(<span class="hljs-string">"Slicing a "</span> + mr.type() + <span class="hljs-string">" of "</span> 
        + mr.weightToKg() + <span class="hljs-string">" kg in "</span> + n + <span class="hljs-string">" slices ..."</span>);
      stop();
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> {
      System.out.println(<span class="hljs-string">"Start slicer ..."</span>);
    }
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> {
      System.out.println(<span class="hljs-string">"Stop slicer ..."</span>);
    }
  }
}
</code></pre>
    <p class="normal">And, calling <code class="inlineCode">Slicer</code> can be done as usual:</p>
    <pre class="programlisting code"><code class="hljs-code">MelonRecord.Slicer slicer = <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>.Slicer();
slicer.slice(melon, <span class="hljs-number">10</span>);
slicer.slice(defaultMelon, <span class="hljs-number">14</span>);
</code></pre>
    <p class="normal">But, even if it is allowed to add all these artifacts in a Java record, I strongly suggest you think twice before doing this. The main reason is that Java records should be about data and only data, so it is kind of weird to pollute a record with artifacts that involve additional behavior. If you hit such a scenario, then you probably need a Java class, not a Java record.</p>
    <p class="normal">In the next problem, we <a id="_idIndexMarker420"/>will see what we cannot add to a Java record.</p>
    <h1 id="_idParaDest-171" class="heading-1">91. Iterating what we cannot have in a record</h1>
    <p class="normal">There are several artifacts that <a id="_idIndexMarker421"/>we cannot have in a Java record. Let’s tackle the top 5 one by one.</p>
    <h2 id="_idParaDest-172" class="heading-2">A record cannot extend another class</h2>
    <p class="normal">Since a record already extends <code class="inlineCode">java.lang.Record</code> and Java doesn’t support multiple inheritances, we cannot write a record that extends another class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> 
  <span class="hljs-keyword">extends</span> <span class="hljs-title">Cucurbitaceae</span> {…}
</code></pre>
    <p class="normal">This snippet doesn’t compile.</p>
    <h2 id="_idParaDest-173" class="heading-2">A record cannot be extended</h2>
    <p class="normal">Java records are <code class="inlineCode">final</code> classes, so they cannot be extended:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">PumpkinClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MelonRecord</span> {…}
</code></pre>
    <p class="normal">This snippet doesn’t compile.</p>
    <h2 id="_idParaDest-174" class="heading-2">A record cannot be enriched with instance fields</h2>
    <p class="normal">When we declare a record, we also provide the components that become the instance fields of the record. Later, we cannot add more instance fields as we could in a typical class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">private</span> String color;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String color;
}
</code></pre>
    <p class="normal">Adding <code class="inlineCode">color</code> as a <code class="inlineCode">final</code> or non-<code class="inlineCode">final</code> separate field doesn’t compile.</p>
    <h2 id="_idParaDest-175" class="heading-2">A record cannot have private canonical constructors</h2>
    <p class="normal">Sometimes we create classes with <code class="inlineCode">private</code> constructors that expose <code class="inlineCode">static</code> factories for creating instances. Basically, we call the constructor indirectly via a <code class="inlineCode">static</code> factory method. This practice <a id="_idIndexMarker422"/>is not available in a Java record because <code class="inlineCode">private</code> canonical/compact constructors are not allowed:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
    <span class="hljs-built_in">this</span>.type = type;
    <span class="hljs-built_in">this</span>.weight = weight;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MelonRecord <span class="hljs-title">newInstance</span><span class="hljs-params">(</span>
<span class="hljs-params">      String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(type, weight);
  } 
}
</code></pre>
    <p class="normal">This snippet doesn’t compile. However, you can have <code class="inlineCode">public</code> canonical constructors and <code class="inlineCode">private</code> non-canonical constructors that first invoke one of the <code class="inlineCode">public</code> canonical constructors.</p>
    <h2 id="_idParaDest-176" class="heading-2">A record cannot have setters</h2>
    <p class="normal">As you saw, a Java record exposes a getter (accessor method) for each of its components. These getters have the same names as components (for <code class="inlineCode">type</code> we have <code class="inlineCode">type()</code>, not <code class="inlineCode">getType()</code>). On the other hand, we cannot have setters since the fields corresponding to the given components are <code class="inlineCode">final</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(String type)</span> {
     <span class="hljs-built_in">this</span>.type = type;
   }
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWeight</span><span class="hljs-params">(</span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
      <span class="hljs-built_in">this</span>.weight = weight;
   }
}
</code></pre>
    <p class="normal">This snippet doesn’t compile. Well, the list of artifacts that cannot be added to a Java record remains open, but<a id="_idIndexMarker423"/> these are the most common.</p>
    <h1 id="_idParaDest-177" class="heading-1">92. Defining multiple constructors in a record</h1>
    <p class="normal">As you know, when we declare a Java<a id="_idIndexMarker424"/> record, the compiler uses the given components to create a default constructor known as the canonical constructor. We can also provide an explicit canonical/compact constructor, as you saw in <em class="italic">Problem 89</em>.</p>
    <p class="normal">But, we can go even further and declare more constructors with a different list of arguments. For example, we can have a constructor with no arguments for returning a default instance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_MELON_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Crenshaw"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_MELON_WEIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;
  MelonRecord() {
    <span class="hljs-built_in">this</span>(DEFAULT_MELON_TYPE, DEFAULT_MELON_WEIGHT);
  } 
}
</code></pre>
    <p class="normal">Or, we can write a constructor that gets only the melon’s type or the melon’s weight as an argument:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_MELON_TYPE</span> <span class="hljs-operator">=</span> <span class="hljs-string">"Crenshaw"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_MELON_WEIGHT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;
  MelonRecord(String type) {
    <span class="hljs-built_in">this</span>(type, DEFAULT_MELON_WEIGHT);
  }
  MelonRecord(<span class="hljs-type">float</span> weight) {
    <span class="hljs-built_in">this</span>(DEFAULT_MELON_TYPE, weight);
  } 
}
</code></pre>
    <p class="normal">Moreover, we can add arguments that don’t fit any component (here, <code class="inlineCode">country</code>):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; countries = <span class="hljs-keyword">new</span> <span class="hljs-title">HashSet</span>&lt;&gt;();
  MelonRecord(String type, <span class="hljs-type">int</span> weight, String country) {
    <span class="hljs-built_in">this</span>(type, weight);
    MelonRecord.countries.add(country);
  }  
}
</code></pre>
    <p class="normal">What do all these constructors have in common? They all call the canonical constructor via the <code class="inlineCode">this</code> keyword. Remember that the only way to instantiate a Java record is via its canonical constructor, which<a id="_idIndexMarker425"/> can be called directly or, as you saw in the previous examples, indirectly. So, keep in mind that all explicit constructors that you add to a Java record must first call the canonical constructor.</p>
    <h1 id="_idParaDest-178" class="heading-1">93. Implementing interfaces in records</h1>
    <p class="normal">Java records cannot extend another <a id="_idIndexMarker426"/>class but they can implement any interface exactly like a typical class. Let’s consider the following interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">PestInspector</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title">detectPest</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> Math.random() &gt; <span class="hljs-number">0.5d</span>;
  }
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exterminatePest</span><span class="hljs-params">()</span>;
}
</code></pre>
    <p class="normal">The following snippet of code is a straightforward usage of this interface:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span>   
       <span class="hljs-keyword">implements</span> <span class="hljs-title">PestInspector</span> {
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exterminatePest</span><span class="hljs-params">()</span> {  
    <span class="hljs-keyword">if</span> (detectPest()) {
      System.out.println(<span class="hljs-string">"</span><span class="hljs-string">All pests have been exterminated"</span>);
    } <span class="hljs-keyword">else</span> {
      System.out.println(
        <span class="hljs-string">"This melon is clean, no pests have been found"</span>);
    }
  }
}
</code></pre>
    <p class="normal">Notice that the code <a id="_idIndexMarker427"/>overrides the <code class="inlineCode">abstract</code> method <code class="inlineCode">exterminatePest()</code> and calls the <code class="inlineCode">default</code> method <code class="inlineCode">detectPest()</code>.</p>
    <h1 id="_idParaDest-179" class="heading-1">94. Understanding record serialization</h1>
    <p class="normal">In order to understand how Java records are serialized/deserialized, let’s have a parallel between classical code based on <a id="_idIndexMarker428"/>plain Java classes and the same code but expressed via the Java record’s syntactical sugar.</p>
    <p class="normal">So, let’s consider the following two plain Java classes (we have to explicitly implement the <code class="inlineCode">Serializable</code> interface because, in the second part of this problem, we want to serialize/deserialize these classes):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Melon</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String type;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> weight;
  <span class="hljs-keyword">public</span> <span class="hljs-title">Melon</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {
    <span class="hljs-built_in">this</span>.type = type;
    <span class="hljs-built_in">this</span>.weight = weight;
  }
  <span class="hljs-comment">// getters, hashCode(), equals(), and toString()</span>
}
</code></pre>
    <p class="normal">And, the <code class="inlineCode">MelonContainer</code> class that uses the previous <code class="inlineCode">Melon</code> class:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MelonContainer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LocalDate expiration;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String batch;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Melon melon;
  <span class="hljs-keyword">public</span> <span class="hljs-title">MelonContainer</span><span class="hljs-params">(LocalDate expiration, </span>
<span class="hljs-params">      String batch, Melon melon)</span> {
    ...
    <span class="hljs-keyword">if</span> (!batch.startsWith(<span class="hljs-string">"ML"</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
        <span class="hljs-string">"The batch format should be: MLxxxxxxxx"</span>);
    }
    ...
<span class="hljs-built_in">    this</span>.expiration = expiration;
<span class="hljs-built_in">    this</span>.batch = batch;
<span class="hljs-built_in">    this</span>.melon = melon;
  }
  <span class="hljs-comment">// getters, hashCode(), equals(), and toString()</span>
}
</code></pre>
    <p class="normal">If we express this code <a id="_idIndexMarker429"/>via Java records, then we have the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonContainerRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">  LocalDate expiration, String batch, Melon melon)</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {
  <span class="hljs-keyword">public</span> MelonContainerRecord {
    ...
    <span class="hljs-keyword">if</span> (!batch.startsWith(<span class="hljs-string">"ML"</span>)) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(
        <span class="hljs-string">"The batch format should be: MLxxxxxxxx"</span>);
    } 
    ...
  }
}
</code></pre>
    <p class="normal">Notice that we have explicitly implemented the <code class="inlineCode">Serializable</code> interface since, by default, Java records<a id="_idIndexMarker430"/> are not serializable.</p>
    <p class="normal">Next, let’s create a <code class="inlineCode">MelonContainer</code> instance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonContainer</span> <span class="hljs-variable">gacContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonContainer</span>(
  LocalDate.now().plusDays(<span class="hljs-number">15</span>), <span class="hljs-string">"</span><span class="hljs-string">ML9000SQA0"</span>, 
    <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"Gac"</span>, <span class="hljs-number">5000</span>));
</code></pre>
    <p class="normal">And, a <code class="inlineCode">MelonContainerRecord</code> instance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonContainerRecord</span> <span class="hljs-variable">gacContainerR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonContainerRecord</span>(
  LocalDate.now().plusDays(<span class="hljs-number">15</span>), <span class="hljs-string">"ML9000SQA0"</span>, 
    <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"Gac"</span>, <span class="hljs-number">5000</span>));
</code></pre>
    <p class="normal">To serialize these objects (<code class="inlineCode">gacContainer</code> and <code class="inlineCode">gacContainerR</code>), we can use the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> ( <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectOutputStream</span>(
   <span class="hljs-keyword">new</span> <span class="hljs-title">FileOutputStream</span>(<span class="hljs-string">"object.data"</span>))) {
     oos.writeObject(gacContainer);
}
<span class="hljs-keyword">try</span> ( <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectOutputStream</span>(
   <span class="hljs-keyword">new</span> <span class="hljs-title">FileOutputStream</span>(<span class="hljs-string">"object_record.data"</span>))) {
     oos.writeObject(gacContainerR);
}
</code></pre>
    <p class="normal">And, the deserialization can be accomplished via the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">MelonContainer desGacContainer;
<span class="hljs-keyword">try</span> ( ObjectInputStream ios = <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectInputStream</span>(
  <span class="hljs-keyword">new</span> <span class="hljs-title">FileInputStream</span>(<span class="hljs-string">"object.data"</span>))) {
  desGacContainer = (MelonContainer) ios.readObject();
}
MelonContainerRecord desGacContainerR;
<span class="hljs-keyword">try</span> ( ObjectInputStream ios = <span class="hljs-keyword">new</span> <span class="hljs-title">ObjectInputStream</span>(
  <span class="hljs-keyword">new</span> <span class="hljs-title">FileInputStream</span>(<span class="hljs-string">"</span><span class="hljs-string">object_record.data"</span>))) {
  desGacContainerR = (MelonContainerRecord) ios.readObject();
}
</code></pre>
    <p class="normal">Before exploiting these snippets of code for a practical examination of serialization/deserialization, let’s<a id="_idIndexMarker431"/> try a theoretical approach meant to provide some hints for these operations.</p>
    <h2 id="_idParaDest-180" class="heading-2">How serialization/deserialization works</h2>
    <p class="normal">The serialization/deserialization <a id="_idIndexMarker432"/>operations are represented in the following diagram:</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_02.png" alt="Figure 4.2.png"/></figure>
    <p class="packt_figref">Figure 4.2: Java serialization/deserialization operations</p>
    <p class="normal">In a nutshell, <em class="italic">serialization</em> (or serializing an object) is the<a id="_idIndexMarker433"/> operation of extracting the state of an object as a byte stream and representing it as a persistent format (a file, a database, in memory, over the network, and so on). The reverse operation is called <em class="italic">deserialization</em> (or deserializing an <a id="_idIndexMarker434"/>object) and represents the steps of reconstructing the object state from the persistent format.</p>
    <p class="normal">In Java, an object is serializable if it implements the <code class="inlineCode">Serializable</code> interface. This is an empty interface with no state or behavior that acts as a marker for the compiler. In the absence of this interface, the compiler assumes that the object is not serializable.</p>
    <p class="normal">The compiler uses its internal algorithm for the serialization of objects. This algorithm relies on every trick in the book, like special privileges (ignoring accessibility rules) to access objects, malicious reflection, constructors bypassing, and so on. It is beyond our purpose to bring light to this dark magic, so as a developer, it is enough to know that:</p>
    <ul>
      <li class="bulletList">If a part of an object is not serializable then you’ll get a runtime error</li>
      <li class="bulletList">You can alter the serialization/ deserialization operations via the <code class="inlineCode">writeObject()</code>/<code class="inlineCode">readObject()</code> API</li>
    </ul>
    <p class="normal">Ok, now let’s see what’s going on when an object is serialized.</p>
    <h2 id="_idParaDest-181" class="heading-2">Serializing/deserializing gacContainer (a typical Java class)</h2>
    <p class="normal">The <code class="inlineCode">gacContainer</code> object is an<a id="_idIndexMarker435"/> instance of <code class="inlineCode">MelonContainer</code>, which is a plain Java class: </p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonContainer</span> <span class="hljs-variable">gacContainer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonContainer</span>(
  LocalDate.now().plusDays(<span class="hljs-number">15</span>), <span class="hljs-string">"</span><span class="hljs-string">ML9000SQA0"</span>, 
    <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"Gac"</span>, <span class="hljs-number">5000</span>));
</code></pre>
    <p class="normal">After serializing it in a file called <em class="italic">object.data</em>, we obtain the byte stream representing the <code class="inlineCode">gacContainer</code> state. While you can inspect this file in the bundled code (use a hex editor such as <a href="https://hexed.it/"><span class="url">https://hexed.it/</span></a>), here is a human-readable interpretation of its content:</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_03.png" alt="Figure 4.3.png"/></figure>
    <p class="packt_figref">Figure 4.3: Human-readable interpretation of gacContainer serialization</p>
    <p class="normal">The deserialization operation takes place by building the object graph from the top down. When the class name is known, the compiler creates an object by calling the non-arguments constructor of the first superclass of <code class="inlineCode">MelonContainer</code> that is non-serializable. In this case, that is the non-argument constructor of <code class="inlineCode">java.lang.Object</code>. So, the compiler is not calling the constructor of <code class="inlineCode">MelonContainer</code>.</p>
    <p class="normal">Next, the fields are created and set to the default values, so the created object has <code class="inlineCode">expiration</code>, <code class="inlineCode">batch</code>, and <code class="inlineCode">melon</code> as <code class="inlineCode">null</code>. Of course, this is not the correct state of our object, so we continue processing the serialization stream to extract and populate the fields with the correct values. This can be seen in the following diagram (on the left side, the created object has default values; on the right side, the fields have been populated with the correct state):</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_04.png" alt="Figure 4.4.png"/></figure>
    <p class="packt_figref">Figure 4.4: Populating the created object with the correct state</p>
    <p class="normal">When the compiler hits the <code class="inlineCode">melon</code> field, it must perform the same steps to obtain the <code class="inlineCode">Melon</code> instance. It sets the fields (<code class="inlineCode">type</code> and <code class="inlineCode">weight</code> to <code class="inlineCode">null</code>, respectively, <code class="inlineCode">0.0f</code>). Further, it reads the real values from <a id="_idIndexMarker436"/>the stream and sets the correct state for the <code class="inlineCode">melon</code> object.</p>
    <p class="normal">Finally, after the entire stream is read, the compiler will link the objects accordingly. This is shown in the following figure (1, 2, and 3 represent the steps of the deserialization operation):</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_05.png" alt="Figure 4.5.png"/></figure>
    <p class="packt_figref">Figure 4.5: Linking the objects to obtain the final state</p>
    <p class="normal">At this point, the deserialization operation has been done and we can use the resulting object.</p>
    <h3 id="_idParaDest-182" class="heading-3">Deserializing a malicious stream</h3>
    <p class="normal">Providing a malicious stream means altering the object state before deserialization. This <a id="_idIndexMarker437"/>can be done in many ways. For instance, we can manually modify the <em class="italic">object.data</em> instance in an editor (this is like an untrusted source) as in the following figure where we replaced the valid batch <code class="inlineCode">ML9000SQA0</code> with the invalid batch <code class="inlineCode">0000000000</code>:</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_06.png" alt="Figure 4.6.png"/></figure>
    <p class="packt_figref">Figure 4.6: Modify the original stream to obtain a malicious stream</p>
    <p class="normal">If we deserialize the malicious stream (in the bundle code, you can find it as the <code class="inlineCode">object_malicious.data</code> file) then<a id="_idIndexMarker438"/> you can see that the corrupted data has “successfully” landed in our object (a simple call of <code class="inlineCode">toString()</code> reveals that batch is <code class="inlineCode">0000000000</code>):</p>
    <pre class="programlisting code"><code class="hljs-code">MelonContainer{expiration=<span class="hljs-number">2023</span>-<span class="hljs-number">02</span>-<span class="hljs-number">26</span>, 
   <span class="code-highlight"><strong class="hljs-slc">batch=</strong><strong class="hljs-number-slc">0000000000</strong></span>, melon=Melon{type=Gac, weight=<span class="hljs-number">5000.0</span>}}
</code></pre>
    <p class="normal">The guarding conditions from <code class="inlineCode">Melon</code>/<code class="inlineCode">MelonContainer</code> constructors are useless since the deserialization doesn’t call these constructors.</p>
    <p class="normal">So, if we summarize the shortcomings of serializing/deserializing a Java class, we must highlight the presence of the window of time that occurs when the objects are in an improper state (waiting for the compiler to populate fields with the correct data and to link them in the final graph) and the risk of dealing with malicious states. Now, let’s pass a Java record through this process.</p>
    <h2 id="_idParaDest-183" class="heading-2">Serializing/deserializing gacContainerR (a Java record)</h2>
    <p class="normal">In a nutshell, the minimalist design of declaring Java records and their semantic constraints allows the<a id="_idIndexMarker439"/> serialization/deserialization operations to act differently from a typical Java class. And when I say “differently,” I should actually say much better and more robust. How so? Well, the serialization of a Java record is based only on its component’s state, while deserialization relies on the single point of entry for a Java record, its canonical constructor. Remember that the only way to create a Java record is to directly/indirectly call its canonical constructor? This applies to deserialization as well, so this operation can no longer bypass the canonical constructor.</p>
    <p class="normal">That being said, the <code class="inlineCode">gacContainerR</code> object is a <code class="inlineCode">MelonContainerRecord</code> instance:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">MelonContainerRecord</span> <span class="hljs-variable">gacContainerR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonContainerRecord</span>(
  LocalDate.now().plusDays(<span class="hljs-number">15</span>), <span class="hljs-string">"ML9000SQA0"</span>, 
    <span class="hljs-keyword">new</span> <span class="hljs-title">Melon</span>(<span class="hljs-string">"</span><span class="hljs-string">Gac"</span>, <span class="hljs-number">5000</span>));
</code></pre>
    <p class="normal">After serializing it in a file called <code class="inlineCode">object_record.data</code>, we obtain the byte stream representing the <code class="inlineCode">gacContainerR</code> state. While you can inspect this file in the bundled code (use a hex editor such as <a href="https://hexed.it/"><span class="url">https://hexed.it/</span></a>), here is a human-readable interpretation of its content:</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_07.png" alt="Figure 4.7.png"/></figure>
    <p class="packt_figref">Figure 4.7: Human-readable interpretation of MelonContainerRecord serialization</p>
    <p class="normal">Yes, you’re right—with the exception of the class name (<code class="inlineCode">MelonContainerRecord</code>), the rest is the same as in <em class="italic">Figure 4.3</em>. This sustains the migration from ordinary/regular Java classes to Java records. This time, the compiler can use the accessors exposed by the record, so no dark magic is needed.</p>
    <p class="normal">Ok, so nothing got our attention here, so let’s examine the deserialization operation.</p>
    <p class="normal">Remember that for regular Java classes, the deserialization builds the object graph from the top down. In the case of Java records, this operation takes place from the bottom up, so in reverse order. In other words, this time, the compiler reads first the fields (primitives and reconstructed objects) from the stream and stores them in memory. Next, having all the fields in its hands, the compiler tries to match these fields (their names and values) against the components of the record. Any field from the stream that doesn’t match a component (name and value) is dropped from the deserialization operation. Finally, after the match is successfully performed, the compiler calls the canonical constructor to reconstruct the record object state.</p>
    <h3 id="_idParaDest-184" class="heading-3">Deserializing a malicious stream</h3>
    <p class="normal">In the bundled code, you can find a file named <code class="inlineCode">object_record_malicious.data</code> where we replaced the valid <a id="_idIndexMarker440"/>batch <code class="inlineCode">ML9000SQA0</code> with the invalid batch <code class="inlineCode">0000000000</code>. This time, deserializing this malicious stream will result in the exception from the following figure:</p>
    <figure class="mediaobject"><img src="../Images/B19665_04_08.png" alt="Figure 4.9.png"/></figure>
    <p class="packt_figref">Figure 4.8: Deserializing a malicious stream causing an exception</p>
    <p class="normal">As you already know, this exception originates in our guarding condition added in the explicit canonical constructor of our Java record. </p>
    <p class="normal">It is obvious that Java records significantly improve serialization/deserialization operations. This time, there is no moment when the reconstructed objects are in a corrupted state, and the malicious streams can be intercepted by guarding conditions placed in the canonical/compact constructor.</p>
    <p class="normal">In other words, the record’s semantic constraints, their minimalist design, the state accessible only via the accessor methods, and the object creation only via the canonical constructors sustain the serialization/deserialization as a trusted process.</p>
    <h2 id="_idParaDest-185" class="heading-2">Refactoring legacy serialization</h2>
    <p class="normal">Serialization/deserialization via Java<a id="_idIndexMarker441"/> records is awesome, but what can we do in the case of legacy code, such as <code class="inlineCode">MelonContainer</code>? We cannot take all our legacy classes that act as carriers of data and rewrite them as Java records. It will consume a lot of work and time.</p>
    <p class="normal">Actually, there is a solution backed in the serialization mechanism that requires us to add two methods named <code class="inlineCode">writeReplace()</code> and <code class="inlineCode">readResolve()</code>. By following this reasonable refactoring step, we can serialize legacy code as records and deserialize it back into legacy code.</p>
    <p class="normal">If we apply this refactoring step to <code class="inlineCode">MelonContainer</code>, then we start by adding the <code class="inlineCode">writeReplace()</code> method in this class as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Serial</span>
<span class="hljs-keyword">private</span> Object <span class="hljs-title">writeReplace</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonContainerRecord</span>(expiration, batch, melon);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">writeReplace()</code> method must throw an <code class="inlineCode">ObjectStreamException</code> and return an instance of <code class="inlineCode">MelonContainerRecord</code>. The <a id="_idIndexMarker442"/>compiler will use this method for serializing <code class="inlineCode">MelonContainer</code> instances as long as we mark it with the <code class="inlineCode">@Serial</code> annotation. Now, the serialization of a <code class="inlineCode">MelonContainer</code> instance will produce the <em class="italic">object.data</em> file containing the byte stream corresponding to a <code class="inlineCode">MelonContainerRecord</code> instance.</p>
    <p class="normal">Next, the <code class="inlineCode">readResolve()</code> method must be added to the <code class="inlineCode">MelonContainerRecord</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Serial</span>
<span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">MelonContainer</span>(expiration, batch, melon);
}
</code></pre>
    <p class="normal">The <code class="inlineCode">readResolve()</code> method must throw an <code class="inlineCode">ObjectStreamException</code> and return an instance of <code class="inlineCode">MelonContainer</code>. Again, the compiler will use this method for deserializing <code class="inlineCode">MelonContainerRecord</code> instances as long as we mark it with the <code class="inlineCode">@Serial</code> annotation.</p>
    <p class="normal">When the compiler deserializes an instance of <code class="inlineCode">MelonContainerRecord</code>, it will call the canonical constructor of this record, so it will pass through our guarding conditions. This means that a malicious stream will not pass the guarding conditions, so we avoid creating corrupted objects. If the stream contains valid values, then the <code class="inlineCode">readResolve()</code> method will use them to reconstruct the legacy <code class="inlineCode">MelonContainer</code>.</p>
    <p class="normal">Hey, Kotlin/Lombok, can you do this? No, you can’t!</p>
    <p class="normal">In the bundled code, you can find a file named <code class="inlineCode">object_malicious.data</code> that you can use to practice the previous statement.</p>
    <h1 id="_idParaDest-186" class="heading-1">95. Invoking the canonical constructor via reflection</h1>
    <p class="normal">It is not a daily task to invoke the canonical constructor of a Java record via reflection. However, this can be accomplished<a id="_idIndexMarker443"/> quite easily starting with JDK 16, which provides in <code class="inlineCode">java.lang.Class</code> the <code class="inlineCode">RecordComponent[] getRecordComponents()</code> method. As its name and signature suggest, this method returns an array of <code class="inlineCode">java.lang.reflect.RecordComponent</code> representing the components of the current Java record.</p>
    <p class="normal">Having this array of components, we can call the well-known <code class="inlineCode">getDeclaredConstructor()</code> method to identify the constructor that gets as arguments exactly this array of components. And that is the canonical constructor.</p>
    <p class="normal">The code that puts these statements into practice is provided by the Java documentation itself, so there is no need to reinvent it. Here it is:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this method is from the official documentation of JDK</span>
<span class="hljs-comment">// https://docs.oracle.com/en/java/javase/19/docs/api/</span>
<span class="hljs-comment">// java.base/java/lang/Class.html#getRecordComponents()</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title">Record</span>&gt; Constructor&lt;T&gt;
<span class="hljs-title">      getCanonicalConstructor</span><span class="hljs-params">(Class&lt;T&gt; cls)</span>
          <span class="hljs-keyword">throws</span> NoSuchMethodException {
  Class&lt;?&gt;[] paramTypes
    = Arrays.stream(cls.getRecordComponents())
            .map(RecordComponent::getType)
            .toArray(Class&lt;?&gt;[]::<span class="hljs-keyword">new</span>);
  <span class="hljs-keyword">return</span> cls.getDeclaredConstructor(paramTypes);
}
</code></pre>
    <p class="normal">Consider the following records:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonMarketRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">  List&lt;MelonRecord&gt; melons, String country)</span> {}
</code></pre>
    <p class="normal">Finding and calling the canonical constructors for these records via the previous solution can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Constructor&lt;MelonRecord&gt; cmr = 
   Records.getCanonicalConstructor(MelonRecord.class);
<span class="hljs-type">MelonRecord</span> <span class="hljs-variable">m1</span> <span class="hljs-operator">=</span> cmr.newInstance(<span class="hljs-string">"Gac"</span>, <span class="hljs-number">5000f</span>);
<span class="hljs-type">MelonRecord</span> <span class="hljs-variable">m2</span> <span class="hljs-operator">=</span> cmr.newInstance(<span class="hljs-string">"Hemi"</span>, <span class="hljs-number">1400f</span>);
Constructor&lt;MelonMarketRecord&gt; cmmr = 
   Records.getCanonicalConstructor(MelonMarketRecord.class);
  <span class="hljs-type">MelonMarketRecord</span> <span class="hljs-variable">mm</span> <span class="hljs-operator">=</span> cmmr.newInstance(
     List.of(m1, m2), <span class="hljs-string">"China"</span>);
</code></pre>
    <p class="normal">If you need deep coverage<a id="_idIndexMarker444"/> of Java reflection principles, then consider <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 7</em>.</p>
    <h1 id="_idParaDest-187" class="heading-1">96. Using records in streams</h1>
    <p class="normal">Consider the <code class="inlineCode">MelonRecord</code> that we have <a id="_idIndexMarker445"/>used before:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {}
</code></pre>
    <p class="normal">And a list of melons as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;MelonRecord&gt; melons = Arrays.asList(
  <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(<span class="hljs-string">"</span><span class="hljs-string">Crenshaw"</span>, <span class="hljs-number">1200</span>),
  <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(<span class="hljs-string">"Gac"</span>, <span class="hljs-number">3000</span>), 
  <span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(<span class="hljs-string">"Hemi"</span>, <span class="hljs-number">2600</span>),
  ...
);
</code></pre>
    <p class="normal">Our goal is to iterate this list of melons and extract the total weight and the list of weights. This data can be carried by a regular Java class or by another record as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">WeightsAndTotalRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">  </span><span class="hljs-type">double</span><span class="hljs-params"> totalWeight, List&lt;Float&gt; weights)</span> {}
</code></pre>
    <p class="normal">Populating this record with data can be done in several ways, but if we prefer the Stream API then most probably we will go for the <code class="inlineCode">Collectors.teeing()</code> collector. We won’t go into too much detail here, but we’ll quickly show that it is useful for merging the results of two downstream collectors. (If you’re interested, you can find more details about this particular collector in <em class="italic">Java Coding Problems, First Edition, Chapter 9, Problem 192</em>.)</p>
    <p class="normal">Let’s see the code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">WeightsAndTotalRecord</span> <span class="hljs-variable">weightsAndTotal</span> <span class="hljs-operator">=</span> melons.stream()
  .collect(Collectors.teeing(
     summingDouble(MelonRecord::weight),
     mapping(MelonRecord::weight, toList()),
     WeightsAndTotalRecord::<span class="hljs-keyword">new</span>
));
</code></pre>
    <p class="normal">Here, we have the <code class="inlineCode">summingDouble()</code> collector, which computes the total weight, and the <code class="inlineCode">mapping()</code> collector, which maps the weights in a list. The results of these two downstream collectors are merged in <code class="inlineCode">WeightsAndTotalRecord</code>.</p>
    <p class="normal">As you can see, the<a id="_idIndexMarker446"/> Stream API and records represent a very nice combo. Let’s have another example starting from this functional code:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Double, Long&gt; elevations = DoubleStream.of(
      <span class="hljs-number">22</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">100</span>, <span class="hljs-number">123</span>, <span class="hljs-number">22</span>, <span class="hljs-number">230</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">250</span>, <span class="hljs-number">22</span>)
  .filter(e -&gt; e &gt; <span class="hljs-number">0</span>)
  .map(e -&gt; e * <span class="hljs-number">0.393701</span>)   
  .mapToObj(e -&gt; (<span class="hljs-type">double</span>) e)
  .collect(Collectors.groupingBy(
     Function.identity(), counting()));
</code></pre>
    <p class="normal">This code starts from a list of elevations given in centimeters (based on sea level being 0). First, we want to keep only the positive elevations (so, we apply <code class="inlineCode">filter()</code>). Next, these will be converted to inches (via <code class="inlineCode">map()</code>) and counted (via the <code class="inlineCode">groupingBy()</code> and <code class="inlineCode">counting()</code> collectors). </p>
    <p class="normal">The resulting data is carried by <code class="inlineCode">Map&lt;Double, Long&gt;</code>, which is not very expressive. If we pull this map out of the context (for instance, we pass it as an argument into a method), it is hard to say what <code class="inlineCode">Double</code> and <code class="inlineCode">Long</code> represent. It would be more expressive to have something such as <code class="inlineCode">Map&lt;Elevation, ElevationCount&gt;</code>, which clearly describes its content. </p>
    <p class="normal">So, <code class="inlineCode">Elevation</code> and <code class="inlineCode">ElevationCount</code> can be two records as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">record</span> <span class="hljs-title">Elevation</span><span class="hljs-params">(</span><span class="hljs-type">double</span><span class="hljs-params"> value)</span> { 
  Elevation(<span class="hljs-type">double</span> value) { 
    <span class="hljs-built_in">this</span>.value = value * <span class="hljs-number">0.393701</span>;
  } 
}
<span class="hljs-keyword">record</span> <span class="hljs-title">ElevationCount</span><span class="hljs-params">(</span><span class="hljs-type">long</span><span class="hljs-params"> count)</span> {}
</code></pre>
    <p class="normal">To simplify the functional code a little bit, we also moved to convert from centimeters to inches in the <code class="inlineCode">Elevation</code> record, inside its explicit canonical constructor. This time, the functional code can be rewritten as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">Map&lt;Elevation, ElevationCount&gt; elevations = DoubleStream.of(
      <span class="hljs-number">22</span>, -<span class="hljs-number">10</span>, <span class="hljs-number">100</span>, -<span class="hljs-number">5</span>, <span class="hljs-number">100</span>, <span class="hljs-number">123</span>, <span class="hljs-number">22</span>, <span class="hljs-number">230</span>, -<span class="hljs-number">1</span>, <span class="hljs-number">250</span>, <span class="hljs-number">22</span>)
  .filter(e -&gt; e &gt; <span class="hljs-number">0</span>)                
  .mapToObj(Elevation::<span class="hljs-keyword">new</span>)
  .collect(Collectors.groupingBy(Function.identity(), 
           Collectors.collectingAndThen(counting(), 
             ElevationCount::<span class="hljs-keyword">new</span>)));
</code></pre>
    <p class="normal">Now, passing <code class="inlineCode">Map&lt;Elevation, ElevationCount&gt;</code> to a method dispels any doubt about its content. Any team member <a id="_idIndexMarker447"/>can inspect these records in the blink of an eye without losing time reading our functional implementation in order to deduce what <code class="inlineCode">Double</code> and <code class="inlineCode">Long</code> represent. We can be even more expressive and rename the <code class="inlineCode">Elevation</code> record as <code class="inlineCode">PositiveElevation</code>.</p>
    <h1 id="_idParaDest-188" class="heading-1">97. Introducing record patterns for instanceof</h1>
    <p class="normal">In order to introduce <em class="italic">record patterns</em>, we need <a id="_idIndexMarker448"/>a more complex record than the one we’ve used so far, so here’s one:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(String name, String specialty)</span> 
<span class="hljs-keyword">  implements</span> <span class="hljs-title">Staff</span> {}
</code></pre>
    <p class="normal">This record implements the <code class="inlineCode">Staff</code> interface as any other employee of our hospital. Now, we can identify a certain doctor in the old-fashioned style via <code class="inlineCode">instanceof</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">cabinet</span><span class="hljs-params">(Staff staff)</span> {
  <span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> Doctor) {
    <span class="hljs-type">Doctor</span> <span class="hljs-variable">dr</span> <span class="hljs-operator">=</span> (Doctor) staff;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Cabinet of "</span> + dr.specialty() 
      + <span class="hljs-string">". Doctor: "</span> + dr.name();
  }
  ...
}
</code></pre>
    <p class="normal">But, as we know from <em class="italic">Chapter</em> 2, <em class="italic">Problems</em> <em class="italic">58-67</em>, JDK has introduced <em class="italic">type patterns</em> that can be used for <code class="inlineCode">instanceof</code> and <code class="inlineCode">switch</code>. So, in this particular case, we can rewrite the previous code via type patterns as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">cabinet</span><span class="hljs-params">(Staff staff)</span> {
  <span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> Doctor dr) { <span class="hljs-comment">// type pattern matching</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Cabinet of "</span> + dr.specialty() 
       + <span class="hljs-string">". Doctor: "</span> + dr.name();
  }
  ...
}
</code></pre>
    <p class="normal">Nothing is new so far! The binding variable <code class="inlineCode">dr</code> can be used to call the record accessor’s <code class="inlineCode">specialty()</code> and <code class="inlineCode">name()</code>, to add checks, computations, and so on. But, the compiler knows very well that the <code class="inlineCode">Doctor</code> record was built based on two components (<code class="inlineCode">name</code> and <code class="inlineCode">specialty</code>) so the compiler should be able to deconstruct this object and give us these components directly as binding <a id="_idIndexMarker449"/>variables instead of accessing them via <code class="inlineCode">dr</code>.</p>
    <p class="normal">This is exactly what <em class="italic">record pattern matching</em> is all about. Record pattern matching appeared as a preview feature in JDK 19 (JEP 405), as a second preview feature in JDK 20 (JEP 432), and as a final release in JDK 21 (JEP 440).</p>
    <p class="normal">Record pattern matching is exactly the syntax of declaring <code class="inlineCode">name</code> and <code class="inlineCode">specialty</code> as binding variables by following the same declaration syntax as in the record itself (or like in the canonical constructor). Here is the previous code written via record patterns:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">cabinet</span><span class="hljs-params">(Staff staff)</span> { 
  <span class="hljs-comment">// record pattern matching</span>
  <span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="code-highlight"><strong class="hljs-title-slc">Doctor</strong><strong class="hljs-params-slc">(String name, String specialty)</strong></span>){ 
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Cabinet of "</span> + name + <span class="hljs-string">". Doctor: "</span> + specialty;
  }
  ...
}
</code></pre>
    <p class="normal">Very simple, isn’t it? </p>
    <p class="normal">Now, <code class="inlineCode">name</code> and <code class="inlineCode">specialty</code> are the binding variables that can be used directly. We simply put this syntax in place of the type pattern. In other words, we replaced the type pattern with a record pattern.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">The compiler exposes the record’s components via the corresponding binding variables. This is accomplished by deconstructing records in pattern matching, which is referred to as <em class="italic">record patterns</em>. In other <a id="_idIndexMarker450"/>words, the deconstruction patterns allow us to access the components of an object in a very handy, intuitive, and readable way.</p>
      <p class="normal">In record patterns, it is the compiler’s responsibility to initialize binding variables such as <code class="inlineCode">name</code> and <code class="inlineCode">specialty</code>. In order to accomplish this, the compiler calls the accessors of the corresponding components. This means that if you have some extra code in these accessors (for example, return defensive copies, perform validations or apply constraints, and so on), then this code is properly executed.</p>
    </div>
    <p class="normal">Let’s go further and work <a id="_idIndexMarker451"/>with some nested records.</p>
    <h2 id="_idParaDest-189" class="heading-2">Nested records and record patterns</h2>
    <p class="normal">Let’s assume that besides the <code class="inlineCode">Doctor</code> record, we <a id="_idIndexMarker452"/>also have the following<a id="_idIndexMarker453"/> record:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String name, Doctor doctor)</span> 
<span class="hljs-keyword">  implements</span> <span class="hljs-title">Staff</span> {}
</code></pre>
    <p class="normal">Each resident has a coordinator, which is a doctor, so a <code class="inlineCode">Resident</code> nests a <code class="inlineCode">Doctor</code>. This time, we have to nest the record patterns accordingly as in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">cabinet</span><span class="hljs-params">(Staff staff)</span> { 
  <span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String rsname, </span>
<span class="hljs-params">      Doctor(String drname, String specialty)</span>)) { 
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Cabinet of "</span> + specialty + <span class="hljs-string">". Doctor: "</span> 
                         + drname + <span class="hljs-string">", Resident: "</span> + rsname;
  }  
  ...
}
</code></pre>
    <p class="normal">Both the resident and the doctor, have a <code class="inlineCode">name</code> component. But we cannot use the binding variable <code class="inlineCode">name</code> twice in this context since it will cause a conflict. This is why we have <code class="inlineCode">rsname</code> and <code class="inlineCode">drname</code>. Notice that the names of the binding variables don’t have to mirror the names of the components. This<a id="_idIndexMarker454"/> is possible because the compiler identifies components by position not <a id="_idIndexMarker455"/>by their names. But, of course, when it is possible, mirroring the name reduces the confusion and keeps the readability of the code high.</p>
    <p class="normal">If there is no need to deconstruct the <code class="inlineCode">Doctor</code> record, then we can write it like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String name, Doctor dr)</span>) { 
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Cabinet of "</span> + dr.specialty() + <span class="hljs-string">". Doctor: "</span> 
                       + dr.name() + <span class="hljs-string">", Resident: "</span> + name;
}
</code></pre>
    <p class="normal">Adding more nested records follows the same principle. For instance, let’s add the <code class="inlineCode">Patient</code> and <code class="inlineCode">Appointment</code> records as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Appointment</span><span class="hljs-params">(LocalDate date, Doctor doctor)</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span>
<span class="hljs-params">  String name, </span><span class="hljs-type">int</span><span class="hljs-params"> npi, Appointment appointment)</span> {}
</code></pre>
    <p class="normal">Now, we can write the following beauty:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reception</span><span class="hljs-params">(Object o)</span> {
  <span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> ptname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> npi, </span>
<span class="hljs-params">                  Appointment(</span><span class="hljs-keyword">var</span><span class="hljs-params"> date, </span>
<span class="hljs-params">                  Doctor (</span><span class="hljs-keyword">var</span><span class="hljs-params"> drname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span>))) {
   <span class="hljs-keyword">return</span> <span class="hljs-string">"Patient "</span> + ptname + <span class="hljs-string">" (NPI: "</span> + npi
          + <span class="hljs-string">") has an appointment at "</span>
          + date + <span class="hljs-string">" to the doctor "</span> + drname
          + <span class="hljs-string">" ("</span> + specialty + <span class="hljs-string">")."</span>;
  }
  ...
}
</code></pre>
    <p class="normal">Or, if we don’t want to deconstruct <code class="inlineCode">Appointment</code> and use <code class="inlineCode">var</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span>
<span class="hljs-params">    </span><span class="hljs-keyword">var</span><span class="hljs-params"> ptname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> npi, </span><span class="hljs-keyword">var</span><span class="hljs-params"> ap)</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Patient "</span> + ptname + <span class="hljs-string">" (NPI: "</span> + npi
       + <span class="hljs-string">") has an appointment at "</span>
       + ap.date() + <span class="hljs-string">" to the doctor "</span> + ap.doctor().name() 
       + <span class="hljs-string">" ("</span> + ap.doctor().specialty() + <span class="hljs-string">")."</span>;
}
</code></pre>
    <p class="normal">Notice that, this time, we have used <code class="inlineCode">var</code> instead of explicit types. Feel free to do the same since <code class="inlineCode">var</code> fits very well in <a id="_idIndexMarker456"/>this case. If you are not familiar with type inference, then consider <em class="italic">Java Coding Problems</em>, <em class="italic">First Edition</em>, <em class="italic">Chapter 4</em>, which contains detailed explanations and best<a id="_idIndexMarker457"/> practices. More details about argument type inference in record patterns are available later in this chapter in <em class="italic">Problem 100</em>.</p>
    <p class="normal">I think you got the idea!</p>
    <h1 id="_idParaDest-190" class="heading-1">98. Introducing record patterns for switch</h1>
    <p class="normal">You already know that type patterns can be used for <code class="inlineCode">instanceof</code> and <code class="inlineCode">switch</code> expressions. This statement is true<a id="_idIndexMarker458"/> for record patterns as well. For instance, let’s reiterate the <code class="inlineCode">Doctor</code> and <code class="inlineCode">Resident</code> records:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(String name, String specialty)</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">Staff</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String name, Doctor doctor)</span> 
  <span class="hljs-keyword">implements</span> <span class="hljs-title">Staff</span> {}
</code></pre>
    <p class="normal">We can easily use these two records via record patterns in a <code class="inlineCode">switch</code> expression as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">cabinet</span><span class="hljs-params">(Staff staff)</span> {
 <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(staff) {  
  <span class="hljs-keyword">case</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> name, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span> 
    -&gt; <span class="hljs-string">"Cabinet of "</span> + specialty + <span class="hljs-string">". Doctor: "</span> + name;
  <span class="hljs-keyword">case</span> <span class="hljs-title">Resident</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> rsname, Doctor(</span><span class="hljs-keyword">var</span><span class="hljs-params"> drname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span>) 
    -&gt; <span class="hljs-string">"Cabinet of "</span> + specialty + <span class="hljs-string">". Doctor: "</span> 
                     + drname + <span class="hljs-string">", Resident: "</span> + rsname;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"Cabinet closed"</span>;
 }; 
}
</code></pre>
    <p class="normal">Adding more nested records follows the same principle. For instance, let’s add the <code class="inlineCode">Patient</code> and <code class="inlineCode">Appointment</code> records as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Appointment</span><span class="hljs-params">(LocalDate date, Doctor doctor)</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span>
<span class="hljs-params">  String name, </span><span class="hljs-type">int</span><span class="hljs-params"> npi, Appointment appointment)</span> {}
</code></pre>
    <p class="normal">Now, we can write the following beauty:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reception</span><span class="hljs-params">(Object o)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {           
    <span class="hljs-keyword">case</span> <span class="hljs-title">Patient</span><span class="hljs-params">(String ptname, </span><span class="hljs-type">int</span><span class="hljs-params"> npi, </span>
<span class="hljs-params">         Appointment(LocalDate date, </span>
<span class="hljs-params">         Doctor (String drname, String specialty)</span>)) -&gt;
           <span class="hljs-string">"Patient "</span> + ptname + <span class="hljs-string">" (NPI: "</span> + npi
              + <span class="hljs-string">") has an appointment at "</span>
              + date + <span class="hljs-string">" to the doctor "</span> + drname + <span class="hljs-string">" ("</span> 
              + specialty + <span class="hljs-string">")."</span>;
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">""</span>;
  };
}
</code></pre>
    <p class="normal">Or, without<a id="_idIndexMarker459"/> deconstructing <code class="inlineCode">Appointment</code> and using <code class="inlineCode">var</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
  <span class="hljs-keyword">case</span> <span class="hljs-title">Patient</span><span class="hljs-params">(var ptname, var npi, </span><span class="hljs-keyword">var</span><span class="hljs-params"> ap)</span> -&gt;
    <span class="hljs-string">"Patient "</span> + ptname + <span class="hljs-string">" (NPI: "</span> 
    + npi + <span class="hljs-string">"</span><span class="hljs-string">) has an appointment at "</span>
    + ap.date() + <span class="hljs-string">" to the doctor "</span> + ap.doctor().name() 
    + <span class="hljs-string">" ("</span> + ap.doctor().specialty() + <span class="hljs-string">")."</span>;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">""</span>;
};
</code></pre>
    <p class="normal">Notice that the topics covered in <em class="italic">Chapter 2</em>, such as dominance, completeness, and unconditional patterns, remain valid for record patterns with <code class="inlineCode">switch</code> as well. Actually, there are some important things to highlight about unconditional patterns, but that is covered later, in <em class="italic">Problem 101</em>.</p>
    <h1 id="_idParaDest-191" class="heading-1">99. Tackling guarded record patterns</h1>
    <p class="normal">Exactly as in the case<a id="_idIndexMarker460"/> of type patterns, we can add guarding conditions based on the binding variables. For instance, the following code uses guarding conditions with <code class="inlineCode">instanceof</code> for determining if the Allergy cabinet is open or closed (you should be familiar with the <code class="inlineCode">Doctor</code> record from the previous two problems):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">cabinet</span><span class="hljs-params">(Staff staff)</span> {
  <span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(String name, String specialty)</span> 
       &amp;&amp; (specialty.equals(<span class="hljs-string">"Allergy"</span>) 
       &amp;&amp; (name.equals(<span class="hljs-string">"Kyle Ulm"</span>)))) { 
     <span class="hljs-keyword">return</span> <span class="hljs-string">"The cabinet of "</span> + specialty 
       + <span class="hljs-string">" is closed. The doctor "</span> 
       + name + <span class="hljs-string">" is on holiday."</span>;
  }                
  <span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(String name, String specialty)</span> 
      &amp;&amp; (specialty.equals(<span class="hljs-string">"Allergy"</span>) 
      &amp;&amp; (name.equals(<span class="hljs-string">"John Hora"</span>)))) { 
    <span class="hljs-keyword">return</span> <span class="hljs-string">"The cabinet of "</span> + specialty 
      + <span class="hljs-string">" is open. The doctor "</span> 
      + name + <span class="hljs-string">" is ready to receive patients."</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Cabinet closed"</span>;
}
</code></pre>
    <p class="normal">If we add into the<a id="_idIndexMarker461"/> equation the <code class="inlineCode">Resident</code> record as well, then we can write this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String rsname, </span>
<span class="hljs-params">    Doctor(String drname, String specialty)</span>)
       &amp;&amp; (specialty.equals(<span class="hljs-string">"Dermatology"</span>) 
       &amp;&amp; rsname.equals(<span class="hljs-string">"Mark Oil"</span>))) { 
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Cabinet of "</span> + specialty + <span class="hljs-string">". Doctor "</span> 
    + drname + <span class="hljs-string">" and resident "</span> + rsname
    + <span class="hljs-string">" are ready to receive patients."</span>;
}
</code></pre>
    <p class="normal">And, if we add the <code class="inlineCode">Patient</code> and <code class="inlineCode">Appointment</code> records as well, then we can check if a certain patient has an appointment as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reception</span><span class="hljs-params">(Object o)</span> {
  <span class="hljs-keyword">if </span>(o <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> ptname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> npi,</span>
<span class="hljs-params">                  Appointment(</span><span class="hljs-keyword">var</span><span class="hljs-params"> date,</span>
<span class="hljs-params">                  Doctor (</span><span class="hljs-keyword">var</span><span class="hljs-params"> drname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span>))
     &amp;&amp; (ptname.equals(<span class="hljs-string">"Alicia Goy"</span>) &amp;&amp; npi == <span class="hljs-number">1234567890</span>
     &amp;&amp; LocalDate.now().equals(date))) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"The doctor "</span> + drname + <span class="hljs-string">" from "</span> + specialty
                         + <span class="hljs-string">" is ready for you "</span> + ptname;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-string">""</span>;
}
</code></pre>
    <p class="normal">When we are using<a id="_idIndexMarker462"/> record patterns with guarded conditions in <code class="inlineCode">switch</code> expressions, things are straightforward. The mention consists of using the <code class="inlineCode">when</code> keyword (not the <code class="inlineCode">&amp;&amp;</code> operator) as in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">cabinet</span><span class="hljs-params">(Staff staff)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(staff) {             
    <span class="hljs-keyword">case</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> name, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span> 
      when specialty.equals(<span class="hljs-string">"Dermatology"</span>) 
        -&gt; <span class="hljs-string">"The cabinet of "</span> + specialty 
              + <span class="hljs-string">" is currently under renovation"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> name, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span> 
      when (specialty.equals(<span class="hljs-string">"Allergy"</span>) 
      &amp;&amp; (name.equals(<span class="hljs-string">"Kyle Ulm"</span>))) 
        -&gt; <span class="hljs-string">"The cabinet of "</span> + specialty 
              + <span class="hljs-string">" is closed. The doctor "</span> + name 
              + <span class="hljs-string">" is on holiday."</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> name, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span> 
      when (specialty.equals(<span class="hljs-string">"Allergy"</span>) 
      &amp;&amp; (name.equals(<span class="hljs-string">"John Hora"</span>))) 
        -&gt; <span class="hljs-string">"The cabinet of "</span> + specialty 
              + <span class="hljs-string">" is open. The doctor "</span> + name 
              + <span class="hljs-string">" is ready to receive patients."</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">Resident</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> rsname, </span>
<span class="hljs-params">        Doctor(</span><span class="hljs-keyword">var</span><span class="hljs-params"> drname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span>) 
      when (specialty.equals(<span class="hljs-string">"Dermatology"</span>) 
      &amp;&amp; rsname.equals(<span class="hljs-string">"Mark Oil"</span>)) 
        -&gt; <span class="hljs-string">"Cabinet of "</span> + specialty + <span class="hljs-string">". Doctor "</span> 
               + drname + <span class="hljs-string">" and resident "</span> + rsname
               + <span class="hljs-string">" are ready to receive patients."</span>;
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"Cabinet closed"</span>;
  };                
}
</code></pre>
    <p class="normal">And, if we add the <code class="inlineCode">Patient</code> and <code class="inlineCode">Appointment</code> records as well, then we can check if a certain patient has an <a id="_idIndexMarker463"/>appointment as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">reception</span><span class="hljs-params">(Object o)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
    <span class="hljs-keyword">case</span> <span class="hljs-title">Patient</span><span class="hljs-params">(String ptname, </span><span class="hljs-type">int</span><span class="hljs-params"> npi, </span>
<span class="hljs-params">         Appointment(LocalDate date, </span>
<span class="hljs-params">         Doctor (String drname, String specialty)</span>))
      when (ptname.equals(<span class="hljs-string">"Alicia Goy"</span>) 
      &amp;&amp; npi == <span class="hljs-number">1234567890</span> &amp;&amp; LocalDate.now().equals(date)) 
        -&gt; <span class="hljs-string">"The doctor "</span> + drname + <span class="hljs-string">" from "</span> + specialty 
           + <span class="hljs-string">" is ready for you "</span> + ptname;
    <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">""</span>;
  };                
}    
</code></pre>
    <p class="normal">The JDK 19+ context-specific keyword <code class="inlineCode">when</code> is added between the pattern label and the checks (the boolean expressions representing the guarding conditions) this avoids the confusion of using the <code class="inlineCode">&amp;&amp;</code> operator.</p>
    <h1 id="_idParaDest-192" class="heading-1">100. Using generic records in record patterns</h1>
    <p class="normal">Declaring a generic record for<a id="_idIndexMarker464"/> mapping fruit data can be done as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">FruitRecord</span>&lt;T&gt;(T t, String country) {}
</code></pre>
    <p class="normal">Now, let’s assume a <code class="inlineCode">MelonRecord</code>, which is a fruit (actually, there is some controversy over whether a melon is a fruit or a vegetable, but let’s say that it is a fruit):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(String type, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> {}
</code></pre>
    <p class="normal">We can declare a <code class="inlineCode">FruitRecord&lt;MelonRecord&gt;</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">FruitRecord&lt;MelonRecord&gt; fruit = 
  <span class="hljs-keyword">new</span> <span class="hljs-title">FruitRecord</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title">MelonRecord</span>(<span class="hljs-string">"Hami"</span>, <span class="hljs-number">1000</span>), <span class="hljs-string">"China"</span>);
</code></pre>
    <p class="normal">This <code class="inlineCode">FruitRecord&lt;MelonRecord&gt;</code> can be used in record patterns with <code class="inlineCode">instanceof</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> FruitRecord&lt;MelonRecord&gt;(
    MelonRecord melon, String country)) {
  System.out.println(melon + <span class="hljs-string">" from "</span> + country);
} 
</code></pre>
    <p class="normal">Or, in <code class="inlineCode">switch</code> statements/expressions:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">switch</span>(fruit) {
  <span class="hljs-keyword">case</span> FruitRecord&lt;MelonRecord&gt;(
       MelonRecord melon, String country) :
    System.out.println(melon + <span class="hljs-string">" from "</span> + country); <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span> : <span class="hljs-keyword">break</span>; 
};
</code></pre>
    <p class="normal">Next, let’s see how we <a id="_idIndexMarker465"/>can use type argument inference.</p>
    <h2 id="_idParaDest-193" class="heading-2">Type argument inference</h2>
    <p class="normal">Java supports inference of type arguments<a id="_idIndexMarker466"/> for record patterns, so we can re-write the previous examples as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> FruitRecord&lt;MelonRecord&gt;(
    <span class="hljs-keyword">var</span> melon, <span class="hljs-keyword">var</span> country)) {
  System.out.println(melon + <span class="hljs-string">" from "</span> + country);
}
</code></pre>
    <p class="normal">Or, if we want more concise code, then we can drop the type arguments as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> <span class="hljs-title">FruitRecord</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> melon, </span><span class="hljs-keyword">var</span><span class="hljs-params"> country)</span>) {
  System.out.println(melon + <span class="hljs-string">" from "</span> + country);
}
</code></pre>
    <p class="normal">The same works for <code class="inlineCode">switch</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">switch</span> (fruit) {
  <span class="hljs-keyword">case</span> FruitRecord&lt;MelonRecord&gt;(<span class="hljs-keyword">var</span> melon, <span class="hljs-keyword">var</span> country) :
    System.out.println(melon + <span class="hljs-string">" from "</span> + country); <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span> : <span class="hljs-keyword">break</span>;
};
</code></pre>
    <p class="normal">Or, more concise:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">switch</span> (fruit) {
  <span class="hljs-keyword">case</span> <span class="hljs-title">FruitRecord</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> melon, </span><span class="hljs-keyword">var</span><span class="hljs-params"> country)</span> :
    System.out.println(melon + <span class="hljs-string">" from "</span> + country); <span class="hljs-keyword">break</span>;
  <span class="hljs-keyword">default</span> : <span class="hljs-keyword">break</span>;
};
</code></pre>
    <p class="normal">Here, the type for <code class="inlineCode">melon</code> is inferred as <code class="inlineCode">MelonRecord</code>, and the type for <code class="inlineCode">country</code> as <code class="inlineCode">String</code>.</p>
    <p class="normal">Now, let’s assume the following generic record:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">EngineRecord</span>&lt;X, Y, Z&gt;(X x, Y y, Z z) {}
</code></pre>
    <p class="normal">The generics <code class="inlineCode">X</code>, <code class="inlineCode">Y</code>, and <code class="inlineCode">Z</code> can <a id="_idIndexMarker467"/>be anything. For instance, we can define an engine by its type, horsepower, and cooling system as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">EngineRecord&lt;String, Integer, String&gt; engine
  = <span class="hljs-keyword">new</span> <span class="hljs-title">EngineRecord</span>(<span class="hljs-string">"TV1"</span>, <span class="hljs-number">661</span>, <span class="hljs-string">"Water cooled"</span>);
</code></pre>
    <p class="normal">Next, we can use the <code class="inlineCode">engine</code> variable and <code class="inlineCode">instanceof</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (engine <span class="hljs-keyword">instanceof</span> EngineRecord&lt;String, Integer, String&gt;
   (<span class="hljs-keyword">var</span> type, <span class="hljs-keyword">var</span> power, <span class="hljs-keyword">var</span> cooling)) {
  System.out.println(type + <span class="hljs-string">" - "</span> + power + <span class="hljs-string">" - "</span> + cooling);
}
<span class="hljs-comment">// or, more concise</span>
<span class="hljs-keyword">if</span> (engine <span class="hljs-keyword">instanceof</span> <span class="hljs-title">EngineRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">    </span><span class="hljs-keyword">var</span><span class="hljs-params"> type, </span><span class="hljs-keyword">var</span><span class="hljs-params"> power, </span><span class="hljs-keyword">var</span><span class="hljs-params"> cooling)</span>) {
  System.out.println(type + <span class="hljs-string">"</span><span class="hljs-string"> - "</span> + power + <span class="hljs-string">" - "</span> + cooling);
}
</code></pre>
    <p class="normal">And, with <code class="inlineCode">switch</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">switch</span> (engine) {
  <span class="hljs-keyword">case</span> EngineRecord&lt;String, Integer, String&gt;(
      <span class="hljs-keyword">var</span> type, <span class="hljs-keyword">var</span> power, <span class="hljs-keyword">var</span> cooling) :
    System.out.println(type + <span class="hljs-string">" - "</span>
                                + power + <span class="hljs-string">" - "</span> + cooling);
  <span class="hljs-keyword">default</span> : <span class="hljs-keyword">break</span>;
};
<span class="hljs-comment">// or, more concise</span>
<span class="hljs-keyword">switch</span> (engine) {
  <span class="hljs-keyword">case</span> <span class="hljs-title">EngineRecord</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> type, </span><span class="hljs-keyword">var</span><span class="hljs-params"> power, </span><span class="hljs-keyword">var</span><span class="hljs-params"> cooling)</span> :
    System.out.println(type + <span class="hljs-string">"</span><span class="hljs-string"> - "</span>
                            + power + <span class="hljs-string">" - "</span> + cooling);
  <span class="hljs-keyword">default</span> : <span class="hljs-keyword">break</span>;
};
</code></pre>
    <p class="normal">In both examples, we<a id="_idIndexMarker468"/> rely on inferred types for arguments. The type inferred for the <code class="inlineCode">type</code> argument is <code class="inlineCode">String</code>, for <code class="inlineCode">power</code> is <code class="inlineCode">Integer</code>, and for <code class="inlineCode">cooling</code> is <code class="inlineCode">String</code>.</p>
    <h2 id="_idParaDest-194" class="heading-2">Type argument inference and nested records</h2>
    <p class="normal">Let’s assume the following<a id="_idIndexMarker469"/> record:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span><span class="hljs-function"> </span><span class="hljs-keyword">record</span><span class="hljs-function"> </span><span class="hljs-title">ContainerRecord</span><span class="hljs-function">&lt;</span><span class="hljs-title">C</span><span class="hljs-function">&gt;(</span><span class="hljs-params">C c</span><span class="hljs-function">)</span> {}
</code></pre>
    <p class="normal">And the following nested <code class="inlineCode">container</code>:</p>
    <pre class="programlisting code"><code class="hljs-code">ContainerRecord&lt;String&gt; innerContainer
  = <span class="hljs-keyword">new</span> <span class="hljs-title">ContainerRecord</span>(<span class="hljs-string">"Inner container"</span>);
ContainerRecord&lt;ContainerRecord&lt;String&gt;&gt; container
  = <span class="hljs-keyword">new</span> <span class="hljs-title">ContainerRecord</span>(innerContainer);
</code></pre>
    <p class="normal">Next, we can use <code class="inlineCode">container</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (container <span class="hljs-keyword">instanceof</span>
    ContainerRecord&lt;ContainerRecord&lt;String&gt;&gt;(
      ContainerRecord(<span class="hljs-keyword">var</span> c))) {
  System.out.println(c);
}
</code></pre>
    <p class="normal">Here, the <code class="inlineCode">type</code> argument for the nested pattern <code class="inlineCode">ContainerRecord(var c)</code> is inferred to be <code class="inlineCode">String</code>, so the pattern itself is inferred to be <code class="inlineCode">ContainerRecord&lt;String&gt;(var c)</code>.</p>
    <p class="normal">More concise code can be obtained if we drop the type arguments in the outer record pattern as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (container <span class="hljs-keyword">instanceof</span> <span class="hljs-title">ContainerRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">    ContainerRecord(</span><span class="hljs-keyword">var</span><span class="hljs-params"> c)</span>)) {
      System.out.println(c);
}
</code></pre>
    <p class="normal">Here, the compiler will infer that the entire <code class="inlineCode">instanceof</code> pattern is <code class="inlineCode">ContainerRecord&lt;ContainerRecord&lt;String&gt;&gt;(ContainerRecord&lt;String&gt;(var c))</code>.</p>
    <p class="normal">Or, if we want the outer container, then we write the following record pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (container <span class="hljs-keyword">instanceof</span>
    ContainerRecord&lt;ContainerRecord&lt;String&gt;&gt;(<span class="hljs-keyword">var</span> c)) {
  System.out.println(c);
}
</code></pre>
    <p class="normal">In the bundled code, you can find these examples for <code class="inlineCode">switch</code> as well.</p>
    <div class="note">
      <p class="normal"><strong class="keyWord">Important note</strong></p>
      <p class="normal">Pay attention that type patterns don’t support the implicit inference of type arguments (for instance, the type pattern <code class="inlineCode">List list</code> is always treated as a raw type pattern).</p>
    </div>
    <p class="normal">So, Java Generics can be<a id="_idIndexMarker470"/> used in records exactly as in regular Java classes. Moreover, we can use them in conjunction with record patterns and <code class="inlineCode">instanceof</code>/<code class="inlineCode">switch</code>.</p>
    <h1 id="_idParaDest-195" class="heading-1">101. Handling nulls in nested record patterns</h1>
    <p class="normal">From <em class="italic">Chapter 2</em>, <em class="italic">Problem 54</em>, <em class="italic">Tackling the case null clause in switch,</em> we know that starting with JDK 17 (JEP 406), we can treat a <code class="inlineCode">null</code> case in <code class="inlineCode">switch</code> as any other common case:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">case</span> <span class="hljs-literal">null</span> -&gt; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title">IllegalArgumentException</span>(...);
</code></pre>
    <p class="normal">Moreover, from <em class="italic">Problem 67</em>, we know that, when<a id="_idIndexMarker471"/> type patterns are involved as well, a total pattern matches everything unconditionally including <code class="inlineCode">null</code> values (known as an unconditional pattern). Solving this issue can be done by explicitly adding a <code class="inlineCode">null</code> case (as in the previous snippet of code) or relying on JDK 19+. Starting with JDK 19, the unconditional pattern still matches <code class="inlineCode">null</code> values only it will not allow the execution of that branch. The <code class="inlineCode">switch</code> expressions will throw a <code class="inlineCode">NullPointerException</code> without even looking at the patterns.</p>
    <p class="normal">This statement partially works for record patterns as well. For instance, let’s consider the following records:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Fruit</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">SeedRecord</span><span class="hljs-params">(String type, String country)</span> 
<span class="hljs-keyword">  implements</span> <span class="hljs-title">Fruit</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> 
<span class="hljs-keyword">  implements</span> <span class="hljs-title">Fruit</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">EggplantRecord</span><span class="hljs-params">(SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> 
<span class="hljs-keyword">  implements</span> <span class="hljs-title">Fruit</span> {}
</code></pre>
    <p class="normal">And, let’s consider the following <code class="inlineCode">switch</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">buyFruit</span><span class="hljs-params">(Fruit fruit)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(fruit) {
<span class="hljs-keyword">    case</span> <span class="hljs-literal">null</span> -&gt; <span class="hljs-string">"Ops!"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">SeedRecord</span><span class="hljs-params">(String type, String country)</span> 
      -&gt; <span class="hljs-string">"This is a seed of "</span> + type + <span class="hljs-string">" from "</span> + country;
    <span class="hljs-keyword">case</span> <span class="hljs-title">EggplantRecord</span><span class="hljs-params">(SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> 
      -&gt; <span class="hljs-string">"This is a "</span> + seed.type() + <span class="hljs-string">" eggplant"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> 
      -&gt; <span class="hljs-string">"This is a "</span> + seed.type() + <span class="hljs-string">" melon"</span>;
    <span class="hljs-keyword">case</span> Fruit v -&gt; <span class="hljs-string">"This is an unknown fruit"</span>;
  };
}
</code></pre>
    <p class="normal">If we call <code class="inlineCode">buyFruit(null)</code>, then <a id="_idIndexMarker472"/>we will get the message <em class="italic">Ops!</em>. The compiler is aware that the selector expression is <code class="inlineCode">null</code> and that there is a <code class="inlineCode">case null</code>, therefore it will execute that branch. If we remove that <code class="inlineCode">case null</code>, then we immediately get a <code class="inlineCode">NullPointerException</code>. The compiler will not evaluate the record patterns; it will simply throw a <code class="inlineCode">NullPointerException</code>. </p>
    <p class="normal">Next, let’s create an eggplant:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">SeedRecord</span> <span class="hljs-variable">seed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">SeedRecord</span>(<span class="hljs-string">"Fairytale"</span>, <span class="hljs-string">"India"</span>);
<span class="hljs-type">EggplantRecord</span> <span class="hljs-variable">eggplant</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">EggplantRecord</span>(seed, <span class="hljs-number">300</span>);
</code></pre>
    <p class="normal">This time, if we call <code class="inlineCode">buyFruit(seed)</code>, we get the message <em class="italic">This is a seed of Fairytale from India. </em>The call matches the <code class="inlineCode">case SeedRecord(String type, String country)</code> branch. And, if we call <code class="inlineCode">buyFruit(eggplant)</code>, then we get the message <em class="italic">This is a Fairytale eggplant</em>. The call matches the <code class="inlineCode">case EggplantRecord(SeedRecord seed, float weight)</code> branch. There are no surprises so far!</p>
    <p class="normal">Now, let’s have an edge case. We assume that <code class="inlineCode">SeedRecord</code> is <code class="inlineCode">null</code> and we create the following “bad” eggplant:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">EggplantRecord</span> <span class="hljs-variable">badEggplant</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">EggplantRecord</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">300</span>);
</code></pre>
    <p class="normal">The <code class="inlineCode">buyFruit(badEggplant)</code> call will return a <code class="inlineCode">NullPointerException</code> containing the following crystal clear message: <em class="italic">java.lang.NullPointerException: Cannot invoke “modern.challenge.SeedRecord.type()” because “seed” is null</em>. As you can see, in the case of nested <code class="inlineCode">null</code>, the compiler cannot prevent the execution of the corresponding branch. The nested <code class="inlineCode">null</code> doesn’t short-circuit the code and hits the code of our branch (<code class="inlineCode">case EggplantRecord(SeedRecord seed, float weight)</code>) where we call <code class="inlineCode">seed.type()</code>. Since <code class="inlineCode">seed</code> is <code class="inlineCode">null</code>, we get a <code class="inlineCode">NullPointerException</code>.</p>
    <p class="normal">We cannot cover this edge case via a case such as <code class="inlineCode">case EggplantRecord(null, float weight)</code>. This will not<a id="_idIndexMarker473"/> compile. Obviously, a deeper or wider nesting will complicate these edge cases even more. However, we can add a guard to prevent the issue and cover this case as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">case</span> <span class="hljs-title">EggplantRecord</span><span class="hljs-params">(SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> 
     when seed == <span class="hljs-literal">null</span> -&gt; <span class="hljs-string">"Ops! What's this?!"</span>;
</code></pre>
    <p class="normal">Let’s see what happens in the case of using <code class="inlineCode">instanceof</code> instead of <code class="inlineCode">switch</code>. So, the code becomes:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">buyFruit</span><span class="hljs-params">(Fruit fruit)</span> {
  <span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> <span class="hljs-title">SeedRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">      String type, String country)</span>) {
     <span class="hljs-keyword">return</span> <span class="hljs-string">"This is a seed of "</span> + type + <span class="hljs-string">"</span><span class="hljs-string"> from "</span> + country;
  }
  <span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> <span class="hljs-title">EggplantRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">      SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"This is a "</span> + seed.type() + <span class="hljs-string">" eggplant"</span>;
  } 
  <span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> <span class="hljs-title">MelonRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">      SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"This is a "</span> + seed.type() + <span class="hljs-string">" melon"</span>;
  } 
  <span class="hljs-keyword">return</span> <span class="hljs-string">"This is an unknown fruit"</span>;
}
</code></pre>
    <p class="normal">In the case of <code class="inlineCode">instanceof</code>, there is no need to add explicit <code class="inlineCode">null</code> checks. A call such as <code class="inlineCode">buyFruit(null)</code> will return the message <em class="italic">This is an unknown fruit</em>. This happens since no <code class="inlineCode">if</code> statement will match the given <code class="inlineCode">null</code>.</p>
    <p class="normal">Next, if we call <code class="inlineCode">buyFruit(seed)</code>, we get the message <em class="italic">This is a seed of Fairytale from India</em>. The call matches the <code class="inlineCode">if (fruit instanceof SeedRecord(String type, String country))</code> branch. And, if we call <code class="inlineCode">buyFruit(eggplant)</code>, then we get the message <em class="italic">This is a Fairytale eggplant</em>. The call matches the case <code class="inlineCode">if (fruit instanceof EggplantRecord(SeedRecord seed, float weight))</code> branch. Again, there are no surprises so far!</p>
    <p class="normal">Finally, let’s bring in front the <code class="inlineCode">badEggplant</code> via the <code class="inlineCode">buyFruit(badEggplant)</code> call. Exactly as in the case of the <code class="inlineCode">switch</code> example, the result will consist of an NPE: <em class="italic">Cannot invoke “modern.challenge.SeedRecord.type()” because “seed” is null</em>. Again, the nested <code class="inlineCode">null</code> cannot be intercepted <a id="_idIndexMarker474"/>by the compiler and the <code class="inlineCode">if (fruit instanceof EggplantRecord(SeedRecord seed, float weight))</code> branch is executed leading to a <code class="inlineCode">NullPointerException</code> because we call <code class="inlineCode">seed.type()</code> while <code class="inlineCode">seed</code> is <code class="inlineCode">null</code>.</p>
    <p class="normal">Trying to cover this edge case via the following snippet of code will not compile:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> <span class="hljs-title">EggplantRecord</span><span class="hljs-params">(</span><span class="hljs-literal">null</span><span class="hljs-params">, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Ops! What's this?!"</span>;
}
</code></pre>
    <p class="normal">However, we can add a guard to cover this case as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (fruit <span class="hljs-keyword">instanceof</span> <span class="hljs-title">EggplantRecord</span><span class="hljs-params">(</span>
<span class="hljs-params">    SeedRecord seed, </span><span class="hljs-type">float</span><span class="hljs-params"> weight)</span> &amp;&amp; seed == <span class="hljs-literal">null</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Ops! What's this?!"</span>;
}
</code></pre>
    <p class="normal">So, pay attention that nested patterns don’t take advantage of <code class="inlineCode">case null</code> or of the JDK 19+ behavior that throws an NPE without even inspecting the patterns. This means that <code class="inlineCode">null</code> values can pass through a <code class="inlineCode">case</code> (or <code class="inlineCode">instanceof</code> check) and execute that branch leading to NPEs. So, avoiding <code class="inlineCode">null</code> values or adding extra checks (guards) as much as possible should be the way to a smooth road ahead.</p>
    <h1 id="_idParaDest-196" class="heading-1">102. Simplifying expressions via record patterns</h1>
    <p class="normal">Java records can help us to<a id="_idIndexMarker475"/> simplify snippets of code meant to handle/evaluate different expressions (mathematical, statistical, string-based, <strong class="keyWord">Abstract Syntax Tree</strong> (<strong class="keyWord">AST</strong>), and so on) a lot. Typically, evaluating such expressions implies a lot of conditions and checks that can be implemented via <code class="inlineCode">if</code> and/or <code class="inlineCode">switch</code> statements.</p>
    <p class="normal">For example, let’s consider the following records meant to shape string-based expressions that can be concatenated:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">interface</span> <span class="hljs-title">Str</span> {}
<span class="hljs-keyword">record</span> <span class="hljs-title">Literal</span>(String text) <span class="hljs-keyword">implements</span> <span class="hljs-title">Str</span> {}
<span class="hljs-keyword">record</span> <span class="hljs-title">Variable</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Str</span> {}
<span class="hljs-keyword">record</span> <span class="hljs-title">Concat</span><span class="hljs-params">(Str first, Str second)</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Str</span> {}
</code></pre>
    <p class="normal">Some parts of the string expression are literals (<code class="inlineCode">Literal</code>) while others are provided as variables (<code class="inlineCode">Variable</code>). For brevity, we can evaluate these expressions only via the concatenation operation (<code class="inlineCode">Concat</code>), but feel free to add more operations.</p>
    <p class="normal">During the evaluation, we have an intermediary step for simplifying the expression by removing/replacing <a id="_idIndexMarker476"/>irrelevant parts. For example, we can consider that the terms of the expression that are empty strings can be safely removed from the concatenation process. In other words, a string expression such as <code class="inlineCode">t + " "</code> can be simplified as <code class="inlineCode">t</code>, since the second term of our expression is a blank string.</p>
    <p class="normal">The code meant to perform this kind of simplification can rely on type patterns and <code class="inlineCode">instanceof</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Str <span class="hljs-title">shortener</span><span class="hljs-params">(Str str)</span> {
  <span class="hljs-keyword">if</span> (str <span class="hljs-keyword">instanceof</span> Concat s) {
    <span class="hljs-keyword">if</span> (s.first() <span class="hljs-keyword">instanceof</span> Variable first 
       &amp;&amp; s.second() <span class="hljs-keyword">instanceof</span> Literal second 
       &amp;&amp; second.text().isBlank()) {
          <span class="hljs-keyword">return</span> first;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s.first() <span class="hljs-keyword">instanceof</span> Literal first 
       &amp;&amp; s.second() <span class="hljs-keyword">instanceof</span> Variable second 
       &amp;&amp; first.text().isBlank()) {
          <span class="hljs-keyword">return</span> second;
    } 
  }
  <span class="hljs-keyword">return</span> str;
}
</code></pre>
    <p class="normal">This code will become quite verbose if we continue to add more rules for simplifying the given <code class="inlineCode">str</code>. Fortunately, we can increase the readability of this code by using record patterns and <code class="inlineCode">switch</code>. This way, the code becomes more compact and expressive. Check this out:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Str <span class="hljs-title">shortener</span><span class="hljs-params">(Str str)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (str) { 
    <span class="hljs-keyword">case</span> <span class="hljs-title">Concat</span><span class="hljs-params">(Variable(</span><span class="hljs-keyword">var</span><span class="hljs-params"> name)</span>, Literal(<span class="hljs-keyword">var</span> text)) 
      when text.isBlank() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">Variable</span>(name); 
    <span class="hljs-keyword">case</span> <span class="hljs-title">Concat</span><span class="hljs-params">(Literal(</span><span class="hljs-keyword">var</span><span class="hljs-params"> text)</span>, Variable(<span class="hljs-keyword">var</span> name)) 
      when text.isBlank() -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title">Variable</span>(name);
    <span class="hljs-keyword">default</span> -&gt; str;
  }; 
}
</code></pre>
    <p class="normal">How cool is<a id="_idIndexMarker477"/> this? </p>
    <h1 id="_idParaDest-197" class="heading-1">103. Hooking unnamed patterns and variables</h1>
    <p class="normal">One of the most remarkable preview features of JDK 21 is JEP 443 or <em class="italic">unnamed patterns and variables</em>. In other words, via <a id="_idIndexMarker478"/>unnamed patterns and variables, JDK 21 provides support for representing record components and local variables that we are not using in our code (we don’t care about them) as an underscore character (_).</p>
    <h2 id="_idParaDest-198" class="heading-2">Unnamed patterns</h2>
    <p class="normal">Deconstructing a record allows us to<a id="_idIndexMarker479"/> express record patterns, but we do not always use all the resulting components. Unnamed patterns are useful for indicating the record components that we don’t use but we have to declare for the sake of syntax. For instance, let’s have the following example (the <code class="inlineCode">Doctor</code>, <code class="inlineCode">Resident</code>, <code class="inlineCode">Patient</code>, and <code class="inlineCode">Appointment</code> records were introduced earlier, in <em class="italic">Problem 97</em> and <em class="italic">98</em>, so, for brevity, I’ll skip their declarations here):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(String name, String specialty)</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"The cabinet of "</span> + specialty
       + <span class="hljs-string">" is currently under renovation"</span>;
}
</code></pre>
    <p class="normal">In this example, the <code class="inlineCode">Doctor</code> record was deconstructed as <code class="inlineCode">Doctor(String name, String specialty)</code> but we are using only the <code class="inlineCode">specialty</code> component while we don’t need the <code class="inlineCode">name</code> component. However, we cannot write <code class="inlineCode">Doctor(String specialty)</code> since this doesn’t respect the <code class="inlineCode">Doctor</code> record signature. Alternatively, we can simply replace the <code class="inlineCode">String name</code> with an underscore as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(_, String specialty)</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"The cabinet of "</span> + specialty
        + <span class="hljs-string">" is currently under renovation"</span>;
}
</code></pre>
    <p class="normal">The unnamed pattern is<a id="_idIndexMarker480"/> shorthand for the type pattern <code class="inlineCode">var _</code>, so we can write <code class="inlineCode">if (staff instanceof Doctor(var _, String specialty))</code> as well.</p>
    <p class="normal">Let’s consider another use case:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String name, Doctor dr)</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"The resident of this cabinet is : "</span> + name;
}
</code></pre>
    <p class="normal">In this case, we use the <code class="inlineCode">name</code> of the <code class="inlineCode">Resident</code> but we don’t care about the <code class="inlineCode">Doctor</code>, so we can simply use an underscore as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String name, _)</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"The resident of this cabinet is : "</span> + name;
}
</code></pre>
    <p class="normal">Here is another example that ignores the specialty of the doctor:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (staff <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String rsname,</span>
<span class="hljs-params">      Doctor(String drname, _)</span>)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">"This is the cabinet of doctor "</span> + drname
         + <span class="hljs-string">" and resident "</span> + rsname;
}
</code></pre>
    <p class="normal">Next, let’s add the <code class="inlineCode">Patient</code> and <code class="inlineCode">Appointment</code> records as well:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> ptname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> npi,</span>
<span class="hljs-params">                    Appointment(</span><span class="hljs-keyword">var</span><span class="hljs-params"> date,</span>
<span class="hljs-params">                    Doctor (</span><span class="hljs-keyword">var</span><span class="hljs-params"> drname, </span><span class="hljs-keyword">var</span><span class="hljs-params"> specialty)</span>))) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Patient "</span> + ptname
       + <span class="hljs-string">" has an appointment for the date of "</span> + date;
}
</code></pre>
    <p class="normal">In this example, we don’t need the <code class="inlineCode">npi</code> component and the <code class="inlineCode">Doctor</code> component so we can replace them with an underscore:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> ptname, _,</span>
<span class="hljs-params">                    Appointment(</span><span class="hljs-keyword">var</span><span class="hljs-params"> date, _)</span>)) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Patient "</span> + ptname
       + <span class="hljs-string">" has an appointment for the date of "</span> + date;
}
</code></pre>
    <p class="normal">And, here is a case that needs only the patient’s name:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> <span class="hljs-title">Patient</span><span class="hljs-params">(</span><span class="hljs-keyword">var</span><span class="hljs-params"> ptname, _, _)</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Patient "</span> + ptname + <span class="hljs-string">" has an appointment"</span>;
}
</code></pre>
    <p class="normal">Of course, in such cases, you <a id="_idIndexMarker481"/>may prefer to rely on type pattern matching and express the code as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (o <span class="hljs-keyword">instanceof</span> Patient pt) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">"Patient "</span> + pt.name() + <span class="hljs-string">" has an appointment"</span>;
}
</code></pre>
    <p class="normal">I think you got the idea! When you don’t need a record component and you want to clearly communicate this aspect while typing your code faster, just replace that component with an underscore (_).</p>
    <p class="normal">Unnamed patterns can be used with <code class="inlineCode">switch</code> as well. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// without unnamed patterns</span>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(staff) {
  <span class="hljs-keyword">case</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(String name, String specialty)</span> -&gt;
      <span class="hljs-string">"The cabinet of "</span> + specialty
    + <span class="hljs-string">" is currently under renovation"</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String name, Doctor dr)</span> -&gt;
      <span class="hljs-string">"The resident of this cabinet is : "</span> + name;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"Cabinet closed"</span>;
};
<span class="hljs-comment">// with unnamed patterns</span>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(staff) {
  <span class="hljs-keyword">case</span> <span class="hljs-title">Doctor</span><span class="hljs-params">(_, String specialty)</span> -&gt;
      <span class="hljs-string">"The cabinet of "</span> + specialty
    + <span class="hljs-string">" is currently under renovation"</span>;
  <span class="hljs-keyword">case</span> <span class="hljs-title">Resident</span><span class="hljs-params">(String name, _)</span> -&gt;
      <span class="hljs-string">"The resident of this cabinet is : "</span> + name;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">"Cabinet closed"</span>;
};
</code></pre>
    <p class="normal">Nested records and unnamed patterns can significantly reduce the code length. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// without unnamed patterns</span>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
  <span class="hljs-keyword">case</span> <span class="hljs-title">Patient</span><span class="hljs-params">(String ptname, </span><span class="hljs-type">int</span><span class="hljs-params"> npi,</span>
<span class="hljs-params">               Appointment(LocalDate date,</span>
<span class="hljs-params">               Doctor (String drname, String specialty)</span>)) -&gt;
      <span class="hljs-string">"Patient "</span> + ptname + <span class="hljs-string">" has an appointment"</span>;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">""</span>;
};
<span class="hljs-comment">// with unnamed patterns</span>
<span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(o) {
  <span class="hljs-keyword">case</span> <span class="hljs-title">Patient</span><span class="hljs-params">(String ptname, _, _)</span> -&gt;
      <span class="hljs-string">"Patient "</span> + ptname + <span class="hljs-string">"</span><span class="hljs-string"> has an appointment"</span>;
  <span class="hljs-keyword">default</span> -&gt; <span class="hljs-string">""</span>;
};
</code></pre>
    <p class="normal">Now, let’s focus on another<a id="_idIndexMarker482"/> use case of unnamed variables, and let’s assume the following starting point:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">EngineType</span>
  permits ESSEngine, DSLEngine, LPGEngine {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ESSEngine </span><span class="hljs-keyword">extends</span> <span class="hljs-title">EngineType</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">DSLEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EngineType</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title">LPGEngine</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EngineType</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Car</span>&lt;E <span class="hljs-keyword">extends</span> <span class="hljs-title">EngineType</span>&gt;(E engineType) {}
</code></pre>
    <p class="normal">So, we have a sealed class (<code class="inlineCode">EngineType</code>) extended by three final classes (<code class="inlineCode">ESSEngine</code>, <code class="inlineCode">DSLEngine</code>, and <code class="inlineCode">LPGEngine</code>), and a record (<code class="inlineCode">Car</code>). Next, we want to write the following <code class="inlineCode">switch</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">addCarburetor</span><span class="hljs-params">(Car c)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(c) {
    <span class="hljs-keyword">case</span> <span class="hljs-title">Car</span><span class="hljs-params">(DSLEngine dsl)</span>, Car(ESSEngine ess)
      -&gt; <span class="hljs-string">"Adding a carburetor to a ESS or DSL car"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">Car</span><span class="hljs-params">(LPGEngine lpg)</span>
      -&gt; <span class="hljs-string">"Adding a carburetor to a LPG car"</span>;
  };
}
</code></pre>
    <p class="normal">Check out the first <code class="inlineCode">case</code> label. We have grouped the first two patterns in one <code class="inlineCode">case</code> label since the DSL and ESS cars can have the same type of carburetor. However, this will not compile and will result in an error: <em class="italic">illegal fall-through from a pattern</em>. Since both patterns can match is <a id="_idIndexMarker483"/>erroneous to name the components. In such cases, we can elide the components via unnamed variables as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">addCarburetor</span><span class="hljs-params">(Car c)</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(c) {
    <span class="hljs-keyword">case</span> <span class="hljs-title">Car</span><span class="hljs-params">(DSLEngine _)</span>, Car(ESSEngine _)
      -&gt; <span class="hljs-string">"</span><span class="hljs-string">Adding a carburetor to a ESS or DSL car"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">Car</span><span class="hljs-params">(LPGEngine lpg)</span>
      -&gt; <span class="hljs-string">"Adding a carburetor to a LPG car"</span>;
  };
}
</code></pre>
    <p class="normal">This compiles and works fine. Moreover, the second <code class="inlineCode">case</code> label can be written as <code class="inlineCode">case</code> <code class="inlineCode">Car(LPGEngine _)</code> as well since we don’t use the <code class="inlineCode">lpg</code> name on the right-hand side.</p>
    <p class="normal">If you need to add a <em class="italic">guard</em> to a case label with multiple patterns, then keep in mind that the guard applies to the multiple patterns as a whole not to each individual pattern. For instance, the following code is correct:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">addCarburetor</span><span class="hljs-params">(Car c, </span><span class="hljs-type">int</span><span class="hljs-params"> carburetorType)</span>{
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span>(c) {
    <span class="hljs-keyword">case</span> <span class="hljs-title">Car</span><span class="hljs-params">(DSLEngine _)</span>, Car(ESSEngine _)
      when carburetorType == <span class="hljs-number">1</span>
        -&gt; <span class="hljs-string">"Adding a carburetor of type 1 to a ESS or DSL car"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">Car</span><span class="hljs-params">(DSLEngine _)</span>, Car(ESSEngine _)
        -&gt; <span class="hljs-string">"Adding a carburetor of tpye "</span>
           + carburetorType + <span class="hljs-string">" to a ESS or DSL car"</span>;
    <span class="hljs-keyword">case</span> <span class="hljs-title">Car</span><span class="hljs-params">(LPGEngine lpg)</span> -&gt; <span class="hljs-string">"Adding a carburetor "</span>
           + carburetorType + <span class="hljs-string">" to a LPG car"</span>;
  };
}
</code></pre>
    <p class="normal">Next, let’s tackle unnamed variables.</p>
    <h2 id="_idParaDest-199" class="heading-2">Unnamed variables</h2>
    <p class="normal">Along with <strong class="keyWord">unnamed patterns</strong> (specific to the deconstruction of record components), JDK 21 introduces <em class="italic">unnamed variables</em>. An unnamed variable is also represented by an underscore (_) and is useful to <a id="_idIndexMarker484"/>highlight which variables we don’t need/use. Such variables can occur in one of the following contexts.</p>
    <h3 id="_idParaDest-200" class="heading-3">In a catch block</h3>
    <p class="normal">Whenever you don’t use the<a id="_idIndexMarker485"/> exception parameter of a <code class="inlineCode">catch</code> block, you can replace it with an underscore. For instance, in the following snippet of code, we catch an <code class="inlineCode">ArithmeticException</code> but we log a friendly message that doesn’t use the exception parameter:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">divisor</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
<span class="hljs-keyword">try</span> {
  <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> / divisor;
  <span class="hljs-comment">// use result</span>
} <span class="hljs-keyword">catch</span> (ArithmeticException _) {
  System.out.println(<span class="hljs-string">"Divisor "</span> + divisor + <span class="hljs-string">" is not good"</span>);
}
</code></pre>
    <p class="normal">The same technique can be applied to multi-catch cases.</p>
    <h3 id="_idParaDest-201" class="heading-3">In a for loop</h3>
    <p class="normal">Unnamed variables can be used in <a id="_idIndexMarker486"/>a simple <code class="inlineCode">for</code> loop. For instance, in the following snippet of code, we call <code class="inlineCode">logLoopStart()</code> but we don’t use the returned result:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title">int</span>[]{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>};
<span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, _ = logLoopStart(i); i &lt; arr.length; i++) {
  <span class="hljs-comment">// use i</span>
}
</code></pre>
    <p class="normal">Unnamed variables can be used in an enhanced <code class="inlineCode">for</code> loop as well. In the following snippet of code, we iterate the cards list via an enhanced <code class="inlineCode">for</code> loop but we don’t use the cards:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
List&lt;String&gt; cards = List.of(
  <span class="hljs-string">"12 spade"</span>, <span class="hljs-string">"6 diamond"</span>, <span class="hljs-string">"14 diamond"</span>);
<span class="hljs-keyword">for</span> (String _ : cards) {
  <span class="hljs-keyword">if</span> (score &lt; <span class="hljs-number">10</span>) {
    score ++;
  } <span class="hljs-keyword">else</span> {
    score --;
  }
}
</code></pre>
    <p class="normal">So, here, we don’t care <a id="_idIndexMarker487"/>about the cards’ values, so instead of writing <code class="inlineCode">for (String card : cards) {…}</code>, we simply write <code class="inlineCode">for (String _ : cards) {…}</code>.</p>
    <h3 id="_idParaDest-202" class="heading-3">In an assignment that ignores the result</h3>
    <p class="normal">Let’s consider the following code:</p>
    <pre class="programlisting code"><code class="hljs-code">Files.deleteIfExists(Path.of(<span class="hljs-string">"/file.txt"</span>));
</code></pre>
    <p class="normal">The <code class="inlineCode">deleteIfExists()</code> method returns a boolean result indicating if the given file was successfully deleted or not. But, in this<a id="_idIndexMarker488"/> code, we didn’t capture that result, so it is not clear if we want to ignore the result or if we just forgot about it. If we assume that we forgot about it, then most probably we wanted to write this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> Files.deleteIfExists(Path.of(<span class="hljs-string">"/file.txt"</span>));
<span class="hljs-keyword">if</span> (success) { ... }
</code></pre>
    <p class="normal">But, if we just wanted to ignore it, then we can clearly communicate it via an unnamed variable (this signals that we are aware of the result but we don’t want to take further actions based on its value):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-type">boolean</span> <span class="hljs-variable">_</span> <span class="hljs-operator">=</span> Files.deleteIfExists(Path.of(<span class="hljs-string">"/file.txt"</span>));
<span class="hljs-type">var</span> <span class="hljs-variable">_</span> <span class="hljs-operator">=</span> Files.deleteIfExists(Path.of(<span class="hljs-string">"/file.txt"</span>));
</code></pre>
    <p class="normal">The same technique applies every time you want to ignore the result of the expression on the right-hand side.</p>
    <h3 id="_idParaDest-203" class="heading-3">In try-with-resources</h3>
    <p class="normal">Sometimes, we don’t use the<a id="_idIndexMarker489"/> resource opened in a <em class="italic">try-with-resources</em> block. We just need the context of this resource and we want to benefit from the fact that it is <code class="inlineCode">AutoCloseable</code>. For instance, when we call <code class="inlineCode">Arena.ofConfined()</code>, we may need the <code class="inlineCode">Arena</code> context without explicitly using it. In such cases, unnamed variables can help us as in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">Arena</span> <span class="hljs-variable">_</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
<span class="hljs-comment">  // don't use arena</span>
}
</code></pre>
    <p class="normal">Or, using <code class="inlineCode">var</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">_</span> <span class="hljs-operator">=</span> Arena.ofConfined()) {
<span class="hljs-comment">  // don't use arena</span>
}
</code></pre>
    <p class="normal">The <code class="inlineCode">Arena</code> API is part of the<a id="_idIndexMarker490"/> Foreign (Function) Memory API introduced in <em class="italic">Chapter 7</em>.</p>
    <h3 id="_idParaDest-204" class="heading-3">In lambda expressions</h3>
    <p class="normal">When a lambda parameter is not<a id="_idIndexMarker491"/> relevant for our lambda expression, we can simply replace it with an underscore. Here is an example:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;Melon&gt; melons = Arrays.asList(…);
Map&lt;String, Integer&gt; resultToMap = melons.stream()
  .collect(Collectors.toMap(Melon::getType, Melon::getWeight,
    (oldValue, _) -&gt; oldValue));
</code></pre>
    <p class="normal">Done! Don’t forget that this is a preview feature in JDK 21, so use <code class="inlineCode">--enable-preview</code>.</p>
    <h1 id="_idParaDest-205" class="heading-1">104. Tackling records in Spring Boot</h1>
    <p class="normal">Java records fit perfectly in Spring<a id="_idIndexMarker492"/> Boot applications. Let’s have<a id="_idIndexMarker493"/> several scenarios where Java records can help us increase readability and expressiveness <a id="_idIndexMarker494"/>by squeezing the homologous code.</p>
    <h2 id="_idParaDest-206" class="heading-2">Using records in controllers</h2>
    <p class="normal">Typically, a Spring Boot <a id="_idIndexMarker495"/>controller operates with simple POJO classes that carry our data back over the wire to the client. For instance, check out this simple controller endpoint returning a list of authors, including their books:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@GetMapping("/authors")</span>
<span class="hljs-keyword">public</span> List&lt;Author&gt; fetchAuthors() {
  <span class="hljs-keyword">return</span> bookstoreService.fetchAuthors();
}
</code></pre>
    <p class="normal">Here, the <code class="inlineCode">Author</code> (and <code class="inlineCode">Book</code>) can be simple carriers of data written as POJOs. But, they can be replaced by records as well. Here it is:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Book</span><span class="hljs-params">(String title, String isbn)</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Author</span><span class="hljs-params">(</span>
<span class="hljs-params">  String name,  String genre, List&lt;Book&gt; books)</span> {}
</code></pre>
    <p class="normal">That’s all! The Jackson library (which is the default JSON library in Spring Boot) will automatically marshal<a id="_idIndexMarker496"/> instances of type <code class="inlineCode">Author</code>/<code class="inlineCode">Book</code> into JSON. In the bundled code, you can practice the complete example via the <code class="inlineCode">localhost:8080/authors</code> endpoint address.</p>
    <h2 id="_idParaDest-207" class="heading-2">Using records with templates</h2>
    <p class="normal">Thymeleaf (<a href="https://www.thymeleaf.org/"><span class="url">https://www.thymeleaf.org/</span></a>) is probably the<a id="_idIndexMarker497"/> most used templating<a id="_idIndexMarker498"/> engine in Spring Boot applications. Thymeleaf pages (HTML pages) are typically populated with data carried by POJO classes, which means that Java records should work as well.</p>
    <p class="normal">Let’s consider the previous <code class="inlineCode">Author</code> and <code class="inlineCode">Book</code> records, and the following controller endpoint:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@GetMapping("/bookstore")</span>
<span class="hljs-keyword">public</span> String <span class="hljs-title">bookstorePage</span><span class="hljs-params">(Model model)</span> {
  model.addAttribute(<span class="hljs-string">"authors"</span>, 
    bookstoreService.fetchAuthors());
  <span class="hljs-keyword">return</span> <span class="hljs-string">"bookstore"</span>;
}
</code></pre>
    <p class="normal">The <code class="inlineCode">List&lt;Author&gt;</code> returned via <code class="inlineCode">fetchAuthors()</code> is stored in the model under a variable named <code class="inlineCode">authors</code>. This variable is used to populate <code class="inlineCode">bookstore.html</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code">…
&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"author : ${authors}"</span>&gt;
<span class="hljs-tag">  &lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">th:text</span><span class="hljs-tag">=</span><span class="hljs-string">"${author.name} + ' (' </span>
<span class="hljs-string">             + ${author.genre} + ')'"</span><span class="hljs-tag"> /&gt;</span>
  &lt;<span class="hljs-name">ul</span> <span class="hljs-attr">th:each</span>=<span class="hljs-string">"book : ${author.books}"</span>&gt;
<span class="hljs-tag">    &lt;</span><span class="hljs-name">li</span><span class="hljs-tag"> </span><span class="hljs-attr">th:text</span><span class="hljs-tag">=</span><span class="hljs-string">"</span><span class="hljs-string">${book.title}"</span><span class="hljs-tag"> /&gt;</span>
<span class="hljs-tag">  &lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
<span class="hljs-tag">&lt;/</span><span class="hljs-name">ul</span><span class="hljs-tag">&gt;</span>
…
</code></pre>
    <p class="normal">Done! </p>
    <h2 id="_idParaDest-208" class="heading-2">Using records for configuration</h2>
    <p class="normal">Let’s assume that in <code class="inlineCode">application.properties</code> we have the following two properties (they could be expressed in YAML as<a id="_idIndexMarker499"/> well):</p>
    <pre class="programlisting code"><code class="hljs-code">bookstore.bestseller.author=Joana Nimar
bookstore.bestseller.book=Prague history
</code></pre>
    <p class="normal">Spring Boot maps such properties to POJO via <code class="inlineCode">@ConfigurationProperties</code>. But, a record can be used as well. For instance, these properties can be mapped to the <code class="inlineCode">BestSellerConfig</code> record as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@ConfigurationProperties(prefix = "bookstore.bestseller")</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">BestSellerConfig</span><span class="hljs-params">(String author, String book)</span> {}
</code></pre>
    <p class="normal">Next, in <code class="inlineCode">BookstoreService</code> (a typical Spring Boot service), we can inject <code class="inlineCode">BestSellerConfig</code> and call its accessors:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Service</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BookstoreService</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BestSellerConfig bestSeller;
  <span class="hljs-keyword">public</span> <span class="hljs-title">BookstoreService</span><span class="hljs-params">(BestSellerConfig bestSeller)</span> {
<span class="hljs-built_in">    this</span>.bestSeller = bestSeller;
  }
  <span class="hljs-keyword">public</span> String <span class="hljs-title">fetchBestSeller</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> bestSeller.author() + <span class="hljs-string">" | "</span> + bestSeller.book();
  }
}
</code></pre>
    <p class="normal">In the bundled code, we have <a id="_idIndexMarker500"/>added a controller that uses this service as well.</p>
    <h2 id="_idParaDest-209" class="heading-2">Record and dependency injection</h2>
    <p class="normal">In the previous examples, we have<a id="_idIndexMarker501"/> injected the <code class="inlineCode">BookstoreService</code> service into <code class="inlineCode">BookstoreController</code> using the typical mechanism provided by SpringBoot – dependency injection via constructor (it can be done via <code class="inlineCode">@Autowired</code> as well):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">BookstoreController</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BookstoreService bookstoreService;
  <span class="hljs-keyword">public</span> <span class="hljs-title">BookstoreController</span><span class="hljs-params">(</span>
<span class="hljs-params">       BookstoreService bookstoreService)</span> {
    <span class="hljs-built_in">this</span>.bookstoreService = bookstoreService;
  }
  <span class="hljs-meta">@GetMapping("/authors")</span>
  <span class="hljs-keyword">public</span> List&lt;Author&gt; <span class="hljs-title">fetchAuthors</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> bookstoreService.fetchAuthors();
  }
}
</code></pre>
    <p class="normal">But, we can compact this class by re-writing it as a record as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@RestController</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">BookstoreController</span><span class="hljs-params">(</span>
<span class="hljs-params">     BookstoreService bookstoreService)</span> {
  <span class="hljs-meta">@GetMapping("/authors")</span>
  <span class="hljs-keyword">public</span> List&lt;Author&gt; fetchAuthors() {
    <span class="hljs-keyword">return</span> bookstoreService.fetchAuthors();
  }
}
</code></pre>
    <p class="normal">The canonical constructor of this record will be the same as our explicit constructor. Feel free to challenge yourself to<a id="_idIndexMarker502"/> find more use cases of Java records in Spring Boot applications.</p>
    <h1 id="_idParaDest-210" class="heading-1">105. Tackling records in JPA</h1>
    <p class="normal">If you are a fan of JPA (I cannot see why, but who am I to judge), then you’ll be more than happy to find out that Java<a id="_idIndexMarker503"/> records can be helpful in JPA. Typically, Java records can be<a id="_idIndexMarker504"/> used as DTOs. Next, let’s see several scenarios when records and JPA make a delightful combo.</p>
    <h2 id="_idParaDest-211" class="heading-2">DTO via record constructor</h2>
    <p class="normal">Let’s assume that we have a <a id="_idIndexMarker505"/>JPA typical <code class="inlineCode">Author</code> entity that maps author data such as <code class="inlineCode">id</code>, <code class="inlineCode">name</code>, <code class="inlineCode">age</code>, and <code class="inlineCode">genre</code>. </p>
    <p class="normal">Next, we want to write a query that fetches the authors of a certain <code class="inlineCode">genre</code>. But, we don’t need to fetch authors as entities because we don’t plan to modify this data. This is a read-only query returning only the <code class="inlineCode">name</code> and <code class="inlineCode">age</code> of each author of the given <code class="inlineCode">genre</code>. So, we need a DTO that can be expressed via records as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">AuthorDto</span><span class="hljs-params">(String name, </span><span class="hljs-type">int</span><span class="hljs-params"> age)</span> {}
</code></pre>
    <p class="normal">Next, a typical Spring Data JPA, <code class="inlineCode">AuthorRepository</code> powered by the Spring Data Query Builder mechanism, can take advantage of this record as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorRepository</span>
   <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;Author, Long&gt; {
  <span class="hljs-meta">@Transactional(readOnly = true)</span>    
  List&lt;AuthorDto&gt; findByGenre(String genre);
}
</code></pre>
    <p class="normal">Now, the generated query fetches the data and Spring Boot will map it accordingly to be carried around by the <code class="inlineCode">AuthorDto</code>.</p>
    <h2 id="_idParaDest-212" class="heading-2">DTO via record and JPA constructor expression</h2>
    <p class="normal">Another flavor of the previous <a id="_idIndexMarker506"/>scenario can rely on a JPA query that uses a constructor expression as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorRepository</span>
     <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;Author, Long&gt; {
  <span class="hljs-meta">@Transactional(readOnly = true)</span>
  <span class="hljs-meta">@Query(value = "SELECT</span>
<span class="hljs-meta">         new com.bookstore.dto.AuthorDto(a.name, a.age) </span>
<span class="hljs-meta">         FROM Author a")</span>
  List&lt;AuthorDto&gt; fetchAuthors();
}
</code></pre>
    <p class="normal">The <code class="inlineCode">AuthorDto</code> is the same record listed in the previous example.</p>
    <h2 id="_idParaDest-213" class="heading-2">DTO via record and result transformer</h2>
    <p class="normal">If working with Hibernate 6.0+ result transformers is<a id="_idIndexMarker507"/> not on your “to-do” list, then you can simply jump to the next topic.</p>
    <p class="normal">Let’s consider the following two records:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">BookDto</span><span class="hljs-params">(Long id, String title)</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">AuthorDto</span><span class="hljs-params">(Long id, String name, </span>
<span class="hljs-params">       </span><span class="hljs-type">int</span><span class="hljs-params"> age, List&lt;BookDto&gt; books)</span> {
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBook</span><span class="hljs-params">(BookDto book)</span> {
    books().add(book);
  }
}
</code></pre>
    <p class="normal">This time, we have to fetch a hierarchical DTO represented by <code class="inlineCode">AuthorDto</code> and <code class="inlineCode">BookDto</code>. Since an author can have several books written, we have to provide, in <code class="inlineCode">AuthorDto</code>, a component of the type <code class="inlineCode">List&lt;BookDto&gt;</code> and a helper method for collecting the books of the current author.</p>
    <p class="normal">In order to populate this hierarchical DTO, we can rely on an implementation of <code class="inlineCode">TupleTransformer</code>, <code class="inlineCode">ResultListTransformer</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthorBookTransformer</span> <span class="hljs-keyword">implements</span>
       TupleTransformer, ResultListTransformer {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Long, AuthorDto&gt;
    authorsDtoMap = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> Object <span class="hljs-title">transformTuple</span><span class="hljs-params">(Object[] os, String[] strings)</span>{
    <span class="hljs-type">Long</span> <span class="hljs-variable">authorId</span> <span class="hljs-operator">=</span> ((Number) os[<span class="hljs-number">0</span>]).longValue();
    <span class="hljs-type">AuthorDto</span> <span class="hljs-variable">authorDto</span> <span class="hljs-operator">=</span> authorsDtoMap.get(authorId);
    <span class="hljs-keyword">if</span> (authorDto == <span class="hljs-literal">null</span>) {
      authorDto = <span class="hljs-keyword">new</span> <span class="hljs-title">AuthorDto</span>(((Number) os[<span class="hljs-number">0</span>]).longValue(), 
             (String) os[<span class="hljs-number">1</span>], (<span class="hljs-type">int</span>) os[<span class="hljs-number">2</span>], <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;());
    }
    <span class="hljs-type">BookDto</span> <span class="hljs-variable">bookDto</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BookDto</span>(
      ((Number) os[<span class="hljs-number">3</span>]).longValue(), (String) os[<span class="hljs-number">4</span>]);
    authorDto.addBook(bookDto);
    authorsDtoMap.putIfAbsent(authorDto.id(), authorDto);
    <span class="hljs-keyword">return</span> authorDto;
  }
  <span class="hljs-meta">@Override</span>
  <span class="hljs-keyword">public</span> List&lt;AuthorDto&gt; <span class="hljs-title">transformList</span><span class="hljs-params">(List list)</span> { 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(authorsDtoMap.values());
  }
}
</code></pre>
    <p class="normal">You can find the <a id="_idIndexMarker508"/>complete application in the bundled code. </p>
    <h2 id="_idParaDest-214" class="heading-2">DTO via record and JdbcTemplate</h2>
    <p class="normal">If working with SpringBoot <code class="inlineCode">JdbcTemplate</code> is not on your “to-do” list, then you can simply jump to the next topic.</p>
    <p class="normal">The <code class="inlineCode">JdbcTemplate</code> API has been a huge<a id="_idIndexMarker509"/> success among those who love to work with JDBC. So, if you are familiar with this API, then you’ll be very happy to find out that it can be combined with Java records quite nicely.</p>
    <p class="normal">For instance, having the same <code class="inlineCode">AuthorDto</code> and <code class="inlineCode">BookDto</code> as in the previous scenario, we can rely on <code class="inlineCode">JdbcTemplate</code> to populate this hierarchical DTO as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Repository</span>
<span class="hljs-meta">@Transactional(readOnly = true)</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">AuthorExtractor</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JdbcTemplate jdbcTemplate;
  <span class="hljs-keyword">public</span> <span class="hljs-title">AuthorExtractor</span><span class="hljs-params">(JdbcTemplate jdbcTemplate)</span> {
<span class="hljs-built_in">    this</span>.jdbcTemplate = jdbcTemplate;
  }
  <span class="hljs-keyword">public</span> List&lt;AuthorDto&gt; extract() {
    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">"SELECT a.id, a.name, a.age, b.id, b.title "</span>
    + <span class="hljs-string">"</span><span class="hljs-string">FROM author a INNER JOIN book b ON a.id = b.author_id"</span>;
    List&lt;AuthorDto&gt; result = jdbcTemplate.query(sql, 
     (ResultSet rs) -&gt; {
      <span class="hljs-keyword">final</span> Map&lt;Long, AuthorDto&gt; authorsMap = <span class="hljs-keyword">new</span> <span class="hljs-title">HashMap</span>&lt;&gt;();
      <span class="hljs-keyword">while</span> (rs.next()) {
        <span class="hljs-type">Long</span> <span class="hljs-variable">authorId</span> <span class="hljs-operator">=</span> (rs.getLong(<span class="hljs-string">"id"</span>));
<span class="hljs-type">        AuthorDto</span> <span class="hljs-variable">author</span> <span class="hljs-operator">=</span> authorsMap.get(authorId);
        <span class="hljs-keyword">if</span> (author == <span class="hljs-literal">null</span>) {
          author = <span class="hljs-keyword">new</span> <span class="hljs-title">AuthorDto</span>(rs.getLong(<span class="hljs-string">"id"</span>),
            rs.getString(<span class="hljs-string">"name"</span>), 
              rs.getInt(<span class="hljs-string">"age"</span>), <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>()); 
        }
<span class="hljs-type">        BookDto</span> <span class="hljs-variable">book</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title">BookDto</span>(rs.getLong(<span class="hljs-string">"id"</span>), 
          rs.getString(<span class="hljs-string">"title"</span>)); 
        author.addBook(book);
        authorsMap.putIfAbsent(author.id(), author);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title">ArrayList</span>&lt;&gt;(authorsMap.values());
    });
    <span class="hljs-keyword">return</span> result;
  }
}
</code></pre>
    <p class="normal">You can find the <a id="_idIndexMarker510"/>complete application in the bundled code. </p>
    <h2 id="_idParaDest-215" class="heading-2">Team up Java records and @Embeddable</h2>
    <p class="normal">Hibernate 6.2+ allows us to define Java<a id="_idIndexMarker511"/> records as embeddable. Practically, we start with an embeddable class defined as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Embeddable</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">Contact</span><span class="hljs-params">(</span>
<span class="hljs-params">  String email, String twitter, String phone)</span> {}
</code></pre>
    <p class="normal">Next, we use this embeddable in our <code class="inlineCode">Author</code> entity as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Entity</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Author</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;
  <span class="hljs-meta">@Id</span>
  <span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span>
  <span class="hljs-keyword">private</span> Long id;
  <span class="hljs-meta">@Embedded</span>
  <span class="hljs-keyword">private</span> Contact contact;
  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;
  <span class="hljs-keyword">private</span> String name;
  <span class="hljs-keyword">private</span> String genre;
  ...
}
</code></pre>
    <p class="normal">And, in our <code class="inlineCode">AuthorDto</code> DTO as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">AuthorDto</span><span class="hljs-params">(</span>
<span class="hljs-params">  String name, </span><span class="hljs-type">int</span><span class="hljs-params"> age, Contact contact)</span> {}
</code></pre>
    <p class="normal">Next, a classical Spring Data JPA <code class="inlineCode">AuthorRepository</code> powered by the Spring Data Query Builder mechanism can<a id="_idIndexMarker512"/> take advantage of this record as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-meta">@Repository</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">AuthorRepository</span>
   <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;Author, Long&gt; {
  <span class="hljs-meta">@Transactional(readOnly = true)</span>    
  List&lt;AuthorDto&gt; findByGenre(String genre);
}
</code></pre>
    <p class="normal">Now, the generated query fetches the data and Spring Boot will map it accordingly to be carried around by the <code class="inlineCode">AuthorDto</code>. If we print one of the fetched authors to the console, we will see something like this:</p>
    <pre class="programlisting code"><code class="hljs-code">[AuthorDto[name=Mark Janel, age=<span class="hljs-number">23</span>, 
   contact=<span class="code-highlight"><strong class="hljs-slc">Contact[email=mark.janel</strong><strong class="hljs-meta-slc">@yahoo</strong><strong class="hljs-slc">.com,</strong></span> 
                   <span class="code-highlight"><strong class="hljs-slc">twitter=</strong><strong class="hljs-meta-slc">@markjanel</strong><strong class="hljs-slc">, phone=+</strong><strong class="hljs-number-slc">40198503</strong></span>]]
</code></pre>
    <p class="normal">The highlighted part represents our embeddable.</p>
    <h1 id="_idParaDest-216" class="heading-1">106. Tackling records in jOOQ</h1>
    <p class="normal">The more you learn about JPA, the<a id="_idIndexMarker513"/> more you’ll love jOOQ. Why? Because jOOQ represents the best way to write SQL in Java. Flexibility, versatility, dialect agnostic, rock-solid SQL support, a small learning curve, and high performance are just a few<a id="_idIndexMarker514"/> of the attributes that make jOOQ the most appealing persistence technology for modern applications.</p>
    <p class="normal">Being part of the modern technology stack, jOOQ is the new persistence trend that respects all standards of a mature, robust, and well-documented technology.</p>
    <p class="normal">If you are not familiar with jOOQ, then please consider my book <em class="italic">jOOQ Masterclass</em>.</p>
    <p class="normal">That being said, let’s assume that we have a database schema consisting of two tables, <code class="inlineCode">Productline</code> and <code class="inlineCode">Product</code>. A product line contains multiple products, so we can shape this one-to-many relationship via two records as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">RecordProduct</span><span class="hljs-params">(String productName, </span>
<span class="hljs-params">  String productVendor, Integer quantityInStock)</span> {}
<span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title">RecordProductLine</span><span class="hljs-params">(String productLine, </span>
<span class="hljs-params">  String textDescription, List&lt;RecordProduct&gt; products)</span> {}
</code></pre>
    <p class="normal">In jOOQ, we <a id="_idIndexMarker515"/>can populate this<a id="_idIndexMarker516"/> model via a simple query based on the <code class="inlineCode">MULTISET</code> operator:</p>
    <pre class="programlisting code"><code class="hljs-code">List&lt;RecordProductLine&gt; resultRecord = ctx.select(
  PRODUCTLINE.PRODUCT_LINE, PRODUCTLINE.TEXT_DESCRIPTION,
    multiset(
      select(
          PRODUCT.PRODUCT_NAME, PRODUCT.PRODUCT_VENDOR, 
          PRODUCT.QUANTITY_IN_STOCK)
        .from(PRODUCT)
        .where(PRODUCTLINE.PRODUCT_LINE.eq(
               PRODUCT.PRODUCT_LINE))
        ).as(<span class="hljs-string">"products"</span>).convertFrom(
           r -&gt; r.map(mapping(RecordProduct::<span class="hljs-keyword">new</span>))))
         .from(PRODUCTLINE)
         .orderBy(PRODUCTLINE.PRODUCT_LINE)
         .fetch(mapping(RecordProductLine::<span class="hljs-keyword">new</span>));
</code></pre>
    <p class="normal">How cool is this? jOOQ can produce any nested collection value of jOOQ Records or DTOs (POJO/Java records) in a fully type-safe manner, with zero reflections, no N+1 risks, no de-duplications, and no accidental Cartesian products. This allows the database to perform nesting and optimize the query execution plan.</p>
    <p class="normal">In the bundled code, you can see another example that fetches a many-to-many relationship in a record model. Moreover, in the bundled code, you can find an example that relies on the jOOQ <code class="inlineCode">MULTISET_AGG()</code> function. This is a synthetic aggregate function that can be used as an alternative to <code class="inlineCode">MULTISET</code>.</p>
    <h1 id="_idParaDest-217" class="heading-1">Summary</h1>
    <p class="normal">The goal of this chapter was to deeply cover Java records and record patterns. We have assigned the same importance to both the theoretical and the practical parts so that, in the end, there are no secrets regarding the use of these two topics. And, just in case you wonder why we didn’t cover the topic regarding record patterns appearing in the header of an enhanced <code class="inlineCode">for</code> statement, then please notice that this was added as a preview in JDK 20 but it was removed in JDK 21. This feature may be re-proposed in a future JEP.</p>
    <h1 class="heading-1">Leave a review!</h1>
    <p class="normal">Enjoying this book? Help readers like you by leaving an Amazon review. Scan the QR code below for a 20% discount code.</p>
    <p class="normal"><img src="../Images/Leave_Reivew_QR.png" style="width:10em;" alt="" role="presentation"/></p>
    <p class="normal" style="font-size:0.75em;"><em class="italic">*Limited Offer</em></p>
  </div>
</body></html>