- en: '*Chapter 8*: Building and Testing Your Cloud-Native Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we've looked at various MicroProfile technologies
    in isolation. Now, let's come back to our example application, the **IBM Stock
    Trader**, first introduced in [*Chapter 3*](B17377_03_Final_SB_epub.xhtml#_idTextAnchor049),
    *Introducing the IBM Stock Trader Cloud-Native Application*, to see those in use
    across various microservices. In this chapter, we'll focus on how to build those
    microservices, how to construct the container image for each and push them to
    an image registry, how to unit test them, and the usage of various MicroProfile
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the Stock Trader microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Stock Trader container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Stock Trader microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stock Trader usage of MicroProfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with how to build the various
    pieces of such a cloud-native application, how to try out each of them, and how
    to demonstrate their usage.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build and test the microservices as described in this section, you will
    need to have the following tools installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**) – Java 8 or later: [http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache Maven: [https://maven.apache.org](https://maven.apache.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Git client: [https://git-scm.com](https://git-scm.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Docker client: [https://www.docker.com/products](https://www.docker.com/products
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling the Stock Trader microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how to create a local copy of the source code
    for each microservice, and how to compile it and package it up into an archive
    that can be deployed onto an application server.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public GitHub organization called *IBMStockTrader*, at [https://github.com/IBMStockTrader](https://github.com/IBMStockTrader),
    contains repositories for each of the dozen or so microservices comprising the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on the `trader` repository, and clone its contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The most important files here are `Dockerfile` and the `pom.xml` (both of which
    we''ll discuss shortly), and the `src` directory, which contains all of the source
    code. This includes the Java code (under `src/main/java` – each of the Stock Trader
    microservices has its own sub-package under `com.ibm.hybrid.cloud.sample.stocktrader`),
    the web artifacts (under `src/main/webapp`), and the Open Liberty configuration
    (under `src/main/liberty/config` – we''ll look at this further in the *Building
    the Stock Trader container images* section). All of the microservices in the application
    follow this same structure. Let''s take a look at the contents of the `src` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Source code layout in the IBMStockTrader Git repositories'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Source code layout in the IBMStockTrader Git repositories
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen the source code structure in each Git repository, let's
    look at how to use *Maven* to build it and package the results up for deployment
    to the Docker container for the Open Liberty application server.
  prefs: []
  type: TYPE_NORMAL
- en: Maven
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `pom.xml` file tells Maven what to build and how. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to include the following stanza in the `pom.xml` file so that
    usage of `org.eclipse.microprofile.*` packages will compile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the *umbrella* dependency that puts all of the MicroProfile 4 features
    on the compile-time classpath. You can also just choose particular MicroProfile
    features if you prefer; for example, to put just *MicroProfile Health* on the
    compile-time classpath, you'd specify `org.eclipse.microprofile.health`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note the `<scope>provided</scope>` line – this tells Maven that, though it should
    add such JAR files to the compile-time classpath, it should *NOT* bundle such
    JAR files inside the WAR file being built. The application server (Open Liberty,
    in our case) hosting the WAR file *provides* such JAR files, and having an additional
    copy inside the application can cause class loader issues, so we tell it `provided`
    to avoid that.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s use Maven to build our `Trader` microservice. Most modern `brew
    install maven` to install it. Note that Maven also depends on Java, and you will
    need the `JAVA_HOME` environment variable to point to your Java installation.
    Let''s use `mvn compile` to compile our code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, it takes less than a couple of seconds to compile all of the
    code. Of course, if any compilation errors occurred, they will be shown when this
    is run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s package up the WAR file, via `mvn package`. Some of the several
    pages of output are snipped out to save space, but the important part is shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, we can run some basic integration tests via the command `mvn verify`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will execute any test classes you might have under `src/test/java` (highly
    recommended, to catch problems early), such as our `HealthEndpointIT.java` and
    `HomePageIT.java` under `src/test/java/com/ibm/hybrid/cloud/sample/stocktrader/trader/test`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we've seen how to compile, package, and test our code, let's look at
    how to containerize it and test the container.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Stock Trader container images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in previous sections, we use *Open Liberty* as the application
    server hosting most of the Stock Trader microservices. And we use *Docker* to
    produce the container images that ultimately get run in a Kubernetes cluster such
    as the *OpenShift Container Platform* cluster.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections will describe how we configure the server, and how
    we package it up into a container image.
  prefs: []
  type: TYPE_NORMAL
- en: Open Liberty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a variety of MicroProfile compliant Java application servers on the
    market. As a reminder from [*Chapter 3*](B17377_03_Final_SB_epub.xhtml#_idTextAnchor049),
    *Introducing the IBM Stock Trader Cloud-Native Application*, most of the Stock
    Trader microservices (Trader, Broker, Broker-Query, Portfolio, Account, Trade
    History, Messaging, Notification-Slack, Collector, and Looper) are based on the
    open source Open Liberty application server. For variety, there are three other
    microservices based on different servers:'
  prefs: []
  type: TYPE_NORMAL
- en: Stock Quote, which runs on Red Hat's **Quarkus**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification-Twitter, which runs on **traditional WebSphere Application Server**
    (**tWAS**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tradr is the only non-Java microservice, which is written in Node.js.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But here, we'll focus on the ones that run on Open Liberty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important file for configuring an Open Liberty server is the `server.xml`
    file. This defines the features that should be enabled in the server, and the
    configuration for each of those features. You can enable all of the MicroProfile
    4.1 features by listing the `microProfile-4.1` feature in your `server.xml` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise just like with the Maven dependencies, if you prefer to enable fewer
    features, such as if you only want *MicroProfile Health* and *MicroProfile Metrics*,
    you can instead list them separately as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the features you enable, some of them support stanzas for configuration.
    Many of the Java Enterprise Edition resources are configured here, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: JDBC DataSources for talking to relational databases such as IBM DB2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JMS ActivationSpecs for talking to messaging systems such as IBM MQ.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudantDatabase for talking to a NoSQL datastore such as IBM Cloudant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the MicroProfile features in particular, here is how the Stock Trader microservices
    configure the *MicroProfile JWT* and *MicroProfile Metrics* features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: These features have been discussed in the previous chapters, so we won't repeat
    that here. One thing to note though is that we are referencing environment variables
    such as `${JWT_ISSUER}`, rather than hardcoding such values; this way, we don't
    have to rebuild the container image if we want to modify the values – instead,
    we would just update the value in a Kubernetes *ConfigMap* or *Secret*, and our
    operator would configure the `.yaml` file for the *Deployment* to obtain and pass
    the appropriate values as environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the `server.xml` file, other Open Liberty-specific files in the `src/main/liberty/config`
    directory include `jvm.options` (used to pass JVM system properties, and so on),
    and your key store and/or trust store files (such as `key.p12` and `trust.p12`
    in the `src/main/liberty/config/resources/security` directory). The files are
    laid out here in the same directory structure as is required in the Open Liberty
    server so that we can just copy the entire directory into the appropriate location
    in the Docker container for Open Liberty, as we'll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have all of the input files ready that need to become part of the
    Docker container image, you use a `Dockerfile` to say what files you want copied
    where. You can also run commands other than `COPY`, such as setting file permissions
    or installing additional tools in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `Dockerfile` for the Trader microservice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: kernel-slim image, which means no features beyond the kernel are packaged in
    the image, in the interest of size. The next important line says we want to copy
    the `src/main/liberty/config` directory into the `/config` directory in the container
    image. This `/config` directory is actually a soft link to `/opt/ol/wlp/usr/servers/defaultServer`
    in Open Liberty (or to `/opt/ibm/wlp/usr/servers/defaultServer` on commercial
    WebSphere Liberty, which you'd get via `FROM ibmcom/websphere-liberty:kernel-java11-openj9-ubi`).
    We copy the whole directory (and its subdirectories), rather than a separate `COPY`
    per file, to reduce the number of layers in the resulting Docker image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we run a script called `features.sh`, which downloads all of the features
    we specify in `server.xml` we copied into the Docker image in the previous step.
    If instead of using the `kernel-slim` image we had instead used the `full` image,
    this step would not be needed. Note we want to run this before we copy our WAR
    file (that Maven produced) into the container so that we don't need to rerun this
    time-consuming step each time we make a small change to our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we copy our WAR file (or the Messaging microservice copies in an `ear`
    file instead, as it has our one EJB – an MDB) into the container. Note `--chown
    1001:0`, which tells it what user and group should own the file – without this,
    the server, which does *NOT* run as root, would not have authority to access the
    files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we run the `configure.sh` script, which does some further tweaking
    of file permissions, and which builds the shared class cache to improve performance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now run our build, which will execute each line of the `Dockerfile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have a Docker image produced, which we can push to an image registry,
    so that it''s available for your operator to access and use in a Kubernetes environment
    such as the **OpenShift Container Platform** (**OCP**). For example, here we push
    it to Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we''ve built the *Trader* microservice, repeat the aforementioned
    steps for the *Stock Quote* microservice, which we''ll also use later in this
    chapter. As a quick recap, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone https://github.com/IBMStockTrader/stock-quote`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd stock-quote`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mvn package`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker build -t stock-quote .`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at how to test the container images we just
    built.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Stock Trader microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned how to build our microservices, the next important step,
    before deploying them to an OpenShift environment, is to first perform some unit
    tests on them to make sure they are working as desired.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the frontend microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can perform such unit tests by using locally installed Docker on our laptops.
    Let''s run the Docker container we just built for Trader, and try it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This `docker run` command starts the container, tells it to expose its port
    `9443` (the default HTTPS port for Open Liberty), and passes a few environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The environment variable `TEST_MODE` is used to facilitate testing the Trader
    microservice, which usually needs connectivity to a Broker microservice. It has
    an option to bypass that and work with hardcoded data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our container is running, let''s hit `https://localhost:9443/trader`
    in a browser. After logging in (as `stock`/`trader`), we can see the hardcoded
    `TEST_MODE` data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Testing the Trader UI microservice via docker run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Testing the Trader UI microservice via docker run
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have successfully tested the *Trader* microservice in a
    container!
  prefs: []
  type: TYPE_NORMAL
- en: Testing a backend microservice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing a frontend microservice in a browser is pretty straightforward since
    the web browser takes care of login cookies for you, but when it comes to testing
    one of the backend microservices, it is a bit more difficult, due to the use of
    the **JSON Web Token** (**JWT**) for **Single Sign-On** (**SSO**) purposes.  The
    *Stock Quote* microservice is an example of such a backend microservice that uses
    **MicroProfile JWT** to ensure that no caller is allowed in without first having
    passed a login challenge, which returns a JWT upon success.
  prefs: []
  type: TYPE_NORMAL
- en: Start the Docker container for the Stock Quote microservice we built earlier
    via `docker run -p 9080:9080 -e JWT_AUDIENCE=test -e JWT_ISSUER=test stock-quote:latest`.
    Like before, this exposes a port so that we can communicate with it; in this case,
    it is port `9080`, used for standard (unencrypted) HTTP access.
  prefs: []
  type: TYPE_NORMAL
- en: However, just directly invoking the REST API exposed by the Stock Quote microservice,
    by running a command such as `curl http://localhost:9080/stock-quote/TEST`, will
    result in a `401` error being returned due to the missing SSO credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`TEST` is another special value that returns hardcoded data, bypassing the
    call to the internet to get an actual stock quote.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can address this problem by using our frontend Trader microservice to do
    a login and then looking in the Web Inspector built into the browser to find out
    the value of the JWT cookie. This will be a little different in each browser;
    in my case, I''m using Safari on my Mac, and I select **Develop** | **Show Web
    Inspector** from the menu bar. Then I just find the **summary** request (this
    is the servlet showing all of the portfolios) and copy the value of its **JWT**
    cookie to the clipboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Getting the JWT value from the Web Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_03_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Getting the JWT value from the Web Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'Then just paste that big string into an `Authorization` header in `curl`, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we got back a stock price of `123.45` from this quick unit test
    of our backend Stock Quote microservice. Note that JWTs automatically expire,
    so after a while, you'll have to do this again to get a fresh one if your `curl`
    calls start getting rejected. Of course, there are also GUI REST test clients
    that can simplify this common issue of how to pass credentials to a backend service.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen the approach for how to build and test the containers for
    each of our microservices, let's dive a bit deeper into the usage of MicroProfile
    4.1 features in the Stock Trader application.
  prefs: []
  type: TYPE_NORMAL
- en: Using MicroProfile features in Stock Trader
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a view of which Stock Trader microservices use which MicroProfile
    features. Note that there are two ways a microservice can benefit from a given
    MicroProfile feature – implicitly or explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: In the implicit case, just listing the feature in your `server.xml` file gives
    you value; for example, you can obtain default implementations for readiness and
    liveness probes just by enabling the `mpHealth-3.1` feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the explicit case, you directly code to the APIs offered by the feature,
    such as implementing your own custom logic for whether your microservice is healthy
    by coding to classes in the `org.eclipse.microprofile.health` package from within
    your own Java classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following table, we can see which microservices use which feature, with
    the *not* sign meaning not at all, the *dash* meaning implicit usage, and the
    *checkmark* meaning explicit usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.1 – MicroProfile usage in each Stock Trader microservice'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_01_new.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1 – MicroProfile usage in each Stock Trader microservice
  prefs: []
  type: TYPE_NORMAL
- en: Note that the tWAS-based Notification-Twitter and the Node.js-based Tradr aren't
    listed (since they don't run on a MicroProfile-compliant server) and that the
    Messaging microservice is just an MDB with no HTTP endpoint, so most MicroProfile
    features don't apply to it. Also, with Stock Trader, we tend to use the (Istio-based)
    *OpenShift Service Mesh* to define our Fault Tolerance policies via `.yaml` files,
    rather than directly coding to the mpFaultTolerance feature.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit usage of MicroProfile features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MicroProfile delivers significant benefits to applications that are being modernized
    to a MicroProfile-compliant application server, even if the applications aren't
    updated to code to the APIs of the various MicroProfile features. This can be
    useful, such as in situations where you are modernizing from the traditional WebSphere
    Application Server to Open Liberty, but don't want to have to make a lot of code
    updates. In the following sub-sections, we'll examine which MicroProfile features
    can provide such implicit benefits.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile Health
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, you can get automatic implementations of the Kubernetes
    startup, readiness, and liveness probes, just by enabling the `mpHealth-3.1` feature
    in your `server.xml` file. Note that startup probes are relatively new in Kubernetes,
    added in version 1.16, which corresponds to OpenShift version 4.3\. And support
    for them was added rather recently in MicroProfile, starting in version 4.1, which
    is the first version containing MicroProfile Health version 3.1.
  prefs: []
  type: TYPE_NORMAL
- en: A startup probe is useful if your application takes a long time to start (such
    as if it loads and caches a lot of data from a database).
  prefs: []
  type: TYPE_NORMAL
- en: A readiness probe is important so that work won't get routed to a newly started
    pod until it is actually ready to process such requests.
  prefs: []
  type: TYPE_NORMAL
- en: The default readiness implementation will return `false` until the server and
    all of its applications are fully started, and from then on will return `true`,
    until a signal is received that the server is stopping (such as when a *HorizontalPodAutoscaler*
    scales down the number of pods for a deployment). This is also the default startup
    probe implementation – so really, you only get additional value from a startup
    probe, above and beyond what you get from the default readiness probe implementation
    if you provide your own explicit implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The default liveness implementation will return `true` as long as the server
    can process inbound HTTP requests. This will usually be the case unless all of
    the threads in the web container are hung/in use, or something really bad like
    an `OutOfMemoryError` has occurred. Kubernetes will automatically kill any pod
    that fails its liveness probe a specified consecutive number of times and start
    a fresh one to replace it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the results of directly calling the startup, readiness, and liveness
    probes on our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: MicroProfile metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three kinds of metrics: base, vendor, and application. The first
    two kinds will be available automatically to anyone that periodically scrapes
    the `/metrics` endpoint (such as *Prometheus*), just by enabling the `mpMetrics-3.0`
    feature in the `server.xml` file. The third kind is only available when the application
    is coded to the annotations or explicit API calls from the `org.eclipse.microprofile.metrics`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Base metrics are defined by the MicroProfile Metrics specification, and generally
    include JVM-level metrics related to heap size, garbage collection, and thread
    counts, in addition to various counters and timings. Vendor metrics vary by each
    application server, and include things such as JDBC and JMS connection pool usage
    and other things that the app server manages for you. Let''s take a look at a
    few of the available base and vendor metrics (the full set would take many pages
    to display) from our running Stock Quote container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: MicroProfile OpenTracing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another of the observability-related features is MicroProfile OpenTracing.
    This will automatically generate trace spans for any JAX-RS operation, simply
    by enabling the `mpOpenTracing-2.0` feature. These trace spans are sent to any
    registered tracer, such as for Jaeger. If you have the Jaeger tracer registered,
    you should see the following in your container''s output, indicating that trace
    spans are being sent on each JAX-RS operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The other important feature of MicroProfile Open Tracing is that a *span* can
    chain to as many calls as needed, so rather than just seeing one span showing
    that A called B and another span showing that B called C, a span could encompass
    showing the call path from A to B to C, including when they occurred, how long
    each part took, and much more. Being able to see, for example, a span that includes
    Trader calling Broker calling Portfolio calling Stock Quote is valuable to those
    wanting to see how all of these various microservices fit together at runtime,
    and whether they are performing as expected.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile OpenAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MicroProfile OpenAPI feature is quite cool since it will generate documentation
    about your JAX-RS class, simply by enabling the `mpOpenAPI-2.0` feature in your
    `server.xml` file. If someone wants to know what operations your microservice
    makes available, all they have to do is `curl http://localhost:9080/openapi` to
    get a `.yaml` file that explains each of the available operations, their input
    parameters, and the data structure they return.
  prefs: []
  type: TYPE_NORMAL
- en: 'One nice bonus item you get with Open Liberty is the ability to have it generate
    a human-friendly web page rendering of this information (sometimes this is referred
    to as the Swagger UI). Just hit `http://localhost:9080/openapi/ui` in a browser
    to see an HTML rendering. Let''s take a look at the HTML rendering for our Broker
    microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – The MicroProfile OpenAPI UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – The MicroProfile OpenAPI UI
  prefs: []
  type: TYPE_NORMAL
- en: Here we can see there's a `Broker` JSON object that these operations return.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also drill into one of the operations and see details about it – let''s
    pick the **PUT** operation that''s used to update a portfolio with a trade of
    stock:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Operation details in the MicroProfile OpenAPI UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Operation details in the MicroProfile OpenAPI UI
  prefs: []
  type: TYPE_NORMAL
- en: Now we can see what path and query parameters are expected, and can even click
    the `curl` command for what we've entered in each field of the form, and the results
    of invoking the operation.
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile JWT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final MicroProfile feature that offers implicit value is MicroProfile JWT.
    Simply by enabling the `mpJWT-1.2` feature in your `server.xml` file (and a few
    other stanzas in the `server.xml` file, a stanza in the WAR file's `web.xml`,
    and a signing key in your `keystore/truststore`), you can cause the app server
    to reject any calls that don't have the required JWT in either the Authorization
    HTTP header or in a cookie.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very powerful feature, in that you get nice single sign-on enforcement,
    without having to edit your Java code at all. If someone tries to invoke your
    microservice without attaching an appropriate JWT, it will get rejected with a
    `403` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When this occurs, you will see the following message get logged by your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Getting such powerful security enforcement, without any Java coding on your
    part, is a very nice feature provided by MicroProfile!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a feel for how to build and unit test any of the microservices
    in the Stock Trader application. You should also now be comfortable with how to
    containerize such microservices, and then run such containers and invoke such
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, often, rather than running such build steps as we''ve covered in
    this chapter manually from Command Prompt, you will have a DevOps pipeline that
    runs such steps for you, such as automatically kicking off via a webhook when
    you commit a change to your Git repository. For example, see this blog entry on
    such a CI/CD pipeline for the Trader microservice, which also performs various
    security and compliance checks: [https://medium.com/cloud-engagement-hub/are-your-ci-cd-processes-compliant-cee6db1cf82a](https://medium.com/cloud-engagement-hub/are-your-ci-cd-processes-compliant-cee6db1cf82a).
    But it''s good to understand how to do stuff manually, rather than it just seeming
    like some magical, mysterious thing occurs to get to where your container image
    is built and available in your image registry.'
  prefs: []
  type: TYPE_NORMAL
- en: We've also covered how Stock Trader benefits from many of the MicroProfile features,
    even though it is not explicitly coded to such features. The fact that modernizing
    to a MicroProfile-compliant app server offers such benefits "for free," without
    your developers having to spend time modifying their code, is a strong motivator
    for engaging in such an application modernization effort.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to deploy this application to an OpenShift
    cluster, via its operator, and will look at how we can use it to perform some
    *Day 2* operations.
  prefs: []
  type: TYPE_NORMAL
