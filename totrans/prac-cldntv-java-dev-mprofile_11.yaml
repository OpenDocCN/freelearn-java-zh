- en: '*Chapter 8*: Building and Testing Your Cloud-Native Application'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we've looked at various MicroProfile technologies
    in isolation. Now, let's come back to our example application, the **IBM Stock
    Trader**, first introduced in [*Chapter 3*](B17377_03_Final_SB_epub.xhtml#_idTextAnchor049),
    *Introducing the IBM Stock Trader Cloud-Native Application*, to see those in use
    across various microservices. In this chapter, we'll focus on how to build those
    microservices, how to construct the container image for each and push them to
    an image registry, how to unit test them, and the usage of various MicroProfile
    features.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Compiling the Stock Trader microservices
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the Stock Trader container images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the Stock Trader microservices
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stock Trader usage of MicroProfile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with how to build the various
    pieces of such a cloud-native application, how to try out each of them, and how
    to demonstrate their usage.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To build and test the microservices as described in this section, you will
    need to have the following tools installed:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '**Java Development Kit** (**JDK**) – Java 8 or later: [http://ibm.biz/GetSemeru](http://ibm.biz/GetSemeru)'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apache Maven: [https://maven.apache.org](https://maven.apache.org)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Git client: [https://git-scm.com](https://git-scm.com)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Docker client: [https://www.docker.com/products](https://www.docker.com/products
    )'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiling the Stock Trader microservices
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at how to create a local copy of the source code
    for each microservice, and how to compile it and package it up into an archive
    that can be deployed onto an application server.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A public GitHub organization called *IBMStockTrader*, at [https://github.com/IBMStockTrader](https://github.com/IBMStockTrader),
    contains repositories for each of the dozen or so microservices comprising the
    application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on the `trader` repository, and clone its contents:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The most important files here are `Dockerfile` and the `pom.xml` (both of which
    we''ll discuss shortly), and the `src` directory, which contains all of the source
    code. This includes the Java code (under `src/main/java` – each of the Stock Trader
    microservices has its own sub-package under `com.ibm.hybrid.cloud.sample.stocktrader`),
    the web artifacts (under `src/main/webapp`), and the Open Liberty configuration
    (under `src/main/liberty/config` – we''ll look at this further in the *Building
    the Stock Trader container images* section). All of the microservices in the application
    follow this same structure. Let''s take a look at the contents of the `src` directory:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Source code layout in the IBMStockTrader Git repositories'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Source code layout in the IBMStockTrader Git repositories
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen the source code structure in each Git repository, let's
    look at how to use *Maven* to build it and package the results up for deployment
    to the Docker container for the Open Liberty application server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了每个 Git 仓库中的源代码结构，让我们看看如何使用 *Maven* 来构建它并将结果打包以部署到 Open Liberty 应用程序服务器的
    Docker 容器。
- en: Maven
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Maven
- en: 'The `pom.xml` file tells Maven what to build and how. Here are the steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`pom.xml` 文件告诉 Maven 要构建什么以及如何构建。以下是步骤：'
- en: 'First, you need to include the following stanza in the `pom.xml` file so that
    usage of `org.eclipse.microprofile.*` packages will compile:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要在 `pom.xml` 文件中包含以下段落，以便 `org.eclipse.microprofile.*` 包的使用可以编译：
- en: '[PRE1]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is the *umbrella* dependency that puts all of the MicroProfile 4 features
    on the compile-time classpath. You can also just choose particular MicroProfile
    features if you prefer; for example, to put just *MicroProfile Health* on the
    compile-time classpath, you'd specify `org.eclipse.microprofile.health`.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是将所有 MicroProfile 4 功能放在编译时类路径上的 *总依赖项*。如果您愿意，也可以只选择特定的 MicroProfile 功能；例如，要将仅
    *MicroProfile Health* 放在编译时类路径上，您需要指定 `org.eclipse.microprofile.health`。
- en: Note the `<scope>provided</scope>` line – this tells Maven that, though it should
    add such JAR files to the compile-time classpath, it should *NOT* bundle such
    JAR files inside the WAR file being built. The application server (Open Liberty,
    in our case) hosting the WAR file *provides* such JAR files, and having an additional
    copy inside the application can cause class loader issues, so we tell it `provided`
    to avoid that.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意 `<scope>provided</scope>` 行 - 这告诉 Maven，尽管它应该将这些 JAR 文件添加到编译时类路径，但它不应该将这些
    JAR 文件捆绑在构建的 WAR 文件中。托管 WAR 文件的应用服务器（在我们的例子中是 Open Liberty）提供了这些 JAR 文件，在应用程序内部有额外的副本可能会导致类加载器问题，所以我们告诉它
    `provided` 以避免这种情况。
- en: 'Next, let''s use Maven to build our `Trader` microservice. Most modern `brew
    install maven` to install it. Note that Maven also depends on Java, and you will
    need the `JAVA_HOME` environment variable to point to your Java installation.
    Let''s use `mvn compile` to compile our code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们使用 Maven 构建我们的 `Trader` 微服务。大多数现代系统通过 `brew install maven` 来安装它。请注意，Maven
    也依赖于 Java，您需要设置 `JAVA_HOME` 环境变量以指向您的 Java 安装。让我们使用 `mvn compile` 来编译我们的代码：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, it takes less than a couple of seconds to compile all of the
    code. Of course, if any compilation errors occurred, they will be shown when this
    is run.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如您所见，编译所有代码只需几秒钟的时间。当然，如果发生任何编译错误，它们将在运行时显示。
- en: 'Next, let''s package up the WAR file, via `mvn package`. Some of the several
    pages of output are snipped out to save space, but the important part is shown
    here:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们通过 `mvn package` 打包 WAR 文件。为了节省空间，一些输出页被省略了，但这里显示了重要的部分：
- en: '[PRE3]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Lastly, we can run some basic integration tests via the command `mvn verify`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以通过命令 `mvn verify` 运行一些基本的集成测试。
- en: 'This will execute any test classes you might have under `src/test/java` (highly
    recommended, to catch problems early), such as our `HealthEndpointIT.java` and
    `HomePageIT.java` under `src/test/java/com/ibm/hybrid/cloud/sample/stocktrader/trader/test`:'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将执行 `src/test/java` 下可能存在的任何测试类（强烈推荐，以尽早发现问题），例如我们位于 `src/test/java/com/ibm/hybrid/cloud/sample/stocktrader/trader/test`
    下的 `HealthEndpointIT.java` 和 `HomePageIT.java`：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now that we've seen how to compile, package, and test our code, let's look at
    how to containerize it and test the container.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何编译、打包和测试我们的代码，接下来让我们看看如何容器化它并测试容器。
- en: Building the Stock Trader container images
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建股票交易者容器镜像
- en: As discussed in previous sections, we use *Open Liberty* as the application
    server hosting most of the Stock Trader microservices. And we use *Docker* to
    produce the container images that ultimately get run in a Kubernetes cluster such
    as the *OpenShift Container Platform* cluster.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们使用 *Open Liberty* 作为托管大多数股票交易者微服务应用程序服务器的服务器。我们使用 *Docker* 来生成最终在 Kubernetes
    集群（如 *OpenShift Container Platform* 集群）中运行的容器镜像。
- en: The following subsections will describe how we configure the server, and how
    we package it up into a container image.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下小节将描述我们如何配置服务器，以及如何将其打包成容器镜像。
- en: Open Liberty
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Open Liberty
- en: 'There are a variety of MicroProfile compliant Java application servers on the
    market. As a reminder from [*Chapter 3*](B17377_03_Final_SB_epub.xhtml#_idTextAnchor049),
    *Introducing the IBM Stock Trader Cloud-Native Application*, most of the Stock
    Trader microservices (Trader, Broker, Broker-Query, Portfolio, Account, Trade
    History, Messaging, Notification-Slack, Collector, and Looper) are based on the
    open source Open Liberty application server. For variety, there are three other
    microservices based on different servers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上有许多符合MicroProfile规范的Java应用程序服务器。作为提醒，从[*第3章*](B17377_03_Final_SB_epub.xhtml#_idTextAnchor049)，“介绍IBM股票交易云原生应用程序”，大多数股票交易微服务（交易员、经纪人、经纪人-查询、投资组合、账户、交易历史、消息传递、通知-Slack、收集器、循环器）都是基于开源的Open
    Liberty应用程序服务器。为了多样性，还有三个基于不同服务器的其他微服务：
- en: Stock Quote, which runs on Red Hat's **Quarkus**.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 股票报价，运行在红帽的**Quarkus**上。
- en: Notification-Twitter, which runs on **traditional WebSphere Application Server**
    (**tWAS**).
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知-Twitter，运行在**传统WebSphere应用程序服务器**（**tWAS**）上。
- en: Tradr is the only non-Java microservice, which is written in Node.js.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Tradr是唯一的非Java微服务，它用Node.js编写。
- en: But here, we'll focus on the ones that run on Open Liberty.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这里，我们将关注在Open Liberty上运行的那些。
- en: 'The most important file for configuring an Open Liberty server is the `server.xml`
    file. This defines the features that should be enabled in the server, and the
    configuration for each of those features. You can enable all of the MicroProfile
    4.1 features by listing the `microProfile-4.1` feature in your `server.xml` as
    follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 配置Open Liberty服务器的最重要的文件是`server.xml`文件。它定义了应在服务器中启用的功能以及每个功能的配置。您可以通过在`server.xml`中列出`microProfile-4.1`功能来启用所有MicroProfile
    4.1功能，如下所示：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Otherwise just like with the Maven dependencies, if you prefer to enable fewer
    features, such as if you only want *MicroProfile Health* and *MicroProfile Metrics*,
    you can instead list them separately as shown here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，就像Maven依赖项一样，如果您更喜欢启用较少的功能，例如，如果您只想启用*MicroProfile Health*和*MicroProfile
    Metrics*，您可以像下面这样单独列出它们：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In addition to the features you enable, some of them support stanzas for configuration.
    Many of the Java Enterprise Edition resources are configured here, such as the
    following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 除了您启用的功能外，其中一些支持配置段。许多Java企业版资源都在此配置，例如以下内容：
- en: JDBC DataSources for talking to relational databases such as IBM DB2.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与关系数据库（如IBM DB2）通信的JDBC数据源。
- en: JMS ActivationSpecs for talking to messaging systems such as IBM MQ.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于与消息系统（如IBM MQ）通信的JMS ActivationSpecs。
- en: CloudantDatabase for talking to a NoSQL datastore such as IBM Cloudant.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CloudantDatabase用于与NoSQL数据存储（如IBM Cloudant）通信。
- en: 'For the MicroProfile features in particular, here is how the Stock Trader microservices
    configure the *MicroProfile JWT* and *MicroProfile Metrics* features:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于特定的MicroProfile功能，以下是股票交易微服务如何配置*MicroProfile JWT*和*MicroProfile Metrics*功能：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These features have been discussed in the previous chapters, so we won't repeat
    that here. One thing to note though is that we are referencing environment variables
    such as `${JWT_ISSUER}`, rather than hardcoding such values; this way, we don't
    have to rebuild the container image if we want to modify the values – instead,
    we would just update the value in a Kubernetes *ConfigMap* or *Secret*, and our
    operator would configure the `.yaml` file for the *Deployment* to obtain and pass
    the appropriate values as environment variables.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能已在之前的章节中讨论过，所以这里不再重复。但需要注意的是，我们引用的是环境变量，如`${JWT_ISSUER}`，而不是硬编码这些值；这样，如果我们想修改这些值，我们就不必重新构建容器镜像——相反，我们只需更新Kubernetes
    *ConfigMap*或*Secret*中的值，然后我们的操作员将为*Deployment*配置`.yaml`文件，以获取和传递适当的环境变量值。
- en: Beyond the `server.xml` file, other Open Liberty-specific files in the `src/main/liberty/config`
    directory include `jvm.options` (used to pass JVM system properties, and so on),
    and your key store and/or trust store files (such as `key.p12` and `trust.p12`
    in the `src/main/liberty/config/resources/security` directory). The files are
    laid out here in the same directory structure as is required in the Open Liberty
    server so that we can just copy the entire directory into the appropriate location
    in the Docker container for Open Liberty, as we'll see in the next section.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you have all of the input files ready that need to become part of the
    Docker container image, you use a `Dockerfile` to say what files you want copied
    where. You can also run commands other than `COPY`, such as setting file permissions
    or installing additional tools in the container:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the `Dockerfile` for the Trader microservice:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: kernel-slim image, which means no features beyond the kernel are packaged in
    the image, in the interest of size. The next important line says we want to copy
    the `src/main/liberty/config` directory into the `/config` directory in the container
    image. This `/config` directory is actually a soft link to `/opt/ol/wlp/usr/servers/defaultServer`
    in Open Liberty (or to `/opt/ibm/wlp/usr/servers/defaultServer` on commercial
    WebSphere Liberty, which you'd get via `FROM ibmcom/websphere-liberty:kernel-java11-openj9-ubi`).
    We copy the whole directory (and its subdirectories), rather than a separate `COPY`
    per file, to reduce the number of layers in the resulting Docker image.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we run a script called `features.sh`, which downloads all of the features
    we specify in `server.xml` we copied into the Docker image in the previous step.
    If instead of using the `kernel-slim` image we had instead used the `full` image,
    this step would not be needed. Note we want to run this before we copy our WAR
    file (that Maven produced) into the container so that we don't need to rerun this
    time-consuming step each time we make a small change to our application.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we copy our WAR file (or the Messaging microservice copies in an `ear`
    file instead, as it has our one EJB – an MDB) into the container. Note `--chown
    1001:0`, which tells it what user and group should own the file – without this,
    the server, which does *NOT* run as root, would not have authority to access the
    files.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we run the `configure.sh` script, which does some further tweaking
    of file permissions, and which builds the shared class cache to improve performance.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now run our build, which will execute each line of the `Dockerfile`:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now have a Docker image produced, which we can push to an image registry,
    so that it''s available for your operator to access and use in a Kubernetes environment
    such as the **OpenShift Container Platform** (**OCP**). For example, here we push
    it to Docker Hub:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now that we''ve built the *Trader* microservice, repeat the aforementioned
    steps for the *Stock Quote* microservice, which we''ll also use later in this
    chapter. As a quick recap, run the following commands:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone https://github.com/IBMStockTrader/stock-quote`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd stock-quote`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mvn package`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker build -t stock-quote .`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will look at how to test the container images we just
    built.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Testing the Stock Trader microservices
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've learned how to build our microservices, the next important step,
    before deploying them to an OpenShift environment, is to first perform some unit
    tests on them to make sure they are working as desired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Testing the frontend microservice
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can perform such unit tests by using locally installed Docker on our laptops.
    Let''s run the Docker container we just built for Trader, and try it out:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This `docker run` command starts the container, tells it to expose its port
    `9443` (the default HTTPS port for Open Liberty), and passes a few environment
    variables.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The environment variable `TEST_MODE` is used to facilitate testing the Trader
    microservice, which usually needs connectivity to a Broker microservice. It has
    an option to bypass that and work with hardcoded data.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our container is running, let''s hit `https://localhost:9443/trader`
    in a browser. After logging in (as `stock`/`trader`), we can see the hardcoded
    `TEST_MODE` data:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Testing the Trader UI microservice via docker run'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_02.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – Testing the Trader UI microservice via docker run
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations, you have successfully tested the *Trader* microservice in a
    container!
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Testing a backend microservice
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Testing a frontend microservice in a browser is pretty straightforward since
    the web browser takes care of login cookies for you, but when it comes to testing
    one of the backend microservices, it is a bit more difficult, due to the use of
    the **JSON Web Token** (**JWT**) for **Single Sign-On** (**SSO**) purposes.  The
    *Stock Quote* microservice is an example of such a backend microservice that uses
    **MicroProfile JWT** to ensure that no caller is allowed in without first having
    passed a login challenge, which returns a JWT upon success.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Start the Docker container for the Stock Quote microservice we built earlier
    via `docker run -p 9080:9080 -e JWT_AUDIENCE=test -e JWT_ISSUER=test stock-quote:latest`.
    Like before, this exposes a port so that we can communicate with it; in this case,
    it is port `9080`, used for standard (unencrypted) HTTP access.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: However, just directly invoking the REST API exposed by the Stock Quote microservice,
    by running a command such as `curl http://localhost:9080/stock-quote/TEST`, will
    result in a `401` error being returned due to the missing SSO credentials.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '`TEST` is another special value that returns hardcoded data, bypassing the
    call to the internet to get an actual stock quote.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'We can address this problem by using our frontend Trader microservice to do
    a login and then looking in the Web Inspector built into the browser to find out
    the value of the JWT cookie. This will be a little different in each browser;
    in my case, I''m using Safari on my Mac, and I select **Develop** | **Show Web
    Inspector** from the menu bar. Then I just find the **summary** request (this
    is the servlet showing all of the portfolios) and copy the value of its **JWT**
    cookie to the clipboard:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Getting the JWT value from the Web Inspector'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17377_08_03_new.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Getting the JWT value from the Web Inspector
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: 'Then just paste that big string into an `Authorization` header in `curl`, as
    shown here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, we got back a stock price of `123.45` from this quick unit test
    of our backend Stock Quote microservice. Note that JWTs automatically expire,
    so after a while, you'll have to do this again to get a fresh one if your `curl`
    calls start getting rejected. Of course, there are also GUI REST test clients
    that can simplify this common issue of how to pass credentials to a backend service.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen the approach for how to build and test the containers for
    each of our microservices, let's dive a bit deeper into the usage of MicroProfile
    4.1 features in the Stock Trader application.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Using MicroProfile features in Stock Trader
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with a view of which Stock Trader microservices use which MicroProfile
    features. Note that there are two ways a microservice can benefit from a given
    MicroProfile feature – implicitly or explicitly:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: In the implicit case, just listing the feature in your `server.xml` file gives
    you value; for example, you can obtain default implementations for readiness and
    liveness probes just by enabling the `mpHealth-3.1` feature.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the explicit case, you directly code to the APIs offered by the feature,
    such as implementing your own custom logic for whether your microservice is healthy
    by coding to classes in the `org.eclipse.microprofile.health` package from within
    your own Java classes.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following table, we can see which microservices use which feature, with
    the *not* sign meaning not at all, the *dash* meaning implicit usage, and the
    *checkmark* meaning explicit usage:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.1 – MicroProfile usage in each Stock Trader microservice'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_01_new.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Table 8.1 – MicroProfile usage in each Stock Trader microservice
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note that the tWAS-based Notification-Twitter and the Node.js-based Tradr aren't
    listed (since they don't run on a MicroProfile-compliant server) and that the
    Messaging microservice is just an MDB with no HTTP endpoint, so most MicroProfile
    features don't apply to it. Also, with Stock Trader, we tend to use the (Istio-based)
    *OpenShift Service Mesh* to define our Fault Tolerance policies via `.yaml` files,
    rather than directly coding to the mpFaultTolerance feature.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Implicit usage of MicroProfile features
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MicroProfile delivers significant benefits to applications that are being modernized
    to a MicroProfile-compliant application server, even if the applications aren't
    updated to code to the APIs of the various MicroProfile features. This can be
    useful, such as in situations where you are modernizing from the traditional WebSphere
    Application Server to Open Liberty, but don't want to have to make a lot of code
    updates. In the following sub-sections, we'll examine which MicroProfile features
    can provide such implicit benefits.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile为那些正在现代化为MicroProfile兼容应用程序服务器的应用程序提供了显著的好处，即使这些应用程序没有更新到各种MicroProfile功能的API。这在某些情况下可能很有用，例如，当你从传统的WebSphere应用程序服务器现代化到Open
    Liberty时，但不想进行大量的代码更新。在以下子节中，我们将检查哪些MicroProfile功能可以提供这样的隐式好处。
- en: MicroProfile Health
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MicroProfile健康检查
- en: As mentioned previously, you can get automatic implementations of the Kubernetes
    startup, readiness, and liveness probes, just by enabling the `mpHealth-3.1` feature
    in your `server.xml` file. Note that startup probes are relatively new in Kubernetes,
    added in version 1.16, which corresponds to OpenShift version 4.3\. And support
    for them was added rather recently in MicroProfile, starting in version 4.1, which
    is the first version containing MicroProfile Health version 3.1.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你只需在`server.xml`文件中启用`mpHealth-3.1`功能，就可以获得Kubernetes启动、就绪和存活探测的自动实现。请注意，启动探测在Kubernetes中相对较新，是在版本1.16中添加的，对应于OpenShift版本4.3。MicroProfile对这些探测的支持是在版本4.1中添加的，这是包含MicroProfile
    Health版本3.1的第一个版本。
- en: A startup probe is useful if your application takes a long time to start (such
    as if it loads and caches a lot of data from a database).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序启动时间较长（例如，如果它从数据库加载并缓存大量数据），启动探测非常有用。
- en: A readiness probe is important so that work won't get routed to a newly started
    pod until it is actually ready to process such requests.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 就绪探测非常重要，这样工作就不会被路由到尚未真正准备好处理此类请求的新启动Pod。
- en: The default readiness implementation will return `false` until the server and
    all of its applications are fully started, and from then on will return `true`,
    until a signal is received that the server is stopping (such as when a *HorizontalPodAutoscaler*
    scales down the number of pods for a deployment). This is also the default startup
    probe implementation – so really, you only get additional value from a startup
    probe, above and beyond what you get from the default readiness probe implementation
    if you provide your own explicit implementation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的就绪实现将在服务器及其所有应用程序完全启动之前返回`false`，然后将继续返回`true`，直到收到服务器停止的信号（例如，当*HorizontalPodAutoscaler*减少部署的Pod数量时）。这也是默认的启动探测实现——所以，如果你提供了自己的显式实现，你从启动探测中获得的额外价值，将超出默认就绪探测实现所提供的内容。
- en: The default liveness implementation will return `true` as long as the server
    can process inbound HTTP requests. This will usually be the case unless all of
    the threads in the web container are hung/in use, or something really bad like
    an `OutOfMemoryError` has occurred. Kubernetes will automatically kill any pod
    that fails its liveness probe a specified consecutive number of times and start
    a fresh one to replace it.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的存活实现只要服务器能够处理传入的HTTP请求就会返回`true`。这通常情况下是成立的，除非Web容器中的所有线程都挂起/正在使用，或者发生了像`OutOfMemoryError`这样的严重问题。Kubernetes会自动杀死任何连续多次失败存活探测的Pod，并启动一个新的Pod来替换它。
- en: 'Here are the results of directly calling the startup, readiness, and liveness
    probes on our container:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是直接在我们的容器上调用启动、就绪和存活探测的结果：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: MicroProfile metrics
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MicroProfile度量指标
- en: 'There are three kinds of metrics: base, vendor, and application. The first
    two kinds will be available automatically to anyone that periodically scrapes
    the `/metrics` endpoint (such as *Prometheus*), just by enabling the `mpMetrics-3.0`
    feature in the `server.xml` file. The third kind is only available when the application
    is coded to the annotations or explicit API calls from the `org.eclipse.microprofile.metrics`
    package.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种类型的度量指标：基础、供应商和应用。前两种类型将自动对定期抓取`/metrics`端点（如*Prometheus*）的任何人可用，只需在`server.xml`文件中启用`mpMetrics-3.0`功能即可。第三种类型仅在应用程序编码为注释或来自`org.eclipse.microprofile.metrics`包的显式API调用时才可用。
- en: 'Base metrics are defined by the MicroProfile Metrics specification, and generally
    include JVM-level metrics related to heap size, garbage collection, and thread
    counts, in addition to various counters and timings. Vendor metrics vary by each
    application server, and include things such as JDBC and JMS connection pool usage
    and other things that the app server manages for you. Let''s take a look at a
    few of the available base and vendor metrics (the full set would take many pages
    to display) from our running Stock Quote container:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 基础指标由MicroProfile Metrics规范定义，通常包括与堆大小、垃圾收集和线程计数相关的JVM级别指标，以及各种计数器和计时器。供应商指标因每个应用程序服务器而异，包括JDBC和JMS连接池使用以及其他应用程序服务器为你管理的事情。让我们看看从我们的运行Stock
    Quote容器中可用的几个基础和供应商指标（完整集合将占用许多页面）：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: MicroProfile OpenTracing
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MicroProfile OpenTracing
- en: 'Another of the observability-related features is MicroProfile OpenTracing.
    This will automatically generate trace spans for any JAX-RS operation, simply
    by enabling the `mpOpenTracing-2.0` feature. These trace spans are sent to any
    registered tracer, such as for Jaeger. If you have the Jaeger tracer registered,
    you should see the following in your container''s output, indicating that trace
    spans are being sent on each JAX-RS operation:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 与可观察性相关的另一个功能是MicroProfile OpenTracing。通过启用`mpOpenTracing-2.0`功能，它将自动为任何JAX-RS操作生成跟踪跨度。这些跟踪跨度被发送到任何已注册的跟踪器，例如Jaeger。如果你已经注册了Jaeger跟踪器，你应该在你的容器输出中看到以下内容，表明跟踪跨度正在每个JAX-RS操作上发送：
- en: '[PRE16]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The other important feature of MicroProfile Open Tracing is that a *span* can
    chain to as many calls as needed, so rather than just seeing one span showing
    that A called B and another span showing that B called C, a span could encompass
    showing the call path from A to B to C, including when they occurred, how long
    each part took, and much more. Being able to see, for example, a span that includes
    Trader calling Broker calling Portfolio calling Stock Quote is valuable to those
    wanting to see how all of these various microservices fit together at runtime,
    and whether they are performing as expected.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile Open Tracing的另一个重要功能是，一个*跨度*可以链接到所需数量的调用，因此，而不是只看到一个跨度显示A调用了B，另一个跨度显示B调用了C，一个跨度可以包含从A到B再到C的调用路径，包括它们发生的时间、每个部分花费的时间以及更多。能够看到例如包含交易员调用经纪人调用投资组合调用股票报价的跨度，对于那些想要了解所有这些各种微服务在运行时如何组合在一起以及它们是否按预期执行的人来说是有价值的。
- en: MicroProfile OpenAPI
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI
- en: The MicroProfile OpenAPI feature is quite cool since it will generate documentation
    about your JAX-RS class, simply by enabling the `mpOpenAPI-2.0` feature in your
    `server.xml` file. If someone wants to know what operations your microservice
    makes available, all they have to do is `curl http://localhost:9080/openapi` to
    get a `.yaml` file that explains each of the available operations, their input
    parameters, and the data structure they return.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: MicroProfile OpenAPI功能相当酷，因为它会通过在`server.xml`文件中启用`mpOpenAPI-2.0`功能来生成关于你的JAX-RS类的文档。如果有人想知道你的微服务提供了哪些操作，他们只需执行`curl
    http://localhost:9080/openapi`来获取一个`.yaml`文件，该文件解释了每个可用的操作、它们的输入参数以及它们返回的数据结构。
- en: 'One nice bonus item you get with Open Liberty is the ability to have it generate
    a human-friendly web page rendering of this information (sometimes this is referred
    to as the Swagger UI). Just hit `http://localhost:9080/openapi/ui` in a browser
    to see an HTML rendering. Let''s take a look at the HTML rendering for our Broker
    microservice:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Open Liberty提供的一个很好的额外功能是能够生成一个人类友好的网页渲染信息（有时这被称为Swagger UI）。只需在浏览器中输入`http://localhost:9080/openapi/ui`即可查看HTML渲染。让我们看看我们的Broker微服务的HTML渲染：
- en: '![Figure 8.4 – The MicroProfile OpenAPI UI'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – MicroProfile OpenAPI UI]'
- en: '](img/B17377_08_04.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17377_08_04.jpg)'
- en: Figure 8.4 – The MicroProfile OpenAPI UI
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.4 – MicroProfile OpenAPI UI](#)'
- en: Here we can see there's a `Broker` JSON object that these operations return.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到，这些操作返回了一个`Broker` JSON对象。
- en: 'We can also drill into one of the operations and see details about it – let''s
    pick the **PUT** operation that''s used to update a portfolio with a trade of
    stock:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以深入到其中一个操作中，查看其详细信息 – 让我们选择用于更新股票交易的**PUT**操作：
- en: '![Figure 8.5 – Operation details in the MicroProfile OpenAPI UI'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.5 – MicroProfile OpenAPI UI中的操作详情](#)'
- en: '](img/B17377_08_05.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17377_08_05.jpg)'
- en: Figure 8.5 – Operation details in the MicroProfile OpenAPI UI
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – MicroProfile OpenAPI UI中的操作详情
- en: Now we can see what path and query parameters are expected, and can even click
    the `curl` command for what we've entered in each field of the form, and the results
    of invoking the operation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: MicroProfile JWT
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final MicroProfile feature that offers implicit value is MicroProfile JWT.
    Simply by enabling the `mpJWT-1.2` feature in your `server.xml` file (and a few
    other stanzas in the `server.xml` file, a stanza in the WAR file's `web.xml`,
    and a signing key in your `keystore/truststore`), you can cause the app server
    to reject any calls that don't have the required JWT in either the Authorization
    HTTP header or in a cookie.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a very powerful feature, in that you get nice single sign-on enforcement,
    without having to edit your Java code at all. If someone tries to invoke your
    microservice without attaching an appropriate JWT, it will get rejected with a
    `403` error:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When this occurs, you will see the following message get logged by your container:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Getting such powerful security enforcement, without any Java coding on your
    part, is a very nice feature provided by MicroProfile!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a feel for how to build and unit test any of the microservices
    in the Stock Trader application. You should also now be comfortable with how to
    containerize such microservices, and then run such containers and invoke such
    microservices.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, often, rather than running such build steps as we''ve covered in
    this chapter manually from Command Prompt, you will have a DevOps pipeline that
    runs such steps for you, such as automatically kicking off via a webhook when
    you commit a change to your Git repository. For example, see this blog entry on
    such a CI/CD pipeline for the Trader microservice, which also performs various
    security and compliance checks: [https://medium.com/cloud-engagement-hub/are-your-ci-cd-processes-compliant-cee6db1cf82a](https://medium.com/cloud-engagement-hub/are-your-ci-cd-processes-compliant-cee6db1cf82a).
    But it''s good to understand how to do stuff manually, rather than it just seeming
    like some magical, mysterious thing occurs to get to where your container image
    is built and available in your image registry.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: We've also covered how Stock Trader benefits from many of the MicroProfile features,
    even though it is not explicitly coded to such features. The fact that modernizing
    to a MicroProfile-compliant app server offers such benefits "for free," without
    your developers having to spend time modifying their code, is a strong motivator
    for engaging in such an application modernization effort.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how to deploy this application to an OpenShift
    cluster, via its operator, and will look at how we can use it to perform some
    *Day 2* operations.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
