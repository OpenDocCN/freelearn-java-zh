- en: Chapter 2. New Specifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will only talk about new specifications that have been added in
    Java EE 7\. In concrete terms, we will present and show how to use the following
    APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency Utilities for Java EE 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch Applications for Java Platform 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java API for JSON Processing 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java API for WebSocket 1.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Concurrency Utilities for Java EE 1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrency Utilities for Java EE 1.0 was developed under JSR 236\. This section
    gives you only an overview of the API. The complete document specification (for
    more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr236/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: Why concurrency?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In computer science, **concurrency** is the ability of an application or a system
    to execute many tasks in parallel. Before the advent of multitasking system, computers
    could only run one process at a time. At that time, the programs were not only
    difficult to design, but they were also executed sequentially from beginning to
    end and when the machine was running a program that had access to a peripheral
    device, the running program was first interrupted to allow the reading of the
    peripheral.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The development of multitasking operating systems enabled the simultaneous execution
    of many processes (instances of running programs) within a machine and many threads
    (also called lightweight processes; they are subsets of a process that can be
    run concurrently with each other) within a process. Due to this progress, it has
    become possible to run multiple applications at the same time, for example, listening
    to music and downloading a document while writing a text document.
  prefs: []
  type: TYPE_NORMAL
- en: In enterprise applications, concurrency can increase the interactivity of your
    program by running heavy processing asynchronously in a thread. It can also be
    used to improve the response time of an application by dividing a big task into
    smaller units that will be executed simultaneously by many threads.
  prefs: []
  type: TYPE_NORMAL
- en: Risks of concurrency
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although each thread has its proper stack of execution, it is very common to
    have multiple threads that share the same resources or depend on each other. In
    such cases, the absence of good synchronization makes threading behavior unpredictable
    and can degrade system performance. For example, the lack of coordination of interrelated
    threads can result in deadlocks and indefinitely interrupt processing.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency and Java EE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen previously, the misuse of threads can have catastrophic consequences
    on an application. In the case of a container, it could not only compromise its
    integrity, but also poorly exploit the resources provided to other components.
    This is one of the reasons why developers were not allowed to create threads in
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: To enable implementation of concurrency within Java EE components, the Java
    EE 7 platform has integrated Concurrency Utilities. Using this API, a Java EE
    server can become aware of the resources that are used by threads and provide
    them with good execution context. Furthermore, it allows the server to manage
    the pool and lifecycle of threads.
  prefs: []
  type: TYPE_NORMAL
- en: Java EE Concurrency API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Concurrency Utilities for Java EE 1.0 was developed with the followings goals
    in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: To provide a simple and flexible concurrency API to the Java EE platform without
    compromising the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To facilitate migration from Java SE to Java EE by providing consistency between
    the concurrency programming models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To allow the implementation of common and advanced concurrency patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Concurrency Utilities was built over the Concurrency Utilities API developed
    under JSR-166 for Java SE (which facilitates the migration from Java SE to Java
    EE). It offers four main programming interfaces whose instances must be made available
    to application components as container-managed objects. The offered interfaces
    are: `ContextService`, `ManagedExecutorService`, `ManagedScheduledExecutorService`,
    and `ManagedThreadFactory`. All these interfaces are contained in the `javax.enterprise.concurrent`
    package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These four interfaces can be explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Managed executor service**: The `ManagedExecutorService` interface extends
    the `java.util.concurrent.ExecutorService` interface. It allows us to submit an
    asynchronous task that will be run on a separate thread created and managed by
    the container. By default, any Java EE 7-compliant server must provide a `ManagedScheduledExecutorService`
    that can be accessed by application components under the **JNDI** name `java:comp/DefaultManagedScheduledExecutorService`.
    But, if you want to create your own, you must first declare the `ManagedExecutorService`
    resource environment reference in the `web.xml` file for a web application or
    `ejb-jar.xml` for an EJB module. The specification recommends that all `ManagedExecutorService`
    resource environment references be organized in the `java:comp/env/concurrent`
    subcontext.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following configuration is an example declaration of a `ManagedExecutorService`
    resource environment reference:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After declaring the JNDI reference, you can then inject it by using the `@Resource`
    annotation as shown in the following code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The task to submit to the container must either implement the `java.lang.Runnable`
    or `java.util.concurrent.Callable` interface. The differences between these interfaces
    are presented in the following table:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Runnable | Callable |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| Since JDK 1.0. | Since JDK 5.0. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| It has `run()` method to define task. | It has the `call()` method to define
    task. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| It is not generic and the `run()` method does not return any value. | It
    is generic and the `call()` method of a `Callable<V>` instance returns a value
    of type `V`. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: '| The `run()` method cannot throw checked exception. | The `call()` method
    can throw checked exception. |'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
- en: 'The following code demonstrates how to define a task that will run reports
    asynchronously:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The following code shows us how to submit a task. We can see that the `submit()`
    method of the `ManagedExecutorService` instance returns an object of type `Future`
    that will get back the result of the running task when it becomes available:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Managed scheduled executor service:** The `ManagedScheduledExecutorService`
    interface extends the `ManagedExecutorService` and `java.util.concurrent.ScheduledExecutorService`
    interfaces in order to execute a task at a specific time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instances of this interface are defined in the same way as that of the `ManagedExecutorService`
    interface. The following code demonstrates how to execute a task ten seconds after
    its submission:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '**Managed thread factory:** The `ManagedThreadFactory` interface provides method
    to create managed thread instances in a container. The task must implement the
    `java.lang.Runnable` interface. The following code demonstrates how to create
    and run a container-managed thread.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Context service:** This interface allows the creation of contextual objects
    without using `ManagedExecutorService` or `ManagedScheduledExecutorService` interfaces,
    as we did in the previous cases, with the aim of allowing the extension of the
    capabilities of a Java EE platform for concurrency. Concretely, with this interface,
    you can create a workflow system or use customized Java SE platform `ExecutorService`
    implementations within a container. For example, if you desire to use the pool
    management mechanism provided by the class `java.util.concurrent.ThreadPoolExecutor`
    of Java SE to manage your threads in the context of a Java EE component, you will
    just need to combine `ManagedThreadFactory`, `ExecutorService`, and `ContextService`
    objects. The result is as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is probably a simple example of the use you can make of this feature. For
    more advanced examples, please consult the specification document in the *Context
    service* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram provides an overview of relationships between Concurrency
    Utilities and other Java EE platform elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Java EE Concurrency API](img/9235OT_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Besides, it is possible to refine the configurations of different resources
    for better performance (for details, see the specification document), and the
    Concurrency Utilities for Java EE 1.0 provide many other interfaces like `ManagedTaskListener`
    that can be used to monitor the state of a task's `Future` object.
  prefs: []
  type: TYPE_NORMAL
- en: Batch Applications for Java Platform 1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Batch Applications API for the Java Platform 1.0 was developed under JSR
    352\. This section just gives you an overview of the API. The complete document
    specification (for more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr352/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is batch processing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: According to the Cambridge Advanced Learner's Dictionary, a batch is a group
    of things or people dealt with at the same time or considered similar in type.
    And a process is a series of actions that you take in order to achieve a result.
    Based on these two definitions, we can say that **batch processing** is a series
    of repetitive actions on a large amount of data in order to achieve a result.
    Given the large amounts of data that it has to deal with, batch processing is
    often used for end of day, month, period, and year processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a short list of domains where you can use batch processing:'
  prefs: []
  type: TYPE_NORMAL
- en: Data import/export from/to XML or CSV files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accounting processing such as consolidations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ETL** (**extract-transform-load**) in a data warehouse'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Digital files processing (downloading, processing, or saving)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notification of a service's subscribers (such as forum, group, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why a dedicated API for batch processing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After having an idea about batch processing, some people might ask themselves:
    Why not just set a `foreach` loop that launches many threads? First of all, you
    have to know that batch processing is not only concerned with the execution speed.
    Indeed, the processing of large amounts of data is often affected by many exceptions,
    which could generate a number of preoccupations: What action should be taken in
    case of exceptions? Should we cancel the whole process for any exception? If not,
    what action should be canceled? For which type of exception? If you only need
    to cancel a certain number of transactions, how do you recognize them? And at
    the end of a batch processing, it is always important to know how many treatments
    have been canceled. How many have been registered successfully? How many have
    been ignored?'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have not finished identifying questions that batch processing
    can raise, but we discover that this is already a great deal. Trying to build
    such a tool on your own may not only complicate your application but also introduce
    new bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Batch API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Batch Applications API for the Java Platform 1.0 was developed to provide
    a solution to the different needs listed in the earlier bullet items. It targets
    both Java SE and Java EE applications and requires at least the 6th Version of
    JVM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The features offered by this API can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It offers the **Reader-Processor-Writer** pattern natively and gives you the
    ability to implement your own batch pattern. This allows you to choose the best
    pattern depending on the case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It gives the possibility of defining the behavior (skip, retry, rollback, and
    so on) of the batch processing for each type of error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It supports many step-level metrics such as: `rollbackCount`, `readSkipCount`,
    `writeSkipCount`, and so on for monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be configured to run some processes in parallel and offer the possibility
    to use JTA or `RESOURCE_LOCAL` transaction mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To do this, the Batch Applications API for the Java Platform 1.0 is based on
    a solid architecture that can be outlined by the following diagram. A **Job**
    is managed by a `JobOperator` and has one or many steps, which can be either **chunk**
    or **batchlet**. During its lifecycle, information (metadata) about a job is stored
    in `JobRepository`, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Understanding the Batch API](img/9235OT_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: JobRepository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we said earlier, `JobRepository` stores metadata about current and past running
    jobs. It can be accessed through `JobOperator`.
  prefs: []
  type: TYPE_NORMAL
- en: Job
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **Job** can be seen as an entity to encapsulate a unit of batch processing.
    It is made up of one or many steps, which must be configured within an XML file
    called a **Job configuration file** or **Job XML**. This file will contain job
    identification information and different steps that compose the job. The code
    that follows shows the skeleton of a Job XML file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The Job XML file is named with the convention `<name>.xml` (for example, `inscriptionJob.xml`)
    and should be stored under the `META-INF/batch-jobs` directory for portable application.
  prefs: []
  type: TYPE_NORMAL
- en: Step
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A **Step** is an autonomous phase of a batch. It contains all the necessary
    information to define and control a piece of batch processing. A batch step is
    either a chunk or a batchlet (the two are mutually exclusive). The step of the
    following code is a chunk type step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Chunk
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **chunk** is a type of step that implements the Reader-Processor-Writer pattern.
    It runs in the scope of a configurable transaction and can receive many configuration
    values. The following code is a more enhanced version of the **inscription-validator-Job**
    shown in the preceding code. In this listing, we have added a configuration to
    define the unit element that will be used in order to manage the commit behavior
    of the chunk (`checkpoint-policy="item"`), and a configuration to define the number
    of items (unit elements) to process before commit (`item-count="15"`). We have
    also specified the number of exceptions a step will skip if any configured exceptions
    that can be skipped are thrown by the chunk (`skip-limit="30"`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a chunk type step with some configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The following code shows us what chunk batch artifact implementation looks like.
    The `InscriptionCheckpoint` allows you to know the line that is being processed.
    The source code of this section is a validation program that sends a message to
    the candidates to let them know if they have been accepted or not. At the end,
    it displays monitoring information in a web page. The processing is launched by
    the `ChunkStepBatchProcessing.java` Servlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a skeleton of chunk batch artifact implementations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Batchlet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **batchlet** is a type of step to implement your own batch pattern. Unlike
    a chunk that performs tasks in three phases (reading, processing, and writing),
    a batchlet step is invoked once and returns an exit status at the end of processing.
    The following code shows us what a batchlet batch artifact implementation looks
    like. The source code of this section sends an information message to all students
    and displays some important information about the batch. The processing is launched
    by the `BatchletStepBatchProcessing.java` Servlet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is a skeleton of batchlet batch artifact implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The batch.xml configuration file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `batch.xml` file is an XML file that contains the batch artifacts of the
    batch application. It establishes a correspondence between the batch artifact
    implementation and the reference name that is used in the Job XML file. The `batch.xml`
    file must be stored in the `META-INF` directory for a portable application. The
    following code gives us the contents of the `batch.xml` file for the `inscription-validator-Job`
    Job shown in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of `batch.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: JobOperator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `JobOperator` instance is accessible through the `getJobOperator()` method
    of the `BatchRuntime` class. It provides a set of operations to manage (`start`,
    `stop`, `restart` and so on) a job and access `JobRepository` (`getJobNames`,
    `getJobInstances`, `getStepExecutions`, and so on). The following code shows how
    to start the `inscription-validator-Job` Job shown earlier without any specific
    property. It is important to note that the `inscriptionJob` value that is specified
    in the `JobOperator.start` command is the name of the Job XML file (not the ID
    of the job). In the Servlet `ChunkStepBatchProcessing`, you will see how to retrieve
    the status and how to monitor information about batch processing from the `JobOperator`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of code to start a Job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Java API for JSON Processing 1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java API for JSON Processing 1.0 was developed under JSR 353\. This section
    gives you only an overview of the API. The complete document specification (for
    more information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr353/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is JSON?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**JavaScript Object Notation** (**JSON**) is a lightweight data-interchange
    text format. It is based on a subset of JavaScript, but it is completely language
    independent. JSON format is often used for data exchanges between web client and
    web server or web service. But, it can be used whenever you need to store or transmit
    relatively small amounts of data that can easily be represented as a combination
    of name-value pairs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JSON is built on two structures, which are: a collection of name-value pairs
    and an ordered list of values. These structures are made from three data types:
    `object`, `array`, and `value`.'
  prefs: []
  type: TYPE_NORMAL
- en: Object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An **object** is an unordered set of `name:value` pairs within braces (`{}`).
    After each name, there is a colon (`:`) and the name-value pairs are separated
    by a comma (`,`). The name is `string` type while the type of the value can be
    `string`, `object` and so on The following text gives an example of a JSON object,
    which contains some information about a student:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An **array** is an ordered collection of values separated by a comma (`,`) within
    brackets (`[]`). The following text gives an example of a JSON array, which contains
    a list of students with their score in alphabetical order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Value
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A JSON **value** can be a `string` in double quotes, a `boolean` true or false,
    an `object`, an `array` or `null`.
  prefs: []
  type: TYPE_NORMAL
- en: Why JSON?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **XML** (**Extensible Markup** **Language**) was released after the **SGML**
    (**Standardised Generalised Markup Language**, which was powerful and extensible
    but complex) and the **HTML** (**HyperText Markup** **Language**, a simple version
    of SGML focused on data presentation) to overcome the shortcomings of both languages.
    Its power, flexibility, and simplicity have favored its use in many applications
    for configuration management, storage, data transfer, and so on. With the advent
    of **AJAX** technologies, the use of XML was widespread in exchanges between browsers
    and web servers. But, it presented some limitations: XML documents are heavy in
    nature because of the duplication of information, loading, and handling of data
    can be complex and processing XML documents sometimes is browser dependent.'
  prefs: []
  type: TYPE_NORMAL
- en: To provide a solution to these problems, the JSON format was developed as an
    alternative to XML. In fact, despite its portability and flexibility, JSON does
    not support namespaces, data access requires a knowledge of the document and until
    now, there is no **XSD** or **DTD** to validate the document's structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple comparison between XML and JSON data presentation is shown in the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| XML data presentation | JSON data presentation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Java API for JSON processing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Java API for JSON processing defines an API to process (`parse`, `generate`,
    `transform`, and `query`) JSON documents by using either the streaming API or
    the object model API.
  prefs: []
  type: TYPE_NORMAL
- en: The streaming API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The **streaming API** is for JSON as **StAX API** is for XML. In other words,
    the streaming API is an event-based JSON parsing. It parses a JSON file sequentially
    and fires an event whenever a it encounters a new tag in the stream (new value
    String, new start of objet, end of objet, new start of an array …). The example
    that follows shows us how to get contact information within the JSON data presented
    on the previous page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of JSON processing using the streaming API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The streaming API consists of five interfaces, one `enum` class, and two exceptions.
    All of them are contained in the `javax.json.stream` package. Among these interfaces,
    we have the `JsonParser` interface, which contains methods for step-by-step read-only
    access to JSON data, and the `JsonGenerator` interface, which provides methods
    to generate (write out) JSON step-by-step. Instances of these interfaces can be
    created respectively with `JsonParserFactory` and `JsonGeneratorFactory` factories.
    All events triggered by the streaming API are contained in the `JsonParser.Event`
    `enum` class.
  prefs: []
  type: TYPE_NORMAL
- en: It's recommended to use the streaming API to parse large JSON files because,
    unlike the object model API, it does not require loading the whole file before
    processing. This ensures good memory management.
  prefs: []
  type: TYPE_NORMAL
- en: The object model API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The object model API is for JSON as **DOM API** is for XML. This means that
    it represents a JSON document as a tree structure in memory before giving the
    possibility to navigate in or query the document. This API provides the most flexible
    way to parse a JSON document by giving a random access to any data it contains.
    But in return, it requires more memory. That is why it is not suitable for large
    documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The object model API consists of thirteen interfaces, one class, one enum class
    and one exception. All of them are packages in `javax.json`. Among interfaces,
    we have: `JsonArrayBuilder` and `JsonObjectBuilder` to build JSON arrays and JSON
    objects respectively from scratch; `JsonArray` to access the ordered values of
    a JSON array as a list and `JsonObject` to access the values of a JSON object
    as a Map and `JsonBuilderFactory` to create `JsonObjectBuilder` or `JsonArrayBuilder`
    instances; `JsonReader` to read JSON from an input source and `JsonReaderFactory`
    to create `JsonReader` instances; `JsonWriter` to write JSON to an output source,
    and `JsonWriterFactory` to create `JsonWriter` instances. The following code demonstrates
    how to create an object model from scratch and access data within it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of JSON processing using the object model
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Java API for WebSocket 1.0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Java API for WebSocket 1.0 was developed under JSR 356\. This section just
    gives you an overview of the API. The complete document specification (for more
    information) can be downloaded from [http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html](http://jcp.org/aboutJava/communityprocess/final/jsr356/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: What is WebSocket?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally called **TCPConnection** in previous versions of the HTML5 specification,
    **WebSocket** is an independent protocol built over the **TCP** (**Transmission
    Control Protocol**), which enables bidirectional and full-duplex communication
    between a client and a server.
  prefs: []
  type: TYPE_NORMAL
- en: To open a WebSocket connection in web application , the web client uses an HTTP
    request to ask the server to upgrade the connection to a WebSocket connection.
    If the server supports and accepts the WebSocket protocol connection request,
    it will still return a response through HTTP. From that moment, the communication
    is established and both parties can send and receive data by using only the WebSocket
    protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Why WebSocket?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Today, many web applications (instant messaging, trading platforms, some e-commerce
    platforms, online gaming, and so on) require a real-time communication between
    a client (browser) and a server. If you do not know, the HTTP protocol is a stateless
    half-duplex protocol. This means that, to access new information and update a
    web page, the client must always open a connection to the server, send a request,
    wait for the server response, and then close the connection. Thus, in a real-time
    context, the client will frequently send requests to the server in order to detect
    the presence of new data and many request-responses will be made even when there
    is no new information.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get around this problem, many solutions have been proposed. The most efficient
    was certainly long polling, which can be described like this: the client makes
    a request to the server; if there is data available, the server responds. Otherwise,
    it waits until there is new information before responding. After receiving the
    response, the client sends another request and so on. Although it seems good,
    this technique requires proprietary solutions (comet) and when data are frequently
    updated, the loop connection-request-response-disconnection may negatively impact
    the network.'
  prefs: []
  type: TYPE_NORMAL
- en: WebSocket is not an HTTP-based technique, it is a protocol that provides a new
    and better way to overcome the shortcomings of the HTTP protocol in real-time
    communication between web client and web server/service.
  prefs: []
  type: TYPE_NORMAL
- en: The WebSocket API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Java API for WebSocket 1.0 defines a standard API to build WebSocket-driven
    applications in the Java EE platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'A WebSocket application consists of two types of components called endpoints:
    a client endpoint and a server endpoint. A client endpoint is the component that
    initiates a WebSocket connection, while a server endpoint is waiting for connections.
    With the Java API for WebSocket 1.0, both component types can be created either
    programmatically or declaratively by using annotations. In this chapter we will
    only see annotated endpoints in a small student chat room application.'
  prefs: []
  type: TYPE_NORMAL
- en: Server endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code demonstrates how to create a WebSocket endpoint that is
    able to accept client connections and send messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `@ServerEndpoint` annotation defines a server type endpoint and the path
    where it will be deployed. You will also notice that the API offers annotations
    to describe the method to be executed in each step of the endpoint lifecycle.
    The following table gives the list and the role of WebSocket endpoint lifecycle
    annotations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table lists the WebSocket endpoint lifecycle annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation | Role |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnOpen` | Designates the method to be executed at the opening of a connection
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnMessage` | Designates the method to be executed when a message is received
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnError` | Designates the method to be executed in case of a connection
    error |'
  prefs: []
  type: TYPE_TB
- en: '| `@OnClose` | Designates the method to be executed when the connection is
    closed |'
  prefs: []
  type: TYPE_TB
- en: 'Any message sent by a WebSocket client is intercepted by the `onMessage()`
    method, which takes the client session and the message as parameters (for other
    parameters that can be taken, please see the specification). Messages can be sent
    synchronously with the method `Session.getBasicRemote()` or asynchronously with
    the method `Session.getAsyncRemote()`. Each of these methods is used to send messages
    of type: `text`, `binary`, `object`, `ping`, and pong frames. The following codedemonstrates
    how to send a text message to all connected clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The session object contains a variable to store some user-specific information.
    The code that follows demonstrates how to communicate with many customers by giving
    the name of the person who sent the message each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Client endpoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our client WebSocket endpoint is a `.jsp` web page (`websocketChatClient.jsp`)
    which is based on JavaScript code. As you can see, the client side has the same
    lifecycle methods and through the power of JSON, we can easily access and display
    messages sent by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is an example of a web client WebSocket endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have tried to present the usefulness and implementation of
    the new specifications of Java EE 7\. In the coming chapters, we will analyze
    the improvements that have been made to the specifications inherited from Java
    EE 6 and use the opportunity to show how to integrate new specifications with
    existing ones.
  prefs: []
  type: TYPE_NORMAL
