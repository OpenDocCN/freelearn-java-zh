- en: Chapter 7. Testing and Reporting with Gradle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover four different topics: testing with TestNG,
    integration testing, code coverage with JaCoCo, and code analysis with Sonar.
    In [Chapter 2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 2. Building Java Projects"), *Building Java Projects*, we already discussed
    unit testing with JUnit. In this chapter, we''ll cover another widely used testing
    tool, TestNG. Code coverage and code quality are the other two important aspects
    in **test-driven development** (**TDD**). In today''s agile development process,
    developers need continuous feedback on the code developed by them. Code quality
    tools help us to achieve this goal. Often, these tools are integrated with the
    **Continuous Integration** (**CI**) systems so that these reports are created
    on a daily basis (may be even after each commit), shared among different teams,
    and even be persisted for future analysis. In this chapter, we will be focusing
    only on the Gradle aspects of different tools. We will mainly cover different
    Gradle plugins that support these features.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with TestNG
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Working with TestNG is similar to the JUnit integration that we discussed in
    [Chapter 2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0 "Chapter 2. Building
    Java Projects"), *Building Java Projects*. The very first step is to create the
    build file with TestNG dependencies and configure the test closure. The following
    build file adds the TestNG library as the `testCompile` dependency and in the
    test closure, we added a `testng.xml` file to execute the test cases. In this
    section, we will briefly discuss the use of `testng.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: However, you can read more about TestNG configuration at [http://testng.org/doc/documentation-main.html](http://testng.org/doc/documentation-main.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have created three test cases named as `verifyMapSize`,
    `verifyMapNotNull`, and `addEvenNumbers`. These test cases are grouped as `Smoke`
    and `Integration` test cases. If you execute a Gradle test command, all the three
    test cases will be executed and the test report will be created in the `build/reports/tests`
    directory. The look and feel of the report is similar to the JUnit report that
    we saw earlier. The actual TestNG report is created in the `test-output/` directory
    in the project home directory. Both JUnit and TestNG generate their own different
    report formats, but Gradle reconciles them into a standard look and feel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A TestNG test case can be executed from a command line, Ant file, Gradle script,
    Eclipse plugin, or a TestNG test suite file. TestNG suite files provide a flexible
    mechanism control for the test execution. In a test suite file, you can define
    test classes, tests, test group names, listener information, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We have created a sample `testng.xml` file in the `src/test/resource` folder.
    The file has some important information. The **listener configuration** to create
    a report format, a **test group** declaration as `Smoke`, and a test class named
    `com.packtpub.ge.ch7.HashTest`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gradle doesn''t force you to put `testng.xml` in the `src/test/resources`,
    and we''re just doing this as a means to keep it organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have only included test cases that are marked as `Smoke`, the TestNG
    invoked only two test cases, `verifyMapNotNull` and `addEvenNumbers`, when we
    executed the `gradle test` command. The following figure shows the TestNG report
    that is created in the `<Project_Home>/ test-output/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing with TestNG](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing is one of the key step in software development life cycle. It is
    one of the first checks to verify the code quality. Most of the basic functionalities
    can be tested with unit test cases. They are quick and take little time to execute.
    We discussed both JUnit framework and TestNG framework to unit test the code.
    The next step in the quality check process is integration testing. As by general
    definition of unit testing, you divide your code into small units and test them
    independently, which is good when you are developing your code independently.
    Once you commit the code and integrate the code with other developers, you need
    another level of testing, which is known as integration testing. It verifies the
    communication between different components working together as expected or not.
    Your test reports might give 100 percent success results in unit testing, but
    unless and until you perform integration testing, you cannot be assured of the
    functionality of the software as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen Gradle support for unit testing and how Gradle provides
    conventions to write your test classes in different directory structures and tasks
    to execute the test cases. Gradle does not differentiate between unit testing
    and integration testing, if we talk in terms of the convention it provides. To
    enable integration testing along with unit testing in Gradle, you need to customize
    the Gradle to enable both. Consider the following hierarchy for your project source
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is the standard folder structure you create for your source and test code.
    You create `src/test/java` to store your unit test cases. Now, if you want to
    add integration test cases to your project, you can merge the integration test
    cases in the same directory structure; however, this would not be a good design—since
    you might want to execute the unit test case each time you build your project
    and might want to execute the integration test biweekly or weekly—as it might
    consume more time depending on the project complexity and size. Thus, rather than
    merging the integration tests to your unit test cases' directory structure, we
    recommend you to create a separate directory structure, `src/integrationTest/java`,
    for integration test cases, and you can configure the same in your Gradle build
    scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following will be the updated directory structure to store the integration
    test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have created the directory structure, you need to configure this in
    your Gradle build script. The updated build script would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have added one extra configuration, `integrationTest`, to add the integration
    test cases. To execute the integration tests, we have also defined one task, `runIntegrationTest`,
    which is of type `Test` and configured the `testClassesDir` and classpath attributes.
    Once we have added additional `sourceSets` to the build script, the `java` plugin
    automatically adds two new dependency configurations to your build script `integrationTestCompile`
    and `integrationTestRuntime`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command to check for the current dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `integrationTestCompile` can be used to configure dependencies required
    to compile the test cases and `integrationTestRuntime` can be used to configure
    dependencies required to execute the test cases. As you can see, no dependencies
    are explicitly configured for integration test cases. You can configure them under
    dependencies closure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We do not want to execute the integration tests each time we build the project.
    Thus, to execute the integration test, you need to explicitly execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This will invoke the `runIntegrationTest` task and will execute the integration
    test cases. If you want to execute these test cases each time you build your code,
    you can link this task with other tasks using `dependsOn` or any other dependency
    attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are so many coverage tools available for source code analysis such as
    EMMA, Corbatura, JaCoCo, and so on. In this section, we'll cover Gradle integration
    with JaCoCo to find the source code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Before we get started, we need to understand what code coverage is and why it
    is important in the test-driven development.
  prefs: []
  type: TYPE_NORMAL
- en: Code coverage is a metric that we can use to check how much of the source code
    was tested. Higher code coverage means a greater percentage of our code has been
    tested. Code coverage is typically done in the unit testing cycle. During code
    coverage, a developer must ensure that different logical paths in the source code
    have been tested and verified to achieve better code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Here, it is important to understand that the code coverage is not directly related
    to code quality. High code coverage does not guarantee that the quality code has
    been written. A developer must use static code analysis tools such as PMD ([https://pmd.github.io/](https://pmd.github.io/))
    to find the quality of the code. Another point to remember is that, even with
    100 percent of code coverage, there is no guarantee that a complete bug-free code
    has been written. Thus, many developers argue that this not a right metric to
    be considered for the code quality or unit test. However, 70-80 percent code coverage
    is considered to be a good number for healthy code coverage.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Gradle, the code coverage tool, JaCoCo, can be applied to a project like
    any other plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `build.gradle` file has the following content. We have created a few TestNG
    test cases to test the functionalities of the source code. We have also configured
    a test task to be dependent on the `jacocoTestReport` task. This is to make sure
    that test cases are executed before running and creating the test coverage reports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the report will be created in the `<build dir>/reports/jacoco/test/html
    directory` and an HTML report file will be generated. For example, we have created
    a simple POJO `User.java` file with the getter and setter methods. Also, we have
    created a few unit test cases to verify the functionalities. The two sample test
    cases are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can execute the `jacocoTestReport` task to generate the code coverage
    report:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the coverage report, you can observe that all the methods of the Java class
    were tested unit tests. You can further drill down following the links in the
    report that shows the line coverage on the source code. The source code is marked
    in green and red to display what is covered and what is not tested. The following
    figure (*Figure 7.2*) shows the code coverage statistics for the `User.java` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code coverage](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, an HTML report file is generated in the `build/reports/jacoco/test/html`
    directory. Also, the default version of the `jacoco` plugin can be modified by
    modifying the `jacoco` extension as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the report can be customized by configuring the `jacocoTestReport`
    task as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Code analysis reports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sonar is one of the most popular quality management tools that gives a complete
    analysis of a project in terms of lines of code, documentation, test coverage,
    issues, and complexities. As a developer, we are mainly interested in the following
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate lines of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lacking comments in the source code, especially in public APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not following coding standards and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding code complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code coverage produced by unit tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we will discuss Gradle integration with Sonar. The only prerequisite
    is, the Sonar server should be installed and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'A prerequisite to run Sonar is to have Java installed on the box. Once prerequisites
    are met, you can install Sonar in just three simple steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the distribution from [http://www.sonarqube.org/downloads/](http://www.sonarqube.org/downloads/)
    and unzip it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open a console and start the Sonar server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On Windows platforms, start `$SONAR_HOME\bin\windows-x86-32\StartSonar.bat`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On other platforms, start `$SONAR_HOME/bin/[OS]/sonar.sh`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to `http://localhost:9000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To run `sonar-runner` plugin, we just need to apply the plugin `sonar-runner`
    and configure it to connect to the Sonar server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the build file `build.gradle` for your project with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The above configuration is self-explanatory. You need to add configurations
    such as Sonar URL, DB URL, and JDBC driver details, and our build file is ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to run the `sonarRunner` task for code analysis. After successful
    execution of this task, you will find the report hosted on the Sonar server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can open `http://localhost:9000/` to browse the projects. This page
    is the default dashboard page, which shows the details of all the projects. You
    can find your project and browse through the details. The details will be displayed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code analysis reports](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3
  prefs: []
  type: TYPE_NORMAL
- en: 'You can again further verify the details of each metric, just by following
    the links provided in the project home page. For example, the following figure
    displays the source code-related metrics in the Sonar. It provides details such
    as code complexity, lines of code, methods, documentation, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code analysis reports](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more on Sonar at [http://docs.sonarqube.org/display/SONAR/Documentation/](http://docs.sonarqube.org/display/SONAR/Documentation/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the testing and reporting aspects of Gradle. We
    started our discussion with TestNG and also discussed how we can configure Gradle
    to support the integration test cases separate from unit test cases. Then, we
    discussed code coverage with JaCoCo and, finally, we talked about Sonar integration
    with Gradle.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how to organize the build logic in build
    scripts and plugins. We'll explore how to modularize plugin code so that it can
    be shared across multi-project Gradle build. We'll also explore how to create
    a custom plugin in Gradle.
  prefs: []
  type: TYPE_NORMAL
