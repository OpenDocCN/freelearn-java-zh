<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Publishing Artifacts" id="aid-SJGS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Publishing Artifacts</h1></div></div></div><p>In the previous chapters, we learned how to define and use dependencies in our projects. However, the code we write in our projects can also be a dependency for another project. In order for another project to use our code as a dependency, we should publish our code as a dependency artifact so that it can be used by other projects.</p><p>In this chapter, you will learn how you can define artifacts in your project. These artifacts need to be published for others to use them. We first publish them using a filesystem, so the artifacts can be used from the same computer or even if we use a network share on an intranet. In later chapters, we will see how to publish our artifacts to a Maven repository, an Ivy repository, and Bintray.</p><div class="section" title="Defining artifact configurations"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Defining artifact configurations</h1></div></div></div><p>A Gradle project can <a id="id151" class="indexterm"/>contain artifacts we want to publish. An artifact can be a ZIP or JAR archive file or any other file. We can define one or more artifacts in one project. Thus, we don't have to create two different projects if we want to have two different artifacts from the same source tree.</p><p>In Gradle, we group artifacts using configurations. We used configurations to define dependencies for our project, but now we will use the configurations to group our artifacts that can be dependencies for others. So a configuration can contain both dependencies and artifacts. If we apply the Java plugin to our project, we get a configuration named <code class="literal">archives</code>, that contains the default JAR artifact for the project.</p><p>In the following example Gradle build file, we use the Java plugin. We add a task to display the filename of the artifact that belongs to the <code class="literal">archives</code> configuration. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

// Set the archivesBaseName property,
// to change the name of the
// default project artifact.
archivesBaseName = 'java_lib'

task artifactsInfo &lt;&lt; {
  // Find archives configuration
  // and display file name(s)
  // for artifacts belonging
  // to the configuration.
  configurations
    .findByName('archives')
    .allArtifacts
    .each { artifact -&gt;
      println artifact.file.name
    }
}</pre></div><p>When we run the <code class="literal">artifactsInfo</code> task from the command line, we see the <code class="literal">java_lib.jar</code> filename in the output. The following code shows this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle artifactsInfo</strong></span>
<span class="strong"><strong>:artifactsInfo</strong></span>
<span class="strong"><strong>java_lib.jar</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 1.088 secs</strong></span>
</pre></div><p>For each configuration in our project, Gradle adds two tasks to the project: <code class="literal">build&lt;ConfigurationName&gt;</code> and <code class="literal">upload&lt;ConfigurationName&gt;</code>. The <code class="literal">build&lt;ConfigurationName&gt;</code> task creates the artifacts for the given configuration name. The <code class="literal">upload&lt;ConfigurationName&gt;</code> task creates and uploads the artifacts for the given configuration name. The <code class="literal">upload&lt;ConfigurationName&gt;</code> task needs extra configuration to know where to upload the artifacts. We will see later in this chapter how to configure the task.</p><p>In our example project, we <a id="id152" class="indexterm"/>have the <code class="literal">buildArchives</code> and <code class="literal">uploadArchives</code> tasks. Let's run the <code class="literal">buildArchives</code> task for our example project and see which tasks are executed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle buildArchives</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:processResources</strong></span>
<span class="strong"><strong>:classes</strong></span>
<span class="strong"><strong>:jar</strong></span>
<span class="strong"><strong>:buildArchives</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 1.209 secs</strong></span>
<span class="strong"><strong>$ ls build/libs</strong></span>
<span class="strong"><strong>java_lib.jar</strong></span>
</pre></div><p>Here, we can see that first everything is prepared in our Java project to create the JAR artifact. The JAR artifact is then added to the <code class="literal">artifacts</code> configuration. The <code class="literal">java_lib.jar</code> JAR file that is created can be found in the <code class="literal">build/libs</code> directory.</p><p>If we set the <code class="literal">version</code> property for our project, then it will be used in the name of our created artifact. In the next <a id="id153" class="indexterm"/>example build file, we will set the <code class="literal">version</code> property and look at the name that is created for the artifact:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

archivesBaseName = 'java_lib'

// Set project version,
// which is then used in the 
// artifact name.
version = '2.3'

task artifactsInfo &lt;&lt; {
configurations
    .findByName('archives')
    .allArtifacts
    .each { artifact -&gt;
      println artifact.file.name
    }
}</pre></div><p>Let's run the <code class="literal">artifactsInfo</code> task to see the name of our artifact:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle artifactsInfo</strong></span>
<span class="strong"><strong>:artifactsInfo</strong></span>
<span class="strong"><strong>java_lib-2.3.jar</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 2.831 secs</strong></span>
</pre></div></div></div>
<div class="section" title="Defining artifacts" id="aid-TI1E1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Defining artifacts</h1></div></div></div><p>In the previous section, you <a id="id154" class="indexterm"/>learned that the Java plugin adds an <code class="literal">archives</code> configuration that is used to group artifacts from the project. Just as we created configurations for dependencies in our project, we can also create our own configurations for its artifacts. To assign an archive or file to this configuration, we must use the <code class="literal">artifacts</code> configuration block in our build script. Inside the configuration closure, we use the name of the configuration followed by the artifact. We can also further customize the artifact definition inside the <code class="literal">artifacts</code> block.</p><p>We can define artifacts <a id="id155" class="indexterm"/>with the following three types:</p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><thead><tr><th valign="bottom">
<p>Type</p>
</th><th valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<code class="literal">AbstractArchiveTask</code>
</p>
</td><td valign="top">
<p>The <a id="id156" class="indexterm"/>information for the artifact is extracted from the archive task. The artifact is an instance of <code class="literal">PublishArtifact</code> in the <code class="literal">org.gradle.api.artifact</code>
<code class="literal">s</code> package.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">File</code>
</p>
</td><td valign="top">
<p>The <a id="id157" class="indexterm"/>information for the artifact is extracted from the filename. The artifact is an instance of <code class="literal">ConfigurablePublishArtifact</code> that extends <code class="literal">PublishArtifact</code>.</p>
</td></tr><tr><td valign="top">
<p>
<code class="literal">Map</code>
</p>
</td><td valign="top">
<p>This is <a id="id158" class="indexterm"/>another way to define a file artifact. The map must contain a <code class="literal">file</code> key, and other properties are used to further configure the artifact.</p>
</td></tr></tbody></table></div><div class="section" title="Using the archive task"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Using the archive task</h2></div></div></div><p>In the next example <a id="id159" class="indexterm"/>build file, we will use an archive task to define the artifacts for the project. It is important to remember to apply the Gradle base plugin to the project <a id="id160" class="indexterm"/>because the base plugin adds the task rules for <code class="literal">build&lt;ConfigurationName&gt;</code> and <code class="literal">upload&lt;ConfigurationName&gt;</code>. The following code shows this:</p><div class="informalexample"><pre class="programlisting">// The base plugin adds the
// build&lt;ConfigurationName&gt; and
// upload&lt;ConfigurationName&gt; tasks
// to our project.
apply plugin: 'base'

// Add archive task that will
// create a ZIP file with some
// contents we want to be published.
task manual(type: Zip) {
  baseName = 'manual'

  from 'src/manual'
}

// Create a new artifacts configuration
// with the name manualDistribution.
configurations {
  manualDistribution
}

// Use the manual archive task
// to define the artifact for the
// manualDistribution configuration.
// Syntax:
// configurationName archiveTask
artifacts {
  manualDistribution manual
}</pre></div><p>When we use an archive task to define the artifact for a configuration, Gradle also adds a task dependency for the artifact. This means that, if we invoke the <code class="literal">buildManualDistribution</code> task, Gradle also invokes the <code class="literal">manual</code> task that generates the archive for the <a id="id161" class="indexterm"/>artifact configuration. We see this when we execute the task <a id="id162" class="indexterm"/>from the command line. The following command shows this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle buildManualDistribution</strong></span>
<span class="strong"><strong>:manual</strong></span>
<span class="strong"><strong>:buildManualDistribution</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 1.368 s</strong></span>
<span class="strong"><strong>ecs</strong></span>
</pre></div></div><div class="section" title="Using artifact files"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Using artifact files</h2></div></div></div><p>Besides archive tasks, we <a id="id163" class="indexterm"/>can use a file as an artifact. Gradle will use the properties of the file to define the artifact name, type, and extension. In the following example build file, we use a file as an artifact:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'base'

configurations {
  readmeDistribution
}

artifacts {
  // Use a file as artifact.
  // Name and extension are extracted
  // from the actual file.
  readmeDistribution file('src/files/README.txt')
}</pre></div><p>We can add an extra configuration closure when we use the file artifact notation. In the closure, we can set the name, type, extension, and classifier attributes. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'base'

configurations {
  readmeDistribution
}

artifacts {
  // Define file artifact, but we also
  // customize the file artifact
  // name, extension and classifier.
  readmeDistribution file('src/files/README.txt'), {
    name 'PLEASE_READ_THIS'
    extension ''
    classifier 'docs'
  }
}</pre></div><p>One interesting method we can use in the file artifact configuration closure is the <code class="literal">builtBy</code> method. This method accepts one or more task names that are responsible for building the artifact. If we <a id="id164" class="indexterm"/>use this method, Gradle can determine the tasks that need to be executed when we run the <code class="literal">build&lt;ConfigurationName&gt;</code> or <code class="literal">upload&lt;ConfigurationName&gt;</code> task.</p><p>We will use the <code class="literal">builtBy</code> method in the next example build file:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'base'

configurations {
  readmeDistribution
}

// New task that copies
// a file to the build directory.
task docFiles(type:Copy) {
  from 'src/files'
  into "${buildDir}/docs"
  include 'README.txt'
}

artifacts {
  // Define file artifact.
  readmeDistribution(file("${buildDir}/docs/README.txt")) {
    // Define which task is responsible
    // for creating the file, so a
    // task dependency is added for
    // the buildReadmeDistribution and
    // uploadReadmeDistribution tasks.
    builtBy docFiles
  }
}</pre></div><p>To ensure that the <code class="literal">docFiles</code> task is added as a task dependency, we run the <code class="literal">buildReadmeDistribution</code> from the command line. The following command shows this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle buildReadmeDistribution</strong></span>
<span class="strong"><strong>:docFiles</strong></span>
<span class="strong"><strong>:buildReadmeDistribution</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 0.864 secs</strong></span>
</pre></div><p>Finally, we can use a map <a id="id165" class="indexterm"/>notation when we define a file artifact. We use the <code class="literal">file</code> attribute to define the file. We can also use the <code class="literal">name</code>, <code class="literal">extension</code>, <code class="literal">type</code>, <code class="literal">classifier</code>, and <code class="literal">builtBy</code> keys for the definition. In the following example build file, we use the map notation:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'base'

configurations {
  readmeDistribution
}

task docFiles(type:Copy) {
  from 'src/files'
  into "${buildDir}/docs"
  include 'README.txt'
}

artifacts {
  // Define file artifact.
  readmeDistribution(
    file: "${buildDir}/docs/README.txt",
    name: 'DO_READ',
    extension: 'me',
    type: 'text',
    classifier: 'docs'
    builtBy: docFiles
  )
}</pre></div></div></div>
<div class="section" title="Creating artifacts" id="aid-UGI01"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Creating artifacts</h1></div></div></div><p>We saw how to define <a id="id166" class="indexterm"/>artifacts, but we also need to create artifacts in our build files. We can either use an archive task to create the artifact or a file can be an artifact. Most of the time, when we use Gradle in a Java project, we build an archive with compiled classes and resources. Actually, the Java plugin adds a <code class="literal">jar</code> task to our project that will just do that. The JAR file created is then added to the <code class="literal">archives</code> configuration.</p><p>In the next example build file, we will use the Java plugin and simply rely on the default artifact configuration and tasks. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

// Define project properties.
group = 'com.mrhaki.sample'
version = '2.1'
archivesBaseName = 'sample'

// Extra task to check the artifacts.
task artifactsInfo &lt;&lt; {
  configurations
    .findByName('archives')
    .allArtifacts
    .each { artifact -&gt;
      println artifact.file.name
    }
}</pre></div><p>We can now run the <code class="literal">buildArchives</code> task and check the artifacts with the <code class="literal">artifactsInfo</code> task from the command line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle buildArchives artifactsInfo</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:processResources</strong></span>
<span class="strong"><strong>:classes</strong></span>
<span class="strong"><strong>:jar</strong></span>
<span class="strong"><strong>:buildArchives</strong></span>
<span class="strong"><strong>:artifactsInfo</strong></span>
<span class="strong"><strong>sample-2.1.jar</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 7.643 secs</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>In this case, we have a single artifact; however, in the same project we can have more than one artifact when we use Gradle. For example, we might want to have our source packaged into a JAR file and our generated documentation as well. Both JAR files should be part of the <code class="literal">archives</code> configuration so that, when we execute the <code class="literal">buildArchives</code> task, all the tasks necessary to create these <a id="id167" class="indexterm"/>JAR files are executed.</p><p>We extend our previous example build file, add the code to create two extra JAR files, and add them to the <code class="literal">archives</code> artifact configuration. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

// Define project properties.
group = 'com.mrhaki.sample'
version = '2.1'
archivesBaseName = 'sample'

// Create a JAR file with the
// Java source files.
task sourcesJar(type: Jar) {
  classifier = 'sources'

  from sourceSets.main.allJava
}

// Create a JAR file with the output
// of the javadoc task.
task javadocJar(type: Jar) {
  classifier = 'javadoc'

  from javadoc
}

artifacts {
  // Add the new archive tasks
  // to the artifacts configuration.
  archives sourcesJar, javadocJar
}

// Extra task to check the artifacts.
task artifactsInfo &lt;&lt; {
  configurations
    .findByName('archives')
    .allArtifacts
    .each { artifact -&gt;
      println artifact.file.name
    }
}</pre></div><p>We will now execute the <code class="literal">buildArchives</code> and <code class="literal">artifactsInfo</code> tasks. We see in the output that our two new tasks, <code class="literal">sourcesJar</code> and <code class="literal">javadocJar</code>, are executed. And the generated artifact files are <code class="literal">sample-2.1.jar</code>, <code class="literal">sample-2.1-sources.jar</code>, and <code class="literal">sample-2.1-javadoc.jar</code>. The <a id="id168" class="indexterm"/>following command shows this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle buildArchives artifactsInfo</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:processResources</strong></span>
<span class="strong"><strong>:classes</strong></span>
<span class="strong"><strong>:jar</strong></span>
<span class="strong"><strong>:javadoc</strong></span>
<span class="strong"><strong>:javadocJar</strong></span>
<span class="strong"><strong>:sourcesJar</strong></span>
<span class="strong"><strong>:buildArchives</strong></span>
<span class="strong"><strong>:artifactsInfo</strong></span>
<span class="strong"><strong>sample-2.1.jar</strong></span>
<span class="strong"><strong>sample-2.1-sources.jar</strong></span>
<span class="strong"><strong>sample-2.1-javadoc.jar</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 2.945 secs</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>In the preceding example, we have a Java project and, from the same source set, we want to create two different archive files. The source set contains a few API classes and implementation classes. We want to have a JAR file with the API classes and a JAR file, along with the implementation classes. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

// Define project properties.
group = 'com.mrhaki.sample'
version = '2.1'
archivesBaseName = 'sample'

// We create a new source set
// api, which contains the
// Java sources. This means
// Gradle will search for the
// directory src/api/java.
sourceSets {
  api
}

task apiJar(type: Jar) {
  appendix = 'api'

  // We use the output of the
  // compilation of the api
  // source set, to be the
  // contents of this JAR file.
  from sourceSets.api.output
}

artifacts {
  // Assign apiJar archive task to the
  // archives configuration.
  archives apiJar
}

// Extra task to check the artifacts.
task artifactsInfo &lt;&lt; {
  configurations
    .findByName('archives')
    .allArtifacts
    .each { artifact -&gt;
      println artifact.file.name
    }
}</pre></div><p>We will now run the <code class="literal">buildArchives</code> task and see that all the tasks necessary to create the JAR file with the <a id="id169" class="indexterm"/>classes from the <code class="literal">api</code> source set are executed:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle buildArchives artifactsInfo</strong></span>
<span class="strong"><strong>:compileApiJava</strong></span>
<span class="strong"><strong>:processApiResources</strong></span>
<span class="strong"><strong>:apiClasses</strong></span>
<span class="strong"><strong>:apiJar</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:processResources</strong></span>
<span class="strong"><strong>:classes</strong></span>
<span class="strong"><strong>:jar</strong></span>
<span class="strong"><strong>:buildArchives</strong></span>
<span class="strong"><strong>:artifactsInfo</strong></span>
<span class="strong"><strong>sample-2.1.jar</strong></span>
<span class="strong"><strong>sample-api-2.1.jar</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 2.</strong></span>
<span class="strong"><strong>095 secs</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div></div>
<div class="section" title="Publishing artifacts to the local directory" id="aid-VF2I1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Publishing artifacts to the local directory</h1></div></div></div><p>We now know how to <a id="id170" class="indexterm"/>create one or more artifacts and how to use artifact configurations to group them. In this section, we will see how we can copy our artifacts to a local directory or network share. Remember that, for each artifact's configuration, Gradle adds a <code class="literal">build&lt;ConfigurationName&gt;</code> task and an <code class="literal">upload&lt;ConfigurationName&gt;</code> task. Now it is time to learn more about the <code class="literal">upload&lt;ConfigurationName&gt;</code> task so that we can copy our artifacts. In the following chapters we will also <a id="id171" class="indexterm"/>learn how to deploy to a Maven repository, an Ivy repository, and to Bintray.</p><p>For each <code class="literal">upload&lt;ConfigurationName&gt;</code> task, we must configure a repository definition. The repository definition is basically the destination of our artifacts when we upload or publish them. In this section, we use a local directory, so we define a repository using the <code class="literal">flatDir</code> method. We specify a name and the directory so that Gradle knows where the output of the <code class="literal">upload&lt;ConfigurationName&gt;</code> task needs to go. In Gradle projects where we have applied the Java plugin, we already have the <code class="literal">archives</code> artifact configuration and the <code class="literal">uploadArchives</code> task. We must configure the <code class="literal">uploadArchives</code> task and define the repository that needs to be used. In the next example build file, we will use the <code class="literal">lib-repo</code> local directory as the repository directory:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

// Define project properties.
group = 'com.mrhaki.sample'
version = '2.1'
archivesBaseName = 'sample'

// Configure the uploadArchives task.
uploadArchives {
  // Define a local directory as the
  // upload repository. The artifacts
  // must be 'published' in this
  // directory.
  repositories {
    flatDir(
      name: 'upload-repository',
      dirs: "${projectDir}/lib-repo")
  }
}</pre></div><p>Let's see the output <a id="id172" class="indexterm"/>when we execute the <code class="literal">uploadArchives</code> task and check the files in the <code class="literal">lib-repo</code> directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle uploadArchives</strong></span>
<span class="strong"><strong>:compileJava UP-TO-DATE</strong></span>
<span class="strong"><strong>:processResources UP-TO-DATE</strong></span>
<span class="strong"><strong>:classes UP-TO-DATE</strong></span>
<span class="strong"><strong>:jar UP-TO-DATE</strong></span>
<span class="strong"><strong>:uploadArchives</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 3.424 secs</strong></span>
<span class="strong"><strong>$ ls -1 lib-repo</strong></span>
<span class="strong"><strong>ivy-2.1.xml</strong></span>
<span class="strong"><strong>ivy-2.1.xml.sha1</strong></span>
<span class="strong"><strong>sample-2.1.jar</strong></span>
<span class="strong"><strong>sample-2.1.jar.sha1</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>In our <code class="literal">lib-repo</code> directory, for our artifact, we have an Ivy descriptor file named <code class="literal">ivy-2.1.xml</code> and, for this descriptor file, a checksum file named <code class="literal">ivy-2.1.xml.sha1</code>. Also, we see our <code class="literal">sample-2.1.jar</code> artifact and the <code class="literal">sample-2.1.jar.sha1</code> checksum file for our artifact. The Ivy <a id="id173" class="indexterm"/>descriptor file contains basic information about our artifact. This is shown by the following code:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ivy-module version="2.0" &gt;
  &lt;info organisation="com.mrhaki.sample" module="java" revision="2.1" status="integration" publication="20141126060840"&gt;
    &lt;description/&gt;
  &lt;/info&gt;
  &lt;configurations&gt;
    &lt;conf name="archives" visibility="public" description="Configuration for archive artifacts."/&gt;
    &lt;conf name="compile" visibility="private" description="Compile classpath for source set 'main'."/&gt;
    &lt;conf name="default" visibility="public" description="Configuration for default artifacts." extends="runtime"/&gt;
    &lt;conf name="runtime" visibility="private" description="Runtime classpath for source set 'main'." extends="compile"/&gt;
    &lt;conf name="testCompile" visibility="private" description="Compile classpath for source set 'test'." extends="compile"/&gt;
    &lt;conf name="testRuntime" visibility="private" description="Runtime classpath for source set 'test'." extends="runtime,testCompile"/&gt;
  &lt;/configurations&gt;
  &lt;publications&gt;
    &lt;artifact name="sample" type="jar" ext="jar" conf="archives,runtime"/&gt;
  &lt;/publications&gt;
&lt;/ivy-module&gt;</pre></div><p>We have configured the repository inside the <code class="literal">uploadArchives</code> task configuration. However, we can also refer to an existing repository definition that was configured in our project using the <code class="literal">repositories</code> configuration block. This is a good practice because we only have to define the <a id="id174" class="indexterm"/>repository once and can reuse it in multiple tasks in our build files. Let's rewrite our previous example build file, define the <a id="id175" class="indexterm"/>repository in a <code class="literal">repositories</code> configuration block, and refer to it from the <code class="literal">uploadArchives</code> task. The following code shows this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

// Define project properties.
group = 'com.mrhaki.sample'
version = '2.1'
archivesBaseName = 'sample'

// Define upload repository.
repositories {
  flatDir(
    name: 'upload-repository',
    dirs: "${projectDir}/repo")
}


// Configure the uploadArchives task.
uploadArchives {
  // Refer to repository with the
  // name 'upload-repository' as the
  // repository for uploading artifacts.
  repositories.add(
    project.repositories.'upload-repository')
}</pre></div><div class="section" title="Excluding the descriptor file"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Excluding the descriptor file</h2></div></div></div><p>By default, an Ivy <a id="id176" class="indexterm"/>descriptor file is added to the upload location. If we don't want it, we can set the <code class="literal">uploadDescriptor</code> property for the <code class="literal">Upload</code> task.</p><p>In the following example build file, we set the <code class="literal">uploadDescriptor</code> property to <code class="literal">false</code> in the <code class="literal">uploadArchives</code> task:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

// Define project properties.
group = 'com.mrhaki.sample'
version = '2.1'
archivesBaseName = 'sample'

// Define upload repository.
repositories {
  flatDir(
    name: 'upload-repository',
    dirs: "${projectDir}/lib-repo")
}

uploadArchives {
  // Exclude the descriptor file.
  uploadDescriptor = false

  repositories.add(
    project.repositories.'upload-repository')
}</pre></div><p>When we execute the task and <a id="id177" class="indexterm"/>look at the files in the <code class="literal">lib-repo</code> directory, we see that the descriptor file is not added. The following code shows this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle uploadArchives</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:processResources</strong></span>
<span class="strong"><strong>:classes</strong></span>
<span class="strong"><strong>:jar</strong></span>
<span class="strong"><strong>:uploadArchives</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 1.463 secs</strong></span>
<span class="strong"><strong>$ ls -1 lib-repo</strong></span>
<span class="strong"><strong>sample-2.1.jar</strong></span>
<span class="strong"><strong>sam</strong></span>
<span class="strong"><strong>ple-2.1.jar.sha1</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div></div></div>
<div class="section" title="Signing artifacts" id="aid-10DJ41"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Signing artifacts</h1></div></div></div><p>We can digitally sign <a id="id178" class="indexterm"/>artifacts in Gradle with the signing plugin. The plugin supports generating <span class="strong"><strong>Pretty Good Privacy</strong></span> (<span class="strong"><strong>PGP</strong></span>) signatures. This signature format <a id="id179" class="indexterm"/>is also required for publication to Maven Central Repository. To create a PGP signature, we must install a few PGP tools on our computer. Installation of the tools is different for each operating system. On Unix-like systems, the software is probably available via a package manager. With the PGP software, we need to create a key pair that we can use to sign artifacts.</p><p>To sign artifacts, we must apply the signing plugin to our project. Then we must configure the plugin using a <code class="literal">signing</code> configuration block. We need to at least add information about our PGP key pair. We need the hexadecimal representation of the public key, the path to the secret key ring file with our private key, and the passphrase used to protect the private key. We assign this information to the <code class="literal">keyId</code>, <code class="literal">secretKeyRingFile</code>, and <code class="literal">password</code> properties of the signing plugin configuration. These values shouldn't be part of the Gradle build file because they are secret, so it is better to store them in a <code class="literal">gradle.properties</code> file and apply secure file permissions to the file. Also, we do not add this file to our version control system.</p><p>In the following example <code class="literal">gradle.properties</code> file, we set the properties. The values are sample values and are different for each user:</p><div class="informalexample"><pre class="programlisting">signing.keyId = 8B00165A
signing.secretKeyRingFile = /Users/current/.gnupg/secring.gpg
signing.password = secret</pre></div><div class="section" title="Using configurations to sign"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Using configurations to sign</h2></div></div></div><p>We are ready to sign <a id="id180" class="indexterm"/>our artifacts. We need to configure which artifacts we want to be signed using the <code class="literal">signing</code> configuration block. We must specify the name of the artifact configuration that contains the artifacts to be signed.</p><p>When we apply the Java plugin to our project, we get the <code class="literal">archives</code> artifact configuration. We want to sign the artifacts assigned to this configuration. In the next example build file, we apply both the Java and signing plugins. In the <code class="literal">signing</code> configuration block, we define that we want to sign the artifacts belonging to the <code class="literal">archives</code> configuration:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'signing'

group = 'com.mrhaki.sample'
version = '2.1'
archivesBaseName = 'sample'

// Configure signing plugin.
signing {
  // Define that we want to
  // sign the artifacts belonging
  // to the archives configuration.
  sign configurations.archives
}

uploadArchives {
  repositories {
    flatDir(
      name: 'local-repo',
      dirs: "${projectDir}/repo")
  }
}</pre></div><p>The signing plugin also adds a new task rule to our project—<code class="literal">sign&lt;ConfigurationName&gt;</code>. The name of the configuration is what we define in the <code class="literal">signing</code> configuration block. We defined the <code class="literal">archives</code> configuration so, in our project, we can now execute the <a id="id181" class="indexterm"/>
<code class="literal">signArchives</code> task. The task is also added as a task dependency to the assemble task; thus, every time we invoke the <code class="literal">assemble</code> task, Gradle makes sure the <code class="literal">signArchives</code> task is invoked as well.</p><p>Here, we run the <code class="literal">uploadArchives</code> task to see which files are put in the repository directory:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle uploadArchives</strong></span>
<span class="strong"><strong>:compileJava</strong></span>
<span class="strong"><strong>:processResources</strong></span>
<span class="strong"><strong>:classes</strong></span>
<span class="strong"><strong>:jar</strong></span>
<span class="strong"><strong>:signArchives</strong></span>
<span class="strong"><strong>:uploadArchives</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 4.305 secs</strong></span>
<span class="strong"><strong>$ ls -1 repo</strong></span>
<span class="strong"><strong>ivy-2.1.xml</strong></span>
<span class="strong"><strong>ivy-2.1.xml.sha1</strong></span>
<span class="strong"><strong>sample-2.1.asc</strong></span>
<span class="strong"><strong>sample-2.1.asc.sha1</strong></span>
<span class="strong"><strong>sample-2.1.jar</strong></span>
<span class="strong"><strong>sample-2.1.jar.sha1</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div><p>We notice that a signature file, <code class="literal">sample-2.1.asc</code>, is created together with the <code class="literal">sample-2.1.asc.sha1</code> checksum <a id="id182" class="indexterm"/>file for the signature file.</p></div><div class="section" title="Using archive tasks to sign"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Using archive tasks to sign</h2></div></div></div><p>To sign an artifact <a id="id183" class="indexterm"/>that is not part of an artifact configuration, we must configure the signing plugin differently. In the <code class="literal">signing</code> configuration block, we assigned a configuration in the previous section, but we can also use an archive task. The <a id="id184" class="indexterm"/>output of this archive task will be signed when we invoke the <code class="literal">sign&lt;TaskName&gt;</code> task rule.</p><p>In the next example build file, we will create a ZIP file with the <code class="literal">manualZip</code> task. We will configure the signing plugin for the <code class="literal">manualZip</code> task so that this ZIP file is signed:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'signing'

version = '1.0'

// New archive task to create
// a ZIP file from some files.
task manualZip(type: Zip) {
  archivesBaseName = 'manual'
  from 'src/docroot'
}

// Configure signing plugin to
// sign the output of the
// manualZip task.
signing {
  sign manualZip
}

// Create new configuration for
// ZIP and signed ZIP artifacts.
configurations {
  manualDistribution
}

// Set artifacts to manualDistribution
// configuration.
artifacts {
  manualDistribution(
    manualZip,
    signManualZip.singleSignature.file)
}

// Configure upload task for
// manualDistribution configuration.
uploadManualDistribution {
  repositories {
    flatDir {
      dirs "${projectDir}/repo"
    }
  }
}
// Add task dependency so signing of
// ZIP file is done before upload.
uploadManualDistribution.dependsOn signManualZip</pre></div><p>All <code class="literal">sign&lt;TaskName&gt;</code> tasks automatically have a task dependency on the archive task identifier by <code class="literal">&lt;TaskName&gt;</code>. So, we can now simply invoke the <code class="literal">uploadManualDistribution</code> task, and the ZIP file is created, signed, and uploaded to the <code class="literal">repo</code> directory. The <a id="id185" class="indexterm"/>following code shows <a id="id186" class="indexterm"/>this:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ gradle uploadManualDistribution</strong></span>
<span class="strong"><strong>:manualZip</strong></span>
<span class="strong"><strong>:signManualZip</strong></span>
<span class="strong"><strong>:uploadManualDistribution</strong></span>

<span class="strong"><strong>BUILD SUCCESSFUL</strong></span>

<span class="strong"><strong>Total time: 1.695 secs</strong></span>
<span class="strong"><strong>$ ls -1 repo</strong></span>
<span class="strong"><strong>ivy-1.0.xml</strong></span>
<span class="strong"><strong>ivy-1.0.xml.sha1</strong></span>
<span class="strong"><strong>manual-1.0.zip</strong></span>
<span class="strong"><strong>manual-1.0.zip-1.0.asc</strong></span>
<span class="strong"><strong>manual-1.0.zip-1.0.asc.sha1</strong></span>
<span class="strong"><strong>manual-1.0.zip.sha1</strong></span>
<span class="strong"><strong>$</strong></span>
</pre></div></div></div>
<div class="section" title="Summary" id="aid-11C3M1"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>In the previous chapters, you learned how to use external dependencies. In this chapter, you learned how you can define artifact configurations to assign your own artifacts. These artifacts can be dependencies for other developers on other projects and applications.</p><p>You also learned how to create a default artifact when you use the Java plugin. Next, we saw how to create more than one artifact from the same project.</p><p>You then learned how to configure an <code class="literal">Upload</code> task, so you can upload your artifacts to a local directory. This directory could also be a network share accessible to other development teams.</p><p>Finally, you learned how you can sign your artifacts using the signing plugin. This could be useful when you want to provide some extra confidence to people using the artifacts.</p><p>In the next chapters, you will see how you can upload your artifacts to a Maven repository, an Ivy repository, and Bintray.</p></div></body></html>