<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unification</h1>
                </header>
            
            <article>
                
<p class="mce-root">Being able to understand and write good code in Scala requires developers to be familiar with the different concepts of the language. In a few places so far, we have mentioned that Scala is really expressive. To some extent, this is because there are a number of programming concepts that have been unified. In this chapter, we will focus on the following concepts:</p>
<ul>
<li class="mce-root">Functions and classes</li>
<li class="mce-root">Algebraic data types and class hierarchies</li>
<li class="mce-root">Modules and objects</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions and classes</h1>
                </header>
            
            <article>
                
<p>In Scala, every value is an object. Functions are first-class values, which also makes them objects of their respective classes.</p>
<p>The following diagram shows the Scala unified type system and how this is achieved. It is adapted from <a href="http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png">http://www.scala-lang.org/old/sites/default/files/images/classhierarchy.png</a> and represents an up-to-date view of the model (some classes such as <kbd>ScalaObject</kbd> have disappeared, as we have already mentioned earlier):</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/f035b5ee-e98b-4ffa-ae47-5b3db49ddcc2.png" style="width:35.00em;height:22.67em;" width="1311" height="850"/></div>
<p>As you can see, Scala does not have the same concept of primitive types that Java has, and all types are ultimately subtypes of <strong>Any</strong>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions as classes</h1>
                </header>
            
            <article>
                
<p>The fact that functions are classes means that they can be freely passed to other methods or classes as if they were just values. This leads to improving the expressiveness of Scala and making it much easier to achieve things, such as callbacks, than in other languages such as Java.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function literals</h1>
                </header>
            
            <article>
                
<p>Let's have a look at an example:</p>
<pre>class FunctionLiterals {<br/>  val sum = (a: Int, b: Int) =&gt; a + b<br/>}<br/><br/>object FunctionLiterals {<br/><br/>  def main(args: Array[String]): Unit = {<br/>    val obj = new FunctionLiterals<br/>    System.out.println(s"3 + 9 = ${obj.sum(3, 9)}")<br/>  }<br/>}</pre>
<p>Here, we can see how the sum field of the <kbd>FunctionLiterals</kbd> class is actually assigned a function. We can assign any function to a variable and then call it as if it was a function (essentially invoking its <kbd>apply</kbd> method). Functions can also be passed as parameters to other methods. Let's add the following to our <kbd>FunctionLiterals</kbd> class:</p>
<pre>def runOperation(f: (Int, Int) =&gt; Int, a: Int, b: Int): Int = {<br/>  f(a, b)<br/>}</pre>
<p>We can then pass the required function to <kbd>runOperation</kbd>, as follows:</p>
<pre>obj.runOperation(obj.sum, 10, 20)<br/>obj.runOperation(Math.max, 10, 20)</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions without syntactic sugar</h1>
                </header>
            
            <article>
                
<p>In the preceding example, we just used syntactic sugar. In order to understand exactly what happens, we will show you what the function literals are converted into. They basically represent extensions to the <kbd>FunctionN</kbd> trait, where <kbd>N</kbd> is the number of parameters. The implementations of the literals are invoked using the <kbd>apply</kbd> method (whenever a class or an object has an <kbd>apply</kbd> method, it can be implicitly invoked just using parentheses after the object name or instance and passing the required parameters, if any). Let's see the equivalent implementation to our previous example:</p>
<pre>class SumFunction extends Function2[Int, Int, Int] {<br/>  override def apply(v1: Int, v2: Int): Int = v1 + v2<br/>}<br/><br/>class FunctionObjects {<br/>  val sum = new SumFunction<br/><br/>  def runOperation(f: (Int, Int) =&gt; Int, a: Int, b: Int): Int = f(a, b)<br/>}<br/><br/>object FunctionObjects {<br/><br/>  def main(args: Array[String]): Unit = {<br/>    val obj = new FunctionObjects<br/>    System.out.println(s"3 + 9 = ${obj.sum(3, 9)}")<br/>    System.out.println(s"Calling run operation: ${obj.<br/>    runOperation(obj.sum, 10, 20)}")<br/>    System.out.println(s"Using Math.max: ${obj.runOperation(Math.max,<br/>     10, 20)}")<br/>  }<br/>}</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Increased expressivity</h1>
                </header>
            
            <article>
                
<p>As you can see from the examples, unifying classes and functions leads to increased expressivity and we can easily achieve various things such as callbacks, lazy parameter evaluation, centralized exception handling, and others, and without writing extra code and logic. Moreover, functions as classes mean that we can extend them to provide extra functionality.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Algebraic data types and class hierarchies</h1>
                </header>
            
            <article>
                
<p><strong>Algebraic data types</strong> (<strong>ADTs</strong>) and class hierarchies are other unifications in the Scala programming language. In other functional languages, there are special ways to create custom algebraic data types. In Scala, this is achieved using class hierarchies and namely <em>case classes</em> and <em>objects</em>. Let's see what an ADT actually is, what types there are, and how to define them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">ADTs</h1>
                </header>
            
            <article>
                
<p>Algebraic data types are just composite types that combine other existing types or just represent some new ones. They only have data and do not contain any functionality on top of this data as normal classes would. Some examples can include the day of the week or a class that represents an RGB color—they have no extra functionality and they just carry information. The following few subsections will give a bit more insight on what ADTs are and what types are out there.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Sum ADTs</h1>
                </header>
            
            <article>
                
<p>Sum algebraic data types are the ones in which we can simply enumerate all the possible values of a type and provide a separate constructor for each value. As an example, let's consider the months of the year. There are only 12 and they cannot change (hopefully):</p>
<pre>sealed abstract trait Month<br/>case object January extends Month<br/>case object February extends Month<br/>case object March extends Month<br/>case object April extends Month<br/>case object May extends Month<br/>case object June extends Month<br/>case object July extends Month<br/>case object August extends Month<br/>case object September extends Month<br/>case object October extends Month<br/>case object November extends Month<br/>case object December extends Month<br/><br/>object MonthDemo {<br/>  def main(args: Array[String]): Unit = {<br/>    val month: Month = February<br/>    System.out.println(s"The current month is: $month")<br/>  }<br/>}</pre>
<p>Running this application will produce the following output:</p>
<pre><strong>The current month is: February</strong></pre>
<div class="mce-root packt_tip packt_infobox">The <kbd>Month</kbd> trait in the preceding code is sealed because we do not want it to be extended outside the current file. As you can see, we've defined the different months as objects, as there is no reason for them to be separate instances. The values are what they are and they do not change.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Product ADTs</h1>
                </header>
            
            <article>
                
<p>In product algebraic data types, we cannot enumerate all the possible values. There are usually too many to manually write them. We cannot provide a separate constructor for each separate value.</p>
<p>Let's think about colors. There are different color models, but one of the most famous ones is RGB. It combines the different values of the main colors (red, green, and blue) in order to represent other colors. If we say that each of these colors can have a value between <kbd>0</kbd> and <kbd>255</kbd>, this would mean that to represent all possibilities, we would need to have 256<sup>3</sup> different constructors. That's why we can use a product ADT:</p>
<pre>sealed case class RGB(red: Int, green: Int, blue: Int)<br/><br/>object RGBDemo {<br/>  def main(args: Array[String]): Unit = {<br/>    val magenta = RGB(255, 0, 255)<br/>    System.out.println(s"Magenta in RGB is: $magenta")<br/>  }<br/>}</pre>
<div class="packt_infobox">Now we can see that for the product ADTs, we have one constructor for different values.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Hybrid ADTs</h1>
                </header>
            
            <article>
                
<p>Hybrid algebraic data types represent a combination of the sum and product ones we described previously. This means that we can have specific value constructors, but these value constructors also provide parameters in order to wrap other types.</p>
<p>Let's see an example. Imagine we are writing a drawing application:</p>
<pre>sealed abstract trait Shape<br/>case class Circle(radius: Double) extends Shape<br/>case class Rectangle(height: Double, width: Double) extends Shape</pre>
<p>We have different shapes. The preceding example shows a sum ADT because we have the <span>specific </span><kbd>Circle</kbd> and <kbd>Rectangle</kbd> value constructors. Also, we have a product ADT because the constructors take extra parameters.</p>
<p>Let's expand our classes a bit. When drawing our shapes, we need to know their positions. This is why we can add a <kbd>Point</kbd> class that holds the <kbd>x</kbd> and <kbd>y</kbd> coordinates:</p>
<pre>case class Point(x: Double, y: Double)<br/><br/>sealed abstract trait Shape<br/>case class Circle(centre: Point, radius: Double) extends Shape<br/>case class Rectangle(topLeft: Point, height: Double, width: Double) extends Shape</pre>
<p>This should hopefully clarify what ADTs are in Scala and how they can be used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The unification</h1>
                </header>
            
            <article>
                
<p>After all of the preceding examples, it is obvious that class hierarchies and ADTs are unified and look like the same thing. This adds a high level of flexibility in the language and makes modeling easier than in other functional programming languages.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pattern matching</h1>
                </header>
            
            <article>
                
<p>Pattern matching is often used with ADTs. It makes the code much clearer and more readable as well as easier to extend in comparison to using the <kbd>if…else</kbd> statements when trying to do something with ADTs based on their values. As you could imagine, these statements can get quite cumbersome in some cases, especially when there are many different possible values for a certain data type. In some cases, pattern matching can be used the same way as <em>enums</em> and the <kbd>switch</kbd> statement is used in Java.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pattern matching with values</h1>
                </header>
            
            <article>
                
<p>In the month's example stated previously, we just have the month names. We might, however, want to also get their number, as the computer will not know this otherwise. Here is how to do this:</p>
<pre>object Month {<br/>  def toInt(month: Month): Int =<br/>    month match {<br/>      case January =&gt; 1<br/>      case February =&gt; 2<br/>      case March =&gt; 3<br/>      case April =&gt; 4<br/>      case May =&gt; 5<br/>      case June =&gt; 6<br/>      case July =&gt; 7<br/>      case August =&gt; 8<br/>      case September =&gt; 9<br/>      case October =&gt; 10<br/>      case November =&gt; 11<br/>      case December =&gt; 12<br/>    }<br/>}</pre>
<p>You can see how we match the different values, and based on them, we return the correct values. Here is how this method can be used now:</p>
<pre>System.out.println(s"The current month is: $month and it's number ${Month.toInt(month)}")</pre>
<p>As expected, our application will produce the following:</p>
<pre><strong>The current month is: February and it's number 2</strong></pre>
<p>The fact that we have specified our base trait to be sealed guarantees that nobody else will extend it outside our code, and we will be able to have an exhaustive pattern match. Unexhaustive pattern matches are problematic. Just as an experiment, if we try to comment out the match rule for February and we compile, we will see the following warning:</p>
<pre>Warning:(19, 5) match may not be exhaustive.<br/>It would fail on the following input: February<br/>    month match {<br/>    ^</pre>
<p>Running the example this way proves that the warning is true and our code has failed when we use <kbd>February</kbd> as a parameter. For the sake of completeness, we can add a default case:</p>
<pre>case _ =&gt; 0</pre>
<p>The examples shown in this subsection are what one can use in Scala, in order to achieve the functionality of <em>enums</em> in Java.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Pattern matching for product ADTs</h1>
                </header>
            
            <article>
                
<p>Pattern matching shows its real power when used for product and hybrid ADTs. In such cases, we can match the actual values of the data types. Let's see how we would implement a functionality to calculate the area of a shape, as defined previously:</p>
<pre>object Shape {<br/>  def area(shape: Shape): Double =<br/>    shape match {<br/>      case Circle(Point(x, y), radius) =&gt; Math.PI * Math.pow(radius, 2)<br/>      case Rectangle(_, h, w) =&gt; h * w<br/>    }<br/>}</pre>
<p>When matching, we can ignore values we don't care about. For the area, we don't really need the position information. In the preceding code, we just showed two different ways in which a matching is possible. The <kbd>_</kbd> operator can be anywhere in the match statement, and it will just ignore the value it is put for. After this, using our example is straightforward:</p>
<pre>object ShapeDemo {<br/>  def main(args: Array[String]): Unit = {<br/>    val circle = Circle(Point(1, 2), 2.5)<br/>    val rect = Rectangle(Point(6, 7), 5, 6)<br/><br/>    System.out.println(s"The circle area is: ${Shape.area(circle)}")<br/>    System.out.println(s"The rectangle area is: ${Shape.area(rect)}")<br/>  }<br/>}</pre>
<p>This will have an output similar to the following:</p>
<pre><strong>The circle area is: 19.634954084936208</strong><br/><strong>The rectangle area is: 30.0</strong></pre>
<p>We can even put constants instead of variables for the ADT constructor parameters during pattern matching. This makes the language quite powerful and allows us to achieve even more complex logic, which will still look quite nice. You can try experimenting with the preceding examples in order to get an idea of how pattern matching actually works.</p>
<div class="packt_infobox">Pattern matching is often used with ADTs and it helps to achieve clean, extendible, and exhaustive code.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Modules and objects</h1>
                </header>
            
            <article>
                
<p>Modules are a way to organize programs. They are interchangeable and pluggable pieces of code that have well-defined interfaces and hidden implementations. In Java, modules are organized in packages. In Scala, modules are objects, just like everything else. This means that they can be parameterized, extended, and passed as parameters, and so on.</p>
<p>Scala modules can provide requirements in order to be used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using modules</h1>
                </header>
            
            <article>
                
<p>We already established that modules and objects are also unified in Scala. This means that we can pass an entire module around our application. It would be useful, however, to show what a module actually looks like. Here is an example:</p>
<pre>trait Tick {<br/>  trait Ticker {<br/>    def count(): Int<br/>    def tick(): Unit<br/>  }<br/>  def ticker: Ticker<br/>}</pre>
<p>Here, <kbd>Tick</kbd> is just an interface to one of our modules. The following is its implementation:</p>
<pre>trait TickUser extends Tick {<br/>  class TickUserImpl extends Ticker {<br/>    var curr = 0<br/>    <br/>    override def count(): Int = curr<br/>    <br/>    override def tick(): Unit = {<br/>      curr = curr + 1<br/>    }<br/>  }<br/>  object ticker extends TickUserImpl<br/>}</pre>
<p>The <kbd>TickUser</kbd> trait is an actual module. It implements <kbd>Tick</kbd> and contains the code hidden inside it. We create a singleton object that will carry the implementation. Note how the name in the object is the same as the method in <kbd>Tick</kbd>. This would cover the need to implement it when mixing in the trait.</p>
<p>Similarly, we can define another interface and an implementation as follows:</p>
<pre>trait Alarm {<br/>  trait Alarmer {<br/>    def trigger(): Unit<br/>  }<br/>  def alarm: Alarmer<br/>}</pre>
<p>The implementation will be the following:</p>
<pre>trait AlarmUser extends Alarm with Tick {<br/>  class AlarmUserImpl extends Alarmer {<br/>    override def trigger(): Unit = {<br/>      if (ticker.count() % 10 == 0) {<br/>        System.out.println(s"Alarm triggered at ${ticker.count()}!")<br/>      }<br/>    }<br/>  }<br/>  object alarm extends AlarmUserImpl<br/>}</pre>
<p>What is interesting here is that we extended both modules in the <kbd>AlarmUser</kbd> one. This shows how modules could be made to be dependent on each other. Finally, we can use our modules as follows:</p>
<pre>object ModuleDemo extends AlarmUser with TickUser {<br/>  def main(args: Array[String]): Unit = {<br/>    System.out.println("Running the ticker. Should trigger the alarm<br/>    every 10 times.")<br/>    (1 to 100).foreach {<br/>      case i =&gt;<br/>        ticker.tick()<br/>        alarm.trigger()<br/>    }<br/>  }<br/>}</pre>
<p>In order for <kbd>ModuleDemo</kbd> to use the <kbd>AlarmUser</kbd> module, it is also required by the compiler to mix in <kbd>TickUser</kbd> or any module that mixes in <kbd>Tick</kbd>. This provides a possibility to plug in a different functionality.</p>
<p>The output of the program will be as follows:</p>
<pre><strong>Running the ticker. Should trigger the alarm every 10 times.</strong><br/><strong>Alarm triggered at 10!</strong><br/><strong>Alarm triggered at 20!</strong><br/><strong>Alarm triggered at 30!</strong><br/><strong>Alarm triggered at 40!</strong><br/><strong>Alarm triggered at 50!</strong><br/><strong>Alarm triggered at 60!</strong><br/><strong>Alarm triggered at 70!</strong><br/><strong>Alarm triggered at 80!</strong><br/><strong>Alarm triggered at 90!</strong><br/><strong>Alarm triggered at 100!</strong></pre>
<div class="packt_infobox">Modules in Scala can be passed as any other object. They are extendable, interchangeable, and their implementation is hidden.</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we focused on unification. We saw how there is a unification between functions and classes, ADTs, class hierarchies, as well as modules and objects. This allows us to be much more expressive and write cleaner and more efficient code. We also covered what pattern matching is and how it can be used in Scala to write good code.</p>
<p>Some of the concepts covered in this chapter will be useful in the following chapters where we will be implementing concrete design patterns. They can also be used to write good software outside the defined design patterns just because the expressivity of Scala allows it, and this defies the need to do the extra work that design patterns add.</p>
<p>In the next chapter, we will look at <strong>abstract</strong> and <strong>self-types</strong> and what they can be useful for.</p>


            </article>

            
        </section>
    </div>



  </body></html>