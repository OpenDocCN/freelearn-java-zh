<html><head></head><body>
		<div id="_idContainer085">
			<h1 class="chapter-number" id="_idParaDest-245"><a id="_idTextAnchor266"/>6</h1>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor267"/>Data Persistence and NoSQL Database Integration with Spring Data</h1>
			<p>SQL and NoSQL databases offer a flexible and scalable approach to data storage and retrieval that can be better suited to certain use cases compared to traditional relational databases. NoSQL databases are designed for horizontal scale-out, flexibility, performance, high availability, and global distribution. However, with this, you lose the consistency, ACID compliance, and expressiveness of a full SQL implementation that a relational database <span class="No-Break">can provide.</span></p>
			<p>It’s important to note that NoSQL databases are not a one-size-fits-all solution, and their suitability depends on the requirements of your application. In some cases, a combination of SQL and NoSQL databases might be the best approach to meet different data storage and retrieval needs within <span class="No-Break">an organization.</span></p>
			<p>In this chapter, we will use some of the most popular NoSQL databases. Each of them has a different approach to data access, but Spring Boot facilitates the developer experience in all <span class="No-Break">of them.</span></p>
			<p>First, we will learn how to use MongoDB, a document-oriented database that stores data in JSON-like objects. We will cover the basics of data access in MongoDB, as well as other advanced scenarios, such as indexing, transactions, and optimistic <span class="No-Break">concurrency persistence.</span></p>
			<p>Next, we will learn how to use Apache Cassandra. It is a wide-column store database, meaning that it stores data in tables with flexible schema and supports column-family data models. We will learn how to perform advanced queries, as well as how to manage optimistic concurrency persistency <span class="No-Break">within it.</span></p>
			<p>In this chapter, we will cover the <span class="No-Break">following recipes:</span></p>
			<ul>
				<li>Connecting your application <span class="No-Break">to MongoDB</span></li>
				<li>Using Testcontainers <span class="No-Break">with MongoDB</span></li>
				<li>Data indexing and sharding <span class="No-Break">in MongoDB</span></li>
				<li>Using transactions <span class="No-Break">in MongoDB</span></li>
				<li>Managing concurrency <span class="No-Break">with MongoDB</span></li>
				<li>Connecting your application to <span class="No-Break">Apache Cassandra</span></li>
				<li>Using Testcontainers with <span class="No-Break">Apache Cassandra</span></li>
				<li>Using Apache <span class="No-Break">Cassandra templates</span></li>
				<li>Managing concurrency with <span class="No-Break">Apache Cassandra</span></li>
			</ul>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor268"/>Technical requirements</h1>
			<p>For this chapter, you will need a MongoDB server and an Apache Cassandra server. In both cases, the easiest way to deploy them in your local environment is by using Docker. You can get Docker from its product page at <a href="https://www.docker.com/products/docker-desktop/">https://www.docker.com/products/docker-desktop/</a>. I will explain how to install MongoDB and Cassandra using Docker in the <span class="No-Break">respective recipes.</span></p>
			<p>If you wish to install MongoDB on your computer, you can follow the installation instructions on the product <span class="No-Break">page: </span><a href="https://www.mongodb.com/try/download/community"><span class="No-Break">https://www.mongodb.com/try/download/community</span></a><span class="No-Break">.</span></p>
			<p>If you need to access MongoDB, you can use MongoDB Shell or MongoDB Compass, both of which can be found at <a href="https://www.mongodb.com/try/download/tools">https://www.mongodb.com/try/download/tools</a>. I will be using MongoDB Shell in this chapter, so I recommend <span class="No-Break">installing it.</span></p>
			<p>For Cassandra, you can follow the instructions <span class="No-Break">at </span><a href="https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html"><span class="No-Break">https://cassandra.apache.org/doc/latest/cassandra/getting_started/installing.html</span></a><span class="No-Break">.</span></p>
			<p>All the recipes that will be demonstrated in this chapter can be found <span class="No-Break">at: </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/tree/main/chapter6</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor269"/>Connecting your application to MongoDB</h1>
			<p>In this recipe, we will learn how to <a id="_idIndexMarker644"/>deploy a MongoDB server in Docker. Next, we<a id="_idIndexMarker645"/> will create a Spring Boot application and connect it to our MongoDB server using Spring Data MongoDB. Finally, we will initialize the database and perform some queries against the data that’s <span class="No-Break">been loaded.</span></p>
			<p>We will use the scenario of football teams and players to demonstrate the different approaches to managing data in MongoDB compared to relational databases such <span class="No-Break">as PostgreSQL.</span></p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor270"/>Getting ready</h2>
			<p>For this recipe, we will use<a id="_idIndexMarker646"/> a MongoDB database. The easiest way to deploy it on your computer is by using Docker. You can download Docker from the product page <span class="No-Break">at </span><a href="https://www.docker.com/products/docker-desktop/"><span class="No-Break">https://www.docker.com/products/docker-desktop/</span></a><span class="No-Break">.</span></p>
			<p>Once you have installed Docker, you<a id="_idIndexMarker647"/> can run a single instance of MongoDB or execute a cluster running in a replica set. Here, you will deploy a cluster running in a replica set. This is not necessary for this recipe but will be necessary for the following recipes as it is necessary to support transactions. I’ve prepared a script to facilitate the deployment of the cluster. This script deploys the cluster using <strong class="source-inline">docker-compose</strong>; once deployed, it initializes the replica set. You can find the script in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-2/start</strong></span><span class="No-Break"> folder.</span></p>
			<p>You will need MongoDB Shell to connect to the MongoDB server. You can download it <span class="No-Break">from </span><a href="https://www.mongodb.com/try/download/shell"><span class="No-Break">https://www.mongodb.com/try/download/shell</span></a><span class="No-Break">.</span></p>
			<p>You will also need the <em class="italic">mongoimport</em> tool to<a id="_idIndexMarker648"/> import some data into the database. It is part of MongoDB’s database tools. Follow the instructions on the product page to install <span class="No-Break">it: </span><a href="https://www.mongodb.com/docs/database-tools/installation/installation/"><span class="No-Break">https://www.mongodb.com/docs/database-tools/installation/installation/</span></a><span class="No-Break">.</span></p>
			<p>The data, once loaded, will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
    "_id": "1884881",
    "name": "Argentina",
    "players": [
         {
             "_id": "199325",
             "jerseyNumber": 1,
             "name": "Vanina CORREA",
             "position": "Goalkeeper",
             "dateOfBirth": "1983-08-14",
             "height": 180,
             "weight": 71
        },
        {
             "_id": "357669",
             "jerseyNumber": 2,
             "name": "Adriana SACHS",
             "position": "Defender",
             "dateOfBirth": "1993-12-25",
             "height": 163,
             "weight": 61
        }
    ]
}</pre>			<p>Each team has a list of players. Keep this structure in mind to better understand <span class="No-Break">this recipe.</span></p>
			<p>You can use <em class="italic">MongoDB Shell</em> to<a id="_idIndexMarker649"/> connect to the database. We will use it to create a database and initialize it with some data. You can find a script to load the data in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. The script and the data are in the <span class="No-Break"><strong class="source-inline">chapter3/recipe3-1/start/data</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor271"/>How to do it...</h2>
			<p>Let’s create a project using Spring <a id="_idIndexMarker650"/>Data MongoDB and create a repository to connect to our database. The database manages football teams, which include players. We will create some queries to get teams and players, and we will implement operations to make changes to our data. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Create a project using the <em class="italic">Spring Initializr</em> tool. Open <a href="https://start.spring.io">https://start.spring.io</a> and use the same parameters that you did in the <em class="italic">Creating a RESTful API</em> recipe of <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, except change the <span class="No-Break">following options:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">footballmdb</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong> and <strong class="bold">Spring </strong><span class="No-Break"><strong class="bold">Data MongoDB</strong></span></li></ul></li>
				<li>Download the template that <a id="_idIndexMarker651"/>was generated with the <em class="italic">Spring Initializr</em> tool and unzip the content to<a id="_idIndexMarker652"/> your <span class="No-Break">working directory.</span></li>
				<li>First, we will configure Spring Data MongoDB to connect to our database. For that purpose, create an <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder. It should look <span class="No-Break">like this:</span><pre class="source-code">
spring:
    data:
        mongodb:
            uri: mongodb://127.0.0.1:27017/?directConnection=true
            database: football</pre></li>				<li>Now, create a class named <strong class="source-inline">Team</strong> and annotate it with <strong class="source-inline">@Document(collection = teams)</strong>. It should look <span class="No-Break">like this:</span><pre class="source-code">
<strong class="bold">@Document(collection = "teams")</strong>
public class Team {
<strong class="bold">    @Id</strong>
    private String id;
    private String name;
    private <strong class="bold">List&lt;Player&gt;</strong> players;
}</pre><p class="list-inset">Note that we also decorated the attribute ID with <strong class="source-inline">@Id</strong> and we are using <strong class="source-inline">List&lt;Player&gt;</strong> in our class. We<a id="_idIndexMarker653"/> will have a single collection of data in<a id="_idIndexMarker654"/> MongoDB called <strong class="source-inline">teams</strong>. Each team will <span class="No-Break">contain players.</span></p></li>				<li>Next, create the <span class="No-Break"><strong class="source-inline">Player</strong></span><span class="No-Break"> class:</span><pre class="source-code">
public class Player {
    private String id;
    private Integer jerseyNumber;
    private String name;
    private String position;
    private LocalDate dateOfBirth;
    private Integer height;
    private Integer weight;
}</pre><p class="list-inset">The <strong class="source-inline">Player</strong> class does not require any special annotation as it’s data that will be embedded in the <span class="No-Break"><strong class="source-inline">Team</strong></span><span class="No-Break"> document.</span></p></li>				<li>Now, create a repository to manage the teams persisted <span class="No-Break">in MongoDB:</span><pre class="source-code">
public interface TeamRepository extends <strong class="bold">MongoRepository</strong>&lt;Team,
String&gt;{
}</pre></li>				<li>As it happens with <strong class="source-inline">JpaRepository</strong>, just by extending our <strong class="source-inline">TeamRepository</strong> interface from <strong class="source-inline">MongoRepository</strong>, we already have basic methods to manipulate <strong class="source-inline">Team</strong> documents in MongoDB. We will use this repository now. To do that, create<a id="_idIndexMarker655"/> a new service <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">FootballService</strong></span><span class="No-Break">:</span><pre class="source-code">
@Service
public class FootballService {
    private TeamRepository teamRepository;
    public FootballService(TeamRepository teamRepository) {
        this.teamRepository = teamRepository;
    }
}</pre><p class="list-inset">Now, we can create a new method in our service that retrieves a team using its <strong class="source-inline">Id</strong> value. This method in the<a id="_idIndexMarker656"/> service can use the <strong class="source-inline">findById</strong> method in <strong class="source-inline">TeamRepository</strong>, which is available by extending <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">MongoRepository</strong></span><span class="No-Break">:</span></p><pre class="source-code">public Team getTeam(String id) { 
    return teamRepository.<strong class="bold">findById</strong>(id).get();
}</pre><p class="list-inset">Spring Data MongoDB can automatically implement the queries of our <strong class="source-inline">TeamRepository</strong> interface just by following the standard naming convention. The details of the naming convention can be found at <a href="https://docs.spring.io/spring-data/mongodb/reference/repositories/query-keywords-reference.html">https://docs.spring.io/spring-data/mongodb/reference/repositories/query-keywords-reference.html</a>. As an example, let’s create a method to find a team by <span class="No-Break">its name:</span></p><pre class="source-code">public Optional&lt;Team&gt; findByName(String name);</pre><p class="list-inset">We can also create a method to find the teams with a name that contains <span class="No-Break">a string:</span></p><pre class="source-code">public List&lt;Team&gt; findByNameContaining(String name);</pre></li>				<li>Now, we will create a method<a id="_idIndexMarker657"/> to find a player. For this, we will <a id="_idIndexMarker658"/>need to look into the teams to find the player. It can be implemented by using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Query</strong></span><span class="No-Break"> annotation:</span><pre class="source-code">
@Query(value = "{'players._id': ?0}", fields = "{'players.$': 1}")
public Team findPlayerById(String id);</pre></li>				<li>As you can see, the query’s <strong class="source-inline">value</strong> attribute<a id="_idIndexMarker659"/> is not SQL – it’s in <strong class="bold">MongoDB Query Language</strong> (<strong class="bold">MQL</strong>). Also, the query’s <strong class="source-inline">fields</strong> attribute corresponds to the fields we want to retrieve from the document – in this case, just the <strong class="source-inline">players</strong> field of the document. This method will return a <strong class="source-inline">Team</strong> object with only <span class="No-Break">one player.</span><p class="list-inset">Let’s see how we can use this method. To do so, create a method in <strong class="source-inline">FootballService</strong> <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">findPlayerById</strong></span><span class="No-Break">:</span></p><pre class="source-code">
public Player getPlayer(String id) {
    Team team = teamRepository.findPlayerById(id);
    if (team != null) {
        return team.getPlayers().isEmpty()
                                     ? null
                                     : team.getPlayers().get(0);
    } else {
        return null;
    }
}</pre><p class="list-inset">We will use the <strong class="source-inline">save</strong> method of <strong class="source-inline">MongoRepository</strong> to <em class="italic">upsert</em> teams and <strong class="source-inline">delete</strong>/<strong class="source-inline">deleteById</strong> to make changes in <span class="No-Break">the database:</span></p><ul><li><strong class="bold">Upsert</strong> means that if the <a id="_idIndexMarker660"/>data doesn’t exist, this <a id="_idIndexMarker661"/>method will create the data, and will update the <a id="_idIndexMarker662"/>data if it already exists. Let’s create a method named <strong class="source-inline">saveTeam</strong> in the <span class="No-Break"><strong class="source-inline">FootballService</strong></span><span class="No-Break"> class:</span><pre class="source-code">public Team saveTeam(Team team) {
    return teamRepository.save(team);
}</pre></li><li>Now, create a method to delete a team by <span class="No-Break">its ID:</span><pre class="source-code">public void deleteTeam(String id) {
    teamRepository.deleteById(id);
}</pre></li></ul></li>			</ol>
			<p>In this recipe, we implemented a service that uses <strong class="source-inline">MongoRepository</strong> to perform the basic operations to interact with our MongoDB database. I’ve created a RESTful API to expose the methods that were implemented by the <strong class="source-inline">FootballService</strong> service that was created in this recipe. I’ve also created a script to make the requests to the RESTful API. You can find all this in this book’s GitHub repository, in the <span class="No-Break"><strong class="source-inline">chapter6/reciper6-1/end</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor272"/>How it works...</h2>
			<p>When the application starts, Spring Data MongoDB scans the application looking for <strong class="source-inline">MongoRepository</strong> interfaces. Then, it generates the implementation for the methods defined in the repository and registers the interface implementation as a bean to make it available for the rest of the application. To infer the implementation of the interface, it uses the naming convention of the methods; see https://docs.spring.io/spring-data/mongodb/docs/current/reference/html/#repository-query-keywords for more details. Spring Data MongoDB also scans for methods with the <strong class="source-inline">@Query</strong> annotation to generate the implementation for <span class="No-Break">those methods</span><span class="No-Break">.</span></p>
			<p>Regarding the <strong class="source-inline">@Query</strong> annotation, Spring Data MongoDB can do certain validations, but you should keep in mind that MongoDB is schema-flexible by design. This means that it doesn’t assume that a field should or shouldn’t exist. It will return a <strong class="source-inline">null</strong> value instead. Keep in mind that if the results are <a id="_idIndexMarker663"/>different from what you expected, there is probably a typo in <span class="No-Break">your query.</span></p>
			<p>In <strong class="source-inline">findPlayerById</strong>, we <a id="_idIndexMarker664"/>implemented a query to return an element of an array in a document. It is important to understand the data that’s returned by MongoDB. When we want to find player <strong class="source-inline">430530</strong>, it returns the container document, a <strong class="source-inline">Team</strong> object with an <strong class="source-inline">id</strong> value of 1882891, with just the property players, and an array of just one element – that is, the player with ID <strong class="source-inline">430530</strong>. It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
[
  {
    "_id": "1882891",
    "players": [
      {
        "_id": "430530",
        "jerseyNumber": 2,
        "name": "Courtney NEVIN",
        "position": "Defender",
        "dateOfBirth": {
          "$date": "2002-02-11T23:00:00Z"
        },
        "height": 169,
        "weight": 64
      }
    ]
  }
]</pre>			<p class="callout-heading">Note</p>
			<p class="callout">I’ve included players in the team collection for learning purposes. If you have a similar scenario and you expect to perform a lot of queries while searching for an element of an array in a collection, you might prefer to have a MongoDB collection for that array. In this case, I would store players in their own collection. It will perform and scale <span class="No-Break">much better.</span></p>
			<p>Here,<strong class="source-inline"> MongoRepository</strong> provides <a id="_idIndexMarker665"/>three methods to <span class="No-Break">save data:</span></p>
			<ul>
				<li><strong class="source-inline">save</strong>: This method inserts<a id="_idIndexMarker666"/> a document if it doesn’t exist <a id="_idIndexMarker667"/>and replaces it if it does exist. This behavior is also known <span class="No-Break">as </span><span class="No-Break"><em class="italic">upsert</em></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">saveAll</strong>: This method behaves in the same way as <strong class="source-inline">save</strong>, but it allows you to persist a list of documents at the <span class="No-Break">same time.</span></li>
				<li><strong class="source-inline">insert</strong>: This method adds a new document to the collection. So, if the document already exists, it will fail. This method is optimized for inserting operations as it doesn’t check the previous existence of <span class="No-Break">the document.</span></li>
			</ul>
			<p>The <strong class="source-inline">save</strong> and <strong class="source-inline">saveAll</strong> methods replace the document entirely if it already exists. If you only want to update certain properties of your entity, also known as partial document updates, you will need to use <span class="No-Break">Mongo templates.</span></p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor273"/>There’s more...</h2>
			<p>I recommend looking to <strong class="source-inline">MongoTemplate</strong> for more advanced scenarios, such as when you need partial updates. Here’s an example of it if you only want to update the <span class="No-Break">team name:</span></p>
			<pre class="source-code">
public void updateTeamName(String id, String name) {
    Query query = new Query(Criteria.where("id").is(id));
    Update updateName = new Update().set("name", name);
mongoTemplate.updateFirst(query, updateName, Team.class);
}</pre>			<p>As you can see, it allows you <a id="_idIndexMarker668"/>to define the <strong class="source-inline">where</strong> criteria to query the <a id="_idIndexMarker669"/>object and allows the <em class="italic">update</em> operation, defining which fields you want to update. Here, <strong class="source-inline">MongoTemplate</strong> is the core component used by Spring Data MongoDB to create the implementation of <span class="No-Break"><strong class="source-inline">Mo<a id="_idTextAnchor274"/>ngoRepository</strong></span><span class="No-Break"> interfaces.</span></p>
			<h1 id="_idParaDest-253"><a id="_idTextAnchor275"/>Using Testcontainers with MongoDB</h1>
			<p>When creating integration <a id="_idIndexMarker670"/>tests that depend on MongoDB, we have two options: using an in-memory database server embedded in our application or using Testcontainers. The in-memory database server can have slight differences from our <a id="_idIndexMarker671"/>production system. For that reason, I recommend using Testcontainers; it allows you to use a real MongoDB database hosted in Docker with all <span class="No-Break">features enabled.</span></p>
			<p>In this recipe, we’ll learn how to set up a MongoDB Testcontainer and how to execute some initialization scripts so that we can insert test data into <span class="No-Break">the database.</span></p>
			<h2 id="_idParaDest-254"><a id="_idTextAnchor276"/>Getting ready</h2>
			<p>Executing Testcontainers requires a Docker-API compatible runtime. You can install Docker by following the instructions on the official web <span class="No-Break">page: </span><a href="https://www.docker.com/products/docker-desktop/"><span class="No-Break">https://www.docker.com/products/docker-desktop/</span></a><span class="No-Break">.</span></p>
			<p>In this recipe, we’ll add tests for the project we created in the <em class="italic">Connecting your application to MongoDB</em> recipe. I’ve created a working version of that recipe in case you haven’t completed it yet. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <strong class="source-inline">chapter6/recipe6-2/start</strong> folder. In this folder, you will also find a file named <strong class="source-inline">teams.json</strong>. This will be used to initialize the data for <span class="No-Break">the tests.</span></p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor277"/>How to do it...</h2>
			<p>Let’s enhance our project by creating automated tests <span class="No-Break">with Testcontainers:</span></p>
			<ol>
				<li>First, we’ll need to include <a id="_idIndexMarker672"/>the Testcontainers dependencies. For that, open the <strong class="source-inline">pom.xml</strong> file and<a id="_idIndexMarker673"/> add the <span class="No-Break">following dependencies:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;mongodb&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></li>				<li>As we’ll need to initialize the data in the database during the test execution, copy the <strong class="source-inline">team.json</strong> file described in the <em class="italic">Getting ready</em> section into the <span class="No-Break"><strong class="source-inline">tests/resources/mongo</strong></span><span class="No-Break"> folder.</span></li>
				<li>Next, create a test class. Let’s name it <strong class="source-inline">FootballServiceTest</strong>, and annotate the class with <strong class="source-inline">@SpringBootTest</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">@Testcontainers</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">@SpringBootTest</strong>
<strong class="bold">@Testcontainers</strong>
class FootballServiceTest</pre></li>				<li>We’ll continue setting up the test class by creating the MongoDB container. As we’ll see in the next <a id="_idIndexMarker674"/>step, we’ll need to initialize the database with some<a id="_idIndexMarker675"/> data. For that, we’ll copy the <strong class="source-inline">teams.json</strong> file described in <em class="italic">Step 2</em> to the container. We’ll create the container and pass the file <span class="No-Break">as follows:</span><pre class="source-code">
static MongoDBContainer mongoDBContainer = new <strong class="bold">MongoDBContainer</strong>("mongo").<strong class="bold">withCopyFileToContainer</strong>(
   MountableFile.<strong class="bold">forClasspathResource</strong>("mongo/teams.json"), teams.json");</pre></li>				<li>Now, we’ll start the container and import the data from the <strong class="source-inline">teams.json</strong> file. To import the data, we’ll use the <span class="No-Break"><em class="italic">mongoimport</em></span><span class="No-Break"> tool:</span><pre class="source-code">
<strong class="bold">@BeforeAll</strong>
static void startContainer() throws IOException, InterruptedException {
    mongoDBContainer.start();
    importFile("teams");
}
static void importFile(String fileName) throws IOException, InterruptedException {
    Container.ExecResult res = <strong class="bold">mongoDBContainer.execInContainer</strong>("<strong class="bold">mongoimport</strong>", "--db=football", "--collection=" + fileName, "--jsonArray", fileName + ".json");
    if (res.getExitCode() &gt; 0){
        throw new RuntimeException("MongoDB not properly initialized");
    }
}</pre><p class="list-inset">Note that this step should be performed before the tests start. That’s why it’s annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@BeforeAll</strong></span><span class="No-Break">.</span></p></li>				<li>Now, we should configure<a id="_idIndexMarker676"/> the context so that it uses the MongoDB database hosted in Testcontainers. For that, we’ll use the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">DynamicPropertySource</strong></span><span class="No-Break"> annotation:</span><pre class="source-code">
<strong class="bold">@DynamicPropertySource</strong>
static void setMongoDbProperties(DynamicPropertyRegistry registry) {
    registry.add("<strong class="bold">spring.data.mongodb.uri</strong>", <strong class="bold">mongoDBContainer::getReplicaSetUrl</strong>);
}</pre></li>				<li>Now that the MongoDB <a id="_idIndexMarker677"/>repository has been configured, we can continue with the normal test implementation. Let’s inject <strong class="source-inline">FootballService</strong> into the test class and implement a simple test that will retrieve a <span class="No-Break"><strong class="source-inline">Team</strong></span><span class="No-Break"> object:</span><pre class="source-code">
@Autowired
private FootballService footballService;
@Test
void getTeam() {
   Team team = footballService.getTeam("1884881");
   assertNotNull(team);
}</pre></li>				<li>You can implement the tests for the rest of the functionality. I’ve created some basic tests for the <strong class="source-inline">FootballService</strong> class. You can find them in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-2/end</strong></span><span class="No-Break"> folder.</span></li>
			</ol>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor278"/>How it works...</h2>
			<p>As we saw in the <em class="italic">PostgreSQL integration tests with Testcontainers</em> recipe of <a href="B21646_05.xhtml#_idTextAnchor203"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, by adding the <strong class="source-inline">@Testcontainers</strong> annotation, all the containers that are declared as static are available for all the tests in the class and stopped after the last test is executed. In this recipe, we used the specialized <strong class="source-inline">MongoDBContainer</strong> container; it provides the URL of the server, which we can use to configure the test context. This configuration is performed by using <a id="_idIndexMarker678"/>the <strong class="source-inline">@DynamicPropertySource</strong> annotation, as we saw in <span class="No-Break"><em class="italic">Step 6</em></span><span class="No-Break">.</span></p>
			<p>In this recipe, we learned how to<a id="_idIndexMarker679"/> copy files to the container and execute programs inside it. All the files in the <strong class="source-inline">resources</strong> folder are available at runtime. We copied the <strong class="source-inline">teams.json</strong> file to the container and then used the <strong class="source-inline">mongoimport</strong> tool to import the data into MongoDB. This tool is available in the MongoDB Docker image. One advantage of executing this tool in the container is that it’s not necessary to specify the database <span class="No-Break">server address.</span></p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor279"/>Data indexing and sharding in MongoDB</h1>
			<p>In this recipe, we will manage football matches and their timeline – that is, the events that occur during the<a id="_idIndexMarker680"/> game. An event may involve one or two players and we must consider that the players’ fans want to access all actions where their favorite players are involved. We will <a id="_idIndexMarker681"/>also consider that the number of matches and their events is growing every day, so we need to prepare our application to support all <span class="No-Break">the load.</span></p>
			<p>In this recipe, we’ll introduce <a id="_idIndexMarker682"/>some key concepts to make your application performant and scalable. MongoDB, like relational databases, enables you to create indexes that optimize data access. If you plan to access certain data using the same parameters, it is worth creating indexes to optimize data read. Of course, you will require more storage and memory, and write operations will be impacted. So, you will need to plan and analyze your <span class="No-Break">application needs.</span></p>
			<p>As the size of your data increases, you will need to scale your MongoDB database. <strong class="bold">Sharding</strong> is a database <a id="_idIndexMarker683"/>architecture and partitioning technique that’s used to horizontally partition data across multiple servers or nodes in a distributed system. With sharding, you can scale out your database by adding more servers and distributing the data across them using shards. A shard ensures that all data in the same shard will be on the <span class="No-Break">same server.</span></p>
			<p>In this recipe, we will use indexing and sharding in our football application while taking advantage of the features provided by <a id="_idIndexMarker684"/>Spring Data MongoDB. We will use other interesting features of Spring<a id="_idIndexMarker685"/> Data MongoDB, such as referring documents from <span class="No-Break">other documents.</span></p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor280"/>Getting ready</h2>
			<p>We will use the same tools that we did in the first recipe, <em class="italic">Connecting your application to MongoDB</em> – that is, Docker, MongoDB, and MongoDB tools such as <em class="italic">Mongo Shell</em> <span class="No-Break">and </span><span class="No-Break"><em class="italic">mongoimport</em></span><span class="No-Break">.</span></p>
			<p>We will reuse the code from the <em class="italic">Connecting your application to MongoDB</em> recipe. If you haven’t completed it yet, don’t worry – I’ve prepared a working version in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in <strong class="source-inline">chapter6/recipe6-</strong> <strong class="source-inline">3/start</strong>. I’ve also created a script to load data into the database using the <em class="italic">mongoimport</em> tool. This can be found in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-3/start/data</strong></span><span class="No-Break"> folder.</span></p>
			<p>The data is a bit different compared to what was provided in the <em class="italic">Connecting your application to MongoDB</em> recipe. I moved the players to their own MongoDB collection, and I added new collections to manage the matches and match events. If you want to keep the data from the previous recipe, I recommend that you create a new database for this recipe. You can do so by simply changing the <strong class="source-inline">--db</strong> parameter when calling the <strong class="source-inline">mongoimport</strong> tool. The calls will look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
mongoimport --uri="mongodb://127.0.0.1:27017/?directConnection=true"
<strong class="bold">--db=football2</strong> --collection=teams --jsonArray &lt; teams.json</pre>			<h2 id="_idParaDest-259"><a id="_idTextAnchor281"/>How to do it...</h2>
			<p>First, we will host the players’ data in their own MongoDB collection. Players will be important entities for the new requirements, so they deserve their own collection. Then, we will create the document classes for matches and events. We will learn how to use Spring Data MongoDB annotations to configure MongoDB <em class="italic">indexes</em> and <em class="italic">shards</em>. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Let’s start by configuring players in their own MongoDB collection. Annotate the <strong class="source-inline">Player</strong> class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Document</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">@Document(collection = "players")</strong>
public class Player {
    @Id
private String id;
}</pre><p class="list-inset">Annotate the <strong class="source-inline">id</strong> field <a id="_idIndexMarker686"/>with the <strong class="source-inline">@Id</strong> annotation. We’re doing this as it will be the <span class="No-Break">document identifier.</span></p><p class="list-inset">Now, remove the <strong class="source-inline">players</strong> field <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">Team</strong></span><span class="No-Break">.</span></p></li>				<li>Next, create the classes for <a id="_idIndexMarker687"/>matches and their events. For matches, we will create a class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Match</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">@Document(collection = "matches")</strong>
public class Match {
    @Id
    private String id;
    private LocalDate matchDate;
    <strong class="bold">@Indexed</strong>
    <strong class="bold">@DBRef(lazy = false)</strong>
    <strong class="bold">private Team team1;</strong>
    <strong class="bold">@Indexed</strong>
    <strong class="bold">@DBRef(lazy = false)</strong>
    <strong class="bold">private Team team2;</strong>
    private Integer team1Goals;
    private Integer team2Goals;
}</pre><p class="list-inset">Note that we started using two new annotations, <strong class="source-inline">@Indexed</strong> and <strong class="source-inline">@DBRef</strong>. They will be fully <a id="_idIndexMarker688"/>explained in the <em class="italic">How it works...</em> section of <span class="No-Break">this recipe.</span></p><p class="list-inset">For the match events, we<a id="_idIndexMarker689"/> will create a class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">MatchEvent</strong></span><span class="No-Break">:</span></p><pre class="source-code"><strong class="bold">@Sharded(shardKey = { "match" })</strong>
@Document(collection = "match_events")
public class MatchEvent {
    @Id
    private String id;
    <strong class="bold">@Field(name = "event_time")</strong>
    private LocalDateTime time;
    private Integer type;
    private String description;
    @Indexed
    @DBRef
    private Player player1;
    @Indexed
    @DBRef
    private Player player2;
    private List&lt;String&gt; mediaFiles;
    @DBRef
    private Match match;
}</pre><p class="list-inset">With that, we have introduced the <strong class="source-inline">@Sharded</strong> and <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">Field</strong></span><span class="No-Break"> annotations.</span></p></li>				<li>To be able to use the new <a id="_idIndexMarker690"/>classes, we will create a repository for each class – that is, <strong class="source-inline">PlayerRepository</strong>, <strong class="source-inline">MatchRepository</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">MatchEventRepository</strong></span><span class="No-Break">.</span><p class="list-inset">Let’s look at <strong class="source-inline">MatchEventRepository</strong> in detail. It will implement the operations we need for <span class="No-Break">our</span><span class="No-Break"><a id="_idIndexMarker691"/></span><span class="No-Break"> requirements:</span></p><ul><li>Return all events in <span class="No-Break">a match</span></li><li>Return all player events in <span class="No-Break">a match:</span><pre class="source-code">
public interface MatchEventRepository extends MongoRepository&lt;MatchEvent, String&gt;{
    @Query(value = "{'match.$id': ?0}")
    List&lt;MatchEvent&gt; findByMatchId(String matchId);
    @Query(value = "{'$and': [{'match.$id': ?0}, {'$or':[
{'player1.$id':?1}, {'player2.$id':?1} ]}]}")
    List&lt;MatchEvent&gt; findByMatchIdAndPlayerId(String matchId, String playerId);
}</pre></li></ul></li>				<li>At this point, we could run our application as Spring Data MongoDB components are in place. However, not all of the<a id="_idIndexMarker692"/> indexes have been created yet. If we want to create them as part of our <a id="_idIndexMarker693"/>application, we need to create a configuration class that extends <strong class="source-inline">AbstractMongoClientConfiguration</strong>, instructing Spring Mongo DB to create the <span class="No-Break">indexes automatically:</span><pre class="source-code">
<strong class="bold">@Configuration</strong>
public class MongoConfig <strong class="bold">extends</strong>
<strong class="bold">AbstractMongoClientConfiguration</strong> {
    @Override
    protected boolean <strong class="bold">autoIndexCreation</strong>() {
        return true;
    }
}</pre></li>				<li>Now, we can create a service using these repositories to implement the new requirements of our application while connecting to MongoDB in an optimized way. I’ve created a service and a RESTful controller to demonstrate the use of these repositories. I’ve also added a few more tests using Testcontainers. You can find them in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-3/end</strong></span><span class="No-Break"> folder.</span></li>
			</ol>
			<h2 id="_idParaDest-260"><a id="_idTextAnchor282"/>How it works...</h2>
			<p>First, I will explain the impact of the annotations that were used in <span class="No-Break">this recipe.</span></p>
			<p>The <strong class="source-inline">@DBRef</strong> annotation is a way to reference another document but keep in mind that this is a mechanism that’s implemented by Spring Data MongoDB, not by the database engine itself. In MongoDB, the concept of reference integrity doesn’t exist, and it should be managed at the application level. Here, <strong class="source-inline">@DBRef</strong> represents a document as an object with <span class="No-Break">three fields:</span></p>
			<ul>
				<li><strong class="source-inline">$ref</strong>: This contains the collection <span class="No-Break">being referenced</span></li>
				<li><strong class="source-inline">$id</strong>: This contains the ID of the document <span class="No-Break">being referenced</span></li>
				<li><strong class="source-inline">$db</strong>: This contains the database<a id="_idIndexMarker694"/> of the document <span class="No-Break">being referenced</span></li>
			</ul>
			<p>For example, here, you have a reference to <span class="No-Break">team </span><span class="No-Break"><strong class="source-inline">1882891</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
{
    "$ref": "teams",
    "$id": "1882891",
    "$db": "football"
}</pre>			<p>Spring Data MongoDB can <a id="_idIndexMarker695"/>use this annotation to automatically retrieve the referenced document. We can specify this behavior using the <strong class="source-inline">lazy</strong> attribute. By default, it is <strong class="source-inline">true</strong>, meaning that Spring Data MongoDB won’t retrieve it automatically. If you set it to <strong class="source-inline">false</strong>, it will retrieve the referenced document automatically. We used this for the match document to automatically retrieve the information from the two teams playing <span class="No-Break">the match.</span></p>
			<p>The <strong class="source-inline">@Indexed</strong> annotation, as you may have figured out, creates an index in MongoDB. Then, the queries that use the indexed fields will perform faster for <span class="No-Break">read operations.</span></p>
			<p>The <strong class="source-inline">@Sharded</strong> annotation tells MongoDB how the collections should be distributed across shards. A server in a cluster can host one or more shards. We can also see a shard as a way to specify which documents will be hosted on the same server. In our case, we are interested in retrieving the events by match. This is the reason we configured <strong class="source-inline">match</strong> as the shard key. Selecting a good sharding key is crucial to make our application performant and scalable as it will impact the way the workload will be distributed across <span class="No-Break">the servers.</span></p>
			<p>When a query is performed in a sharded collection, MongoDB should identify if the request can be performed in a single shard or whether it will need to distribute the query across shards. It will gather the results from shards, aggregate them, and then return the results to the client. If you intentionally need to scale out a query horizontally, this is an excellent mechanism. It may happen that a request doesn’t need to be distributed and could be executed in a single shard, but because of a wrong shard key selection, it is executed as a distributed query. The consequence is that it will consume more resources than expected because more servers will perform an unnecessary query, so the results have to <span class="No-Break">be aggregated.</span></p>
			<p>Sharding involves dividing a <a id="_idIndexMarker696"/>database into smaller parts, called shards, that can be hosted on a single server. A server can<a id="_idIndexMarker697"/> host multiple shards, and the shards are replicated across servers for <a id="_idIndexMarker698"/>availability. The number of servers can automatically increase or decrease, depending on the load. Sharding is useful for managing large datasets and large clusters, which are typically deployed in the <a id="_idIndexMarker699"/>cloud. For example, <strong class="bold">MongoDB Atlas</strong> can be hosted on<a id="_idIndexMarker700"/> cloud providers such as <strong class="bold">Azure</strong>, <strong class="bold">Amazon Web Services</strong> (<strong class="bold">AWS</strong>), and <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), allowing the number of servers to be adjusted to meet real <a id="_idIndexMarker701"/>demand. However, in cases where the database is hosted in a single container on a computer, as in our example, sharding won’t provide any significant benefits. In larger deployments, sharding is a crucial feature for achieving <span class="No-Break">our goals.</span></p>
			<p>We didn’t explicitly create an index for <strong class="source-inline">match</strong> in <strong class="source-inline">MatchEvent</strong>, but it is implicitly created since it is the <span class="No-Break">sharding key.</span></p>
			<p>Finally, we used the <strong class="source-inline">@Field</strong> annotation. This is used to map a field in our document class to a different field in MongoDB. In our case, we mapped the <strong class="source-inline">time</strong> field in our class to the <strong class="source-inline">event_time</strong> field <span class="No-Break">in MongoDB.</span></p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor283"/>There’s more...</h2>
			<p>Some decisions should be made when designing the data layer with MongoDB or other document-oriented databases. For example, should we mix different types of objects in the same collection, or should we keep each type of document in <span class="No-Break">different collections?</span></p>
			<p>Having different types of objects in the same collection can make sense if they share some common fields and you want to perform queries by those fields, or you want to aggregate data from different objects. For the rest of the scenarios, it is probably better to have each type of document in its own collection. It helps create indexes and facilitate the creation <span class="No-Break">of shards.</span></p>
			<p>In this recipe, we didn’t mix different types of documents, but that is the reason why Spring Data MongoDB introduces a field named <strong class="source-inline">_class</strong> when it persists a document. For instance, this is the document that’s persisted when creating a <span class="No-Break">new team:</span></p>
			<pre class="source-code">
{
  "_id": "99999999",
  "name": "Mars",
  <strong class="bold">"_class": "com.packt.footballmdb.repository.Team"</strong>
}</pre>			<p>Another decision to make is whether we should embed some data in a document or if that data should be in its own document. In the <em class="italic">Connecting your application to MongoDB</em> recipe, we embedded <a id="_idIndexMarker702"/>the players into their team, while in this recipe, we moved that information to its<a id="_idIndexMarker703"/> own collection. It may depend on the importance or independence of the embeddable document. In this recipe, the players required their own document as they can be directly referenced from other documents, such as <span class="No-Break">match events.</span></p>
			<p>There could be other reasons, such as the expected write concurrency over the embedded entity. For instance, we could embed the events in the matches. However, during a match, we could assume that there will be a high number of events happening. That operation would require a high number of write operations on the matc<a id="_idTextAnchor284"/>h document, which will require more <span class="No-Break">consistency management.</span></p>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor285"/>Using transactions in MongoDB</h1>
			<p>We want to create a new service<a id="_idIndexMarker704"/> where users can purchase a virtual token that can be used to obtain virtual goods in this new game. The main goods are cards with <a id="_idIndexMarker705"/>player pictures and other information, a kind of <span class="No-Break">virtual sticker.</span></p>
			<p>There are two operations that we need to implement: the token purchase and the cards purchase. For the token purchase, there is a payment validation. Cards can only be purchased with tokens. Of course, the users will be able to purchase cards if they have <span class="No-Break">enough tokens.</span></p>
			<p>Since we need to ensure consistency regarding the token and cards balance, we will need to use transactions with our <span class="No-Break">MongoDB repository.</span></p>
			<p>In this recipe, we will learn more about MongoDB transactions and how they differ from relational <span class="No-Break">database transactions.</span></p>
			<h2 id="_idParaDest-263"><a id="_idTextAnchor286"/>Getting ready</h2>
			<p>We will use the same tools that we did in the <em class="italic">Connecting your application to MongoDB</em> recipe – that is, Docker <span class="No-Break">and MongoDB.</span></p>
			<p>We will reuse the code<a id="_idIndexMarker706"/> from the <em class="italic">Data indexing and sharding in MongoDB</em> recipe. If you haven’t completed it yet, don’t worry – I’ve prepared a working version<a id="_idIndexMarker707"/> in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<p class="callout-heading">MongoDB transactions</p>
			<p class="callout">MongoDB transactions are not supported in <a id="_idIndexMarker708"/>standalone servers. In the <em class="italic">Connecting your application to MongoDB</em> recipe, I provided a script to deploy a cluster using a <span class="No-Break">replica set.</span></p>
			<p class="callout">In the <em class="italic">Deploying a MongoDB cluster in Testcontainers</em> recipe, we’ll cover how to deploy multiple servers with containers to be able to test <span class="No-Break">MongoDB transactions.</span></p>
			<h2 id="_idParaDest-264"><a id="_idTextAnchor287"/>How to do it...</h2>
			<p>We will need to create a data model to support users and cards in our new service. Later, we will create a service that will use MongoDB transactions to perform operations involving users and cards consistently. We will configure our application so that it supports transactions as well. Follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Let’s start by creating the classes that will manage the objects to be stored <span class="No-Break">in MongoDB:</span><ol><li class="upper-roman">First, we will create a class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">User</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
@Document(collection = "users")
public class User {
    @Id
    private String id;
    private String username;
    private Integer tokens;
}</pre><ol><li class="upper-roman" value="2">Next, we will <a id="_idIndexMarker709"/>create a class <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">Card</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">@Document(collection = "cards")
public class Card {
    @Id
    private String id;
    @DBRef
    private Player player;
    @DBRef
    private User owner;
}</pre></li>				<li>Next, we need to <a id="_idIndexMarker710"/>create the corresponding <strong class="source-inline">MongoRepository</strong> interfaces. <span class="No-Break">Let’s go:</span><ol><li class="upper-roman">Create an interface <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">UserRepository</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
public interface UserRepository extends MongoRepository&lt;User, String&gt;{
}</pre><ol><li class="upper-roman" value="2">And another interface <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">CardRepository</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">public interface CardRepository extends MongoRepository&lt;Card, String&gt;{
}</pre></li>				<li>Now, we need to create a service class that will manage the business logic of our application. To do that, create a class<a id="_idIndexMarker711"/> named <strong class="source-inline">UserService</strong>. Remember to annotate the class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Service</strong></span><span class="No-Break">:</span><pre class="source-code">
@Service
public class UserService {
}</pre></li>				<li>This service will need the <a id="_idIndexMarker712"/>new repositories we created – that is, <strong class="source-inline">UserRepository</strong> and <strong class="source-inline">CardRepository</strong>, as well as <strong class="source-inline">PlayerRepository</strong>, which we created in the <em class="italic">Data indexing and sharding in MongoDB</em> recipe. We will need <strong class="source-inline">MongoTemplate</strong> as well. We will create a constructor with these repositories, after which the Spring Boot dependency manager will <span class="No-Break">inject them:</span><pre class="source-code">
@Service
public class UserService {
    private UserRepository userRepository;
    private PlayerRepository playersRepository;
    private CardRepository cardsRepository;
    private MongoTemplate mongoTemplate;
    public UserService(UserRepository userRepository,
                       PlayerRepository playersRepository,
                       CardRepository cardsRepository,
                       MongoTemplate mongoTemplate) {
        this.userRepository = userRepository;
        this.playersRepository = playersRepository;
        this.cardsRepository = cardsRepository;
        this.mongoTemplate = mongoTemplate;
    }</pre></li>				<li>Next, we’ll implement our <span class="No-Break">business logic:</span><ol><li class="upper-roman">Create a method for purchasing tokens <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">buyTokens</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
public Integer buyTokens(String userId, Integer tokens) {
    Query query = new Query(Criteria.where("id").is(userId));
    <strong class="bold">Update update = new Update().inc("tokens", tokens);</strong>
    UpdateResult result = mongoTemplate.updateFirst(query, update, User.class, "users");
    return (int) result.getModifiedCount();
}</pre><ol><li class="upper-roman" value="2">Create <a id="_idIndexMarker713"/>a method for<a id="_idIndexMarker714"/> purchasing cards <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">buyCards</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code"><strong class="bold">@Transactional</strong>
public Integer buyCards(String userId, Integer count) {
    Optional&lt;User&gt; userOpt = userRepository.findById(userId);
    if (userOpt.isPresent()) {
        User user = userOpt.get();
        List&lt;Player&gt; availablePlayers = getAvailablePlayers();
        Random random = new Random();
        if (user.getTokens() &gt;= count) {
            user.setTokens(user.getTokens() - count);
        } else {
            throw new RuntimeException("Not enough tokens");
        }
        List&lt;Card&gt; cards = Stream.generate(() -&gt; {
            Card card = new Card();
            card.setOwner(user);
            card.setPlayer(availablePlayers.get(
                    random.nextInt(0,
                            availablePlayers.size())));
            return card;
        }).limit(count).toList();
<strong class="bold">        List&lt;Card&gt; savedCards = cardsRepository.saveAll(cards);</strong>
        userRepository.save(user);
        return savedCards.size();
    }
    return 0;
}</pre></li>				<li>To allow transactions in our<a id="_idIndexMarker715"/> application, we need to<a id="_idIndexMarker716"/> register a <strong class="source-inline">MongoTransactionManager</strong> bean. To do so, in our <strong class="source-inline">MongoConfig</strong> class, add the <span class="No-Break">following method:</span><pre class="source-code">
<strong class="bold">@Bean</strong>
<strong class="bold">MongoTransactionManager</strong>
transactionManager(MongoDatabaseFactory dbFactory) { 
    return new MongoTransactionManager(dbFactory); 
}</pre></li>			</ol>
			<p>Now, our application can use transactions to execute <span class="No-Break">operations atomically.</span></p>
			<h2 id="_idParaDest-265"><a id="_idTextAnchor288"/>How it works...</h2>
			<p>By default, MongoDB native transactions are disabled in Spring Data MongoDB. That is the reason why we needed to register <strong class="source-inline">MongoTransactionManager</strong>. Once configured, when we annotate a method <a id="_idIndexMarker717"/>with <strong class="source-inline">@Transactional</strong>, it will create <span class="No-Break">a transaction.</span></p>
			<p>It is very important to note that <a id="_idIndexMarker718"/>transactions provide atomic operations, meaning that all of them are saved or none of them are, but they don’t support isolation. The <strong class="source-inline">buyCards</strong> method will save all <strong class="source-inline">cards</strong> and the changes on <strong class="source-inline">user</strong> or it will save none <span class="No-Break">of them.</span></p>
			<p>An important difference compared to transactions in relational databases is that there is no locking or isolation. If we make changes to the same <strong class="source-inline">User</strong> document that is modified in <strong class="source-inline">buyCards</strong> in another request, it will raise a <strong class="bold">write conflict exception</strong>. MongoDB is designed for performance and scalability at the<a id="_idIndexMarker719"/> cost of losing features from ACID transactions. We’ll learn how to manage concurrency in more detail in the <em class="italic">Managing concurrency with </em><span class="No-Break"><em class="italic">MongoDB</em></span><span class="No-Break"> recipe.</span></p>
			<p>As you’ve probably realized, the <strong class="source-inline">buyTokens</strong> method does not use transactions. The main reason is that it doesn’t need to. All operations in a single document are considered isolated and atomic. Since the only field that’s updated is <strong class="source-inline">tokens</strong>, we used the <strong class="source-inline">inc</strong> operation to modify the value. The advantage of this operator is that it’s performed atomically in the server, even in high-concurrency environments. If we use transactions in operations involving a single document, it could raise write conflicts exceptions if two requests are updating the same document. This behavior could seem counter-intuitive if you compare it to the behavior of transactions in <span class="No-Break">relational databases.</span></p>
			<h2 id="_idParaDest-266"><a id="_idTextAnchor289"/>See also</h2>
			<p>In addition to <strong class="source-inline">$inc</strong>, there are other atomic operations in MongoDB worth knowing about for concurrent scenarios. They can be applied to fields and arrays. See <a href="https://www.mongodb.com/docs/v7.0/reference/operator/update/">https://www.mongodb.com/docs/v7.0/reference/operator/update/</a> for <span class="No-Break">more details.</span></p>
			<h1 id="_idParaDest-267"><a id="_idTextAnchor290"/>Deploying a MongoDB cluster in Testcontainers</h1>
			<p>MongoDB transactions are only supported in multiple server clusters. However, <strong class="source-inline">MongoDBContainer</strong>, as explained in the <em class="italic">Using Testcontainers with MongoDB</em> recipe uses a single server deployment. Therefore, we cannot use it for the integration tests of the new feature to<a id="_idIndexMarker720"/> buy cards as it <span class="No-Break">requires transactions.</span></p>
			<p>In this recipe, we’ll learn<a id="_idIndexMarker721"/> how to set up multiple Testcontainers and configure a MongoDB cluster. With that, we’ll be able to implement integration tests for the buy <span class="No-Break">cards feature.</span></p>
			<h2 id="_idParaDest-268"><a id="_idTextAnchor291"/>Getting ready</h2>
			<p>This recipe will implement the integration tests for the <em class="italic">Using transactions in MongoDB</em> recipe. If you haven’t completed it yet, don’t worry – I’ve prepared a version from which you can start this recipe. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</a>, <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter6/recipe6-5/start</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-269"><a id="_idTextAnchor292"/>How to do it...</h2>
			<p>In this recipe, we’ll set up the MongoDB cluster using Testcontainers and test the features involving transactions. Let’s <span class="No-Break">get started!</span></p>
			<ol>
				<li>Since the new buy cards feature is the, we’ll create a new test class named <strong class="source-inline">UserServiceTest</strong> and set up everything in this class. Since it uses Testcontainers, we’ll annotate the class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Testcontainers</strong></span><span class="No-Break">:</span><pre class="source-code">
@SpringBootTest
<strong class="bold">@Testcontainers</strong>
class UserServiceTest</pre></li>				<li>Next, we’ll create the MongoDB cluster. It will consist of three MongoDB containers deployed in the <span class="No-Break">same network:</span><ol><li class="upper-roman">Declare a <strong class="source-inline">Network</strong> static field. This class is part of the Testcontainers library and allows us to define a <span class="No-Break">Docker network:</span></li></ol><pre class="source-code">
static Network mongoDbNetwork = Network.newNetwork();</pre><ol><li class="upper-roman" value="2">Now, create three static <strong class="source-inline">GenericContainer</strong> fields with the <span class="No-Break">following properties:</span><ul><li>Each field will have the latest <strong class="source-inline">mongo</strong> <span class="No-Break">Docker image.</span></li><li>Each field will have the <span class="No-Break">same network.</span></li><li>The three <a id="_idIndexMarker722"/>containers will expose <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">27017</strong></span><span class="No-Break">.</span></li><li>Each container will have a different network alias: <strong class="source-inline">mongo1</strong>, <strong class="source-inline">mongo2</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">mongo3</strong></span><span class="No-Break">.</span></li><li>The three containers will start with a <strong class="source-inline">mongod</strong> command that initializes the MongoDB cluster, with the only difference being the binding IP hostname. Each container <a id="_idIndexMarker723"/>will use its <span class="No-Break">network alias.</span></li></ul></li><li class="upper-roman">Here, we have the first <span class="No-Break">field, </span><span class="No-Break"><strong class="source-inline">mongoDBContainer1</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">static GenericContainer&lt;?&gt; mongoDBContainer<strong class="bold">1</strong> = new GenericContainer&lt;&gt;("mongo:latest")
    .withNetwork(mongoDbNetwork)
    .withCommand("mongod", "--replSet", "rs0", "--port", "27017", "--bind_ip", "localhost,<strong class="bold">mongo1</strong>")
    <strong class="bold">.withNetworkAliases("mongo1")</strong>
    .withExposedPorts(27017);</pre><ol><li class="upper-roman" value="4">The other fields, <strong class="source-inline">mongoDBContainer2</strong>, and <strong class="source-inline">mongoDBContainer3</strong>, are declared as <strong class="source-inline">mongoDBContainer1</strong>, except we must change <strong class="source-inline">mongo1</strong> to <strong class="source-inline">mongo2</strong> and <span class="No-Break"><strong class="source-inline">mongo3</strong></span><span class="No-Break">, respectively.</span></li></ol></li>				<li>Now that the three MongoDB containers have been declared, the next step is to start the containers and initiate the MongoDB replica set. We need to execute the following MongoDB<a id="_idIndexMarker724"/> command in one of <span class="No-Break">the servers:</span><pre class="source-code">
rs.initiate({
   _id: "rs0",
   members: [
       {_id: 0, host: "mongo1"},
       {_id: 1, host: "mongo2"},
       {_id: 2, host: "mongo3"}
   ]})</pre><p class="list-inset">I’ve created a utility method named <strong class="source-inline">buildMongoEvalCommand</strong> to format the commands so that they’re<a id="_idIndexMarker725"/> ready to be executed in MongoDB. We’ll execute the MongoDB replica set initialization before any test execution. For that, we’ll use the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">BeforeAll</strong></span><span class="No-Break"> annotation:</span></p><pre class="source-code">String initCluster = """
                rs.initiate({
                 _id: "rs0",
                 members: [
                   {_id: 0, host: "mongo1"},
                   {_id: 1, host: "mongo2"},
                   {_id: 2, host: "mongo3"}
                 ]
                })
                """;
mongoDBContainer1.start();
mongoDBContainer2.dependsOn(mongoDBContainer1).start();
mongoDBContainer3.dependsOn(mongoDBContainer2).start();
<strong class="bold">mongoDBContainer1.execInContainer(buildMongoEvalCommand(initCluster));</strong></pre></li>				<li>The last configuration step<a id="_idIndexMarker726"/> is setting the <strong class="source-inline">mongodb</strong> address in<a id="_idIndexMarker727"/> the application using the <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">DynamicPropertySource</strong></span><span class="No-Break"> annotation:</span><pre class="source-code">
<strong class="bold">@DynamicPropertySource</strong>
static void setMongoDbProperties(DynamicPropertyRegistry registry) {
    registry.add("<strong class="bold">spring.data.mongodb.uri</strong>", () -&gt; {
        String mongoUri = "mongodb://" + <strong class="bold">mongoDBContainer1.getHost()</strong> + ":" + <strong class="bold">mongoDBContainer1.getMappedPort(27017)</strong> + "/?directConnect=true";
        return mongoUri;
   });
<strong class="bold">}</strong></pre></li>				<li>Now, we can create our testing methods. For instance, we’ll create a test for the <strong class="source-inline">buyCards</strong> method of the <span class="No-Break"><strong class="source-inline">UserService</strong></span><span class="No-Break"> class:</span><pre class="source-code">
@Test
void buyCards() {
    User user = new User();
    user.setUsername("Sample user");
    User createdUser = userService.createUser(user);
    Integer buyTokens = 10;
    userService.buyTokens(createdUser.getId(), buyTokens);
    Integer requestedCards = 1;
    Integer cardCount = <strong class="bold">userService.buyCards</strong>(user.getId(), requestedCards);
    assertThat(cardCount, is(requestedCards));
   // do more assert
}</pre><p class="list-inset">Some code snippets <a id="_idIndexMarker728"/>have been simplified or omitted <a id="_idIndexMarker729"/>for clarity. You can find more details in this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook"><span class="No-Break">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook</span></a><span class="No-Break">.</span></p></li>			</ol>
			<h2 id="_idParaDest-270"><a id="_idTextAnchor293"/>How it works...</h2>
			<p>The <strong class="source-inline">MongoDBContainer</strong> container, which is available as a module in the Testcontainers project, only works as a single server deployment. For that reason, instead of using <strong class="source-inline">MongoDBContainer</strong>, we used <strong class="source-inline">GenericContainer</strong>. After that, we adapted to Testcontainers so that we could set up the script explained in the <em class="italic">Getting ready</em> section of the <em class="italic">Connecting your application to MongoDB</em> recipe. To do so, we did <span class="No-Break">the following:</span></p>
			<ul>
				<li>Created a <span class="No-Break">Docker network.</span></li>
				<li>Deployed at least three MongoDB servers <span class="No-Break">in containers.</span></li>
				<li>Initialized the MongoDB replica set. A replica set is a group of Mongo processes that work together to maintain the same dataset. We can consider this <span class="No-Break">a cluster.</span></li>
			</ul>
			<p>As you may have noticed, we used the <strong class="source-inline">directConnection</strong> setting when connecting to the MongoDB cluster. This setting means that we connect directly to one specific node of the cluster. When connecting to a replica set, normally, the connection string specifies all cluster nodes and the client connects to the most appropriate one. The reason we use <strong class="source-inline">directConnection</strong> is because the nodes can discover each other using the network alias. After all, they are in the same network and can use DNS names. However, the application we developed runs on our development computer, which hosts the containers, but it’s in a different network and cannot find the nodes by name. If we were in the same network, the MongoDB <a id="_idIndexMarker730"/>connection string would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
mongodb://mongo1:27017,mongo2:27017,mongo3:27017/football?replicaSet=rs0</pre>			<p>In this case, the client will <a id="_idIndexMarker731"/>connect to the appropriate node. To execute transactions, it’s necessary to connect to the primary server. The application we developed may fail when performing these transactions because it’s not connected to the <span class="No-Break">primary server.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">buildMongoEvalCommand</strong> method has been adapted from the original <strong class="source-inline">MongoDBContainer</strong> container from the <strong class="source-inline">Testcontainer</strong> project. You can find the original code <span class="No-Break">at </span><a href="https://github.com/testcontainers/testcontainers-java/blob/main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java"><span class="No-Break">https://github.com/testcontainers/testcontainers-java/blob/<span id="_idTextAnchor294"/>main/modules/mongodb/src/main/java/org/testcontainers/containers/MongoDBContainer.java</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-271"><a id="_idTextAnchor295"/>Managing concurrency with MongoDB</h1>
			<p>In this recipe, we will implement <a id="_idIndexMarker732"/>a feature to exchange player cards between users. Some cards are more difficult to get, which results in them having a higher demand. So, while many users try to find them, only one may get it. This is a scenario <a id="_idIndexMarker733"/>of <span class="No-Break">high concurrency.</span></p>
			<p>A user can exchange or buy another user’s card using a certain number of tokens. The process we will implement consists of the <span class="No-Break">following steps:</span></p>
			<ol>
				<li>First, we need to check that the buyer has the tokens <span class="No-Break">they promised.</span></li>
				<li>Then, we’ll subtract the number of tokens from the buyer and add them to <span class="No-Break">the seller.</span></li>
				<li>Finally, we will change the <span class="No-Break">card owner.</span></li>
			</ol>
			<p>MongoDB supports optimistic concurrency control through a document’s versioning system. Each document has a version number (often called a <em class="italic">revision</em> or <em class="italic">version</em> field) that is incremented whenever the document is modified. When multiple clients attempt to update the same document simultaneously, the version numbers are used to detect conflicts, and the changes <a id="_idIndexMarker734"/>are rejected if there is <span class="No-Break">a conflict.</span></p>
			<p>We will add version support to <strong class="source-inline">cards</strong> and <strong class="source-inline">users</strong> as we need to control that the users haven’t spent the tokens on<a id="_idIndexMarker735"/> another thing and that the cards are not exchanged with <span class="No-Break">another user.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor296"/>Getting ready</h2>
			<p>We will use the same tools that we used in the <em class="italic">Connecting your application to MongoDB</em> recipe – that is, Docker <span class="No-Break">and MongoDB.</span></p>
			<p>We will reuse the code from the <em class="italic">Deploying a MongoDB cluster in Testcontainers</em> recipe. If you haven’t completed it yet, don’t worry – I’ve prepared a working version in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-4/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-273"><a id="_idTextAnchor297"/>How to do it...</h2>
			<p>Let’s add version control support to our <strong class="source-inline">Card</strong> and <strong class="source-inline">User</strong> documents and implement a card exchange transaction with optimistic <span class="No-Break">concurrency control:</span></p>
			<ol>
				<li>First, we will modify the classes involved in our feature so that they support optimistic concurrency. We’ll do this by adding a new field annotated <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Version</strong></span><span class="No-Break">:</span><ol><li class="upper-roman">Modify the <strong class="source-inline">User</strong> class by adding a new <strong class="source-inline">Long</strong> field <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">version</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
<strong class="bold">@Version</strong>
private Long version;</pre><ol><li class="upper-roman" value="2">And the same <strong class="source-inline">version</strong> field to the <span class="No-Break"><strong class="source-inline">Card</strong></span><span class="No-Break"> class.</span></li></ol></li>				<li>Next, we will create a new service <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">TradingService</strong></span><span class="No-Break">:</span><pre class="source-code">
@Service
public class TradingService {
    private CardRepository cardRepository;
    private UserRepository userRepository;
    public TradingService(CardRepository cardRepository,
                          UserRepository userRepository) {
        this.cardRepository = cardRepository;
        this.userRepository = userRepository;
    }
}</pre><p class="list-inset">Here, <strong class="source-inline">CardRepository</strong> and <strong class="source-inline">UserRepository</strong> are added as dependencies in the constructor as we <a id="_idIndexMarker736"/>will need them to implement the card exchange <span class="No-Break">business logic.</span></p></li>				<li>Now, we will create two <a id="_idIndexMarker737"/>methods to implement the business logic. One will be annotated with <strong class="source-inline">@Transactional</strong> to control that all changes are atomic, and another one to control <span class="No-Break">concurrency exceptions:</span><ul><li>The business logic method should look <span class="No-Break">as follows:</span><pre class="source-code">
<strong class="bold">@Transactional</strong>
private Card exchangeCardInternal(String cardId, String newOwnerId, Integer price) {
    Card card = cardRepository.findById(cardId).orElseThrow();
    User newOwner =
userRepository.findById(newOwnerId).orElseThrow();
    if (newOwner.getTokens() &lt; price) {
        throw new RuntimeException("Not enough tokens");
    }
    newOwner.setTokens(newOwner.getTokens() - price);
    User oldOwner = card.getOwner();
    oldOwner.setTokens(oldOwner.getTokens() + price);
    card.setOwner(newOwner);
    card = cardRepository.save(card);
    userRepository.saveAll(List.of(newOwner, oldOwner));
    return card;
}</pre></li><li>The method to <a id="_idIndexMarker738"/>control concurrency should<a id="_idIndexMarker739"/> look <span class="No-Break">like this:</span><pre class="source-code">public boolean exchangeCard(String cardId, String newOwnerId,
                                  Integer price) {
    try{
        exchangeCardInternal(cardId, newOwnerId, price);
        return true;
    } catch (<strong class="bold">OptimisticLockingFailureException e</strong>) {
        return false;
    }
}</pre></li></ul><p class="list-inset">With this mechanism, we can control the concurrency operations that are performed on our documents. You can now implement a RESTful API that will use this business logic. I’ve prepared a working sample in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter6/recipe6-6/end</strong></span><span class="No-Break">.</span></p></li>			</ol>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor298"/>How it works...</h2>
			<p>By adding the <strong class="source-inline">@Version</strong> annotation, the save operations not only check that the <strong class="source-inline">id</strong> value is the same, but also the field <a id="_idIndexMarker740"/>annotated with <strong class="source-inline">version</strong>. The <a id="_idIndexMarker741"/>generated query looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Query query = new
Query(Criteria.where("id").is(id)<strong class="bold">.and("version").is(version)</strong>);
Update update = new Update().set("tokens", value).inc("version", 1);
mongoTemplate.updateFirst(query, update, User.class);</pre>			<p>If this operation fails, it throws an <span class="No-Break"><strong class="source-inline">OptimisticLockingFailureException</strong></span><span class="No-Break"> exception.</span></p>
			<p>Depending on the business requirements, we could retry the operations or just abandon them, as we did in our scenario. If a user already sold the card you want, you should look for <span class="No-Break">another one.</span></p>
			<p>Since we needed to modify three different documents, we used a transaction. We used the <strong class="source-inline">@Transactional</strong> annotation for declarative transaction management. If we want to roll back changes that have been performed in that transaction, we need to throw an exception. That is why we let Spring Data MongoDB throw <strong class="source-inline">Opt<a id="_idTextAnchor299"/>imisticLockingFailureException</strong> in the <strong class="source-inline">exchangeCardInternal</strong> method and capture it <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">exchangeCard</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor300"/>Connecting your application to Apache Cassandra</h1>
			<p>In this recipe, we want to create <a id="_idIndexMarker742"/>a system that allows users to post comments related to matches, players, or match events. We decided to use Apache Cassandra due to its high scalability and <span class="No-Break">low-latency capabilities.</span></p>
			<p>In this recipe, we’ll learn how to connect our Spring Boot application to an Apache Cassandra server using Spring Data for Apache <span class="No-Break">Cassandra repositories.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor301"/>Getting ready</h2>
			<p>For this recipe, we will use an Apache Cassandra database. The easiest way to deploy Apache Cassandra on your computer is by using a container hosted in Docker. You can perform this task by executing<a id="_idIndexMarker743"/> the following <span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
docker run -p 9042:9042 --name cassandra -d cassandra:latest</pre>			<p>This command will download the latest Apache Cassandra Docker image, if you don’t have one yet on your computer, and will start a Cassandra server listening on <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">9042</strong></span><span class="No-Break">.</span></p>
			<p>After starting the server, you will need to create a <strong class="bold">Keyspace</strong>. A Keyspace is a logical aggregation of tables. To create a <a id="_idIndexMarker744"/>Keyspace, you can execute the following Docker command. It will execute a <strong class="source-inline">cqlsh</strong> script inside <span class="No-Break">the container:</span></p>
			<pre class="console">
docker exec -it cassandra cqlsh -e "CREATE KEYSPACE footballKeyspace WITH replication = {'class': 'SimpleStrategy'};"</pre>			<p>You may need to wait a few seconds for the Cassandra server to finish initializing before creating <span class="No-Break">the Keyspace.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor302"/>How to do it...</h2>
			<p>Let’s create a project with Apache Cassandra support. We will use the already familiar Spring Data concept of <strong class="source-inline">Repository</strong> to connect to <span class="No-Break">Apache Cassandra:</span></p>
			<ol>
				<li>First, we will create a new Spring Boot project using the <em class="italic">Spring Initializr</em> tool. As usual, open <a href="https://start.spring.io">https://start.spring.io</a>. We will use the same parameters we used in <a href="B21646_01.xhtml#_idTextAnchor020"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, in the <em class="italic">Creating a RESTful API</em> recipe, except we’ll use the <span class="No-Break">following parameters:</span><ul><li>For <strong class="bold">Artifact</strong>, <span class="No-Break">type </span><span class="No-Break"><strong class="source-inline">footballcdb</strong></span></li><li>For <strong class="bold">Dependencies</strong>, select <strong class="bold">Spring Web</strong> and <strong class="bold">Spring Data for </strong><span class="No-Break"><strong class="bold">Apache Cassandra</strong></span></li></ul></li>
				<li>Next, we will create a class named <strong class="source-inline">Comment</strong>. This represents the data for our <span class="No-Break">new feature.</span><p class="list-inset">We need to annotate the class with <strong class="source-inline">@Table</strong> and the fields with <strong class="source-inline">@PrimaryKeyColumn</strong> if they form part of the primary key. We can use <strong class="source-inline">@Column</strong> if we want to<a id="_idIndexMarker745"/> map a field to a different column name <span class="No-Break">in Cassandra:</span></p><pre class="source-code">
<strong class="bold">@Table</strong>
public class Comment {
    <strong class="bold">@PrimaryKeyColumn</strong>(name = "comment_id", ordinal = 0, type = PrimaryKeyType.PARTITIONED, ordering = Ordering.DESCENDING)
    private String commentId;
    private String userId;
    private String targetType;
    private String targetId;
    private String content;
    private LocalDateTime date;
    public Set&lt;String&gt; labels = new HashSet&lt;&gt;();
<strong class="bold">}</strong></pre><p class="list-inset">The <strong class="source-inline">Comment</strong> table will include the comment content, the date, and the user posting the comment. It will also include information about the target of the comment – that is, a player, a match, or any other component we may have in our <span class="No-Break">football application.</span></p></li>				<li>We need to create a new <strong class="source-inline">Repository</strong> for <strong class="source-inline">Comment</strong> that extends <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">CassandraRepository</strong></span><span class="No-Break">:</span><pre class="source-code">
public interface CommentRepository extends
<strong class="bold">CassandraRepository</strong>&lt;Comment, String&gt;{
}</pre><p class="list-inset">As is usual with Spring Data’s <strong class="source-inline">Repository</strong>, it provides some methods to manipulate <strong class="source-inline">Comment</strong> entities, such as <strong class="source-inline">findById</strong>, <strong class="source-inline">findAll</strong>, <strong class="source-inline">save</strong>, <span class="No-Break">and others.</span></p></li>				<li>As we will retrieve the comments when showing other entities, such as matches or players, we’ll need to create a method in <strong class="source-inline">CommentRepository</strong> to get the comments by the type of target and the <span class="No-Break">target itself:</span><pre class="source-code">
<strong class="bold">@AllowFiltering</strong>
List&lt;Comment&gt; findByTargetTypeAndTargetId(String targetType, String targetId);</pre><p class="list-inset">Note that as with<a id="_idIndexMarker746"/> other repositories in Spring Data, it can implement the interface by inferring the query from the <span class="No-Break">method name.</span></p><p class="list-inset">It is important to annotate the method with the <strong class="source-inline">@AllowFiltering</strong> annotation as we are not retrieving the data via the <span class="No-Break">primary key.</span></p></li>				<li>We can now create a service using <strong class="source-inline">CommentRepository</strong> to implement our application requirements. We’ll name the service <strong class="source-inline">CommentService</strong> and ensure it has the <span class="No-Break">following content:</span><pre class="source-code">
<strong class="bold">@Service</strong>
public class CommentService {
    private CommentRepository commentRepository;
    public CommentService(CommentRepository commentRepository){
        this.commentRepository = commentRepository;
    }
}</pre></li>				<li>Now, we must create the functionality. We will create a method to create a comment and a couple of methods to retrieve <span class="No-Break">all comments:</span><ul><li>We’ll use a record to receive the <span class="No-Break">comment data:</span><pre class="source-code">
public record CommentPost(String userId, String targetType, String targetId, String commentContent, Set&lt;String&gt; labels) {
}</pre></li><li>Let’s define<a id="_idIndexMarker747"/> the <strong class="source-inline">postComment</strong> method so that we can create a <span class="No-Break">new comment:</span><pre class="source-code">public Comment postComment(CommentPost commentPost) {
    Comment comment = new Comment();
    comment.setCommentId(UUID.randomUUID().toString());
    comment.setUserId(commentPost.userId());
    comment.setTargetType(commentPost.targetType());
    comment.setTargetId(commentPost.targetId());
    comment.setContent(commentPost.commentContent());
    comment.setDate(LocalDateTime.now());
    comment.setLabels(commentPost.labels());
    return commentRepository.<strong class="bold">save</strong>(comment);
}</pre></li><li>Now, we can create a method to retrieve <span class="No-Break">all comments:</span><pre class="source-code">public List&lt;Comment&gt; getComments() {
    return commentRepository.findAll();
}</pre></li><li>We can retrieve all comments in general, but it makes more sense to retrieve the comments related to another entity. For instance, it’s more common to get comments about <span class="No-Break">a player:</span><pre class="source-code">public List&lt;Comment&gt; getComments(String targetType,
                                 String targetId) {
    return commentRepository.findByTargetTypeAndTargetId(
                                          targetType, targetId);
}</pre></li></ul></li>				<li>Finally, we need to configure the application so that it can connect to our Cassandra server. In the <em class="italic">Getting ready</em> section of this recipe, I provided instructions to deploy it<a id="_idIndexMarker748"/> on your computer by using Docker, including how to create a Keyspace. To configure the application, create an <strong class="source-inline">application.yml</strong> file in the <strong class="source-inline">resources</strong> folder. Add the <span class="No-Break">following content:</span><pre class="source-code">
spring:
    cassandra:
        <strong class="bold">keyspace-name: footballKeyspace</strong>
        schema-action: CREATE_IF_NOT_EXISTS
        contact-points: localhost
        local-datacenter: datacenter1
        port: 9042</pre></li>				<li>We now have the components that are required to provide the comments functionality. We created <strong class="source-inline">CassandraRepository</strong> and we connected to a Cassandra server. I’ve created a RESTful API to consume this service. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">chapter6/recipe6-7/end</strong></span><span class="No-Break">.</span></li>
			</ol>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor303"/>How it works...</h2>
			<p>As we saw with other Spring Data projects, when you create an interface extending from <strong class="source-inline">CassandraRepository</strong>, Spring Data for Apache Cassandra generates an implementation and registers<a id="_idIndexMarker749"/> the implementation as a <em class="italic">bean</em> to make it available for the rest of <span class="No-Break">the components.</span></p>
			<p>It can generate the implementation using the naming convention and using the <strong class="bold">Cassandra Query Language</strong> (<strong class="bold">CQL</strong>) with the <strong class="source-inline">@Query</strong> annotation. Both ways generate an implementation using <a id="_idIndexMarker750"/>Cassandra templates, something that will be detailed in the <span class="No-Break">next recipe.</span></p>
			<p>We haven’t covered CQL yet, a <a id="_idIndexMarker751"/>syntactically similar language to SQL, but with important differences as Cassandra is a NoSQL technology. For instance, it doesn’t support <span class="No-Break"><strong class="bold">JOIN</strong></span><span class="No-Break"> queries.</span></p>
			<p>Note that in the <strong class="source-inline">findByTargetTypeAndTargetId</strong> method, we used <strong class="source-inline">@AllowFiltering</strong>. Cassandra is a NoSQL database that’s designed for high availability and scalability but it achieves these features by limiting the types of queries it can handle efficiently. Cassandra is optimized for fast retrieval of data based on the primary key or clustering columns. When you query data in Cassandra, it’s expected that you provide at least the primary key components to locate the <span class="No-Break">data efficiently.</span></p>
			<p>However, in some cases, you may need to perform queries that filter data on non-primary key columns. These types of queries are not efficient in Cassandra as they may require a full table scan and can be very slow on large datasets. You can use the <strong class="source-inline">@AllowFiltering</strong> annotation to explicitly indicate to Spring Data for Apache Cassandra that you’re aware of<a id="_idTextAnchor304"/> the performance implications and that you want to perform such a query despite its <span class="No-Break">potential inefficiency.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor305"/>See also</h2>
			<p>It is recommended that you get familiar with CQL if you plan to work with Cassandra. You can <a id="_idTextAnchor306"/>find more information about it on the project <span class="No-Break">page: </span><a href="https://cassandra.apache.org/doc/stable/cassandra/cql/"><span class="No-Break">https://cassandra.apache.org/doc/stable/cassandra/cql/</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor307"/>Using Testcontainers with Cassandra</h1>
			<p>To ensure the reliability of our application, we need to run integration tests with our Cassandra project. Similar to MongoDB, we have two options for running tests with Cassandra – either by using <a id="_idIndexMarker752"/>an in-memory embedded Cassandra server or Testcontainers. However, I recommend using Testcontainers with a Cassandra server as this eliminates any potential compatibility issues since it uses a real <span class="No-Break">Cassandra instance.</span></p>
			<p>In this recipe, we will learn <a id="_idIndexMarker753"/>how to use the Testcontainers Cassandra module to create integration tests for our <span class="No-Break">Comments service.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor308"/>Getting ready</h2>
			<p>In this recipe, we will create an integration test for the Comments service that we created in the <em class="italic">Connecting your application to Apache Cassandra</em> recipe. If you haven’t completed this recipe yet, you can use the project that I have prepared. You can find it in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-8/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor309"/>How to do it...</h2>
			<p>Are you ready to take your application to the next level? Let’s start preparing it so that it can run Testcontainers and see how we can <span class="No-Break">improve it!</span></p>
			<ol>
				<li>We’ll start by adding the Testcontainers dependencies to our <strong class="source-inline">pom.xml</strong> file – that is, the general Testcontainers dependency and the Cassandra <span class="No-Break">Testcontainers module:</span><pre class="source-code">
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;
    &lt;artifactId&gt;cassandra&lt;/artifactId&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></li>				<li>Next, create a file named <strong class="source-inline">createKeyspace.cql</strong> in the test <strong class="source-inline">resources</strong> folder. This file should <a id="_idIndexMarker754"/>contain the Cassandra Keyspace <span class="No-Break">creation command:</span><pre class="source-code">
CREATE KEYSPACE footballKeyspace WITH replication = {'class': 'SimpleStrategy'};</pre></li>				<li>Now, we can create a test class for our <strong class="source-inline">CommentService</strong>. You can name the test class <strong class="source-inline">CommentServiceTest</strong>. Before<a id="_idIndexMarker755"/> we start creating the test, we’ll need to set up the Testcontainer. For that, do <span class="No-Break">the following:</span><ol><li class="upper-roman">Annotate the test class <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">@Testcontainers</strong></span><span class="No-Break">:</span></li></ol><pre class="source-code">
<strong class="bold">@Testcontainers</strong>
@SpringBootTest
class CommentServiceTest</pre><ol><li class="upper-roman" value="2">Declare a static <span class="No-Break"><strong class="source-inline">CassandraContainer</strong></span><span class="No-Break"> field:</span><ul><li>Here, we’ll specify the Cassandra Docker image. We’ll use the default <span class="No-Break"><strong class="source-inline">cassandra</strong></span><span class="No-Break"> image.</span></li><li>We must apply the Cassandra script to be executed during the container initialization process – that is, <strong class="source-inline">createKeyspace.cql</strong>, which we defined in <span class="No-Break"><em class="italic">Step 2</em></span><span class="No-Break">.</span></li><li>We must also expose the port where Cassandra listens for connections – that is, <span class="No-Break">port </span><span class="No-Break"><strong class="source-inline">9042</strong></span><span class="No-Break">:</span></li></ul></li></ol><pre class="source-code">static CassandraContainer cassandraContainer = (CassandraContainer) new CassandraContainer("<strong class="bold">cassandra</strong>")
            .withInitScript("<strong class="bold">createKeyspace.cql</strong>")
            .withExposedPorts(<strong class="bold">9042</strong>);</pre><ol><li class="upper-roman" value="3">Before executing <a id="_idIndexMarker756"/>the tests, start the container. We’ll use the <strong class="source-inline">@BeforeAll</strong> annotation for <span class="No-Break">that purpose:</span></li></ol><pre class="source-code">@BeforeAll
static void startContainer() throws IOException, InterruptedException {
    cassandraContainer.start();
}</pre><ol><li class="upper-roman" value="4">The last Testcontainers configuration involves setting the Cassandra connection setting in the <a id="_idIndexMarker757"/>application context. For that, we’ll use <strong class="source-inline">@DynamicPropertySource</strong> and the properties that were provided by the <strong class="source-inline">cassandraContainer</strong> field we <span class="No-Break">declared previously:</span></li></ol><pre class="source-code"><strong class="bold">@DynamicPropertySource</strong>
static void setCassandraProperties(DynamicPropertyRegistry registry) {
    registry.add("spring.cassandra.keyspace-name", () -&gt; "footballKeyspace");
    registry.add("spring.cassandra.contact-points", () -&gt; cassandraContainer.getContactPoint().getAddress());
    registry.add("spring.cassandra.port", () -&gt; cassandraContainer.getMappedPort(9042));
    registry.add("spring.cassandra.local-datacenter", () -&gt; cassandraContainer.getLocalDatacenter());
}</pre></li>				<li>Now, we can create <a id="_idIndexMarker758"/>our integration test. Let’s name <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">postCommentTest</strong></span><span class="No-Break">:</span><pre class="source-code">
@Autowired
CommentService commentService;
@Test
void postCommentTest() {
    CommentPost comment = new CommentPost("user1", "player", "1", "The best!", Set.of("label1", "label2"));
    Comment result = commentService.postComment(comment);
    assertNotNull(result);
    assertNotNull(result.getCommentId());
}</pre></li>			</ol>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor310"/>How it works...</h2>
			<p>The <strong class="source-inline">org.testcontainers:cassandra</strong> dependency contains the <strong class="source-inline">CassandraContainer</strong> class, which provides most of the functionality required to set up the Testcontainer for our<a id="_idIndexMarker759"/> integration test. It allows us to specify the Docker image we want <span class="No-Break">to use.</span></p>
			<p>Here, <strong class="source-inline">withInitScript</strong> executes CQL scripts in Cassandra by taking a file from the test’s classpath. This simplifies execution as file copying and client tool availability are not a concern. We used this functionality to create the Keyspace, as we did in the <em class="italic">Getting ready</em> section of the <em class="italic">Connecting your application to Apache </em><span class="No-Break"><em class="italic">Cassandra</em></span><span class="No-Break"> recipe.</span></p>
			<p>We don’t need to manually check if the Container service is ready to accept connections. Testcontainers automatically waits until the service is ready to initiate <span class="No-Break">the tests.</span></p>
			<p>Finally, we used the properties exposed by the <strong class="source-inline">CassandraContainer</strong> class to configure the connection. We used the <strong class="source-inline">getContactPoint</strong> method to get the server host address, the <strong class="source-inline">getPort</strong> method<a id="_idIndexMarker760"/> to get the port exposed by the<a id="_idIndexMarker761"/> container, and the <strong class="source-inline">getLocalDatacenter</strong> method to get the simulated <span class="No-Break">datacenter name.</span></p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor311"/>Using Apache Cassandra templates</h1>
			<p>We may want to access our data hosted in <a id="_idIndexMarker762"/>Cassandra in a more flexible way than the one provided by <strong class="source-inline">CassandraRepository</strong>. For instance, we may want to retrieve data from our comments system using a dynamic or complex query, execute operations in batch, or access a low-level feature. In those cases, it is more convenient to use a Cassandra template as it provides more low-level access to <span class="No-Break">Cassandra’s features.</span></p>
			<p>In this recipe, we will implement functionality that will dynamically search comments using different parameters, such as a date range, tags, and so on. For that, we’ll use <span class="No-Break"><strong class="bold">Cassandra templates</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor312"/>Getting ready</h2>
			<p>We will use the same tools that we did in the <em class="italic">Connecting your application to Apache Cassandra</em> recipe – that is, Docker and <span class="No-Break">Apache Cassandra.</span></p>
			<p>To complete this recipe, you’ll need the project you created for the <em class="italic">Using Testcontainers with Cassandra</em> recipe. If you haven’t completed that recipe yet, don’t worry – you can use a full version of the project that I’ve prepared in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-9/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor313"/>How to do it...</h2>
			<p>In this recipe, we’ll enhance the Comment service we created in the previous recipe with new search functionality so that users can use as many parameters as <span class="No-Break">they want:</span></p>
			<ol>
				<li>First, we need to inject <strong class="source-inline">CassandraTemplate</strong> into our <strong class="source-inline">CommentService</strong> class. To do that, modify the constructor so that it makes the Spring Dependency Container <span class="No-Break">inject </span><span class="No-Break"><strong class="source-inline">CassandraTemplate</strong></span><span class="No-Break">:</span><pre class="source-code">
@Service
public class CommentService {
    private CommentRepository commentRepository;
    <strong class="bold">private CassandraTemplate cassandraTemplate;</strong>
    public CommentService(CommentRepository commentRepository,
<strong class="bold">                          CassandraTemplate cassandraTemplate</strong>) {
        this.commentRepository = commentRepository;
        this.cassandraTemplate = cassandraTemplate;
    }
}</pre></li>				<li>Now, add a new <a id="_idIndexMarker763"/>overloading for the <span class="No-Break"><strong class="source-inline">getComments</strong></span><span class="No-Break"> method:</span><pre class="source-code">
public List&lt;Comment&gt; getComments(String targetType,
                                 String targetId,
                                 Optional&lt;String&gt; userId,
                                 Optional&lt;LocalDateTime&gt; start,
                                 Optional&lt;LocalDateTime&gt; end,
                                 Optional&lt;Set&lt;String&gt;&gt; labels)</pre><p class="list-inset">This method has two types of parameters: mandatory <span class="No-Break">and optional.</span></p><p class="list-inset">We assume that users will always retrieve comments associated with a target entity – for instance, a player or a match. For that reason, the <strong class="source-inline">targetType</strong> and <strong class="source-inline">targetId</strong> parameters <span class="No-Break">are mandatory.</span></p><p class="list-inset">The rest of the parameters<a id="_idIndexMarker764"/> are optional; hence they are defined <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">Optional&lt;T&gt;</strong></span><span class="No-Break">.</span></p></li>				<li>In this new method, we will use the <strong class="source-inline">QueryBuilder</strong> component to create <span class="No-Break">our query:</span><pre class="source-code">
Select select = QueryBuilder.<strong class="bold">selectFrom</strong>("comment").all()
                .<strong class="bold">whereColumn</strong>("targetType")
                .isEqualTo(QueryBuilder.literal(targetType))
                .<strong class="bold">whereColumn</strong>("targetId")
                .isEqualTo(QueryBuilder.literal(targetId));</pre><p class="list-inset">Here, we selected the <strong class="source-inline">comment</strong> table by using <strong class="source-inline">selectFrom</strong>, and we set the mandatory columns, <strong class="source-inline">targetType</strong>, and <strong class="source-inline">targetId</strong>, by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">whereColumn</strong></span><span class="No-Break">.</span></p><p class="list-inset">The rest of the optional fields will use <strong class="source-inline">whereColumn</strong>, but only if they <span class="No-Break">are</span><span class="No-Break"> provided:</span></p><pre class="source-code">if (userId.isPresent()) {
          select = select.whereColumn("userId")
                   .isEqualTo(QueryBuilder.literal(userId.get()));
}
if (start.isPresent()) {
    select = select.whereColumn("date")
                   .isGreaterThan(QueryBuilder
                       .literal(start.get().toString()));
}
if (end.isPresent()) {
    select = select.whereColumn("date")
                   .isLessThan(QueryBuilder
                       .literal(end.get().toString()));
}
if (labels.isPresent()) {
    for (String label : labels.get()) {
        select = select.whereColumn("labels")
                       .contains(QueryBuilder.literal(label));
    }
}</pre></li>				<li>Finally, we can use <a id="_idIndexMarker765"/>the query with <strong class="source-inline">CassandraTemplate</strong> by using the <strong class="source-inline">select</strong> method. Let’s <span class="No-Break">do it:</span><pre class="source-code">
return<strong class="bold"> cassandraTemplate</strong>.select(select.<strong class="bold">allowFiltering</strong>().build(),
                                Comment.class);</pre><p class="list-inset">Here, we used <strong class="source-inline">allowFiltering</strong>. Since we are not using the primary key, we need to tell Cassandra that we assume that the query is <span class="No-Break">potentially inefficient.</span></p></li>				<li>We implemented the new feature for our Comment service to perform dynamic queries using <strong class="source-inline">CassandraTemplate</strong>. Now, you can create a RESTful API interface to interact with the new feature. I’ve created a sample RESTful API that uses the new feature and prepared integration tests for the Comments service. You can find these in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-9/end</strong></span><span class="No-Break"> folder.</span></li>
			</ol>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor314"/>How it works...</h2>
			<p>Spring Data for Apache Cassandra registers a <strong class="source-inline">CassandraTemplate</strong> bean in the Spring Boot Dependency Container. It is used internally to implement the repositories described in the <em class="italic">Connecting your application to Apache Cassandra</em> recipe. By doing this, it can be injected into our components by <span class="No-Break">Spring Boot.</span></p>
			<p>You can compose a CQL string by<a id="_idIndexMarker766"/> concatenating the predicates, but this is prone to introducing typos in queries. That’s why we used <strong class="source-inline">QueryBuilder</strong>. As I explained in the <em class="italic">Connecting your applic<a id="_idTextAnchor315"/>ation to Apache Cassandra</em> recipe, we need to set <strong class="source-inline">allowFiltering</strong> when we make queries that don’t use the table <span class="No-Break">primary key.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor316"/>There’s more...</h2>
			<p>We can do the same query by building a string with a dynamic CQL statement. This would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
public List&lt;Comment&gt; getCommentsString(String targetType,
                                       String targetId,
                                       Optional&lt;String&gt; userId,
                                       Optional&lt;LocalDateTime&gt; start,
                                       Optional&lt;LocalDateTime&gt; end,
                                       Optional&lt;Set&lt;String&gt;&gt; labels) {
    String query = "SELECT * FROM comment WHERE targetType ='"
                   + targetType + "' AND targetId='" + targetId + "'";
    if (userId.isPresent()) {
        query += " AND userId='" + userId.get() + "'";
    }
    if (start.isPresent()) {
        query += " AND date &gt; '" + start.get().toString() + "'";
    }
    if (end.isPresent()) {
        query += " AND date &lt; '" + end.get().toString() + "'";
    }
    if (labels.isPresent()) {
        for (String label : labels.get()) {
           query += " AND labels CONTAINS '" + <a id="_idTextAnchor317"/>label + "'";
        }
    }
    query += " ALLOW FILTERING";
    return cassandraTemplate.select(query, Comment.class);
}</pre>			<h1 id="_idParaDest-289"><a id="_idTextAnchor318"/>Managing concurrency with Apache Cassandra</h1>
			<p>We want to enhance our <a id="_idIndexMarker767"/>comments system by adding a new feature: upvoting comments. We will add a counter to our comments showing the positive votes that have <span class="No-Break">been received.</span></p>
			<p>This simple requirement can <a id="_idIndexMarker768"/>be complex in a high-concurrency scenario. If multiple users are upvoting a comment, it may happen that we aren’t updatin<a id="_idTextAnchor319"/>g the latest version of the comment. To tackle this scenario, we will use an optimistic concurrency approach <span class="No-Break">with Cassandra.</span></p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor320"/>Getting ready</h2>
			<p>We will use the same tools that we did in the <em class="italic">Connecting your application to Apache Cassandra</em> recipe – that is, Docker and <span class="No-Break">Apache Cassandra.</span></p>
			<p>The starting point will be the project we created for the <em class="italic">Using Apache Cassandra Templates</em> recipe. If you haven’t completed it yet, don’t worry – you can use a full version of the project that I’ve prepared in this book’s GitHub reposito<a id="_idTextAnchor321"/>ry at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>. It can be found in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-10/start</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor322"/>How to do it...</h2>
			<p>In this recipe, we will implement the upvoting feature using optimistic concurrency. But before that, we’ll need to prepare our comment entity. Let’s <span class="No-Break">get started:</span></p>
			<ol>
				<li>The first thing we’ll need to do is create a new field that will store the number of upvotes received by a comment. So, let’s modify the <strong class="source-inline">Comment</strong> class by adding a new field <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">upvotes</strong></span><span class="No-Break">:</span><pre class="source-code">
private Integer upvotes;</pre></li>				<li>We’ll need to modify the table schema in the Cassandra server. For that, we’ll need to connect to the server and execute a <strong class="source-inline">cqlsh</strong> command. The easiest way to do this is by connecting to the Docker container. The following command will open an interactive session <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">cqlsh</strong></span><pre class="source-code">
docker exec -it cassandra cqlsh</pre><p class="list-inset">Ensure that <strong class="source-inline">cqlsh</strong> is in <strong class="source-inline">footballKeyspace</strong>. To do so, execute the following command <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">cqlsh</strong></span><span class="No-Break">:</span></p><pre class="source-code">USE footballKeyspace;</pre><p class="list-inset">Now, alter the table <a id="_idIndexMarker769"/>comment to add the new <strong class="source-inline">upvotes</strong> column. For that, execute the<a id="_idIndexMarker770"/> following command <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">cqlsh</strong></span><span class="No-Break">:</span></p><pre class="source-code">ALTER TABLE Comment ADD upvotes int;</pre><p class="list-inset">Now, you can exit <strong class="source-inline">cqlsh</strong> by executing the <span class="No-Break"><strong class="source-inline">quit;</strong></span><span class="No-Break"> command.</span></p><p class="list-inset">It isn’t possible to assign default values in Cassandra. If you have existing comments in your database, Cassandra will return a <strong class="source-inline">null</strong> value for field upvotes. So, we’ll need to manage this <span class="No-Break">scenario accordingly.</span></p></li>				<li>Now, it’s time to use the new field in a new operation. We’ll implement that operation in our <strong class="source-inline">CommentService</strong> service by creating a new method <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">upvoteComment</strong></span><span class="No-Break">:</span><pre class="source-code">
public Comment upvoteComment(String commentId) {</pre><p class="list-inset">Next, we’ll retrieve the first comment. We can use the existing <strong class="source-inline">CommentRepository</strong> or <strong class="source-inline">CassandraTemplate</strong>. We’ll use <strong class="source-inline">CommentRepository</strong> as it <span class="No-Break">is simpler:</span></p><pre class="source-code">Comment comment =
commentRepository.findByCommentId(commentId).get();</pre><p class="list-inset">Now, we need to update the upvotes field, but we’ll keep the <span class="No-Break">current value:</span></p><pre class="source-code">Integer currentVotes = comment.getUpvotes();
if (currentVotes == null) {
    comment.setUpvotes(1);
} else {
    comment.setUpvotes(currentVotes + 1);
}</pre><p class="list-inset">Next, we’ll use the current value to <a id="_idIndexMarker771"/>create the condition. Only if we are updating the current value will<a id="_idIndexMarker772"/> we apply <span class="No-Break">the change:</span></p><pre class="source-code">CriteriaDefinition ifCriteria =<strong class="bold"> Criteria</strong>
<strong class="bold">                               .where(ColumnName.from("upvotes"))</strong>
<strong class="bold">                               .is(currentVotes);</strong>
EntityWriteResult&lt;Comment&gt; result = cassandraTemplate
                               .<strong class="bold">update</strong>(comment,
                                   <strong class="bold">UpdateOptions.builder()</strong>
<strong class="bold">                                   .ifCondition(ifCriteria)</strong>
<strong class="bold">                                   .build());</strong></pre><p class="list-inset">Now, we need to check if the result was what <span class="No-Break">we expected:</span></p><pre class="source-code">if (result.<strong class="bold">wasApplied</strong>()) {
    return result.getEntity();
}</pre><p class="list-inset">If the result is not what we expected, we can retry the operation a few times while waiting a few milliseconds between executions, but this will depend on the requirements of <span class="No-Break">the application.</span></p></li>			</ol>
			<p>Now, you can implement a RESTful API for this new functionality. I’ve prepared a sample RESTful API and integration tests in this <a id="_idTextAnchor323"/>book’s GitHub repository at <a href="https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/">https://github.com/PacktPublishing/Spring-Boot-3.0-Cookbook/</a>, in the <span class="No-Break"><strong class="source-inline">chapter6/recipe6-10/end</strong></span><span class="No-Break"> folder.</span></p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor324"/>How it works...</h2>
			<p>The key to optimistic concurrency management in Cassandra is the conditional update command. In CQL, Cassandra provides an <strong class="source-inline">IF</strong> clause that we can use in <strong class="source-inline">CassandraTemplate</strong>. With this <strong class="source-inline">IF</strong> clause, you can conditionally update data, but only if certain conditions are met, which<a id="_idIndexMarker773"/> includes checking the current state of <span class="No-Break">the data.</span></p>
			<p>We could create a <strong class="source-inline">version</strong> field in<a id="_idIndexMarker774"/> the comments table to implement a mechanism, as we saw in the <em class="italic">Managing concurrency with MongoDB</em> recipe. However, Spring Data for Apache Cassandra does not provide any special capability to manage this automatically, so we would need to implement it ourselves. In addition, we don’t expect any other change in the <strong class="source-inline">comment</strong> entity, so we can use upvotes to control if the row has been modified. The <strong class="source-inline">upvotes</strong> field is our <span class="No-Break"><strong class="source-inline">version</strong></span><span class="No-Break"> field.</span></p>
		</div>
	

		<div class="Content" id="_idContainer086">
			<h1 id="_idParaDest-293" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor325"/>Part 3: Application Optimization</h1>
			<p>In large-scale applications, it’s necessary to understand where the bottlenecks are and how they can be improved. In this part, we’ll follow a systematic approach to optimizing and measuring the improvements that we apply. We’ll also use advanced techniques such as reactive programming and <span class="No-Break">event-driven design.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B21646_07.xhtml#_idTextAnchor326"><em class="italic">Chapter 7</em></a>, <em class="italic">Finding Bottlenecks and Optimizing Your Application</em></li>
				<li><a href="B21646_08.xhtml#_idTextAnchor365"><em class="italic">Chapter 8</em></a>, <em class="italic">Spring Reactive and Spring Cloud Stream</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer087">
			</div>
		</div>
		<div>
			<div class="Basic-Graphics-Frame" id="_idContainer088">
			</div>
		</div>
	</body></html>