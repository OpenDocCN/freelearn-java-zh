<html><head></head><body>
		<div id="_idContainer049">
			<h1 class="chapter-number" id="_idParaDest-74"><a id="_idTextAnchor122"/>6</h1>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor123"/>NoSQL in Java Demystified – One API to Rule Them All</h1>
			<p>NoSQL databases have gained significant popularity recently, and this chapter explores why they deserve more attention. With the evolution of software and increased diverse requirements, NoSQL databases offer an easier route to success. Using the Jakarta standard, this persistence type is helpful in various areas, including more traditional sectors such as finance. NoSQL databases provide flexible data modeling, horizontal scaling, and better performance, among other advantages. As a result, they are suitable for managing large amounts of structured or unstructured data and have become a popular choice for modern applications. This chapter will guide us on how to use NoSQL databases with Java, helping developers exploit their features <span class="No-Break">and capabilities.</span></p>
			<p>We will cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Understanding NoSQL <span class="No-Break">database trade-offs</span></li>
				<li>Consuming NoSQL databases with <strong class="bold">Jakarta </strong><span class="No-Break"><strong class="bold">NoSQL</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">JNoSQL</strong></span><span class="No-Break">)</span></li>
				<li><span class="No-Break">Graph databases</span></li>
			</ul>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor124"/>Technical requirements</h1>
			<p>The following are required for <span class="No-Break">this chapter</span></p>
			<ul>
				<li><span class="No-Break">Java 17</span></li>
				<li><span class="No-Break">Git</span></li>
				<li><span class="No-Break">Maven</span></li>
				<li><span class="No-Break">Docker</span></li>
				<li>Any <span class="No-Break">preferred IDE</span></li>
				<li>The code for this chapter can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06"><span class="No-Break">https://github.com/PacktPublishing/Persistence-Best-Practices-for-Java-Applications/tree/main/chapter-06</span></a><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor125"/>Understanding NoSQL database trade-offs</h1>
			<p>NoSQL databases are <a id="_idIndexMarker226"/>popular, including several persistence solutions offered by the top database engines. It is essential to remember that NoSQL databases do not eliminate the need for <span class="No-Break">relational databases.</span></p>
			<p>SQL databases remain crucial to most enterprise solutions. They are where people more often start to learn to program, and there are numerous articles and books written on <span class="No-Break">the topic.</span></p>
			<p>Furthermore, the maturity of the products that use SQL is vast! Those products can help you with crucial tasks, such as backups, migrations, and <span class="No-Break">query analysis.</span></p>
			<p>The goal is not to demotivate you from using NoSQL. However, once you are a senior engineer, remember the second law of software architecture mentioned in <em class="italic">Fundamentals of Software Architecture: An Engineering Approach</em> by Neal Ford: everything has <span class="No-Break">a trade-off!</span></p>
			<p>Consider that, and let’s move on to the <span class="No-Break">NoSQL database.</span><a id="_idTextAnchor126"/></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor127"/>Consuming NoSQL databases with JNoSQL</h1>
			<p>We are lucky <a id="_idIndexMarker227"/>to have several solutions<a id="_idIndexMarker228"/> and success cases in the Java platform. Thus, the next step is to create a standard API as soon as this <span class="No-Break">technology matures.</span></p>
			<p>The JNoSQL specification aims to simplify the communication between Java and <span class="No-Break">NoSQL databases.</span></p>
			<p>The benefit of standardizing the behavior and interface of multiple NoSQL databases is code portability and ease of integration. We usually talk about switching the database, which is true. However, the most significant advantage is to make it easier for everybody to work on a project. When it is required, you can switch <span class="No-Break">databases naturally.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer045">
					<img alt="Figure 6.1: NoSQL databases – document type" src="image/Figure_6.01_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1: NoSQL databases – document type</p>
			<p>There are<a id="_idIndexMarker229"/> great <a id="_idIndexMarker230"/>benefits to using a standard API; furthermore, you can use particular behavior, such as <strong class="bold">Cassandra Query Language</strong> (<strong class="bold">CQL</strong>) for <a id="_idIndexMarker231"/>Cassandra <a id="_idIndexMarker232"/>and <strong class="bold">ArangoDB Query Language </strong>(<strong class="bold">AQL</strong>)  <span class="No-Break">for ArangoDB.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer046">
					<img alt="Figure 6.2: NoSQL databases – document type with a single API" src="image/Figure_6.02_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2: NoSQL databases – document type with a single API</p>
			<p>This is the main principle of JNoSQL, to simplify and make your and your organization’s life easier when it comes to Java and NoSQL databases. On the spec side, you can explore your entities; for example, with JPA, you can use annotations to operate with several NoSQL database types, such as document, column, graph, and key-value. See how the same annotations work in several <span class="No-Break">document databases:</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer047">
					<img alt="Figure 6.3: JNoSQL abstraction for multiple database integrations" src="image/Figure_6.03_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3: JNoSQL abstraction for multiple database integrations</p>
			<p>The spec supports <a id="_idIndexMarker233"/>the<a id="_idIndexMarker234"/> most popular NoSQL types: key-value, document, wide-column or other column types, <span class="No-Break">and g<a id="_idTextAnchor128"/>raph.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor129"/>Key-value databases</h2>
			<p>Starting with the<a id="_idIndexMarker235"/> simplest<a id="_idIndexMarker236"/> one: key-value. This NoSQL solution flavor has a structure that looks like a map. Thus, you can generally find information from the key, and the value is a blob. Each vendor has a different way of serializing and storing the value, such as text, JSON, or <span class="No-Break">binary JSON.</span></p>
			<p>Using the library system, we can use this database to save the user settings information; thus, we’ll create a <strong class="source-inline">User</strong> entity to preserve the language <span class="No-Break">and categories.</span></p>
			<p>To provide an example of this model, we’ll follow a simple Java SE application with JNoSQL. We will use the most popular key-value database <span class="No-Break">solution: Redis.</span></p>
			<p>Defining the configuration of Redis in production would require its own book; we’ll install this sample locally, but please, if working in production, check the Redis documentation for more details. For now, once you have Docker configured, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
docker run --name redis-instance -p 6379:6379 -d redis</pre>			<p>The server is running; the next step is to add dependencies to our project. This sample uses the Maven project, so we’ll add the mapping dependency and the <span class="No-Break">Redis driver:</span></p>
			<pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;org.eclipse.jnosql.mapping&lt;/groupId&gt;
    &lt;artifactId&gt;jnosql-mapping-key-value&lt;/artifactId&gt;
    &lt;version&gt;${jnosql.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.jnosql.communication&lt;/groupId&gt;
    &lt;artifactId&gt;jnosql-redis-driver&lt;/artifactId&gt;
    &lt;version&gt;${jnosql.version}&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>With the dependencies<a id="_idIndexMarker237"/> ready, the <a id="_idIndexMarker238"/>next step is to create the <strong class="source-inline">User</strong> entities with the annotations to map to a key-value database. It requires an annotation to define as a JNoSQL entity and the key, where you’ll set the <strong class="source-inline">Entity</strong> and <strong class="source-inline">Id</strong> <span class="No-Break">annotations, respectively:</span></p>
			<pre class="source-code">
@Entitypublic class User {
    @Id
    private String userName;
    private String name;
    private Set&lt;String&gt; languages;
    private Set&lt;String&gt; categories;
  //...
}</pre>
			<p>The <strong class="source-inline">Entity</strong> and <strong class="source-inline">Id</strong> annotations are used when defining the <strong class="source-inline">User</strong> entity class and the <strong class="source-inline">userName</strong> <span class="No-Break">field, respectively.</span></p>
			<p>Let’s execute it. <strong class="source-inline">KeyValueTemplate</strong> is the instance we use to operate a key-value database; it is the<a id="_idIndexMarker239"/> lowest<a id="_idIndexMarker240"/> level of <span class="No-Break">mapping communication:</span></p>
			<pre class="source-code">
public static void main(String[] args) {    User otavio = User.builder().userName("otaviojava")
            .name("Otavio Santana")
            .category("Technology")
            .category("Philosophy")
            .category("History")
            .language("English")
            .language("Portuguese")
            .language("French").build();
    try (SeContainer container =
      SeContainerInitializer.newInstance().initialize()) {
        KeyValueTemplate template =
          container.select(KeyValueTemplate.class).get();
        User userSaved = template.put(otavio);
        System.out.println("User saved: " + userSaved);
        Optional&lt;User&gt; user = template.get("otaviojava",
          User.class);
        System.out.println("Entity found: " + user);
        template.delete("otaviojava");
    }
}</pre>
			<p>The queries on this database type have limitations, but it is powerful. The <strong class="bold">Time To Live</strong> (<strong class="bold">TTL</strong>) is a<a id="_idIndexMarker241"/> feature<a id="_idIndexMarker242"/> used to define<a id="_idIndexMarker243"/> the expiration time of the information in <span class="No-Break">a database:</span></p>
			<pre class="source-code">
public static void main(String[] args) throws  InterruptedException {
    User poliana = User.builder()
            .userName("poly")
            .name("Poliana Santana")
            .category("Philosophy")
            .category("History")
            .language("English")
            .language("Portuguese")
            .build();
    try (SeContainer container = SeContainerInitializer
      .newInstance().initialize()) {
        KeyValueTemplate template = container
          .select(KeyValueTemplate.class).get();
        template.put(poliana, Duration.ofSeconds(1));
        System.out.println("The key return: " +
          template.get("poly", User.class));
        TimeUnit.SECONDS.sleep(2L);
        System.out.println("Entity after expired: " +
          template.get("poly", User.class));
        template.delete("poly");
    }
}</pre>
			<p>But wait, where is the<a id="_idIndexMarker244"/> configuration? The <a id="_idIndexMarker245"/>JNoSQL implementation uses Eclipse MicroProfile configuration to preserve good software practices, such as <span class="No-Break">twelve-factor app.</span></p>
			<p>In this sample, we’ll put the properties in the <strong class="source-inline">property</strong> file, but we can overwrite the system environment or include more configurations, such as a username <span class="No-Break">and password:</span></p>
			<pre class="source-code">
jnosql.keyvalue.database=developersjnosql.redis.port=6379
jnosql.redis.host=localhost</pre>
			<p>The key-value is a strong ally when you want to save entities that should be fast to read/write. These solutions usually work in memory with a snapshot to avoid data loss if the server <span class="No-Break">goes down.</span></p>
			<p>Like any technology solution, there are trade-offs to consider. For example, while it is possible to retrieve information using an ID and return the value as a unique blob, this approach may<a id="_idIndexMarker246"/> not be<a id="_idIndexMarker247"/> ideal in all situations. Therefore, let’s explore the next type of solution to a<a id="_idTextAnchor130"/>ddress <span class="No-Break">this issue.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor131"/>Column databases</h2>
			<p>The following database <a id="_idIndexMarker248"/>type is<a id="_idIndexMarker249"/> the wide-column type, which follows the same principles as key-value, but instead of a unique blob, you can split the information into <span class="No-Break">small columns.</span></p>
			<p>This NoSQL database is also known as a two-dimensional key-value store. The most popular implementation is Apache Cassandra; this section will cover an integration between Java and <span class="No-Break">Apache Cassandra.</span></p>
			<p>As mentioned, we won’t cover tips for running in production; for now, we’ll run a single instance for <span class="No-Break">test purposes:</span></p>
			<pre class="source-code">
docker run -d --name cassandra-instance -p 9042:9042 cassandra</pre>			<p class="callout-heading">Tip</p>
			<p class="callout">When running a Cassandra instance with Docker, please don’t run it this way in production. This configuration is best for your test environment. For production use, go to the Apache Cassandra documentation on the <span class="No-Break">Apache website.</span></p>
			<p>We’ll follow the same idea of configuration, so we’ll use Java and Maven projects. The first step on the Java side is to add dependencies to the <span class="No-Break">Maven project:</span></p>
			<pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;org.eclipse.jnosql.mapping&lt;/groupId&gt;
    &lt;artifactId&gt;jnosql-cassandra-extension&lt;/artifactId&gt;
    &lt;version&gt;${jnosql.version}&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>This dependency seems different because it is a Cassandra extension; it is the column API plus behavior specific to Cassandra, such as CQL. If you wish, you can use it as we did with Redis, but you cannot use Cassandra-specific <span class="No-Break">behavior easily:</span></p>
			<pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;org.eclipse.jnosql.communication&lt;/groupId&gt;
    &lt;artifactId&gt;jnosql-cassandra-driver&lt;/artifactId&gt;
    &lt;version&gt;${jnosql.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.eclipse.jnosql.mapping&lt;/groupId&gt;
    &lt;artifactId&gt;jnosql-mapping-column&lt;/artifactId&gt;
    &lt;version&gt;${project.version}&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>This NoSQL database works differently from SQL. Indeed, denormalization is your <span class="No-Break">best friend.</span></p>
			<p>First, visualize the<a id="_idIndexMarker250"/> model. Then<a id="_idIndexMarker251"/>, create it. We want to track and view the rental records of a user with a particular ID who <span class="No-Break">rents books:</span></p>
			<pre class="source-code">
@Entity("rental")public class RentalBook {
    @Id("id")
    private UUID id;
    @Column
    private LocalDate date;
    @Column
    @UDT("user")
    private User user;
    @Column
    @UDT("book")
    private Set&lt;Book&gt; books = new HashSet&lt;&gt;();
}
@Entity
public class User {
    @Column
    private String username;
    @Column
    private String name;
}
@Entity
public class Book {
    @Column
    private UUID id;
    @Column
    private String title;
}</pre>
			<p>That’s it for the model; from the ID, we can return the track record of a book rental. We’re replicating information such as the book’s title and the user’s name to avoid any joins or more processes, but once a field has been updated, we need to run an event in the background to <span class="No-Break">update it.</span></p>
			<p>The <strong class="source-inline">User</strong> and <strong class="source-inline">Book</strong> entities are user-defined types, where we can add multiple values to a <span class="No-Break">single column.</span></p>
			<p>Despite JPA, JNoSQL must define each field to be stored using either a <strong class="source-inline">Column</strong> or <span class="No-Break"><strong class="source-inline">Id</strong></span><span class="No-Break"> annotation.</span></p>
			<p>Let’s execute the<a id="_idIndexMarker252"/> code, as <a id="_idIndexMarker253"/>essentially we can use the same principles and behavior that we did with key-value. We can also select the fields to return in a query instead of always <span class="No-Break">returning everything:</span></p>
			<pre class="source-code">
try(SeContainer container =  SeContainerInitializer.newInstance().initialize()) {
        RentalBook otavio = RentalBook.builder()
                .id(UUID.randomUUID())
                .date(LocalDate.now())
                .user(User.of("otaviojava", "Otavio
                   Santana"))
                .book(Book.of(UUID.randomUUID(), "Clean
                   Code"))
                .book(Book.of(UUID.randomUUID(), "Effective
                   Java"))
                .build();
        RentalBook karina = RentalBook.builder()
                .id(UUID.randomUUID())
                .date(LocalDate.now())
                .user(User.of("kvarel4", "Karina Varela"))
                .book(Book.of(UUID.randomUUID(), "Clean
                Arch"))
                .build();
        ColumnTemplate template =  container
          .select(CassandraTemplate.class).get();
        template.insert(List.of(otavio, karina),
          Duration.ofDays(600L));
        ColumnQuery query = ColumnQuery.select("id",
          "date").from("rental")
                .where("id").eq(karina.getId()).build();
        System.out.println("Executing query using API: ");
        template.select(query).forEach(System.out::println);
        System.out.println("Executing query using text: ");
        template.query("select * from rental")
          .forEach(System.out::println);
    }</pre>
			<p>Cassandra is not schemaless, although you need to create the schema before using it. Running the query locally is OK, but don’t use it in production. This is because it takes time to start and run it in production. The following code shows a configuration for <span class="No-Break">using Cassandra:</span></p>
			<pre class="source-code">
jnosql.column.database=libraryjnosql.cassandra.query.1=CREATE KEYSPACE IF NOT EXISTS library WITH replication = {'class': 'SimpleStrategy', 'replication_factor' : 3};
jnosql.cassandra.query.2=CREATE TYPE IF NOT EXISTS library.user (username text, name text);
jnosql.cassandra.query.3=CREATE TYPE IF NOT EXISTS library.book (id uuid, title text );
jnosql.cassandra.query.4=CREATE COLUMNFAMILY IF NOT EXISTS library.rental (id uuid PRIMARY KEY, date text, user user, books frozen&lt;set&lt;book&gt;&gt;);</pre>
			<p>Compared to<a id="_idIndexMarker254"/> key-value, wide-column<a id="_idIndexMarker255"/> has more flexibility in the model. But we still have the issue of searching fields that are not an ID; how can we solve this? Let’s move on to the following database type to answer <span class="No-Break">this question.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Cassandra has a secondary index for allowing querying outside the key. Pay attention because there are several <a id="_idTextAnchor132"/>implications for <span class="No-Break">using it.</span></p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor133"/>Document databases</h2>
			<p>Our third NoSQL type <a id="_idIndexMarker256"/>can search <a id="_idIndexMarker257"/>for fields aside from the ID; good news! The document NoSQL type has an XML or JSON structure. Searching for the ID is still the more efficient way, but being able to search for information through other fields gives the model more flexibility and makes it easier to explore the information in the database <span class="No-Break">as well.</span></p>
			<p>For this sample, we’ll use MongoDB for the implementation. We’ll run a single node locally. Please, pay attention when running this in production; but for now, we’ll run it from a <span class="No-Break">Docker image:</span></p>
			<pre class="source-code">
docker run -d --name mongodb-instance -p 27017:27017 mongo</pre>			<p>As the Maven dependency, we’ll add the <span class="No-Break">MongoDB extension:</span></p>
			<pre class="source-code">
&lt;dependency&gt;    &lt;groupId&gt;org.eclipse.jnosql.mapping&lt;/groupId&gt;
    &lt;artifactId&gt;jnosql-mongodb-extension&lt;/artifactId&gt;
    &lt;version&gt;${jnosql.version}&lt;/version&gt;
&lt;/dependency&gt;</pre>
			<p>In this sample, we’ll show the book items inside the store. The model is similar to wide-column in that it is <a id="_idIndexMarker258"/>query-driven, but we have more flexibility to search this time. The model follows the DDD principle, with <strong class="source-inline">Book</strong> as the entity and <strong class="source-inline">Author</strong> as the <span class="No-Break">value object:</span></p>
			<pre class="source-code">
@Entitypublic class Book {
    @Id
    private String id;
    @Column
    private String title;
    @Column
    private List&lt;String&gt; categories;
    @Column
    private Set&lt;String&gt; languages;
    @Column
    private Author author;
 }
 @Entity
public record Author(@Column("nickname") String nickname,
  @Column("name") String name, @Column("profile") String
     profile) {
    public static AuthorBuilder builder() {
        return new AuthorBuilder();
    }
}</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you are using an immutable value object, it is an excellent candidate to use to explore the newest feature from <span class="No-Break">Java: records.</span></p>
			<p>The model is ready <a id="_idIndexMarker259"/>to explore; thus, we’ll <a id="_idIndexMarker260"/>run it on Java SE and explore <strong class="source-inline">DocumentTemplate</strong>, which follows the same principle as the previous database flavors – being a bridge between Java and <span class="No-Break">the database:</span></p>
			<pre class="source-code">
try (SeContainer container =  SeContainerInitializer.newInstance().initialize()) {
    Author otavio = Author.builder()
      .nickname("otaviojava").name("Otavio Santana")
        .profile("@otaviojava").build();
    Book cassandra = Book.builder()
            .title("Apache Cassandra Horizontal scalability
              for Java applications")
            .category("database").category("technology")
            .language("Portuguese").language("English")
            .author(otavio).build();
    DocumentTemplate template = container
      .select(DocumentTemplate.class).get();
    template.insert(cassandra);
    System.out.println("The database found: " +
      template.find(Book.class, cassandra.getId()));
    template.delete(Book.class, cassandra.getId());
}</pre>
			<p>The power of documents is similar to relational databases, but we don’t have the same powerful transactions as SQL and JOINs. Even with this limitation, we can order elements<a id="_idIndexMarker261"/> from <span class="No-Break">any</span><span class="No-Break"><a id="_idIndexMarker262"/></span><span class="No-Break"> field:</span></p>
			<pre class="source-code">
try (SeContainer container =  SeContainerInitializer.newInstance().initialize()) {
    Author neal = Author.builder()
      .nickname("neal").name("Neal Ford")
         .profile("@neal4d").build();
    Book evolutionary = Book.builder()
            .title("Building Evolutionary Architectures:
              Support Constant Change")
            .category("architecture")
            .category("technology")
            .language("Portuguese").language("English")
            .author(neal).build();
//...
    DocumentTemplate template = container
      .select(DocumentTemplate.class).get();
    template.insert(evolutionary);
    DocumentQuery query = DocumentQuery
       .select().from("Book")
                    .where("author.nickname").eq("neal")
                    .orderBy("title").asc().build();
    System.out.println("The query by API");
    template.select(query).forEach(System.out::println);
}</pre>
			<p>The properties for running the sample will follow the same core idea to take advantage of the <span class="No-Break">twelve-factor app:</span></p>
			<pre class="source-code">
jnosql.document.database=libraryjnosql.mongodb.host=localhost:27017</pre>
			<p>The flexibility the document NoSQL type has in querying is terrific! But what about the relationship <a id="_idIndexMarker263"/>between <a id="_idIndexMarker264"/>entities? This kind of query is required at some point, so how can we solve it? Let’s look a<a id="_idTextAnchor134"/>t the last NoSQL type and <span class="No-Break">find out.</span></p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor135"/>Graph databases</h2>
			<p>If you’re looking<a id="_idIndexMarker265"/> for a <a id="_idIndexMarker266"/>relationship, you have come to the right place! Let’s talk about graph databases. A graph database is a powerful engine with a graph structure that saves information based on vertices and edges, where an edge is an object to hold the <span class="No-Break">relationship information.</span></p>
			<p>Using an edge, you can define a relationship’s direction and properties; it is even more potent than a <span class="No-Break">relational database.</span></p>
			<p>Let’s create a simple recommendation engine with a person who can read/write and <span class="No-Break">meet people.</span></p>
			<div>
				<div class="IMG---Figure" id="_idContainer048">
					<img alt="Figure 6.4: The relationships between people and books" src="image/Figure_6.04_B19375.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4: The relationships between people and books</p>
			<p>The first thing to do<a id="_idIndexMarker267"/> is ensure <a id="_idIndexMarker268"/>that we have at least a single instance running; remember, this is not the proper way to run <span class="No-Break">in production:</span></p>
			<pre class="source-code">
docker run --publish=7474:7474 --publish=7687:7687 --env NEO4J_AUTH=neo4j/admin neo4j</pre>			<p>We’ll have two entities: <strong class="source-inline">Book</strong> and <strong class="source-inline">Person</strong>. A person can write N books, read N books, and meet N. A tree hierarchy and a meta-relationship indicate a graph database when we have multiple <span class="No-Break">N-to-N relationships:</span></p>
			<pre class="source-code">
@Entitypublic class Book {
    @Id
    private Long id;
    @Column
    private String name;
}
@Entity
public class Person {
    @Id
    private Long id;
    @Column
    private String name;
    @Column
    private String profile;
}
@Entity
public class Category {
    @Id
    private Long id;
    @Column
    private String name;
}</pre>
			<p>The graph also has a <strong class="source-inline">GraphTemplate</strong> instance where you can operate with the <span class="No-Break">graph database.</span></p>
			<p>This sample will <a id="_idIndexMarker269"/>use a <strong class="source-inline">LibraryGraph</strong> to <a id="_idIndexMarker270"/>operate all the operations on this system. Be ready to refactor <a id="_idIndexMarker271"/>it as it gets bigger, mainly because it breaks the single responsibility <span class="No-Break"><strong class="bold">SOLID</strong></span><span class="No-Break"> principle.</span></p>
			<p>The main point to remember is the developer’s core principle to make the code maintainable and readable; unfortunately, we don’t yet have a full set of established best practices for NoSQL as we do <span class="No-Break">with SQL:</span></p>
			<pre class="source-code">
@ApplicationScopedclass LibraryGraph {
    @Inject
    private GraphTemplate template;
    public Book save(Book book) {
        Objects.requireNonNull(book, "book is required");
        return template.getTraversalVertex()
          .hasLabel(Book.class)
                .has("name", book.getName())
                .&lt;Book&gt;next()
                .orElseGet(() -&gt; template.insert(book));
    }
    public Category save(Category category) {
        Objects.requireNonNull(category, "category is
          required");
        return template.getTraversalVertex()
          .hasLabel(Category.class)
                .has("name", category.getName())
                .&lt;Category&gt;next()
                .orElseGet(() -&gt;
                   template.insert(category));
    }
//...
}</pre>
			<p>The last step is to run it. There are tiny differences between the query and operation when inserting<a id="_idIndexMarker272"/> entities and<a id="_idIndexMarker273"/> relationships. We can implement the following graph <span class="No-Break">using Neo4j.</span></p>
			<p>JNoSQL uses Apache TinkerPop as a communication layer where we can search for queries by using Gremlin. This opens up a world <span class="No-Break">of possibilities:</span></p>
			<pre class="source-code">
try (SeContainer container =  SeContainerInitializer.newInstance().initialize()) {
    LibraryGraph graph = container
      .select(LibraryGraph.class).get();
    Category software = graph
      .save(Category.of("Software"));
    Category java = graph.save(Category.of("Java"));
    Person joshua = graph.save(Person.of("Joshua Bloch",
      "@joshbloch"));
    graph.is(java, software);
    graph.write(joshua, effectiveJava);
     List&lt;String&gt; softwareCategories =
       graph.getSubCategories();
    List&lt;String&gt; softwareBooks = graph.getSoftwareBooks();
    List&lt;String&gt; softwareNoSQLBooks =
      graph.getSoftwareNoSQL();
    Set&lt;Category&gt; categories = graph.getCategories(otavio);
    Set&lt;String&gt; suggestions = graph.getFollow(otavio);
   }</pre>
			<p>The graph database has extensive capabilities to leverage relationships, but it comes at the cost of <a id="_idIndexMarker274"/>performance. It is <a id="_idIndexMarker275"/>tough to scale the database<a id="_idTextAnchor136"/>, and it is slower than a <span class="No-Break">key-value database.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor137"/>Summary</h1>
			<p>We’ve finished our journey through NoSQL types, where we looked at the least flexible to the least scalable types. Paying attention to modeling is crucial because it is different from SQL databases and is a common pitfall for beginners in <span class="No-Break">NoSQL databases.</span></p>
			<p>We introduced you to the JNoSQL Java API standard, which streamlines the integration of Java applications with NoSQL databases. We will discuss Jakarta and the data persistence layer in the chapter on polyglot persistence. In the next chapter, we will cover relational databases <span class="No-Break">using jOOQ.</span></p>
		</div>
	</body></html>