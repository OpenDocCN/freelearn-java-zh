- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the fundamentals of **GraphQL**, including
    its **schema definition language** (**SDL**), queries, mutations, and subscriptions.
    The GraphQL API is popular in hand-held device-based apps such as mobile apps
    because it is fast and efficient in fetching the data and better than REST in
    certain cases. Therefore, it is important to learn about GraphQL. You will learn
    more about its comparison with REST in the *Comparing GraphQL with REST* section
    in this chapter. After completing this chapter, you will know the basics of GraphQL,
    including its semantics, schema design, and everything you need to develop a GraphQL-based
    API using Spring and Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning the fundamentals of GraphQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing a GraphQL schema
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing GraphQL queries and mutations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving the N+1 problem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers the theory behind GraphQL and related concepts. It is advised
    to go through this chapter first to develop and test the GraphQL-based service
    code presented in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have heard of or be aware of GraphQL, which has become more popular
    in the API space in past few years and is becoming the preferred way of implementing
    APIs for handheld devices and the web.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is a declarative query and manipulation language and server-side runtime
    for APIs. GraphQL empowers the client to query exactly the data they want – no
    more, no less.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss its brief history in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of GraphQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In 2011, Facebook was facing challenges in terms of improving the performance
    of its website on mobile browsers. They started building their own mobile app
    with mobile-native technologies. However, APIs were not up to the mark because
    of hierarchical and recursive data. They wanted to optimize their network calls.
    Note that in those days, mobile network speed was in Kb/s in some parts of the
    world. Having a fast, high-quality mobile app was going to be the key to their
    success, since their consumers had started shifting to mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: In 2012, a few engineers on Facebook – Lee Byron, Dan Schafer, and Nick Schrock
    – teamed up to create GraphQL. Initially, it was used to design and develop Facebook’s
    newsfeed feature, but later, it was used across its infrastructure, being used
    internally at Facebook exclusively until it was open sourced in 2015, when the
    GraphQL specification and its JavaScript implementation were made available to
    the public. Soon, other language implementations of the GraphQL specification
    started rolling out, including Java.
  prefs: []
  type: TYPE_NORMAL
- en: I think you would enjoy watching this GraphQL documentary at [https://www.youtube.com/watch?v=783ccP__No8](https://www.youtube.com/watch?v=783ccP__No8),
    which walks through GraphQL’s journey from being an internal Facebook tool to
    its current success.
  prefs: []
  type: TYPE_NORMAL
- en: Did you know?
  prefs: []
  type: TYPE_NORMAL
- en: Netflix and Coursera were also working on a similar idea to build efficient
    and performant APIs. Coursera didn’t take it forward, but Netflix open sourced
    Falcor.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing GraphQL with REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You developed APIs using REST in *Part 1: RESTful Web Services* of this book.
    In fact, an example e-commerce UI app also consumed REST APIs to implement its
    e-commerce functionality in the first part of this book. We are going to keep
    referring to REST in this chapter so that we can understand the necessary GraphQL
    concepts wherever they’re applicable. This correlation should help you grasp the
    GraphQL concepts easily.'
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is more powerful, flexible, and efficient than REST. Let’s understand
    why.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an example where a user logs in to an e-commerce UI app and
    automatically navigates to the product listing page. When this happens, the UI
    app consumes three different endpoints, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user endpoint, to fetch the user’s information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The product endpoint, to fetch the product list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The cart endpoint, to fetch the cart items from the user’s cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, basically, you must make three calls in REST to fetch the required information
    in a fixed structure (you can’t change the fields that are sent in response) from
    the backend.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, GraphQL can fetch a user’s information, a user’s cart data,
    and the product list in a single call. Thus, it reduces the number of network
    calls from three to one. GraphQL just exposes a single endpoint, unlike REST,
    where you must define an endpoint for each use case. You might say that you can
    write a new REST endpoint that does that. Yes, that may solve this specific use
    case, but it is not flexible; it won’t allow for quick iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, GraphQL lets you describe the fields you want to fetch from the backend
    in a request. The server response contains only those fields, which are sent as
    a part of the request– no more, no less.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you may want to add user reviews to products. For this, you just
    need to add the reviews field to the GraphQL query. Similarly, you don’t need
    to consume extra fields. You just add those fields that you need to the GraphQL
    query. On the other hand, REST’s response contains predefined fields, regardless
    of whether you need certain fields in the response object or not. Then, you must
    filter the required fields at the client end. Therefore, we can say that GraphQL
    uses network bandwidth more efficiently by avoiding over-/under-fetching problems.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL APIs don’t need constant changes as happens with REST, where you may
    need to change the API or add new APIs for a requirement change. This improves
    the development speed and iteration. You can easily add new fields or mark thsose
    that have been deprecated (fields not being used by a client anymore). Therefore,
    you can make the changes in the client without impacting the backend. In short,
    you can write evolving APIs without any versioning and breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: REST offers caching using built-in HTTP specifications. However, GraphQL does
    not follow the HTTP specifications; instead, it makes use of libraries such as
    Apollo/Relay for caching. However, REST is based on HTTP and does not follow any
    specification for implementation, which may lead to inconsistent implementations,
    as we discussed when comparing REST with gRPC. You can use the HTTP `GET` method
    to delete a resource.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL is superior to REST APIs in terms of its usage in mobile clients. The
    capabilities of GraphQL APIs are also defined using strong types. These types
    are part of the schema that contains the API definitions. These types are written
    in the schema using **SDL**.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL acts as a contract between the server and the client. You can correlate
    the GraphQL schema with the gRPC **interface definition language** (**IDL**) file
    and OpenAPI specification file.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll discuss the fundamentals of GraphQL in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Learning the fundamentals of GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL APIs contain three important **root types** – **query**, **mutation**,
    and **subscription**. These are all defined in the GraphQL schema using special
    SDL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL provides a single endpoint that returns the JSON response based on the
    request, which can be a query, a mutation, or a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s understand queries.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Query type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Query` type is used for reading operations that fetch information from
    the server. A single `Query` type can contain many queries. Let’s write a query
    using SDL to retrieve the logged-in user, as shown in the following GraphQL schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you have done two things:'
  prefs: []
  type: TYPE_NORMAL
- en: You have defined the query root of the GraphQL interface, which contains the
    query you can run. It contains just a single query type, `me`, that returns an
    instance of the `LoggedInUser` type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have specified the user-defined `LoggedInUser` object type, which contains
    four fields. These fields are followed by their types. In the preceding code,
    you used GraphQL’s built-in *scalar types*, called `ID` and `String`, to define
    the types of the fields. We’ll discuss these types later in this chapter when
    we discuss built-in scalar types in detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have this schema implementation on the server and have fired the following
    GraphQL query, you will only get the fields you requested, along with their values,
    as a JSON object in response.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the `me` query and its JSON response in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, here GraphQL’s request input does not start with a query because
    `Query` is the default for the payload. This is called an `Mutation`. However,
    if you want, you can also prefix the query request input with `query`, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this allows you to only query those fields that you need. Here,
    only the `id` and `username` fields were requested from the `LoggedInUser` type,
    and the server responded with only these two fields. The request payload is enclosed
    in curly braces `{}`. You can use `#` for commenting in the schema.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how to define `Query` and `object` types in a GraphQL schema.
    You also learned how to form a GraphQL request payload according to its query
    type and the expected JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn about GraphQL mutations in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Mutation type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Mutation` type is used in GraphQL requests for all the add, update, and
    delete operations that get performed on the server. A single `Mutation` type can
    contain many mutations. Let’s define an `addItemInCart` mutation that adds a new
    item to the cart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have defined the `Mutation` type and a new object type called `Item`.
    The mutation is added and called `addItemInCart`. The `Query`, `Mutation`, and
    `Subscription` types can pass arguments. To define the necessary parameters, you
    can enclose the named arguments with `()` brackets; the arguments are divided
    by commas. The signature of `addItemInCart` contains two arguments and returns
    a list of cart items. A list is marked using `[]` brackets.
  prefs: []
  type: TYPE_NORMAL
- en: Optional and required arguments
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you declare an argument with a default value, such as the following
    mutation:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pay(amount: Float, currency: String = "``USD"): Payment`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `currency` is an optional argument. It contains the default value, whereas
    `amount` is a required field because it does not contain any default value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note that `Int` is a built-in scalar type for signed 32-bit integers.
    Default values are null in GraphQL. If you want to force a non-nullable value
    for any field, then its type should be marked with an exclamation mark (`!`).
    Once it (`!`) has been applied to any field in the schema, the GraphQL server
    will always provide a value instead of a null for that field when it is placed
    in the request payload by the client. You can also declare a list with exclamation
    marks; for example, `items: [Item]!` and `items: [Item!]!`. Both declarations
    will provide zero or more items in a list. However, the latter would provide only
    a valid `Item` object (i.e., a non-nullable value).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have this schema implementation on the server, you can use the following
    GraphQL query. You will get only the fields you requested, along with their values,
    as a JSON object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can see that this time, the GraphQL request input starts with the `mutation`
    keyword. If you don’t start a mutation with the `mutation` keyword, then you might
    get an error with a message along the lines of **Field ‘addItemInCart’ doesn’t
    exist on type ‘Query’**. This is because the server treats the request payload
    as a query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you must add the required arguments to the `addItemInCart` mutation and
    then add the fields (`id` and `productId`) you want to retrieve in response. Once
    the request has been processed successfully, you will get a JSON output like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the value of the `id` field is generated by the server. Similarly, you
    can write other mutations, such as delete and update, in the schema. Then, you
    can use the payload in the GraphQL request to process the mutation accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore the GraphQL `Subscription` type in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Subscription type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concept of subscriptions will be new to you if you are only familiar with
    REST. In the absence of GraphQL, you might use polling or WebSockets to implement
    similar functionality. There are many use cases where you will need the subscription
    feature, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Live score updates or election results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Batch processing updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many such cases where you will need to immediately update events.
    GraphQL provides a subscription feature for this use case. In such cases, the
    client subscribes to the event by initiating and holding a steady connection.
    When the subscribed event occurs, the server pushes the resultant event data to
    the client. For example, let’s say you want to know whenever there is a change
    in any item’s inventory in an e-commerce app. Any change in the quantity of an
    item would trigger the event and the subscription would get a response with the
    updated quantity.
  prefs: []
  type: TYPE_NORMAL
- en: This data is sent as a stream through an initiated connection, rather than through
    a request/response kind of communication (which was used in the cases of query/mutation).
  prefs: []
  type: TYPE_NORMAL
- en: Recommended approach
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that a subscription should only be used when a small update
    occurs for a large object (such as batch processing), or there are live updates
    with low latency, such as a live score update. Otherwise, you should use polling
    (executing a query periodically at a specified interval).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a subscription in a schema, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have defined an `orderShipped` subscription that accepts `customer
    ID` as an argument and returns `Order`. Clients subscribe to this event, and then
    whenever an order is shipped for the given `customerId`, the server will push
    the requested order details to the client using a stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following GraphQL request to subscribe to the GraphQL subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The client will request a JSON response whenever any order belonging to a given
    customer is shipped. The server pushes these updates to all the clients who subscribed
    to this GraphQL subscription.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to declare the `Query`, `Mutation`, and `Subscription`
    types in a GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: You have defined scalar types and the user-defined object types in a schema.
    You also explored how to write a GraphQL request input for a query, mutation,
    or subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you know how to define the operation parameters in root types and pass
    arguments while sending GraphQL requests. Note that the non-nullable field in
    the schema can be marked by an exclamation mark (`!`). For arrays, or lists of
    objects, you must use square brackets (`[]`).
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll deep dive into GraphQL schema.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a GraphQL schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A schema is a GraphQL file that is written using DSL syntax. Primarily, it contains
    root types (query, mutation, and subscription), and the respective types that
    are used in root types, such as object types, scalar types, interfaces, union
    types, input types, and fragments.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s discuss these types. You learned about root types (query, mutation,
    and subscription) and object types in the previous section. Let’s now learn more
    about scalar types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding scalar types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Scalar types** resolve concrete data. There are three kinds of scalar types
    – built-in scalar types, custom scalar types, and enumeration types. Let’s discuss
    built-in scalar types first. GraphQL provides the following five kinds of built-in
    scalar types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Int`: This stores integers, and is represented by a signed 32-bit integer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float`: This stores a signed, double-precision, floating-point value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`String`: This stores a sequence of UTF-8 characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Boolean`: This stores a Boolean value – true or false.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ID`: This is used to define the object identifier string. This can only be
    serialized as a string, and is not human-readable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also define your own scalar types, which are known as custom scalar
    types. An example is the `Date` type, which can be defined like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You need to write an implementation that determines the serialization, deserialization,
    and validation of these custom scalar types. For example, the date can be treated
    as a Unix timestamp, or a string with a particular date format in a custom scalar
    `Date` type case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another special scalar type is the enumeration type (`enum`), which is used
    to define a particular set of allowed values. Let’s define an order status enumeration,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `OrderStatus` enumeration type represents the order status at a given
    point in time.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll next examine GraphQL fragments in the following subsection before exploring
    other types.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding fragments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may encounter conflicting scenarios while querying on the client side. You
    may have two or more queries that return the same result (the same object or set
    of fields). To avoid this conflict, you can give the query result a name. This
    name is known as an **alias**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use an alias in the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `HomeAndBillingAddress` is a named query that contains the `getAddress`
    query operation. `getAddress` is being used twice, which results in it returning
    the same set of fields. Therefore, the `home` and `billing` aliases are used to
    differentiate the result object.
  prefs: []
  type: TYPE_NORMAL
- en: The `getAddress` query may return the `Address` object. The `Address` object
    may have additional fields, such as `type`, `state`, `country`, and `contactNo`.
    So, when you have queries that may use the same set of fields, you can create
    a **fragment** and use it in queries. A fragment logically creates a subgroup
    of fields from the existing object in the GraphQL schema that can be reused at
    multiple places, as shown in the following code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a fragment and replace the common fields in the previous code
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `addressFragment` fragment has been created and used in the query.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create an `contains the nested object and you just want a few fields
    of the nested object rather than all the object fields. Inline fragments can be
    used when a querying field returns an **Interface**` **or `Union` type. We will
    explore inline fragments in more detail later in the *Understanding interfaces*
    subsection under the *Designing a GraphQL* *schema* section.**
  prefs: []
  type: TYPE_NORMAL
- en: '**We’ll look at GraphQL interfaces in the next subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GraphQL interfaces are abstract. You may have a few fields that are common across
    multiple objects. You can create an `interface` type for such sets of fields.
    For example, a product may have some common attributes, such as ID, name, and
    description. The product can also have other attributes based on its type. For
    example, a book may have several pages, an author, and a publisher, while a bookcase
    may have material, width, height, and depth attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s define these three objects (`Product`, `Book`, and `Bookcase`) using
    interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, an abstract type called `Product` has been created using the `interface`
    keyword. This interface can be implemented when we wish to create new object types
    – `Book` and `Bookcase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can simply write the following query that will return all the products
    (books and bookcases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the following query on the client side to retrieve all the
    products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You might have noticed that the preceding code only contains attributes from
    the `Product` interface. If you want to retrieve attributes from `Book` and `Bookcase`,
    then you must use **inline fragments**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, an operation (`…`) is used to create inline fragments. This way, you can
    fetch the fields from the type that implements the interface.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll understand `Union` types in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Union types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s say there are two object types – `Book` and `Author`. Here, you want to
    write a GraphQL query that can return both books and authors. Note that the interface
    is not there; so, how can we combine both objects in the query result? In such
    cases, you can use a **Union type**, which is a combination of two or more objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following before creating a `Union` type:'
  prefs: []
  type: TYPE_NORMAL
- en: You don’t need to have a common field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Union members should be of a concrete type. Therefore, you can’t use `union`,
    `interface`, `input`, or `scalar` types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s create a `union` type that can return any object included in the `union`
    type – books and bookcases – as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `union` keyword is used to create a `union` type for the `Book` and
    `Author` objects. A pipe symbol (`|`) is used to separate the included objects.
    Finally, a query is defined that returns a collection of books or authors that
    contain the given text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write this query for the client, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, an inline fragment is used in the query. Another important point
    is the extra field, called `__typename`, which refers to the object it belongs
    to and helps you differentiate between different objects in the client.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at input types in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding input types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you have used scalar types as arguments. GraphQL also allows you to
    pass object types as arguments in mutations. The only difference is that you have
    to declare them with `input` instead of using the `type` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a mutation that accepts an input type as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `addProduct` mutation accepts `ProductInput` as an argument and returns
    `Product`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the GraphQL request to add a product to the client, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, you are running a mutation that uses an `input` variable. You might have
    observed that `Variable` is being used here to pass `ProductInput`. The named
    mutation is used for the variable. If variables, along with their types, are defined
    in the mutation, then they should be used in the mutation.
  prefs: []
  type: TYPE_NORMAL
- en: Variable values should be assigned in the variable section (or beforehand in
    the client). The value of a variable’s input is assigned using a JSON object that
    should map to `ProductInput`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll look at the tools we can use while designing a GraphQL schema in the next
    subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a schema with GraphQL tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use the following tools for design and work with GraphQL, with each
    having its own offerings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GraphiQL**: This is pronounced *graphical*. It is an official GraphQL Foundation
    project that provides the web-based GraphQL **IDE**. It makes use of **Language
    Server Protocol** (**LSP**), which uses the JSON-RPC-based protocol between the
    source code editor and the IDE. It is available at [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL Playground**: This is another popular GraphQL IDE that once provided
    better features than GraphiQL. However, GraphiQL now has feature parity with Playground.
    At the time of writing, GraphQL Playground is in maintenance mode. Check out [https://github.com/graphql/graphql-playground/issues/1366](https://github.com/graphql/graphql-playground/issues/1366)
    for more details. It is available at [https://github.com/graphql/graphql-playground](https://github.com/graphql/graphql-playground).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL Faker**: This provides mock data for your GraphQL APIs. It is available
    at [https://github.com/APIs-guru/graphql-faker](https://github.com/APIs-guru/graphql-faker).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL Editor**: This allows you to design your schema visually and then
    transform it into code. It is available at [https://github.com/graphql-editor/graphql-editor](https://github.com/graphql-editor/graphql-editor).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GraphQL Voyager**: This converts your schema into interactive graphs, such
    as entity diagrams and all the relationships among these entities. It is available
    at [https://github.com/APIs-guru/graphql-voyager](https://github.com/APIs-guru/graphql-voyager).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you’ll test the knowledge that you have acquired throughout
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Testing GraphQL queries and mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s write queries and mutations in a real GraphQL schema to test the skills
    you have learned up to this point using GitHub’s GraphQL API explorer. Let’s perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, go to [https://docs.github.com/en/graphql/overview/explorer](https://docs.github.com/en/graphql/overview/explorer).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might have to authorize it using your GitHub account, so that you can execute
    GraphQL queries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'GitHub Explorer is based on GraphiQL. It is divided into three vertical sections
    (from left to right in the gray area in *Figure 13**.1*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The left-hand section is divided into two subsections – an upper section for
    writing queries and a bottom section for defining variables.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The middle vertical section shows the response.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Normally, the rightmost section is hidden. Click on the **Docs** link to display
    it. It shows the respective documentation and schema, along with the root types
    that you can explore.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 13.1 – GraphQL API Explorer](img/Figure_13.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – GraphQL API Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s fire the following query to find out the ID of the repository you wish
    to mark with a star:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you are querying the previous edition of this book’s repository by providing
    two arguments – the repository’s `name` and its `owner`. You are fetching a few
    of the fields. One of the most important ones is `stargazerCount` because we are
    going to perform an `addStar` mutation. This count will tell us whether the mutation
    was successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Execute Query** button on the top bar or press *Ctrl* + *Enter*
    to execute the query. You should get the following output once this query executes
    successfully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, you need to copy the value of `id` from the response, as it will be needed
    to mark this repository with a star.
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following query to perform the `addStar` mutation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This performs the `addStar` mutation for the repository with the given ID.
  prefs: []
  type: TYPE_NORMAL
- en: Once the previous query has executed successfully, you must re-execute the query
    from *step 4* to find out about the change. If you get an access issue, then you
    can choose your own GitHub repository to perform these steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also explore other queries and mutations to deep dive into GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s understand the N+1 problem in GraphQL queries before we jump
    into the implementation in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Solving the N+1 problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The N+1 problem is not new to Java developers. You might have encountered this
    problem while using Hibernate, which occurs if you don’t optimize your queries
    or write entities properly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what the N+1 problem is.
  prefs: []
  type: TYPE_NORMAL
- en: What is the N+1 problem?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **N+1 problem** normally occurs when associations are involved. There are
    one-to-many relationships between the customer and the order. One customer can
    have many orders. If you need to find all the customers and their orders, you
    can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: First, find all the users. This find operation returns the list of user objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, find all the orders belonging to each user found in *step 1*. The `userId`
    field acts as the relation between the `Order` and `User` objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, here, you fire two queries. If you further optimize the implementation,
    you can place a *join* between these two entities (`Order` and `User`) and receive
    all the records in a single query.
  prefs: []
  type: TYPE_NORMAL
- en: If this is so simple, then why does GraphQL encounter the N+1 problem? You need
    to understand the **resolver** function to answer this question.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you refer to the database schema you created in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097),
    *Writing Business Logic for APIs*, you can see that the `getUsersOrders` query
    will lead to the following SQL statements being executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here, to perform the `getUsersOrders()` operation, you execute a query on the
    user to fetch all the users. Then, you executes N queries on orders. This is why
    it is called the N+1 problem. This is not efficient because ideally you should
    execute a single query, or in the worst case, two queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL can only respond with the values of fields that have been requested
    in the query due to resolvers. Each field has its own resolver function in the
    GraphQL server implementation that fetches the data for its corresponding field.
    Let’s assume we have the following schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have a mutation that returns a collection of users. Each `User` may
    have a collection of orders. You could therefore use the following query in the
    client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let’s understand how this query will be processed by the server.
  prefs: []
  type: TYPE_NORMAL
- en: In the server, each field will have its own resolver function that fetches the
    corresponding data. The first resolver will be for the user and will fetch all
    the users from the data store. Next, the resolver will fetch orders for each user.
    It will fetch the orders from the data store based on the given user ID. Therefore,
    the `orders` resolver will execute `n` times, where `n` is the number of users
    that have been fetched from the data store.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn how to resolve the N+1 problem in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: How can we solve the N+1 problem?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The required solution will wait until all the orders have been loaded. Once
    all the user IDs have been retrieved, a database call should be made to fetch
    all the orders in a single data-store call. You can use a batch if the size of
    the database is huge. Then, the executer can resolve the individual order resolvers.
    However, this is easier said than done. GraphQL provides a library called **DataLoader**
    ([https://github.com/graphql/dataloader](https://github.com/graphql/dataloader))
    that does this job for you. This library mainly performs the batching and caching
    of queries.
  prefs: []
  type: TYPE_NORMAL
- en: Java provides a similar library called **java-dataloader** ([https://github.com/graphql-java/java-dataloader](https://github.com/graphql-java/java-dataloader))
    that can help you solve this problem. You can find out more about it at [https://www.graphql-java.com/documentation/batching](https://www.graphql-java.com/documentation/batching).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about GraphQL, its advantages, and how it compares
    to REST. You learned how GraphQL solves over-fetching and under-fetching problems.
    You then learned about GraphQL’s root types – queries, mutations, and subscriptions
    – and how different blocks can help you design the GraphQL schema. Finally, you
    understood how resolvers work, how they can lead to the N+1 problem, and the solution
    to this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know about the fundamentals of GraphQL, you can start designing
    GraphQL schemas. You also learned about GraphQL’s client-side queries and how
    to make use of aliases, fragments, and variables to resolve common problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will make use of the GraphQL skills you acquired in
    this chapter to implement GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is GraphQL better than REST? If yes, then in what way?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When should you use fragments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you use variables in a GraphQL query?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It depends on the use cases. However, GraphQL performs much better for mobile
    apps and web-based UI applications and is best suited for **service-to-service**
    (**s2s**) communications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fragments should be used while sending a request from the GraphQL client when
    the response contains an interface or union.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can use a variable in a GraphQL query/mutation, as shown in the following
    code. This code used to modify the GraphQL request sent in *step 6* of the *Testing
    GraphQL queries and* *mutations* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, you can see that the `$repoId` variable is used. You must declare that
    variable in the named mutation and it can then be used in the mutation’s argument,
    as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GraphQL specifications: [https://spec.graphql.org/](https://spec.graphql.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GraphQL documentation: [https://graphql.org/learn/](https://graphql.org/learn/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Full-Stack Web Development with GraphQL and* *React*: [https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880](https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
