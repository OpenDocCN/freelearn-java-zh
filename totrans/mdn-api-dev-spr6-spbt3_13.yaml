- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Getting Started with GraphQL
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 GraphQL
- en: In this chapter, you will learn about the fundamentals of **GraphQL**, including
    its **schema definition language** (**SDL**), queries, mutations, and subscriptions.
    The GraphQL API is popular in hand-held device-based apps such as mobile apps
    because it is fast and efficient in fetching the data and better than REST in
    certain cases. Therefore, it is important to learn about GraphQL. You will learn
    more about its comparison with REST in the *Comparing GraphQL with REST* section
    in this chapter. After completing this chapter, you will know the basics of GraphQL,
    including its semantics, schema design, and everything you need to develop a GraphQL-based
    API using Spring and Spring Boot.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解 GraphQL 的基础知识，包括其 **模式定义语言**（**SDL**）、查询、突变和订阅。GraphQL API 在基于手持设备的应用程序中很受欢迎，如移动应用，因为它在获取数据方面既快又高效，在某些情况下优于
    REST。因此，了解 GraphQL 非常重要。你将在本章的 *比较 GraphQL 与 REST* 部分了解更多关于其与 REST 的比较。完成本章后，你将了解
    GraphQL 的基础知识，包括其语义、模式设计以及使用 Spring 和 Spring Boot 开发基于 GraphQL 的 API 所需的一切。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Getting to know GraphQL
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 GraphQL
- en: Learning the fundamentals of GraphQL
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 GraphQL 的基础知识
- en: Designing a GraphQL schema
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 GraphQL 模式
- en: Testing GraphQL queries and mutations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试 GraphQL 查询和突变
- en: Solving the N+1 problem
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决 N+1 问题
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter covers the theory behind GraphQL and related concepts. It is advised
    to go through this chapter first to develop and test the GraphQL-based service
    code presented in the next chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了 GraphQL 及相关概念的理论基础。建议首先阅读本章，以便开发并测试下一章中展示的基于 GraphQL 的服务代码。
- en: Getting to know GraphQL
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 GraphQL
- en: You might have heard of or be aware of GraphQL, which has become more popular
    in the API space in past few years and is becoming the preferred way of implementing
    APIs for handheld devices and the web.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过或了解 GraphQL，它在过去几年中在 API 领域变得更加流行，并成为实现手持设备和 Web API 的首选方式。
- en: GraphQL is a declarative query and manipulation language and server-side runtime
    for APIs. GraphQL empowers the client to query exactly the data they want – no
    more, no less.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 是一种声明式查询和操作语言，也是 API 的服务器端运行时。GraphQL 使客户端能够查询他们确切想要的数据——不多也不少。
- en: We’ll discuss its brief history in the next subsection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中讨论其简要历史。
- en: A brief history of GraphQL
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL 的简要历史
- en: In 2011, Facebook was facing challenges in terms of improving the performance
    of its website on mobile browsers. They started building their own mobile app
    with mobile-native technologies. However, APIs were not up to the mark because
    of hierarchical and recursive data. They wanted to optimize their network calls.
    Note that in those days, mobile network speed was in Kb/s in some parts of the
    world. Having a fast, high-quality mobile app was going to be the key to their
    success, since their consumers had started shifting to mobile devices.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 2011 年，Facebook 在提高其网站在移动浏览器上的性能方面面临挑战。他们开始使用移动原生技术构建自己的移动应用。然而，由于层次结构和递归数据，API
    并未达到预期。他们希望优化他们的网络调用。请注意，在那些日子里，世界某些地区的移动网络速度仅为 Kb/s。拥有快速、高质量的移动应用将成为他们成功的关键，因为他们的消费者已经开始转向移动设备。
- en: In 2012, a few engineers on Facebook – Lee Byron, Dan Schafer, and Nick Schrock
    – teamed up to create GraphQL. Initially, it was used to design and develop Facebook’s
    newsfeed feature, but later, it was used across its infrastructure, being used
    internally at Facebook exclusively until it was open sourced in 2015, when the
    GraphQL specification and its JavaScript implementation were made available to
    the public. Soon, other language implementations of the GraphQL specification
    started rolling out, including Java.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 2012 年，Facebook 上的一些工程师——Lee Byron、Dan Schafer 和 Nick Schrock——联合起来创建 GraphQL。最初，它被用来设计和开发
    Facebook 的新闻源功能，但后来，它被用于其整个基础设施中，仅在 Facebook 内部使用，直到 2015 年开源，当时 GraphQL 规范及其
    JavaScript 实现对公众开放。很快，GraphQL 规范的其他语言实现也开始推出，包括 Java。
- en: I think you would enjoy watching this GraphQL documentary at [https://www.youtube.com/watch?v=783ccP__No8](https://www.youtube.com/watch?v=783ccP__No8),
    which walks through GraphQL’s journey from being an internal Facebook tool to
    its current success.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我想你会喜欢观看这个关于 GraphQL 的纪录片，[https://www.youtube.com/watch?v=783ccP__No8](https://www.youtube.com/watch?v=783ccP__No8)，它讲述了
    GraphQL 从内部 Facebook 工具到目前成功的历程。
- en: Did you know?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道吗？
- en: Netflix and Coursera were also working on a similar idea to build efficient
    and performant APIs. Coursera didn’t take it forward, but Netflix open sourced
    Falcor.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix和Coursera也在研究一个类似的想法来构建高效且性能良好的API。Coursera没有继续推进，但Netflix开源了Falcor。
- en: Comparing GraphQL with REST
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较GraphQL与REST
- en: 'You developed APIs using REST in *Part 1: RESTful Web Services* of this book.
    In fact, an example e-commerce UI app also consumed REST APIs to implement its
    e-commerce functionality in the first part of this book. We are going to keep
    referring to REST in this chapter so that we can understand the necessary GraphQL
    concepts wherever they’re applicable. This correlation should help you grasp the
    GraphQL concepts easily.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本书的*第1部分：RESTful Web服务*中使用了REST API来开发API。实际上，一个示例电子商务UI应用也在本书的第一部分中消耗了REST
    API来实现其电子商务功能。我们将继续在本章中引用REST，以便我们可以在适用的情况下理解必要的GraphQL概念。这种相关性应该有助于你轻松掌握GraphQL概念。
- en: GraphQL is more powerful, flexible, and efficient than REST. Let’s understand
    why.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL比REST更强大、更灵活、更高效。让我们了解原因。
- en: 'Let’s consider an example where a user logs in to an e-commerce UI app and
    automatically navigates to the product listing page. When this happens, the UI
    app consumes three different endpoints, as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个例子，其中用户登录到电子商务UI应用并自动导航到产品列表页面。当这种情况发生时，UI应用会消耗三个不同的端点，如下所示：
- en: The user endpoint, to fetch the user’s information
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户端点，用于获取用户信息
- en: The product endpoint, to fetch the product list
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品端点，用于获取产品列表
- en: The cart endpoint, to fetch the cart items from the user’s cart
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 购物车端点，用于从用户的购物车中获取购物车项目
- en: So, basically, you must make three calls in REST to fetch the required information
    in a fixed structure (you can’t change the fields that are sent in response) from
    the backend.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，你必须在REST中进行三次调用，以从后端获取固定结构（你无法更改响应中发送的字段）所需的信息。
- en: On the other hand, GraphQL can fetch a user’s information, a user’s cart data,
    and the product list in a single call. Thus, it reduces the number of network
    calls from three to one. GraphQL just exposes a single endpoint, unlike REST,
    where you must define an endpoint for each use case. You might say that you can
    write a new REST endpoint that does that. Yes, that may solve this specific use
    case, but it is not flexible; it won’t allow for quick iteration.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，GraphQL可以在一个调用中获取用户信息、用户的购物车数据和产品列表。因此，它将网络调用次数从三个减少到一次。与REST不同，REST必须为每个用例定义一个端点。你可能会说可以编写一个新的REST端点来解决这个问题。是的，这可能解决了这个特定的用例，但它不够灵活；它不会允许快速迭代。
- en: Moreover, GraphQL lets you describe the fields you want to fetch from the backend
    in a request. The server response contains only those fields, which are sent as
    a part of the request– no more, no less.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，GraphQL允许你在请求中描述你想要从后端获取的字段。服务器响应只包含作为请求一部分的字段，没有更多，也没有更少。
- en: For example, you may want to add user reviews to products. For this, you just
    need to add the reviews field to the GraphQL query. Similarly, you don’t need
    to consume extra fields. You just add those fields that you need to the GraphQL
    query. On the other hand, REST’s response contains predefined fields, regardless
    of whether you need certain fields in the response object or not. Then, you must
    filter the required fields at the client end. Therefore, we can say that GraphQL
    uses network bandwidth more efficiently by avoiding over-/under-fetching problems.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能想添加用户评论到产品中。为此，你只需将评论字段添加到GraphQL查询中。同样，你不需要消耗额外的字段。你只需将需要的字段添加到GraphQL查询中。另一方面，REST的响应包含预定义的字段，无论你是否需要在响应对象中获取某些字段。然后，你必须在客户端过滤所需的字段。因此，我们可以这样说，GraphQL通过避免过度/不足获取问题，更有效地使用网络带宽。
- en: GraphQL APIs don’t need constant changes as happens with REST, where you may
    need to change the API or add new APIs for a requirement change. This improves
    the development speed and iteration. You can easily add new fields or mark thsose
    that have been deprecated (fields not being used by a client anymore). Therefore,
    you can make the changes in the client without impacting the backend. In short,
    you can write evolving APIs without any versioning and breaking changes.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API不需要像REST那样进行不断的变化，在REST中，你可能需要更改API或添加新的API以满足需求变化。这提高了开发速度和迭代。你可以轻松地添加新字段或标记那些已经被弃用的（不再被客户端使用的字段）。因此，你可以在客户端进行更改，而不会影响后端。简而言之，你可以编写不断发展的API，而不需要任何版本控制和破坏性更改。
- en: REST offers caching using built-in HTTP specifications. However, GraphQL does
    not follow the HTTP specifications; instead, it makes use of libraries such as
    Apollo/Relay for caching. However, REST is based on HTTP and does not follow any
    specification for implementation, which may lead to inconsistent implementations,
    as we discussed when comparing REST with gRPC. You can use the HTTP `GET` method
    to delete a resource.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST使用内置的HTTP规范提供缓存。然而，GraphQL不遵循HTTP规范；相反，它使用Apollo/Relay等库进行缓存。然而，REST基于HTTP，并且没有遵循任何实现规范，这可能导致不一致的实现，正如我们在比较REST与gRPC时讨论的那样。您可以使用HTTP
    `GET`方法删除资源。
- en: GraphQL is superior to REST APIs in terms of its usage in mobile clients. The
    capabilities of GraphQL APIs are also defined using strong types. These types
    are part of the schema that contains the API definitions. These types are written
    in the schema using **SDL**.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在移动客户端的使用方面，GraphQL API优于REST API。GraphQL API的功能也使用强类型定义。这些类型是包含API定义的模式的一部分。这些类型使用**SDL**在模式中编写。
- en: GraphQL acts as a contract between the server and the client. You can correlate
    the GraphQL schema with the gRPC **interface definition language** (**IDL**) file
    and OpenAPI specification file.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL充当服务器和客户端之间的合约。您可以将GraphQL模式与gRPC **接口定义语言**（**IDL**）文件和OpenAPI规范文件相关联。
- en: We’ll discuss the fundamentals of GraphQL in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论GraphQL的基础知识。
- en: Learning the fundamentals of GraphQL
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习GraphQL的基础知识
- en: GraphQL APIs contain three important **root types** – **query**, **mutation**,
    and **subscription**. These are all defined in the GraphQL schema using special
    SDL syntax.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL API包含三个重要的**根类型** – **查询**、**突变**和**订阅**。这些都是在GraphQL模式中使用特殊SDL语法定义的。
- en: GraphQL provides a single endpoint that returns the JSON response based on the
    request, which can be a query, a mutation, or a subscription.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL提供了一个单一端点，根据请求返回JSON响应，该请求可以是查询、突变或订阅。
- en: First, let’s understand queries.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们了解查询。
- en: Exploring the Query type
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索查询类型
- en: 'The `Query` type is used for reading operations that fetch information from
    the server. A single `Query` type can contain many queries. Let’s write a query
    using SDL to retrieve the logged-in user, as shown in the following GraphQL schema:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query`类型用于读取操作，从服务器获取信息。单个`Query`类型可以包含多个查询。让我们使用SDL编写一个查询，以检索已登录用户，如下面的GraphQL模式所示：'
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, you have done two things:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您做了两件事：
- en: You have defined the query root of the GraphQL interface, which contains the
    query you can run. It contains just a single query type, `me`, that returns an
    instance of the `LoggedInUser` type.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已定义了GraphQL接口的查询根，其中包含您可以运行的查询。它只包含一个查询类型，`me`，它返回`LoggedInUser`类型的实例。
- en: You have specified the user-defined `LoggedInUser` object type, which contains
    four fields. These fields are followed by their types. In the preceding code,
    you used GraphQL’s built-in *scalar types*, called `ID` and `String`, to define
    the types of the fields. We’ll discuss these types later in this chapter when
    we discuss built-in scalar types in detail.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您已指定用户定义的`LoggedInUser`对象类型，其中包含四个字段。这些字段后面跟着它们的类型。在前面的代码中，您使用了GraphQL的内置*标量类型*，称为`ID`和`String`，来定义字段的类型。我们将在本章后面详细讨论这些类型时讨论这些类型。
- en: Once you have this schema implementation on the server and have fired the following
    GraphQL query, you will only get the fields you requested, along with their values,
    as a JSON object in response.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在服务器上实现了此模式，并执行了以下GraphQL查询，您将只获得请求的字段及其值，作为JSON对象响应。
- en: 'You can find the `me` query and its JSON response in the following code block:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下代码块中找到`me`查询及其JSON响应：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Interestingly, here GraphQL’s request input does not start with a query because
    `Query` is the default for the payload. This is called an `Mutation`. However,
    if you want, you can also prefix the query request input with `query`, as shown
    here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这里GraphQL的请求输入不以`query`开头，因为`Query`是负载的默认值。这被称为`Mutation`。但是，如果您愿意，您也可以在查询请求输入前加上`query`前缀，如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this allows you to only query those fields that you need. Here,
    only the `id` and `username` fields were requested from the `LoggedInUser` type,
    and the server responded with only these two fields. The request payload is enclosed
    in curly braces `{}`. You can use `#` for commenting in the schema.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这允许你只查询你需要的字段。在这里，只从`LoggedInUser`类型请求了`id`和`username`字段，服务器只响应了这两个字段。请求负载被括号`{}`包围。你可以在模式中使用`#`进行注释。
- en: Now, you know how to define `Query` and `object` types in a GraphQL schema.
    You also learned how to form a GraphQL request payload according to its query
    type and the expected JSON response.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你知道如何在GraphQL模式中定义`Query`和`object`类型。你还学习了如何根据查询类型和预期的JSON响应形成GraphQL请求负载。
- en: We’ll learn about GraphQL mutations in the next subsection.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中学习GraphQL突变。
- en: Exploring the Mutation type
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Mutation类型
- en: 'The `Mutation` type is used in GraphQL requests for all the add, update, and
    delete operations that get performed on the server. A single `Mutation` type can
    contain many mutations. Let’s define an `addItemInCart` mutation that adds a new
    item to the cart:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mutation`类型用于GraphQL请求中在服务器上执行的所有添加、更新和删除操作。一个`Mutation`类型可以包含多个突变。让我们定义一个`addItemInCart`突变，该突变将新项目添加到购物车中：'
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, you have defined the `Mutation` type and a new object type called `Item`.
    The mutation is added and called `addItemInCart`. The `Query`, `Mutation`, and
    `Subscription` types can pass arguments. To define the necessary parameters, you
    can enclose the named arguments with `()` brackets; the arguments are divided
    by commas. The signature of `addItemInCart` contains two arguments and returns
    a list of cart items. A list is marked using `[]` brackets.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你已经定义了`Mutation`类型和一个名为`Item`的新对象类型。添加了一个名为`addItemInCart`的突变，并且`Query`、`Mutation`和`Subscription`类型都可以传递参数。为了定义必要的参数，你可以用`()`括号包围命名参数；参数之间用逗号分隔。`addItemInCart`的签名包含两个参数，并返回一个购物车项目列表。列表使用`[]`括号标记。
- en: Optional and required arguments
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可选和必需参数
- en: 'Let’s say you declare an argument with a default value, such as the following
    mutation:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你声明了一个具有默认值的参数，如下面的突变所示：
- en: '`pay(amount: Float, currency: String = "``USD"): Payment`'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`pay(amount: Float, currency: String = "USD"): Payment`'
- en: Here, `currency` is an optional argument. It contains the default value, whereas
    `amount` is a required field because it does not contain any default value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`currency`是一个可选参数。它包含默认值，而`amount`是一个必需字段，因为它不包含任何默认值。
- en: 'Please note that `Int` is a built-in scalar type for signed 32-bit integers.
    Default values are null in GraphQL. If you want to force a non-nullable value
    for any field, then its type should be marked with an exclamation mark (`!`).
    Once it (`!`) has been applied to any field in the schema, the GraphQL server
    will always provide a value instead of a null for that field when it is placed
    in the request payload by the client. You can also declare a list with exclamation
    marks; for example, `items: [Item]!` and `items: [Item!]!`. Both declarations
    will provide zero or more items in a list. However, the latter would provide only
    a valid `Item` object (i.e., a non-nullable value).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，`Int`是GraphQL中用于有符号32位整数的内置标量类型。默认值在GraphQL中为null。如果你想强制任何字段为非null值，那么其类型应该用感叹号（`!`）标记。一旦它（`!`）被应用于模式中的任何字段，当客户端将其放在请求负载中时，GraphQL服务器将始终提供值而不是null。你还可以用感叹号声明一个列表；例如，`items:
    [Item]!`和`items: [Item!]!`。这两种声明都将提供一个包含零个或多个项目的列表。然而，后者将只提供一个有效的`Item`对象（即非null值）。'
- en: 'Once you have this schema implementation on the server, you can use the following
    GraphQL query. You will get only the fields you requested, along with their values,
    as a JSON object:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在服务器上实现了这个模式实现，你就可以使用以下GraphQL查询。你将只得到你请求的字段及其值，作为一个JSON对象：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see that this time, the GraphQL request input starts with the `mutation`
    keyword. If you don’t start a mutation with the `mutation` keyword, then you might
    get an error with a message along the lines of **Field ‘addItemInCart’ doesn’t
    exist on type ‘Query’**. This is because the server treats the request payload
    as a query.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，这次，GraphQL请求输入以`mutation`关键字开头。如果你不以`mutation`关键字开始突变，那么你可能会得到一个错误消息，例如**字段‘addItemInCart’在类型‘Query’上不存在**。这是因为服务器将请求负载视为查询。
- en: 'Here, you must add the required arguments to the `addItemInCart` mutation and
    then add the fields (`id` and `productId`) you want to retrieve in response. Once
    the request has been processed successfully, you will get a JSON output like the
    following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您必须向 `addItemInCart` 突变添加所需的参数，然后添加您想要检索的域（`id` 和 `productId`）。一旦请求成功处理，您将获得以下类似的
    JSON 输出：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the value of the `id` field is generated by the server. Similarly, you
    can write other mutations, such as delete and update, in the schema. Then, you
    can use the payload in the GraphQL request to process the mutation accordingly.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`id` 字段的值由服务器生成。同样，您可以在模式中编写其他突变，如删除和更新。然后，您可以使用 GraphQL 请求中的有效负载相应地处理突变。
- en: We’ll explore the GraphQL `Subscription` type in the next subsection.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中探讨 GraphQL `Subscription` 类型。
- en: Exploring the Subscription type
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索订阅类型
- en: 'The concept of subscriptions will be new to you if you are only familiar with
    REST. In the absence of GraphQL, you might use polling or WebSockets to implement
    similar functionality. There are many use cases where you will need the subscription
    feature, including the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只熟悉 REST，那么订阅的概念可能对您来说是新的。在没有 GraphQL 的情况下，您可能会使用轮询或 WebSocket 来实现类似的功能。有许多需要订阅功能的使用场景，包括以下内容：
- en: Live score updates or election results
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时比分更新或选举结果
- en: Batch processing updates
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量处理更新
- en: There are many such cases where you will need to immediately update events.
    GraphQL provides a subscription feature for this use case. In such cases, the
    client subscribes to the event by initiating and holding a steady connection.
    When the subscribed event occurs, the server pushes the resultant event data to
    the client. For example, let’s say you want to know whenever there is a change
    in any item’s inventory in an e-commerce app. Any change in the quantity of an
    item would trigger the event and the subscription would get a response with the
    updated quantity.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多需要立即更新事件的此类情况。GraphQL 为此用例提供了订阅功能。在这种情况下，客户端通过启动并保持稳定的连接来订阅事件。当订阅的事件发生时，服务器将结果事件数据推送到客户端。例如，假设您想了解电子商务应用中任何商品库存的任何变化。任何商品数量的变化都会触发事件，并且订阅将收到包含更新数量的响应。
- en: This data is sent as a stream through an initiated connection, rather than through
    a request/response kind of communication (which was used in the cases of query/mutation).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此数据通过已启动的连接以流的形式发送，而不是通过请求/响应类型的通信（这在查询/突变的情况下使用过）。
- en: Recommended approach
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐方法
- en: It is recommended that a subscription should only be used when a small update
    occurs for a large object (such as batch processing), or there are live updates
    with low latency, such as a live score update. Otherwise, you should use polling
    (executing a query periodically at a specified interval).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 建议仅在大型对象（如批量处理）发生少量更新时使用订阅，或者有低延迟的实时更新（如实时比分更新）时使用订阅。否则，您应该使用轮询（在指定间隔定期执行查询）。
- en: 'Let’s create a subscription in a schema, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在模式中创建一个订阅，如下所示：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, we have defined an `orderShipped` subscription that accepts `customer
    ID` as an argument and returns `Order`. Clients subscribe to this event, and then
    whenever an order is shipped for the given `customerId`, the server will push
    the requested order details to the client using a stream.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个接受 `customer ID` 作为参数的 `orderShipped` 订阅，并返回 `Order`。客户端订阅此事件，然后每当给定
    `customerId` 的订单发货时，服务器将使用流将请求的订单详细信息推送到客户端。
- en: 'You can use the following GraphQL request to subscribe to the GraphQL subscription:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下 GraphQL 请求来订阅 GraphQL 订阅：
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The client will request a JSON response whenever any order belonging to a given
    customer is shipped. The server pushes these updates to all the clients who subscribed
    to this GraphQL subscription.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端将在任何属于给定客户的订单发货时请求 JSON 响应。服务器将这些更新推送到所有订阅此 GraphQL 订阅的客户端。
- en: In this section, you learned how to declare the `Query`, `Mutation`, and `Subscription`
    types in a GraphQL schema.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您学习了如何在 GraphQL 模式中声明 `Query`、`Mutation` 和 `Subscription` 类型。
- en: You have defined scalar types and the user-defined object types in a schema.
    You also explored how to write a GraphQL request input for a query, mutation,
    or subscription.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 您在模式中定义了标量类型和用户定义的对象类型。您还探讨了如何为查询、突变或订阅编写 GraphQL 请求输入。
- en: Now, you know how to define the operation parameters in root types and pass
    arguments while sending GraphQL requests. Note that the non-nullable field in
    the schema can be marked by an exclamation mark (`!`). For arrays, or lists of
    objects, you must use square brackets (`[]`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经知道如何在根类型中定义操作参数，并在发送GraphQL请求时传递参数。请注意，模式中的非空字段可以用感叹号（`!`）标记。对于数组或对象列表，您必须使用方括号（`[]`）。
- en: In the next section, we’ll deep dive into GraphQL schema.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨GraphQL模式。
- en: Designing a GraphQL schema
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计GraphQL模式
- en: A schema is a GraphQL file that is written using DSL syntax. Primarily, it contains
    root types (query, mutation, and subscription), and the respective types that
    are used in root types, such as object types, scalar types, interfaces, union
    types, input types, and fragments.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是一个使用DSL语法编写的GraphQL文件。主要包含根类型（查询、突变和订阅），以及根类型中使用的相应类型，如对象类型、标量类型、接口、联合类型、输入类型和片段。
- en: First, let’s discuss these types. You learned about root types (query, mutation,
    and subscription) and object types in the previous section. Let’s now learn more
    about scalar types.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论这些类型。在前一节中，您已经学习了根类型（查询、突变和订阅）和对象类型。现在让我们更深入地了解标量类型。
- en: Understanding scalar types
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解标量类型
- en: '**Scalar types** resolve concrete data. There are three kinds of scalar types
    – built-in scalar types, custom scalar types, and enumeration types. Let’s discuss
    built-in scalar types first. GraphQL provides the following five kinds of built-in
    scalar types:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**标量类型**用于解析具体数据。标量类型共有三种——内置标量类型、自定义标量类型和枚举类型。我们先来讨论内置标量类型。GraphQL提供了以下五种内置标量类型：'
- en: '`Int`: This stores integers, and is represented by a signed 32-bit integer.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Int`：这种类型存储整数，由一个有符号的32位整数表示。'
- en: '`Float`: This stores a signed, double-precision, floating-point value.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Float`：这种类型存储一个有符号的双精度浮点值。'
- en: '`String`: This stores a sequence of UTF-8 characters.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`String`：这种类型存储一个UTF-8字符序列。'
- en: '`Boolean`: This stores a Boolean value – true or false.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Boolean`：这种类型存储布尔值——真或假。'
- en: '`ID`: This is used to define the object identifier string. This can only be
    serialized as a string, and is not human-readable.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ID`：用于定义对象标识符字符串。这只能序列化为字符串，且不可读。'
- en: 'You can also define your own scalar types, which are known as custom scalar
    types. An example is the `Date` type, which can be defined like so:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以定义自己的标量类型，这些类型被称为自定义标量类型。例如，`Date`类型可以定义如下：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You need to write an implementation that determines the serialization, deserialization,
    and validation of these custom scalar types. For example, the date can be treated
    as a Unix timestamp, or a string with a particular date format in a custom scalar
    `Date` type case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要编写一个实现，以确定这些自定义标量类型的序列化、反序列化和验证。例如，日期可以被视为Unix时间戳，或者在一个自定义的`Date`类型中以特定日期格式的字符串。
- en: 'Another special scalar type is the enumeration type (`enum`), which is used
    to define a particular set of allowed values. Let’s define an order status enumeration,
    as shown here:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个特殊的标量类型是枚举类型（`enum`），用于定义一组允许的值。让我们定义一个订单状态枚举，如下所示：
- en: '[PRE9]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, the `OrderStatus` enumeration type represents the order status at a given
    point in time.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`OrderStatus`枚举类型表示在特定时间点的订单状态。
- en: We’ll next examine GraphQL fragments in the following subsection before exploring
    other types.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在探索其他类型之前，我们将先检查以下子节中的GraphQL片段。
- en: Understanding fragments
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解片段
- en: You may encounter conflicting scenarios while querying on the client side. You
    may have two or more queries that return the same result (the same object or set
    of fields). To avoid this conflict, you can give the query result a name. This
    name is known as an **alias**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端查询时，您可能会遇到冲突的场景。您可能有两个或多个查询返回相同的结果（相同的对象或字段集）。为了避免这种冲突，您可以给查询结果起一个名字。这个名字被称为**别名**。
- en: 'Let’s use an alias in the following query:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下查询中使用一个别名：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, `HomeAndBillingAddress` is a named query that contains the `getAddress`
    query operation. `getAddress` is being used twice, which results in it returning
    the same set of fields. Therefore, the `home` and `billing` aliases are used to
    differentiate the result object.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`HomeAndBillingAddress`是一个包含`getAddress`查询操作的命名查询。`getAddress`被使用了两次，这导致它返回相同的字段集。因此，使用`home`和`billing`别名来区分结果对象。
- en: The `getAddress` query may return the `Address` object. The `Address` object
    may have additional fields, such as `type`, `state`, `country`, and `contactNo`.
    So, when you have queries that may use the same set of fields, you can create
    a **fragment** and use it in queries. A fragment logically creates a subgroup
    of fields from the existing object in the GraphQL schema that can be reused at
    multiple places, as shown in the following code snippet.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`getAddress` 查询可能会返回 `Address` 对象。`Address` 对象可能有额外的字段，如 `type`、`state`、`country`
    和 `contactNo`。因此，当你有可能会使用相同字段集的查询时，你可以创建一个 **片段** 并在查询中使用它。片段逻辑上从 GraphQL 模式中的现有对象创建字段子集，可以在多个地方重复使用，如下面的代码片段所示。'
- en: 'Let’s create a fragment and replace the common fields in the previous code
    block:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个片段并替换前面代码块中的公共字段：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, the `addressFragment` fragment has been created and used in the query.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`addressFragment` 片段已经被创建并用于查询中。
- en: You can also create an `contains the nested object and you just want a few fields
    of the nested object rather than all the object fields. Inline fragments can be
    used when a querying field returns an **Interface**` **or `Union` type. We will
    explore inline fragments in more detail later in the *Understanding interfaces*
    subsection under the *Designing a GraphQL* *schema* section.**
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以创建一个 `contains the nested object and you just want a few fields of the nested
    object rather than all the object fields. Inline fragments can be used when a
    querying field returns an **Interface**` **or `Union` type. We will explore inline
    fragments in more detail later in the *Understanding interfaces* subsection under
    the *Designing a GraphQL* *schema* section.**
- en: '**We’ll look at GraphQL interfaces in the next subsection.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们将在下一小节中查看 GraphQL 接口。**'
- en: Understanding interfaces
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解接口
- en: GraphQL interfaces are abstract. You may have a few fields that are common across
    multiple objects. You can create an `interface` type for such sets of fields.
    For example, a product may have some common attributes, such as ID, name, and
    description. The product can also have other attributes based on its type. For
    example, a book may have several pages, an author, and a publisher, while a bookcase
    may have material, width, height, and depth attributes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL 接口是抽象的。你可能有几个字段在多个对象中是通用的。你可以为这样的字段集创建一个 `interface` 类型。例如，产品可能有一些共同属性，如
    ID、名称和描述。产品还可以根据其类型具有其他属性。例如，一本书可能有几页、作者和出版社，而书架可能有材料、宽度、高度和深度属性。
- en: 'Let’s define these three objects (`Product`, `Book`, and `Bookcase`) using
    interfaces:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用接口关键字定义这三个对象（`Product`、`Book` 和 `Bookcase`）：
- en: '[PRE12]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here, an abstract type called `Product` has been created using the `interface`
    keyword. This interface can be implemented when we wish to create new object types
    – `Book` and `Bookcase`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用 `interface` 关键字创建了一个名为 `Product` 的抽象类型。当我们希望创建新的对象类型 - `Book` 和 `Bookcase`
    时，可以实现此接口。
- en: 'Now, you can simply write the following query that will return all the products
    (books and bookcases):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以简单地编写以下查询，它将返回所有产品（书籍和书架）：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, you can use the following query on the client side to retrieve all the
    products:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在客户端使用以下查询来检索所有产品：
- en: '[PRE14]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You might have noticed that the preceding code only contains attributes from
    the `Product` interface. If you want to retrieve attributes from `Book` and `Bookcase`,
    then you must use **inline fragments**, as shown here:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到前面的代码只包含来自 `Product` 接口的属性。如果你想从 `Book` 和 `Bookcase` 获取属性，那么你必须使用 **内联片段**，如下所示：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, an operation (`…`) is used to create inline fragments. This way, you can
    fetch the fields from the type that implements the interface.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用操作符（`…`）用于创建内联片段。这样，你可以从实现接口的类型中获取字段。
- en: We’ll understand `Union` types in the next subsection.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中理解 `Union` 类型。
- en: Understanding Union types
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解联合类型
- en: Let’s say there are two object types – `Book` and `Author`. Here, you want to
    write a GraphQL query that can return both books and authors. Note that the interface
    is not there; so, how can we combine both objects in the query result? In such
    cases, you can use a **Union type**, which is a combination of two or more objects.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有两种对象类型 - `Book` 和 `Author`。在这里，你想要编写一个 GraphQL 查询，它可以返回书籍和作者。请注意，接口不存在；那么我们如何在查询结果中结合这两个对象？在这种情况下，你可以使用
    **联合类型**，它是由两个或多个对象组合而成的。
- en: 'Consider the following before creating a `Union` type:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Union` 类型之前，请考虑以下内容：
- en: You don’t need to have a common field.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不需要有公共字段。
- en: Union members should be of a concrete type. Therefore, you can’t use `union`,
    `interface`, `input`, or `scalar` types.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联合成员应该是具体类型。因此，你不能使用 `union`、`interface`、`input` 或 `scalar` 类型。
- en: 'Let’s create a `union` type that can return any object included in the `union`
    type – books and bookcases – as shown in the following code block:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个可以返回 `union` 类型中包含的任何对象的 `union` 类型 – 书籍和书架 – 如以下代码块所示：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, the `union` keyword is used to create a `union` type for the `Book` and
    `Author` objects. A pipe symbol (`|`) is used to separate the included objects.
    Finally, a query is defined that returns a collection of books or authors that
    contain the given text.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，使用 `union` 关键字为 `Book` 和 `Author` 对象创建了一个 `union` 类型。使用管道符号（`|`）来分隔包含的对象。最后，定义了一个查询，返回包含给定文本的书籍或作者集合。
- en: 'Now, let’s write this query for the client, as shown here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为客户编写这个查询，如下所示：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, an inline fragment is used in the query. Another important point
    is the extra field, called `__typename`, which refers to the object it belongs
    to and helps you differentiate between different objects in the client.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，查询中使用了内联片段。另一个重要点是额外的字段，称为 `__typename`，它引用所属的对象并帮助您在客户端区分不同的对象。
- en: We’ll look at input types in the next subsection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中查看输入类型。
- en: Understanding input types
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解输入类型
- en: So far, you have used scalar types as arguments. GraphQL also allows you to
    pass object types as arguments in mutations. The only difference is that you have
    to declare them with `input` instead of using the `type` keyword.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经使用了标量类型作为参数。GraphQL 还允许您在突变中传递对象类型作为参数。唯一的区别是您必须使用 `input` 关键字来声明它们，而不是使用
    `type` 关键字。
- en: 'Let’s create a mutation that accepts an input type as an argument:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个接受输入类型作为参数的突变：
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, the `addProduct` mutation accepts `ProductInput` as an argument and returns
    `Product`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`addProduct` 突变接受 `ProductInput` 作为参数并返回 `Product`。
- en: 'Now, let’s use the GraphQL request to add a product to the client, as shown
    here:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用 GraphQL 请求向客户端添加产品，如下所示：
- en: '[PRE19]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, you are running a mutation that uses an `input` variable. You might have
    observed that `Variable` is being used here to pass `ProductInput`. The named
    mutation is used for the variable. If variables, along with their types, are defined
    in the mutation, then they should be used in the mutation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您正在运行一个使用 `input` 变量的突变。您可能已经注意到这里使用了 `Variable` 来传递 `ProductInput`。命名突变用于变量。如果突变中定义了变量及其类型，则应在突变中使用它们。
- en: Variable values should be assigned in the variable section (or beforehand in
    the client). The value of a variable’s input is assigned using a JSON object that
    should map to `ProductInput`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的值应在变量部分（或在客户端之前）分配。变量的输入值使用一个映射到 `ProductInput` 的 JSON 对象来分配。
- en: We’ll look at the tools we can use while designing a GraphQL schema in the next
    subsection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中查看在设计 GraphQL 模式时我们可以使用的工具。
- en: Designing a schema with GraphQL tools
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GraphQL 工具设计模式
- en: 'You can use the following tools for design and work with GraphQL, with each
    having its own offerings:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下工具进行设计和与 GraphQL 一起工作，每个工具都有自己的特色：
- en: '**GraphiQL**: This is pronounced *graphical*. It is an official GraphQL Foundation
    project that provides the web-based GraphQL **IDE**. It makes use of **Language
    Server Protocol** (**LSP**), which uses the JSON-RPC-based protocol between the
    source code editor and the IDE. It is available at [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphiQL**：这个发音为 *graphical*。它是一个官方的 GraphQL 基金会项目，提供了一个基于网络的 GraphQL **IDE**。它使用了
    **语言服务器协议**（**LSP**），该协议在源代码编辑器和 IDE 之间使用基于 JSON-RPC 的协议。它可在 [https://github.com/graphql/graphiql](https://github.com/graphql/graphiql)
    获取。'
- en: '**GraphQL Playground**: This is another popular GraphQL IDE that once provided
    better features than GraphiQL. However, GraphiQL now has feature parity with Playground.
    At the time of writing, GraphQL Playground is in maintenance mode. Check out [https://github.com/graphql/graphql-playground/issues/1366](https://github.com/graphql/graphql-playground/issues/1366)
    for more details. It is available at [https://github.com/graphql/graphql-playground](https://github.com/graphql/graphql-playground).'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphQL Playground**：这是另一个流行的 GraphQL IDE，它曾经提供了比 GraphiQL 更好的功能。然而，现在 GraphiQL
    与 Playground 具有功能一致性。在撰写本文时，GraphQL Playground 处于维护模式。有关更多详细信息，请查看 [https://github.com/graphql/graphql-playground/issues/1366](https://github.com/graphql/graphql-playground/issues/1366)。它可在
    [https://github.com/graphql/graphql-playground](https://github.com/graphql/graphql-playground)
    获取。'
- en: '**GraphQL Faker**: This provides mock data for your GraphQL APIs. It is available
    at [https://github.com/APIs-guru/graphql-faker](https://github.com/APIs-guru/graphql-faker).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphQL Faker**：这为你的GraphQL API提供模拟数据。它可在[https://github.com/APIs-guru/graphql-faker](https://github.com/APIs-guru/graphql-faker)找到。'
- en: '**GraphQL Editor**: This allows you to design your schema visually and then
    transform it into code. It is available at [https://github.com/graphql-editor/graphql-editor](https://github.com/graphql-editor/graphql-editor).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphQL编辑器**：这允许你可视化地设计你的模式，然后将其转换为代码。它可在[https://github.com/graphql-editor/graphql-editor](https://github.com/graphql-editor/graphql-editor)找到。'
- en: '**GraphQL Voyager**: This converts your schema into interactive graphs, such
    as entity diagrams and all the relationships among these entities. It is available
    at [https://github.com/APIs-guru/graphql-voyager](https://github.com/APIs-guru/graphql-voyager).'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GraphQL Voyager**：这把你的模式转换为交互式图表，如实体图以及这些实体之间所有的关系。它可在[https://github.com/APIs-guru/graphql-voyager](https://github.com/APIs-guru/graphql-voyager)找到。'
- en: In the next section, you’ll test the knowledge that you have acquired throughout
    this chapter.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将测试本章所学到的知识。
- en: Testing GraphQL queries and mutations
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试GraphQL查询和突变
- en: 'Let’s write queries and mutations in a real GraphQL schema to test the skills
    you have learned up to this point using GitHub’s GraphQL API explorer. Let’s perform
    the following steps:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在实际的GraphQL模式中编写查询和突变，以测试你使用GitHub的GraphQL API探索器学到的能力。让我们执行以下步骤：
- en: First, go to [https://docs.github.com/en/graphql/overview/explorer](https://docs.github.com/en/graphql/overview/explorer).
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，访问[https://docs.github.com/en/graphql/overview/explorer](https://docs.github.com/en/graphql/overview/explorer)。
- en: You might have to authorize it using your GitHub account, so that you can execute
    GraphQL queries.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能需要使用你的GitHub账户授权它，这样你就可以执行GraphQL查询。
- en: 'GitHub Explorer is based on GraphiQL. It is divided into three vertical sections
    (from left to right in the gray area in *Figure 13**.1*):'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitHub探索器基于GraphiQL。它分为三个垂直部分（从左到右在*图13.1*的灰色区域中）：
- en: The left-hand section is divided into two subsections – an upper section for
    writing queries and a bottom section for defining variables.
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧部分分为两个子部分——一个用于编写查询的上部区域和一个用于定义变量的下部区域。
- en: The middle vertical section shows the response.
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的垂直部分显示了响应。
- en: Normally, the rightmost section is hidden. Click on the **Docs** link to display
    it. It shows the respective documentation and schema, along with the root types
    that you can explore.
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，最右侧的部分是隐藏的。点击**文档**链接来显示它。它显示了相应的文档和模式，以及你可以探索的根类型。
- en: '![Figure 13.1 – GraphQL API Explorer](img/Figure_13.1_B19349.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – GraphQL API探索器](img/Figure_13.1_B19349.jpg)'
- en: Figure 13.1 – GraphQL API Explorer
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – GraphQL API探索器
- en: 'Let’s fire the following query to find out the ID of the repository you wish
    to mark with a star:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们执行以下查询以找出你想要标记为星号的仓库的ID：
- en: '[PRE20]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, you are querying the previous edition of this book’s repository by providing
    two arguments – the repository’s `name` and its `owner`. You are fetching a few
    of the fields. One of the most important ones is `stargazerCount` because we are
    going to perform an `addStar` mutation. This count will tell us whether the mutation
    was successful or not.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你通过提供两个参数——仓库的`name`和其`owner`来查询这本书的上一版仓库。你正在获取一些字段。其中最重要的一个字段是`stargazerCount`，因为我们将要执行一个`addStar`突变。这个计数将告诉我们突变是否成功。
- en: 'Click on the **Execute Query** button on the top bar or press *Ctrl* + *Enter*
    to execute the query. You should get the following output once this query executes
    successfully:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击顶部栏上的**执行查询**按钮或按*Ctrl* + *Enter*键来执行查询。一旦查询成功执行，你应该会得到以下输出：
- en: '[PRE21]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, you need to copy the value of `id` from the response, as it will be needed
    to mark this repository with a star.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你需要复制响应中的`id`值，因为它将用于标记这个仓库。
- en: 'Execute the following query to perform the `addStar` mutation:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下查询以执行`addStar`突变：
- en: '[PRE22]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This performs the `addStar` mutation for the repository with the given ID.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这执行了给定ID的仓库的`addStar`突变。
- en: Once the previous query has executed successfully, you must re-execute the query
    from *step 4* to find out about the change. If you get an access issue, then you
    can choose your own GitHub repository to perform these steps.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦之前的查询成功执行，你必须从*步骤4*重新执行查询以了解更改情况。如果你遇到访问问题，你可以选择自己的GitHub仓库来执行这些步骤。
- en: You can also explore other queries and mutations to deep dive into GraphQL.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以探索其他查询和突变，以深入了解GraphQL。
- en: Finally, let’s understand the N+1 problem in GraphQL queries before we jump
    into the implementation in the next chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们跳到下一章的实现之前，让我们理解在GraphQL查询中N+1问题。
- en: Solving the N+1 problem
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决N+1问题
- en: The N+1 problem is not new to Java developers. You might have encountered this
    problem while using Hibernate, which occurs if you don’t optimize your queries
    or write entities properly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: N+1问题对于Java开发者来说并不陌生。在使用Hibernate时，你可能遇到过这个问题，这通常发生在你没有优化查询或正确编写实体时。
- en: Let’s look at what the N+1 problem is.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看N+1问题是什么。
- en: What is the N+1 problem?
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是N+1问题？
- en: 'The **N+1 problem** normally occurs when associations are involved. There are
    one-to-many relationships between the customer and the order. One customer can
    have many orders. If you need to find all the customers and their orders, you
    can do the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**N+1问题**通常在涉及关联时发生。客户和订单之间存在一对一的关系。一个客户可以有多个订单。如果你需要找到所有客户及其订单，你可以这样做：'
- en: First, find all the users. This find operation returns the list of user objects.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，找到所有用户。这个查找操作返回用户对象列表。
- en: Then, find all the orders belonging to each user found in *step 1*. The `userId`
    field acts as the relation between the `Order` and `User` objects.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在*步骤1*中找到属于每个用户的所有订单。`userId`字段充当`Order`和`User`对象之间的关系。
- en: So, here, you fire two queries. If you further optimize the implementation,
    you can place a *join* between these two entities (`Order` and `User`) and receive
    all the records in a single query.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这里，你执行了两个查询。如果你进一步优化实现，你可以在这两个实体（`Order`和`User`）之间放置一个*连接*，并使用单个查询接收所有记录。
- en: If this is so simple, then why does GraphQL encounter the N+1 problem? You need
    to understand the **resolver** function to answer this question.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这很简单，那么为什么GraphQL会遇到N+1问题？你需要理解**解析器**函数来回答这个问题。
- en: 'If you refer to the database schema you created in [*Chapter 4*](B19349_04.xhtml#_idTextAnchor097),
    *Writing Business Logic for APIs*, you can see that the `getUsersOrders` query
    will lead to the following SQL statements being executed:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你参考你在[*第4章*](B19349_04.xhtml#_idTextAnchor097)中创建的数据库模式，*为API编写业务逻辑*，你可以看到`getUsersOrders`查询将导致以下SQL语句被执行：
- en: '[PRE23]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, to perform the `getUsersOrders()` operation, you execute a query on the
    user to fetch all the users. Then, you executes N queries on orders. This is why
    it is called the N+1 problem. This is not efficient because ideally you should
    execute a single query, or in the worst case, two queries.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，为了执行`getUsersOrders()`操作，你将对用户执行查询以获取所有用户。然后，你对订单执行N次查询。这就是为什么它被称为N+1问题。这并不高效，因为理想情况下你应该执行单个查询，或者在最坏的情况下，执行两个查询。
- en: 'GraphQL can only respond with the values of fields that have been requested
    in the query due to resolvers. Each field has its own resolver function in the
    GraphQL server implementation that fetches the data for its corresponding field.
    Let’s assume we have the following schema:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 由于解析器的存在，GraphQL只能响应查询中请求的字段值。在GraphQL服务器的实现中，每个字段都有自己的解析函数，用于获取其对应字段的数據。让我们假设我们有以下模式：
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here, we have a mutation that returns a collection of users. Each `User` may
    have a collection of orders. You could therefore use the following query in the
    client:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个返回用户集合的突变。每个`User`可能有一个订单集合。因此，你可以在客户端使用以下查询：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Let’s understand how this query will be processed by the server.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解这个查询是如何被服务器处理的。
- en: In the server, each field will have its own resolver function that fetches the
    corresponding data. The first resolver will be for the user and will fetch all
    the users from the data store. Next, the resolver will fetch orders for each user.
    It will fetch the orders from the data store based on the given user ID. Therefore,
    the `orders` resolver will execute `n` times, where `n` is the number of users
    that have been fetched from the data store.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器中，每个字段都将有自己的解析函数，用于获取对应的数据。第一个解析器将是用户解析器，将从数据存储中获取所有用户。接下来，解析器将为每个用户获取订单。它将根据给定的用户ID从数据存储中获取订单。因此，`orders`解析器将执行n次，其中n是从数据存储中获取的用户数量。
- en: We’ll learn how to resolve the N+1 problem in the next subsection.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一小节中学习如何解决N+1问题。
- en: How can we solve the N+1 problem?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们如何解决N+1问题？
- en: The required solution will wait until all the orders have been loaded. Once
    all the user IDs have been retrieved, a database call should be made to fetch
    all the orders in a single data-store call. You can use a batch if the size of
    the database is huge. Then, the executer can resolve the individual order resolvers.
    However, this is easier said than done. GraphQL provides a library called **DataLoader**
    ([https://github.com/graphql/dataloader](https://github.com/graphql/dataloader))
    that does this job for you. This library mainly performs the batching and caching
    of queries.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 所需的解决方案将等待直到所有订单都已加载。一旦检索到所有用户ID，就应该在单个数据存储调用中调用数据库以获取所有订单。如果数据库的大小很大，可以使用批量操作。然后，执行者可以解决单个订单解析器。然而，说起来容易做起来难。GraphQL
    提供了一个名为 **DataLoader** 的库 ([https://github.com/graphql/dataloader](https://github.com/graphql/dataloader))，它可以为你完成这项工作。这个库主要执行查询的批量和缓存。
- en: Java provides a similar library called **java-dataloader** ([https://github.com/graphql-java/java-dataloader](https://github.com/graphql-java/java-dataloader))
    that can help you solve this problem. You can find out more about it at [https://www.graphql-java.com/documentation/batching](https://www.graphql-java.com/documentation/batching).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Java 提供了一个类似的库，名为 **java-dataloader** ([https://github.com/graphql-java/java-dataloader](https://github.com/graphql-java/java-dataloader))，可以帮助你解决这个问题。你可以在
    [https://www.graphql-java.com/documentation/batching](https://www.graphql-java.com/documentation/batching)
    上了解更多信息。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about GraphQL, its advantages, and how it compares
    to REST. You learned how GraphQL solves over-fetching and under-fetching problems.
    You then learned about GraphQL’s root types – queries, mutations, and subscriptions
    – and how different blocks can help you design the GraphQL schema. Finally, you
    understood how resolvers work, how they can lead to the N+1 problem, and the solution
    to this problem.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了 GraphQL、它的优势以及它与 REST 的比较。你学习了 GraphQL 如何解决过度获取和不足获取的问题。然后，你学习了 GraphQL
    的根类型——查询、突变和订阅——以及不同的块如何帮助你设计 GraphQL 模式。最后，你了解了解析器的工作原理，它们如何导致 N+1 问题以及这个问题的解决方案。
- en: Now that you know about the fundamentals of GraphQL, you can start designing
    GraphQL schemas. You also learned about GraphQL’s client-side queries and how
    to make use of aliases, fragments, and variables to resolve common problems.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了 GraphQL 的基础知识，你可以开始设计 GraphQL 模式。你还学习了 GraphQL 的客户端查询以及如何使用别名、片段和变量来解决常见问题。
- en: In the next chapter, you will make use of the GraphQL skills you acquired in
    this chapter to implement GraphQL APIs.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将利用本章学到的 GraphQL 技能来实现 GraphQL API。
- en: Questions
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Is GraphQL better than REST? If yes, then in what way?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GraphQL 是否比 REST 更好？如果是的话，那是在哪些方面？
- en: When should you use fragments?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 何时应该使用片段？
- en: How can you use variables in a GraphQL query?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在 GraphQL 查询中使用变量？
- en: Answers
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: It depends on the use cases. However, GraphQL performs much better for mobile
    apps and web-based UI applications and is best suited for **service-to-service**
    (**s2s**) communications.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这取决于用例。然而，GraphQL 对于移动应用和基于 Web 的 UI 应用程序性能更好，最适合 **服务到服务** （**s2s**） 通信。
- en: Fragments should be used while sending a request from the GraphQL client when
    the response contains an interface or union.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当响应包含接口或联合时，应该在从 GraphQL 客户端发送请求时使用片段。
- en: 'You can use a variable in a GraphQL query/mutation, as shown in the following
    code. This code used to modify the GraphQL request sent in *step 6* of the *Testing
    GraphQL queries and* *mutations* section:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以在 GraphQL 查询/突变中使用变量，如下面的代码所示。这段代码曾用于修改 *测试 GraphQL 查询和突变* 部分的 *步骤 6* 中发送的
    GraphQL 请求：
- en: '[PRE26]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, you can see that the `$repoId` variable is used. You must declare that
    variable in the named mutation and it can then be used in the mutation’s argument,
    as shown in the following code snippet:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到使用了 `$repoId` 变量。你必须在该命名的突变中声明该变量，然后它就可以在突变参数中使用，如下面的代码片段所示：
- en: '[PRE27]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Further reading
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'GraphQL specifications: [https://spec.graphql.org/](https://spec.graphql.org/)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 规范：[https://spec.graphql.org/](https://spec.graphql.org/)
- en: 'GraphQL documentation: [https://graphql.org/learn/](https://graphql.org/learn/)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GraphQL 文档：[https://graphql.org/learn/](https://graphql.org/learn/)
- en: '*Full-Stack Web Development with GraphQL and* *React*: [https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880](https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880)**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 GraphQL 和 React 进行全栈 Web 开发*：[https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880](https://www.packtpub.com/product/full-stack-web-development-with-graphql-and-react-second-edition/9781801077880)**'
