<html><head></head><body>
<div id="_idContainer038" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor123" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-92" class="calibre6"><a id="_idTextAnchor124" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.2.1">GraalVM</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In the ever-evolving landscape of JVMs, GraalVM stands out as a revolutionary and versatile alternative. </span><span class="kobospan" id="kobo.3.2">This chapter delves into the intricacies of GraalVM, unraveling its unique features and shedding light on its role as a game-changer in the realm of JVM internals. </span><span class="kobospan" id="kobo.3.3">GraalVM, developed by Oracle Labs, transcends the traditional boundaries of a conventional JVM by providing a polyglot runtime that supports multiple languages, including Java, JavaScript, Python, Ruby, and more. </span><span class="kobospan" id="kobo.3.4">This flexibility opens up new avenues for developers, allowing them to integrate different languages within a single application seamlessly. </span><span class="kobospan" id="kobo.3.5">As we navigate the pages of this chapter, you’ll gain a comprehensive understanding of GraalVM’s architecture, its distinctive components, and its pivotal role in reshaping the landscape of </span><span><span class="kobospan" id="kobo.4.1">Java development.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">GraalVM’s architecture is a testament not only to its engineering prowess but also to its commitment to performance and efficiency. </span><span class="kobospan" id="kobo.5.2">The chapter not only explores the underlying architecture and components of GraalVM but also highlights its innovative JIT compiler, which is at the heart of its efficiency. </span><span class="kobospan" id="kobo.5.3">Understanding the nuts and bolts of GraalVM’s architecture is essential for developers looking to harness its power to optimize and enhance the performance of their applications. </span><span class="kobospan" id="kobo.5.4">Additionally, we’ll delve into real-world use cases, showcasing scenarios where GraalVM excels and the unique problems it addresses. </span><span class="kobospan" id="kobo.5.5">Whether you’re aiming to boost the execution speed of your Java applications or seeking a seamless integration of multiple languages, GraalVM emerges as a compelling solution, and this chapter will guide you through its capabilities and potential applications. </span><span class="kobospan" id="kobo.5.6">Get ready to explore the cutting-edge features of GraalVM and unlock a new dimension of possibilities in the ever-evolving landscape of </span><span><span class="kobospan" id="kobo.6.1">JVM internals.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">In this chapter, we’ll explore </span><span><span class="kobospan" id="kobo.8.1">the topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><span class="kobospan" id="kobo.9.1">GraalVM overview</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.10.1">Native Image</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.11.1">Creating a </span><span><span class="kobospan" id="kobo.12.1">Native Image</span></span></li>
</ul>
<h1 id="_idParaDest-93" class="calibre6"><a id="_idTextAnchor125" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.13.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.14.1">For this chapter, you will require </span><span><span class="kobospan" id="kobo.15.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><span class="kobospan" id="kobo.16.1">GraalVM 21</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.17.1">Git</span></span></li>
<li class="calibre14"><span><span class="kobospan" id="kobo.18.1">Maven</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.19.1">Any </span><span><span class="kobospan" id="kobo.20.1">preferred IDE</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.21.1">This chapter’s GitHub repository, found at - </span><a href="https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07" class="calibre4 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.22.1">https://github.com/PacktPublishing/Mastering-the-Java-Virtual-Machine/tree/main/chapter-07</span></span></a></li>
</ul>
<h1 id="_idParaDest-94" class="calibre6"><a id="_idTextAnchor126" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.23.1">GraalVM overview</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.24.1">In this enlightening section, we’ll embark on a journey through the groundbreaking landscape of GraalVM, an innovation</span><a id="_idIndexMarker448" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.25.1"> that has redefined the expectations of a JVM. </span><span class="kobospan" id="kobo.25.2">GraalVM’s rise to prominence can be attributed to its sensational features, with a special emphasis on its high-performance compiler, </span><strong class="bold"><span class="kobospan" id="kobo.26.1">ahead-of-time</span></strong><span class="kobospan" id="kobo.27.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.28.1">AOT</span></strong><span class="kobospan" id="kobo.29.1">) compilation, and prowess in</span><a id="_idIndexMarker449" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.30.1"> managing diverse </span><span><span class="kobospan" id="kobo.31.1">language runtimes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.32.1">At the heart of GraalVM’s exceptional performance lies its state-of-the-art JIT compiler. </span><span class="kobospan" id="kobo.32.2">This compiler is meticulously engineered to optimize the execution of Java applications, pushing the boundaries of speed and efficiency. </span><span class="kobospan" id="kobo.32.3">Unlike traditional JVMs, GraalVM’s JIT compiler boasts advanced techniques and optimizations, resulting in faster startup times and reduced memory footprint. </span><span class="kobospan" id="kobo.32.4">Therefore, developers experience a significant boost in the overall performance of their applications, making GraalVM an invaluable tool for those striving for excellence in </span><span><span class="kobospan" id="kobo.33.1">execution speed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.34.1">GraalVM introduces a paradigm shift with its AOT compilation, enabling developers to pre-compile their programs into native machine code. </span><span class="kobospan" id="kobo.34.2">This approach eliminates the need for JIT compilation during runtime, resulting in faster startup times and lower memory consumption. </span><span class="kobospan" id="kobo.34.3">AOT compilation opens up new horizons for GraalVM, making it an ideal choice for scenarios where rapid startup and reduced latency are critical. </span><span class="kobospan" id="kobo.34.4">This section will explore the intricacies of AOT compilation and guide you on harnessing its power to optimize </span><span><span class="kobospan" id="kobo.35.1">your applications.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.36.1">GraalVM transcends the confines of a traditional JVM by offering a multilingual runtime environment. </span><span class="kobospan" id="kobo.36.2">This means developers can seamlessly integrate and execute programs written in multiple languages within the same application. </span><span class="kobospan" id="kobo.36.3">From Java and JavaScript to Python, Ruby, and more, GraalVM supports various languages, fostering a polyglot ecosystem. </span><span class="kobospan" id="kobo.36.4">This section will delve into the implications of polyglot capabilities, demonstrating how developers </span><a id="_idIndexMarker450" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.37.1">can leverage this feature to build versatile and efficient applications that transcend </span><span><span class="kobospan" id="kobo.38.1">language barriers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.39.1">While GraalVM brings many innovative features, like any technology, it comes with trade-offs. </span><span class="kobospan" id="kobo.39.2">This section aims to shed light on these considerations, helping developers make informed decisions on when and where to harness the power </span><span><span class="kobospan" id="kobo.40.1">of GraalVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.41.1">While balancing benefits such as enhanced runtime and polyglot capabilities, developers must also consider factors like increased memory usage, longer compilation times, and compatibility nuances. </span><span class="kobospan" id="kobo.41.2">Exploring these trade-offs will empower developers to make informed decisions tailored to their project requirements. </span><span class="kobospan" id="kobo.41.3">Understanding these intricacies enables a strategic application of GraalVM’s strengths while mitigating potential challenges in specific </span><span><span class="kobospan" id="kobo.42.1">use cases:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.43.1">Memory overhead</span></strong><span class="kobospan" id="kobo.44.1">: A slight increase in memory usage often accompanies GraalVM’s impressive performance gains. </span><span class="kobospan" id="kobo.44.2">The advanced optimizations and versatile language support contribute to </span><a id="_idIndexMarker451" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.45.1">a more substantial memory footprint than some traditional JVMs. </span><span class="kobospan" id="kobo.45.2">Developers must weigh the performance benefits against the potential impact on memory resources, particularly in environments with stringent </span><span><span class="kobospan" id="kobo.46.1">memory constraints.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.47.1">Compilation time</span></strong><span class="kobospan" id="kobo.48.1">: While GraalVM’s JIT compiler is a powerhouse for runtime performance, it’s worth noting that the initial compilation time may be longer compared to other JVMs. </span><span class="kobospan" id="kobo.48.2">Developers working on short-lived applications or scenarios where quick startup is critical should carefully assess whether the benefits of runtime performance outweigh the longer compilation times during </span><span><span class="kobospan" id="kobo.49.1">application initialization.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.50.1">Compatibility</span></strong><span class="kobospan" id="kobo.51.1">: While GraalVM supports a wide array of languages, certain language features or libraries might not be fully compatible. </span><span class="kobospan" id="kobo.51.2">Developers need to consider their projects’ specific language requirements and ensure that GraalVM provides adequate support. </span><span class="kobospan" id="kobo.51.3">Compatibility issues may require additional effort in</span><a id="_idIndexMarker452" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.52.1"> adapting or optimizing code to work seamlessly </span><span><span class="kobospan" id="kobo.53.1">with GraalVM.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">Identifying the optimal scenarios for leveraging GraalVM’s strengths requires a targeted assessment of best use cases. </span><span class="kobospan" id="kobo.54.2">In microservices and serverless architectures, GraalVM’s superior performance and reduced memory footprint align seamlessly with the agility demands of these environments. </span><span class="kobospan" id="kobo.54.3">Its polyglot capabilities make it ideal for projects involving multiple languages, fostering a cohesive runtime environment. </span><span class="kobospan" id="kobo.54.4">High-performance computing applications benefit from GraalVM’s advanced JIT compilation, accelerating computation-intensive tasks. </span><span class="kobospan" id="kobo.54.5">Additionally, resource-intensive applications in cloud environments can capitalize on GraalVM’s efficiency in resource utilization without compromising performance. </span><span class="kobospan" id="kobo.54.6">Developers can strategically employ GraalVM to maximize its advantages in diverse application scenarios by pinpointing these </span><span><span class="kobospan" id="kobo.55.1">use cases:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.56.1">Microservices and serverless architectures</span></strong><span class="kobospan" id="kobo.57.1">: GraalVM’s impressive performance gains and reduced </span><a id="_idIndexMarker453" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.58.1">memory footprint make it well-suited for microservices and serverless architectures. </span><span class="kobospan" id="kobo.58.2">The faster startup times and efficient resource utilization align with the demands of these environments where agility and responsiveness </span><span><span class="kobospan" id="kobo.59.1">are paramount.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.60.1">Polyglot applications</span></strong><span class="kobospan" id="kobo.61.1">: The polyglot capabilities of GraalVM shine in scenarios where applications are built using multiple programming languages. </span><span class="kobospan" id="kobo.61.2">If your project involves components written in Java, JavaScript, Python, Ruby, and more, GraalVM’s ability to seamlessly integrate these languages within a single runtime environment becomes a </span><span><span class="kobospan" id="kobo.62.1">decisive advantage.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.63.1">High-performance computing</span></strong><span class="kobospan" id="kobo.64.1">: Applications with a focus on high-performance computing, such as scientific simulations or data processing, can benefit from GraalVM’s advanced JIT compilation. </span><span class="kobospan" id="kobo.64.2">The enhanced runtime performance can significantly accelerate </span><span><span class="kobospan" id="kobo.65.1">computation-intensive tasks.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.66.1">Resource-intensive applications</span></strong><span class="kobospan" id="kobo.67.1">: GraalVM’s efficiency in resource utilization makes it an excellent choice for resource-intensive applications, particularly in cloud-based environments. </span><span class="kobospan" id="kobo.67.2">Developers can leverage GraalVM to optimize resource consumption without compromising </span><span><span class="kobospan" id="kobo.68.1">on performance.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.69.1">In conclusion, GraalVM</span><a id="_idIndexMarker454" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.70.1"> presents a compelling option for various scenarios, especially where the trade-offs align with the project’s priorities and constraints. </span><span class="kobospan" id="kobo.70.2">By carefully evaluating the application’s specific needs, developers can harness the full potential of GraalVM in scenarios where its strengths shine </span><span><span class="kobospan" id="kobo.71.1">the brightest.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.72.1">As we conclude our exploration of GraalVM and its nuanced considerations, it becomes evident that this innovative JVM alternative is a force to be reckoned with in the ever-evolving landscape of Java development. </span><span class="kobospan" id="kobo.72.2">From its high-performance JIT compiler to polyglot language runtimes, GraalVM offers a compelling set of features that can elevate application development to new heights. </span><span class="kobospan" id="kobo.72.3">While we’ve discussed the trade-offs involved, it’s crucial to recognize that these considerations are integral to making informed decisions in line with specific </span><span><span class="kobospan" id="kobo.73.1">project requirements.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.74.1">Moreover, our journey through GraalVM’s best use cases has unveiled scenarios where its strengths shine brightest, from microservices architectures to resource-intensive cloud applications. </span><span class="kobospan" id="kobo.74.2">However, the story doesn’t end here. </span><span class="kobospan" id="kobo.74.3">GraalVM’s Native Image functionality takes the narrative further by allowing developers to compile applications ahead of time into standalone executables, completely sidestepping the need for a JVM during deployment. </span><span class="kobospan" id="kobo.74.4">It sets the stage for a deeper dive into Native Image, where GraalVM’s capabilities are extended to provide an even more streamlined, efficient, and resource-friendly approach to application deployment. </span><span class="kobospan" id="kobo.74.5">As we unravel the possibilities unlocked by GraalVM’s Native Image, reshaping the landscape of Java development with unparalleled efficiency </span><span><span class="kobospan" id="kobo.75.1">and innov</span><a id="_idTextAnchor127" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.76.1">ation.</span></span></p>
<h1 id="_idParaDest-95" class="calibre6"><a id="_idTextAnchor128" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.77.1">Native Image</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.78.1">Welcome to an illuminating session dedicated to GraalVM, a game-changing technology that transcends the conventional boundaries </span><a id="_idIndexMarker455" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.79.1">of JVMs. </span><span class="kobospan" id="kobo.79.2">Developed by Oracle Labs, GraalVM emerges as a multifaceted solution, introducing revolutionary features that redefine the application development landscape. </span><span class="kobospan" id="kobo.79.3">This section serves as your gateway to understanding the key facets of GraalVM, from its high-performance JIT compiler to its polyglot language runtimes and innovative AOT compilation. </span><span class="kobospan" id="kobo.79.4">As we delve into GraalVM’s architecture and capabilities, you’ll gain insights into how it addresses the evolving needs of modern applications. </span><span class="kobospan" id="kobo.79.5">Join us on this exploration of GraalVM, where innovation meets versatility, and discover how it empowers developers to create efficient, polyglot applications that push the boundaries of what’s possible in the </span><span><span class="kobospan" id="kobo.80.1">Java ecosystem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.81.1">One of the most distinctive features of GraalVM is its Native Image functionality, a transformative capability that propels application deployment into a new era. </span><span class="kobospan" id="kobo.81.2">Unlike traditional Java applications running on a JVM, GraalVM’s Native Image empowers developers to compile their applications ahead of time into standalone executables. </span><span class="kobospan" id="kobo.81.3">Instead of relying on a JVM during deployment, the application is packaged as a self-contained binary directly</span><a id="_idIndexMarker456" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.82.1"> interacting with the operating system, bypassing the need for an intermediary </span><span><span class="kobospan" id="kobo.83.1">virtual machine.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.84.1">The key advantage of the Native Image approach lies in its efficiency gains during both startup time and runtime performance. </span><span class="kobospan" id="kobo.84.2">By eliminating the need for a JVM to interpret and execute the code, Native Image significantly reduces the application’s startup time, making it ideal for scenarios where rapid responsiveness is crucial. </span><span class="kobospan" id="kobo.84.3">Moreover, the absence of a JVM reduces the application’s memory footprint, enhancing resource utilization and making it more suitable for </span><span><span class="kobospan" id="kobo.85.1">resource-constrained environments.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.86.1">However, it should also be highlighted that AOT compilation removes the exact benefits of JIT compilation as the bytecode is no longer available at runtime to optimize the code concerning changing code behavior. </span><span class="kobospan" id="kobo.86.2">In many cases where applications run for a longer time, the gain of a quick startup, while notable, may be partially offset because the overall performance is lower due to the absence of dynamic runtime optimizations. </span><span class="kobospan" id="kobo.86.3">For a detailed exploration of this trade-off between AOT and JIT, you can refer to this insightful </span><span><span class="kobospan" id="kobo.87.1">presentation: </span></span><a href="https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/" class="calibre4 pcalibre pcalibre1"><span><span class="kobospan" id="kobo.88.1">https://www.azul.com/blog/jit-performance-ahead-of-time-versus-just-in-time/</span></span></a><span><span class="kobospan" id="kobo.89.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.90.1">While GraalVM’s Native Image feature brings notable advantages in terms of startup time, memory efficiency, and resource utilization, it also comes with trade-offs that developers should </span><span><span class="kobospan" id="kobo.91.1">carefully consider:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.92.1">Build time and complexity</span></strong><span class="kobospan" id="kobo.93.1">: Creating a Native Image involves AOT compilation, which occurs during the build phase. </span><span class="kobospan" id="kobo.93.2">This compilation process is more time-consuming compared to traditional JIT compilation used in JVM-based applications. </span><span class="kobospan" id="kobo.93.3">Additionally, configuring the Native Image build can be more intricate, requiring developers to manage native libraries, reflective access, and other considerations to achieve </span><span><span class="kobospan" id="kobo.94.1">optimal results.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.95.1">Dynamic class loading and reflection</span></strong><span class="kobospan" id="kobo.96.1">: Native Image requires a static analysis of the application’s code during compilation, which can pose challenges for applications that heavily rely on dynamic class loading or reflection. </span><span class="kobospan" id="kobo.96.2">Since the Native Image</span><a id="_idIndexMarker457" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.97.1"> compiler needs to know the complete set of classes and methods at build time, dynamically loaded or generated code may need special handling, potentially requiring adjustments to the </span><span><span class="kobospan" id="kobo.98.1">application code.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.99.1">Limited runtime profile</span></strong><span class="kobospan" id="kobo.100.1">: AOT compilation necessitates a comprehensive understanding of the application’s behavior during the build phase. </span><span class="kobospan" id="kobo.100.2">It can be challenging for applications with complex runtime behaviors or those dynamically adapting to various scenarios. </span><span class="kobospan" id="kobo.100.3">In such cases, the Native Image may not capture the complete runtime profile, leading to potential </span><span><span class="kobospan" id="kobo.101.1">performance trade-offs.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.102.1">Platform dependencies</span></strong><span class="kobospan" id="kobo.103.1">: Native Image produces platform-specific binaries, potentially introducing challenges for cross-platform compatibility. </span><span class="kobospan" id="kobo.103.2">While GraalVM provides some level of cross-compilation support, developers must be mindful of potential platform dependencies and thoroughly test their applications on </span><span><span class="kobospan" id="kobo.104.1">target platforms.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.105.1">The footprint of included libraries</span></strong><span class="kobospan" id="kobo.106.1">: Including certain libraries in a Native Image can increase size, potentially offsetting some of the gains in memory efficiency. </span><span class="kobospan" id="kobo.106.2">Developers must carefully choose and optimize the dependencies included in the native image to strike the right balance between footprint </span><span><span class="kobospan" id="kobo.107.1">and functionality.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.108.1">Navigating the landscape of application deployment, it becomes essential to comprehend the fundamental distinctions between Native Image applications and those running on a JVM. </span><span class="kobospan" id="kobo.108.2">The divergence lies in their approach to execution and resource utilization. </span><span class="kobospan" id="kobo.108.3">Native Image applications, crafted through GraalVM’s innovative AOT compilation, stand out for their streamlined startup times and reduced memory footprints. </span><span class="kobospan" id="kobo.108.4">They eschew the need for a JVM during deployment, directly interacting with the operating system as standalone executables. </span><span class="kobospan" id="kobo.108.5">In contrast, JVM-based applications boast portability across platforms and can run on any environment equipped with a compatible JVM. </span><span class="kobospan" id="kobo.108.6">Next, we’ll delve into the nuances of these differences, shedding light on considerations such as startup time, memory efficiency, and the impact on application portability. </span><span class="kobospan" id="kobo.108.7">By </span><a id="_idIndexMarker458" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.109.1">unraveling these distinctions, developers can make informed choices tailored to the specific demands of their projects, unlocking the optimal balance between performance, portability, and </span><span><span class="kobospan" id="kobo.110.1">resource utilization:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.111.1">Startup time</span></strong><span class="kobospan" id="kobo.112.1">: Native Image applications excel in terms of startup time as they eliminate the overhead associated with initializing a JVM. </span><span class="kobospan" id="kobo.112.2">This is particularly advantageous for short-lived applications or microservices where rapid responsiveness is paramount. </span><span class="kobospan" id="kobo.112.3">In contrast, JVM-based applications typically have a longer startup time as the JVM needs to interpret and compile the code </span><span><span class="kobospan" id="kobo.113.1">at runtime.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.114.1">Memory footprint</span></strong><span class="kobospan" id="kobo.115.1">: Native Image applications generally have a smaller memory footprint compared to their JVM counterparts. </span><span class="kobospan" id="kobo.115.2">Without the need for a JVM, the overhead associated with running the virtual machine is eliminated, resulting in more efficient resource utilization. </span><span class="kobospan" id="kobo.115.3">This makes Native Image applications well-suited for environments with stringent </span><span><span class="kobospan" id="kobo.116.1">memory constraints.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.117.1">Portability</span></strong><span class="kobospan" id="kobo.118.1">: JVM applications are known for their portability – the ability to run on any platform with a compatible JVM. </span><span class="kobospan" id="kobo.118.2">On the other hand, Native Image applications, being compiled to platform-specific binaries, may have platform dependencies. </span><span class="kobospan" id="kobo.118.3">While GraalVM provides some level of cross-compilation support, it’s essential to consider platform-specific implications when using </span><span><span class="kobospan" id="kobo.119.1">Native Image.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.120.1">Diving into the intricate decision-making process of application deployment, the following comparison table illuminates the distinctive characteristics between Native Image applications and those operating on a JVM. </span><span class="kobospan" id="kobo.120.2">Each column encapsulates crucial aspects that influence performance, resource utilization, and adaptability. </span><span class="kobospan" id="kobo.120.3">Native Image applications, sculpted through GraalVM’s innovative AOT compilation, boast expedited startup times and diminished memory footprints, making them particularly adept for scenarios prioritizing efficiency. </span><span class="kobospan" id="kobo.120.4">In contrast, JVM-based applications offer the advantage of cross-platform compatibility and dynamic adaptability, leveraging JIT compilation. </span><span class="kobospan" id="kobo.120.5">This table serves as a compass for developers, providing a concise yet comprehensive guide to navigate the trade-offs and make informed decisions based on the specific needs of </span><span><span class="kobospan" id="kobo.121.1">their</span></span><span><a id="_idIndexMarker459" class="calibre4 pcalibre pcalibre1"/></span><span><span class="kobospan" id="kobo.122.1"> projects:</span></span></p>
<table class="no-table-style" id="table001-4">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.123.1">Feature</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.124.1">Native </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.125.1">Image Applications</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.126.1">JVM-Based Applications</span></strong></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.127.1">Startup Time</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.128.1">Generally faster</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.129.1">May be slower, depending on the </span><span><span class="kobospan" id="kobo.130.1">JIT compilation</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.131.1">Memory Footprint</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.132.1">Smaller</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.133.1">Larger</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.134.1">Build Time</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.135.1">Longer due to </span><span><span class="kobospan" id="kobo.136.1">AOT compilation</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.137.1">Shorter due to the JIT </span><span><span class="kobospan" id="kobo.138.1">compilation</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.139.1">Dynamic </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.140.1">Class Loading</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.141.1">Limited; requires </span><span><span class="kobospan" id="kobo.142.1">careful handling</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.143.1">More flexible</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.144.1">Reflection</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.145.1">Limited; requires </span><span><span class="kobospan" id="kobo.146.1">careful handling</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.147.1">More flexible</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.148.1">Platform Portability</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span><span class="kobospan" id="kobo.149.1">Platform-specific binaries</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.150.1">Cross-platform with a </span><span><span class="kobospan" id="kobo.151.1">compatible JVM</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.152.1">Resource Utilization</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.153.1">Efficient; </span><span><span class="kobospan" id="kobo.154.1">lower overheads</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.155.1">May have higher overheads depending on </span><span><span class="kobospan" id="kobo.156.1">the JVM</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.157.1">Dependency Inclusion</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.158.1">Need to optimize to </span><span><span class="kobospan" id="kobo.159.1">manage size</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.160.1">Easier management with </span><span><span class="kobospan" id="kobo.161.1">dependency managers</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.162.1">Adaptability to </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.163.1">Runtime Changes</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.164.1">Less dynamic; needs </span><span><span class="kobospan" id="kobo.165.1">careful handling</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.166.1">More adaptive with JIT </span><span><span class="kobospan" id="kobo.167.1">compilation</span></span></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><span><strong class="bold"><span class="kobospan" id="kobo.168.1">Build Complexity</span></strong></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.169.1">Higher; </span><span><span class="kobospan" id="kobo.170.1">requires configuration</span></span></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><span class="kobospan" id="kobo.171.1">Lower; generally handled by </span><span><span class="kobospan" id="kobo.172.1">the JVM</span></span></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.173.1">Table 7.1: Native Image versus JVM</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.174.1">This table provides a high-level overview of the key differences between Native Image and JVM-based applications. </span><span class="kobospan" id="kobo.174.2">It’s important to note that the choice between the two depends on specific project requirements, considering factors such as startup time, memory efficiency, platform </span><a id="_idIndexMarker460" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.175.1">portability, and flexibility needed in </span><span><span class="kobospan" id="kobo.176.1">dynamic features.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.177.1">On exploring the differences between Native Image applications and their counterparts, it becomes clear that the path to optimal application deployment is nuanced and multifaceted. </span><span class="kobospan" id="kobo.177.2">This comparative journey has uncovered both approaches’ unique strengths and considerations, guiding developers toward informed decisions that align with project priorities. </span><span class="kobospan" id="kobo.177.3">Now, with a richer understanding of the trade-offs and benefits, we stand at the threshold of </span><span><span class="kobospan" id="kobo.178.1">hands-on mastery.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.179.1">In the upcoming session, we’ll delve into the practical realm of creating a Native Image using GraalVM. </span><span class="kobospan" id="kobo.179.2">We’ll unravel the intricacies of the AOT compilation process, demystifying the steps to transform a Java application into a standalone executable. </span><span class="kobospan" id="kobo.179.3">From optimizing dependencies to navigating platform specific considerations, this hands-on exploration will empower you to harness the efficiency gains of Native Image deployment. </span><span class="kobospan" id="kobo.179.4">Join us in the next section as we embark on a practical journey toward unlocking the potential of Native Image, reshaping the landscape of application deployment with GraalVM’s </span><span><span class="kobospan" id="kobo.180.1">groundbreaking capabilities.</span></span><a id="_idTextAnchor129" class="calibre4 pcalibre pcalibre1"/></p>
<h1 id="_idParaDest-96" class="calibre6"><a id="_idTextAnchor130" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.181.1">Creating a Native Image</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.182.1">In this immersive and hands-on section, we delve into mastering the creation of Native Images using GraalVM. </span><span class="kobospan" id="kobo.182.2">Building upon the insights gained in our comparative exploration of Native Image applications and JVM counterparts, this section is your gateway to the practical realm of application</span><a id="_idIndexMarker461" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.183.1"> deployment efficiency. </span><span class="kobospan" id="kobo.183.2">As we shift from theory to practice, our focus now centers on empowering you to wield the transformative capabilities of Native Image compilation. </span><span class="kobospan" id="kobo.183.3">Prepare to embark on a journey where we demystify the AOT compilation process, offering step-by-step guidance on transforming a Java application into a </span><span><span class="kobospan" id="kobo.184.1">standalone executable.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.185.1">Throughout this section, we will delve into the intricacies of optimizing dependencies, navigating platform-specific considerations, and unleashing the full potential of Native Image deployment. </span><span class="kobospan" id="kobo.185.2">Whether you’re a seasoned developer seeking to enhance application performance or an enthusiast eager to explore the cutting-edge of GraalVM technology, this hands-on experience will equip you with the practical skills to integrate Native Image compilation seamlessly into your development toolkit. </span><span class="kobospan" id="kobo.185.3">Let’s dive in and turn theory into practice as we navigate the creation of Native Images, reshaping the landscape of application deployment with GraalVM’s </span><span><span class="kobospan" id="kobo.186.1">revolutionary capabilities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.187.1">In this hands-on practice section, we’ll dive into the exciting world of Native Image compilation by working on a whimsically simple yet illustrative Java application. </span><span class="kobospan" id="kobo.187.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.188.1">App</span></strong><span class="kobospan" id="kobo.189.1"> class is designed to print a greeting to the world and, in a super silly twist, reverse a given string. </span><span class="kobospan" id="kobo.189.2">As we explore the code, you’ll notice it’s not your typical “Hello, World!” </span><span class="kobospan" id="kobo.189.3">example. </span><span class="kobospan" id="kobo.189.4">Instead, it introduces a method called </span><strong class="source-inline"><span class="kobospan" id="kobo.190.1">reverseString</span></strong><span class="kobospan" id="kobo.191.1"> that recursively reverses a given string. </span><span class="kobospan" id="kobo.191.2">The application starts by printing a greeting and then reverses the string “Native Image is awesome” using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.192.1">reverseString</span></strong></span><span><span class="kobospan" id="kobo.193.1"> method.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.194.1">This playful sample serves as the canvas for our Native Image experiment. </span><span class="kobospan" id="kobo.194.2">Through this exercise, we’ll not only witness the creation of a Native Image but also gain insights into the optimization process and the resulting efficiency gains. </span><span class="kobospan" id="kobo.194.3">So, buckle up as we traverse the creation of a Native Image for this super silly yet instructive Java application. </span><span class="kobospan" id="kobo.194.4">Let’s make the whimsical tangible and explore the magic of Native Image </span><span><span class="kobospan" id="kobo.195.1">with GraalVM:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.196.1">
public class App {    public static void main(String[] args) {
        System.out.println("Hello, World! </span><span class="kobospan1" id="kobo.196.2">with Native image");
        String str = "Native Image is awesome";
        String reversed = reverseString(str);
        System.out.println("The reversed string is: " + reversed);
    }
    public static String reverseString(String str) {
        if (str.isEmpty())
            return str;
        return reverseString(str.substring(1)) + str.charAt(0);
    }
}</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.197.1">Setting up GraalVM is a crucial step in our journey toward mastering Native Image compilation. </span><span class="kobospan" id="kobo.197.2">To streamline this process and manage different Java versions effortlessly, we’ll leverage the SDKMan project. </span><span class="kobospan" id="kobo.197.3">SDKMan simplifies the installation and switching between different Java versions, providing a seamless experience </span><span><span class="kobospan" id="kobo.198.1">for developers.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.199.1">For manual installation, you can refer to the official GraalVM documentation. </span><span class="kobospan" id="kobo.199.2">However, to make our lives easier, let’s </span><a id="_idIndexMarker462" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.200.1">use SDKMan to install GraalVM. </span><span class="kobospan" id="kobo.200.2">At the time of writing, we’re opting for version 21.0.1 with GraalVM support. </span><span class="kobospan" id="kobo.200.3">Execute the following command in </span><span><span class="kobospan" id="kobo.201.1">your terminal:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.202.1">
sdk install java 21.0.1-graal</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.203.1">This command fetches and installs GraalVM version 21.0.1 through SDKMan. </span><span class="kobospan" id="kobo.203.2">Once established, you can either set it as the default Java version for your system or use it selectively in the current terminal session. </span><span class="kobospan" id="kobo.203.3">If you wish to set it as the default, employ the </span><span><span class="kobospan" id="kobo.204.1">following command:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.205.1">
sdk use java 21.0.1-graal</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.206.1">Now, with GraalVM seamlessly integrated into your development environment, we’re well-prepared to explore Native Image creation. </span><span class="kobospan" id="kobo.206.2">Let’s embark on the next steps of this hands-on journey, where we’ll combine the power of GraalVM with the simplicity </span><span><span class="kobospan" id="kobo.207.1">of SDKMan.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.208.1">Creating a Native Image is the pivotal next step in our exploration, and the process involves a series of </span><a id="_idIndexMarker463" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.209.1">commands to compile, package, and, finally, generate the native image. </span><span class="kobospan" id="kobo.209.2">Let’s break </span><span><span class="kobospan" id="kobo.210.1">it down:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.211.1">Compile the </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.212.1">App class</span></strong></span><span><span class="kobospan" id="kobo.213.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.214.1">
   javac -d build src/main/java/expert/os/App.java</span></pre><p class="calibre3"><span class="kobospan" id="kobo.215.1">This command compiles the </span><strong class="source-inline"><span class="kobospan" id="kobo.216.1">App</span></strong><span class="kobospan" id="kobo.217.1"> class and stores the compiled files in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.218.1">build</span></strong></span><span><span class="kobospan" id="kobo.219.1"> directory.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.220.1">Create a </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.221.1">JAR file</span></strong></span><span><span class="kobospan" id="kobo.222.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.223.1">
   jar --create --file App.jar --main-class expert.os.App -C build .</span></pre><p class="calibre3"><span class="kobospan" id="kobo.224.1">Here, we package the compiled files into a JAR file named </span><strong class="source-inline"><span class="kobospan" id="kobo.225.1">App.jar</span></strong><span class="kobospan" id="kobo.226.1"> and specify the main class </span><span><span class="kobospan" id="kobo.227.1">as </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.228.1">expert.os.App</span></strong></span><span><span class="kobospan" id="kobo.229.1">.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.230.1">Create the </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.231.1">Native Image</span></strong></span><span><span class="kobospan" id="kobo.232.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.233.1">
   native-image -jar App.jar</span></pre><p class="calibre3"><span class="kobospan" id="kobo.234.1">Utilizing GraalVM’s </span><strong class="source-inline"><span class="kobospan" id="kobo.235.1">native-image</span></strong><span class="kobospan" id="kobo.236.1"> tool, we generate the native image from the JAR file. </span><span class="kobospan" id="kobo.236.2">This step involves AOD compilation, resulting in a </span><span><span class="kobospan" id="kobo.237.1">standalone executable.</span></span></p></li> <li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.238.1">Execute the </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.239.1">Native Image</span></strong></span><span><span class="kobospan" id="kobo.240.1">:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.241.1">
./App</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.242.1">With the native image created, we can run the executable. </span><span class="kobospan" id="kobo.242.2">Upon execution, the console will display the </span><span><span class="kobospan" id="kobo.243.1">following output:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.244.1">
   Hello, World! </span><span class="kobospan1" id="kobo.244.2">with Native image   The reversed string is: emosewa si egamI evitaN</span></pre>
<p class="calibre3"><span class="kobospan" id="kobo.245.1">Congratulations! </span><span class="kobospan" id="kobo.245.2">You’ve successfully navigated the process of creating a Native Image using GraalVM, turning our whimsically simple Java application into a streamlined, standalone executable. </span><span class="kobospan" id="kobo.245.3">This</span><a id="_idIndexMarker464" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.246.1"> hands-on experience sets the stage for further exploration of the efficiency gains and optimization possibilities offered by Native Image compilation. </span><span class="kobospan" id="kobo.246.2">Let’s revel in the results and continue our journey into the dynamic realm </span><span><span class="kobospan" id="kobo.247.1">of GraalVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.248.1">As we conclude this section on Native Image creation with GraalVM, it’s evident that we’ve embarked on a transformative journey in application deployment. </span><span class="kobospan" id="kobo.248.2">By seamlessly integrating the power of GraalVM, we’ve transformed a playful Java application into a standalone executable, unlocking efficiency gains in startup time and </span><span><span class="kobospan" id="kobo.249.1">resource utilization.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.250.1">Through meticulous compilation steps and the magic of AOT processing, we’ve witnessed the birth of a native image. </span><span class="kobospan" id="kobo.250.2">The output of our executable not only echoes the familiar “Hello, World!” </span><span class="kobospan" id="kobo.250.3">greeting but also showcases the whimsical reversal of a string – a testament to the versatility </span><span><span class="kobospan" id="kobo.251.1">of GraalVM.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.252.1">This hands-on experience lays a solid foundation for further exploration. </span><span class="kobospan" id="kobo.252.2">Armed with a Native Image, developers can delve into real-world applications, optimizing performance and navigating the intricacies of efficient resource utilization. </span><span class="kobospan" id="kobo.252.3">The journey doesn’t end here, though; it extends into the dynamic landscapes of </span><span><span class="kobospan" id="kobo.253.1">GraalVM’s capabilities.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.254.1">As we celebrate the successful execution of our native image, let this be a catalyst for your continued exploration into the possibilities and efficiencies unlocked by GraalVM. </span><span class="kobospan" id="kobo.254.2">The adventure continues, and the next chapters await, promising deeper insights and mastery in the fascinating world of Java </span><span><span class="kobospan" id="kobo.255.1">application developm</span><a id="_idTextAnchor131" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.256.1">ent.</span></span></p>
<h1 id="_idParaDest-97" class="calibre6"><a id="_idTextAnchor132" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.257.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.258.1">In this chapter, we delved into the transformative capabilities of GraalVM, from its high-performance compiler to the creation of a Native Image. </span><span class="kobospan" id="kobo.258.2">Witnessing the efficiency gains achievable through AOT compilation marked a significant milestone, showcasing GraalVM’s versatility in reshaping the Java </span><span><span class="kobospan" id="kobo.259.1">development landscape.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.260.1">As we conclude, this chapter served as a stepping stone to the broader exploration of the JVM ecosystem and alternative JVMs in the next chapter. </span><span class="kobospan" id="kobo.260.2">The diverse options beyond conventional JVMs, such as OpenJ9 and Azul Zing, will be unraveled, providing insights into their unique features and contributions to the ever-evolving Java ecosystem. </span><span class="kobospan" id="kobo.260.3">Join us in the next chapter as we navigate the diverse paths within the JVM landscape, informed by the knowledge we’ve gained from our exploration </span><span><span class="kobospan" id="kobo.261.1">of Graa</span><a id="_idTextAnchor133" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.262.1">lVM.</span></span></p>
<h1 id="_idParaDest-98" class="calibre6"><a id="_idTextAnchor134" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.263.1">Questions</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.264.1">Answer the following questions to test your knowledge of </span><span><span class="kobospan" id="kobo.265.1">this chapter:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.266.1">What is the primary benefit of GraalVM’s Native </span><span><span class="kobospan" id="kobo.267.1">Image compilation?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.268.1">Increased </span><span><span class="kobospan" id="kobo.269.1">memory footprint</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.270.1">Slower </span><span><span class="kobospan" id="kobo.271.1">startup time</span></span></li><li class="alphabets"><span><span class="kobospan" id="kobo.272.1">Platform portability</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.273.1">Limited </span><span><span class="kobospan" id="kobo.274.1">language support</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.275.1">Which command is used to compile the </span><strong class="source-inline1"><span class="kobospan" id="kobo.276.1">App</span></strong><span class="kobospan" id="kobo.277.1"> class in the GraalVM Native Image </span><span><span class="kobospan" id="kobo.278.1">creation process?</span></span><ol class="calibre17"><li class="alphabets"><strong class="source-inline1"><span class="kobospan" id="kobo.279.1">compile -</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.280.1">class App</span></strong></span></li><li class="alphabets"><strong class="source-inline1"><span class="kobospan" id="kobo.281.1">javac -d </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.282.1">build src/main/java/expert/os/App.java</span></strong></span></li><li class="alphabets"><strong class="source-inline1"><span class="kobospan" id="kobo.283.1">native-image --</span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.284.1">compile App</span></strong></span></li><li class="alphabets"><span><strong class="source-inline1"><span class="kobospan" id="kobo.285.1">graalvm-compile App.java</span></strong></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.286.1">What is the purpose of the </span><strong class="source-inline1"><span class="kobospan" id="kobo.287.1">reverseString</span></strong><span class="kobospan" id="kobo.288.1"> method in the provided </span><span><span class="kobospan" id="kobo.289.1">Java application?</span></span><ol class="calibre17"><li class="alphabets"><span><span class="kobospan" id="kobo.290.1">Concatenates strings</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.291.1">Reverses a </span><span><span class="kobospan" id="kobo.292.1">given string</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.293.1">Checks for </span><span><span class="kobospan" id="kobo.294.1">a palindrome</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.295.1">Removes whitespace from </span><span><span class="kobospan" id="kobo.296.1">a string</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.297.1">How does GraalVM’s Native Image differ from JVM-based applications in terms of </span><span><span class="kobospan" id="kobo.298.1">startup time?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.299.1">Native Image has a slower </span><span><span class="kobospan" id="kobo.300.1">startup time</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.301.1">Both have similar </span><span><span class="kobospan" id="kobo.302.1">startup times</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.303.1">Native Image has a faster </span><span><span class="kobospan" id="kobo.304.1">startup time</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.305.1">JVM-based applications have a faster </span><span><span class="kobospan" id="kobo.306.1">startup time</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.307.1">What is SDKMan used for in the context of </span><span><span class="kobospan" id="kobo.308.1">GraalVM installation?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.309.1">Managing Java versions </span><span><span class="kobospan" id="kobo.310.1">and installations</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.311.1">Creating </span><span><span class="kobospan" id="kobo.312.1">native images</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.313.1">Debugging </span><span><span class="kobospan" id="kobo.314.1">Java applications</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.315.1">Managing </span><span><span class="kobospan" id="kobo.316.1">Docker images</span></span></li></ol></li>
<li class="calibre14"><span class="kobospan" id="kobo.317.1">What does the </span><strong class="source-inline1"><span class="kobospan" id="kobo.318.1">native-image</span></strong><span class="kobospan" id="kobo.319.1"> command do in the GraalVM Native Image </span><span><span class="kobospan" id="kobo.320.1">creation process?</span></span><ol class="calibre17"><li class="alphabets"><span class="kobospan" id="kobo.321.1">Compiles Java </span><span><span class="kobospan" id="kobo.322.1">source code</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.323.1">Generates a </span><span><span class="kobospan" id="kobo.324.1">standalone executable</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.325.1">Downloads </span><span><span class="kobospan" id="kobo.326.1">Java dependencies</span></span></li><li class="alphabets"><span class="kobospan" id="kobo.327.1">Executes the </span><span><span class="kobospan" id="kobo.328.1">Java application</span></span></li></ol></li>
</ol>
<h1 id="_idParaDest-99" class="calibre6"><a id="_idTextAnchor135" class="calibre4 pcalibre pcalibre1"/><span class="kobospan" id="kobo.329.1">Answers</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.330.1">Here are the answers to this </span><span><span class="kobospan" id="kobo.331.1">chapter’s questions:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.332.1">C. </span><span><span class="kobospan" id="kobo.333.1">Platform portability</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.334.1">B. </span><strong class="source-inline1"><span class="kobospan" id="kobo.335.1">javac -d </span></strong><span><strong class="source-inline1"><span class="kobospan" id="kobo.336.1">build src/main/java/expert/os/App.java</span></strong></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.337.1">B. </span><span class="kobospan" id="kobo.337.2">Reverses a </span><span><span class="kobospan" id="kobo.338.1">given string</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.339.1">C. </span><span class="kobospan" id="kobo.339.2">Native Image has a faster </span><span><span class="kobospan" id="kobo.340.1">startup time</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.341.1">A. </span><span class="kobospan" id="kobo.341.2">Managing Java versions </span><span><span class="kobospan" id="kobo.342.1">and installations</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.343.1">B. </span><span class="kobospan" id="kobo.343.2">Generates a </span><span><span class="kobospan" id="kobo.344.1">standalone executable</span></span></li>
</ol>
</div>
</body></html>