- en: 14\. Recursion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14. 递归
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter, we will see how using recursion can help you to write effective
    code. The chapter begins with an initial exercise illustrating one of the simplest
    mistakes you can make with recursion: forgetting to code a termination condition.
    The first step, then, is learning how to salvage your program when the Java stack
    has blown away. From there, you will learn to write recursive methods in order
    to handle mathematical formulas and other recurrent processing needs. Finally,
    with these techniques (and those further defined by this chapter), you will practice
    creating and processing XML files with the **Document Object Model** (**DOM**)
    API.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将看到如何使用递归帮助你编写有效的代码。章节从一项初始练习开始，该练习说明了你可以用递归犯的最简单的错误之一：忘记编写终止条件。因此，第一步是学习如何在
    Java 栈溢出时挽救你的程序。从那里，你将学习编写递归方法来处理数学公式和其他重复处理需求。最后，通过这些技术（以及本章进一步定义的技术），你将练习使用
    **文档对象模型**（**DOM**）API 创建和处理 XML 文件。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Recursion is where a method calls itself, over and over again. Recursion, when
    used carefully, can be a useful programming technique; but the key is to use it
    correctly.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一个方法一次又一次地调用自己。当谨慎使用时，递归可以是一种有用的编程技术；但关键是正确使用它。
- en: An important point is that recursion is just a programming technique. You can
    often avoid it, if you want, by writing some form of an iterative loop. However,
    if the problem you need to solve is truly recursive, the iterative approach will
    likely be much more complex than the comparatively simpler and more elegant recursion
    code which corresponds.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要点是，递归只是一种编程技术。如果你愿意，你通常可以通过编写某种形式的迭代循环来避免它。然而，如果你需要解决的问题确实是递归的，那么迭代方法可能比相对简单且更优雅的递归代码复杂得多。
- en: This chapter delves into this handy programming technique.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了这种实用的编程技巧。
- en: Delving into Recursion
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入递归
- en: Recursion is useful for many mathematical problems, such as when working with
    cellular automata, Sierpinski triangles, and fractals. In computer graphics, recursion
    can be used to help generate realistic-looking mountains, plants, and other natural
    phenomena. Classic problems, such as the Tower of Hanoi, work well with recursion.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 递归对于许多数学问题很有用，例如在处理细胞自动机、谢宾斯基三角形和分形时。在计算机图形学中，递归可以用来帮助生成看起来逼真的山脉、植物和其他自然现象。经典的汉诺塔问题非常适合使用递归。
- en: In Java applications, you will often use recursion when traversing tree data
    structures, including XML and HTML documents.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 应用程序中，你将经常在遍历树形数据结构时使用递归，包括 XML 和 HTML 文档。
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can refer to [https://packt.live/2JaIre8](https://packt.live/2JaIre8) for
    more information on the Tower of Hanoi problem.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考 [https://packt.live/2JaIre8](https://packt.live/2JaIre8) 获取关于汉诺塔问题的更多信息。
- en: 'A simple example of recursion looks like the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的一个简单例子如下：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, each call to the `add()` method will call itself with a number
    that is one greater than the one used for the current call.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，每次对 `add()` 方法的调用都会用比当前调用使用的数字大一的数字调用自己。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You always need a termination condition to stop the recursion. This example
    does not have one.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是需要一个终止条件来停止递归。这个例子没有。
- en: 'Exercise 1: Using Recursion to Overflow the Stack'
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1：使用递归溢出栈
- en: 'This example demonstrates what happens when you don''t provide a way for a
    recursive method to stop. Bad things happen to your program. Follow these steps
    to perform the exercise:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子演示了当你没有为递归方法提供停止方式时会发生什么。你的程序会遇到一些问题。按照以下步骤进行练习：
- en: Select `New` and then select `Project…` from the `File` menu in IntelliJ.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 的“文件”菜单中选择“新建”，然后选择“项目...”。
- en: Select `Gradle` for the type of project. Click on `Next`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择项目的类型为“Gradle”。点击“下一步”。
- en: For `Group Id`, enter `com.packtpub.recursion`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“组 ID”，输入“com.packtpub.recursion”。
- en: For `Artifact Id`, enter `chapter14`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“工件 ID”，输入“chapter14”。
- en: For `Version`, enter `1.0`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于“版本”，输入“1.0”。
- en: Accept the default on the next pane. Click on `Next`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一页接受默认设置。点击“下一步”。
- en: Leave the project name as `chapter14`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目名称保留为“chapter14”。
- en: Click on `Finish`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“完成”。
- en: Call up `build.gradle` in the IntelliJ text editor.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 IntelliJ 文本编辑器中打开 `build.gradle`。
- en: 'Change `sourceCompatibility` so that it is set to `12` as shown here:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `sourceCompatibility` 设置为 `12`，如图所示：
- en: '[PRE1]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the `src/main/java` folder, create a new Java package.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main/java` 文件夹中创建一个新的 Java 包。
- en: Enter `com.packtpub.recursion` as the package name.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将包名输入为“com.packtpub.recursion”。
- en: Right-click on this package in the `Project` pane and create a new Java class
    named `RunForever`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Project`窗格中右键单击此包，创建一个名为`RunForever`的新Java类。
- en: 'Enter the recursive method as follows:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式进入递归方法：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Enter a `main()` method as follows:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式进入`main()`方法：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Run this program; you will see it fail with an exception:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行这个程序；你会看到它因异常而失败：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The full code will look as follows:'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的代码如下所示：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can fix this problem by providing a terminating condition to stop the recursion,
    as shown in the following `RunAndStop.java` file:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以通过提供终止条件来停止递归，如下面的`RunAndStop.java`文件所示：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you run this program, you will see the following output:'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到以下输出：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Trying Tail Recursion
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试尾递归
- en: Tail recursion is when the last executable statement of the recursive method
    is a call to itself. Tail recursion is important because the Java compiler could—but
    doesn't at this time—jump back to the start of the method. This helps because
    the compiler wouldn't have to store the stack frame for the method call, making
    it more efficient and using less memory on the call stack.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归是指递归方法的最后一个可执行语句是对自身的调用。尾递归很重要，因为Java编译器可以——但在此刻还没有——跳回方法的开头。这有助于编译器不需要为方法调用存储栈帧，使其更高效，并在调用栈上使用更少的内存。
- en: 'Exercise 2: Using Recursion to Calculate Factorials'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2：使用递归计算阶乘
- en: Factorials are great examples for demonstrating how recursion works.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘是演示递归工作原理的绝佳例子。
- en: 'You can calculate the factorial of an integer by multiplying the number with
    all the positive numbers that are less than itself. For example, the factorial
    of 4, also written as 4!, is calculated as 4 * 3 * 2 * 1\. Carry out the following
    steps to perform the exercise:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将数字与所有小于它的正数相乘来计算一个整数的阶乘。例如，4的阶乘，也写作4!，计算为4 * 3 * 2 * 1。执行以下步骤来完成练习：
- en: Right-click on the `com.packtpub.recursion` package name.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`com.packtpub.recursion`包名。
- en: Create a new Java class named `Factorial`.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Factorial`的新Java类。
- en: 'Enter the recursive method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入递归方法：
- en: '[PRE8]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since a factorial is a number multiplied by all positive numbers less than itself,
    in each call to the `factorial()` method, it returns the number multiplied by
    the factorial of the number minus one. If the passed-in number is 1, it returns
    simply the number 1.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于阶乘是一个数乘以所有小于它的正数，因此在每次调用`factorial()`方法时，它返回该数乘以比该数小一的阶乘。如果传入的数是1，它就简单地返回数字1。
- en: 'Enter the `main()` method, which launches the factorial calculation:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入`main()`方法，它启动阶乘计算：
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code will calculate the factorial of 6, which is also represented as 6
    factorial or 6!.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此代码将计算6的阶乘，也称为6阶乘或6!。
- en: 'When you run this program, you will see the following output:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行这个程序时，你会看到以下输出：
- en: '[PRE10]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The full code will look as follows:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 完整的代码如下所示：
- en: '[PRE11]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Factorials and many other mathematical concepts work well with recursion. Another
    common task that fits with this programming technique is processing a hierarchical
    document, such as XML or HTML.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 阶乘以及许多其他数学概念与递归很好地结合。另一个适合这种编程技术的常见任务是处理层次文档，例如XML或HTML。
- en: Processing an XML Document
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理XML文档
- en: 'XML documents have nodes. Each node may have child nodes; for example, consider
    the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: XML文档有节点。每个节点可能有子节点；例如，考虑以下：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this XML snippet, the `<cities>` element has one child element, `<city>`.
    The `<city>` child element, in turn, has four child elements.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个XML片段中，`<cities>`元素有一个子元素`<city>`。`<city>`子元素反过来又有四个子元素。
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This data comes from [https://packt.live/33IrCyR](https://packt.live/31yBoSL)
    and was used in an exercise in *Chapter 6*, *Libraries, Packages, and Modules*.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数据来自[https://packt.live/33IrCyR](https://packt.live/31yBoSL)，并在*第6章*，*库、包和模块*中的练习中使用。
- en: Now, consider how you would write code to process the above XML data. Java comes
    with classes to parse the XML file. The only issue is what to do with the XML
    document once you have parsed it into Java objects. That's where recursion can
    be useful.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑你将如何编写代码来处理上述XML数据。Java提供了解析XML文件的类。唯一的问题是解析成Java对象后如何处理XML文档。这就是递归可以发挥作用的地方。
- en: You could write code to process each `<city>` element, such as the data for
    `London`. In that element, the code would extract the data from the child elements,
    such as the name of the city, the name of the country, and the summertime high
    temperature.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以编写代码来处理每个 `<city>` 元素，例如 `London` 的数据。在该元素中，代码将提取子元素中的数据，例如城市名称、国家名称和夏令时高温。
- en: Note how the two additional cities, `Paris` and `Milan`, are shown. This data
    could be processed in a similar way to how the `London` data was processed. Once
    you see the similarity, you may find that recursion proves useful.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何显示两个额外的城市，`Paris` 和 `Milan`。这些数据可以以与 `London` 数据类似的方式处理。一旦你看到相似性，你可能会发现递归非常有用。
- en: 'Exercise 3: Creating an XML File'
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 3：创建一个 XML 文件
- en: 'To demonstrate how to parse and then recursively traverse XML documents, we
    need some XML data:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何解析并递归遍历 XML 文档，我们需要一些 XML 数据：
- en: Right-click on `src/main/resources` and select `New` and then `File`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `src/main/resources` 并选择 `New`，然后选择 `File`。
- en: Enter `cities.xml` as the name of the file.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件名输入为 `cities.xml`。
- en: 'Enter the following XML data into the file:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 XML 数据输入到文件中：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Java includes more than one API for processing XML data. With the **Simple API
    for XML** (**SAX**), you can process an XML document one event at a time. Events
    include starting an element, getting some text from within an element, and ending
    an element.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Java 包含多个用于处理 XML 数据的 API。使用 **简单 XML API**（**SAX**），你可以一次处理一个 XML 文档的事件。事件包括开始一个元素、从元素内部获取一些文本以及结束一个元素。
- en: With the **Document Object Model** (**DOM**), the API reads in an XML document.
    From this point your code can traverse the elements in the tree of DOM elements.
    The API that fits best with recursive processing is the DOM API.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **文档对象模型**（**DOM**），API 读取 XML 文档。从这一点开始，你的代码可以遍历 DOM 元素的树。最适合递归处理的 API 是
    DOM API。
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information about the Java XML APIs at [https://packt.live/31yBoSL](https://packt.live/31yBoSL)
    and [https://packt.live/2BvD2tJ](https://packt.live/2BvD2tJ).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.live/31yBoSL](https://packt.live/31yBoSL) 和 [https://packt.live/2BvD2tJ](https://packt.live/2BvD2tJ)
    找到有关 Java XML API 的更多信息。
- en: Introducing the DOM XML API
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 DOM XML API
- en: With the DOM API, you can use a `DocumentBuilder` class to parse an XML file
    into a tree of objects in memory. These objects all implement the `org.w3c.Node`
    interface. The node interface allows you to extract data from each XML element
    and then retrieve all the child nodes under a node.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DOM API，你可以使用 `DocumentBuilder` 类将 XML 文件解析为内存中的对象树。这些对象都实现了 `org.w3c.Node`
    接口。节点接口允许你从每个 XML 元素中提取数据，然后检索节点下的所有子节点。
- en: Regular XML elements, such as `<city>` in our example, implement the `Element`
    interface, which extends the `Node` interface. Additionally, textual items implement
    the `Text` interface. And, the overall document is represented by the `Document`
    interface.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，如 `<city>` 这样的常规 XML 元素实现了 `Element` 接口，该接口扩展了 `Node` 接口。此外，文本项实现了 `Text`
    接口。整个文档由 `Document` 接口表示。
- en: 'The entire DOM is hierarchical. For example, consider the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 整个 DOM 是分层的。例如，考虑以下内容：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this short snippet, `<city>` is an element, and has a child element for `<name>`.
    The `London` text is a child of the `<name>` element. The `London` text will be
    held in an object that implements the `Text` interface.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简短的片段中，`<city>` 是一个元素，并且有一个子元素 `<name>`。`London` 文本是 `<name>` 元素的子元素。`London`
    文本将保存在一个实现 `Text` 接口的对象中。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The DOM API needs to load the entire XML document into a hierarchy of nodes.
    The DOM API would not be appropriate for a large XML document, as you could run
    out of memory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: DOM API 需要将整个 XML 文档加载到节点层次结构中。对于大型 XML 文档，DOM API 可能不合适，因为你可能会耗尽内存。
- en: When using the DOM API, the first step is to load an XML file and parse it into
    the hierarchy of objects.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DOM API 时，第一步是加载一个 XML 文件并将其解析为对象层次结构。
- en: 'To do that, you need a `DocumentBuilder` class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你需要一个 `DocumentBuilder` 类：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once you have a `DocumentBuilder` class, you can parse an XML file to get a
    `Document` interface:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你有了 `DocumentBuilder` 类，你可以解析 XML 文件以获取 `Document` 接口：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since a `Document` is a `Node`, you can start processing all the child nodes.
    Typically, you start with the first child of the `Document` interface (`<cities>`
    in our earlier example):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Document` 是 `Node`，你可以开始处理所有子节点。通常，你从 `Document` 接口的第一子节点开始（在我们的早期示例中是 `<cities>`）：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The call to `getFirstChild()` returns the first child of the `document`, which
    is the top-level XML element. You can then call `getChildNodes()` to retrieve
    all the immediate child elements. Unfortunately, the `NodeList` object returned
    is not a `List` and not a `Collection` interface, which makes iterating over the
    child nodes more difficult.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`getFirstChild()`的调用返回`document`的第一个子节点，即顶级XML元素。然后你可以调用`getChildNodes()`来检索所有直接子元素。不幸的是，返回的`NodeList`对象既不是`List`也不是`Collection`接口，这使得遍历子节点变得更加困难。'
- en: 'You can then use recursion to get the child nodes of any given node, and the
    children of those children, and so on. For example, look at the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以使用递归获取任何给定节点的子节点，以及这些子节点的子节点，依此类推。例如，看看以下内容：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we first check whether a given node has child nodes. If not,
    we have nothing to do. If there are child nodes, we'll use the same technique
    shown previously to get each child node.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先检查给定的节点是否有子节点。如果没有，我们就没有什么可做的。如果有子节点，我们将使用之前展示的相同技术来获取每个子节点。
- en: Once we have a node, the code checks whether the node is a `Text` node by using
    the `getNodeType()` method. If the node is a `Text` node, we'll print out the
    text. If not, we'll make a recursive call with the child node. This will retrieve
    all the children of the child node.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个节点，代码就会使用`getNodeType()`方法检查节点是否是`Text`节点。如果是`Text`节点，我们将打印出文本。如果不是，我们将对子节点进行递归调用。这将检索子节点的所有子节点。
- en: 'Exercise 4: Traversing an XML Document'
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习4：遍历XML文档
- en: 'In this exercise, we''ll write code to traverse the tree of node objects parsed
    from the `cities.xml` file we created in *Exercise 3*, *Creating an XML File*.
    The code will print out the XML elements as text. Carry out the following steps
    to complete the exercise:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写代码来遍历从我们在*练习3*中创建的`cities.xml`文件解析出的节点对象树。该代码将打印出XML元素作为文本。按照以下步骤完成练习：
- en: 'Edit the `build.gradle` file. Add new dependency for the `Apache Commons Lang`
    library:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`build.gradle`文件。为`Apache Commons Lang`库添加新的依赖项：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This library has a few helpful utility methods that we will use when generating
    the output.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此库有几个有用的实用方法，我们将在生成输出时使用。
- en: Right-click on the `com.packtpub.recursion` package name.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`com.packtpub.recursion`包名。
- en: Create a new Java class named `XmlTraverser`.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`XmlTraverser`的新Java类。
- en: 'Enter the following method to load an XML file into the DOM tree:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下方法以将XML文件加载到DOM树中：
- en: '[PRE20]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note how this code catches all the possible exceptions from reading in the file
    and parsing the XML content.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这段代码如何捕获从读取文件和解析XML内容中可能出现的所有异常。
- en: 'Next, enter in a method to print the `Text` node content:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入一个方法来打印`Text`节点的内容：
- en: '[PRE21]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method uses the Apache `StringUtils` class to check whether the text is
    blank or not. You'll find that the DOM API populates a lot of blank `Text` nodes.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法使用Apache `StringUtils`类来检查文本是否为空。你会发现DOM API填充了很多空的`Text`节点。
- en: 'To help represent the hierarchical nature of XML documents, enter a utility
    method for indenting:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了帮助表示XML文档的层次结构，输入一个缩进实用方法：
- en: '[PRE22]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Again, we use the `StringUtils` class to do the tedious work of padding an empty
    string with a given number of spaces.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次，我们使用`StringUtils`类来完成用给定数量的空格填充空字符串的繁琐工作。
- en: 'Next, we create the main recursive method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建主递归方法：
- en: '[PRE23]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This method prints out the name of the input node (which will be the city, country,
    or something similar). It then checks for child nodes. If the child node is a
    `Text` node, it prints out the text. Otherwise, this method calls itself recursively
    to process all the children of the child node.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法打印出输入节点的名称（这将是一个城市、国家或类似的东西）。然后检查子节点。如果子节点是`Text`节点，则打印出文本。否则，此方法将递归调用自身以处理子节点的所有子节点。
- en: 'To get going, create a short method to start the recursive calls from the first
    child of the XML document:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始，创建一个简短的方法从XML文档的第一个子节点开始递归调用：
- en: '[PRE24]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need a `main()` method to load the XML file and traverse the document:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个`main()`方法来加载XML文件并遍历文档：
- en: '[PRE25]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When you run this program, you will see the following output:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行此程序时，你将看到以下输出：
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The preceding output is truncated. The full source code of this exercise can
    be found at: [https://packt.live/33VDygZ](https://packt.live/33VDygZ).'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述输出被截断。此练习的完整源代码可以在以下位置找到：[https://packt.live/33VDygZ](https://packt.live/33VDygZ)。
- en: 'Activity 1: Calculating the Fibonacci Sequence'
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动1：计算斐波那契数列
- en: The Fibonacci sequence is a series of numbers where each number is the sum of
    the previous two numbers. Write a recursive method to generate the first 15 numbers
    of the Fibonacci sequence. Note that the Fibonacci value for 0 is 0, and the Fibonacci
    value for 1 is 1.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列是一系列数字，其中每个数字都是前两个数字的和。编写一个递归方法来生成斐波那契序列的前15个数字。请注意，斐波那契值对于0是0，对于1是1。
- en: The Fibonacci sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契序列为0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55，等等。
- en: 'So, you can use the following as a guide:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以使用以下内容作为指南：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''ll use a recursive method to calculate the Fibonacci value for a given
    input, and then create a loop to display the sequence. To do so, perform the following
    steps:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用递归方法来计算给定输入的斐波那契值，然后创建一个循环来显示序列。为此，请执行以下步骤：
- en: Create the `fibonacci` method.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`fibonacci`方法。
- en: Check if the value passed to the `fibonacci` method is 0, if yes then return
    0.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查传递给`fibonacci`方法的值是否为0，如果是，则返回0。
- en: Also, check if the value passed to the `fibonacci` method is 1, if yes then
    return 1.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还要检查传递给`fibonacci`方法的值是否为1，如果是，则返回1。
- en: Else, add the fibonacci values of the previous two numbers.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，加上前两个数的斐波那契值。
- en: In the main method, create a for loop that initializes from 0 to 15 and call
    the `fibonaci` method.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主方法中，创建一个从0到15的for循环并调用`fibonaci`方法。
- en: 'When you run your program, you should see an output like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行你的程序时，你应该看到以下类似的输出：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Note
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 562.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第562页找到。
- en: Summary
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Recursion is a handy programming technique that is used for a few complex problems.
    You'll commonly find recursion in mathematical formulas, as well as when traversing
    hierarchical data structures such as binary trees or XML documents. With recursion,
    a Java method or a class calls itself. But do not forget to code a terminating
    condition, or you'll find your application quickly runs out of memory on the Java
    call stack. you'll find your application quickly runs out of memory on the Java
    call stack.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一种方便的编程技术，用于解决一些复杂问题。你通常会在数学公式中找到递归，以及在遍历二叉树或XML文档等分层数据结构时。使用递归，Java方法或类会调用自身。但不要忘记编写终止条件，否则你会发现你的应用程序在Java调用栈上很快就会耗尽内存。
- en: In the next chapter, you'll learn about predicates and functional programming
    with Java.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习使用Java进行谓词和函数式编程。
