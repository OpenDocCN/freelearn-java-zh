- en: 14\. Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will see how using recursion can help you to write effective
    code. The chapter begins with an initial exercise illustrating one of the simplest
    mistakes you can make with recursion: forgetting to code a termination condition.
    The first step, then, is learning how to salvage your program when the Java stack
    has blown away. From there, you will learn to write recursive methods in order
    to handle mathematical formulas and other recurrent processing needs. Finally,
    with these techniques (and those further defined by this chapter), you will practice
    creating and processing XML files with the **Document Object Model** (**DOM**)
    API.'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is where a method calls itself, over and over again. Recursion, when
    used carefully, can be a useful programming technique; but the key is to use it
    correctly.
  prefs: []
  type: TYPE_NORMAL
- en: An important point is that recursion is just a programming technique. You can
    often avoid it, if you want, by writing some form of an iterative loop. However,
    if the problem you need to solve is truly recursive, the iterative approach will
    likely be much more complex than the comparatively simpler and more elegant recursion
    code which corresponds.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter delves into this handy programming technique.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is useful for many mathematical problems, such as when working with
    cellular automata, Sierpinski triangles, and fractals. In computer graphics, recursion
    can be used to help generate realistic-looking mountains, plants, and other natural
    phenomena. Classic problems, such as the Tower of Hanoi, work well with recursion.
  prefs: []
  type: TYPE_NORMAL
- en: In Java applications, you will often use recursion when traversing tree data
    structures, including XML and HTML documents.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to [https://packt.live/2JaIre8](https://packt.live/2JaIre8) for
    more information on the Tower of Hanoi problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of recursion looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, each call to the `add()` method will call itself with a number
    that is one greater than the one used for the current call.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You always need a termination condition to stop the recursion. This example
    does not have one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 1: Using Recursion to Overflow the Stack'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This example demonstrates what happens when you don''t provide a way for a
    recursive method to stop. Bad things happen to your program. Follow these steps
    to perform the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `New` and then select `Project…` from the `File` menu in IntelliJ.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `Gradle` for the type of project. Click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Group Id`, enter `com.packtpub.recursion`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Artifact Id`, enter `chapter14`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Version`, enter `1.0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Accept the default on the next pane. Click on `Next`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the project name as `chapter14`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Finish`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call up `build.gradle` in the IntelliJ text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change `sourceCompatibility` so that it is set to `12` as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `src/main/java` folder, create a new Java package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `com.packtpub.recursion` as the package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on this package in the `Project` pane and create a new Java class
    named `RunForever`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the recursive method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter a `main()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run this program; you will see it fail with an exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full code will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can fix this problem by providing a terminating condition to stop the recursion,
    as shown in the following `RunAndStop.java` file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you run this program, you will see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Trying Tail Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tail recursion is when the last executable statement of the recursive method
    is a call to itself. Tail recursion is important because the Java compiler could—but
    doesn't at this time—jump back to the start of the method. This helps because
    the compiler wouldn't have to store the stack frame for the method call, making
    it more efficient and using less memory on the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 2: Using Recursion to Calculate Factorials'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Factorials are great examples for demonstrating how recursion works.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can calculate the factorial of an integer by multiplying the number with
    all the positive numbers that are less than itself. For example, the factorial
    of 4, also written as 4!, is calculated as 4 * 3 * 2 * 1\. Carry out the following
    steps to perform the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.recursion` package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class named `Factorial`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the recursive method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Since a factorial is a number multiplied by all positive numbers less than itself,
    in each call to the `factorial()` method, it returns the number multiplied by
    the factorial of the number minus one. If the passed-in number is 1, it returns
    simply the number 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter the `main()` method, which launches the factorial calculation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will calculate the factorial of 6, which is also represented as 6
    factorial or 6!.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you run this program, you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The full code will look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Factorials and many other mathematical concepts work well with recursion. Another
    common task that fits with this programming technique is processing a hierarchical
    document, such as XML or HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Processing an XML Document
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'XML documents have nodes. Each node may have child nodes; for example, consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this XML snippet, the `<cities>` element has one child element, `<city>`.
    The `<city>` child element, in turn, has four child elements.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This data comes from [https://packt.live/33IrCyR](https://packt.live/31yBoSL)
    and was used in an exercise in *Chapter 6*, *Libraries, Packages, and Modules*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, consider how you would write code to process the above XML data. Java comes
    with classes to parse the XML file. The only issue is what to do with the XML
    document once you have parsed it into Java objects. That's where recursion can
    be useful.
  prefs: []
  type: TYPE_NORMAL
- en: You could write code to process each `<city>` element, such as the data for
    `London`. In that element, the code would extract the data from the child elements,
    such as the name of the city, the name of the country, and the summertime high
    temperature.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the two additional cities, `Paris` and `Milan`, are shown. This data
    could be processed in a similar way to how the `London` data was processed. Once
    you see the similarity, you may find that recursion proves useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 3: Creating an XML File'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how to parse and then recursively traverse XML documents, we
    need some XML data:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on `src/main/resources` and select `New` and then `File`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `cities.xml` as the name of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following XML data into the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Java includes more than one API for processing XML data. With the **Simple API
    for XML** (**SAX**), you can process an XML document one event at a time. Events
    include starting an element, getting some text from within an element, and ending
    an element.
  prefs: []
  type: TYPE_NORMAL
- en: With the **Document Object Model** (**DOM**), the API reads in an XML document.
    From this point your code can traverse the elements in the tree of DOM elements.
    The API that fits best with recursive processing is the DOM API.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find more information about the Java XML APIs at [https://packt.live/31yBoSL](https://packt.live/31yBoSL)
    and [https://packt.live/2BvD2tJ](https://packt.live/2BvD2tJ).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the DOM XML API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the DOM API, you can use a `DocumentBuilder` class to parse an XML file
    into a tree of objects in memory. These objects all implement the `org.w3c.Node`
    interface. The node interface allows you to extract data from each XML element
    and then retrieve all the child nodes under a node.
  prefs: []
  type: TYPE_NORMAL
- en: Regular XML elements, such as `<city>` in our example, implement the `Element`
    interface, which extends the `Node` interface. Additionally, textual items implement
    the `Text` interface. And, the overall document is represented by the `Document`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The entire DOM is hierarchical. For example, consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In this short snippet, `<city>` is an element, and has a child element for `<name>`.
    The `London` text is a child of the `<name>` element. The `London` text will be
    held in an object that implements the `Text` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The DOM API needs to load the entire XML document into a hierarchy of nodes.
    The DOM API would not be appropriate for a large XML document, as you could run
    out of memory.
  prefs: []
  type: TYPE_NORMAL
- en: When using the DOM API, the first step is to load an XML file and parse it into
    the hierarchy of objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, you need a `DocumentBuilder` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have a `DocumentBuilder` class, you can parse an XML file to get a
    `Document` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a `Document` is a `Node`, you can start processing all the child nodes.
    Typically, you start with the first child of the `Document` interface (`<cities>`
    in our earlier example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The call to `getFirstChild()` returns the first child of the `document`, which
    is the top-level XML element. You can then call `getChildNodes()` to retrieve
    all the immediate child elements. Unfortunately, the `NodeList` object returned
    is not a `List` and not a `Collection` interface, which makes iterating over the
    child nodes more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then use recursion to get the child nodes of any given node, and the
    children of those children, and so on. For example, look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first check whether a given node has child nodes. If not,
    we have nothing to do. If there are child nodes, we'll use the same technique
    shown previously to get each child node.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have a node, the code checks whether the node is a `Text` node by using
    the `getNodeType()` method. If the node is a `Text` node, we'll print out the
    text. If not, we'll make a recursive call with the child node. This will retrieve
    all the children of the child node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 4: Traversing an XML Document'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll write code to traverse the tree of node objects parsed
    from the `cities.xml` file we created in *Exercise 3*, *Creating an XML File*.
    The code will print out the XML elements as text. Carry out the following steps
    to complete the exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `build.gradle` file. Add new dependency for the `Apache Commons Lang`
    library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This library has a few helpful utility methods that we will use when generating
    the output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Right-click on the `com.packtpub.recursion` package name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Java class named `XmlTraverser`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the following method to load an XML file into the DOM tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note how this code catches all the possible exceptions from reading in the file
    and parsing the XML content.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, enter in a method to print the `Text` node content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method uses the Apache `StringUtils` class to check whether the text is
    blank or not. You'll find that the DOM API populates a lot of blank `Text` nodes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To help represent the hierarchical nature of XML documents, enter a utility
    method for indenting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, we use the `StringUtils` class to do the tedious work of padding an empty
    string with a given number of spaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we create the main recursive method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method prints out the name of the input node (which will be the city, country,
    or something similar). It then checks for child nodes. If the child node is a
    `Text` node, it prints out the text. Otherwise, this method calls itself recursively
    to process all the children of the child node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To get going, create a short method to start the recursive calls from the first
    child of the XML document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need a `main()` method to load the XML file and traverse the document:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you run this program, you will see the following output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The preceding output is truncated. The full source code of this exercise can
    be found at: [https://packt.live/33VDygZ](https://packt.live/33VDygZ).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Activity 1: Calculating the Fibonacci Sequence'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Fibonacci sequence is a series of numbers where each number is the sum of
    the previous two numbers. Write a recursive method to generate the first 15 numbers
    of the Fibonacci sequence. Note that the Fibonacci value for 0 is 0, and the Fibonacci
    value for 1 is 1.
  prefs: []
  type: TYPE_NORMAL
- en: The Fibonacci sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you can use the following as a guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use a recursive method to calculate the Fibonacci value for a given
    input, and then create a loop to display the sequence. To do so, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `fibonacci` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check if the value passed to the `fibonacci` method is 0, if yes then return
    0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, check if the value passed to the `fibonacci` method is 1, if yes then
    return 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Else, add the fibonacci values of the previous two numbers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the main method, create a for loop that initializes from 0 to 15 and call
    the `fibonaci` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you run your program, you should see an output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 562.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Recursion is a handy programming technique that is used for a few complex problems.
    You'll commonly find recursion in mathematical formulas, as well as when traversing
    hierarchical data structures such as binary trees or XML documents. With recursion,
    a Java method or a class calls itself. But do not forget to code a terminating
    condition, or you'll find your application quickly runs out of memory on the Java
    call stack. you'll find your application quickly runs out of memory on the Java
    call stack.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about predicates and functional programming
    with Java.
  prefs: []
  type: TYPE_NORMAL
