- en: Managing Data Persistence with Quarkus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have developed some basic applications using in-memory structures
    that can be accessed through REST channels. But this is just the beginning. In
    real-world examples, you don't just rely on in-memory data; instead, you persist
    your data structure either on a relational database or somewhere else, such as
    in NoSQL storage. Therefore, in this chapter, we will leverage the essential skills
    we need in order to build applications in Quarkus that persist data into a relational
    database. We will also learn how to use an **Object Relational Mapping** (**ORM**)
    tool such as Hibernate ORM to map a database as storage and how to simplify its
    usage with the **Hibernate ORM with Panache** extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ORM layer to the customer service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and running an application to reach an RDBMS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Taking both services (application and database) into the cloud
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding Hibernate ORM with Panache on top of your application to simplify the
    ORM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05).
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ORM layer to our applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve ever worked on an Enterprise project before, you will know that
    almost every Java application uses an ORM tool to map an external database. The
    advantages of mapping a database structure with Java objects are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Database neutrality**: Your code will not be database-specific, so you don''t
    need to adapt your code to a specific database SQL syntax, which may vary between
    vendors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Developer friendly workflow**: You don''t need to write complex SQL structures
    to access your data â€“ you simply need to refer to Java fields.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the other hand, it's also true that, by writing native SQL statements, you
    can be truly aware of what your code is actually doing. Also, in most cases, you
    can achieve maximum performance benefits by writing direct SQL statements. For
    this reason, most ORM tools include an option to execute native SQL statements
    to bypass the standard ORM logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the Quarkus toolkit, you can use the `quarkus-hibernate-orm` extension to
    map your Java classes as entity objects. Hibernate ORM sits between the Java application
    data access layer and the relational database. You can use Hibernate ORM APIs
    to perform operations such as query, delete, store, and on domain data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, let''s define the domain model for our application. We will start
    with the simple **Customer** object since we already know what it is. To make
    our example a bit more interesting, we will add another object, called **Orders**,
    that is related to our **Customer** object. To be precise, we will declare a **one-to-many**
    relationship between a **Customer** and its **Orders**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4acb8b92-fd0f-44da-b3d6-666191e02670.png)'
  prefs: []
  type: TYPE_IMG
- en: To get started, let's check the first example for this chapter, which is located
    in the `Chapter05/hibernate` folder in this book's GitHub repository. We recommend
    importing the project into your IDE before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you inspect the `pom.xml` file of this project, you will find several new
    extensions included in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`quarkus-hibernate-orm`: This extension is the core dependency that we need
    in order to use Hibernate''s ORM tool in our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-agroal`: This extension buys us the Agroal connection pool, which
    will handle JDBC connection management for us.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-jdbc-postgresql`: This extension contains the JDBC modules that we
    need in order to connect to the PostgreSQL database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quarkus-resteasy-jsonb`: This extension is needed so that we can create JSON
    items at runtime and produce a JSON response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following code shows the additional dependencies as XML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've looked at the project's configuration, let's inspect the single
    components that make up our application.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the entity layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first thing we need to check is the list of entity objects that will map
    the database tables. The first one is the `Customer @Entity` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s go through the single annotations we have included in the entity class:'
  prefs: []
  type: TYPE_NORMAL
- en: The `@Entity` annotation makes this class eligible for persistence. It can be
    coupled with the `@Table` annotation to define the corresponding database table
    to a map. If it's not included, like in our case, it will map a database table
    with the same name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@NamedQuery` annotation (placed at the class level) is a statically defined
    SQL statement featuring a query string. Using named queries in your code improves
    how your code is organized since it separates the JPA query language from the
    Java code. It also avoids the bad practice of embedding string literals directly
    in your SQL, thus enforcing the use of parameters instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Id` annotation specifies the primary key of an entity, which will be unique
    for every record.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@SequenceGenerator` annotation is used to delegate the creation of a sequence
    as a unique identifier for primary keys. You will need to check that your database
    is capable of handling sequences. On the other hand, although this isn't the default
    option, this is considered a safer alternative since the identifier can be generated
    prior to executing the `INSERT` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@Column` annotation is used to tell Hibernate ORM that the Java field maps
    a database column. Note that we have also specified a constraint in terms of the
    size of the column. Since we will let Hibernate ORM create our database structures
    from Java code, all the constraints that are declared in the Java class will effectively
    turn into database constraints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we had to apply two annotations on top of the `orders` field:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@OneToMany` annotation defines a one-to-many relationship with the `Orders`
    table (that is, one customer is associated with many orders).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@JsonbTransient` annotation prevents mapping the field to the JSON representation
    (since the reverse mapping for this relationship is included in the `Orders` class,
    mapping this field to JSON would cause a `StackOverflow` error).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In our code example, we have omitted the getter/setter methods for the sake
    of brevity. These are, however, needed by Hibernate ORM to perform entity reads
    and writes against the database. In the *Making data persistence easier with Hibernate
    Panache* section later in this chapter, we will learn how to make our code leaner
    and cleaner by extending the `PanacheEntity` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Customer` entity, in turn, references the following `Orders` class, which
    provides the other side of the one-to-many annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It's worth noting that the named query for this class is slightly more elaborated
    since `Orders.findAll` `NamedQuery` uses a parameter in order to filter the orders
    by a specific customer.
  prefs: []
  type: TYPE_NORMAL
- en: Since the `Customer` structure and the `Orders` structure make up a bidirectional
    association, we need to map the corresponding `Customer` field to the `@javax.persistence.ManyToOne`
    annotation.
  prefs: []
  type: TYPE_NORMAL
- en: We also have included the `@javax.persistence.JoinColumn` annotation to indicate
    that this entity is the owner of the relationship. In database terms, this means
    that the corresponding table has a column with a foreign key for the referenced
    table. Now that we have a class where data will be stored, let's inspect the `Repository`
    class, which is used to access data from the RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the repository classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to access our `Customer` data, we are still relying on the `CustomerRepository`
    class, which needs to be adjusted. First and foremost, we have injected an instance
    of the `EntityManager` interface in order to manage the persistence of entity
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have a reference to `EntityManager`, we can use it to perform CRUD
    operations on the rest of the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that we have marked all methods that are performing write
    operations with the `@javax.transaction.Transactional` annotation. This is the
    simplest way to demarcate transaction boundaries in a Quarkus application, just
    like we used to do in Java Enterprise applications. In practice, a `@Transactional`
    method will run in the context of the caller's transaction, if any. Otherwise,
    it will start a new transaction before running the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we created a `Repository` class, which is also used to manage orders.
    The `OrderRepository` class is pretty much equivalent to the `CustomerRepository`
    class, except for the fact that the `findAll` method will filter through the orders
    of a specific customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've discussed `Repository` and entity classes, let's check out the
    REST endpoint, which makes the application responsive.
  prefs: []
  type: TYPE_NORMAL
- en: Defining REST endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our application defines one REST endpoint for each `Repository` class. We already
    coded `CustomerEndpoint` in the previous chapter, which was blissfully unaware
    of whether it was using storage or not. Therefore, half of the work has already
    been done. We''ve only added `OrderEndpoint` here, which maps CRUD HTTP operations
    accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Our `OrderEndpoint` is slightly more elaborate since it needs to filter through
    each order operation by `Customer` ID in the `getAll` method. We also used the
    `@PathParam` annotation across the code to move the `Customer` and `Orders` data
    from the client to the REST endpoint.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Database connections are made through Quarkus'' main configuration file (`application.properties`),
    which needs, at the very least, the JDBC settings for the database. We will be
    using PostgreSQL as storage so that the JDBC URL and driver comply with PostgreSQL
    JDBC''s specifications. The following configuration will be used to access the
    `quarkusdb` database, which uses the `quarkus/quarkus` credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that we are using two environment variables (`POSTGRESQL_SERVICE_HOST`
    and `POSTGRESQL_SERVICE_PORT`) to define the database host and port. If they're
    left undefined, they will be set to `localhost` and `5432`. This configuration
    will come in handy when we switch our application from the local filesystem to
    the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we configured Hibernate ORM to use the **drop and create** strategy at
    boot. This is ideal for developing or testing applications as it will drop and
    regenerate the schema and database objects from the Java Entity each time we start
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, we have included the Agroal connection pool settings to define
    the pool''s initial size, the minimum number of connections to be kept available
    in memory, and the maximum number of simultaneous connections which can be opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, it can be useful to have some pre-inserted rows in our schema for
    testing purposes. Hence, we have set the location where the script (`import.sql`)
    is located using the following property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following content in the `import.sql` script adds two rows to the `Customer`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding SQL script can be found in the `src/main/resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've inspected our service, we will check the test class, which verifies
    CRUD operations automatically. Then, we will take a look at the web interface
    so that we can test the code through a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Coding a test class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our basic `Test` class assumes that we already have a couple of `Customer`
    objects available. Therefore, once we verify their count with a `GET` request,
    we will test all CRUD operations on the `Orders` subordinate entity, as illustrated
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This test class shouldn't be too complex at this point. We are basically testing
    that the two customers are available in the database using the `org.hamcrest.CoreMatchers.is`
    construct. Then, we are performing a complete round of operations on the `Orders`
    entity by creating one item, updating it, querying it, and finally deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the test, we need an available database where data is going
    to be persisted. The recommended approach, if you haven''t got an active PostgreSQL
    instance, is to start a `docker` image using the following shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Please note that, in addition to the database user, password, and DB settings,
    we are also enforcing our container via the `--ulimit memlock=-1:-1` setting in
    order to do unlimited memlocking to prevent swapping. We are also forwarding the
    database's address and port to all IPv4/IPv6 addresses that are available on the
    local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output will be emitted when the `docker` process is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can launch the test class with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output should confirm that the test ran successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Now, we will check the static web pages of the project that we have added so
    that we can access and manage our service.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a web interface to our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our service includes two static web pages to manage the customer service and
    the orders for each customer. As you know from our previous chapter, static pages
    are found in the `src/main/resources/META-INF/resources` file of your project
    by default. We can reuse the same `index.html` page from the previous chapter,
    which will be our landing page for our application. One enhancement you will find,
    though, is an action named Add Order, which redirects our users to the `order.html`
    page, which passes a query parameter of the `Customer` information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `order.html` page has its own AngularJS Controller that is in charge of
    displaying the set of `Orders` for the `Customer` selected, allowing us to read,
    create, modify, or delete existing orders. The following is the first part of
    the Angular Controller, which defines the module and Controller names, and collects
    the form parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second part of our JavaScript code, we have included a `$scope.update`
    function to insert/edit new `Orders`, a `$scope.remove` function to delete existing
    orders, and a `reloadData` function to retrieve the list of `Orders` for that
    `Customer`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For the sake of brevity, we haven't included the full HTML page but you can
    find it in this book's GitHub repository (as we mentioned in the *Technical requirements*
    section at the beginning of this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: Running the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The application can be executed from the same shell where we ran our test (so
    that we still retain the `DB_HOST` environment variable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should expect the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, go to the landing page using the following URL: `http://localhost:8080`.
    Here, you will see a prefilled list of customers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9f32f679-dac7-4607-9dab-c25bbd7bb617.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Try adding some orders for customers by clicking on the Orders button. You
    will be taken to the following UI, where you can read, modify, delete, and store
    new orders for each customer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6e8ea23-d473-45dd-86f0-54f15ef572c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Great! The application works as expected. Can it be improved further? From a
    performance point of view, the throughput of the application could be improved
    if we cached data that is frequently accessed. The next section will show you
    how you can accomplish this using Hibernate ORM's caching mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: Caching entity data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Caching entities can be easily configured in Hibernate ORM through its advanced
    caching mechanism. Three kinds of cache are available out of the box:'
  prefs: []
  type: TYPE_NORMAL
- en: The **first-level cache** is a transaction-level cache that's used to track
    the state of the entities during the current session. It's enabled by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **second-level cache** is used to cache entities across various Hibernate
    ORM sessions. This makes it a `SessionFactory`-level cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **query cache** is used to cache Hibernate ORM queries and their results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second-level cache and query cache are not enabled by default due to the
    large amount of memory they could potentially consume. To make an entity eligible
    to cache its data, you can annotate it with the `@javax.persistence.Cacheable`
    annotation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, the customer's field values are cached, except for collections
    and relationships with other entities. This means that the entity, once cached,
    can be searched by its primary key without querying the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of HQL queries can also be cached. This can be quite useful when
    you want to execute queries for read-mostly entity objects. The simplest way to
    make an HQL query cacheable is to add a `@javax.persistence.QueryHint` annotation
    to `@NamedQuery`, with the `org.hibernate.cacheable` attribute set to `true`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily verify the preceding assertion by turning on SQL logging in
    your `application.properties` file, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if you run the application, you should be able to see a **single** SQL
    statement you can use to query the `Customer` list in the console, no matter how
    many times you have requested the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Great! You have reached the first milestone, that is, running the application
    on your local filesystem and caching frequently used SQL statements in Hibernate
    ORM's **second-level cache** (**2LC**). Now, it's time to take our application
    to the cloud!
  prefs: []
  type: TYPE_NORMAL
- en: Taking an application to the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Having tested the application through the local JVM, it''s time to bring it
    natively into the cloud. The interesting part of this process will be connecting
    the Quarkus application with the PostgreSQL application on OpenShift without touching
    even one line of code! Let''s look at how we can achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start your Minishift instance and create a new project named `quarkus-hibernate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will be adding a PostgreSQL application to our project. A PostgreSQL
    image stream is included in the `openshift` namespace by default, which you can
    check with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output in your console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To create the PostgreSQL application, the following configuration variables
    need to be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POSTGRESQL_USER`: Username for the PostgreSQL account to be created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRESQL_PASSWORD`: Password for the user account'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POSTGRESQL_DATABASE`: Database name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be using the same parameters we defined in the `application.properties`
    file so that we can bootstrap our application with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In your console logs, check that the following output has been produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the list of available services (`oc get services`) to
    verify whether `postgresql` is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the service is now active at the cluster IP address `172.30.154.130`.
    Luckily, we don't need to hardcode this address in our application code since
    we will be using the service name, `postgresql`, which works like an alias of
    the cluster address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create a binary build of our project so that it can be deployed
    into Minishift. Impatient users can just execute the `deploy-openshift.sh` script,
    which is available on GitHub in the root folder of this chapter. Within it, you
    will find the following commented list of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of this process, you should be able to see the following route available
    through the `oc get routes` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The overall status of the applications can be also checked from the web console
    of your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0d455dab-3759-4c8c-b958-4b76759df252.png)'
  prefs: []
  type: TYPE_IMG
- en: You can now navigate to the external route of the application (the actual route
    address will vary, depending on your network configuration. In our example, it's
    http://quarkus-hibernate-quarkus-hibernate.192.168.42.30.nip.io) and check that
    the application works smoothly on the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Making data persistence easier using Panache API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hibernate ORM is the standard way to map database structures into Java objects.
    The main downside of using an ORM tool is that even a simple database structure
    requires lots of boilerplate code (such as getter and setters methods). Also,
    you have to include basic query methods in your repository classes, which makes
    the work quite repetitive. In this section, we will learn how to use Hibernate
    Panache to simplify and accelerate the development of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: To get started with Hibernate ORM with Panache, let's check the second example
    for this chapter, which is located in the `Chapter05/hibernate-panache` folder
    in this book's GitHub repository. We recommend importing the project into your
    IDE before you move on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you take a look at the project''s configuration, you will see that we have
    included `quarkus-hibernate-orm-panache` in the `pom.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the only configuration that we need to use Hibernate Panache. Now comes
    the funny part. There are two strategies for plugging Panache into your entity:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Extending the `io.quarkus.hibernate.orm.panache.PanacheEntity` class: This
    is the simplest option as you will get an ID field that is auto-generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Extending `io.quarkus.hibernate.orm.panache.PanacheEntityBase`: This option
    can be used if you require a custom ID strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we are using a `SequenceGenerator` strategy for our ID field, we will
    use the latter option. Following is the `Customer` class, which has been rewritten
    so that it extends `PanacheEntityBase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the code has been reduced quite a lot as we haven''t used a
    getter/setter field. Instead, some fields have been exposed as `public` so that
    they can be accessed directly by the classes. The `Orders` entity has been rewritten
    using the same pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have seen some of the benefits that are provided by Hibernate Panache.
    Another aspect worth mentioning is that by extending `PanacheEntityBase` (or `PanacheEntity`),
    you will be able to use a set of static methods directly on your entity. Following
    is a table containing the most common methods you can trigger on your entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `count` | Counts this entity from the database (with an optional query and
    parameters) |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | Delete this entity from the database if it has already been persisted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `flush` | Flushes all pending changes to the database |'
  prefs: []
  type: TYPE_TB
- en: '| `findById` | Finds an entity of this type by ID |'
  prefs: []
  type: TYPE_TB
- en: '| `find` | Finds entities using a query with optional parameters and a sort
    strategy |'
  prefs: []
  type: TYPE_TB
- en: '| `findAll` | Finds all the entities of this type |'
  prefs: []
  type: TYPE_TB
- en: '| `list` | Shortcut for `find().list()` |'
  prefs: []
  type: TYPE_TB
- en: '| `listAll` | Shortcut for `findAll().list()` |'
  prefs: []
  type: TYPE_TB
- en: '| `deleteAll` | Deletes all the entities of this type |'
  prefs: []
  type: TYPE_TB
- en: '| `delete` | Deletes entities using a query with optional parameters |'
  prefs: []
  type: TYPE_TB
- en: '| `persist` | Persists all given entities |'
  prefs: []
  type: TYPE_TB
- en: 'The following shows the `CustomerRepository` class, which leverages the new
    field and methods that are available in the `Customer` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The most obvious advantage is that you don't need `EntityManager` as a proxy
    to manage your entity class anymore. Instead, you can directly invoke static methods
    that are available in your entity, thus dramatically reducing the verbosity of
    your `Repository` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, let''s have a look at the `OrderRepository` class,
    which has been adapted to use Panache objects as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Nothing else has been changed in your application since switching to Hibernate
    Panache is completely transparent for our REST endpoint and the web interfaces.
    Build and run the application as usual with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'On the console, you should see that the application has started and the two
    initial customers have been added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, enjoy your simplified CRUD application powered by Hibernate ORM with Panache!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at data persistence and covered the well-known Hibernate
    ORM framework. If you have some years' Enterprise programming under your belt,
    you shouldn't have found it challenging to apply the same concepts to Quarkus.
    Now, your overall skills include configuring an RDBMS-based application using
    Hibernate and its simplified paradigm called Panache. We have also learned how
    to deploy and connect both RDBMS and our application on the cloud on an OpenShift
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we have mastered the major pillars of Enterprise programming (moving
    from REST services to servlets, CDI, and data persistence).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll learn how we can complement the standard Enterprise
    API with the MicroProfile API in Quarkus.
  prefs: []
  type: TYPE_NORMAL
