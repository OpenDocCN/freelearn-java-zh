- en: Managing Data Persistence with Quarkus
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Quarkus 管理数据持久化
- en: So far, we have developed some basic applications using in-memory structures
    that can be accessed through REST channels. But this is just the beginning. In
    real-world examples, you don't just rely on in-memory data; instead, you persist
    your data structure either on a relational database or somewhere else, such as
    in NoSQL storage. Therefore, in this chapter, we will leverage the essential skills
    we need in order to build applications in Quarkus that persist data into a relational
    database. We will also learn how to use an **Object Relational Mapping** (**ORM**)
    tool such as Hibernate ORM to map a database as storage and how to simplify its
    usage with the **Hibernate ORM with Panache** extension.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用内存结构开发了一些基本的应用程序，这些结构可以通过 REST 通道访问。但这只是开始。在现实世界的例子中，你不仅仅依赖于内存数据；相反，你将数据结构持久化在关系型数据库或其他地方，例如
    NoSQL 存储。因此，在本章中，我们将利用构建 Quarkus 应用程序并将数据持久化到关系型数据库所需的基本技能。我们还将学习如何使用 **对象关系映射**（**ORM**）工具，如
    Hibernate ORM，将数据库映射为存储，以及如何使用 **Hibernate ORM with Panache** 扩展简化其使用。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding an ORM layer to the customer service
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在客户服务中添加 ORM 层
- en: Configuring and running an application to reach an RDBMS
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和运行应用程序以连接到 RDBMS
- en: Taking both services (application and database) into the cloud
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将服务（应用程序和数据库）同时迁移到云端
- en: Adding Hibernate ORM with Panache on top of your application to simplify the
    ORM
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的应用程序上添加 Hibernate ORM with Panache 以简化 ORM
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You can find the source code for the project in this chapter on GitHub at [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 上找到本章项目的源代码，链接为 [https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05](https://github.com/PacktPublishing/Hands-On-Cloud-Native-Applications-with-Java-and-Quarkus/tree/master/Chapter05)。
- en: Adding an ORM layer to our applications
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在我们的应用程序中添加 ORM 层
- en: 'If you''ve ever worked on an Enterprise project before, you will know that
    almost every Java application uses an ORM tool to map an external database. The
    advantages of mapping a database structure with Java objects are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前曾参与过企业项目，你会知道几乎每个 Java 应用程序都使用 ORM 工具来映射外部数据库。使用 Java 对象映射数据库结构的优势如下：
- en: '**Database neutrality**: Your code will not be database-specific, so you don''t
    need to adapt your code to a specific database SQL syntax, which may vary between
    vendors.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库中立性**：你的代码将不是针对特定数据库的，因此你不需要将你的代码适应特定的数据库 SQL 语法，这些语法可能在供应商之间有所不同。'
- en: '**Developer friendly workflow**: You don''t need to write complex SQL structures
    to access your data – you simply need to refer to Java fields.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者友好的工作流程**：你不需要编写复杂的 SQL 结构来访问你的数据 - 你只需要引用 Java 字段。'
- en: On the other hand, it's also true that, by writing native SQL statements, you
    can be truly aware of what your code is actually doing. Also, in most cases, you
    can achieve maximum performance benefits by writing direct SQL statements. For
    this reason, most ORM tools include an option to execute native SQL statements
    to bypass the standard ORM logic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，编写原生 SQL 语句确实可以使你真正了解你的代码正在做什么。此外，在大多数情况下，通过编写直接 SQL 语句，你可以实现最大的性能提升。因此，大多数
    ORM 工具都包括执行原生 SQL 语句的选项，以绕过标准的 ORM 逻辑。
- en: In the Quarkus toolkit, you can use the `quarkus-hibernate-orm` extension to
    map your Java classes as entity objects. Hibernate ORM sits between the Java application
    data access layer and the relational database. You can use Hibernate ORM APIs
    to perform operations such as query, delete, store, and on domain data.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Quarkus 工具包中，你可以使用 `quarkus-hibernate-orm` 扩展将你的 Java 类映射为实体对象。Hibernate ORM
    位于 Java 应用程序数据访问层和关系型数据库之间。你可以使用 Hibernate ORM API 执行查询、删除、存储和域数据等操作。
- en: 'First of all, let''s define the domain model for our application. We will start
    with the simple **Customer** object since we already know what it is. To make
    our example a bit more interesting, we will add another object, called **Orders**,
    that is related to our **Customer** object. To be precise, we will declare a **one-to-many**
    relationship between a **Customer** and its **Orders**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义我们应用程序的领域模型。我们将从简单的**Customer**对象开始，因为我们已经知道它是什么。为了使我们的例子更有趣，我们将添加另一个对象，称为**Orders**，它与我们的**Customer**对象相关。更准确地说，我们将声明一个**Customer**和其**Orders**之间的**一对一**关系：
- en: '![](img/4acb8b92-fd0f-44da-b3d6-666191e02670.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4acb8b92-fd0f-44da-b3d6-666191e02670.png)'
- en: To get started, let's check the first example for this chapter, which is located
    in the `Chapter05/hibernate` folder in this book's GitHub repository. We recommend
    importing the project into your IDE before moving on.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，让我们检查本章的第一个示例，它位于本书GitHub仓库的`Chapter05/hibernate`文件夹中。我们建议在继续之前将项目导入到您的IDE中。
- en: 'If you inspect the `pom.xml` file of this project, you will find several new
    extensions included in it:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您检查这个项目的`pom.xml`文件，您将发现其中包含了许多新的扩展。
- en: '`quarkus-hibernate-orm`: This extension is the core dependency that we need
    in order to use Hibernate''s ORM tool in our application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-hibernate-orm`：这个扩展是我们使用Hibernate的ORM工具在应用程序中所需的核心依赖项。'
- en: '`quarkus-agroal`: This extension buys us the Agroal connection pool, which
    will handle JDBC connection management for us.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-agroal`：这个扩展为我们购买了Agroal连接池，它将为我们处理JDBC连接管理。'
- en: '`quarkus-jdbc-postgresql`: This extension contains the JDBC modules that we
    need in order to connect to the PostgreSQL database.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-jdbc-postgresql`：这个扩展包含我们连接到PostgreSQL数据库所需的JDBC模块。'
- en: '`quarkus-resteasy-jsonb`: This extension is needed so that we can create JSON
    items at runtime and produce a JSON response.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`quarkus-resteasy-jsonb`：这个扩展是必需的，这样我们就可以在运行时创建JSON项并生成JSON响应。'
- en: 'The following code shows the additional dependencies as XML elements:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了作为XML元素的附加依赖项：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we've looked at the project's configuration, let's inspect the single
    components that make up our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了项目的配置，让我们检查构成我们应用程序的单个组件。
- en: Defining the entity layer
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义实体层
- en: 'The first thing we need to check is the list of entity objects that will map
    the database tables. The first one is the `Customer @Entity` class, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要检查映射数据库表的实体对象列表。第一个是`Customer @Entity`类，如下所示：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s go through the single annotations we have included in the entity class:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一检查我们在实体类中包含的单个注解：
- en: The `@Entity` annotation makes this class eligible for persistence. It can be
    coupled with the `@Table` annotation to define the corresponding database table
    to a map. If it's not included, like in our case, it will map a database table
    with the same name.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Entity`注解使这个类有资格进行持久化。它可以与`@Table`注解结合使用，以将相应的数据库表映射到映射。如果没有包含，就像在我们的例子中一样，它将映射具有相同名称的数据库表。'
- en: The `@NamedQuery` annotation (placed at the class level) is a statically defined
    SQL statement featuring a query string. Using named queries in your code improves
    how your code is organized since it separates the JPA query language from the
    Java code. It also avoids the bad practice of embedding string literals directly
    in your SQL, thus enforcing the use of parameters instead.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@NamedQuery`注解（放置在类级别）是一个静态定义的SQL语句，包含一个查询字符串。在您的代码中使用命名查询可以提高代码的组织方式，因为它将JPA查询语言与Java代码分开。它还避免了将字符串字面量直接嵌入SQL中的不良做法，从而强制使用参数。'
- en: The `@Id` annotation specifies the primary key of an entity, which will be unique
    for every record.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Id`注解指定了实体的主键，它将为每条记录都是唯一的。'
- en: The `@SequenceGenerator` annotation is used to delegate the creation of a sequence
    as a unique identifier for primary keys. You will need to check that your database
    is capable of handling sequences. On the other hand, although this isn't the default
    option, this is considered a safer alternative since the identifier can be generated
    prior to executing the `INSERT` statement.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@SequenceGenerator`注解用于委托创建一个序列作为主键的唯一标识符。您需要检查您的数据库是否能够处理序列。另一方面，尽管这不是默认选项，但这被认为是一个更安全的替代方案，因为标识符可以在执行`INSERT`语句之前生成。'
- en: The `@Column` annotation is used to tell Hibernate ORM that the Java field maps
    a database column. Note that we have also specified a constraint in terms of the
    size of the column. Since we will let Hibernate ORM create our database structures
    from Java code, all the constraints that are declared in the Java class will effectively
    turn into database constraints.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Column` 注解用于告诉 Hibernate ORM，Java 字段映射了一个数据库列。请注意，我们还在列的大小方面指定了一个约束。由于我们将让
    Hibernate ORM 从 Java 代码创建我们的数据库结构，因此 Java 类中声明的所有约束都将有效地转换为数据库约束。'
- en: 'Finally, we had to apply two annotations on top of the `orders` field:'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们不得不在 `orders` 字段上应用两个注解：
- en: The `@OneToMany` annotation defines a one-to-many relationship with the `Orders`
    table (that is, one customer is associated with many orders).
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@OneToMany` 注解定义了与 `Orders` 表（即一个客户关联多个订单）的一对多关系。'
- en: The `@JsonbTransient` annotation prevents mapping the field to the JSON representation
    (since the reverse mapping for this relationship is included in the `Orders` class,
    mapping this field to JSON would cause a `StackOverflow` error).
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@JsonbTransient` 注解阻止将字段映射到 JSON 表示形式（由于这个关系的反向映射包含在 `Orders` 类中，将此字段映射到 JSON
    将导致 `StackOverflow` 错误）。'
- en: In our code example, we have omitted the getter/setter methods for the sake
    of brevity. These are, however, needed by Hibernate ORM to perform entity reads
    and writes against the database. In the *Making data persistence easier with Hibernate
    Panache* section later in this chapter, we will learn how to make our code leaner
    and cleaner by extending the `PanacheEntity` API.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的代码示例中，为了简洁起见，我们省略了 getter/setter 方法。然而，Hibernate ORM 需要这些方法来对数据库执行实体读取和写入。在本章后面的
    *使用 Hibernate Panache 简化数据持久性* 部分，我们将学习如何通过扩展 `PanacheEntity` API 来使我们的代码更加精简和整洁。
- en: 'The `Customer` entity, in turn, references the following `Orders` class, which
    provides the other side of the one-to-many annotation:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Customer` 实体反过来又引用了以下 `Orders` 类，它提供了单一到多注解的另一端：'
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It's worth noting that the named query for this class is slightly more elaborated
    since `Orders.findAll` `NamedQuery` uses a parameter in order to filter the orders
    by a specific customer.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，这个类的命名查询稍微详细一些，因为 `Orders.findAll` `NamedQuery` 使用一个参数来过滤特定客户的订单。
- en: Since the `Customer` structure and the `Orders` structure make up a bidirectional
    association, we need to map the corresponding `Customer` field to the `@javax.persistence.ManyToOne`
    annotation.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `Customer` 结构和 `Orders` 结构构成一个双向关联，我们需要将相应的 `Customer` 字段映射到 `@javax.persistence.ManyToOne`
    注解。
- en: We also have included the `@javax.persistence.JoinColumn` annotation to indicate
    that this entity is the owner of the relationship. In database terms, this means
    that the corresponding table has a column with a foreign key for the referenced
    table. Now that we have a class where data will be stored, let's inspect the `Repository`
    class, which is used to access data from the RDBMS.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还包含了 `@javax.persistence.JoinColumn` 注解，以表明这个实体是关系的所有者。在数据库术语中，这意味着相应的表有一个外键列，用于引用表。现在我们已经有一个将存储数据的类，让我们检查
    `Repository` 类，它用于从 RDBMS 访问数据。
- en: Coding the repository classes
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写仓库类
- en: 'In order to access our `Customer` data, we are still relying on the `CustomerRepository`
    class, which needs to be adjusted. First and foremost, we have injected an instance
    of the `EntityManager` interface in order to manage the persistence of entity
    instances:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了访问我们的 `Customer` 数据，我们仍然依赖于 `CustomerRepository` 类，这需要调整。首先，我们注入了 `EntityManager`
    接口的一个实例，以便管理实体实例的持久性：
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once we have a reference to `EntityManager`, we can use it to perform CRUD
    operations on the rest of the class:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `EntityManager` 的引用，我们就可以使用它来对类中的其余部分执行 CRUD 操作：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's important to note that we have marked all methods that are performing write
    operations with the `@javax.transaction.Transactional` annotation. This is the
    simplest way to demarcate transaction boundaries in a Quarkus application, just
    like we used to do in Java Enterprise applications. In practice, a `@Transactional`
    method will run in the context of the caller's transaction, if any. Otherwise,
    it will start a new transaction before running the method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，我们已将所有执行写操作的方法标记为 `@javax.transaction.Transactional` 注解。这是在 Quarkus
    应用程序中划分事务边界的最简单方法，就像我们在 Java 企业应用程序中做的那样。在实践中，如果存在调用者的上下文事务，则 `@Transactional`
    方法将在该事务的上下文中运行。否则，它将在运行方法之前启动一个新事务。
- en: 'Next, we created a `Repository` class, which is also used to manage orders.
    The `OrderRepository` class is pretty much equivalent to the `CustomerRepository`
    class, except for the fact that the `findAll` method will filter through the orders
    of a specific customer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个`Repository`类，该类也用于管理订单。`OrderRepository`类基本上等同于`CustomerRepository`类，除了`findAll`方法会过滤特定客户的订单：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we've discussed `Repository` and entity classes, let's check out the
    REST endpoint, which makes the application responsive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了`Repository`和实体类，让我们来看看REST端点，它使应用程序具有响应性。
- en: Defining REST endpoints
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义REST端点
- en: 'Our application defines one REST endpoint for each `Repository` class. We already
    coded `CustomerEndpoint` in the previous chapter, which was blissfully unaware
    of whether it was using storage or not. Therefore, half of the work has already
    been done. We''ve only added `OrderEndpoint` here, which maps CRUD HTTP operations
    accordingly:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序为每个`Repository`类定义了一个REST端点。我们在上一章中已经编写了`CustomerEndpoint`，它对是否使用存储一无所知。因此，一半的工作已经完成。我们在这里只添加了`OrderEndpoint`，它相应地映射CRUD
    HTTP操作：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Our `OrderEndpoint` is slightly more elaborate since it needs to filter through
    each order operation by `Customer` ID in the `getAll` method. We also used the
    `@PathParam` annotation across the code to move the `Customer` and `Orders` data
    from the client to the REST endpoint.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`OrderEndpoint`稍微复杂一些，因为它需要在`getAll`方法中通过`Customer` ID过滤每个订单操作。我们还使用了`@PathParam`注解在代码中，以将`Customer`和`Orders`数据从客户端移动到REST端点。
- en: Connecting to the database
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: 'Database connections are made through Quarkus'' main configuration file (`application.properties`),
    which needs, at the very least, the JDBC settings for the database. We will be
    using PostgreSQL as storage so that the JDBC URL and driver comply with PostgreSQL
    JDBC''s specifications. The following configuration will be used to access the
    `quarkusdb` database, which uses the `quarkus/quarkus` credentials:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库连接是通过Quarkus的主配置文件（`application.properties`）进行的，该文件至少需要包含数据库的JDBC设置。我们将使用PostgreSQL作为存储，因此JDBC
    URL和驱动程序应符合PostgreSQL JDBC的规范。以下配置将用于访问`quarkusdb`数据库，该数据库使用`quarkus/quarkus`凭据：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note that we are using two environment variables (`POSTGRESQL_SERVICE_HOST`
    and `POSTGRESQL_SERVICE_PORT`) to define the database host and port. If they're
    left undefined, they will be set to `localhost` and `5432`. This configuration
    will come in handy when we switch our application from the local filesystem to
    the cloud.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用两个环境变量（`POSTGRESQL_SERVICE_HOST`和`POSTGRESQL_SERVICE_PORT`）来定义数据库主机和端口。如果它们未被定义，它们将被设置为`localhost`和`5432`。当我们将应用程序从本地文件系统切换到云时，此配置将非常有用。
- en: 'Next, we configured Hibernate ORM to use the **drop and create** strategy at
    boot. This is ideal for developing or testing applications as it will drop and
    regenerate the schema and database objects from the Java Entity each time we start
    the application:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们配置了Hibernate ORM在启动时使用**删除并创建**策略。这对于开发或测试应用程序来说非常理想，因为它会在每次启动应用程序时从Java实体中删除并重新生成模式和数据表：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Additionally, we have included the Agroal connection pool settings to define
    the pool''s initial size, the minimum number of connections to be kept available
    in memory, and the maximum number of simultaneous connections which can be opened:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还包括了Agroal连接池设置，以定义池的初始大小、在内存中保持可用的最小连接数以及可以同时打开的最大连接数：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, it can be useful to have some pre-inserted rows in our schema for
    testing purposes. Hence, we have set the location where the script (`import.sql`)
    is located using the following property:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了测试目的，在我们的模式中预先插入一些行可能很有用。因此，我们使用以下属性设置了脚本（`import.sql`）的位置：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following content in the `import.sql` script adds two rows to the `Customer`
    table:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`import.sql`脚本中的以下内容向`Customer`表添加了两行：'
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding SQL script can be found in the `src/main/resources` folder.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上述SQL脚本可以在`src/main/resources`文件夹中找到。
- en: Now that we've inspected our service, we will check the test class, which verifies
    CRUD operations automatically. Then, we will take a look at the web interface
    so that we can test the code through a browser.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了我们的服务，我们将检查测试类，该类会自动验证CRUD操作。然后，我们将查看Web界面，以便我们可以通过浏览器测试代码。
- en: Coding a test class
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写测试类
- en: 'Our basic `Test` class assumes that we already have a couple of `Customer`
    objects available. Therefore, once we verify their count with a `GET` request,
    we will test all CRUD operations on the `Orders` subordinate entity, as illustrated
    in the following code:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的基本 `Test` 类假设我们已经有几个 `Customer` 对象可用。因此，一旦我们通过 `GET` 请求验证它们的数量，我们将在 `Orders`
    从属实体上测试所有 CRUD 操作，如下所示：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This test class shouldn't be too complex at this point. We are basically testing
    that the two customers are available in the database using the `org.hamcrest.CoreMatchers.is`
    construct. Then, we are performing a complete round of operations on the `Orders`
    entity by creating one item, updating it, querying it, and finally deleting it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，这个测试类不应该太复杂。我们基本上是在测试使用 `org.hamcrest.CoreMatchers.is` 构造在数据库中可用的两个客户。然后，我们通过创建一个项目、更新它、查询它，最后删除它，对
    `Orders` 实体执行一轮完整的操作。
- en: 'Before running the test, we need an available database where data is going
    to be persisted. The recommended approach, if you haven''t got an active PostgreSQL
    instance, is to start a `docker` image using the following shell:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行测试之前，我们需要一个可用的数据库，其中数据将被持久化。如果您还没有活动的 PostgreSQL 实例，建议您使用以下 shell 启动 `docker`
    镜像：
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Please note that, in addition to the database user, password, and DB settings,
    we are also enforcing our container via the `--ulimit memlock=-1:-1` setting in
    order to do unlimited memlocking to prevent swapping. We are also forwarding the
    database's address and port to all IPv4/IPv6 addresses that are available on the
    local machine.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，除了数据库用户、密码和数据库设置外，我们还在 `--ulimit memlock=-1:-1` 设置中强制执行我们的容器，以进行无限制的内存锁定，防止交换。我们还将数据库的地址和端口转发到本地机器上可用的所有
    IPv4/IPv6 地址。
- en: 'The following output will be emitted when the `docker` process is started:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当启动 `docker` 进程时，将发出以下输出：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, you can launch the test class with the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以使用以下命令启动测试类：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The expected output should confirm that the test ran successfully:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出应确认测试已成功运行：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we will check the static web pages of the project that we have added so
    that we can access and manage our service.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查我们添加的项目中的静态网页，以便我们可以访问和管理我们的服务。
- en: Adding a web interface to our application
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的应用程序添加网络界面
- en: 'Our service includes two static web pages to manage the customer service and
    the orders for each customer. As you know from our previous chapter, static pages
    are found in the `src/main/resources/META-INF/resources` file of your project
    by default. We can reuse the same `index.html` page from the previous chapter,
    which will be our landing page for our application. One enhancement you will find,
    though, is an action named Add Order, which redirects our users to the `order.html`
    page, which passes a query parameter of the `Customer` information:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务包括两个静态网页来管理客户服务和每个客户的订单。正如您从我们之前的章节中了解到的，默认情况下，静态页面位于您项目的 `src/main/resources/META-INF/resources`
    文件中。我们可以重用上一章中的相同 `index.html` 页面，这将成为我们应用程序的着陆页。不过，您会发现一个名为“添加订单”的操作，它将用户重定向到
    `order.html` 页面，并传递一个包含 `Customer` 信息的查询参数：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `order.html` page has its own AngularJS Controller that is in charge of
    displaying the set of `Orders` for the `Customer` selected, allowing us to read,
    create, modify, or delete existing orders. The following is the first part of
    the Angular Controller, which defines the module and Controller names, and collects
    the form parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`order.html` 页面有自己的 AngularJS 控制器，负责显示所选 `Customer` 的 `Orders` 集合，使我们能够读取、创建、修改或删除现有订单。以下为
    Angular 控制器的第一部分，它定义了模块和控制器名称，并收集表单参数：'
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the second part of our JavaScript code, we have included a `$scope.update`
    function to insert/edit new `Orders`, a `$scope.remove` function to delete existing
    orders, and a `reloadData` function to retrieve the list of `Orders` for that
    `Customer`, as shown in the following code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们 JavaScript 代码的第二部分中，我们包含了 `$scope.update` 函数来插入/编辑新的 `Orders`，一个 `$scope.remove`
    函数来删除现有订单，以及一个 `reloadData` 函数来检索该 `Customer` 的 `Orders` 列表，如下所示：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: For the sake of brevity, we haven't included the full HTML page but you can
    find it in this book's GitHub repository (as we mentioned in the *Technical requirements*
    section at the beginning of this chapter).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我们没有包括完整的 HTML 页面，但您可以在本书的 GitHub 仓库中找到它（正如我们在本章开头的 *技术要求* 部分中提到的）。
- en: Running the application
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用程序
- en: 'The application can be executed from the same shell where we ran our test (so
    that we still retain the `DB_HOST` environment variable):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序可以从我们运行测试的同一shell中执行（这样我们仍然保留`DB_HOST`环境变量）：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You should expect the following output in the console:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在控制台中期望以下输出：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, go to the landing page using the following URL: `http://localhost:8080`.
    Here, you will see a prefilled list of customers:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下URL转到登录页面：`http://localhost:8080`。在这里，您将看到一个预先填充的客户列表：
- en: '![](img/9f32f679-dac7-4607-9dab-c25bbd7bb617.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f32f679-dac7-4607-9dab-c25bbd7bb617.png)'
- en: 'Try adding some orders for customers by clicking on the Orders button. You
    will be taken to the following UI, where you can read, modify, delete, and store
    new orders for each customer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击订单按钮添加一些客户订单。您将被带到以下UI，在这里您可以读取、修改、删除并为每个客户存储新的订单：
- en: '![](img/e6e8ea23-d473-45dd-86f0-54f15ef572c9.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6e8ea23-d473-45dd-86f0-54f15ef572c9.png)'
- en: Great! The application works as expected. Can it be improved further? From a
    performance point of view, the throughput of the application could be improved
    if we cached data that is frequently accessed. The next section will show you
    how you can accomplish this using Hibernate ORM's caching mechanisms.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！应用程序按预期工作。它是否可以进一步改进？从性能的角度来看，如果我们缓存频繁访问的数据，应用程序的吞吐量可以得到提高。下一节将向您展示如何使用Hibernate
    ORM的缓存机制实现这一点。
- en: Caching entity data
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存实体数据
- en: 'Caching entities can be easily configured in Hibernate ORM through its advanced
    caching mechanism. Three kinds of cache are available out of the box:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在Hibernate ORM中，可以通过其高级缓存机制轻松配置实体缓存。默认情况下，有三种类型的缓存可用：
- en: The **first-level cache** is a transaction-level cache that's used to track
    the state of the entities during the current session. It's enabled by default.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一级缓存**是事务级别的缓存，用于跟踪当前会话期间实体的状态。默认情况下启用。'
- en: The **second-level cache** is used to cache entities across various Hibernate
    ORM sessions. This makes it a `SessionFactory`-level cache.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**二级缓存**用于在各个Hibernate ORM会话之间缓存实体。这使得它成为`SessionFactory`级别的缓存。'
- en: The **query cache** is used to cache Hibernate ORM queries and their results.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询缓存**用于缓存Hibernate ORM查询及其结果。'
- en: 'The second-level cache and query cache are not enabled by default due to the
    large amount of memory they could potentially consume. To make an entity eligible
    to cache its data, you can annotate it with the `@javax.persistence.Cacheable`
    annotation, as shown in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于二级缓存和查询缓存可能会消耗大量内存，因此默认情况下未启用。要使实体有资格缓存其数据，您可以使用`@javax.persistence.Cacheable`注解对其进行注解，如下所示：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this scenario, the customer's field values are cached, except for collections
    and relationships with other entities. This means that the entity, once cached,
    can be searched by its primary key without querying the database.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，客户的字段值被缓存，除了与其他实体的集合和关系外。这意味着一旦实体被缓存，就可以通过其主键进行搜索，而无需查询数据库。
- en: 'The results of HQL queries can also be cached. This can be quite useful when
    you want to execute queries for read-mostly entity objects. The simplest way to
    make an HQL query cacheable is to add a `@javax.persistence.QueryHint` annotation
    to `@NamedQuery`, with the `org.hibernate.cacheable` attribute set to `true`,
    as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: HQL查询的结果也可以被缓存。当您想对主要进行读操作的实体对象执行查询时，这非常有用。使HQL查询可缓存的简单方法是在`@NamedQuery`中添加一个`@javax.persistence.QueryHint`注解，将`org.hibernate.cacheable`属性设置为`true`，如下所示：
- en: '[PRE23]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'You can easily verify the preceding assertion by turning on SQL logging in
    your `application.properties` file, as shown here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在`application.properties`文件中开启SQL日志来轻松验证前面的断言，如下所示：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, if you run the application, you should be able to see a **single** SQL
    statement you can use to query the `Customer` list in the console, no matter how
    many times you have requested the page:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果您运行应用程序，您应该能够在控制台中看到一条**单个**SQL语句，无论您请求页面多少次，都可以用它来查询`Customer`列表：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Great! You have reached the first milestone, that is, running the application
    on your local filesystem and caching frequently used SQL statements in Hibernate
    ORM's **second-level cache** (**2LC**). Now, it's time to take our application
    to the cloud!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！您已经达到了第一个里程碑，即在本地文件系统上运行应用程序，并在Hibernate ORM的**二级缓存**（**2LC**）中缓存常用SQL语句。现在，是时候将我们的应用程序迁移到云端了！
- en: Taking an application to the cloud
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用程序迁移到云端
- en: 'Having tested the application through the local JVM, it''s time to bring it
    natively into the cloud. The interesting part of this process will be connecting
    the Quarkus application with the PostgreSQL application on OpenShift without touching
    even one line of code! Let''s look at how we can achieve this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过本地 JVM 测试了应用程序之后，现在是时候将其原生地引入云中了。这个过程有趣的部分将是将 Quarkus 应用程序与 OpenShift 上的
    PostgreSQL 应用程序连接起来，而无需修改任何一行代码！让我们看看我们如何实现这一点：
- en: 'Start your Minishift instance and create a new project named `quarkus-hibernate`:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动你的 Minishift 实例，并创建一个名为 `quarkus-hibernate` 的新项目：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will be adding a PostgreSQL application to our project. A PostgreSQL
    image stream is included in the `openshift` namespace by default, which you can
    check with the following command:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将向我们的项目中添加一个 PostgreSQL 应用程序。默认情况下，`openshift` 命名空间中包含一个 PostgreSQL 镜像流，你可以使用以下命令进行检查：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You should see the following output in your console:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在控制台中看到以下输出：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To create the PostgreSQL application, the following configuration variables
    need to be set:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 PostgreSQL 应用程序，需要设置以下配置变量：
- en: '`POSTGRESQL_USER`: Username for the PostgreSQL account to be created'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRESQL_USER`：要创建的 PostgreSQL 账户的用户名'
- en: '`POSTGRESQL_PASSWORD`: Password for the user account'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRESQL_PASSWORD`：用户账户的密码'
- en: '`POSTGRESQL_DATABASE`: Database name'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POSTGRESQL_DATABASE`：数据库名称'
- en: 'We will be using the same parameters we defined in the `application.properties`
    file so that we can bootstrap our application with the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在 `application.properties` 文件中定义的相同参数，以便我们可以使用以下命令启动我们的应用程序：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In your console logs, check that the following output has been produced:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的控制台日志中，检查以下输出是否已生成：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Let''s take a look at the list of available services (`oc get services`) to
    verify whether `postgresql` is available:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看可用的服务列表（`oc get services`），以验证 `postgresql` 是否可用：
- en: '[PRE31]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the service is now active at the cluster IP address `172.30.154.130`.
    Luckily, we don't need to hardcode this address in our application code since
    we will be using the service name, `postgresql`, which works like an alias of
    the cluster address.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，服务现在在集群 IP 地址 `172.30.154.130` 上处于活动状态。幸运的是，我们不需要在我们的应用程序代码中硬编码此地址，因为我们将会使用服务名称
    `postgresql`，它就像集群地址的别名一样工作。
- en: 'Now, we will create a binary build of our project so that it can be deployed
    into Minishift. Impatient users can just execute the `deploy-openshift.sh` script,
    which is available on GitHub in the root folder of this chapter. Within it, you
    will find the following commented list of commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们项目的二进制构建，以便它可以部署到 Minishift。对于没有耐心的用户，可以直接执行 GitHub 上此章节根目录中的 `deploy-openshift.sh`
    脚本。在其中，你可以找到以下带注释的命令列表：
- en: '[PRE32]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'At the end of this process, you should be able to see the following route available
    through the `oc get routes` command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在此过程结束时，你应该能够通过 `oc get routes` 命令看到以下路由可用：
- en: '[PRE33]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The overall status of the applications can be also checked from the web console
    of your project:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你项目的网络控制台中检查应用程序的整体状态：
- en: '![](img/0d455dab-3759-4c8c-b958-4b76759df252.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d455dab-3759-4c8c-b958-4b76759df252.png)'
- en: You can now navigate to the external route of the application (the actual route
    address will vary, depending on your network configuration. In our example, it's
    http://quarkus-hibernate-quarkus-hibernate.192.168.42.30.nip.io) and check that
    the application works smoothly on the cloud.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以导航到应用程序的外部路由（实际的路由地址将根据你的网络配置而变化。在我们的例子中，是 http://quarkus-hibernate-quarkus-hibernate.192.168.42.30.nip.io），并检查应用程序在云上是否运行顺畅。
- en: Making data persistence easier using Panache API
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Panache API 使数据持久性更容易
- en: Hibernate ORM is the standard way to map database structures into Java objects.
    The main downside of using an ORM tool is that even a simple database structure
    requires lots of boilerplate code (such as getter and setters methods). Also,
    you have to include basic query methods in your repository classes, which makes
    the work quite repetitive. In this section, we will learn how to use Hibernate
    Panache to simplify and accelerate the development of our applications.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Hibernate ORM 是将数据库结构映射到 Java 对象的标准方式。使用 ORM 工具的主要缺点是，即使是简单的数据库结构也需要大量的样板代码（例如
    getter 和 setter 方法）。此外，你必须在你的仓库类中包含基本的查询方法，这使得工作相当重复。在本节中，我们将学习如何使用 Hibernate
    Panache 来简化并加速我们应用程序的开发。
- en: To get started with Hibernate ORM with Panache, let's check the second example
    for this chapter, which is located in the `Chapter05/hibernate-panache` folder
    in this book's GitHub repository. We recommend importing the project into your
    IDE before you move on.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用带有Panache的Hibernate ORM，让我们检查本章的第二个示例，该示例位于本书GitHub存储库的`Chapter05/hibernate-panache`文件夹中。我们建议在继续之前将项目导入到你的IDE中。
- en: 'If you take a look at the project''s configuration, you will see that we have
    included `quarkus-hibernate-orm-panache` in the `pom.xml` file:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看项目的配置，你会看到我们在`pom.xml`文件中包含了`quarkus-hibernate-orm-panache`：
- en: '[PRE34]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This is the only configuration that we need to use Hibernate Panache. Now comes
    the funny part. There are two strategies for plugging Panache into your entity:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们需要使用的唯一Hibernate Panache配置。现在到了有趣的部分。将Panache连接到你的实体的策略有两种：
- en: 'Extending the `io.quarkus.hibernate.orm.panache.PanacheEntity` class: This
    is the simplest option as you will get an ID field that is auto-generated.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`io.quarkus.hibernate.orm.panache.PanacheEntity`类：这是最简单的方法，因为你将获得一个自动生成的ID字段。
- en: 'Extending `io.quarkus.hibernate.orm.panache.PanacheEntityBase`: This option
    can be used if you require a custom ID strategy.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展`io.quarkus.hibernate.orm.panache.PanacheEntityBase`：如果你需要自定义ID策略，可以使用此选项。
- en: 'Since we are using a `SequenceGenerator` strategy for our ID field, we will
    use the latter option. Following is the `Customer` class, which has been rewritten
    so that it extends `PanacheEntityBase`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为ID字段使用`SequenceGenerator`策略，我们将使用后者选项。以下是被重写的`Customer`类，它扩展了`PanacheEntityBase`：
- en: '[PRE35]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As you can see, the code has been reduced quite a lot as we haven''t used a
    getter/setter field. Instead, some fields have been exposed as `public` so that
    they can be accessed directly by the classes. The `Orders` entity has been rewritten
    using the same pattern:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，代码已经大大减少，因为我们没有使用getter/setter字段。相反，一些字段已被公开为`public`，以便可以直接由类访问。`Orders`实体已经使用相同的模式重写：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'So far, we have seen some of the benefits that are provided by Hibernate Panache.
    Another aspect worth mentioning is that by extending `PanacheEntityBase` (or `PanacheEntity`),
    you will be able to use a set of static methods directly on your entity. Following
    is a table containing the most common methods you can trigger on your entity:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了Hibernate Panache提供的某些好处。另一个值得注意的方面是，通过扩展`PanacheEntityBase`（或`PanacheEntity`），你将能够直接在你的实体上使用一组静态方法。以下是一个包含你可以在实体上触发的最常见方法的表格：
- en: '| **Method** | **Description** |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **描述** |'
- en: '| `count` | Counts this entity from the database (with an optional query and
    parameters) |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 从数据库中计算此实体（可选查询和参数）的数量 |'
- en: '| `delete` | Delete this entity from the database if it has already been persisted.
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 如果该实体已经持久化，则从数据库中删除此实体。 |'
- en: '| `flush` | Flushes all pending changes to the database |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| `flush` | 将所有挂起的更改刷新到数据库 |'
- en: '| `findById` | Finds an entity of this type by ID |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| `findById` | 通过ID查找此类型的实体 |'
- en: '| `find` | Finds entities using a query with optional parameters and a sort
    strategy |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| `find` | 使用可选参数和排序策略的查询查找实体 |'
- en: '| `findAll` | Finds all the entities of this type |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `findAll` | 查找此类型的所有实体 |'
- en: '| `list` | Shortcut for `find().list()` |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `list` | `find().list()`的快捷方式 |'
- en: '| `listAll` | Shortcut for `findAll().list()` |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `listAll` | `findAll().list()`的快捷方式 |'
- en: '| `deleteAll` | Deletes all the entities of this type |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `deleteAll` | 删除此类型的所有实体 |'
- en: '| `delete` | Deletes entities using a query with optional parameters |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `delete` | 使用可选参数的查询删除实体 |'
- en: '| `persist` | Persists all given entities |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `persist` | 持久化所有给定实体 |'
- en: 'The following shows the `CustomerRepository` class, which leverages the new
    field and methods that are available in the `Customer` entity:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例显示了利用`Customer`实体中可用的新字段和方法的重写的`CustomerRepository`类：
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The most obvious advantage is that you don't need `EntityManager` as a proxy
    to manage your entity class anymore. Instead, you can directly invoke static methods
    that are available in your entity, thus dramatically reducing the verbosity of
    your `Repository` class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 最明显的优势是，你不再需要`EntityManager`作为代理来管理你的实体类。相反，你可以直接调用实体中可用的静态方法，从而大大减少`Repository`类的冗长性。
- en: 'For the sake of completeness, let''s have a look at the `OrderRepository` class,
    which has been adapted to use Panache objects as well:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们看看`OrderRepository`类，它已经被修改为使用Panache对象：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Nothing else has been changed in your application since switching to Hibernate
    Panache is completely transparent for our REST endpoint and the web interfaces.
    Build and run the application as usual with the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 自从切换到Hibernate Panache以来，您的应用程序在REST端点和Web界面方面完全透明，没有任何其他更改。使用以下命令按常规构建和运行应用程序：
- en: '[PRE39]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'On the console, you should see that the application has started and the two
    initial customers have been added:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制台上，您应该看到应用程序已启动，并且已添加了两个初始客户：
- en: '[PRE40]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now, enjoy your simplified CRUD application powered by Hibernate ORM with Panache!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，享受由Hibernate ORM和Panache驱动的简化CRUD应用程序吧！
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at data persistence and covered the well-known Hibernate
    ORM framework. If you have some years' Enterprise programming under your belt,
    you shouldn't have found it challenging to apply the same concepts to Quarkus.
    Now, your overall skills include configuring an RDBMS-based application using
    Hibernate and its simplified paradigm called Panache. We have also learned how
    to deploy and connect both RDBMS and our application on the cloud on an OpenShift
    cluster.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了数据持久性，并介绍了广为人知的Hibernate ORM框架。如果您在企业编程方面有一些年的经验，您应该不会觉得将相同的概念应用到Quarkus上有挑战性。现在，您的整体技能包括使用Hibernate及其简化的范式Panache配置基于RDBMS的应用程序。我们还学习了如何在OpenShift集群上部署和连接RDBMS以及我们的应用程序。
- en: To summarize, we have mastered the major pillars of Enterprise programming (moving
    from REST services to servlets, CDI, and data persistence).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，我们已经掌握了企业编程的主要支柱（从REST服务到servlets、CDI和数据持久性）。
- en: In the next chapter, we'll learn how we can complement the standard Enterprise
    API with the MicroProfile API in Quarkus.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何在Quarkus中用MicroProfile API补充标准企业API。
