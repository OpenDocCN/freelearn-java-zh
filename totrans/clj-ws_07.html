<html><head></head><body>
		<div>
			<div id="_idContainer073" class="Content">
			</div>
		</div>
		<div id="_idContainer074" class="Content">
			<h1 id="_idParaDest-151"><a id="_idTextAnchor169"/>7. Recursion II: Lazy Sequences</h1>
		</div>
		<div id="_idContainer084" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, as we continue our exploration of recursive techniques, we will focus on lazy evaluation. We will write functions that safely produce potentially infinite lazy sequences, use lazy evaluation to consume linear data, produce lazily evaluated tree structures from linear data, and write functions that consume tree structures. </p>
			<p class="callout">By the end of this chapter, you will be able to think about new ways of understanding and solving problems.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor170"/>Introduction</h1>
			<p>At its simplest, a <strong class="bold">lazy sequence</strong> is a hybrid of two things:</p>
			<ul>
				<li>A <em class="italic">list</em> (not a vector!) of zero or more items</li>
				<li>A <em class="italic">reference</em> to possible future items of the list that can be computed if necessary</li>
			</ul>
			<p>In other words, there's a real part and a virtual part. Most of the time, you don't need to think about this distinction. That's the whole point of lazy sequences: the virtual part becomes real when you need it, if you need it. When you can stay away from the edge cases, you don't need to worry about the virtual part because as soon as it's needed, it will become real.</p>
			<p>Over the last few chapters, we've already used lazy sequences in many different ways. They are an important, distinctive feature of Clojure and they are something that you'll use every day as a Clojure programmer. You've seen by now that they are list-like structures with a twist: while you are using the first elements of the list, the rest of the list may not exist during runtime. Remember that in a lazy sequence, the individual items are not computed until they are needed. Or, to use the vocabulary of Clojure, they are not realized until they are consumed. You can define a potentially infinite lazy sequence and then only use, and compute, the first three items.</p>
			<p>Up to now, the lazy sequences we've used were returned by core Clojure functions, such as <strong class="source-inline">iterate</strong>, which we looked at briefly in <em class="italic">Chapter 6</em>, <em class="italic">Recursion and Looping</em>, or familiar functions such as <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong>, which we saw in <em class="italic">Chapter 4</em>, <em class="italic">Mapping and Filtering</em>. The next step forward in this path is learning to write your own functions to produce lazy sequences.</p>
			<p>When working in Clojure, lazy sequences are used all the time, as you've already seen by now. Writing functions to build your own lazy sequences is an advanced step and is more prone to errors. It should be considered the final option when dealing with sequences. Here is a rough guide to when deciding which techniques to use for solving a sequence-related problem: </p>
			<ul>
				<li><strong class="bold">Option 1</strong>: Often, functions such as <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">remove</strong> that accept and return sequences will be all you need when working with sequential data.</li>
				<li><strong class="bold">Option 2</strong>: Sometimes, it will be necessary to combine the techniques in option 1 with <strong class="source-inline">reduce</strong>, because your calculation needs to take into account the relationships between items in your data, or because you need to produce an aggregate result.</li>
				<li><strong class="bold">Option 3</strong>: In a much smaller number of cases, you'll need to use some form of recursion, either because you need to customize the iteration (<strong class="source-inline">recur</strong>), or because your data is non-linear, such as a <strong class="source-inline">tree</strong> or a <strong class="source-inline">graph</strong>.</li>
				<li><strong class="bold">Option 4</strong>: In a subset of the cases in <em class="italic">Option 3</em>, the input data is extremely vast, or your calculation produces too many branches. The result is a blown call stack. In such cases, lazy sequences are a solution.</li>
			</ul>
			<p>Each step down this list incurs a higher cost in terms of programmer effort and code complexity. When you stay closer to the beginning of the list, Clojure provides more help and protection from potential mistakes. As you move further down the list, you have to pay more attention to how you implement your solution. Part of being an effective Clojure developer is knowing how to avoid options 3 and 4 when you can, and then using them effectively when you really need to. For certain kinds of problems, such as parsing deeply nested data structures, lazy sequences are a very good fit, and may be the only practical solution in Clojure. That's why it's an important skill to have. There is another benefit too. Knowing how lazy sequences are produced will give you a deeper understanding of how they work.</p>
			<p>In this chapter, we will start by using lazy sequences to deal with linear data before moving on to more complex tree structures. </p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor171"/>A Simple Lazy Sequence</h1>
			<p>To start with, let's consider the simplest possible producer of lazy sequences, the <strong class="source-inline">range</strong> function, which simply returns a possibly infinite series of consecutive integers. The easiest way to write this is to use <strong class="source-inline">iterate</strong>:</p>
			<p class="source-code">(defn iterate-range [] (iterate inc 0))</p>
			<p>Here, <strong class="source-inline">iterate</strong> returns a sequence that starts with the initializer value, zero, and then continues with the result of calling <strong class="source-inline">inc</strong> on zero, then on the result of that and so on. Each intermediate value becomes an item in the returned lazy sequence. It works just fine:</p>
			<p class="source-code">user&gt; (take 5 (iterate-range))</p>
			<p class="source-code">(0 1 2 3 4)</p>
			<p>The <strong class="source-inline">iterate</strong> function is doing all the work. We could stop here, but we wouldn't have learned much about how lazy sequences are built. Here's a more low-level version that performs the same task. It uses the <strong class="source-inline">lazy-seq</strong> macro, which is the base of all lazy sequences:</p>
			<p class="source-code">user&gt; (defn our-range [n]</p>
			<p class="source-code">        (lazy-seq</p>
			<p class="source-code">          (cons n (our-range (inc n)))))</p>
			<p class="source-code">#'user/our-range</p>
			<p>This function might look strange to you. We're going to break it down in detail. Before we do that, let's make sure it works:</p>
			<p class="source-code">user&gt; (take 5 (our-range 0))</p>
			<p class="source-code">(0 1 2 3 4)</p>
			<p>There are three things that stand out here.</p>
			<ul>
				<li>The use of <strong class="source-inline">lazy-seq</strong>. This is what makes the "magic" happen. Notice that <strong class="source-inline">lazy-seq</strong> wraps the entire body of the function.</li>
				<li>The use of <strong class="source-inline">cons</strong>. The name of the <strong class="source-inline">cons</strong> function goes back to Lisp, which is much, much older than Clojure. <strong class="source-inline">cons</strong> is a function that connects two things. In most Lisp dialects, a list is constructed by using <strong class="source-inline">cons</strong> to connect an item to the rest of the list. Using <strong class="source-inline">cons</strong> here means that we are returning a list like this.</li>
				<li>The use of recursion. Without <strong class="source-inline">lazy-seq</strong>, this recursive call would execute immediately, and continuously, until the stack blew up. With <strong class="source-inline">lazy-seq</strong>, the next call does not happen; instead, a reference to that future call is returned.</li>
			</ul>
			<p>The structure of the function mirrors the data structure that it produces:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B14502_07_01.jpg" alt="Figure 7.1: Structure of functions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: Structure of functions</p>
			<p>Thanks to <strong class="source-inline">lazy-seq</strong>, the recursive call becomes a reference.</p>
			<p>On the left, we have the real part; on the right, the virtual part. As the sequence is consumed, more and more virtual calls to <strong class="source-inline">our-range</strong> become real. The reference to further virtual calls remains at the end of the list, ready when more integers are needed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The future, unrealized calculation is often called a <strong class="source-inline">thunk</strong>. The word makes it sound like something that has already been thought, but it is something that hasn't been "<strong class="source-inline">thunk</strong>" yet.</p>
			<p>This is just about the simplest possible version of a lazy sequence, but it is enough to provide an idea of the basic pattern that we will continue to expand upon.</p>
			<h2 id="_idParaDest-154">C<a id="_idTextAnchor172"/>onsuming a Sequence</h2>
			<p>An iterative sequence such as <strong class="source-inline">our-range</strong> takes a single input and builds a sequence by calling a function on the input, then on the result of the first function call, then on the result of that call, and so on. While this kind of computation can be useful sometimes, more often than not our code needs to accept incoming data of some kind.</p>
			<p>The pattern for doing this is a blend of the iterative style of lazy sequence and the recursive functions from the previous chapter. As with other forms of recursion, these functions will be built around conditionals, <strong class="source-inline">if</strong> or <strong class="source-inline">cond</strong> usually, and they will advance through the input sequence by working on the first item and then calling themselves again on the rest of the input. And like <strong class="source-inline">our-range</strong>, they will generally build their output with <strong class="source-inline">cons</strong>, attaching the current item onto a list that points to future possible calculations.</p>
			<h2 id="_idParaDest-155">E<a id="_idTextAnchor173"/>xercise 7.01: Finding Inflection Points</h2>
			<p>In this exercise, we are building a tool to analyze data from users' GPS watches. Runners and hikers want to know how much of the time they are going uphill or downhill. The incoming data is a potentially endless sequence of tuples containing an elevation in meters, and a timestamp, the number of milliseconds since the user started their exercise.</p>
			<p>Each tuple looks as follows:</p>
			<p class="source-code">[24.2 420031]</p>
			<p>We need to iterate through the input sequence looking for local peaks or valleys, that is, the points where the elevation is greater than the preceding and following points (peak), or less than the preceding and following points (valley). We could use <strong class="source-inline">reduce</strong> instead, as we did for the bicycle race problem in <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>. However, the input stream might be very, very long, so we don't want to force evaluation, which is what would happen with <strong class="source-inline">reduce</strong>.</p>
			<ol>
				<li>Define some sample data in the required format. You can find this var at <a href="https://packt.live/2Rhcbu6">https://packt.live/2Rhcbu6</a>:<p class="source-code">(def sample-data</p><p class="source-code">  [[24.2 420031]</p><p class="source-code">   [25.8 492657]</p><p class="source-code">   [25.9 589014]</p><p class="source-code">   [23.8 691995]</p><p class="source-code">   [24.7 734902]</p><p class="source-code">   [23.2 794243]</p><p class="source-code">   [23.1 836204]</p><p class="source-code">   [23.5 884120]])</p></li>
				<li>A peak or a valley can be detected by comparing three consecutive items. Write a predicate for detecting peaks or valleys.<p>As we move through the list of elevation-time tuples, we will look at the current item and the next two items in order to identify peaks and valleys. In a sub-sequence of three items, if the middle item is greater than the first and the last, it's a peak; if it is less than both, it is a valley. In all other cases, the middle item is neither a peak nor a valley. We'll write two functions, <strong class="source-inline">local-max?</strong> and <strong class="source-inline">local-min?</strong>, which will translate this logic into functions:</p><p class="source-code">(defn local-max? [[a b c]]</p><p class="source-code">  (and (&lt; (first a) (first b)) (&lt; (first c) (first b))))</p><p class="source-code">(defn local-min? [[a b c]]</p><p class="source-code">  (and (&gt; (first a) (first b)) (&gt; (first c) (first b))))</p><p>If we wanted to clean up our code with some destructuring, we could avoid all those <strong class="source-inline">first</strong> calls. The functions would take a single, three-item list. Each item is a two-item tuple. With two levels of destructuring, we can extract the elements we need without calling any functions:</p><p class="source-code">(defn local-max? [[[a _] [b _] [c _]]]</p><p class="source-code">  (and (&lt; a b) (&lt; c b)))</p><p class="source-code">(defn local-min? [[[a _] [b _] [c _]]]</p><p class="source-code">  (and (&gt; a b) (&gt; c b)))</p><p class="callout-heading">Note</p><p class="callout">As with many minor stylistic optimizations like this, the important thing is to use the one that you think is the easiest to understand. Clojure's destructuring will seem more and more intuitive as you learn the language, but there's nothing wrong with repeating <strong class="source-inline">first</strong> several times if it makes more sense to you. </p><p>We can already test these on the sample data. The first three values are <strong class="source-inline">[24.2 420031]</strong>, <strong class="source-inline">[25.8 492657]</strong>, and <strong class="source-inline">[25.9 589014]</strong>. Each value is greater than the next so we don't expect this to be either a peak or a valley:</p><p class="source-code">user&gt; (local-max? (take 3 sample-data))</p><p class="source-code">false</p><p class="source-code">user&gt; (local-min? (take 3 sample-data))</p><p class="source-code">false</p><p>If we move forward by two items in <strong class="source-inline">sample-data</strong>, we find a valley. The third, fourth, and fifth items are <strong class="source-inline">[25.9 589014]</strong>, <strong class="source-inline">[23.8 691995]</strong>, and <strong class="source-inline">[24.7 734902]</strong>. The middle value is less than the first and last:</p><p class="source-code">user&gt; (local-min? (take 3 (drop 2 sample-data)))</p><p class="source-code">true</p></li>
				<li>Outline the recursive function. As we discussed, our function will have the same basic shape as most of the recursive functions we've seen so far. For our conditional, there are four cases we need to deal with. Before that, though, we must create a local binding to <strong class="source-inline">current-series</strong>, which will be the first three items in <strong class="source-inline">data</strong>.<p>Since we are just laying out the function, we will return different keywords instead of real values for the moment:</p><p class="source-code">(defn inflection-points [data]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    (let [current-series (take 3 data)]</p><p class="source-code">      (cond (&lt; (count current-series) 3)</p><p class="source-code">            :no-more-data-so-stop</p><p class="source-code">            (local-max? current-series)</p><p class="source-code">            :peak</p><p class="source-code">            (local-min? current-series)</p><p class="source-code">            :valley</p><p class="source-code">            :otherwise</p><p class="source-code">            :neither-so-keep-moving))))</p><p>In the first test in the <strong class="source-inline">cond</strong> expression, we check to see whether we've run out of data, which we can do by checking the length of <strong class="source-inline">current-series</strong>. If <strong class="source-inline">current-series</strong> does not contain three items, then we know that we'll never find a peak or a valley, so it's time to stop. As usual, we place this condition first so that in the subsequent tests we can be sure to have at least some data. The next two tests use the predicates we defined earlier: <strong class="source-inline">local-max?</strong> and <strong class="source-inline">local-min?</strong>. In these cases, we will add the current value to the accumulated <strong class="source-inline">data</strong>. The last possibility is that the current item is neither a minimum nor a maximum. In this case, we aren't interested in that particular item, so we will continue without placing it in the accumulated data.</p></li>
				<li>Now we can start deciding what will happen in each of these four cases. The first case, when we've run out of data, is the simplest, but perhaps the most surprising as well. Here, we just return an empty list:<p class="source-code">(&lt; (count current-series) 3)</p><p class="source-code">'()</p><p>With <strong class="source-inline">recur</strong> based recursion, this wouldn't make any sense: returning an empty list on reaching the end of the input data would mean that the function always returns… an empty list. Not very useful, really. </p><p>With a lazy sequence, however, this last item is simply the end of the list that will be returned. In many cases, the entire list will not be consumed, and the end of the input sequence will never be reached. If we think of a lazy sequence as a series of pointers toward potential calculations, the empty list here is simply the result of the very last potential calculation.</p><p>It is also important that this be an empty list, and not, for example, an empty vector. Vectors are do not support laziness.</p></li>
				<li>The next two cases are where <strong class="source-inline">local-max?</strong> or <strong class="source-inline">local-min?</strong> have decided that the second item in <strong class="source-inline">current-series</strong> is indeed a peak or a valley. When that happens, we need to do two things. First, we need to mark the tuple as either a peak or a valley by appending the appropriate keyword; secondly, we need to make sure that the tuple becomes part of the output sequence. <p>Appending the keyword is easy:</p><p class="source-code">(conj (second current-series) :peak)</p><p>Since each item is a two-value tuple, <strong class="source-inline">conj</strong> will make it into a three-value tuple:</p><p class="source-code">[24.7 734902 :peak]</p><p class="callout-heading">Note</p><p class="callout">When using <strong class="source-inline">conj</strong>, always be careful of what type of sequence you are using. When called on a vector, <strong class="source-inline">conj</strong> will append the new item to the end of the vector. When called on a list, it will append to the beginning. This may seem surprising, but there is a reason: <strong class="source-inline">conj</strong> always adds the new item in the most efficient way possible, depending on the data structure used. For vectors, this means adding to the end; for lists, this means adding to the beginning.</p></li>
				<li>Next, we need to incorporate this new value into the sequence that will be returned. Rather than placing it in an accumulator of some kind, as we might if we were using <strong class="source-inline">recur</strong>, the current item becomes the head of the list of all the remaining items to be calculated. This is what the <strong class="source-inline">cons</strong> function does. And that "list of all the remaining items to be calculated" is represented here as the recursive call to <strong class="source-inline">inflection-points</strong>:<p class="source-code">(local-max? current-series)</p><p class="source-code">(cons</p><p class="source-code">  (conj (second current-series) :peak)</p><p class="source-code">  (inflection-points (rest data)))</p><p class="source-code">(local-min? current-series)</p><p class="source-code">(cons</p><p class="source-code">  (conj (second current-series) :valley)</p><p class="source-code">  (inflection-points (rest data)))</p><p>Think of it this way. To the right, you have all the remaining items. The call to <strong class="source-inline">inflection-points</strong> is going to return them, eventually, or at least potentially. The current item, like we said, is the head of that list. To the left, there are the items that have already been calculated. The last one of those, just to the left of the current item, is going to be the head of a list where the second item is the current item. And so on, all the way to the start of the list. An item is linked to the right by calling a function, and to the left because a function is being called on it.</p><p class="callout-heading">Note</p><p class="callout">Recursion can be hard to grasp. Don't worry! It will get easier with practice.</p><p>When using <strong class="source-inline">recur</strong>, we tend to place the results in an argument to the next call to the recursive function. And we will be doing that with the <strong class="source-inline">current-series</strong> parameter. Because this function will return a lazy sequence, we'll use <strong class="source-inline">cons</strong> and place the current item in front of the potential result set. Each call to the function returns part of a list that the parent call can integrate into what it returns.</p></li>
				<li>The last condition is the least interesting: ignore the current item and move on to the next. We do this in the now-familiar way of removing one item from data in the next recursive call to <strong class="source-inline">inflection-points</strong>:<p class="source-code"> :otherwise</p><p class="source-code">(inflection-points (rest data))</p><p>Here's the complete function:</p><p class="source-code"> (defn inflection-points [data]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    (let [current-series (take 3 data)]</p><p class="source-code">      (cond (&lt; (count current-series) 3)</p><p class="source-code">            '()</p><p class="source-code">            (local-max? current-series)</p><p class="source-code">            (cons</p><p class="source-code">              (conj (second current-series) :peak)</p><p class="source-code">              (inflection-points (rest data)))</p><p class="source-code">            (local-min? current-series)</p><p class="source-code">            (cons</p><p class="source-code">              (conj (second current-series) :valley)</p><p class="source-code">              (inflection-points (rest data)))</p><p class="source-code">            :otherwise</p><p class="source-code">            (inflection-points (rest data))))))</p></li>
				<li>Test the function using the <strong class="source-inline">sample-data</strong> var we defined at the beginning:<p class="source-code">user&gt; (inflection-points sample-data)</p><p class="source-code">([25.9 589014 :peak]</p><p class="source-code"> [23.8 691995 :valley]</p><p class="source-code"> [24.7 734902 :peak]</p><p class="source-code"> [23.1 836204 :valley])</p></li>
				<li>Use Clojure's <strong class="source-inline">cycle</strong> function to transform <strong class="source-inline">sample-data</strong> into a circuit that our jogger runs over and over again:<p class="source-code">user&gt; (take 15 (inflection-points (cycle sample-data)))</p><p class="source-code">([25.9 589014 :peak]</p><p class="source-code"> [23.8 691995 :valley]</p><p class="source-code"> [24.7 734902 :peak]</p><p class="source-code"> [23.1 836204 :valley]</p><p class="source-code"> [25.9 589014 :peak]</p><p class="source-code"> [23.8 691995 :valley]</p><p class="source-code"> [24.7 734902 :peak]</p><p class="source-code"> [23.1 836204 :valley]</p><p class="source-code"> [25.9 589014 :peak]</p><p class="source-code"> [23.8 691995 :valley]</p><p class="source-code"> [24.7 734902 :peak]</p><p class="source-code"> [23.1 836204 :valley]</p><p class="source-code"> [25.9 589014 :peak]</p><p class="source-code"> [23.8 691995 :valley]</p><p class="source-code"> [24.7 734902 :peak])</p><p class="source-code">It just keeps going and going!</p><p><strong class="source-inline">cycle</strong> returns a lazy sequence that repeats a <strong class="source-inline">seq</strong> forever.</p></li>
			</ol>
			<p>This exercise introduced the fundamental structure that you will find in most functions that produce lazy sequences. Making the current the head of the list of future calculations by using <strong class="source-inline">cons</strong> it onto the next recursive call is lazy sequence recursion in a nutshell. The surrounding code may become more complex as we move forward, but this operation will be the building block of all the lazy sequence-producing functions that we write.</p>
			<h2 id="_idParaDest-156">E<a id="_idTextAnchor174"/>xercise 7.02: Calculating a Running Average</h2>
			<p>To put this into practice, let's imagine a scenario similar to the grocery conveyor belt in the previous chapter. This time, though, we're doing quality control on the potatoes that are delivered to our mega-store. The potatoes are weighed as they pass a gate. We want to keep accepting potatoes as long as the average stays within certain bounds. It's all right to have a few small potatoes, or a few huge ones, as long as most of them are within the limits. If the average gets too high or too low, then something must be wrong, so we'll stop accepting potatoes.</p>
			<ol>
				<li value="1">Start up a fresh REPL.</li>
				<li>First, we need to simulate a potato source. We need to define a randomized potato-generating function. We'll use the same technique for producing an infinite sequence of random values as we did for the grocery store, using <strong class="source-inline">repeatedly</strong> and <strong class="source-inline">rand-int</strong>. In this version, we add <strong class="source-inline">10</strong>, which will act as an extreme minimum potato size. This way our generator will produce potatoes between <strong class="source-inline">10</strong> and <strong class="source-inline">400</strong> grams:<p class="source-code">user&gt; (def endless-potatoes (repeatedly (fn [] (+ 10 (rand-int 390)))))</p><p class="source-code">#'user/endless-potatoes</p></li>
				<li>Test this lazy sequence with <strong class="source-inline">take</strong>. You will naturally get different random numbers:<p class="source-code">user&gt; (take 5 endless-potatoes)</p><p class="source-code">(205 349 97 250 18)</p><p class="source-code">user&gt; (take 10 endless-potatoes)</p><p class="source-code">(205 349 97 250 18 219 68 186 196 68)</p><p>Notice how the first five elements are the same both times. Those items have been realized. New potato generation will only occur when more items are computed further along in the sequence.</p><p>Now we arrive at our first design challenge. We need a way of representing the current average for each item in the list. Beyond just the weight of the current potato, we need the potato count at that point in the sequence and the accumulated weight so far. We could use a three-item tuple to hold those three values. If the fifth potato in the list weighs <strong class="source-inline">200</strong> grams, and the total weight of the first five potatoes was <strong class="source-inline">784</strong>, that potato could be represented like this:</p><p class="source-code">[200 5 784]</p><p>Since we have the item count and the total, this design allows us to easily calculate the average at any point in the sequence. </p></li>
				<li>To find the average after three items, we would take three items from the sequence, if our function returns something like this:<p class="source-code">([59 1 59] [134 2 193] [358 3 551])</p><p>Dividing <strong class="source-inline">551</strong>, the total weight so far, by <strong class="source-inline">3</strong>, the number of potatoes, would give us the current average, which is <strong class="source-inline">179.33333</strong> in this case.</p><p>We have our design, but we still need to implement it. Let's go through our options for selecting a sequence-handling technique. <strong class="source-inline">map</strong> won't work here because we need to accumulate data. The <strong class="source-inline">map</strong> windowing pattern from <em class="italic">Chapter 4</em>, <em class="italic">Mapping and Filtering</em>, sounds like it might do the job, but it cannot accumulate data from one end of the sequence. The "window" is local to a few list items. So then maybe <strong class="source-inline">reduce</strong> is the answer? Unfortunately, <strong class="source-inline">reduce</strong> is not lazy: the entire sequence would be realized immediately. In some cases that would be acceptable, but in this case we don't know how long the input will be.</p><p>That leaves us with recursion. We can't use <strong class="source-inline">recur</strong> for the same reason we can't use <strong class="source-inline">reduce</strong>: we might be processing a nearly infinite stream. That also means that standard recursion without <strong class="source-inline">recur</strong> will blow the stack well before we get through our first ton of potatoes. Therefore, we'll use <strong class="source-inline">lazy-seq</strong> to produce different computations. </p></li>
				<li>Start with a skeleton for a function that returns a lazy sequence, using the <strong class="source-inline">lazy-seq</strong> macro to wrap the contents of the recursive function:<p class="source-code">(defn average-potatoes [prev arrivals]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    ))</p><p>The <strong class="source-inline">prev</strong> parameter will start as an empty vector. We will use it to pass the current total on to the next calculation.</p></li>
				<li>Fill in the contents of the recursive function using the patterns learned in the previous chapter, starting with the conditional that stop the recursion when we've exhausted the input. Unlike functions that are designed to continue infinitely, such as <strong class="source-inline">range</strong>, <strong class="source-inline">average-potatoes</strong> only continues as long as it has input, so we do need to check if there is anything left:<p class="source-code">(defn average-potatoes [prev arrivals]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    (if-not arrivals</p><p class="source-code">      '()</p><p class="source-code">      )))</p><p>Here, we see the same pattern as in the previous exercise. When we reach the end of the list, we return an empty list. </p><p class="callout-heading">Note</p><p class="callout">It would be possible to return <strong class="source-inline">nil</strong> here instead because <strong class="source-inline">cons</strong> treats <strong class="source-inline">nil</strong> here just like the empty list. Try <strong class="source-inline">(cons 5 nil)</strong> in your REPL. The empty list does a better job of telling us what is happening here.</p></li>
				<li>Calculate the current item before performing the recursion. We'll use a <strong class="source-inline">let</strong> binding here because we need the current item twice: once as an item in the list, and once as the <strong class="source-inline">prev</strong> argument that will be the basis for calculating the total weight when we get the next potato:<p class="source-code">(defn average-potatoes [prev arrivals]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    (if-not arrivals</p><p class="source-code">      '()</p><p class="source-code">      (let [[_ n total] prev</p><p class="source-code">            current [(first arrivals)</p><p class="source-code">                      (inc (or n 0))</p><p class="source-code">                      (+ (first arrivals) (or total 0))]]</p><p class="source-code">        ;; TODO: the actual recursion</p><p class="source-code">        ))))</p><p>The first part of the <strong class="source-inline">let</strong> binding uses some destructuring to get the current count and the total so far from the <strong class="source-inline">prev</strong> argument. We don't need the weight of the previous potato since it is already included in the running total, which is why we've used an underscore for that value.</p><p>With the next binding, we build the actual tuple that will become an item in the sequence. The only complexity here is that <strong class="source-inline">n</strong> and <strong class="source-inline">total</strong> might be nil, so we have to check for that and supply <strong class="source-inline">0</strong> if they are. The first item in the tuple is just the weight of the current potato; the second item is the count we'll use calculating the average; the last is the total weight of all the potatoes counted so far.</p></li>
				<li>Add the recursive logic:<p class="source-code">(defn average-potatoes [prev arrivals]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    (if-not arrivals</p><p class="source-code">      '()</p><p class="source-code">      (let [[_ n total] prev</p><p class="source-code">            current [(first arrivals)</p><p class="source-code">                     (inc (or n 0))</p><p class="source-code">                     (+ (first arrivals) (or total 0))]]</p><p class="source-code">        (cons</p><p class="source-code">          current</p><p class="source-code">          (average-potatoes</p><p class="source-code">            current</p><p class="source-code">            (next arrivals)))))))</p><p>All we've done in this last step is attach the current item to the list that will be created by the subsequent recursive calls to <strong class="source-inline">average-potatoes</strong>. We've supplied <strong class="source-inline">current</strong> as the <strong class="source-inline">prev</strong> argument for the next call. </p><p>Note also that we use <strong class="source-inline">next</strong> instead of <strong class="source-inline">rest</strong>: this way, arrivals will be <strong class="source-inline">nil</strong> when we get to the end of the sequence, which is what we are expecting when we test with <strong class="source-inline">if-not</strong> at the beginning of this function. The <strong class="source-inline">next</strong> function is very similar to <strong class="source-inline">rest</strong>, which we used in the previous example. Both functions take a list and return all but the first item of that list. The difference between the two is visible when there are no more items in the list. In that case, <strong class="source-inline">rest</strong> returns an empty list, while <strong class="source-inline">next</strong> returns <strong class="source-inline">nil</strong>. Choosing one or the other depends on the circumstances. The advantage of <strong class="source-inline">next</strong> is that it is easy to test for truthiness as we did here, instead of calling <strong class="source-inline">empty?</strong> as we did with <strong class="source-inline">rest</strong> in the previous exercise. Because <strong class="source-inline">rest</strong> never returns <strong class="source-inline">nil</strong>, there is no risk of a null pointer exception. </p></li>
				<li>Test your new lazy function. Let's start by looking at a few individual items:<p class="source-code">user&gt; (take 3 (average-potatoes '() endless-potatoes))</p><p class="source-code">([321 1 321] [338 2 659] [318 3 977])</p><p>The third element of each tuple correctly indicates the accumulated weight. That part seems correct.</p><p>Now let's try working with a large number of items. We'll take the last element from a long list of potatoes:</p><p class="source-code">user&gt; (last (take 500000 (average-potatoes '() endless-potatoes)))</p><p class="source-code">[43 500000 102132749]</p><p>At <strong class="source-inline">500,000</strong> potatoes, everything seems to still be working as expected. </p></li>
			</ol>
			<p>In this example, it's important to note the difference between the preceding examples of lazy evaluation using <strong class="source-inline">rand-int</strong> and <strong class="source-inline">inc</strong>. With <strong class="source-inline">rand-int</strong>, each call is independent of all the other calls. Lazy evaluation is only useful here because it's useful to have a potentially infinite sequence. With <strong class="source-inline">inc</strong>, when we implemented our version of <strong class="source-inline">range</strong>, the situation is slightly more complex because each call, and thus each item in the sequence, relies on the results of the call before. This is also true of the <strong class="source-inline">average-potatoes</strong> function: each call relies on the total and the count established in the previous call, and it relays this information onto the next call. At the same time, it does something more, because each calculation also consumes an item from the input sequence.</p>
			<p>The core <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong> functions do this as well: their results are no longer than their inputs. This adds one more reason to use write functions that consume and produce lazy sequences: they can be chained together with other lazy functions without forcing evaluation.</p>
			<h2 id="_idParaDest-157">L<a id="_idTextAnchor175"/>azy Consumption of Data</h2>
			<p>Lazy evaluation is an interface that, most of the time, hides from the user whether a calculation has already been performed, or is about to be performed. This is what it means when we say that a lazy sequence contains possibly differed computations. "Possibly," because we don't know, and we don't need to know, whether or not the computation has already happened.</p>
			<p>To be useful though, lazy evaluation has to be passed from one function call to the next. If we pass a lazy sequence to function A, and the result of that to function B, and so on, the evaluation only remains lazy if A and B are designed to return lazy sequences.</p>
			<p>For example, say we have a lazy sequence called <strong class="source-inline">xs</strong>. If it gets passed to <strong class="source-inline">map</strong>, then to <strong class="source-inline">filter</strong>, and then to <strong class="source-inline">take-while</strong>, it will remain "lazy" the whole time. If instead we insert a <strong class="source-inline">reduce</strong> into that chain of function calls, or if we use <strong class="source-inline">mapv</strong> instead of <strong class="source-inline">map</strong>, the laziness disappears.</p>
			<p>In the end, potential evaluation isn't enough. You do actually want some real data at some point! However, there is generally an advantage in preserving laziness until the very end. That means avoiding something like this:</p>
			<p class="source-code">(-&gt;&gt; xs</p>
			<p class="source-code">     (map some-func)</p>
			<p class="source-code">     (reduce some-reducing-func)</p>
			<p class="source-code">     (filter some-predicate?))</p>
			<p>Here, we take some a sequence and use <strong class="source-inline">map</strong> to apply a function to each item. The call to <strong class="source-inline">map</strong> is lazy but the call to <strong class="source-inline">reduce</strong> is not, so the entire sequence is realized. Then some of those results are discarded by <strong class="source-inline">filter</strong>. Depending on what the functions are doing, this may be the only way to write this code. However, ideally, we would try to use <strong class="source-inline">filter</strong> first to narrow the data as much as possible before calling <strong class="source-inline">reduce</strong>, or any other function that does not preserve laziness:</p>
			<p class="source-code">(-&gt;&gt; xs</p>
			<p class="source-code">     (map some-func)</p>
			<p class="source-code">     (filter some-predicate?)</p>
			<p class="source-code">     (take-while another-predicate?)</p>
			<p class="source-code">     (reduce +))</p>
			<p>The first advantage with this pattern is that your code becomes simpler. <strong class="source-inline">filter</strong> and <strong class="source-inline">take-while</strong> may have removed some types of data that the <strong class="source-inline">reduce</strong> call will not need to deal with at all. By waiting until the very last minute before forcing the sequence to be completely realized, there may actually be less computational work to do. </p>
			<p>To see how this might work, let's look at this simple expression:</p>
			<p class="source-code">(nth (filter even? (range)) 3)</p>
			<p>The evaluation starts with <strong class="source-inline">(range)</strong>, which, if <strong class="source-inline">range</strong> were not lazy, would return all the integers from zero to infinity. In other words, CPU usage would go to 100% and evaluation would stop when something broke.</p>
			<p>Instead of that horrible outcome, though, we can imagine the return value of <strong class="source-inline">(range)</strong> as looking something like this:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B14502_07_02.jpg" alt="Figure 7.2: Representation of range value&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: Representation of range value</p>
			<p>An unrealized lazy sequence: a starting point and a pointer to future calculations.</p>
			<p>This is a lot less work than counting from zero to infinity. It's essentially <strong class="source-inline">0</strong> and a pointer toward instructions for calculating the rest of the sequence, if necessary.</p>
			<p>However, we don't want all the integers, just the even ones:</p>
			<p class="source-code">(filter even? (range))</p>
			<p>With this call to <strong class="source-inline">filter</strong>, we've created a second lazy sequence built upon the first:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B14502_07_03.jpg" alt="Figure 7.3: Creating the second lazy sequence&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: Creating the second lazy sequence</p>
			<p>By adding <strong class="source-inline">filter</strong>, we've created a new lazy sequence that still only has one real piece of data.</p>
			<p>The only concrete data we have so far is still zero. All we've done is add to the instructions for getting the rest of the sequence. Everything is still virtual at this point.</p>
			<p>And then, finally, we call <strong class="source-inline">nth</strong> and ask for the fourth item in the sequence:</p>
			<p class="source-code">user&gt; (nth (filter even? (range)) 3)</p>
			<p class="source-code">6</p>
			<p>Now everything changes. We need the real values of the first four items. <strong class="source-inline">nth</strong> causes the first four items of the <strong class="source-inline">filter</strong> sequence to be evaluated. To do this, <strong class="source-inline">filter</strong> needs the first seven items of the <strong class="source-inline">range</strong> sequence to be evaluated. Suddenly, <strong class="source-inline">(range)</strong> looks like this:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B14502_07_04.jpg" alt="Figure 7.4: Current values in the range&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: Current values in the range</p>
			<p>The first seven items are realized. The rest of the sequence is still virtual.</p>
			<p>And <strong class="source-inline">(filter even? (range))</strong> looks as follows:</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B14502_07_05.jpg" alt="Figure 7.5: Filtering even numbers from the range&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: Filtering even numbers from the range</p>
			<p>The fourth value in the list can now be consumed just like any other value.</p>
			<p>The important thing to understand here is this: the last element in each of these sequences is a pointer to further potential calculations. <strong class="source-inline">filter</strong> and <strong class="source-inline">range</strong> worked together to provide just enough data to <strong class="source-inline">nth</strong>, and no more. By passing pointers (or "instructions for future computations") from function to function, the ultimate consumer can send a signal back up the chain, from pointer to pointer, to obtain the necessary data.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Lazy sequences in Clojure are actually implemented as <strong class="bold">chunked sequences</strong>. This is an implementation detail: as an optimization, Clojure sometimes realizes a few more items than are actually necessary. While this is good to know, it should never matter. It just means that you can't count on an item <em class="italic">not</em> being realized.</p>
			<p>The capacity to avoid performing certain calculations until the last millisecond, or to avoid them entirely, is an important feature of lazy computation. There is another aspect that can be equally important: the ability to "forget" some of the calculations that have already been performed.</p>
			<p>Consider a non-lazy Clojure collection, such as a vector. Whatever size the vector is, the entire vector is available in memory at the same time. When the program no longer needs the vector, the platform on which the program is running, the JVM or a JavaScript engine, has a garbage collector that will free up the memory occupied by the vector. But if the program still needs even just one item from that vector, the garbage collector will keep waiting until it can safely reclaim that memory space.</p>
			<p>A lazy sequence behaves in a totally different manner. Instead of being a single entity, it is a series of linked entities, each one referring to the next. As we've seen, this is how a lazy sequence can even reference items that don't exist yet, and maybe never will. There is another important part of the equation, though. Lazy sequences also the first part of the sequence to be garbage collected if it is no longer needed.</p>
			<p>In the last example, we were looking for the fourth even number in the range. Instead, what if we were looking for the seven millionth even number?</p>
			<p class="source-code">user&gt; (nth (filter even? (range)) 7000000)</p>
			<p class="source-code">14000000</p>
			<p>There is no reason, in this situation, to keep a reference to those first 13,999,999 integers that were produced by <strong class="source-inline">(range)</strong>. That means that they can be safely garbage collected.</p>
			<p>This feature of lazy sequences means that they can be used to process datasets that would be too big to fit in the computer's memory all at once. By "forgetting" the first part and not immediately computing the last part, Clojure can process extremely long sequences while using only a fraction of the memory it would take to contain them all at once. There is, however, a limitation.</p>
			<p>If a program maintains a reference to the beginning of a sequence, then it can no longer be garbage collected. Often, this won't matter, but with very long sequences, it becomes an important consideration. Throughout this chapter, you may notice that we often repeat expressions such as <strong class="source-inline">(first my-seq)</strong> inside a function when it might be tempting to use a local <strong class="source-inline">let</strong> binding instead. This is a way of avoiding references that would prevent a sequence from being garbage collected.</p>
			<h1 id="_idParaDest-158">Lazy <a id="_idTextAnchor176"/>Trees</h1>
			<p>So far, we've seen that the "laziness" of lazy sequences is that they can point to future computations that will only be performed if they become necessary. There is another important advantage that is equally important, and that is what we are going to explore now. Remember from <em class="italic">Chapter 6</em>, <em class="italic">Recursion and Looping</em>, how recursive functions in Clojure need to use <strong class="source-inline">recur</strong> to avoid blowing up the stack? And remember how <strong class="source-inline">recur</strong> only works with a specific kind of recursion, tail recursion, where the next call to the recursive function can totally replace the previous call? The problem, you'll recall, is that only a limited number of stack frames are available. The function call on the root node of the tree needs to wait until all the calls have completed on all the child and grandchild and great-grandchild nodes, and so on. Stack frames are a limited resource but the data we need to operate on is often vast. This mismatch is a problem.</p>
			<p>This is where lazy evaluation comes in. With lazy evaluation, Clojure itself handles the link to the next calculation, not the call stack. This way, when we use a recursive function to walk an entire tree, we are no longer trying to use the stack to map the structure of the tree. Instead, the lazy sequence itself does all the work of keeping track of which results need to be returned to which functions.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor177"/>Exercise 7.03: A Tennis History Tree</h2>
			<p>In <a id="_idTextAnchor178"/>this exercise, we return to the world of tennis. As you remember, in <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>, we built a system for establishing Elo ratings for tennis players based on historical data. These predictions have become popular on the sports journalism website you work for. Some readers have asked for more information about Elo predictions. In response to this new interest in your prediction engine, your employer wants the frontend team to build a visualization that shows the evolution of a player's rating over their last few matches. Your job will be to provide the necessary data.</p>
			<p>We can reuse most of the work we did in <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>, for importing the data and generating the ratings. One modification will be necessary, though. In <em class="italic">Chapter 5</em>, <em class="italic">Many to One: Reducing</em>, we were only interested in the final rating. We'll need to modify our previous code to append, line by line, the current ratings for the players in each match.</p>
			<ol>
				<li value="1">Set up a project identical to the one in <em class="italic">Activity 5.01</em>, <em class="italic">Calculating Elo Ratings for Tennis</em> and copy the functions you wrote for the activity into a new file. You'll need <strong class="source-inline">match-probability</strong>, <strong class="source-inline">recalculate-rating</strong>, and <strong class="source-inline">elo-world-simple</strong>. Copy <strong class="source-inline">match_scores_1968-1990_unindexed_csv.csv</strong> from <a href="https://packt.live/36k1o6X">https://packt.live/36k1o6X</a> into the new project as well. The <strong class="source-inline">deps.edn</strong> file looked like this:<p class="source-code">{:paths ["src" "resources"]</p><p class="source-code"> :deps</p><p class="source-code"> {org.clojure/data.csv {:mvn/version "0.1.4"}</p><p class="source-code">  semantic-csv {:mvn/version "0.2.1-alpha1"}</p><p class="source-code">  org.clojure/math.numeric-tower {:mvn/version "0.0.4"}}}</p><p>The namespace declaration should look as follows:</p><p class="source-code">(ns packt-clojure.lazy-tennis</p><p class="source-code">  (:require [clojure.math.numeric-tower :as math]</p><p class="source-code">            [clojure.java.io :as io]</p><p class="source-code">            [clojure.data.csv :as csv]</p><p class="source-code">            [semantic-csv.core :as sc]))</p></li>
				<li>Modify <strong class="source-inline">elo-world-simple</strong> so that each line (each match) is retained and that the ratings of both players are recorded.<p>Adding the ability to store the ratings of players of each match, at the time they played the match, is rather simple. All the changes occur toward the end of the function. Start with the initialization map for the call to <strong class="source-inline">reduce</strong>. </p><p>In <strong class="source-inline">elo-world-simple</strong>, the call to reduce looks like this (without the contents of the reducing function, for brevity):</p><p class="source-code">(reduce (fn [{:keys [players] :as acc} {:keys [winner_name winner_slug</p><p class="source-code">                                               loser_name loser_slug] :as match}]</p><p class="source-code">          ;; TODO: content temporarily unavailable</p><p class="source-code">          )</p><p class="source-code">        {:players {}</p><p class="source-code">         :match-count 0</p><p class="source-code">         :predictable-match-count 0</p><p class="source-code">         :correct-predictions 0})</p></li>
				<li>In the new version, we'll replace the <strong class="source-inline">:match-count</strong> field with a <strong class="source-inline">:matches</strong> field, whose initial value will be an empty vector:<p class="source-code">(reduce (fn [{:keys [players] :as acc} {:keys [winner_name winner_slug</p><p class="source-code">                                               loser_name loser<a id="_idTextAnchor179"/>_slug] :as match}]</p><p class="source-code">          ;; TODO: your content will be restored shortly</p><p class="source-code">          )</p><p class="source-code">        {:players {}</p><p class="source-code">         :matches []})</p></li>
				<li>To count the matches in the <strong class="source-inline">elo-world-simple</strong> version, for each line in the CSV file, we'll simply increment <strong class="source-inline">:match-count field</strong> in the accumulator as follows:<p class="source-code">(-&gt; acc</p><p class="source-code">    ;; TODO: more missing code</p><p class="source-code">    (update :match-count inc))</p></li>
				<li>In this version, we need to append the current match, decorated with the <strong class="source-inline">winner-rating</strong> and the <strong class="source-inline">loser-rating</strong> that have already been calculated, to the growing list of matches. Here's the complete series of modifications made to <strong class="source-inline">acc</strong>. The new part is the anonymous function supplied to <strong class="source-inline">update</strong>:<p class="source-code">(-&gt; acc</p><p class="source-code">    (assoc-in [:players winner_slug] (recalculate-rating k winner-rating winner-probability 1))</p><p class="source-code">    (assoc-in [:players loser_slug] (recalculate-rating k loser-rating loser-probability 0))</p><p class="source-code">    (update :matches (fn [ms]</p><p class="source-code">                       (conj ms (assoc match</p><p class="source-code">                                       :winner_rating winner-rating</p><p class="source-code">                                       :loser_rating loser-rating)))))</p></li>
				<li>Put the function back together again. For clarity, let's rename it <strong class="source-inline">elo-db</strong>. Since we only care about the list of matches, we can remove all the code dedicated to counting the number of correct predictions. Finally, after the call to <strong class="source-inline">reduce</strong>, we'll add two more calls to the <strong class="source-inline">-&gt;</strong> threading macro:<p class="source-code">(-&gt;&gt;</p><p class="source-code">  ;; calls to reduce, etc.</p><p class="source-code">  :matches</p><p class="source-code">  reverse)</p><p>The <strong class="source-inline">:matches</strong> keyword, acting as a function, extracts the list of matches from the map returned by <strong class="source-inline">reduce</strong>. We also need to <strong class="source-inline">reverse</strong> the order of the matches because the queries we intend to run start at the present and go toward the past.</p><p>This gives us the final state of our function:</p><p class="source-code-heading">tennis_history.clj</p><p class="source-code">16 (defn elo-db</p><p class="source-code">17   ([csv k]</p><p class="source-code">18    (with-open [r (io/reader csv)]</p><p class="source-code">19      (-&gt;&gt; (csv/read-csv r)</p><p class="source-code">20           sc/mappify</p><p class="source-code">21           (sc/cast-with {:winner_sets_won sc/-&gt;int</p><p class="source-code">22                          :loser_sets_won sc/-&gt;int</p><p class="source-code">23                          :winner_games_won sc/-&gt;int</p><p class="source-code">24                          :loser_games_won sc/-&gt;int}</p><p class="source-code-link">The full code for this step can be found at <a href="https://packt.live/2GffSKv">https://packt.live/2GffSKv</a></p><p>In the REPL, run this function on the CSV file and store the matches in a var:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (def ratings (elo-db "match_scores_1991-2016_unindexed_csv.csv" 35))</p><p class="source-code">#'packt-clojure.lazy-tennis/db</p><p>We can verify that the ratings are available:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (map #(select-keys % [:winner_rating :loser_rating]) (take 5 ratings))</p><p class="source-code">({:winner_rating 985.2418497337458, :loser_rating 927.9839328429639}</p><p class="source-code"> {:winner_rating 1265.3903009991964, :loser_rating 875.8644912132612}</p><p class="source-code"> {:winner_rating 1012.6267015729657, :loser_rating 969.5966741618663}</p><p class="source-code"> {:winner_rating 1311.801159776237, :loser_rating 1002.1872608853402}</p><p class="source-code"> {:winner_rating 853.6200747439426, :loser_rating 950.2283493122825})</p><p>With this data in place, we're ready to write functions to search for and extract information from it.</p></li>
				<li>Write a function that tests whether a player is either the winner or loser in a given match.<p>We need to be able to skip over the matches we aren't interested in, so this is a common test. Making it into its own predicate function will make our code easier to read. You might recognize the pattern, using a Clojure set, from <em class="italic">Chapter 4</em>, <em class="italic">Mapping and Filtering</em>:</p><p class="source-code">(defn player-in-match? [{:keys [winner_slug loser_slug]} player-slug]</p><p class="source-code">  ((hash-set winner_slug loser_slug) player-slug))</p><p class="callout-heading">Note</p><p class="callout">Previously, we used a literal set. The <strong class="source-inline">hash-set</strong> function does the same thing, but in a more robust way. If <strong class="source-inline">Winner</strong> and <strong class="source-inline">Loser</strong> were identical for some reason, bad data for example, the program would crash. A literal set expects that you will provide a correct set without any duplicate items. The <strong class="source-inline">hash-set</strong> and <strong class="source-inline">set</strong> functions build sets from the arguments they receive and therefore handle duplicates gracefully. <strong class="source-inline">set</strong> takes a collection of items, whereas <strong class="source-inline">hash-set</strong> takes multiple arguments. It's basically <strong class="source-inline">(apply set …)</strong>.</p><p>We can test it in the REPL with some real data from our "database":</p><p class="source-code">packt-clojure.lazy-tennis&gt; (player-in-match? (first ratings) "gael-monfils")</p><p class="source-code">"gael-monfils"</p><p class="source-code">packt-clojure.lazy-tennis&gt; (player-in-match? (first ratings) "boris-becker")</p><p class="source-code">nil</p></li>
				<li>Now we're ready to write our recursive function that will search through the list of matches. Start with a simple skeleton:<p class="source-code">(defn match-tree-by-player [m player-name]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    (cond (empty? m)</p><p class="source-code">          ;; No more matches</p><p class="source-code">          (player-in-match? (first m) player-name)</p><p class="source-code">          ;; Build the tree!</p><p class="source-code">          ::otherwise</p><p class="source-code">          ;; Keep walking through the tree</p><p class="source-code">          )))</p><p>Like all of our recursive functions that consume another sequence, this one is structured around a conditional. Here we have the tests without the corresponding code. All we need to do now is fill in the blanks!</p></li>
				<li>Start with the last condition, when the current match does not contain the player we're looking for.<p>In this case, we forget about the current record and continue moving along the input list, recursively calling <strong class="source-inline">match-tree-by-player</strong> on the remaining items:</p><p class="source-code"> (match-tree-by-player (rest m) player-slug)</p></li>
				<li>Once again, the basic pattern should be somewhat familiar: <strong class="source-inline">cons</strong> will connect the current item—the current match—to the rest of whatever is to be calculated later. This time, however, we have a new problem: we need to continue our search for matches played by the winner and the loser of the current match. That's two separate searches, which means two separate recursive calls to <strong class="source-inline">match-tree-by-player</strong>. Since we have two things, we need to put them into something. A vector is often a good choice in this kind of situation. Here's the code:<p class="source-code">(cons (first ms)</p><p class="source-code">      (cons</p><p class="source-code">        [(match-tree-by-player (rest ms) (:Winner (first ms)))</p><p class="source-code">         (match-tree-by-player (rest ms) (:Loser (first ms)))]</p><p class="source-code">        '()))</p><p>Surprised by that second call to <strong class="source-inline">cons</strong>? It is there because we need to add more than just one item to our output. We add the current match, then the vector that will hold the heads of the two new trees. Inside the vector, the two calls to <strong class="source-inline">match-tree-by-player</strong> will only be made when needed.</p><p>The final <strong class="source-inline">'()</strong> is necessary because <strong class="source-inline">cons</strong> need a collection as a second argument.</p></li>
				<li>Add the code for when <strong class="source-inline">m</strong> is empty.<p>As in the previous example, we provide an empty list so that the lazy sequence can finally end somewhere.</p><p>Now we can see the complete function:</p><p class="source-code">(defn match-tree-by-player [m player-slug]</p><p class="source-code">  (lazy-seq</p><p class="source-code">    (cond (empty? m)</p><p class="source-code">          '()</p><p class="source-code">          (player-in-match?  (first m) player-slug)</p><p class="source-code">          (cons (first m)</p><p class="source-code">                (cons</p><p class="source-code">                  [(match-tree-by-player (rest m) (:winner_slug (first m)))</p><p class="source-code">                   (match-tree-by-player (rest m) (:loser_slug (first m)))]</p><p class="source-code">                  '()))</p><p class="source-code">          ::otherwise</p><p class="source-code">          (match-tree-by-player (rest m) player-slug))))</p></li>
				<li>Test the function. Let's start with a player we know is not in the match records:<p class="source-code">packt-clojure.tennis&gt; (match-tree-by-player ratings "non-tennis-player")</p><p class="source-code">()</p><p>We get an empty list, which is exactly what we want. </p><p>Now let's try a player from the "database" (this is one of those times where you really want to attach the results to a var rather than trying to print everything to your REPL!):</p><p class="source-code">packt-clojure.tennis&gt; (def federer (match-tree-by-player ratings "roger-federer"))</p><p class="source-code">#'packt-clojure.lazy-tennis/federer</p><p class="source-code">packt-clojure.lazy-tennis&gt; (type federer)</p><p class="source-code">clojure.lang.LazySeq</p><p>We can check the first item to see if our data is really there:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (:winner_rating (first federer))</p><p class="source-code">1129.178155312036</p><p>So far so good!</p></li>
			</ol>
			<p>Let's step back and think about what we've created here. If we try to see how many items are in the list, we get this:</p>
			<p class="source-code">packt-clojure.lazy-tennis&gt; (count federer)</p>
			<p class="source-code">2</p>
			<p>That seems strange. We know that Roger Federer has played a lot more matches than that. The <strong class="source-inline">count</strong> function doesn't work as we expect here because it doesn't understand the structure of this hierarchal return value. All <strong class="source-inline">count</strong> can see is the first item, which is one match, <strong class="source-inline">cons</strong> onto a vector. All the other results are nested inside that vector. Each item in the hierarchy shares this same structure. Conceptually, it looks something like this:</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B14502_07_06.jpg" alt="Figure 7.6: A hierarchical data structure where cons arrows contained in the vectors are lazy&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: A hierarchical data structure where cons arrows contained in the vectors are lazy</p>
			<p>In this diagram, the laziness occurs inside the vector. Those two lazy sequences are not yet realized. We can check this by carefully drilling down into the structure:</p>
			<p class="source-code">packt-clojure.lazy-tennis&gt; (realized? (first (second federer)))</p>
			<p class="source-code">false</p>
			<p>This is a good thing, because the entire structure, if realized, would be huge. Really, really huge. Hiding behind the fast response time is a tree that, if fully realized, would end up repeating thousands of times over the data in the original list. Try removing the <strong class="source-inline">lazy-seq</strong> wrapper from inside <strong class="source-inline">match-tree-by-player</strong>. The result will look something like this:</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B14502_07_07.jpg" alt="Figure 7.7: Overflowing the stack—too many recursive calls&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7: Overflowing the stack—too many recursive calls</p>
			<p>Let's look briefly at this error message. Clojure stack traces are not always that easy to read, but this one does contain some interesting information. The most part is the "<strong class="source-inline">Caused by java.lang.stackOverflowError</strong>" statement. That's what caused the compiler exception and stopped our code. Below this, the repeated lines mentioning <strong class="source-inline">match-tree-by-player</strong> are telling us that <strong class="source-inline">match-tree-by-player</strong> kept calling itself over and over again. This is just a small part of the entire stack trace, which goes on and on for several screens. Earlier, we talked about stack frames. Here, each line is a frame. Each call to the function is waiting for the next one to resolve. After a certain point, there are too many functions waiting on one another, and the stack finally overflows.</p>
			<p>Once again, lazy evaluation saves us from this and allows us to traverse data in complex ways and to build, in a few lines of code, very complex data structures.</p>
			<h2 id="_idParaDest-160">Exercis<a id="_idTextAnchor180"/>e 7.04: A Custom take Function</h2>
			<p>The previous exercise gave us a way to extract a tree from our linear dataset. It still doesn't allow you to do what your employer is asking, namely to display a limited tree that shows just a few levels in the hierarchy. Once we have that, we'll be able to as many levels as the design team wants to show.</p>
			<p>What we really need is a specialized version of Clojure's <strong class="source-inline">take</strong> function that understands the structure of our data. We want to be able to write <strong class="source-inline">(take-matches 4 federer)</strong> and get a four-level tree.</p>
			<p>To do this, we need to solve two problems. First, we need to be able to traverse the tree we've created. Secondly, we need a way to count the number of levels we've traversed.</p>
			<ol>
				<li value="1">This exercise builds on the previous one. Use the <strong class="source-inline">tennis_history.clj</strong> files from <a href="https://packt.live/38Dzp3H">https://packt.live/38Dzp3H</a> or make a complete copy. </li>
				<li>Start with a version of the function that only works when called with zero as its first argument:<p class="source-code">(defn take-matches [limit tree]</p><p class="source-code">  (cond (zero? limit)</p><p class="source-code">        '()))</p><p>Check if it works. To do this, you'll need the <strong class="source-inline">federer</strong> var from the previous exercise:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (take-matches 0 federer)</p><p class="source-code">()</p></li>
				<li>Let's add the possibility of asking for either zero or one items:<p class="source-code">(defn take-matches [limit tree]</p><p class="source-code">  (cond (zero? limit)</p><p class="source-code">        '()</p><p class="source-code">        (= 1 limit)</p><p class="source-code">        (first tree)))</p><p>This behavior duplicates our tests in the last exercise. We simply return the first match in the lazy sequence.</p><p>It's still a good idea to test though. We'll use <strong class="source-inline">select-keys</strong> to avoid lots of extra output data:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (select-keys (take-matches 1 federer) [:winner_slug :loser_slug])</p><p class="source-code">{:winner_slug "roger-federer", :loser_slug "guido-pella"}</p></li>
				<li>Add an <strong class="source-inline">:otherwise</strong> condition when the <strong class="source-inline">limit</strong> is more than one:<p class="source-code">(defn take-matches [limit tree]</p><p class="source-code">  (cond (zero? limit)</p><p class="source-code">        '()</p><p class="source-code">        (= 1 limit)</p><p class="source-code">        (first tree)</p><p class="source-code">        :otherwise-continue</p><p class="source-code">        (cons</p><p class="source-code">          (first tree)</p><p class="source-code">          (cons</p><p class="source-code">            [(take-matches (dec limit) (first (second tree)))</p><p class="source-code">             (take-matches (dec limit) (second (second tree)))]</p><p class="source-code">            '()))))</p><p>This part should look familiar, because it mirrors the structure of the function we wrote to build this structure to begin with, with two levels of <strong class="source-inline">cons</strong>, the second of which attaches a vector containing two more calls to <strong class="source-inline">take-matches</strong>.</p><p>By saying <strong class="source-inline">(dec limit)</strong> each time, the future calls to <strong class="source-inline">take-matches</strong> will eventually reach zero and stop traversing the tree.</p></li>
				<li>Test the complete function:<p class="source-code">(take-matches 3 federer)</p><p>The results will be too long to print here because there are so many fields in each match map. They should have this basic structure:</p><p class="source-code">({}</p><p class="source-code"> [({}</p><p class="source-code">   [{} {}])</p><p class="source-code">  ({}</p><p class="source-code">   [{} {}])])</p><p>In the next exercise, we will make it easier to see these results.</p></li>
			</ol>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor181"/>Knowing When to Be Lazy</h2>
			<p>You may have noticed that we did not use <strong class="source-inline">lazy-seq</strong> this time. Should we have? Obviously, it would be easy enough to wrap the function body with the <strong class="source-inline">lazy-seq</strong> macro. Whether we do that or not depends mostly on how and where the <strong class="source-inline">take-matches</strong> function is going to be used inside our application. If <strong class="source-inline">take-matches</strong> is the final step before passing off our data to the frontend, there is no point in making it lazy. We are certain that the data is of a reasonable size and that we need all of it to produce the visual we are going to show. Making the function eager (the opposite of lazy) seems like a good choice in this case.</p>
			<p>On the other hand, if <strong class="source-inline">take-matches</strong> is going to be used for other tasks, then making it lazy might make sense. If, for example, we wanted to extract a larger number of levels and then perform some other kind of operation on the result, the benefits of lazy evaluation might be important.</p>
			<p>We are getting very close to satisfying our employer's requirements. We can retrieve the tree as a lazy sequence and now we can limit how many levels of match history we want to include. Our only remaining problem is that the results are hard to visualize, even in the REPL. We need to be able to format each match map. However, because of the tree structure, we can't just use <strong class="source-inline">map</strong> to transform each match. This is what we'll accomplish in the next exercise.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor182"/>Exercise 7.05: Formatting the Matches</h2>
			<p>We need a way to reach every map in the tree. Rather than writing a specialized <strong class="source-inline">map</strong> function, we'll add an extra argument to <strong class="source-inline">take-matches</strong> that will be called on each match before it is returned. This will allow us to eliminate some of the keys we don't need for presenting the data to users. Likewise, it would be nice to display the ratings as integers rather than floats. We'll also add a feature: since we have the rating for each player before the match, we can also use the <strong class="source-inline">match-probability</strong> function to show the Elo prediction.</p>
			<ol>
				<li value="1">In the same file as the previous exercise (or in a copy of the project), add a function argument to <strong class="source-inline">take-matches</strong> and call it on the matches before they're returned:<p class="source-code">(defn take-matches [limit tree f]</p><p class="source-code">  (cond (zero? limit)</p><p class="source-code">        '()</p><p class="source-code">        (= 1 limit)</p><p class="source-code">        (f (first tree))</p><p class="source-code">        :otherwise-continue</p><p class="source-code">        (cons</p><p class="source-code">          (f (first tree))</p><p class="source-code">          (cons</p><p class="source-code">            [(take-matches (dec limit) (first (second tree)) f)</p><p class="source-code">             (take-matches (dec limit) (second (second tree)) f)]</p><p class="source-code">            '()))))</p><p>This is really quite simple. Just be careful not to forget to pass the <strong class="source-inline">f</strong> argument to the two recursive calls at the end. The formatting function is needed at every level of the tree. </p><p>Now we can call the function with <strong class="source-inline">select-keys</strong>, or any other formatting function we want.</p><p>To test this, we'll reuse the <strong class="source-inline">federer</strong> var from the two previous exercises. You can rebuild it if necessary like this, where <strong class="source-inline">matches</strong> is the output from <strong class="source-inline">elo-db</strong>:</p><p class="source-code">(def federer (match-tree-by-player matches "roger-federer"))</p><p>Let's look at a few values:</p><p class="source-code">packt-clojure.lazy-tennis&gt; (take-matches 3 federer #(select-keys % [:winner_slug :loser_slug]))</p><p class="source-code">({:winner_slug "roger-federer", :loser_slug "guido-pella"}</p><p class="source-code"> [({:winner_slug "roger-federer", :loser_slug "marcus-willis"}</p><p class="source-code">   [{:winner_slug "roger-federer", :loser_slug "daniel-evans"}</p><p class="source-code">    {:winner_slug "pierre-hugues-herbert",</p><p class="source-code">     :loser_slug "marcus-willis"}])</p><p class="source-code">  ({:winner_slug "benjamin-becker", :loser_slug "guido-pella"}</p><p class="source-code">   [{:winner_slug "dudi-sela", :loser_slug "benjamin-becker"}</p><p class="source-code">    {:winner_slug "guido-pella", :loser_slug "diego-schwartzman"}])])</p><p>Our data visualization could probably use some polish, but even in this form, we can see not only the actual structure of the tree, but the win-loss history of the players involved in Roger Federer's recent matches!</p><p class="callout-heading">Note</p><p class="callout">If we wanted to make the <strong class="source-inline">f</strong> parameter optional, we could supply the <strong class="source-inline">identity</strong> function as a default formatting function. The <strong class="source-inline">identity</strong> function simply returns whatever argument it is called with, which makes it the ideal placeholder function.</p></li>
				<li>Write a <strong class="source-inline">matches-with-ratings</strong> function with a more sophisticated formatting function that changes the rating floats to integers and only shows the players' names and ratings:<p class="source-code">(defn matches-with-ratings [limit tree]</p><p class="source-code">  (take-matches limit</p><p class="source-code">                tree</p><p class="source-code">                (fn [match]</p><p class="source-code">                  (-&gt; match</p><p class="source-code">                      (update :winner_rating int)</p><p class="source-code">                      (update :loser_rating int)</p><p class="source-code">                      (select-keys [:winner_name :loser_name :winner_rating :loser_rating])</p><p class="source-code">                      (assoc :winner_probability_percentage</p><p class="source-code">                             (-&gt;&gt; (match-probability (:winner_rating match)</p><p class="source-code">                                                     (:loser_rating match))</p><p class="source-code">                                  (* 100)</p><p class="source-code">                                  int))))))</p><p>Because <strong class="source-inline">match-probabilty</strong> returns a long decimal, we've made it more user friendly by turning it into a percentage.</p></li>
				<li>Test the new function:<div id="_idContainer082" class="IMG---Figure"><img src="image/B14502_07_08.jpg" alt="Figure 7.8: Matches with ratings&#13;&#10;"/></div></li>
			</ol>
			<p class="figure-caption">Figure 7.8: Matches with ratings</p>
			<p>Now our results tell a real story! Beyond showing who won and who lost, they show whether the result was expected, or a surprise. It's easy to see which matches were upsets, like when Dudi Sela won despite only having 35% chance and which victories were nearly inevitable, such as Roger Federer's 98% chance of defeating Marcus Willis.</p>
			<p>This exercise is also a good illustration of the power of using functions as arguments. With this minor change to our <strong class="source-inline">take-matches</strong> function, it has become something like a custom <strong class="source-inline">map</strong> function that could be used for many different purposes.</p>
			<h2 id="_idParaDest-163">Activity<a id="_idTextAnchor183"/> 7.01: Historical, Player-Centric Elo</h2>
			<p>The data visualization team at the sports journalism website loves your work. The readers are more and more curious about how Elo scores evolve over time. Emails pour in asking for more information. As a result, the journalists have a new request for a visualization. They found that it is difficult to present, on a single web page, more than four levels of tennis history. After that, there are too many branches and the readers stop reading.</p>
			<p>In the new project, the journalists would like to show the evolution of a single player over many matches. For a given match, they would like to show a relatively long history for the player they're focused on, and much shorter histories for each of their opponents.</p>
			<p>This is the kind of graphic that the team wants to be able to make:</p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B14502_07_09.jpg" alt="Figure 7.9: The focus player has a long history, but the opponents are displayed with truncated histories&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9: The focus player has a long history, but the opponents are displayed with truncated histories</p>
			<p>The journalists don't know yet how long the histories will have to be, so both lengths need to be parameterized. If opponent histories are longer than one level, the function should not focus only on the opponent but should return a full sub-tree that includes the opponent, and their opponent, and so on.</p>
			<p>Your job is to adapt the existing code to this new use case.</p>
			<ol>
				<li value="1">As a starting point, you will need the <strong class="source-inline">match-probability</strong>, <strong class="source-inline">recalculate-rating</strong>,<strong class="source-inline"> elo-world-db</strong>, and <strong class="source-inline">match-tree-by-player</strong> functions from the code in <em class="italic">Exercise 7.03</em>, <em class="italic">A Tennis History Tree</em>. You will also need to include their dependencies in your <strong class="source-inline">deps.edn</strong> file.</li>
				<li>The recursive function you will write will be a specialized version of the <strong class="source-inline">take-matches</strong> function from Exercise 7.04. It will operate on the output of <strong class="source-inline">match-tree-by-player</strong>, which in turn uses the output from <strong class="source-inline">elo-world-db</strong>. </li>
				<li>The new function will have different behavior depending on whether a match involves the "focus player" or not. You will need to have separate parameters for both of these behaviors (in place of the <strong class="source-inline">limit</strong> parameter in <strong class="source-inline">take-matches</strong>, for example).</li>
				<li>Like <strong class="source-inline">take-matches</strong>, your new function should accept a functional argument that will be called on individual matches.<p class="callout-heading">Hint</p><p class="callout">Don't forget that you can call <strong class="source-inline">take-matches</strong> from inside your new function, if you need to.</p></li>
				<li>The fact that you have two separate behaviors for different kinds of matches will shape how your function moves recursively through the tree.<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 701.</p></li>
			</ol>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor184"/>Summary</h1>
			<p>Lazy sequences and recursion can be rather challenging. By now, you should know how to safely consume lazy sequences, how to produce them, and how to use them to build tree structures from linear data sources, all without blowing the stack of your runtime.</p>
			<p>As we've said before, writing functions to produce your own recursion-based lazy sequences should be something that you reach for only when all the other options won't work. Start with <strong class="source-inline">map</strong> and <strong class="source-inline">filter</strong>. If that's not enough, try <strong class="source-inline">reduce</strong>. Maybe the other forms of recursion will work. If none of those solve your problem, you have lazy sequences, an extremely powerful and efficient tool. </p>
			<p>Lazy sequences and recursion always make us think. Being able to write your own lazy sequences will also make you a more enlightened consumer of lazy sequences. In Clojure, this is very valuable because lazy sequences are everywhere. Techniques like the ones we've explored here can also help you start thinking about new ways of understanding and solving problems.</p>
			<p>By now, you are well on your way to being able to code effectively in Clojure. To be an effective developer, you also need to know the tooling necessary to manage a Clojure project. That's what we will explore now. In the next chapter, you will learn about namespaces and how to use Leiningen to organize and run your projects. </p>
		</div>
	</body></html>