<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer066">
			</div>
		</div>
		<div class="Content" id="_idContainer067">
			<h1 id="_idParaDest-155"><a id="_idTextAnchor156"/>7. Databases and JDBC</h1>
		</div>
		<div class="Content" id="_idContainer074">
			<p class="callout-heading">Overview</p>
			<p class="callout">In the following chapter, you will learn how to use <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>) to access relational databases from your Java applications. This begins with creating tables in relational databases to store and sort data. Only then can you manipulate these tables by writing basic SQL queries to retrieve and modify that data. Once this baseline is established, you'll be able to apply these skills to Java applications, specifically, in order to access databases and run queries from JDBC. You will further practice using the JDBC PreparedStatement interface to allow for parameterized SQL statements, boosting your speed by cutting out time-consuming and repetitive keystrokes. By the end of this chapter, you will know how to insert and update data from the JDBC, and handle any exceptions it throws with confidence and skill.</p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor157"/>Introduction</h1>
			<p>Databases—especially relational databases—are used in thousands of applications, from small home-based applications to huge enterprise systems. To help us write applications that access databases, Java provides a few very handy tools, starting with <strong class="bold">Java Database Connectivity</strong> (<strong class="bold">JDBC</strong>).</p>
			<p><strong class="bold">JDBC</strong> allows Java applications to connect to a myriad of databases, provided you have the correct driver: a Java library designed to communicate with a given database. Once connected, JDBC provides an API for accessing databases in a manner that is mostly generic. You'll only encounter a few areas where you need to know the specifics of the underlying database implementation.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor158"/>Relational Databases</h1>
			<p>Originally defined by E. F. Codd, relational databases store data in tables, made up of columns and rows. For example, the following table could be used to store customer information:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer068">
					<img alt="Figure 7.1: A database table of customers&#13;&#10;" src="image/C13927_07_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: A database table of customers</p>
			<p>In this customer table example, each row has four columns: an ID, a username, a first name, and a last name.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In addition to celebrities such as Sting, Cher, and Bono, some ethnic groups use just one name. You will not always have first and last names.</p>
			<p>Each row needs a unique way to distinguish that row from all others, called a <strong class="bold">unique primary key</strong>. In this case, the ID column acts as a unique key. In this table, you could also use the username as a unique key.</p>
			<p>Some tables use a single column as a key, while others use the values in multiple columns to form the key, called a <strong class="bold">composite key</strong>.</p>
			<p>Most databases use more than one table. You can relate tables to other tables based on information within a row.</p>
			<p>For example, in an online system, each customer might have multiple email addresses. You can model this relationship using a separate table for email addresses, as shown in Table 2:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer069">
					<img alt="Figure 7.2: A database table for email addresses&#13;&#10;" src="image/C13927_07_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: A database table for email addresses</p>
			<p>In table 2, each row has its own unique ID, with the <strong class="source-inline">EMAIL_ID</strong> column. Each row also links back to the customer table by holding an ID for the user table in the <strong class="source-inline">CUSTOMER_ID</strong> column. This allows the <strong class="source-inline">EMAIL</strong> table to link to the <strong class="source-inline">CUSTOMER</strong> table. User <strong class="source-inline">bobmarley</strong>, for example, has two email addresses in the system, one for home and one for work.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">These email addresses are not real.</p>
			<p>In this hypothetical example, there may also be tables for postal addresses, customer preferences, billing, and other things. Each table would likely relate back to the customer table.</p>
			<p>To use a relational database, you need a <strong class="bold">Relational Database Management System</strong> (<strong class="bold">RDBMS</strong>), the software that manages the tables.</p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor159"/>Relational Database Management Systems</h1>
			<p>Some of the most common RDBMSes include Oracle, MySQL, SQL Server, PostgreSQL, and DB2. In each case, you have software that runs on a server (or servers) to manage the data, along with separate client software to query and manipulate the data.</p>
			<p>To use an RDMS, you first need to install the database software.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor160"/>Installing a Database</h2>
			<p>In this chapter, we'll use an open-source database called H2. H2 is written entirely in Java, so you can run it wherever you run a JVM, such as in Windows, Linux, or macOS systems. On account of its portability and simplicity, H2 works well for the database tables we'll create in this chapter. </p>
			<p>H2 has some nice features in that it comes with a browser-based database console that you can use to access the database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">H2 can also be used inside your applications as an embedded in-memory database. In this case, the database server and client both exist within your Java application.</p>
			<p>To install H2, go to <a href="https://packt.live/2MYw1XX">https://packt.live/2MYw1XX</a> and download the <strong class="bold">All Platforms</strong> zip file. Once downloaded, unzip the file. This will create a folder named <strong class="source-inline">h2</strong>.</p>
			<p>Inside the <strong class="source-inline">h2</strong> folder, you will see sub-folders named <strong class="source-inline">bin</strong>, <strong class="source-inline">docs</strong>, <strong class="source-inline">service</strong>, and <strong class="source-inline">src</strong>. The documentation in the <strong class="source-inline">docs</strong> folder is also available online.</p>
			<p>The bin folder contains the H2 database software bundled into a JAR file. It also contains a Windows batch file and a Unix/Linux shell script. </p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor161"/>Exercise 1: Running the H2 Database</h2>
			<p>Now that you have installed the database, the next step is to get the database up and running. To do this, perform the following steps:</p>
			<ol>
				<li>To run the H2 database, you can use one of the scripts in the <strong class="source-inline">bin</strong> folder, or simply run the <strong class="source-inline">jar</strong> file. For example:<p class="source-code">java -jar h2*.jar</p><p>Regardless of how you launch the H2 database, you can access it from a browser. On some systems, such as macOS, H2 will open the database console in your default browser. </p></li>
				<li>If it does not open automatically, you can simply point your browser to <strong class="source-inline">http://10.0.1.7:8082/</strong>.</li>
				<li>You will see the login pane with the information filled in, as shown in <em class="italic">Figure 7.1</em>:<div class="IMG---Figure" id="_idContainer070"><img alt="Figure 7.3: The login pane for the web database console &#13;&#10;" src="image/C13927_07_03.jpg"/></div><p class="figure-caption">Figure 7.3: The login pane for the web database console </p><p>All the information should be filled in correctly when you start. The database driver (discussed later in this chapter) is <strong class="source-inline">org.h2.Driver</strong>, the JDBC URL is <strong class="source-inline">jdbc:h2:~/test</strong>, the username is <strong class="source-inline">sa</strong> (for system administrator), and the password is empty.</p><p>Obviously, on a real database, you'd use an actual password.</p></li>
				<li>Click <strong class="source-inline">Connect</strong>.<p>In a few moments, you'll see the main console pane, and you're in.</p><p class="callout-heading">Note</p><p class="callout">By default, H2 will store databases in your home directory. With this database named <strong class="source-inline">test</strong>, you should see two files in your home directory with names starting with <strong class="source-inline">test</strong> and ending with <strong class="source-inline">db</strong>.</p></li>
			</ol>
			<p>Once you have the H2 database installed and running, the next step is to start creating tables. To do so, you need to write commands in a language called SQL.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor162"/>Introducing SQL</h1>
			<p><strong class="bold">Structured Query Language</strong> (<strong class="bold">SQL</strong> and often pronounced "sequ-el") provides a common language for querying and manipulating data in relational databases. While there are a few differences, SQL mostly works the same in relational database systems such as Oracle, SQL Server, MySQL, and H2.</p>
			<p>The first thing you need to do is to create a table. To do so, use the <strong class="source-inline">CREATE TABLE</strong> SQL command. To create a table, you must provide the name of the table, the names and types of the columns, and any constraints.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor163"/>Exercise 2: Creating the customer Table</h2>
			<p>Use the SQL <strong class="source-inline">CREATE TABLE</strong> command to create a <strong class="source-inline">customer</strong> table. It should contain the customer ID and the users' first and last names. </p>
			<ol>
				<li value="1">Enter the following SQL commands in the upper-right input pane:<p class="source-code">CREATE TABLE IF NOT EXISTS customer</p><p class="source-code">(</p><p class="source-code">CUSTOMER_ID long,</p><p class="source-code">USERNAME varchar(255),</p><p class="source-code">FIRST_NAME varchar(255),</p><p class="source-code">LAST_NAME varchar(255),</p><p class="source-code">UNIQUE(USERNAME),</p><p class="source-code">PRIMARY KEY (CUSTOMER_ID)</p><p class="source-code">);</p></li>
				<li>After entering the SQL command, click on the <strong class="source-inline">Run</strong> button.<p><em class="italic">Figure 7.2</em> shows the main database console window:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer071">
					<img alt="Figure 7.4: The H2 database console after creating a table&#13;&#10;" src="image/C13927_07_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: The H2 database console after creating a table</p>
			<p>Notice in <em class="italic">Figure 7.4</em> that once the table is created, you see the table name, <strong class="source-inline">CUSTOMER</strong>, in the left-hand pane. You can click on the <strong class="source-inline">+</strong> symbol to expand the table entry and see the columns, as shown in <em class="italic">Figure 7.4</em>.</p>
			<p>The <strong class="source-inline">CREATE TABLE</strong> command can be broken down into its component parts. The command starts with <strong class="source-inline">CREATE TABLE</strong>. After that, <strong class="source-inline">IF NOT EXISTS</strong> means to not attempt to recreate the table if it already exists (the <strong class="source-inline">ALTER TABLE</strong> command is used to change the structure of an existing table):</p>
			<p class="source-code">CREATE TABLE IF NOT EXISTS customer</p>
			<p>Next comes the table name, <strong class="source-inline">customer</strong>.</p>
			<p>After a parenthesis, you will see the definition of the columns and then the constraints:</p>
			<p class="source-code">CUSTOMER_ID long,</p>
			<p class="source-code">USERNAME varchar(255),</p>
			<p class="source-code">FIRST_NAME varchar(255),</p>
			<p class="source-code">LAST_NAME varchar(255),</p>
			<p>The <strong class="source-inline">CUSTOMER_ID</strong> column is of the <strong class="source-inline">long</strong> type, like the Java <strong class="source-inline">long</strong> type. This column will be the unique primary key.</p>
			<p>The <strong class="source-inline">USERNAME</strong>, <strong class="source-inline">FIRST_NAME</strong>, and <strong class="source-inline">LAST_NAME</strong> columns are all of the <strong class="source-inline">varchar</strong> type. The <strong class="source-inline">varchar</strong> type holds variable-length character (text) data up to a maximum number of characters, specified here as <strong class="source-inline">255</strong> characters.</p>
			<p>Next comes the constraints:</p>
			<p class="source-code">UNIQUE(USERNAME),</p>
			<p class="source-code">PRIMARY KEY (USER_ID)</p>
			<p>The <strong class="source-inline">USERNAME</strong> column must be unique, and the <strong class="source-inline">CUSTOMER_ID</strong> column is the primary key. (The primary key must also be unique.) The database will enforce these constraints when you insert data. Note that you can list multiple columns names, separated by commas, to create a composite primary key. This means that the combination of values in those columns must be unique.</p>
			<p>The entire command ends with a closing parenthesis and a semicolon. SQL uses a semicolon in the same way as Java to indicate the end of a statement.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor164"/>Inserting Data into a Table</h2>
			<p>To insert data into a table, use the <strong class="source-inline">INSERT INTO</strong> command. The basic syntax is as follows:</p>
			<p class="source-code">INSERT INTO table_name</p>
			<p class="source-code">(column1, column2, column3, column4)</p>
			<p class="source-code">VALUES (value1, value2, value3, value4);</p>
			<p>You first list the columns and then provide values for those columns. You must provide a value for all columns that do not allow nulls. In this case, the <strong class="source-inline">CUSTOMER_ID</strong> and the <strong class="source-inline">USERNAME</strong> are required. Each must also be unique.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">SQL uses a single quote character to delimit strings. If you need to enter a quote character, use two together, such as <strong class="source-inline">Java''s</strong>. Don't try smart quotes, as are used in some word processors.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor165"/>Exercise 3: Inserting Data</h2>
			<p>This exercise again uses the H2 web console.</p>
			<ol>
				<li value="1">Enter the following SQL in the upper-right input pane:<p class="source-code">INSERT INTO customer</p><p class="source-code">(CUSTOMER_ID, USERNAME, FIRST_NAME, LAST_NAME)</p><p class="source-code">VALUES (1, 'bobmarley', 'Bob', 'Marley');</p></li>
				<li>After entering the SQL command, click on the <strong class="source-inline">Run</strong> button.</li>
				<li>Repeat these two steps with the following two SQL statements:<p class="source-code">INSERT INTO customer</p><p class="source-code">(CUSTOMER_ID, USERNAME, FIRST_NAME, LAST_NAME)</p><p class="source-code">VALUES (2, 'petertosh', 'Peter', 'Tosh');</p><p class="source-code">INSERT INTO customer</p><p class="source-code">(CUSTOMER_ID, USERNAME, FIRST_NAME, LAST_NAME)</p><p class="source-code">VALUES (3, 'jimmy', 'Jimmy', 'Cliff');</p><p class="callout-heading">Note</p><p class="callout">Most RDBMSs support types that will automatically manage ID numbers for a primary key. The syntax does differ in different database software, however. Refer to <a href="https://packt.live/2J6z5Qt">https://packt.live/2J6z5Qt</a> for the <strong class="source-inline">IDENTIIY</strong> type for H2.</p></li>
			</ol>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor166"/>Retrieving Data</h2>
			<p>To retrieve data from a table (or tables), use the <strong class="source-inline">SELECT</strong> command. The SQL <strong class="source-inline">SELECT</strong> command lets you query for data. You must specify what you are looking for. </p>
			<p>The basic syntax is as follows:</p>
			<p class="source-code">SELECT what_columns_you_want</p>
			<p class="source-code">FROM table_name</p>
			<p class="source-code">WHERE criteria_you_want;</p>
			<p>You can provide a comma-delimited list of columns to return, or use an asterisk, <strong class="source-inline">*</strong>, to indicate you want all the columns returned. The simplest query follows:</p>
			<p class="source-code">SELECT * from customer;</p>
			<p>You should now see all the rows returned, as displayed in <em class="italic">Figure 7.3</em>:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer072">
					<img alt="Figure 7.5: Querying all the rows from the customer table&#13;&#10;" src="image/C13927_07_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: Querying all the rows from the customer table</p>
			<p>You can refine your query with a <strong class="source-inline">WHERE</strong> clause. For example:</p>
			<p class="source-code">SELECT * from customer</p>
			<p class="source-code">WHERE first_name = 'Bob';</p>
			<p>This will return all rows that have a <strong class="source-inline">first_name</strong> column value equal to <strong class="source-inline">Bob</strong>, which, so far, would be just one row.</p>
			<p>You can use a wild card query with the <strong class="source-inline">LIKE</strong> modifier:</p>
			<p class="source-code">SELECT * from customer</p>
			<p class="source-code">WHERE username LIKE '%e%';</p>
			<p>This query returns all rows where the username has an <strong class="source-inline">e</strong>.</p>
			<p>In SQL, the percent sign acts as a wild card. This example has a wild card at the beginning of the value, and another at the end. You can use just one wild card, for example, to query for the end of a value:</p>
			<p class="source-code">SELECT * from customer</p>
			<p class="source-code">WHERE username LIKE '%ey';</p>
			<p>This example queries for all records that have a username value that ends in <strong class="source-inline">ey</strong>.</p>
			<p>You can make a more detailed query using <strong class="source-inline">OR</strong> or <strong class="source-inline">AND</strong> in the <strong class="source-inline">WHERE</strong> clause. For example:</p>
			<p class="source-code">SELECT * from customer</p>
			<p class="source-code">WHERE </p>
			<p class="source-code">    first_name = 'Peter'</p>
			<p class="source-code">OR</p>
			<p class="source-code">    last_name = 'Cliff';</p>
			<p>This example returns all rows where the <strong class="source-inline">first_name</strong> is <strong class="source-inline">Peter</strong> or the <strong class="source-inline">last_name</strong> is <strong class="source-inline">Cliff</strong>, which is two rows in this example.</p>
			<p>With an <strong class="source-inline">OR</strong> operator, the <strong class="source-inline">SELECT</strong> statement returns all rows that match either of the criteria. With an <strong class="source-inline">AND</strong> operator, both parts of the criteria must match:</p>
			<p class="source-code">SELECT * from customer</p>
			<p class="source-code">WHERE </p>
			<p class="source-code">    first_name = 'Peter'</p>
			<p class="source-code">AND</p>
			<p class="source-code">    last_name = 'Cliff';</p>
			<p>This example will return zero rows since no row matches both criteria.</p>
			<p>Thus far, we've used an asterisk to indicate that we want all columns returned. You can specify a comma-delimited list of column names instead. For example:</p>
			<p class="source-code">SELECT first_name, last_name from customer</p>
			<p class="source-code">order by</p>
			<p class="source-code">last_name, first_name;</p>
			<p>This example also uses the <strong class="source-inline">ORDER BY</strong> clause to tell the database to return the records in a certain order, in this case, sorted by <strong class="source-inline">last_name</strong> and then <strong class="source-inline">first_name</strong>.</p>
			<p>SQL uses two dashes, <strong class="source-inline">--</strong>, to indicate the start of a comment, as shown here:</p>
			<p class="source-code">-- This is a comment.</p>
			<p>SQL queries can get quite complex. These examples just provide a small taste. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information on SQL, you can refer to the following Packt video: <a href="https://packt.live/33KIi8S">https://packt.live/33KIi8S</a>.</p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor167"/>Relating Tables</h2>
			<p>Most databases include multiple tables, and many of these tables will be related. From the earlier example, we can relate the customer table to a separate table for email addresses. In the previous example, each row in the email table included the ID of the related row in the customer table.</p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor168"/>Exercise 4: Creating the email Table</h2>
			<p>This exercise uses the H2 web console. In this exercise, we will create an email table and insert some values into it.</p>
			<ol>
				<li value="1">Enter the following SQL in the upper-right input pane:<p class="source-code">CREATE TABLE IF NOT EXISTS email</p><p class="source-code">(</p><p class="source-code">EMAIL_ID long,</p><p class="source-code">CUSTOMER_ID long,</p><p class="source-code">EMAIL_ADDRESS varchar(255),</p><p class="source-code">EMAIL_TYPE varchar(255),</p><p class="source-code">PRIMARY KEY (EMAIL_ID)</p><p class="source-code">);</p></li>
				<li>After entering the SQL command, click the <strong class="source-inline">Run</strong> button.</li>
				<li>Include the following <strong class="source-inline">INSERT</strong> statement, and then click the <strong class="source-inline">Run</strong> button:<p class="source-code">INSERT INTO email</p><p class="source-code">(EMAIL_ID, CUSTOMER_ID, EMAIL_ADDRESS, EMAIL_TYPE)</p><p class="source-code">VALUES (1,1, 'bob@example.com', 'HOME');</p></li>
				<li>Include the following <strong class="source-inline">INSERT</strong> statement, and then click on the <strong class="source-inline">Run</strong> button:<p class="source-code">INSERT INTO email</p><p class="source-code">(EMAIL_ID, CUSTOMER_ID, EMAIL_ADDRESS, EMAIL_TYPE)</p><p class="source-code">VALUES (2,1, 'bob.marley@big_company.com', 'WORK');</p></li>
				<li>Include the following <strong class="source-inline">INSERT</strong> statement, and then click on the <strong class="source-inline">Run</strong> button:<p class="source-code">INSERT INTO email</p><p class="source-code">(EMAIL_ID, CUSTOMER_ID, EMAIL_ADDRESS, EMAIL_TYPE)</p><p class="source-code">VALUES (3,2, 'petertosh888@example.com', 'HOME');</p></li>
			</ol>
			<p>Notice how we must manage the IDs, both <strong class="source-inline">EMAIL_ID</strong> and the related <strong class="source-inline">CUSTOMER_ID</strong>. This can become tedious. Java libraries, such as Hibernate, that map Java objects to relational tables can help with this.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Hibernate is considered an ORM, or Object-Relational Mapper. For more information on Hibernate, refer to <a href="https://packt.live/2Bs5z3k">https://packt.live/2Bs5z3k</a>. </p>
			<p>Once you have data in multiple related tables, you can query from multiple tables at once, joining the results together.</p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor169"/>Selecting Data from Multiple Tables</h2>
			<p>When you use the SQL select statement to query data from multiple tables, you need to list all the columns (from all the tables) that you wish to be returned, along with the criteria to search in the <strong class="source-inline">WHERE</strong> clause. In the <strong class="source-inline">WHERE</strong> clause, you will need to join the two tables on some common value. </p>
			<p>For example, the <strong class="source-inline">email</strong> table has a <strong class="source-inline">customer_id</strong> column to join back to the <strong class="source-inline">customer</strong> table. To join that, write a query along the lines of the following:</p>
			<p class="source-code">SELECT username, email_address </p>
			<p class="source-code">FROM customer, email</p>
			<p class="source-code">WHERE email_type = 'HOME'</p>
			<p class="source-code">AND </p>
			<p class="source-code">email.customer_id = customer.customer_id;</p>
			<p>In this query, we ask for the <strong class="source-inline">username</strong> from the customer table, along with the <strong class="source-inline">email_address</strong> from the email table. The <strong class="source-inline">FROM</strong> section lists both the customer and email tables. </p>
			<p>The <strong class="source-inline">WHERE</strong> clause gets more interesting. This query looks for all email addresses where the type is <strong class="source-inline">HOME</strong>. To join this back to the customer table, and to ensure you are getting the right customer, the query adds a join where the <strong class="source-inline">customer_id</strong> email table column corresponds to the <strong class="source-inline">customer_id</strong> customer table column. This ensures that you get the correct customers aligned.</p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor170"/>Modifying Existing Rows</h2>
			<p>The <strong class="source-inline">UPDATE</strong> command lets you modify existing rows. To update data, you need to specify which rows to change, along with the values to change. The basic syntax is as follows:</p>
			<p class="source-code">UPDATE table_name</p>
			<p class="source-code">SET column1 = value1, column2 = value2</p>
			<p class="source-code">WHERE where_clause_to_find_rows</p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor171"/>Exercise 5: Modifying email Data</h2>
			<p>If a user, such as <strong class="source-inline">bobmarley</strong>, switches to a different work email, you would need to update the email table. To do so, perform the following steps:</p>
			<ol>
				<li value="1">Go to the H2 database console.</li>
				<li>Include the following SQL query, and then click <strong class="source-inline">Run</strong>:<p class="source-code">SELECT * from email;</p><p>This command lets you see what values are in the table now before we change anything.</p></li>
				<li>Next, enter the following <strong class="source-inline">UPDATE</strong> statement, and then click <strong class="source-inline">Run</strong>:<p class="source-code">UPDATE email</p><p class="source-code">SET EMAIL_ADDRESS = 'bob.marley@another_company.com'</p><p class="source-code">WHERE customer_id = 1</p><p class="source-code">AND email_type = 'WORK';</p><p>This query changes the <strong class="source-inline">email_address</strong> entry for the customer, <strong class="source-inline">bobmarley</strong>, but just the <strong class="source-inline">WORK</strong> email.</p></li>
				<li>Now, run the select query again (and click <strong class="source-inline">Run</strong>) to see how the table has changed:<p class="source-code">SELECT * from email;</p><p>You should now see the results as shown in the following table:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer073">
					<img alt="Figure 7.6: Output of the query&#13;&#10;" src="image/C13927_07_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: Output of the query</p>
			<h2 id="_idParaDest-171"><a id="_idTextAnchor172"/>Deleting Data</h2>
			<p>To remove data from a table, use the <strong class="source-inline">DELETE</strong> command:</p>
			<p class="source-code">DELETE FROM table_name</p>
			<p class="source-code">WHERE criteria_for_which_rows_to_delete;</p>
			<p>For example, to remove the work email for the customer, <strong class="source-inline">bobmarley</strong>, you would use a command such as the following:</p>
			<p class="source-code">DELETE FROM email</p>
			<p class="source-code">WHERE customer_id = 1</p>
			<p class="source-code">AND email_type = 'WORK';</p>
			<p class="callout-heading">Note</p>
			<p class="callout">When you have tables that are related, deleting data becomes trickier. If you delete a customer, for example, you need to delete all rows from the email table for this customer, too. In this example, the email table depends on the customer table, but the opposite is not true.</p>
			<p>In all the examples so far in this chapter, we've used SQL in the H2 console to work with the data in a test database. In your Java applications, you will use JDBC to accomplish much the same goals.</p>
			<h2 id="_idParaDest-172"><a id="_idTextAnchor173"/>JDBC—Accessing Databases from Java</h2>
			<p>JDBC provides a common API to work with databases. Mostly, JDBC works with relational databases, but you can work with any data source for which you have a <strong class="bold">JDBC driver</strong>, the Java library that communicates with the data source and implements the JDBC API.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">One of the best parts of JDBC is that most driver libraries are written in Java, so you can use these drivers from any platform that runs the JVM.</p>
			<p>The first thing you need to do with JDBC is connect to a data source, typically a database.</p>
			<h2 id="_idParaDest-173"><a id="_idTextAnchor174"/>Connecting to Databases</h2>
			<p>The simplest way to connect to a database using JDBC is to use the <strong class="source-inline">getConnection()</strong> method on the <strong class="source-inline">java.sql.DriverManager</strong> class:</p>
			<p class="source-code">Connection conn = DriverManager.getConnection("jdbc:h2:~/test", "sa", "");</p>
			<p>This method takes three parameters:</p>
			<ul>
				<li>The JDBC URL, which starts with <strong class="source-inline">jdbc:h2</strong> tells <strong class="source-inline">DriverManager</strong> to look for an H2 JDBC driver. <strong class="source-inline">~/test</strong> tells H2 to look for a database named <strong class="source-inline">test</strong> in the current user's home directory. (This is the user—you—running the Java program.) <strong class="source-inline">test</strong> is the default database name created by H2.</li>
				<li>The username to connect under, in this case, <strong class="source-inline">sa</strong>, for the system administrator.</li>
				<li>The password, in this case, is empty.<p class="callout-heading">Note </p><p class="callout">Other than H2, you will likely never have an empty password when connecting to a database. H2 sets up the <strong class="source-inline">sa</strong> account that you can use for testing by default.</p></li>
			</ul>
			<p>The <strong class="source-inline">getConnection()</strong> method returns a <strong class="source-inline">java.sql.Connection</strong> object, which you can use as a starting point for working with a database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">There are other ways to connect to a database, especially when using connection pools, described later in this chapter.</p>
			<p>Almost every JDBC operation can throw a <strong class="source-inline">java.sql.SQLException</strong>, so you will usually wrap JDBC calls in a try-catch block.</p>
			<p>When you are done with a JDBC connection, you should close the connection:</p>
			<p class="source-code">conn.close();</p>
			<h2 id="_idParaDest-174"><a id="_idTextAnchor175"/>Querying Data with JDBC</h2>
			<p>To query from a database with JDBC, create <strong class="source-inline">java.sql.Statement</strong> and then execute a query:</p>
			<p class="source-code">String sql = "SELECT * from customer order by username";</p>
			<p class="source-code">statement = conn.createStatement();</p>
			<p class="source-code">ResultSet results = statement.executeQuery(sql);</p>
			<p>Create a statement using the <strong class="source-inline">Connection</strong> object. You can then execute a SQL query using the <strong class="source-inline">executeQuery()</strong> method, which returns a <strong class="source-inline">java.sql.ResultSet</strong> object. </p>
			<p>The <strong class="source-inline">ResultSet</strong> API can be confusing at first. It is based on the idea of a cursor, a record of the program's position within the data. By calling <strong class="source-inline">next()</strong> on a <strong class="source-inline">ResultSet</strong>, you move the cursor to the next row.</p>
			<p>So, the normal flow for a query will look something like the following:</p>
			<p class="source-code">String sql = "SELECT * from customer order by username";</p>
			<p class="source-code">statement = conn.createStatement();</p>
			<p class="source-code">ResultSet results = statement.executeQuery(sql);</p>
			<p class="source-code">while (results.next()) {</p>
			<p class="source-code">    // Process the current row.</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">ResultSet</strong> starts with a position—the cursor—prior to the first row, so you need to call <strong class="source-inline">next()</strong> to get the very first row of data. The <strong class="source-inline">next()</strong> method returns false when it has reached the end of the data. </p>
			<p>Part of the reason for iterating through a <strong class="source-inline">ResultSet</strong> like this is because some database tables hold so many records that you could not hold them all in memory at the same time. Hence, the general technique is to process one row at a time. </p>
			<p>With each row of data, call <strong class="source-inline">get</strong> methods on the <strong class="source-inline">ResultSet</strong>. For example, to get a string value, call <strong class="source-inline">getString()</strong>:</p>
			<p class="source-code">String username = results.getString("USERNAME");</p>
			<p>In this example, we pass the name of the column to <strong class="source-inline">getString()</strong>. It returns the value of the <strong class="source-inline">USERNAME</strong> column for the current row.</p>
			<p>You can also pass the position of the column in the results. For example:</p>
			<p class="source-code">String username = results.getString(2);</p>
			<p>The position number is the position of the column in the results, which is dependent on the query.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Unlike almost everything else in Java, JDBC columns start counting at 1, not 0.</p>
			<p>You have to know the type of data in the column to call the proper <strong class="source-inline">get</strong> method. For example, to get a <strong class="source-inline">long</strong> value, call <strong class="source-inline">getLong()</strong>:</p>
			<p class="source-code">Long id = results.getLong("CUSTOMER_ID");</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can call <strong class="source-inline">getObject()</strong> if you are unsure of the type of data in the column.</p>
			<p>When done with a <strong class="source-inline">ResultSet</strong>, call <strong class="source-inline">close()</strong>. Similarly, when you're done with a statement, call <strong class="source-inline">close()</strong>. Calling the <strong class="source-inline">close()</strong> method on these objects frees up resources.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor176"/>Exercise 6: Querying Data with JDBC</h2>
			<p>This exercise will create an IntelliJ project, bring in a dependency for the H2 database JDBC driver, and then query the database:</p>
			<ol>
				<li value="1">Select <strong class="source-inline">New</strong> and then <strong class="source-inline">Project…</strong> from the <strong class="source-inline">File</strong> menu in IntelliJ. </li>
				<li>Select <strong class="source-inline">Gradle</strong> for the type of project. Click <strong class="source-inline">Next</strong>.</li>
				<li>For the <strong class="source-inline">Group Id</strong>, enter <strong class="source-inline">com.packtpub.db</strong>.</li>
				<li>For the <strong class="source-inline">Artifact Id</strong>, enter <strong class="source-inline">customers</strong>.</li>
				<li>For the <strong class="source-inline">Version</strong>, enter <strong class="source-inline">1.0</strong>.</li>
				<li>Accept the default on the next pane. Click <strong class="source-inline">Next</strong>.</li>
				<li>Leave the project name as <strong class="source-inline">customers</strong>.</li>
				<li>Click <strong class="source-inline">Finish</strong>.</li>
				<li>Call up <strong class="source-inline">build.gradle</strong> in the IntelliJ text editor.</li>
				<li>Set <strong class="source-inline">sourceCompatibility</strong> to <strong class="source-inline">12</strong>:<p class="source-code">sourceCompatibility = 12</p></li>
				<li>Replace the plugins block with the following, just as we did in <em class="italic">Chapter 6</em>, <em class="italic">Libraries, Packages, and Modules</em>:<p class="source-code">buildscript {</p><p class="source-code">    repositories {</p><p class="source-code">        jcenter()</p><p class="source-code">    }</p><p class="source-code">    dependencies {</p><p class="source-code">        classpath 'com.github.jengelman.gradle.plugins:shadow:2.0.1'</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">apply plugin: 'java'</p><p class="source-code">apply plugin: 'com.github.johnrengelman.shadow'</p></li>
				<li>Add the following dependency to incorporate the H2 library in the project:<p class="source-code">// https://mvnrepository.com/artifact/com.h2database/h2</p><p class="source-code">implementation group: 'com.h2database', name: 'h2', version: '1.4.197'</p><p>Note that the same jar file that provides the JDBC driver also includes the entire database software.</p></li>
				<li>Add the following to the end of the project's <strong class="source-inline">build.gradle</strong> file to define the main class for the executable jar:<p class="source-code">jar {</p><p class="source-code">    manifest {</p><p class="source-code">        attributes 'Main-Class': 'com.packtpub.db.Query</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>In the <strong class="source-inline">src/main/java</strong> folder, create a new Java package.</li>
				<li>Enter <strong class="source-inline">com.packtpub.db</strong> as the package name.</li>
				<li>Right-click on this package in the <strong class="source-inline">Project</strong> pane and create a new Java class named <strong class="source-inline">Query</strong>.</li>
				<li>Create a <strong class="source-inline">main()</strong> method for the <strong class="source-inline">Query</strong> class:</li>
			</ol>
			<p class="source-code-heading">Query.java</p>
			<p class="source-code">6   public static void main(String[] args) {</p>
			<p class="source-code">7  </p>
			<p class="source-code">8      String sql = "SELECT * from customer order by username";</p>
			<p class="source-code">9  </p>
			<p class="source-code">10     Statement statement;</p>
			<p class="source-code">11 </p>
			<p class="source-code">12     Connection conn;</p>
			<p class="source-code">13     try {</p>
			<p class="source-code">14         conn = DriverManager.getConnection("jdbc:h2:~/test", "sa", "");</p>
			<p class="source-code">15 </p>
			<p class="source-code">16         statement = conn.createStatement();</p>
			<p class="source-code">17 </p>
			<p class="source-code">18         ResultSet results = statement.executeQuery(sql);</p>
			<p class="source-code-link"><a href="https://packt.live/2PbKanp">https://packt.live/2PbKanp</a></p>
			<p>This program establishes a connection to an H2 database. Notice how all the JDBC calls are wrapped in a try-catch block.</p>
			<p>After establishing a <strong class="source-inline">connection</strong>, the program asks the <strong class="source-inline">Connection</strong> to create a <strong class="source-inline">Statement</strong>. Calling <strong class="source-inline">executeQuery()</strong> on the <strong class="source-inline">Statement</strong> runs the query, returning a <strong class="source-inline">ResultSet</strong>. With a <strong class="source-inline">while</strong> loop, the program iterates over each row in the <strong class="source-inline">ResultSet</strong>, extracting data, and printing. </p>
			<p>In the end, the program closes the resources used.</p>
			<p>This sets up an executable jar that will run the <strong class="source-inline">Query</strong> class. Remember to run the <strong class="source-inline">shadowJar</strong> Gradle task to build the executable jar with dependencies.</p>
			<p>When you run this program, you should see output similar to the following:</p>
			<p class="source-code">1 bobmarley Bob Marley</p>
			<p class="source-code">3 jimmy Jimmy Cliff</p>
			<p class="source-code">2 petertosh Peter Tosh</p>
			<p>Note that the query asked the database to order the results by username.</p>
			<p>If you are connected to the database from the H2 web console, you will see an error like the following when you run this program:</p>
			<p class="source-code">org.h2.jdbc.JdbcSQLException: Database may be already in use: null. Possible solutions: close all other connection(s); use the server mode [90020-197]</p>
			<p>You should also see the full stack trace for the error. This error indicates that you are already logged into the database as user <strong class="source-inline">sa</strong>. Click on the disconnect icon in the upper-left corner of the H2 web console to close the web console's connection to the database.</p>
			<p>In the <strong class="source-inline">Query</strong> class in <em class="italic">Exercise 6</em>, <em class="italic">Querying Data with JDBC</em>, we used a string for the SQL query. That works fine when your program generates the entire SQL statement itself. However, if you accept user input and then build a string for the SQL, your program may be vulnerable to SQL injection attacks, where a malicious user inputs SQL syntax designed to cause havoc to your database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For a more detailed look at SQL injection vulnerabilities, refer to <a href="https://packt.live/2OYGF3g">https://packt.live/2OYGF3g</a>.</p>
			<p>Because of this risk, you should sanitize any user input prior to placing it in a SQL statement.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor177"/>Sanitizing User Input</h2>
			<p>To sanitize user input:</p>
			<ul>
				<li>You can properly sanitize the data yourself. You could disallow characters that could form SQL syntax, for example.</li>
				<li>You can use the <strong class="source-inline">PreparedStatement</strong> interface and set the values on the prepared statement. JDBC will then sanitize the input for you.</li>
			</ul>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor178"/>Using Prepared Statements</h2>
			<p>A JDBC prepared statement takes in a SQL statement with placeholders for the data values. With most databases, JDBC sends the SQL to the database to be compiled. When you send a SQL statement to a database, the database needs to compile the SQL into an internal format that is native to the database, from which the database can execute the statement.</p>
			<p>With a regular statement, you can provide a SQL statement to methods such as <strong class="source-inline">executeQuery()</strong> and <strong class="source-inline">executeUpdate()</strong>. You can reuse the <strong class="source-inline">Statement</strong> and provide a completely different SQL statement.</p>
			<p>With a <strong class="source-inline">PreparedStatement</strong>, on the other hand, you prepare the statement with a SQL string, and that is all you get. Luckily, though, you provide placeholders for the data values. This means that you can reuse a <strong class="source-inline">PreparedStatement</strong> to insert multiple records into a table, for example.</p>
			<p>From <em class="italic">Exercise 5</em>, <em class="italic">Modifying email Data</em>, we use an <strong class="source-inline">UPDATE</strong> statement:</p>
			<p class="source-code">UPDATE email</p>
			<p class="source-code">SET EMAIL_ADDRESS = 'bob.marley@another_company.com'</p>
			<p class="source-code">WHERE customer_id = 1</p>
			<p class="source-code">AND email_type = 'WORK';</p>
			<p>With a <strong class="source-inline">PreparedStatement</strong>, you would use a question mark, <strong class="source-inline">?</strong> as a placeholder for the input values:</p>
			<p class="source-code">String sql = "UPDATE email " +</p>
			<p class="source-code">    "SET EMAIL_ADDRESS = ? " +</p>
			<p class="source-code">    "WHERE customer_id = ? " +</p>
			<p class="source-code">    "AND email_type = ? ";</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In a prepared statement, you do not need to place single quotes around string placeholders. JDBC will take care of that for you.</p>
			<p>These placeholders need to be filled in prior to using <strong class="source-inline">PreparedStatement</strong>. For example:</p>
			<p class="source-code">statement = conn.prepareStatement(sql);</p>
			<p class="source-code">statement.setString(1, "bob.marley@another_company.com");</p>
			<p class="source-code">statement.setLong(2, 1L);</p>
			<p class="source-code">statement.setString(3, "WORK");</p>
			<p class="source-code">int rowsChanged = statement.executeUpdate();</p>
			<p>Pass your SQL string, with placeholders, to the <strong class="source-inline">prepareStatement()</strong> method on a connection. Then, call <strong class="source-inline">setString()</strong>, <strong class="source-inline">setLong()</strong>, and so on, to fill in the placeholder values. With each set method call, you pass the index of the placeholder to fill, starting with <strong class="source-inline">1</strong> for the first placeholder. Then, pass the value to fill in. JDBC will handle the prevention of SQL injection attacks.</p>
			<p>As for a regular <strong class="source-inline">Statement</strong>, you can call <strong class="source-inline">executeQuery()</strong> to perform a SQL query, or <strong class="source-inline">executeUpdate()</strong> to modify the database. The <strong class="source-inline">executeUpdate()</strong> method handles <strong class="source-inline">INSERT</strong>, <strong class="source-inline">UPDATE</strong>, and <strong class="source-inline">DELETE SQL</strong> statements.</p>
			<p>In this example, <strong class="source-inline">executeUpdate()</strong> returns the number of rows in the table that was modified.</p>
			<p>One of the primary benefits of using prepared statements is that JDBC will sanitize the input values so that you don't have to. The other primary benefit is improved performance. If you execute the same SQL statement again and again, or a nearly similar statement with just different values, then using a prepared statement will speed things up, mostly due to pre-compiling the statement.</p>
			<h2 id="_idParaDest-178"><a id="_idTextAnchor179"/>Transactions and Rollback</h2>
			<p>In relational databases, transaction groups a set of SQL statements together. Either all the statements succeed, or the transaction will get rolled back, undoing the statements. In addition, databases treat all the statements within a transaction as happening at the same time, which helps to ensure that the data has integrity.</p>
			<p>In JDBC, a transaction continues until you call <strong class="source-inline">commit()</strong> on the connection. If there is a failure, you should call <strong class="source-inline">rollback()</strong> on the connection to restore the data to the state it held prior to the transaction.</p>
			<p>By default, a JDBC connection starts in auto-commit mode. This means that each JDBC connection gets committed one at a time. If you want to group a few statements together in a transaction, you first need to turn off auto-commit mode:</p>
			<p class="source-code">conn.setAutoCommit(false);</p>
			<p class="callout-heading">Note</p>
			<p class="callout">After turning off auto-commit mode, you should turn it back on when done accessing the database.</p>
			<p>When you want to end a transaction and commit the results to the database, call <strong class="source-inline">commit()</strong>:</p>
			<p class="source-code">conn.commit();</p>
			<p>If an <strong class="source-inline">SQLException</strong> gets thrown, you'll want to roll back the transaction:</p>
			<p class="source-code">} catch (SQLException e) {</p>
			<p class="source-code">    e.printStackTrace();</p>
			<p class="source-code">    try {</p>
			<p class="source-code">        if (conn != null) {</p>
			<p class="source-code">            conn.rollback();</p>
			<p class="source-code">        }</p>
			<p class="source-code">    } catch (SQLException nested) {</p>
			<p class="source-code">        nested.printStackTrace();</p>
			<p class="source-code">    }</p>
			<p class="source-code">} </p>
			<p>This code shows one of the most tedious parts of working with JDBC. In your exception handler for a <strong class="source-inline">SQLException</strong>, the calls made—<strong class="source-inline">rollback()</strong>, for instance—can also throw another <strong class="source-inline">SQLException</strong>, which you need to catch. You'll find that JDBC code is full of <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong>-<strong class="source-inline">finally</strong> blocks with nested <strong class="source-inline">try</strong>-<strong class="source-inline">catch</strong> blocks. <em class="italic">Exercise 7</em>, <em class="italic">Using Prepared Statements with Transactions</em> shows this technique in action.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor180"/>Exercise 7: Using Prepared Statements with Transactions</h2>
			<p>In this exercise, we'll create another Java class that uses a JDBC <strong class="source-inline">PreparedStatement</strong> to update data in the email table and wrap that update in a JDBC transaction.</p>
			<ol>
				<li value="1">In IntelliJ, create a new class named <strong class="source-inline">Prepared</strong> and create a <strong class="source-inline">main()</strong> method.</li>
				<li>Import the required libraries: <p class="source-code">package com.packtpub.db;</p><p class="source-code">import java.sql.Connection;</p><p class="source-code">import java.sql.DriverManager;</p><p class="source-code">import java.sql.PreparedStatement;</p><p class="source-code">import java.sql.SQLException;</p></li>
				<li>Enter the following code in the <strong class="source-inline">Prepared</strong> class.<p class="source-code">public class Prepared {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        Connection conn = null;</p><p class="source-code">        PreparedStatement statement = null;</p><p class="source-code">        String sql = "UPDATE email " +            "SET EMAIL_ADDRESS = ? " +</p><p class="source-code">            "WHERE customer_id = ? " +</p><p class="source-code">            "AND email_type = ? ";</p><p>The <strong class="source-inline">Prepared</strong> class starts by defining a <strong class="source-inline">SQL UPDATE</strong> statement using placeholders. This SQL statement will later get placed in a <strong class="source-inline">PreparedStatement</strong>.</p></li>
				<li>In the first try-catch block, the program gets a <strong class="source-inline">Connection</strong> to the database and then calls <strong class="source-inline">setAutoCommit()</strong> with a parameter of <strong class="source-inline">false</strong> to turn off auto-commit mode. JDBC now expects the program to manage transactions.</li>
			</ol>
			<p class="source-code-heading">Prepared.java</p>
			<p class="source-code">20         try {</p>
			<p class="source-code">21             conn = DriverManager.getConnection("jdbc:h2:~/test", "sa", "");</p>
			<p class="source-code">22             conn.setAutoCommit(false);</p>
			<p class="source-code">23 </p>
			<p class="source-code">24             statement = conn.prepareStatement(sql);</p>
			<p class="source-code">25             statement.setString(1, "bob.marley@another_company.com");</p>
			<p class="source-code">26             statement.setLong(2, 1L);</p>
			<p class="source-code">27             statement.setString(3, "WORK");</p>
			<p class="source-code">28 </p>
			<p class="source-code">29             int rowsChanged = statement.executeUpdate();</p>
			<p class="source-code">30 </p>
			<p class="source-code">31             conn.commit();</p>
			<p class="source-code">32 </p>
			<p class="source-code">33             System<a id="_idTextAnchor181"/>.out.println("Number rows changed: " + rowsChanged);</p>
			<p class="source-code-link"><a href="https://packt.live/2MSobyQ">https://packt.live/2MSobyQ</a></p>
			<p>When you run the <strong class="source-inline">main()</strong> method, you should see output like the following:</p>
			<p class="source-code">Number rows changed: 1</p>
			<p>Just one row should be modified.</p>
			<p>The program passes the SQL string to the connection's <strong class="source-inline">prepareStatement()</strong> method. This creates a <strong class="source-inline">PreparedStatement</strong> initialized with the given SQL. Next, the program fills in the placeholder values in the <strong class="source-inline">PreparedStatement</strong>.</p>
			<p>When it's done, the program calls <strong class="source-inline">executeUpdate()</strong> on the statement, commits the transaction and then tells us the number of rows that were changed.</p>
			<p>If any of the JDBC calls throws an <strong class="source-inline">SQLException</strong>, the catch block prints the stack trace and then calls <strong class="source-inline">rollback()</strong> on the connection. Calling <strong class="source-inline">rollback()</strong> can also throw <strong class="source-inline">SQLException</strong>, so the program catches that as well, printing the stack trace.</p>
			<p>The <strong class="source-inline">finally</strong> block from the original try-catch-finally block restores auto-commit transaction mode, and then calls <strong class="source-inline">close()</strong> on the <strong class="source-inline">PreparedStatement</strong> and the connection, each of which might also result in an <strong class="source-inline">SQLException</strong>.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor182"/>Simplifying JDBC Programming</h2>
			<p>As you can see from the examples, programming with JDBC is tedious. Because of that, a lot of projects have developed wrappers over the JDBC API in order to simplify making JDBC calls.</p>
			<p>Java itself contains a number of utility classes, such as <strong class="source-inline">JdbcRowSet</strong>, which wrap <strong class="source-inline">ResultSet</strong> objects and provide a somewhat simpler API. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Spring framework provides a number of utilities to simplify JDBC programming. Refer to <a href="https://packt.live/35PalWP">https://packt.live/35PalWP</a> for more information.</p>
			<p>By far the most popular way to access databases without the inconvenience of the JDBC API is to use object-relational mapping software.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor183"/>Using Object-Relational Mapping Software</h2>
			<p>As the name suggests, <strong class="bold">object-relational mapping</strong>, or <strong class="bold">ORM</strong>, software maps between the world of objects and the world of relational tables. With an ORM, you typically write a Java class that represents one row of a table.</p>
			<p>For example, the following class could represent a row in the customer table:</p>
			<p class="source-code-heading">Customer.java</p>
			<p class="source-code">1  package com.packtpub.db;</p>
			<p class="source-code">2  </p>
			<p class="source-code">3  public class Customer {</p>
			<p class="source-code">4      Long customerId;</p>
			<p class="source-code">5      String username;</p>
			<p class="source-code">6      String firstName;</p>
			<p class="source-code">7      String lastName;</p>
			<p class="source-code">8  </p>
			<p class="source-code">9      public Customer(Long customerId, String username, String firstName, String       lastName) {</p>
			<p class="source-code">10         this.customerId = customerId;</p>
			<p class="source-code">11         this.username = username;</p>
			<p class="source-code">12         this.firstName = firstName;</p>
			<p class="source-code">13         this.lastName = lastName;</p>
			<p class="source-code">14     }</p>
			<p class="source-code-link"><a href="https://packt.live/2pvQhYT">https://packt.live/2pvQhYT</a></p>
			<p>The <strong class="source-inline">Customer</strong> class is what is often called a <strong class="bold">Plain Old Java Object</strong> (<strong class="bold">POJO</strong>). ORM software then allows you to use query tables and get back a list of POJOs, or fill in data in a POJO and then persist that object to the database. In the majority of cases, ORM software uses reflection to discover the fields in the class and map those to columns in the table.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><em class="italic">Chapter 19</em> covers reflection.</p>
			<p>The <strong class="bold">Java Persistence API</strong>, or <strong class="bold">JPA</strong>, provides a standardized API to define the mapping between objects and database tables using annotations to describe the mapping. JPA also defines an API for persisting POJOs to database tables.</p>
			<p>Underneath the standard Java Persistence API, you need to use a JPA provider, a library that implements the JPA. The most commonly used JPA provider is called <strong class="bold">Hibernate</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more information on JPA, refer to <a href="https://packt.live/2OZjHsP">https://packt.live/2OZjHsP</a>. JPA is part of the <strong class="bold">Java Enterprise Edition</strong> (<strong class="bold">JavaEE</strong>). </p>
			<h2 id="_idParaDest-182"><a id="_idTextAnchor184"/>Database Connection Pooling</h2>
			<p>The <strong class="source-inline">DriverManager.getConnection()</strong> method can take a good bit of time to establish a connection to a database. To help with this, you can use a database connection pool. </p>
			<p>Connection pools set up multiple and managed connections to a database. Your application can then request a free connection from the pool. Your code uses the connection and then returns it to the pool.</p>
			<p>Some of the main connection pool software libraries are:</p>
			<ul>
				<li>HikariCP, from <a href="https://packt.live/2Bw7gg5">https://packt.live/2Bw7gg5</a></li>
				<li>Apache Commons DBCP, from <a href="https://packt.live/31p4xQg">https://packt.live/31p4xQg</a></li>
				<li>C3p0, from <a href="https://packt.live/2pw1vN0">https://packt.live/2pw1vN0</a></li>
				<li>The Tomcat connection pool, from <a href="https://packt.live/31pGgcJ">https://packt.live/31pGgcJ</a></li>
			</ul>
			<h2 id="_idParaDest-183"><a id="_idTextAnchor185"/>Non-Relational, or NoSQL, Databases</h2>
			<p>Relational databases work well when you have data that works well with the columns and rows in SQL database tables. In the real world, not all data fits neatly into this model. This has led to the creation of NoSQL databases, database management software that does not support relational tables.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Oddly enough, some NoSQL databases support a SQL-like language for accessing data.</p>
			<p>NoSQL databases all differ, and some of the categories to describe these databases overlap. Terrastore, <a href="https://packt.live/2P23i7e">https://packt.live/2P23i7e</a>, and MongoDB, <a href="https://packt.live/31qJVY0">https://packt.live/31qJVY0</a>, are considered document storage databases. In these systems, you store a full document, typically a structured document.</p>
			<p>Cassandra, <a href="https://packt.live/2MtDtej">https://packt.live/2MtDtej</a>, and HBase, <a href="https://packt.live/2VWebsp">https://packt.live/2VWebsp</a>, are sometimes referred to as column-store or column family databases, which store data in columns as opposed to storing data in rows, as is done with most SQL databases. If you organize the columns properly, these databases can very quickly retrieve data. You can also store a huge number of columns.</p>
			<p>Neo4j, <a href="https://packt.live/2o51EXm">https://packt.live/2o51EXm</a>, is a graph database. In a graph database, you retrieve data by following relationships between elements. These relationships form a graph.</p>
			<h2 id="_idParaDest-184"><a id="_idTextAnchor186"/>Activity 1: Track Your Progress</h2>
			<p>In this activity, we will set up database tables in the H2 database to track your progress through this course. These steps will help us complete this activity:</p>
			<ol>
				<li value="1">Create a table called <strong class="source-inline">student</strong>, where each record holds information on a student, such as you. Define the ID, first name, and last name columns.</li>
				<li>Create a table called <strong class="source-inline">chapter</strong>, where each record holds information on a chapter. Define columns for an ID (use the chapter number) and chapter title. For simplicity, you can just enter the chapters up to and including this one.</li>
				<li>Create a table to relate students to chapters, called <strong class="source-inline">student_progress</strong>. This table should have columns for the ID of a student, the ID of a chapter, and a date for when the chapter was completed. Use the <strong class="source-inline">SQL DATE</strong> type and pass the data as <strong class="source-inline">yyyy-MM-dd</strong>. This table should have a composite primary key.<p>You can use the H2 web console to create the tables and insert records.</p></li>
				<li>Create two Java programs that use JDBC.<p>Create the first to query all the chapters a given student has completed, and when. Take as inputs the student's first and last name. This should generate output like the following:</p><p class="source-code">BOB MARLEY</p><p class="source-code">2019-03-01  2 Learning the Basics</p><p class="source-code">2019-03-01  7 Databases and JDBC</p><p>Create the second program to insert chapter completion. Take as inputs the student's first and last name, along with a chapter number. The program should mark that chapter as having been completed today.</p><p>Because both programs take in user input, be sure to use a <strong class="source-inline">PreparedStatement</strong> in each to handle potentially malicious input data. You can create these programs as part of the customer's project created previously in this chapter.</p><p class="callout-heading">Note</p><p class="callout">The solution for the activity can be found on page 548.</p></li>
			</ol>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor187"/>Summary</h1>
			<p>This chapter introduced relational database management systems (RDBMSs) and the SQL language, which is used for working with relational databases. We used an all-Java database called H2. SQL is a language that's used to retrieve and modify data stored in a relational database. JDBC is a Java API that communicates with a relational database. You can use SQL commands to retrieve and modify data. </p>
			<p>There is a lot more to databases than can be presented in a single chapter, but after working through the exercises, you should be able to start working with databases using SQL and JDBC. A book or training course on SQL can help you delve into advanced database topics.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The Packt video SQL Beginner to Guru: MySQL Edition - Master SQL with MySQL: <a href="https://packt.live/33KIi8S">https://packt.live/33KIi8S</a> will help you advance your SQL skills.</p>
			<p>In the next chapter, you'll learn about networking and files using Java.</p>
		</div>
	</body></html>