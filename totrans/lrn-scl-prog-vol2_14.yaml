- en: Testing in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"Change is the end result of all the true learning."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Leo Buscaglia'
  prefs: []
  type: TYPE_NORMAL
- en: 'Software development is an ever transforming process. We have seen in recent
    decades that many patterns have been discovered/rediscovered. These programming
    techniques/paradigms have become an important part and have changed the way we
    approach programming. One of them is **Test-Driven Development **(**TDD**). In
    the TDD approach, we first specify the requirement for our application through
    new tests. Then, one by one, we write concrete code to pass all those tests. In
    this manner, we complete our requirements by writing new test cases, implementing
    code to pass them, and end up building an application that runs as expected. Scala
    provides many frameworks for testing (for example, **ScalaTest***,* **Specs2**,
    and so on) and we have **Mockito** and **ScalaMock**for mocking objects*.* Testing,
    in a way, is a small concept with a vast number of explanations possible. In this
    chapter, we''ll focus on understanding the TDD approach and the way we can follow
    this approach to successfully apply it in Scala. For that, we''ll go through:'
  prefs: []
  type: TYPE_NORMAL
- en: The why and what of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of TDD
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Behavior-driven development** (**BDD**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ScalaTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ScalaCheck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start with why this rocket called TDD is flying so high in the software
    development space nowadays.
  prefs: []
  type: TYPE_NORMAL
- en: The why and what of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write expected and well-designed software, we tend to clarify the requirements
    before starting the development process. With agile practices in place, we translate
    our requirements to what we call user/functional stories. Transforming these stories
    into a simple specification of what we're going to implement adds an advantage.
    That's where writing test cases comes in handy. We specify our program's behavior
    in the form of test cases and then implement those behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: There are some advantages to this approach. Writing test cases first and then
    providing the implementation drives the design of our program. It means that as
    we approach toward implementing the behavior, we can think of our design and code
    for that. If one of your classes, `A`, is dependent on another class, `B`, we
    can make sure that *B* is injected into *A.* In a way, we can make it a practice
    to follow these ways, for example, inject dependencies from other classes. Apart
    from driving the design of your application, TDD also helps us think about the
    use cases and the way in which users of our application might use it. It helps
    us think clearly about the interface the user is going to get so that we can code
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: In TDD, just because we tend to write test cases first, we cover almost all
    lines of our software implementation. This provides automatic code coverage to
    us. Let's take a look at the process of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: The process of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per the approach, we can break down the process of TDD into the following
    steps. The process can be included in your development workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test that will fail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write some code to pass the failing test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor your code to improve quality without any changes in the behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *steps 1* to *3.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We broke down the process into these steps. Let's take a look at each of these
    steps to better understand the reasoning behind each of these.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - write a test that will fail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing to fail is not something we feel confident about, but that's how TDD
    works. After we've determined what's needed from our application and are sure
    about a certain functionality, we can write a test case for functionality in the
    way we want it to work. We want to make sure that we run this test case and that
    it fails. The failure of our test case is expected because we have not implemented
    any code yet to make it successful. The initial failure we mean is step one of
    TDD.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - write code to pass the failing test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best thing about this step is to know how we have to pass a failing test
    case. For that, we'll implement a functionality. In this step, we'll have to write
    some code. We can try to implement a function, not in the best way possible, but
    enough to pass the failing test. Passing a test guarantees the particular behavior
    of a functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 - refactor the code to improve the quality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are confident that our functionality is working, we can go ahead
    and improve the code quality. If the functionality isn't too big, then this step
    can be a part of the previous one. It's logical to have a review of our code once
    the functionality is working. This might improve the quality of our code. After
    the refactor, we should ensure that the feature/functionality is in a working
    state and is intact.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 - repeat steps 1 to 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, for this particular functionality, for which we wrote test cases and implemented
    code, we have ensured that it's working and the code quality is proper. We are
    done with this particular feature/functionality and now can write another test
    case and repeat the process steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can visualize the working of TDD as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the previous diagram, it's clear that TDD is a repetitive process, where
    you specify a use case and write code for it.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of TDD is that our tests serve as a documentation. Library/framework
    developers tend to write test cases that serve the purpose of documentation too.
    How? By making use of DSL or, let's say, English-like sentences for designing
    our test suites. A test suite consists of multiple test cases for our program.
    Let's take a look at the scenario we have used in a couple of our chapters. The
    example we will be using is where we will read Football player's data from a CSV
    file named `football.csv`, convert those to `Player` objects, and further use
    the data to display the player's information or perform some analytics based on
    the information. How would we want to proceed with the test cases for such a scenario,
    or at least, how should it look when we say "English-like sentences" for our specifications?
  prefs: []
  type: TYPE_NORMAL
- en: Scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read the player data and showcase that on the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the given example scenario, we specified a service and named it `PlayerService`.
    Now, this service should have the methods that perform the specified cases. These
    cases are not too complicated, but each case expects our service to provide a
    simple functionality. This example is for explanation purposes, since we've already
    seen the code. We'll also try and implement the same using the TDD approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The point worth nothing about the preceding test specification is that before
    even trying to code, we are sure about certain things:'
  prefs: []
  type: TYPE_NORMAL
- en: There should be a `PlayerService` service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `PlayerService`*,* we should have a `Player` entity*.*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `PlayerService`*,* we should have a functionality to read the player's data.
    It has to be a collection; when the source can't be read or the source contains
    no data, the functionality should return an empty collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `PlayerService`*,* there should be a `getPlayer` functionality that expects
    us to provide some data to it and return a concrete `Player` entity. When we provide
    wrong data (as in the format), the functionality doesn't throw an exception, but
    specifies that it couldn't create a concrete `Player` entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `PlayerService`*,* there should be a `getPlayer` functionality which expects
    us to provide some data to it and return a concrete *Player* entity on receiving
    correct data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In `PlayerService`*,* there should be a `showPlayers` functionality which expects
    us to provide a collection of `Player` entities and print the player's information
    on the console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that the preceding points and specifications we mentioned are similar
    in semantic meaning and that we can use one of these to write test cases makes
    TDD fun. These test specifications are too close to real-world test specs that
    we'll be writing. Take a closer look at the specification we just described; nowhere
    does it state about the programming language choice we had to make. We didn't
    get any hint about the language specifications, so these test cases will work
    in any language if the programming language we use can support such **domain-specific
    language** (**DSL**) lookalike mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: This specification does not limit you to write test cases only in a specified
    format, but you can choose your own style of writing them. This is one of the
    conventions that emerged from TDD, and it's called **behavior-driven development**
    (**BDD**). This term BDD drives itself by specifying behaviors in order to start the
    development of any functionality. It also serves as documentation to our program.
    If you see the specification we wrote, in a way, we documented the way we can
    use functionalities. If these specs were written in Scala, we could have provided
    the method names according to the functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: Let's discuss a bit about this way of driving development by specifying the
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior driven development (BDD)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already saw the *should ... in* way of specifying the behavior of our functionality.
    There are other ways to specify the behaviors, or let's say, ensure the validity
    of our functionality. One of the example is *given**... when**... then**....*
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we specify the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Given**: This is what is available at the time of executing some functionality'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**When***:* We confront a condition that is based on the data that''s given'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Then***:* Execute the part which is expected to happen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this way, we validate the behavior of our functionality. One of the best
    practices when we write test cases for one of the functionalities is to specify
    all the possible scenarios (ideally, that's not possible, but we try our best
    to include all possibilities we can think of). These scenarios include the *empty
    case*, *unit case*, and *failure case*. Finally, we cover all the conditional
    possibilities. With these, we ensure the specifications are valid and that our
    implementations are too. These specifications serve as acceptance criteria for
    our functionality. There are lesser chances of you slipping past some important
    case. It's important to know that there's no hard and fast rule to describe our
    test cases.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits of behavior-driven development is that instead of talking
    in terms of tests, we talk in terms of specifications or scenarios. Hence, not
    just developers, but most of the business stakeholders and domain experts can
    also specify the requirements for an application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, talking about Scala's offering for frameworks or toolkits provided for
    testing, there are a bunch of them. **ScalaTest**, **ScalaCheck**, and **Specs2**
    are a few that developers are using to write tests for their code. We'll go through
    one of the mostly widely used testing tools, ScalaTest, and try to see the way
    specs are implemented using examples.
  prefs: []
  type: TYPE_NORMAL
- en: ScalaTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ScalaTest, as we mentioned, is famous for multiple styles provided to write
    specifications. Not just multiple styles, this kit also serves as a testing tool
    for **Scala.js** and even Java classes. ScalaTest covers most of the Scala ecosystem
    and allows you to choose different ways to write specifications based on the behavior
    of your functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To use ScalaTest, let''s go through some of the basic steps. We can create
    a fresh SBT project and add a dependency for **ScalaTest** via the `build.sbt` file
    or use Lightbend''s tech hub to download a simple Scala project. Let''s try out
    the second approach as it''ll give us ScalaTest already added as a dependency
    in our `build.sbt` file. Let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In your favorite browser, open: [https://developer.lightbend.com](https://developer.lightbend.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the START A PROJECT button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose Scala from project types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can name the project and click on CREATE A PROJECT FOR ME!*:*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: This will download a compressed file for you with the name you specified. Extract
    the compressed file to a specific location and open it in the IntelliJ IDE.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can open `build.sbt` to check the dependencies and project settings specified.
    Our `sbtbuild` file should look like as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, in the `libraryDependencies` settings, `scalaTest` is specified. Hence,
    we can use that. The sample project comes with some source code and test covering
    it. So, we''ll first try to run the test case. If you can see the `scalatest`
    library in the external dependencies directory, as shown in the following diagram,
    then we''re ready to execute tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If these libraries are not shown in your project structure, we can fire the `sbt
    update` command so that SBT can download all the dependencies specified. There''re
    a few more SBT commands that we will use to run our test cases. Let''s take a
    look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt test`: SBT assumes that test sources for Scala are located in the `src/test/scala`
    directory and resources like the configurations for test sources are located in
    the `src/test/resources` directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on previously described assumptions, when we fire a command described
    in the preceding text, SBT compiles all test files present in the respective locations
    and tests all of them. What if you're only concerned about specific test cases?
  prefs: []
  type: TYPE_NORMAL
- en: '`sbt testOnly`: Based on similar assumptions that we had for the `sbt test`
    command, when we fire the `testOnly` command, SBT compiles and tests only test
    cases that we specified along with the command. Consider the following example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`sbt testQuick`: Based on similar assumptions that we had for the `sbt test`
    command, when we fire the `testQuick` command, SBT compiles and tests only those
    test cases that fulfil the following conditions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failing tests from the previous runs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests that have not run yet
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests with transitive dependencies
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These are a few Scala commands we use to test our cases. Also, while testing
    our specs, we''ll use triggered execution. We initiate triggered execution by
    putting `~` before our test command. With this, SBT expects a save change, and
    saving the file again triggers a test execution. So with this, try out this command,
    assuming that we have the SBT shell opened (open the project directory, where
    `build.sbt` is located and the trigger `sbt` command) in the command prompt of
    our choice. Let''s locate our project in the SBT shell and fire the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's this `HelloSpec` class*,* located in the test directory of the project
    we downloaded. If everything works right, as it should, we'll get our tests passed
    and you'll start loving the *green* color. But if the code is red, this means
    it has failed. So, we're ready to delve into `ScalaTest`*.*
  prefs: []
  type: TYPE_NORMAL
- en: Testing in style using ScalaTest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ve tested the `HelloSpec` class*,* so we''ll take a look at the test, and
    the way it''s written. So, we can open the file `Hello` located in `src/test/scala/example`*.*
    The source code looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking a look at the code sample, we can observe a few points:'
  prefs: []
  type: TYPE_NORMAL
- en: We've imported `org.scalatest._` to bring all the traits we want to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The class definition named `HelloSpec` extends `FlatSpec` along with the mix-in
    `Matchers` class. It's a convention to name our test specifications as class name
    followed by `Spec`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The definition consists of only one *specification.* The specification states
    that "there's an object named Hello that says hello in the specified code snippet".
    That's how cool it is—the specification is written in a way any English sentence
    can be written.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The specification is written in a DSL-like manner. The language looks natural,
    and further down, the specification states that there's going to be a method call
    that returns a string equal to `hello`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The call to `shouldEqual` is a `Matcher`*.* The job of a `Matcher` is to match
    the left operand with the right operand. There are several other ways to write
    such `Matchers`, but we'll talk about those in subsequent sections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s very simple and everything''s good till now. Now, let''s take a look
    at the corresponding code file written in the location `src/main/scala/example`*.*
    Let''s look at the file named `Hello.scala`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There's this object named `Hello` according to our specification. We can make
    a call to `greeting`*,* which does nothing but print this string, `hello`*.* Well,
    this example was already available for us to observe, hence we didn't follow TDD.
    But we'll try writing something similar to this using the *test first approach*
    by specifying the behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before writing the first spec on our own, let''s follow some convention or
    one of the good practices and create an abstract class that extends `FlatSpec` 
    with `Matchers` by default so that we don''t have to extend those in every spec
    we write. We can do this by creating a spec file, and let''s name it `SomeSpec`
    and save it in the `src/test/scala/example/` directory. It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now that we've created some abstract class that extends the `FlatSpec` and `Matchers`
    classes, we are ready to follow our first step in TDD to write one failing test
    spec. Our `SomeSpec` abstract class takes a parameter named `toBeTested`, which
    is nothing but the name of the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another test spec, name it `PlayerSpec`, and save it as `src/test/scala/example`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s write the Player case class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'With this code, we can save the file, and as our test is running in the *triggered
    mode,* we can see that the test case passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll follow the same steps again. So, let''s write a few more test cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As we are clear about the behavior of our functionality, we wrote a few more
    test cases. Now, our spec includes more test clauses. We have used a few `Matchers`
    available to us. Let''s see how our tests work:'
  prefs: []
  type: TYPE_NORMAL
- en: After checking for our code, it should compile. In the next clause, we specified
    that our code should throw `FileNotFoundException` when we try to access the wrong
    file path. We used an assertion `assertThrows` to specify such behavior. Here,
    we didn't have to specify any `Matchers` since specifying an *Assertion* was enough.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next clause, we mentioned that the result of `readPlayerDataFromSource` should
    not be empty, empty as in a collection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next spec clause expects to return `None` when we try to call `parseToPlayer`
    with the wrong formatted data to a `Player` instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we expect the `parseToPlayer` method to return a player object when
    we call it with data in the correct format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s clear from our specification and clauses mentioned what we exactly want
    from our functionality. When we try to run the test case, it doesn''t compile
    because we don''t have our methods `readPlayerDataFromSource` and `parseToPlayer`.
    We can define all these methods and the corresponding code. The code should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After writing the code, we can refactor it if needed. In our case, we''ve already
    refactored the code. We may try to run the test cases if you have placed the corresponding
    file in the right path. All our test cases will pass successfully, meaning that
    they will all be green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have a some idea about the toolkit and the way TDD makes it fun to
    write software. We have used `FlatSpec` in our example. There are more of these;
    some of the frequently used Specs are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FunSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WordSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FreeSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PropSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FeatureSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These styles only differ in the way they look. If we consider our test specs
    written in an English-like language, we can say these styles consist of different
    ways in which we can write/speak our sentences. We''ve already seen `FlatSpec`*.*
    The `FunSpec` Spec uses nested clauses with keywords like `describe` and `it`.
    Let''s take a few examples of all of these Spec styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FunSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`WordSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`FreeSpec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These are a few styles that we can use to write our test specs in `ScalaTest`.
    You should definitely check out `ScalaTest`'s documentation ([http://www.scalatest.org/user_guide](http://www.scalatest.org/user_guide))
    to learn more about these styles.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen the way we made assertions and used `Matchers` to check for test
    clause validity. Let's learn more about these. We'll start with the *Assertions*
    trait*.*
  prefs: []
  type: TYPE_NORMAL
- en: Assertions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The trait* Assertions* contains assertions that we can make while specifying
    behaviors for our test cases. There are three default assertions available in
    all the style specs. These assertions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`assert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertResult`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assertThrows`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've already used `assertThrows`, and the other two can also be used in a similar
    fashion. The `assertResult` assertion expects us to provide a value that is going
    to be the result of some calculation we specify. Similarly, `assert` expects us
    to provide a Boolean predicate, which has left and right parts. Some equality
    checks can be performed on some conditions, which result in a Boolean value, based
    on which the test clause passes.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these, there are more assertions available. A few of them are `fail`,
    `cancel`, `succeed`, `intercept`, `assertCompiles`, `assertDoesNotCompile`, and
    so on. Apart from these assertions, we can also use `Matchers` to check for the
    validity of our test specifications. We've used `Matchers` along with keywords
    in a few of our example clauses.
  prefs: []
  type: TYPE_NORMAL
- en: Matchers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've already seen a few `Matchers` in place when we were going through our
    example. These `Matchers` are DSL's way of writing assertions. `ScalaTest` provides
    a rich set of assertions that work with Strings to collections. We can also write
    `Matchers` for custom classes. With these `Matchers`, we can perform the most
    basic assertions like equality checks to custom ones, where we have to deal with
    aggregations and sequencing.
  prefs: []
  type: TYPE_NORMAL
- en: 'These `Matchers` are cool, because of native language-like methods. Consider
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: There are so many ways in which you can speak a particular sentence to convey
    the same information. Similarly, using `ScalaTest`'s `Matchers`, we can specify
    some clause using different methods. `Matchers` come in handy for this.
  prefs: []
  type: TYPE_NORMAL
- en: We also know that sometimes, while writing software, we get to create mock objects
    to pass as arguments. For that, we don't have to write mock objects ourselves,
    but, there're libraries that do this for us. Let's take a look at one of them
    available in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: ScalaMock – a native library to mock objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed, at instances where we need some other services that we are
    yet to define or it's harder to create their instances since using them is a matter
    of complexity, we tend to use some Mocking framework.
  prefs: []
  type: TYPE_NORMAL
- en: '**ScalaMock** is a native framework available in Scala. To include ScalaMock
    in our project, we''ll add a dependency for it in our `build.sbt` file. Let''s
    do that. We''ll add the following line in the build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve specified the test scope, because we''re sure that `scalamock` is only
    going to be used in our test cases. After writing this dependency, we''ll perform
    an `sbt update` command by calling the `sbt update` command in the SBT shell*.*
    This update is going to add the `scalamock` dependency to our project. We can
    ensure this by taking a look at the external sources folder. There''s going to
    be a dependency with the `scalamock` name. If that''s available there, we are
    ready to mock some services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'We''ll try to mock our `PlayerService` object in our application where we want
    to show a list of a few players. Let''s specify a spec for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can perform some test case execution, which includes a call to this
    mocked function. Our test case has to somehow call this function at least once
    in order for it to pass. Mocking of objects is a usual practice we do while writing
    test cases. It relieves us of the burden of manually writing instances of several
    classes/functions, letting us concentrate on what matters, that is, validating
    our program's behavior upfront. And that's why we have such frameworks available,
    making our lives easier as developers. With this, we've come to the end of the
    final chapter of this book. Let's summarize whatever you've learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter never seemed like the last one; it was fun. After going through
    several Scala programming constructs and frameworks, you learned how to ensure
    the validity of our programs. We knew that testing the code we write is essential,
    but this new TDD style of programming was a different experience. We understood
    what TDD actually is—a design scheme driven by specifying the behaviors at the
    beginning, rather than after we complete our code. We talked about why this approach
    is good. Then, we started with the testing tools available in Scala, and learned
    about `ScalaTest`*.* We wrote the specifications and then coded for the same.
    Finally, we also took a look at the mocking framework available in Scala named
    ScalaMock.
  prefs: []
  type: TYPE_NORMAL
- en: Though this is the last chapter, we can think of what more we can do to  make
    our understanding of this language better. One of the best ways is to practice
    more; this will help us understand the concepts well, and we'll also be well versed
    with the constructs. But we'll get the real insight when we go about learning functional
    programming, because that's where all the magic is. Trying to think in a functional
    way, where we do not mutate stuff it, is one of the most important aspects. Finally,
    let's thank the wonderful and ever growing Scala community. Join the community,
    ask questions, and contribute in your own way.
  prefs: []
  type: TYPE_NORMAL
