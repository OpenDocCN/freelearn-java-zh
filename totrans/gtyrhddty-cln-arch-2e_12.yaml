- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Enforcing Architecture Boundaries
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强制执行架构边界
- en: We talked a lot about architecture in previous chapters and it feels good to
    have a target architecture to guide us in our decisions on how to craft code and
    where to put it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了很多关于架构的内容，现在有一个目标架构来指导我们如何编写代码以及将其放置在哪里，感觉很好。
- en: In every above-playsize software project, however, architecture tends to erode
    over time. Boundaries between layers weaken, code becomes harder to test, and
    we generally need more and more time to implement new features.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在每一个大型软件项目中，架构往往会随着时间的推移而侵蚀。层之间的边界减弱，代码变得难以测试，我们通常需要越来越多的时间来实现新功能。
- en: In this chapter, we’ll discuss some measures that we can take to enforce the
    boundaries within our architecture and thus fight architecture erosion.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论我们可以采取的一些措施来强制执行架构内的边界，从而对抗架构侵蚀。
- en: Boundaries and dependencies
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边界和依赖关系
- en: Before we talk about different ways of enforcing architecture boundaries, let’s
    discuss where the boundaries lie within our architecture and what **enforcing
    a boundary** actually means.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论强制执行架构边界的不同方法之前，让我们讨论架构中的边界在哪里，以及**强制执行边界**实际上意味着什么。
- en: "![Figure 12.1 – Enforcing architecture boundaries means enforcing that dependencies\
    \ point in the right direction\uFEFF (dashed arrows mark dependencies that are\
    \ not allowed according to our architecture\uFEFF)](img/Figure_12.1._B19916.jpg)"
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 强制执行架构边界意味着确保依赖关系指向正确的方向（虚线箭头表示根据我们的架构不允许的依赖关系）](img/Figure_12.1._B19916.jpg)'
- en: Figure 12.1 – Enforcing architecture boundaries means enforcing that dependencies
    point in the right direction (dashed arrows mark dependencies that are not allowed
    according to our architecture)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 强制执行架构边界意味着确保依赖关系指向正确的方向（虚线箭头表示根据我们的架构不允许的依赖关系）
- en: '*Figure 12**.1* shows how the elements of our Hexagonal Architecture might
    be distributed across four layers, resembling the generic Clean Architecture approach
    introduced in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029), *Inverting Dependencies*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.1* 展示了我们的六边形架构元素可能分布在四个层次上，类似于在[*第3章*](B19916_03.xhtml#_idTextAnchor029)中介绍的通用Clean
    Architecture方法，“反转依赖”。'
- en: The innermost layer contains domain entities and domain services. The application
    layer around it may access those entities and services to implement a use case,
    usually through an application service. Adapters access those services through
    incoming ports or are being accessed by those services through outgoing ports.
    Finally, the configuration layer contains factories that create adapter and service
    objects and provides them to a dependency injection mechanism.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最内层包含领域实体和领域服务。围绕它的应用层可以访问这些实体和服务以实现一个用例，通常是通过应用服务。适配器通过输入端口访问这些服务，或者通过输出端口被这些服务访问。最后，配置层包含创建适配器和服务对象的工厂，并将它们提供给依赖注入机制。
- en: In the preceding figure, our architecture boundaries become pretty clear. There
    is a boundary between each layer and its next inward and outward neighbor. According
    to the Dependency Rule, dependencies that cross such a layer boundary must always
    point inward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们的架构边界变得非常清晰。每一层与其相邻的内层和外层之间都有一个边界。根据依赖规则，跨越此类层边界的依赖关系必须始终指向内层。
- en: This chapter is about ways to enforce the Dependency Rule. We want to make sure
    that there are no illegal dependencies that point in the wrong direction (dashed
    arrows in the figure).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍如何强制执行依赖规则。我们希望确保没有非法的依赖关系指向错误的方向（图中用虚线箭头表示）。
- en: Visibility modifiers
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可见性修饰符
- en: 'Let’s start with the most basic tool that object-oriented languages in general,
    and Java in particular, provide us with to enforce boundaries: **visibility modifiers**.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从面向对象语言（特别是Java）提供给我们强制执行边界的最基本工具开始：**可见性修饰符**。
- en: Visibility modifiers have been a topic in almost every entry-level job interview
    I have conducted in the last couple of years. I would ask the interviewee which
    visibility modifiers Java provides and what their differences are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 可见性修饰符在过去几年中我进行的几乎所有入门级职位面试中都是一个话题。我会问应聘者Java提供了哪些可见性修饰符以及它们之间的区别是什么。
- en: Most of the interviewees only list the `public`, `protected`, and `private`
    modifiers. Only a few of them know the `default`) modifier. This is always a welcome
    opportunity for me to ask some questions about why such a visibility modifier
    would make sense in order to find out whether the interviewee can abstract from
    their previous knowledge.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数受访者只列出`public`、`protected`和`private`修饰符。只有少数人知道`default`修饰符。这总是我询问一些关于为什么这样的可见性修饰符有意义的绝佳机会，以便找出受访者是否能够从他们以前的知识中抽象出来。
- en: So, why is the package-private modifier such an important modifier? Because
    it allows us to use Java packages to group classes into cohesive “modules.” Classes
    within such a module can access each other, but cannot be accessed from outside
    of the package. We can then choose to make specific classes public to act as entry
    points to the module. This reduces the risk of accidentally violating the Dependency
    Rule by introducing a dependency that points in the wrong direction.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么包私有修饰符如此重要呢？因为它允许我们使用Java包将类分组到紧密的“模块”中。此类模块内的类可以相互访问，但不能从包外部访问。然后我们可以选择将特定的类设置为公共的，作为模块的入口点。这减少了因引入指向错误方向的依赖而意外违反依赖规则的风险。
- en: 'Let’s have another look at the package structure discussed in [*Chapter 4*](B19916_04.xhtml#_idTextAnchor037),
    *Organizing Code*, with visibility modifiers in mind:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次看看[*第4章*](B19916_04.xhtml#_idTextAnchor037)中讨论的包结构，即*组织代码*，考虑到可见性修饰符：
- en: '![](img/code-12.1.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![代码-12.1.jpg](img/code-12.1.jpg)'
- en: We can make the classes in the `persistence` package package-private (marked
    with `o` in the tree above) because they don’t need to be accessed by the outside
    world. The persistence adapter is accessed through the output ports it implements.
    For the same reason, we can make the `SendMoneyService` class package-private.
    Dependency injection mechanisms usually use reflection to instantiate classes,
    so they will still be able to instantiate those classes even if they’re package-private.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`persistence`包中的类设置为包私有（在上述树中用`o`标记），因为它们不需要被外部世界访问。持久性适配器通过其实现的输出端口进行访问。出于同样的原因，我们也可以将`SendMoneyService`类设置为包私有。依赖注入机制通常使用反射来实例化类，因此即使它们是包私有的，它们仍然能够实例化这些类。
- en: With Spring, this approach only works if we use the classpath scanning approach
    discussed in [*Chapter 10*](B19916_10.xhtml#_idTextAnchor089), *Assembling the
    Application*, however, since the other approaches require us to create instances
    of those objects ourselves, which requires public access.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Spring，这种方法只有在使用第[*第10章*](B19916_10.xhtml#_idTextAnchor089)中讨论的类路径扫描方法时才有效，即*组装应用程序*，然而，因为其他方法要求我们自行创建这些对象的实例，这需要公共访问。
- en: 'The rest of the classes in the example have to be public (marked with `+`)
    as defined by our architecture: the `domain` package needs to be accessible by
    the other layers and the `application` layer needs to be accessible by the `web`
    and `persistence` adapters.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的其余类必须根据我们的架构定义为公共的（用`+`标记）：`domain`包需要被其他层访问，而`application`层需要被`web`和`persistence`适配器访问。
- en: The package-private modifier is awesome for small modules with no more than
    a handful of classes. Once a package reaches a certain number of classes, however,
    it grows confusing to have so many classes in the same package. In this case,
    I like to create sub-packages to make the code easier to find (and, I admit, to
    satisfy my sense of aesthetics). This is where the package-private modifier fails
    to deliver, since Java treats sub-packages as different packages and we cannot
    access a package-private member of a sub-package. So, members in sub-packages
    must be `public`, exposing them to the outside world and thus making our architecture
    vulnerable to illegal dependencies.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对于只有几个类的简单模块，包私有修饰符非常出色。然而，一旦包中的类达到一定数量，那么在同一个包中有这么多类就会变得令人困惑。在这种情况下，我喜欢创建子包，以便更容易找到代码（并且，我必须承认，这满足了我的审美感）。这就是包私有修饰符无法发挥作用的地方，因为Java将子包视为不同的包，我们无法访问子包的包私有成员。因此，子包中的成员必须是`public`的，这样它们就会暴露给外部世界，从而使我们的架构容易受到非法依赖的影响。
- en: Post-compile fitness function
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编译后适应度函数
- en: As soon as we use the public modifier on a class, the compiler will let any
    other class use it, even if the direction of the dependency points in the wrong
    direction according to our architecture.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在类上使用公共修饰符，编译器就会允许任何其他类使用它，即使根据我们的架构，依赖关系的方向指向错误的方向。
- en: Since the compiler won’t help us out in these cases, we have to find other means
    to check that the Dependency Rule isn’t violated.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器在这些情况下不会帮助我们，我们必须找到其他方法来检查依赖规则没有被违反。
- en: One way is to introduce a **fitness function** – a function that takes our architecture
    as input and determines its fitness in regard to a specific aspect. In our case,
    *fitness* is defined as *the Dependency Rule is* *not violated*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是引入一个**适应度函数**——一个接受我们的架构作为输入并确定其在特定方面的适应度的函数。在我们的情况下，“适应度”定义为“依赖规则*未被违反*”。
- en: Ideally, a compiler runs a fitness function for us during compilation, but,
    lacking that, we can run such a function at runtime, after the code has already
    been compiled. Such runtime checks are best run during automated tests within
    a continuous integration build.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，编译器在编译过程中为我们运行一个适应度函数，但如果没有这个功能，我们可以在代码编译后运行此函数。这种运行时检查最好在持续集成构建的自动化测试中进行。
- en: A tool that supports this kind of architectural fitness function for Java is
    **ArchUnit**.[1](#footnote-039) Among other things, ArchUnit provides an API to
    check whether dependencies point in the expected direction. If it finds a violation,
    it will throw an exception. It’s best run from within a test based on a unit testing
    framework such as JUnit, making the test fail in case of a dependency violation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此类Java架构适应度函数的工具是**ArchUnit**。[1](#footnote-039) 除了其他功能外，ArchUnit提供了一个API来检查依赖是否指向预期的方向。如果它发现违规，它将抛出一个异常。最好在基于JUnit等单元测试框架的测试中运行，以便在依赖违规的情况下使测试失败。
- en: '[1](#footnote-039-backlink) ArchUnit: https://github.com/TNG/ArchUnit.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[1](#footnote-039-backlink) ArchUnit: https://github.com/TNG/ArchUnit.'
- en: 'With ArchUnit, we can now check the dependencies between our layers, assuming
    that each layer has its own package, as defined in the package structure discussed
    in the previous section. For example, we can check that there is no dependency
    from the domain model on anything outside the domain model:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用ArchUnit，我们现在可以检查我们各层之间的依赖关系，假设每一层都有自己的包，正如前一小节中讨论的包结构所定义的。例如，我们可以检查领域模型没有对外部任何内容的依赖：
- en: '![](img/code-12.2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/code-12.2.jpg)'
- en: This rule validates the dependency rules visualized in *Figure 12**.2*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则验证了*图12*.2中可视化的依赖规则。
- en: '![](img/Figure_12.2._B19916.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/Figure_12.2._B19916.jpg)'
- en: Figure 12.2 – Our domain model may access itself and some library packages,
    but it may not access code in any other packages, for example, the packages containing
    our adapters (inspired by the diagrams at https://www.archunit.org/use-cases)
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 我们的领域模型可能访问自身和一些库包，但它可能不能访问任何其他包中的代码，例如包含我们的适配器的包（受https://www.archunit.org/use-cases中的图表启发）
- en: The problem with the preceding rule is that if we use some library code in the
    domain model, we have to add an exception to this rule for every dependency we
    introduce (like I did with `lombok` and `java` in the example). In [*Chapter 14*](B19916_14.xhtml#_idTextAnchor118),
    *A Component-Based Approach to Software Architecture*, we will see a rule that
    doesn’t have this problem.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前述规则的问题是，如果我们使用领域模型中的某些库代码，我们必须为每个引入的依赖（例如，我在示例中用`lombok`和`java`）添加一个例外。在[*第14章*](B19916_14.xhtml#_idTextAnchor118)《基于组件的软件架构方法》中，我们将看到一个没有这个问题的规则。
- en: 'With a little work, we can even create a kind of **domain-specific language**
    (**DSL**) on top of the ArchUnit API that allows us to specify all relevant packages
    within our Hexagonal Architecture and then automatically check whether all dependencies
    between those packages point in the right direction:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一些工作，我们甚至可以在ArchUnit API之上创建一种**领域特定语言**（**DSL**），允许我们指定六边形架构中的所有相关包，然后自动检查这些包之间的所有依赖是否指向正确的方向：
- en: '![](img/code-12.3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/code-12.3.jpg)'
- en: In the preceding code example, we first specify the parent package of our application.
    We then go on to specify the sub-packages for the domain, adapter, application,
    and configuration layers. The final call to `check()` will then execute a set
    of checks, verifying that the package dependencies are valid according to the
    Dependency Rule. The code for this Hexagonal Architecture DSL is available on
    GitHub if you would like to play around with it.[2](#footnote-038)
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中，我们首先指定应用程序的父包。然后我们继续指定领域、适配器、应用程序和配置层的子包。最后的`check()`调用将执行一系列检查，验证包依赖是否根据依赖规则有效。如果您想尝试这个六边形架构DSL的代码，它可以在GitHub上找到。[2](#footnote-038)
- en: '[2](#footnote-038-backlink) Hexagonal Architecture DSL for ArchUnit: [https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java](https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java).'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[2](#footnote-038-backlink) Hexagonal Architecture DSL for ArchUnit: [https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java](https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java).'
- en: While post-compile checks like the previous one can be a great help in fighting
    illegal dependencies, they are not fail-safe. If we misspell the package name
    `buckpal` in the preceding code example, for example, the test will find no classes
    and thus no dependency violations. A single typo, or, more importantly, a single
    refactoring renaming a package, can make the whole test useless. We should strive
    to make these tests refactoring-safe, or at least make them fail when a refactoring
    has broken them. In the preceding example, we can fail the test when one of the
    mentioned packages does not exist, for example (because it was renamed).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像之前的编译后检查这样的检查可以在对抗非法依赖方面大有帮助，但它们并不是万无一失的。例如，如果我们把前面的代码示例中的包名`buckpal`拼写错误，测试将找不到任何类，因此没有发现依赖违规。一个简单的拼写错误，或者更重要的是，一个重命名包的重构，可以使整个测试变得毫无用处。我们应该努力使这些测试重构安全，或者至少在重构破坏了它们时使它们失败。在前面的例子中，当提到的某个包不存在时，例如（因为它被重命名了），我们可以使测试失败。
- en: Build artifacts
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建工件
- en: Until now, our only tool for demarcating architecture boundaries within our
    code base was packages. All of our code has been part of the same monolithic build
    artifact.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们用于在代码库内划分架构边界的唯一工具是包。我们所有的代码都一直是同一个单体构建工件的一部分。
- en: A build artifact is the result of a (hopefully automated) build process. The
    most popular build tools in the Java world are currently Maven and Gradle. So,
    until now, imagine we had a single Maven or Gradle build script and we could call
    Maven or Gradle to compile, test, and package the code of our application into
    a single JAR file.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 构建工件是（希望是自动化）构建过程的结果。在Java世界中，目前最流行的构建工具是Maven和Gradle。因此，到目前为止，假设我们只有一个Maven或Gradle构建脚本，并且我们可以调用Maven或Gradle来编译、测试和打包我们应用程序的代码到一个单一的JAR文件中。
- en: A main feature of build tools is dependency resolution. To transform a certain
    code base into a build artifact, a build tool first checks whether all the artifacts
    the code base depends on are available. If not, it tries to load them from an
    artifact repository. If this fails, the build will fail with an error before even
    trying to compile the code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 构建工具的一个主要功能是依赖关系解析。为了将某个代码库转换为构建工件，构建工具首先检查代码库所依赖的所有工件是否可用。如果不可用，它尝试从工件仓库中加载它们。如果这失败了，构建将在尝试编译代码之前因为错误而失败。
- en: We can leverage this to enforce the dependencies (and thus enforce the boundaries)
    between the modules and layers of our architecture. For each such module or layer,
    we create a separate build module with its own code base and its own build artifact
    (JAR file) as a result. In the build script of each module, we specify only those
    dependencies to other modules that are allowed according to our architecture.
    Developers can no longer inadvertently create illegal dependencies because the
    classes are not even available on the classpath and they would run into compile
    errors.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以利用这一点来强制执行架构模块和层之间的依赖关系（以及因此强制执行边界）。对于这样的每个模块或层，我们创建一个独立的构建模块，它有自己的代码库和自己的构建工件（JAR文件）作为结果。在每个模块的构建脚本中，我们只指定那些根据我们的架构允许的其他模块的依赖关系。开发者不能再无意中创建非法依赖，因为类甚至不在类路径上，他们将会遇到编译错误。
- en: '![Figure 12.3 – Different ways of dividing our architecture into multiple build
    artifacts to prohibit illegal dependencies](img/Figure_12.3._B19916.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 将我们的架构划分为多个构建工件的不同方式以禁止非法依赖](img/Figure_12.3._B19916.jpg)'
- en: Figure 12.3 – Different ways of dividing our architecture into multiple build
    artifacts to prohibit illegal dependencies
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 将我们的架构划分为多个构建工件的不同方式以禁止非法依赖
- en: '*Figure 12**.3* shows an incomplete set of options to divide our architecture
    into separate build artifacts.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.3* 展示了将我们的架构划分为单独构建工件的不完整选项集。'
- en: Starting on the left, we see a basic three-module build with a separate build
    artifact for the configuration, adapter, and application layers. The `configuration`
    module may access the `adapters` module, which in turn may access the `application`
    module. The configuration module may also access the application module due to
    the implicit, transitive dependency between them. The adapters module contains
    the `web` adapter as well as the `persistence` adapter. This means that the build
    tool will not prohibit dependencies between those adapters. While dependencies
    between those adapters are not strictly forbidden by the Dependency Rule (since
    both adapters are within the same outer layer), in most cases, it’s sensible to
    keep adapters isolated from each other. After all, we usually don’t want changes
    in the persistence layer to leak into the web layer and vice versa (remember the
    Single Responsibility Principle!). The same holds true for other types of adapters,
    for example adapters connecting our application to a certain third-party API.
    We don’t want details of that API leaking into other adapters by adding accidental
    dependencies between adapters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从左侧开始，我们看到一个基本的三个模块构建，包括配置、适配器和应用层的独立构建工件。`配置`模块可以访问`适配器`模块，而`适配器`模块又可以访问`应用`模块。由于它们之间存在隐式的传递依赖，`配置`模块也可以访问`应用`模块。`适配器`模块包含`web`适配器和`持久化`适配器。这意味着构建工具不会禁止这些适配器之间的依赖关系。虽然根据依赖规则，这些适配器之间的依赖关系并不是严格禁止的（因为这两个适配器都在同一个外部层中），但在大多数情况下，保持适配器相互隔离是明智的。毕竟，我们通常不希望持久化层的变化泄露到网络层，反之亦然（记住单一职责原则！）。同样的原则也适用于其他类型的适配器，例如连接我们的应用程序到某个第三方API的适配器。我们不希望通过在适配器之间添加意外的依赖关系，让该API的细节泄露到其他适配器中。
- en: Thus, we may split the single adapters module into multiple build modules, one
    for each adapter, as shown in the second column of *Figure 12**.3*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将单个适配器模块拆分为多个构建模块，每个适配器一个，如*图12**.3*的第二列所示。
- en: Next, we could decide to split up the application module further. It currently
    contains the incoming and outgoing ports to our application, the services that
    implement or use those ports, and the domain entities that should contain much
    of our domain logic.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们还可以决定进一步拆分应用模块。它目前包含传入和传出端口到我们的应用程序，实现或使用这些端口的业务逻辑，以及应该包含大部分领域逻辑的领域实体。
- en: If we decide that our domain entities are not to be used as transfer objects
    within our ports (i.e., we want to disallow the *No Mapping* strategy from [*Chapter
    9*](B19916_09.xhtml#_idTextAnchor081), *Mapping between Boundaries*), we can apply
    the Dependency Inversion Principle and pull out a separate `api` module that contains
    only the port interfaces (the third column in *Figure 12**.3*). The `adapter`
    modules and the `application` module may access the `api` module, but not the
    other way around. The `api` module does not have access to the domain entities
    and cannot use them within the port interfaces. Also, the adapters no longer have
    direct access to the entities and services, so they must go through the ports.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们决定我们的领域实体不应用于我们的端口内作为传输对象（即，我们希望禁止从[*第9章*](B19916_09.xhtml#_idTextAnchor081)，*边界之间的映射*）中提到的*无映射*策略），我们可以应用依赖倒置原则，并拉出一个单独的`api`模块，该模块只包含端口接口（*图12**.3*中的第三列）。`适配器`模块和`应用`模块可以访问`api`模块，但反之则不行。`api`模块无法访问领域实体，也不能在端口接口中使用它们。此外，适配器也不再直接访问实体和服务，因此它们必须通过端口进行访问。
- en: We can even go a step further and split the `api` module in two, one part containing
    only the incoming ports and the other part only containing the outgoing ports
    (the fourth column in *Figure 12**.3*). This way, we can make it very clear whether
    a certain adapter is an incoming adapter or an outgoing adapter by declaring a
    dependency only on the input or the outgoing ports.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以更进一步，将`api`模块拆分为两个部分，一部分只包含传入端口，另一部分只包含传出端口（*图12**.3*中的第四列）。这样，我们通过仅在输入或传出端口上声明依赖关系，就可以清楚地表明某个适配器是传入适配器还是传出适配器。
- en: Also, we could split the application module even further, creating a module
    containing only the services and another containing only the domain model. This
    ensures that the domain model doesn’t access the services, and it would allow
    other applications (with different use cases and thus different services) to use
    the same domain model by simply declaring a dependency on the domain build artifact.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们甚至可以将应用程序模块进一步拆分，创建一个只包含服务的模块，另一个只包含领域模型。这确保了领域模型不会访问服务，并且它允许其他应用程序（具有不同的用例和因此不同的服务）通过简单地声明对领域构建实体的依赖来使用相同的领域模型。
- en: '*Figure 12**.3* illustrates that there are a lot of different ways to divide
    an application into build modules, and there are of course more than just the
    four ways depicted in the figure. The gist is that the finer we cut our modules,
    the stronger we can control dependencies between them. The finer we cut, however,
    the more mapping we have to do between those modules, enforcing one of the mapping
    strategies introduced in [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081), *Mapping*
    *between Boundaries*.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12**.3* 展示了将应用程序划分为构建模块的许多不同方法，当然，图中所描述的不仅仅是四种方法。关键是，我们划分的模块越细，我们就能越强有力地控制它们之间的依赖关系。然而，划分得越细，我们之间就需要进行更多的映射，强制执行在
    [*第 9 章*](B19916_09.xhtml#_idTextAnchor081) 中介绍的一种映射策略，即 *边界之间的映射*。'
- en: 'Besides that, demarcating architecture boundaries with build modules has a
    number of advantages over using simple packages as boundary:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用构建模块来划分架构边界与使用简单的包作为边界相比，具有许多优势：
- en: First, build tools absolutely hate circular dependencies. Circular dependencies
    are bad because a change in one module within the circle would potentially mean
    a change in all other modules within the circle, which is a violation of the Single
    Responsibility Principle. Build tools don’t allow circular dependencies because
    they would run into an endless loop while trying to resolve them. Thus, we can
    be sure that there are no circular dependencies between our build modules.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建工具绝对讨厌循环依赖。循环依赖很糟糕，因为循环内某个模块的更改可能会意味着循环内所有其他模块的更改，这违反了单一职责原则。构建工具不允许循环依赖，因为它们在尝试解决它们时会陷入无限循环。因此，我们可以确信我们的构建模块之间没有循环依赖。
- en: The Java compiler, on the other hand, doesn’t care at all if there is a circular
    dependency between two or more packages.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，Java 编译器根本不在乎两个或更多包之间是否存在循环依赖。
- en: 'Second, build modules allow isolated code changes within certain modules without
    having to take the other modules into consideration. Imagine we have to do a major
    refactoring in the application layer that causes temporary compile errors in a
    certain adapter. If the adapters and application layer are within the same build
    module, some IDEs will insist that all compile errors in the adapters must be
    fixed before we can run the tests in the application layer, even though the tests
    don’t need the adapters to compile. If the application layer is in its own build
    module, however, the IDE won’t care about the adapters at the moment, and we could
    run the application layer tests at will. The same goes for running a build process
    with Maven or Gradle: if both layers are in the same build module, the build would
    fail due to compile errors in either layer.'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二，构建模块允许在某些模块内进行独立的代码更改，而无需考虑其他模块。想象一下，如果我们必须在应用程序层进行重大重构，这会导致某个适配器暂时出现编译错误。如果适配器和应用程序层在同一个构建模块中，一些
    IDE 会坚持要求在我们可以运行应用程序层的测试之前，必须修复适配器中的所有编译错误，即使测试不需要适配器来编译。然而，如果应用程序层在其自己的构建模块中，IDE
    就不会关心适配器，我们可以随意运行应用程序层的测试。对于使用 Maven 或 Gradle 运行构建过程来说，也是如此：如果两个层都在同一个构建模块中，构建会因为任一层的编译错误而失败。
- en: So, multiple build modules allow isolated changes in each module. We could even
    choose to put each module into its own code repository, allowing different teams
    to maintain different modules.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，多个构建模块允许每个模块进行独立的更改。我们甚至可以选择将每个模块放入其自己的代码仓库中，允许不同的团队维护不同的模块。
- en: Finally, with each inter-module dependency explicitly declared in a build script,
    adding a new dependency becomes a conscious act instead of an accident. A developer
    who needs access to a certain class they currently cannot access will hopefully
    give some thought to the question if the dependency is really reasonable before
    adding it to the build script.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在构建脚本中明确声明每个模块间的依赖关系后，添加新依赖关系就变成了一种有意识的行为，而不是意外。一个需要访问他们目前无法访问的类的开发者，在将其添加到构建脚本之前，可能会对依赖关系是否真正合理这个问题进行一些思考。
- en: These advantages come with the added cost of having to maintain a build script,
    though, so the architecture should be somewhat stable before splitting it into
    different build modules.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这些优势伴随着维护构建脚本的额外成本，因此，在将其拆分为不同的构建模块之前，架构应该相对稳定。
- en: Also, build modules tend to be less supple to change over time. Once chosen,
    we tend to stick with the modules we have initially defined. If the slicing of
    modules wasn’t right from the start, we are less likely to correct it later because
    of the added effort of refactoring. Refactoring is easier when all the code lies
    within a single build module.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，构建模块随着时间的推移往往不太灵活。一旦选择，我们往往会坚持最初定义的模块。如果模块的切割一开始就不正确，由于重构的额外努力，我们不太可能后来纠正它。当所有代码都位于单个构建模块内时，重构更容易。
- en: How does this help me build maintainable software?
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这如何帮助我构建可维护的软件？
- en: Software architecture is basically all about managing dependencies between architecture
    elements. If the dependencies become a big ball of mud, the architecture becomes
    a big ball of mud.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 软件架构基本上是关于管理架构元素之间的依赖关系。如果依赖关系变得一团糟，架构也会变得一团糟。
- en: So, to preserve the architecture over time, we need to continually make sure
    that dependencies point in the right direction.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了随着时间的推移保持架构，我们需要不断确保依赖关系指向正确的方向。
- en: When producing new code or refactoring existing code, we should keep the package
    structure in mind and use package-private visibility when possible, to avoid dependencies
    to classes that should not be accessed from outside the package.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在生成新代码或重构现有代码时，我们应该牢记包结构，并在可能的情况下使用包私有可见性，以避免对不应从包外部访问的类产生依赖。
- en: If we need to enforce architecture boundaries within a single build module,
    and the package-private modifier doesn’t work because the package structure won’t
    allow it, we can make use of post-compile tools such as ArchUnit.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要在单个构建模块内强制执行架构边界，并且包私有修饰符不起作用，因为包结构不允许这样做，我们可以利用后编译工具，如ArchUnit。
- en: Any time we feel that the architecture is stable enough, we should extract architecture
    elements into their own build modules because this gives explicit control over
    the dependencies.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们觉得架构足够稳定时，我们应该将架构元素提取到它们自己的构建模块中，因为这提供了对依赖关系的明确控制。
- en: All three approaches can be combined to enforce architecture boundaries and
    thus keep the code base maintainable over time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这三种方法可以结合起来强制执行架构边界，从而随着时间的推移保持代码库的可维护性。
- en: 'In the next chapter, we’ll continue to explore architecture boundaries, but
    from a different perspective: we’ll think about how to manage multiple domains
    (or bounded contexts) in the same application, while keeping the boundaries between
    them distinct.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨架构边界，但从一个不同的角度：我们将思考如何在同一应用程序中管理多个领域（或边界上下文），同时保持它们之间的界限清晰。
