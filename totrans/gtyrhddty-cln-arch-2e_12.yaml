- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enforcing Architecture Boundaries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talked a lot about architecture in previous chapters and it feels good to
    have a target architecture to guide us in our decisions on how to craft code and
    where to put it.
  prefs: []
  type: TYPE_NORMAL
- en: In every above-playsize software project, however, architecture tends to erode
    over time. Boundaries between layers weaken, code becomes harder to test, and
    we generally need more and more time to implement new features.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss some measures that we can take to enforce the
    boundaries within our architecture and thus fight architecture erosion.
  prefs: []
  type: TYPE_NORMAL
- en: Boundaries and dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we talk about different ways of enforcing architecture boundaries, let’s
    discuss where the boundaries lie within our architecture and what **enforcing
    a boundary** actually means.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 12.1 – Enforcing architecture boundaries means enforcing that dependencies\
    \ point in the right direction\uFEFF (dashed arrows mark dependencies that are\
    \ not allowed according to our architecture\uFEFF)](img/Figure_12.1._B19916.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Enforcing architecture boundaries means enforcing that dependencies
    point in the right direction (dashed arrows mark dependencies that are not allowed
    according to our architecture)
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.1* shows how the elements of our Hexagonal Architecture might
    be distributed across four layers, resembling the generic Clean Architecture approach
    introduced in [*Chapter 3*](B19916_03.xhtml#_idTextAnchor029), *Inverting Dependencies*.'
  prefs: []
  type: TYPE_NORMAL
- en: The innermost layer contains domain entities and domain services. The application
    layer around it may access those entities and services to implement a use case,
    usually through an application service. Adapters access those services through
    incoming ports or are being accessed by those services through outgoing ports.
    Finally, the configuration layer contains factories that create adapter and service
    objects and provides them to a dependency injection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, our architecture boundaries become pretty clear. There
    is a boundary between each layer and its next inward and outward neighbor. According
    to the Dependency Rule, dependencies that cross such a layer boundary must always
    point inward.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about ways to enforce the Dependency Rule. We want to make sure
    that there are no illegal dependencies that point in the wrong direction (dashed
    arrows in the figure).
  prefs: []
  type: TYPE_NORMAL
- en: Visibility modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s start with the most basic tool that object-oriented languages in general,
    and Java in particular, provide us with to enforce boundaries: **visibility modifiers**.'
  prefs: []
  type: TYPE_NORMAL
- en: Visibility modifiers have been a topic in almost every entry-level job interview
    I have conducted in the last couple of years. I would ask the interviewee which
    visibility modifiers Java provides and what their differences are.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the interviewees only list the `public`, `protected`, and `private`
    modifiers. Only a few of them know the `default`) modifier. This is always a welcome
    opportunity for me to ask some questions about why such a visibility modifier
    would make sense in order to find out whether the interviewee can abstract from
    their previous knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: So, why is the package-private modifier such an important modifier? Because
    it allows us to use Java packages to group classes into cohesive “modules.” Classes
    within such a module can access each other, but cannot be accessed from outside
    of the package. We can then choose to make specific classes public to act as entry
    points to the module. This reduces the risk of accidentally violating the Dependency
    Rule by introducing a dependency that points in the wrong direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have another look at the package structure discussed in [*Chapter 4*](B19916_04.xhtml#_idTextAnchor037),
    *Organizing Code*, with visibility modifiers in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-12.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can make the classes in the `persistence` package package-private (marked
    with `o` in the tree above) because they don’t need to be accessed by the outside
    world. The persistence adapter is accessed through the output ports it implements.
    For the same reason, we can make the `SendMoneyService` class package-private.
    Dependency injection mechanisms usually use reflection to instantiate classes,
    so they will still be able to instantiate those classes even if they’re package-private.
  prefs: []
  type: TYPE_NORMAL
- en: With Spring, this approach only works if we use the classpath scanning approach
    discussed in [*Chapter 10*](B19916_10.xhtml#_idTextAnchor089), *Assembling the
    Application*, however, since the other approaches require us to create instances
    of those objects ourselves, which requires public access.
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the classes in the example have to be public (marked with `+`)
    as defined by our architecture: the `domain` package needs to be accessible by
    the other layers and the `application` layer needs to be accessible by the `web`
    and `persistence` adapters.'
  prefs: []
  type: TYPE_NORMAL
- en: The package-private modifier is awesome for small modules with no more than
    a handful of classes. Once a package reaches a certain number of classes, however,
    it grows confusing to have so many classes in the same package. In this case,
    I like to create sub-packages to make the code easier to find (and, I admit, to
    satisfy my sense of aesthetics). This is where the package-private modifier fails
    to deliver, since Java treats sub-packages as different packages and we cannot
    access a package-private member of a sub-package. So, members in sub-packages
    must be `public`, exposing them to the outside world and thus making our architecture
    vulnerable to illegal dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Post-compile fitness function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as we use the public modifier on a class, the compiler will let any
    other class use it, even if the direction of the dependency points in the wrong
    direction according to our architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Since the compiler won’t help us out in these cases, we have to find other means
    to check that the Dependency Rule isn’t violated.
  prefs: []
  type: TYPE_NORMAL
- en: One way is to introduce a **fitness function** – a function that takes our architecture
    as input and determines its fitness in regard to a specific aspect. In our case,
    *fitness* is defined as *the Dependency Rule is* *not violated*.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, a compiler runs a fitness function for us during compilation, but,
    lacking that, we can run such a function at runtime, after the code has already
    been compiled. Such runtime checks are best run during automated tests within
    a continuous integration build.
  prefs: []
  type: TYPE_NORMAL
- en: A tool that supports this kind of architectural fitness function for Java is
    **ArchUnit**.[1](#footnote-039) Among other things, ArchUnit provides an API to
    check whether dependencies point in the expected direction. If it finds a violation,
    it will throw an exception. It’s best run from within a test based on a unit testing
    framework such as JUnit, making the test fail in case of a dependency violation.
  prefs: []
  type: TYPE_NORMAL
- en: '[1](#footnote-039-backlink) ArchUnit: https://github.com/TNG/ArchUnit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With ArchUnit, we can now check the dependencies between our layers, assuming
    that each layer has its own package, as defined in the package structure discussed
    in the previous section. For example, we can check that there is no dependency
    from the domain model on anything outside the domain model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-12.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This rule validates the dependency rules visualized in *Figure 12**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_12.2._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Our domain model may access itself and some library packages,
    but it may not access code in any other packages, for example, the packages containing
    our adapters (inspired by the diagrams at https://www.archunit.org/use-cases)
  prefs: []
  type: TYPE_NORMAL
- en: The problem with the preceding rule is that if we use some library code in the
    domain model, we have to add an exception to this rule for every dependency we
    introduce (like I did with `lombok` and `java` in the example). In [*Chapter 14*](B19916_14.xhtml#_idTextAnchor118),
    *A Component-Based Approach to Software Architecture*, we will see a rule that
    doesn’t have this problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a little work, we can even create a kind of **domain-specific language**
    (**DSL**) on top of the ArchUnit API that allows us to specify all relevant packages
    within our Hexagonal Architecture and then automatically check whether all dependencies
    between those packages point in the right direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/code-12.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding code example, we first specify the parent package of our application.
    We then go on to specify the sub-packages for the domain, adapter, application,
    and configuration layers. The final call to `check()` will then execute a set
    of checks, verifying that the package dependencies are valid according to the
    Dependency Rule. The code for this Hexagonal Architecture DSL is available on
    GitHub if you would like to play around with it.[2](#footnote-038)
  prefs: []
  type: TYPE_NORMAL
- en: '[2](#footnote-038-backlink) Hexagonal Architecture DSL for ArchUnit: [https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java](https://github.com/thombergs/buckpal/blob/master/src/test/java/io/reflectoring/buckpal/archunit/HexagonalArchitecture.java).'
  prefs: []
  type: TYPE_NORMAL
- en: While post-compile checks like the previous one can be a great help in fighting
    illegal dependencies, they are not fail-safe. If we misspell the package name
    `buckpal` in the preceding code example, for example, the test will find no classes
    and thus no dependency violations. A single typo, or, more importantly, a single
    refactoring renaming a package, can make the whole test useless. We should strive
    to make these tests refactoring-safe, or at least make them fail when a refactoring
    has broken them. In the preceding example, we can fail the test when one of the
    mentioned packages does not exist, for example (because it was renamed).
  prefs: []
  type: TYPE_NORMAL
- en: Build artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, our only tool for demarcating architecture boundaries within our
    code base was packages. All of our code has been part of the same monolithic build
    artifact.
  prefs: []
  type: TYPE_NORMAL
- en: A build artifact is the result of a (hopefully automated) build process. The
    most popular build tools in the Java world are currently Maven and Gradle. So,
    until now, imagine we had a single Maven or Gradle build script and we could call
    Maven or Gradle to compile, test, and package the code of our application into
    a single JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: A main feature of build tools is dependency resolution. To transform a certain
    code base into a build artifact, a build tool first checks whether all the artifacts
    the code base depends on are available. If not, it tries to load them from an
    artifact repository. If this fails, the build will fail with an error before even
    trying to compile the code.
  prefs: []
  type: TYPE_NORMAL
- en: We can leverage this to enforce the dependencies (and thus enforce the boundaries)
    between the modules and layers of our architecture. For each such module or layer,
    we create a separate build module with its own code base and its own build artifact
    (JAR file) as a result. In the build script of each module, we specify only those
    dependencies to other modules that are allowed according to our architecture.
    Developers can no longer inadvertently create illegal dependencies because the
    classes are not even available on the classpath and they would run into compile
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – Different ways of dividing our architecture into multiple build
    artifacts to prohibit illegal dependencies](img/Figure_12.3._B19916.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Different ways of dividing our architecture into multiple build
    artifacts to prohibit illegal dependencies
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.3* shows an incomplete set of options to divide our architecture
    into separate build artifacts.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting on the left, we see a basic three-module build with a separate build
    artifact for the configuration, adapter, and application layers. The `configuration`
    module may access the `adapters` module, which in turn may access the `application`
    module. The configuration module may also access the application module due to
    the implicit, transitive dependency between them. The adapters module contains
    the `web` adapter as well as the `persistence` adapter. This means that the build
    tool will not prohibit dependencies between those adapters. While dependencies
    between those adapters are not strictly forbidden by the Dependency Rule (since
    both adapters are within the same outer layer), in most cases, it’s sensible to
    keep adapters isolated from each other. After all, we usually don’t want changes
    in the persistence layer to leak into the web layer and vice versa (remember the
    Single Responsibility Principle!). The same holds true for other types of adapters,
    for example adapters connecting our application to a certain third-party API.
    We don’t want details of that API leaking into other adapters by adding accidental
    dependencies between adapters.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, we may split the single adapters module into multiple build modules, one
    for each adapter, as shown in the second column of *Figure 12**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we could decide to split up the application module further. It currently
    contains the incoming and outgoing ports to our application, the services that
    implement or use those ports, and the domain entities that should contain much
    of our domain logic.
  prefs: []
  type: TYPE_NORMAL
- en: If we decide that our domain entities are not to be used as transfer objects
    within our ports (i.e., we want to disallow the *No Mapping* strategy from [*Chapter
    9*](B19916_09.xhtml#_idTextAnchor081), *Mapping between Boundaries*), we can apply
    the Dependency Inversion Principle and pull out a separate `api` module that contains
    only the port interfaces (the third column in *Figure 12**.3*). The `adapter`
    modules and the `application` module may access the `api` module, but not the
    other way around. The `api` module does not have access to the domain entities
    and cannot use them within the port interfaces. Also, the adapters no longer have
    direct access to the entities and services, so they must go through the ports.
  prefs: []
  type: TYPE_NORMAL
- en: We can even go a step further and split the `api` module in two, one part containing
    only the incoming ports and the other part only containing the outgoing ports
    (the fourth column in *Figure 12**.3*). This way, we can make it very clear whether
    a certain adapter is an incoming adapter or an outgoing adapter by declaring a
    dependency only on the input or the outgoing ports.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we could split the application module even further, creating a module
    containing only the services and another containing only the domain model. This
    ensures that the domain model doesn’t access the services, and it would allow
    other applications (with different use cases and thus different services) to use
    the same domain model by simply declaring a dependency on the domain build artifact.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.3* illustrates that there are a lot of different ways to divide
    an application into build modules, and there are of course more than just the
    four ways depicted in the figure. The gist is that the finer we cut our modules,
    the stronger we can control dependencies between them. The finer we cut, however,
    the more mapping we have to do between those modules, enforcing one of the mapping
    strategies introduced in [*Chapter 9*](B19916_09.xhtml#_idTextAnchor081), *Mapping*
    *between Boundaries*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides that, demarcating architecture boundaries with build modules has a
    number of advantages over using simple packages as boundary:'
  prefs: []
  type: TYPE_NORMAL
- en: First, build tools absolutely hate circular dependencies. Circular dependencies
    are bad because a change in one module within the circle would potentially mean
    a change in all other modules within the circle, which is a violation of the Single
    Responsibility Principle. Build tools don’t allow circular dependencies because
    they would run into an endless loop while trying to resolve them. Thus, we can
    be sure that there are no circular dependencies between our build modules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Java compiler, on the other hand, doesn’t care at all if there is a circular
    dependency between two or more packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, build modules allow isolated code changes within certain modules without
    having to take the other modules into consideration. Imagine we have to do a major
    refactoring in the application layer that causes temporary compile errors in a
    certain adapter. If the adapters and application layer are within the same build
    module, some IDEs will insist that all compile errors in the adapters must be
    fixed before we can run the tests in the application layer, even though the tests
    don’t need the adapters to compile. If the application layer is in its own build
    module, however, the IDE won’t care about the adapters at the moment, and we could
    run the application layer tests at will. The same goes for running a build process
    with Maven or Gradle: if both layers are in the same build module, the build would
    fail due to compile errors in either layer.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, multiple build modules allow isolated changes in each module. We could even
    choose to put each module into its own code repository, allowing different teams
    to maintain different modules.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with each inter-module dependency explicitly declared in a build script,
    adding a new dependency becomes a conscious act instead of an accident. A developer
    who needs access to a certain class they currently cannot access will hopefully
    give some thought to the question if the dependency is really reasonable before
    adding it to the build script.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These advantages come with the added cost of having to maintain a build script,
    though, so the architecture should be somewhat stable before splitting it into
    different build modules.
  prefs: []
  type: TYPE_NORMAL
- en: Also, build modules tend to be less supple to change over time. Once chosen,
    we tend to stick with the modules we have initially defined. If the slicing of
    modules wasn’t right from the start, we are less likely to correct it later because
    of the added effort of refactoring. Refactoring is easier when all the code lies
    within a single build module.
  prefs: []
  type: TYPE_NORMAL
- en: How does this help me build maintainable software?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software architecture is basically all about managing dependencies between architecture
    elements. If the dependencies become a big ball of mud, the architecture becomes
    a big ball of mud.
  prefs: []
  type: TYPE_NORMAL
- en: So, to preserve the architecture over time, we need to continually make sure
    that dependencies point in the right direction.
  prefs: []
  type: TYPE_NORMAL
- en: When producing new code or refactoring existing code, we should keep the package
    structure in mind and use package-private visibility when possible, to avoid dependencies
    to classes that should not be accessed from outside the package.
  prefs: []
  type: TYPE_NORMAL
- en: If we need to enforce architecture boundaries within a single build module,
    and the package-private modifier doesn’t work because the package structure won’t
    allow it, we can make use of post-compile tools such as ArchUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Any time we feel that the architecture is stable enough, we should extract architecture
    elements into their own build modules because this gives explicit control over
    the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: All three approaches can be combined to enforce architecture boundaries and
    thus keep the code base maintainable over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we’ll continue to explore architecture boundaries, but
    from a different perspective: we’ll think about how to manage multiple domains
    (or bounded contexts) in the same application, while keeping the boundaries between
    them distinct.'
  prefs: []
  type: TYPE_NORMAL
