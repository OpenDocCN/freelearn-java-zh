<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Property-Based Testing in Scala</h1>
                </header>
            
            <article>
                
<p class="p1">Unit testing is a daily activity of many programmers. It is performed in order to verify the behavior of the software under development. Property-based testing is an alternative and supplementary approach to unit testing. It allows for the description of the expected properties of software and for their verification, if these properties hold using automatically generated data.</p>
<p class="p1">In this chapter, we'll discuss the situations in which property-based testing can be especially useful, and look at how the expected properties can be formulated and the test data can be produced.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The concept of property-based testing</li>
<li>Properties</li>
<li>Generators</li>
<li>Shrinkers</li>
<li>Properties as laws</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<ul>
<li>JDK 1.8+</li>
<li>SBT 1.2+</li>
</ul>
<p>The source code for this chapter is available under: <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter05</a>.<a href="https://github.com/PacktPublishing/Learn-Scala---Fundamentals-of-Scala-2.13/tree/master/ch05"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to property-based testing</h1>
                </header>
            
            <article>
                
<p class="mce-root">The concept of unit testing should be well-known by any professional developer. A unit test usually contains a number of test cases. Each test case describes the expected behavior of a part of the program. The description is usually formulated in the form: <em>for this unit of code in that specific state we expect given input to produce the following output</em>. The developer then replicates such test cases with some deviations in the initial state and/or input data and expectations of the result in order to cover different code paths.</p>
<p class="mce-root">The specification of the test case is represented in the form of a test code relying on a testing framework. As at the moment of this writing, there are two popular testing frameworks for Scala projects, <kbd>ScalaTest</kbd> and <kbd>Specs2</kbd>. It is arguable that at least one of them should be familiar to any Scala developer, so we won't cover them in this book.</p>
<p>Instead, we'll take a look at alternative ways to formulate expectations about the behavior of the program.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">From unit tests to properties</h1>
                </header>
            
            <article>
                
<p>It turns out that testing scenarios (sometimes also called example-based tests) are just one of the many ways to define how the system is expected to work. Examples just describe some properties of the software having a specific state. The state usually affects the output in response to a provided input.</p>
<p>Generally speaking, in addition to properties described via examples, there are other types of properties which characterize software, such as:</p>
<ul class="ul1">
<li class="li1"><span class="s2">Universally quantified properties</span></li>
<li class="li1"><span class="s2">Conditional properties</span></li>
</ul>
<p>With them we can tell something about the system which should hold for any valid input and possibly for all possible states.  This form of testing is called <strong>property-based testing</strong> (<strong>PBT</strong>)<span>. In contrast to the concrete scenario in a unit-testing case, the property is an abstract specification.</span></p>
<p><span>The same way that unit-testing frameworks provide functionality to structure tests and to formulate the expectations in the forms of unit tests, there is a Scala framework for PBT.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">ScalaCheck</h1>
                </header>
            
            <article>
                
<p>ScalaCheck (<a href="http://www.scalacheck.org">http://www.scalacheck.org</a>) is a framework for automated PBT in Scala. It works great with SBT or IntelliJ IDEA and also has a built-in test runner and <span>can be used standalone because of this.</span> It also integrates well with <kbd>ScalaTest</kbd> and <kbd>specs2</kbd>. </p>
<p><kbd>ScalaCheck</kbd> is an external dependency, so we need to add it to the <kbd>build.sbt</kbd>:</p>
<pre>libraryDependencies += "org.scalacheck" %% "scalacheck" % "1.14.0" % Test</pre>
<p>In order to be able to play with the code in REPL, we'll need to add it to the default scope (by removing the <kbd>% Test</kbd> part (this is already done in the chapter's code) and start the REPL with SBT dependencies. If you don't know how to do this, please refer to the <a href="bc164888-625c-460a-9b0b-e6c45c9eb074.xhtml">Appendix A</a>, <em>Preparing the Environment and Running Code Samples</em>, where we explain it in detail.</p>
<p>Now, we can define and verify our first property:</p>
<pre>scala&gt; import org.scalacheck.Prop.forAll<br/>import org.scalacheck.Prop.forAll<br/><br/>scala&gt; val stringLengthProp = forAll { (_: String).length &gt;= 0 }<br/>stringLength: org.scalacheck.Prop = Prop<br/><br/>scala&gt; stringLengthProp.check<br/>+ OK, passed 100 tests.</pre>
<p>We just defined and verified that all <kbd>Strings</kbd> have non-negative lengths! Confused a bit? Let's take a closer look how it was done.</p>
<p>In the first line, we imported a <kbd>forAll</kbd> property factory. In essence, its purpose is to convert functions into properties.</p>
<p>In our case, in the second line the function is of a type <kbd>String =&gt; Boolean</kbd>. Naturally, there is some implicit magic in play. Among other things, there is an implicit conversion <kbd>Boolean =&gt; Property</kbd> and an <kbd>Arbitrary[String]</kbd> which provides a test data, in our case, random strings.</p>
<p>In the third line we call a <kbd>check</kbd> method available on the <kbd>Prop</kbd> (<kbd>ScalaCheck</kbd> uses this name as an abbreviation for <kbd>"property"</kbd>) among other combination and execution methods to execute our test using the default configuration. Hence, it runs with 100 random strings as an input data.</p>
<p>Now that we've got a feeling for how the PBT looks in general, we'll rigorously approach each aspect of it, starting with properties.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Properties</h1>
                </header>
            
            <article>
                
<p>Defining properties is the most important aspect of PBT. It is impossible to test a system properly without having good properties definition. The transition from testing scenarios to properties is usually the hardest part for developers starting to adopt PBT.</p>
<p>Therefore, it is useful to have some kind of system which would help to approach the task of defining a property in a systematic manner. Often, the first step in systematizing something is classification.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Types of properties</h1>
                </header>
            
            <article>
                
<p>We already said that there are universally quantified and conditional properties, depending upon if some property holds always or just for some subset of all possible inputs. Now, we want to break down properties in different dimensions—by how they are defined. Let's see how we could describe some operations in general terms.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Commutativity</h1>
                </header>
            
            <article>
                
<p>If order operands do not matter, we say that the operation is commutative. The most trivial examples would be addition and multiplication. The property should be universal for both of these operations. In the following code, we're creating two properties, one for addition and one for multiplication, and checking that our assumption is correct by comparing results of computations with the changed order of operands:</p>
<pre>scala&gt; forAll((a: Int, b: Int) =&gt; a + b == b + a).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: Int, b: Int) =&gt; a * b == b * a).check<br/>+ OK, passed 100 tests.</pre>
<p>For strings, the addition is defined as a <span>concatenation</span> but is not commutative in general:</p>
<pre>scala&gt; forAll((a: String, b: String) =&gt; a + b == b + a).check<br/>! Falsified after 1 passed tests.<br/>&gt; ARG_0: "\u0001"<br/>&gt; ARG_0_ORIGINAL <br/>&gt; ARG_1: "\u0000"<br/>&gt; ARG_1_ORIGINAL: <img src="Images/c01597ef-ab81-4b97-9919-8651d9758e39.png" style="width:1.83em;height:1.00em;" width="37" height="20"/></pre>
<p>In this example, we can also see how <kbd>ScalaCheck</kbd> generates random inputs and finds some minimal failing case. If at least one of the strings is empty, the property becomes commutative which can be demonstrated with the following modification of the previous test where <kbd>b</kbd> is assigned an empty string:</p>
<pre>scala&gt; forAll((a: String) =&gt; a + "" == "" + a).check<br/>+ OK, passed 100 tests.</pre>
<p>This is an example of a conditional test for string concatenation.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Associativity</h1>
                </header>
            
            <article>
                
<p>The associativity is the same for operators as commutativity is for operands—if there are multiple operations, then the order in which operations are performed does not matter as long as the order of operands does not change.</p>
<p>The associativity properties for multiplication and addition again look very similar, as in the following example where we have three properties, each comparing results of two computations with a different order of operations:</p>
<pre>scala&gt; forAll((a: Int, b: Int, c: Int) =&gt; (a + b) + c == a + (b + c)).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: Int, b: Int, c: Int) =&gt; (a * b) * c == a * (b * c)).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: String, b: String, c: String) =&gt; <br/>   (a + b) + c == a + (b + c)).check<br/>+ OK, passed 100 tests.</pre>
<p>The last line demonstrates that string concatenation is associative as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Identity</h1>
                </header>
            
            <article>
                
<p>The identity property of some operation states that if one of the operands is the identity value, then the result of the operation will be equal to another operand. For multiplication, the identity value is one; for addition, it is zero. Because of the commutativity of both multiplication and addition, the identity value can appear in any position. For example, in the next snippet the identity element appears as the first and as the second operand for all of them:</p>
<pre>scala&gt; forAll((a: Int) =&gt; a + 0 == a &amp;&amp; 0 + a == a).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: Int) =&gt; a * 1 == a &amp;&amp; 1 * a == a).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: String) =&gt; a + "" == a &amp;&amp; "" + a == a).check<br/>+ OK, passed 100 tests.</pre>
<p>For string concatenation, the identity is an empty string. It turns out our conditional commutativity property for strings was just a manifestation of the universal identity property!</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Invariants</h1>
                </header>
            
            <article>
                
<p>Invariant properties are those which should never change in the context of the operation. For example, sorting the contents of the string or changing the case of it should never change its length. The next property demonstrates that it holds for normal as well as for uppercase strings:</p>
<pre>scala&gt; forAll((a: String) =&gt; a.sorted.length == a.length).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: String) =&gt; a.toUpperCase().length == a.length).check<br/>! Falsified after 50 passed tests.<br/>&gt; ARG_0: <img src="Images/0f35ea4a-687e-4bb7-a97b-77ddf68d9764.png" style="width:2.08em;height:1.33em;" width="38" height="24"/><br/><span class="underline">&gt;</span> ARG_0_ORIGINAL: <img src="Images/a47cdf04-22f1-487e-bb6d-e68f338bcb7b.png" style="width:12.75em;height:1.08em;" width="258" height="22"/></pre>
<p>Or well, for <kbd>toUpperCase</kbd> <span>at least </span>it should work if the locale matches the contents of the string or the string only contains ASCII symbols:</p>
<pre>scala&gt; forAll(Gen.asciiStr)((a: String) =&gt; a.toUpperCase().length == a.length).check<br/>+ OK, passed 100 tests.</pre>
<p>Here we went a bit ahead of ourselves and used <kbd>Gen.asciiStr</kbd> to generate strings which only contain ASCII chars.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Idempotence</h1>
                </header>
            
            <article>
                
<p>Idempotent operations only change their operand once. After the initial change, any follow-up application should leave the operand unchanged. Sorting and uppercasing the contents of the string are good examples of idempotent operations. Please note that the same operations had the length property invariant in the previous example.</p>
<p>We can demonstrate that operations <kbd>toUpperCase</kbd> and sorted are idempotent by applying them a different number of times and expecting that the result is the same as after the first application:</p>
<pre>scala&gt; forAll((a: String) =&gt; <br/>  a.toUpperCase().toUpperCase() == a.toUpperCase()).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: String) =&gt; a.sorted.sorted.sorted == a.sorted).check<br/>+ OK, passed 100 tests.</pre>
<p>For multiplications, the natural idempotent element is by definition the identity element. But it is also a zero:</p>
<pre>scala&gt; forAll((a: Int) =&gt; a * 0 * 0 == a * 0) .check<br/>+ OK, passed 100 tests.</pre>
<p>The logical <kbd>AND</kbd> and <kbd>OR</kbd> are idempotent for the Boolean values <kbd>false</kbd> and <kbd>true</kbd>, respectively.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Induction </h1>
                </header>
            
            <article>
                
<p>Inductive properties reflect those of their operand(s). They are usually formulated for the inductive case. </p>
<p>For example, the factorial function for any argument should obey the factorial definition:</p>
<pre>scala&gt; def factorial(n: Long): Long = if (n &lt; 2) n else n * factorial(n-1)<br/>factorial: (n: Long)Long<br/><br/>scala&gt; forAll((a: Byte) =&gt; a &gt; 2 ==&gt; <br/>  (factorial(a) == a * factorial(a - 1))).check<br/>+ OK, passed 100 tests.</pre>
<p>Which is, of course, a conditional property for <kbd>n &gt; 2</kbd>, which we specify using the implication operator <kbd>==&gt;</kbd> (more about this operator later).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Symmetry</h1>
                </header>
            
            <article>
                
<p>Symmetry is a type of invariance. It states that the operand will have its original form after the application of <span>some ordered set of operations </span>. Often this set is limited to a pair of operations or even to a single symmetric operation.</p>
<p>For our usual experimental string, there is a symmetric operation <kbd>reverse</kbd>; for numbers, we could define a pair of addition and subtraction:</p>
<pre>scala&gt; forAll((a: String) =&gt; a.reverse.reverse == a).check<br/>+ OK, passed 100 tests.<br/>scala&gt; forAll((a: Int, b: Int) =&gt; a + b - b == a).check<br/>+ OK, passed 100 tests.</pre>
<p>It is possible to define another pair with multiplication and division as operands (with respect to division by zero, overflow, and precision).</p>
<p>The symmetry property is often called a <strong>round-trip</strong> property. <span>For a single operation it must hold for any inversible function.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Test Oracle</h1>
                </header>
            
            <article>
                
<p>Strictly speaking, the test oracle does not belong to this list because it does not specify an intrinsic quality of the operation. Still, it is a useful and convenient way to pinpoint an expected behavior.</p>
<p>The principle is simple and especially useful during a refactoring or rewriting of the existing system. It uses given trusted implementation to verify the behavior of the new code. Back to our string examples, we might use Java's Array as a test oracle for the sorting of the contents of the string, by expecting that the results of sorting the string and an array, which consists of its elements, would be the same:</p>
<pre>scala&gt; forAll { a: String =&gt;<br/>     | val chars = a.toCharArray<br/>     | java.util.Arrays.sort(chars)<br/>     | val b = String.valueOf(chars)<br/>     | a.sorted == b<br/>     | }.check<br/>+ OK, passed 100 tests.</pre>
<p>But, of course, in the real refactoring scenario on the place of an array, the existing implementation would be used.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining a property</h1>
                </header>
            
            <article>
                
<p>We've defined all different type's properties in the same way, using the most concise version of the <kbd>forAll</kbd> constructor and a <kbd>check</kbd> method. There are some ways to customize them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Checking property</h1>
                </header>
            
            <article>
                
<p>The <kbd>check()</kbd> method accepts <kbd>Test.Parameters</kbd>, which allow for the configuration of a few aspects of how the check is executed. The most useful describe a minimum number of successful tests, the number of workers to run in parallel, a test callback to execute after each test, the maximum discard ratio between passed and discarded tests for conditional tests, and an <span>initial seed which can help to make the property evaluation deterministic</span>. It is also possible to limit the time the test is allowed to execute. Here is an example, which uses both test parameters and a time limit:</p>
<pre>scala&gt; val prop = forAll { a: String =&gt; a.nonEmpty ==&gt; (a.reverse.reverse == a) }<br/>prop: org.scalacheck.Prop = Prop<br/><br/>scala&gt; val timed = within(10000)(prop)<br/>timed: org.scalacheck.Prop = Prop<br/><br/>scala&gt; Test.check(timed) {<br/>     | _.withMinSuccessfulTests(100000).withWorkers(4).withMaxDiscardRatio(3)<br/>     | }<br/>res47: org.scalacheck.Test.Result = Result(Failed(List(),Set(Timeout)),0,0,Map(),10011)</pre>
<p>Here we used the <kbd>Test.check</kbd> method, which executes a property with given parameters and returns test statistics back. We can see that our test has failed because of the timeout.</p>
<p>Besides <kbd>within</kbd>, there are other wrapper methods defined on <kbd>Prop</kbd>. For instance, it is possible to convert exceptions thrown by the property into test failures, to evaluate properties lazily, or to collect data for the test report:</p>
<pre>scala&gt; forAll { a: String =&gt;<br/>     |   classify(a.isEmpty, "empty string", "non-empty string") {<br/>     |     a.sorted.length ?= a.length<br/>     |   }<br/>     | }.check()<br/>+ OK, passed 100 tests.<br/>&gt; Collected test data:<br/>96% non-empty string<br/>4% empty string</pre>
<p class="mce-root">The difference between <kbd>==</kbd> and <kbd>?=</kbd> used in the previous code is subtle—the <kbd>==</kbd> compares two values and returns a Boolean, which is then implicitly converted to the <kbd>Prop</kbd>; the <kbd>?=</kbd> creates a <kbd>Prop</kbd> directly and sometimes it can be useful in the situations where properties are combined, as we'll see further.</p>
<p class="mce-root">A property can also be labelled, which makes it easier to spot in the results:</p>
<pre>scala&gt; val prop2 = "Division by zero" |: protect(forAll((a: Int) =&gt; a / a == 1))<br/>prop2: org.scalacheck.Prop = Prop<br/><br/>scala&gt; prop2.check()<br/>! Exception raised on property evaluation.<br/>&gt; Labels of failing property:<br/>Division by zero<br/>&gt; ARG_0: 0<br/>&gt; Exception: java.lang.ArithmeticException: / by zero<br/>$line74.$read$$iw$$iw$$iw$$iw$$iw$$iw$$iw$$iw$.$anonfun$prop2$2(&lt;console&gt;:2<br/>  3)<br/>...</pre>
<p>Here we also used the <kbd>protect</kbd> method to convert the exception into the test failure.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Combining properties</h1>
                </header>
            
            <article>
                
<p>Until now, we were talking about single, isolated properties. Sometimes, it is useful, or even required, to make sure that some combination of properties holds. For instance, we might want to define a property which holds if and only if all other properties hold. Or we might want to have a property which is true if at least one property from a set of properties is true. There are combination methods defined on <kbd>Prop</kbd> exactly for such use cases. The result is just another property which can be checked the same way we already did:</p>
<pre>    forAll { (a: Int, b: Int, c: Int, d: String) =&gt;<br/>      val multiplicationLaws = all(<br/>        "Commutativity" |: (a * b ?= b * a),<br/>        "Associativity" |: ((a * b) * c ?= a * (b * c)),<br/>        "Identity" |: all(a * 1 ?= a, 1 * a ?= a)<br/>      ) :| "Multiplication laws"<br/>      val stringProps = atLeastOne(d.isEmpty, d.nonEmpty)<br/>      all(multiplicationLaws, stringProps)<br/>    }.check()<br/><br/>+ OK, passed 100 tests.</pre>
<p>This is a nested combination of properties. The topmost one holds if both <kbd>multiplicationLaws</kbd> and <kbd>stringProps</kbd> hold. The <kbd>stringProps</kbd> verifies that any <kbd>String</kbd> is either empty or non-empty; only one of these properties can be true at the same time. For <kbd>multiplicationLaws</kbd>, all nested properties must hold.</p>
<p>There are also more specific combinators, for example <kbd>someFailing</kbd> and <kbd>noneFailing</kbd> which hold in the case if some underlying properties are failing or none are failing respectively. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generators</h1>
                </header>
            
            <article>
                
<p>We have had a detailed discussion of properties, but haven't mentioned yet where the input data for these properties comes from. Let's correct this omission and give generators the care they deserve.</p>
<p>The idea of the generator comes from the general concept of types. In a sense, <span class="s1">a type is a </span><span class="s2">specification of possible values</span> <span class="s1">complying to that type. In other words, </span><span class="s1">types describe the</span> <span class="s2">rules</span> <span class="s1">that values must comply to. These rules give us the possibility to generate ranges of data values for given types.</span></p>
<p>For some types there are more values; for others, there are less. As we already know, there are literal types which contain a single value. The same applies for <kbd>Unit</kbd> type with its <kbd>()</kbd> value. For <kbd>Boolean</kbd>, there are two values that exist: <kbd>true</kbd> and <kbd>false</kbd>. Two values would also exist for an imaginary equality relation type—equal and non-equal. With the same principle, we can say that full ordering takes one of three values: less than, equal, or greater than.</p>
<p>Properties defined in terms of types with such limited sets of possible values are called <em>provable</em>. This is because it is possible to try out all values of a given type (or combinations, if there are multiple parameters) and prove that the program is correct for all possible inputs.</p>
<p>The other type of properties are <em>falsifiable</em> properties. It is not possible (or does not make sense) to try out all possible values of input parameters, hence it is only possible to tell that the functionality under test works for some subset of all inputs.</p>
<p>To make falsifiable properties more trustworthy, existing <kbd>ScalaCheck</kbd> generators for <kbd>Byte</kbd>, <kbd>Short</kbd>, <kbd>Int</kbd>, and <kbd>Long</kbd> place additional weight on <kbd>zero</kbd>, <kbd>+1</kbd>, <kbd>-1</kbd>, and both <kbd>minValue</kbd> and <kbd>maxValue</kbd> for the type.</p>
<p>Let's take a look at which generators are included in the <kbd>ScalaCheck</kbd> and how we can use them to create new generators for the data types specific for our code. We'll also briefly touch the topic of gradually reducing the test data for failing cases known as shrinking.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Existing generators</h1>
                </header>
            
            <article>
                
<p>Speaking about existing generators, ScalaCheck provides a lot of them out of the box, such as all subtypes of <kbd>AnyVal</kbd>, <kbd>Unit</kbd>, <kbd>Function0</kbd>, chars and strings with different contents (<kbd>alphaChar</kbd>, <kbd>alphaLowerChar</kbd>, <kbd>alphaNumChar</kbd>, <kbd>alphaStr</kbd>, <kbd>alphaUpperChar</kbd>, <kbd>numChar</kbd>, <kbd>numStr</kbd>), containers, lists and maps (<kbd>containerOf</kbd>, <kbd>containerOf1</kbd>, <kbd>containerOfN</kbd>, <kbd>nonEmptyContainerOf</kbd>, <kbd>listOf</kbd>, <kbd>listOf1</kbd>, <kbd>listOfN</kbd>, <kbd><span>nonEmptyListOf</span></kbd>, <kbd>mapOf</kbd>, <kbd>mapOfN</kbd>, <kbd>nonEmptyMap</kbd>), numbers (<kbd>chooseNum</kbd>, <kbd>negNum</kbd>, <kbd>posNum</kbd>), duration, <kbd>Calendar</kbd>, <kbd>BitSet</kbd>, and even <kbd>Test.Parameters</kbd>!</p>
<p>If there is no generator <span> suitable for the testing purposes</span> available, it is possible to create a custom generator by implementing a <kbd>Gen</kbd> class:</p>
<pre><span>sealed abstract class </span>Gen[<span>+T</span>] <span>extends </span>Serializable { self =&gt;<br/>  ...<br/><span>  </span><span>def </span>apply(p: Gen.Parameters, seed: Seed): Option[<span>T</span>]<br/>  def sample: Option[T]<br/>  ...<br/>}</pre>
<p>This is an abstract class, which is basically just a function taking test parameters and returning an optional value of the required type.</p>
<p>It is partially implemented, but still, it's a bit mundane to extend it manually. Hence new generators are usually implemented by reusing already existing ones. As an exercise, let's implement a generator for literal types:</p>
<pre><span>def </span>literalGen[<span>T </span>&lt;: Singleton](t: <span>T</span>): Gen[<span>T</span>] = Gen.<span>const</span>(t)<br/><span>implicit val </span><span>myGen: Arbitrary[42] </span>= Arbitrary(<span>literalGen</span>(<span>42</span>))<br/><span>val </span><span>literalProp </span>= <span>forAll</span>((_: <span>42</span>) == <span>42</span>).check</pre>
<p>In the first line, we're creating a generator factory for literal types by delegating the value generation to the <kbd>Gen.const</kbd>. This is safe to do because, by definition, literal types contain just a single value. The second line creates an <kbd>implicit Arbitrary[42]</kbd>, which is expected to be in scope by the <kbd>forAll</kbd> property.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Combining generators</h1>
                </header>
            
            <article>
                
<p>Though it is not very hard to create a custom one, the absolute majority of generators is built by combining existing implementations. <kbd>Gen</kbd> offers a couple of methods that are very useful in such scenarios. The classic example is to use the <kbd>map</kbd> and <kbd>flatMap</kbd> methods to create a generator for a case class.</p>
<p>Let's demonstrate this with an example of playing cards:</p>
<pre><span>sealed trait </span>Rank<br/><span>case class </span>SymRank(s: Char) <span>extends </span>Rank {<br/>  <span>override def </span>toString: <span>String </span>= s.toString<br/>}<br/><span>case class </span>NumRank(n: Int) <span>extends </span>Rank {<br/>  <span>override def </span>toString: <span>String </span>= n.toString<br/>}<br/><span>case class </span>Card(suit: Char, rank: Rank) {<br/>  <span>override def </span>toString: <span>String </span>= <span>s"</span><span>$</span>suit <span>$</span>rank<span>"<br/></span>}</pre>
<p>First, we need some generators for suits and ranks which we can create by reusing existing <kbd>oneOf</kbd> and <kbd>choose</kbd> constructors:</p>
<pre><span>val </span><span>suits </span>= Gen.<span>oneOf</span>(<span>'♡'</span>, <span>'♢'</span>, <span>'♤'</span>, <span>'♧'</span>)<br/><span>val </span><span>numbers </span>= Gen.<span>choose</span>(<span>2</span>, <span>10</span>).map(NumRank)<br/><span>val </span><span>symbols </span>= Gen.<span>oneOf</span>(<span>'A'</span>, <span>'K'</span>, <span>'Q'</span>, <span>'J'</span>).map(SymRank)</pre>
<p>Now, we can combine our generators into the card generator using <kbd>for</kbd> comprehension:</p>
<pre><span>val </span><span>full</span>: Gen[Card] = <span>for </span>{<br/>  suit &lt;- <span>suits<br/></span><span>  </span>rank &lt;- Gen.<span>frequency</span>((<span>9</span>, <span>numbers</span>), (<span>4</span>, <span>symbols</span>))<br/>} <span>yield </span><span>Card</span>(suit, rank)</pre>
<p>We also use <kbd>Gen.frequency</kbd> in order to have a proper distribution of numbers and symbols produced by our combined generator.</p>
<p>It is easy to change this generator to only make cards for a pique pack by using the <kbd>suchThat</kbd> combinator:</p>
<pre><span>val </span><span>piquet</span>: Gen[Card] = <span>full</span>.suchThat {<br/>  <span>case </span><span>Card</span>(_, _: SymRank) =&gt; <span>true<br/></span><span>  case </span><span>Card</span>(_, <span>NumRank</span>(n)) =&gt; n &gt; <span>5<br/></span>}</pre>
<p>We can check that our generators produce trustworthy values by using the <kbd>Prop.collect</kbd> method:</p>
<pre>scala&gt; forAll(piquet) { card =&gt;<br/>     | Prop.collect(card)(true)<br/>     | }.check<br/>+ OK, passed 100 tests.<br/>&gt; Collected test data:<br/>8% ♡ J<br/>6% ♢ 7<br/>6% ♡ 10<br/>... (couple of lines more)<br/>scala&gt; forAll(full) { card =&gt;<br/>     | Prop.collect(card)(true)<br/>     | }.check<br/>+ OK, passed 100 tests.<br/>&gt; Collected test data:<br/>6% ♡ 3<br/>5% ♢ 3<br/>... (a lot more lines)</pre>
<p>Of course, it is also possible to generate a handfull of cards from the deck using one of the container generator methods:</p>
<pre><span>val </span><span>handOfCards</span>: Gen[<span>List</span>[Card]] = Gen.<span>listOfN</span>(<span>6</span>, <span>piquet</span>)</pre>
<p>And use it as before:</p>
<pre>scala&gt; forAll(handOfCards) { hand: Seq[Card] =&gt;<br/>     | Prop.collect(hand.mkString(","))(true)<br/>     | }.check<br/>! Gave up after only 58 passed tests. 501 tests were discarded.<br/>&gt; Collected test data:<br/>2% ♤ 8,♤ 10,♤ 8,♤ 7,♡ Q,♢ 8</pre>
<p>Oh, we have duplicate cards in our hand. It turns out that we need to use a more general form of the container generator, which takes both the type of the container and the type of the element as type parameters:</p>
<pre><span>val </span><span>handOfCards </span>= Gen.<span>containerOfN</span>[<span>Set</span>, Card](<span>6</span>, <span>piquet</span>)<br/>scala&gt; forAll(handOfCards) { hand =&gt;<br/>     | Prop.collect(hand.mkString(","))(true)<br/>     | }.check<br/>! Gave up after only 75 passed tests. 501 tests were discarded.<br/>&gt; Collected test data:<br/>1% ♡ A,♤ J,♡ K,♢ 6,♧ K,♧ A<br/>1% ♤ 9,♧ A,♧ 8,♧ 9</pre>
<p>That is better, but now it seems that the duplicate elements have just disappeared so that we still don't have an expected behavior. Moreover, another issue is obvious—a lot of tests are discarded. This happens because our <kbd>piquet</kbd> generator is defined in terms of filtering the output of the more general <kbd>full</kbd> generator. <kbd>ScalaCheck</kbd> notices that there are too many tests which do not qualify as a valid input and gives up earlier.</p>
<p>Let's fix our <kbd>piquet</kbd> generator and an issue with missing cards. For the first one, we will use the same approach as we've used for the <kbd>full</kbd> generator. We'll just change the number used for the rank:</p>
<pre><span>val </span><span>piquetNumbers </span>= Gen.<span>choose</span>(<span>6</span>, <span>10</span>).map(NumRank)<br/><br/><span>val </span><span>piquet</span>: Gen[Card] = <span>for </span>{<br/>  suit &lt;- <span>suits<br/></span><span>  </span>rank &lt;- Gen.<span>frequency</span>((<span>5</span>, <span>piquetNumbers</span>), (<span>4</span>, <span>symbols</span>))<br/>} <span>yield </span><span>Card</span>(suit, rank)</pre>
<p>Please note how the frequency changed in respect to the changed set of possible values.</p>
<p>To fix the second issue, we will repeatedly generate the set of cards until it has an expected size using <kbd>retryUntil</kbd> combinator:</p>
<pre><span>val </span><span>handOfCards </span>= Gen.<span>containerOfN</span>[<span>Set</span>, Card](<span>6</span>, <span>piquet</span>).retryUntil(_.size == <span>6</span>)<br/><br/>scala&gt; forAll(handOfCards) { hand =&gt;<br/>     | Prop.collect(hand.mkString(","))(true)<br/>     | }.check<br/>+ OK, passed 100 tests.<br/>&gt; Collected test data:<br/>1% ♤ 9,♢ 9,♧ 9,♢ Q,♧ J,♤ 10<br/>...</pre>
<p>Now, our hands are generated as expected.</p>
<p>Of course, there are even more useful combinator methods, which can be used to create other sophisticated generators. Please refer to the documentation (<a href="https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md">https://github.com/rickynils/scalacheck/blob/master/doc/UserGuide.md</a>) or the source code for further details.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Shrinkers</h1>
                </header>
            
            <article>
                
<p><span>We have looked at two cornerstones of PBT—properties and generators. There is still one aspect we should take a look at before considering ourselves done.</span></p>
<p>In PBT, the test data comes from<span> generators </span>and it is kind of random. Given this fact, we could expect that it might be hard to find out why a test is failing. Consider the following example:</p>
<pre>scala&gt; forAllNoShrink { num: Int =&gt;<br/>     | num &lt; 42<br/>     | }.check<br/>! Falsified after 0 passed tests.<br/>&gt; ARG_0: 2008612603</pre>
<p>Here, we can see that our property was falsified by the number <kbd>2008612603</kbd>, which is arguably not very useful. It is more or less obvious for an <kbd>Int</kbd>, but consider a case with a list of many elements and a property formulated for these elements:</p>
<pre>scala&gt; forAllNoShrink(Gen.listOfN(1000, Arbitrary.arbString.arbitrary)) {<br/>     | _.forall(_.length &lt; 10)<br/>     | }.check<br/>! Falsified after 10 passed tests.<br/>&gt; ARG_0: List <img src="Images/1848eddf-4175-42d7-a20f-dda9a37d0a83.png" style="width:26.00em;height:1.17em;" width="469" height="21"/> <br/> <img src="Images/c4b3a37a-46c4-46e4-a95a-1e55a6c5404b.png" style="width:12.17em;height:1.08em;" width="257" height="23"/><br/>  ",<br/>... // a lot of similar lines</pre>
<p>Obviously, it is near to impossible to find out which of 1,000 strings had a wrong length in this test.</p>
<p>At this moment, the new component comes into play: the <kbd>Shrink</kbd>. The job of the shrinker is to find a minimal test data with which the property does not hold. In two previous examples, we used a <kbd>forAllNoShrink</kbd> property constructor and thus had no shrinker active. This is how the result will look like if we change the definition to the normal <kbd>forAll</kbd>:</p>
<pre>scala&gt; forAll(Gen.listOfN(1000, Arbitrary.arbString.arbitrary)) {<br/>     | _.forall(_.length &lt; 10)<br/>     | }.check<br/>! Falsified after 10 passed tests.<br/>&gt; ARG_0: List("")<br/>&gt; ARG_0_ORIGINAL: // a long list as before</pre>
<p>Here, we can see that the minimal list, which falsifies our property, is the list with one empty string. The original failing input is shown as <kbd>ARG_0_ORIGINAL</kbd> and it is of a similar length and complexity as we've seen before.</p>
<p>The <kbd>Shrink</kbd> instances are passed as implicit parameters, so we can summon one to see how they work. We'll do this with our failing value for <kbd>Int</kbd> property:</p>
<pre><span>val </span><span>intShrink</span>: Shrink[Int] = <span>implicitly</span>[Shrink[Int]]<br/>scala&gt; intShrink.shrink(2008612603).toList<br/>res23: List[Int] = List(1004306301, -1004306301, 502153150, -502153150, 251076575, -251076575, 125538287, -125538287, 62769143, -62769143, 31384571, -31384571, 15692285, -15692285, 7846142, -7846142, 3923071, -3923071, 1961535, -1961535, 980767, -980767, 490383, -490383, 245191, -245191, 122595, -122595, 61297, -61297, 30648, -30648, 15324, -15324, 7662, -7662, 3831, -3831, 1915, -1915, 957, -957, 478, -478, 239, -239, 119, -119, 59, -59, 29, -29, 14, -14, 7, -7, 3, -3, 1, -1, 0)</pre>
<p>The <kbd>shrink</kbd> method generates a stream of values and we evaluate it by converting it to the list. It is easy to see the pattern—the values produced by the <kbd>Shrink</kbd> lie symmetrically to the <strong>central</strong> value of <kbd>0</kbd> (zero), starting from the initial failing value, and then are each time divided by two until they converge to the zero. This is pretty much how it is implemented for numbers, including hardcoded values of <kbd>+-two</kbd>, <kbd>+-one</kbd>, and <kbd>zero</kbd>.</p>
<p>It is easy to see that numbers produced by the <kbd>Shrink</kbd> will depend on the initial failing argument. This is why for the first property the <span>returned </span>value will differ each time:</p>
<pre>scala&gt; forAll { (_: Int) &lt; 42 }.check<br/>! Falsified after 0 passed tests.<br/>&gt; ARG_0: 47<br/>&gt; ARG_0_ORIGINAL: 800692446<br/><br/>scala&gt; forAll { (_: Int) &lt; 42 }.check<br/>! Falsified after 0 passed tests.<br/>&gt; ARG_0: 54<br/>&gt; ARG_0_ORIGINAL: 908148321<br/><br/>scala&gt; forAll { (_: Int) &lt; 42 }.check<br/>! Falsified after 2 passed tests.<br/>&gt; ARG_0: 57<br/>&gt; ARG_0_ORIGINAL: 969910515<br/><br/>scala&gt; forAll { (_: Int) &lt; 42 }.check<br/>! Falsified after 6 passed tests.<br/>&gt; ARG_0: 44<br/>&gt; ARG_0_ORIGINAL: 745869268</pre>
<p>As we can see, the resulting failing value depends on the original failing value and is never <kbd>43</kbd>, but sometimes it lies quite close.</p>
<p>Shrinkers are essential at the time there are some properties which do not hold, especially if the input data is of significant size.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">Property-based testing is a supplementary technique to the traditional unit testing and behavior-driven development. It allows one to describe program properties in the form of an abstract specification, and the test data in the form of rules to apply for its generation.</p>
<p class="p1">Properly generated data includes edge cases, which are often ignored during example-based testing, and allows for higher code coverage.</p>
<p class="p1">The <kbd>ScalaCheck</kbd> is a framework for property-based testing with Scala. It has three main components—properties, generators, and shrinkers.</p>
<p class="p1">Universally quantified properties must hold for any test data in any state of the program. Conditional properties are defined for some subset of the data or specific states of the system.</p>
<p class="p1"><kbd>ScalaCheck</kbd> provides a lots of generators for standard types out of the box. The best way to create generators for custom types is by combining existing generators using suitable methods defined on them.</p>
<p class="p1">The role of an optional shrink is to reduce a test data set for a failing property, helping to identify a minimal failing test case.</p>
<p class="p1">There are a few extension libraries available which allow one to generate arbitrary case classes and ADTs (<a href="https://github.com/alexarchambault/scalacheck-shapeless">scalacheck-shapeless</a>), cats type class instances (<a href="https://github.com/non/cats-check">cats-check</a>), and other common cases (<a href="https://github.com/47deg/scalacheck-toolbox">scalacheck-toolbox</a>).</p>
<p>Now, we are properly equipped to start our journey into the land of functional programming concepts, which we will cover in the next part of the book. We will start by examining some types present in the standard library, which are known as effects, such as <kbd>Option</kbd>, <kbd>Try</kbd>, <kbd>Either</kbd>, and <kbd>Future</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Define an invariant property for <span>sorting a list</span></li>
<li>Define an idempotent property for sorting a list</li>
<li>Define an inductive property for sorting a list</li>
<li>Define a generator for a <kbd>List[Lists[Int]]</kbd>, such that elements of the nested list are positive</li>
<li>Define a generator for a <kbd>Map[UUID, () =&gt; String]</kbd></li>
</ol>


            </article>

            
        </section>
    </div>



  </body></html>