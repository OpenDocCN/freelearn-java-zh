- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Spring Cloud Gateway to Hide Microservices behind an Edge Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use Spring Cloud Gateway as an edge server,
    to control what APIs are exposed from our microservices-based system landscape.
    We will see how microservices that have public APIs are made accessible from the
    outside through the edge server, while microservices that have private APIs are
    only accessible from the inside of the microservice landscape. In our system landscape,
    this means that the product composite service and the discovery server, Netflix
    Eureka, will be exposed through the edge server. The three core services, `product`,
    `recommendation`, and `review`, will be hidden from the outside.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding an edge server to our system landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Gateway, including configuring routing rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trying out the edge server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For instructions on how to install the tools used in this book and how to access
    the source code for this book, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Chapter 21*, *Installation Instructions for macOS*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 22*, *Installation Instructions for Microsoft Windows with WSL 2 and
    Ubuntu*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The code examples in this chapter all come from the source code in `$BOOK_HOME/Chapter10`.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to view the changes applied to the source code in this chapter –
    that is, see what it took to add Spring Cloud Gateway as an edge server to the
    microservices landscape – you can compare it with the source code for *Chapter
    9*, *Adding Service Discovery Using Netflix Eureka*.
  prefs: []
  type: TYPE_NORMAL
- en: You can use your favorite `diff` tool and compare the two folders, `$BOOK_HOME/Chapter09`
    and `$BOOK_HOME/Chapter10`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an edge server to our system landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will see how the edge server is added to the system landscape
    and how it affects the way external clients access the public APIs that the microservices
    expose. All incoming requests will now be routed through the edge server, as illustrated
    by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, diagram, text  Description automatically generated](img/B19825_10_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Adding an edge server'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see from the preceding diagram, external clients send all their requests
    to the edge server. The edge server can route the incoming requests based on the
    URL path. For example, requests with a URL that starts with `/product-composite/`
    are routed to the product composite microservice, and a request with a URL that
    starts with `/eureka/` is routed to the discovery server based on Netflix Eureka.
  prefs: []
  type: TYPE_NORMAL
- en: To make the discovery service work with Netflix Eureka, we don’t need to expose
    it through the edge server. The internal services will communicate directly with
    Netflix Eureka. The reasons for exposing it are to make its web page and API accessible
    to an operator that needs to check the status of Netflix Eureka, and to see what
    instances are currently registered in the discovery service.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Chapter 9*, *Adding Service Discovery Using Netflix Eureka*, we exposed
    both the `product-composite` service and the discovery server, Netflix Eureka,
    to the outside. When we introduce the edge server in this chapter, this will no
    longer be the case. This is implemented by removing the following port declarations
    for the two services in the Docker Compose files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the edge server introduced, we will learn how to set up an edge server
    based on Spring Cloud Gateway in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Spring Cloud Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Setting up Spring Cloud Gateway as an edge server is straightforward and can
    be done with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Spring Boot project using Spring Initializr, as described in *Chapter
    3*, *Creating a Set of Cooperating Microservices* – refer to the *Using Spring
    Initializr to generate skeleton code* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a dependency on `spring-cloud-starter-gateway`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be able to locate microservice instances through Netflix Eureka, also add
    the `spring-cloud-starter-netflix-eureka-client` dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the edge server project to the common build file, `settings.gradle`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a `Dockerfile` with the same content as for the microservices; see the `Dockerfile`
    content in the folder `$BOOK_HOME/Chapter10/microservices`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the edge server to our three Docker Compose files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the preceding code, we can see that the edge server exposes port `8080`
    to the outside of Docker Engine. To control how much memory is required, a memory
    limit of `512` MB is applied to the edge server, in the same way as we did for
    the other microservices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since the edge server will handle all incoming traffic, we will move the composite
    health check from the product composite service to the edge server. This is described
    in the *Adding a composite health check* section next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add configuration for routing rules and more. Since there is a lot to configure,
    it is handled in a separate section below, *Configuring a Spring Cloud Gateway*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find the source code for the Spring Cloud Gateway in `$BOOK_HOME/Chapter10/spring-cloud/gateway`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a composite health check
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With an edge server in place, external health check requests also have to go
    through the edge server. Therefore, the composite health check that checks the
    status of all microservices has been moved from the `product-composite` service
    to the edge server. See *Chapter 7*, *Developing Reactive Microservices* – refer
    to the *Adding a health API* section for implementation details for the composite
    health check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following has been added to the edge server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HealthCheckConfiguration` class has been added, which declares the reactive
    health contributor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the preceding code, we can see that a health check for the `product-composite`
    service has been added, instead of the health check used in *Chapter 7*, *Developing
    Reactive Microservices*!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The main application class, `GatewayApplication`, declares a `WebClient.Builder`
    bean to be used by the implementation of the health indicator, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the preceding source code, we can see that `WebClient.builder` is annotated
    with `@LoadBalanced`, which makes it aware of microservice instances registered
    in the discovery server, Netflix Eureka. Refer to the *Service Discovery with
    Netflix Eureka in Spring Cloud* section in *Chapter 9*, *Adding Service Discovery
    Using Netflix Eureka*, for more details.
  prefs: []
  type: TYPE_NORMAL
- en: With a composite health check in place for the edge server, we are ready to
    look at the configuration that needs to be set up for Spring Cloud Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Spring Cloud Gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to configuring Spring Cloud Gateway, the most important thing
    is setting up the routing rules. We also need to set up a few other things in
    the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Since Spring Cloud Gateway will use Netflix Eureka to find the microservices
    it will route traffic to, it must be configured as a Eureka client in the same
    way as described in *Chapter 9*, *Adding Service Discovery Using Netflix Eureka*
    – refer to the *Configuring clients to the Eureka server* section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure Spring Boot Actuator for development usage, as described in *Chapter
    7*, *Developing Reactive Microservices* – refer to the *Adding a health API* section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Configure log levels so that we can see log messages from interesting parts
    of the internal processing in Spring Cloud Gateway, for example, how it decides
    where to route incoming requests to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For the full source code, refer to the configuration file, `src/main/resources/application.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Routing rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Setting up routing rules can be done in two ways: programmatically, using a
    Java DSL, or by configuration. Using a Java DSL to set up routing rules programmatically
    can be useful in cases where the rules are stored in external storage, such as
    a database, or are given at runtime, for example, via a RESTful API or a message
    sent to the gateway. In more static use cases, I find it more convenient to declare
    the routes in the configuration file, `src/main/resources/application.yml`. Separating
    the routing rules from the Java code makes it possible to update the routing rules
    without having to deploy a new version of the microservice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A **route** is defined by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Predicates**, which select a route based on information in the incoming HTTP
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters**, which can modify both the request and/or the response'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **destination URI**, which describes where to send a request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **ID**, that is, the name of the route
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For a full list of available predicates and filters, refer to the reference
    documentation: [https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html](https://cloud.spring.io/spring-cloud-gateway/single/spring-cloud-gateway.html).'
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will first learn how to route requests to the
    `product-composite` service and the Eureka server. After that, we will see how
    predicates and filters can be used, even though they are not used in this book
    elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests to the product-composite API
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If we, for example, want to route incoming requests where the URL path starts
    with `/product-composite/` to our `product-composite` service, we can specify
    a routing rule like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Some points to note from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`id: product-composite`: The name of the route is `product-composite`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uri: lb://product-composite`: If the route is selected by its predicates,
    the request will be routed to the service that is named `product-composite` in
    the discovery service, Netflix Eureka. The protocol `lb://` is used to direct
    Spring Cloud Gateway to use the client-side load balancer to look up the destination
    in the discovery service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`predicates: - Path=/product-composite/**` is used to specify what requests
    this route should match. `**` matches zero or more elements in the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To be able to route requests to the **Swagger UI** set up in *Chapter 5*, *Adding
    an API Description Using OpenAPI*, an extra route to the `product-composite` service
    is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Requests sent to the edge server with a URI starting with `/openapi/` will be
    directed to the `product-composite` service.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Swagger UI is presented behind an edge server, it must be able to
    present an OpenAPI Specification of the API that contains the correct server URL
    – the URL of the edge server instead of the URL of the `product-composite` service
    itself. To enable the `product-composite` service to produce a correct server
    URL in the OpenAPI specification, the following configuration has been added to
    the `product-composite` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For more details, see [https://springdoc.org/index.html#how-can-i-deploy-springdoc-openapi-ui-behind-a-reverse-proxy](https://springdoc.org/index.html#how-can-i-deploy-springdoc-openapi-ui-behind-a-reverse-proxy).
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that the correct server URL is set in the OpenAPI specification,
    the following test has been added to the test script, `test-em-all.bash`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Routing requests to the Eureka server’s API and web page
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Eureka exposes both an API and a web page for its clients. To provide a clean
    separation between the API and the web page in Eureka, we will set up routes as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Requests sent to the edge server with the path starting with `/eureka/api/`
    should be handled as a call to the Eureka API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requests sent to the edge server with the path starting with `/eureka/web/`
    should be handled as a call to the Eureka web page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'API requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    routing rule for the Eureka API looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `{segment}` part in the `Path` value matches zero or more elements in the
    path and will be used to replace the `{segment}` part in the `SetPath` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web page requests will be routed to `http://${app.eureka-server}:8761`. The
    web page will load several web resources, such as `.js`, `.css`, and `.png` files.
    These requests will be routed to `http://${app.eureka-server}:8761/eureka`. The
    routing rules for the Eureka web page look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding configuration, we can take the following notes. The `${app.eureka-server}`
    property is resolved by Spring’s property mechanism, depending on what Spring
    profile is activated:'
  prefs: []
  type: TYPE_NORMAL
- en: When running the services on the same host without using Docker, for example,
    for debugging purposes, the property will be translated to `localhost` using the
    `default` profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When running the services as Docker containers, the Netflix Eureka server will
    run in a container with the DNS name `eureka`. Therefore, the property will be
    translated into `eureka` using the `docker` profile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The relevant parts in the `application.yml` file that define this translation
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have seen how to route requests to both the `product-composite`
    and the Eureka server. As a final step, let’s see how predicates and filters can
    be used in Spring Cloud Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Routing requests with predicates and filters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To learn a bit more about the routing capabilities in Spring Cloud Gateway,
    we will try out **host-based routing**, where Spring Cloud Gateway uses the hostname
    of the incoming request to determine where to route the request. We will use one
    of my favorite websites for testing HTTP codes: [http://httpstat.us/](http://httpstat.us/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A call to `http://httpstat.us/${CODE}` simply returns a response with the `${CODE}`
    HTTP code and a response body, also containing the HTTP code, and a corresponding
    descriptive text. For example, see the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will return the HTTP code `200`, and a response body with the text `200
    OK`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that we want to route calls to `http://${hostname}:8080/headerrouting`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Calls to the `i.feel.lucky` host should return `200 OK`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to the `im.a.teapot` host should return `418 I'm a teapot`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls to all other hostnames should return `501 Not Implemented`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement these routing rules in Spring Cloud Gateway, we can use the `Host`
    route predicate to select requests with specific hostnames, and the `SetPath`
    filter to set the desired HTTP code in the request path. This can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To make calls to `http://i.feel.lucky:8080/headerrouting` return `200 OK`,
    we can set up the following route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To make calls to `http://im.a.teapot:8080/headerrouting` return `418 I''m a
    teapot`, we can set up the following route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, to make calls to all other hostnames return `501 Not Implemented`,
    we can set up the following route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Okay, that was quite a bit of configuration, so let’s now try it out!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the edge server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To try out the edge server, we perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, build the Docker images with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, start the system landscape in Docker and run the usual tests with the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect output similar to what we have seen in previous chapters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_10_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Output from test-em-all.bash'
  prefs: []
  type: TYPE_NORMAL
- en: From the log output, note the second to last test result, `http://localhost:8080`.
    That is the output from the test that verifies that the server URL in Swagger
    UI’s OpenAPI specification is correctly rewritten as the URL of the edge server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the system landscape, including the edge server, up and running, let’s
    explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Examining what is exposed by the edge server outside of the system landscape
    running in the Docker engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trying out some of the most frequently used routing rules as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using URL-based routing to call our APIs through the edge server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using URL-based routing to call the Swagger UI through the edge server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using URL-based routing to call Netflix Eureka through the edge server, both
    using its API and web-based UI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using header-based routing to see how we can route requests based on the hostname
    in the request
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining what is exposed outside the Docker engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand what the edge server exposes to the outside of the system landscape,
    perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `docker-compose ps` command to see which ports are exposed by our services:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we can see in the following output, only the edge server (named `gateway`)
    exposes its port (`8080`) outside the Docker engine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Timeline  Description automatically generated with medium confidence](img/B19825_10_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Output from docker-compose ps'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to see what routes the edge server has set up, we can use the `/actuator/gateway/routes`
    API. The response from this API is rather verbose. To limit the response to information
    we are interested in, we can apply a `jq` filter. In the following example, the
    `id` of the route and the `uri` that the request will be routed to are selected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This command will respond with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_10_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Spring Cloud Gateway routing rules'
  prefs: []
  type: TYPE_NORMAL
- en: This gives us a good overview of the actual routes configured in the edge server.
    Now, let’s try out the routes!
  prefs: []
  type: TYPE_NORMAL
- en: Trying out the routing rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will try out the edge server and the routes it exposes to
    the outside of the system landscape. Let’s start by calling the `product-composite`
    API and its Swagger UI. Then, we’ll call the Eureka API and visit its web page.
    Finally, we’ll conclude by testing the routes that are based on hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: Calling the product composite API through the edge server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s perform the following steps to call the product composite API through
    the edge server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to see what is going on in the edge server, we can follow its log
    output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in a separate terminal window, make the call to the `product-composite`
    API through the edge server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect the normal type of response from the `product-composite` API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface  Description automatically generated](img/B19825_10_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.5: Output from retrieving the composite product with Product ID 1'
  prefs: []
  type: TYPE_NORMAL
- en: 'We should be able to find the following information in the log output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_10_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.6: Log output from the edge server'
  prefs: []
  type: TYPE_NORMAL
- en: From the log output, we can see the pattern matching based on the predicate
    we specified in the configuration, and we can see which microservice instance
    the edge server selected from the available instances in the discovery server
    – in this case, it forwards the request to `http://b8013440aea0:8080/product-composite/1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calling the Swagger UI through the edge server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To verify that we can reach the Swagger UI introduced in *Chapter 5*, *Adding
    an API Description Using OpenAPI*, through the edge server, open the URL `http://localhost:8080/openapi/swagger-ui.html`
    in a web browser. The resulting Swagger UI page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, text, application  Description automatically generated](img/B19825_10_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.7: The Swagger UI through the edge server, gateway'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the server URL: `http://localhost:8080`; this means that the `product-composite`
    API’s own URL, `http://product-service:8080/`, has been replaced in the OpenAPI
    specification returned by the Swagger UI.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to, you can proceed and actually try out the `product-composite`
    API in the Swagger UI, as we did back in *Chapter 5*, *Adding an API Description
    Using OpenAPI*!
  prefs: []
  type: TYPE_NORMAL
- en: Calling Eureka through the edge server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To call Eureka through an edge server, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, call the Eureka API through the edge server to see what instances are
    currently registered in the discovery server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect a response along the lines of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Text  Description automatically generated](img/B19825_10_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.8: Eureka listing the edge server, gateway, in the REST call'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the edge server (named `gateway`) is also present in the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the Eureka web page in a web browser using the URL `http://localhost:8080/eureka/web`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Graphical user interface, website  Description automatically generated](img/B19825_10_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.9: Eureka listing the edge server, gateway, in the web UI'
  prefs: []
  type: TYPE_NORMAL
- en: From the preceding screenshot, we can see the Eureka web page reporting the
    same available instances as the API response in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Routing based on the host header
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s wrap up by testing the route configuration based on the hostname used
    in the requests to see predicates and filters in use!
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, the hostname in the request is set automatically in the `Host` header
    by the HTTP client. When testing the edge server locally, the hostname will be
    `localhost` – that is not so useful when testing hostname-based routing. However,
    we can cheat by specifying another hostname in the `Host` header in the call to
    the API. Let’s see how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To call for the `i.feel.lucky` hostname, use this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expect the response `200 OK`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For the hostname `im.a.teapot`, use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expect the response `418 I'm a teapot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, if not specifying any `Host` header, use `localhost` as the `Host`
    header:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expect the response `501 Not Implemented`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can also use `i.feel.lucky` and `im.a.teapot` as real hostnames in the requests
    if we add them to the file `/etc/hosts`, specifying that they should be translated
    into the same IP address as `localhost`, that is, `127.0.0.1`. To do so, perform
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to add a row to the `/etc/hosts` file with the required
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now perform the same routing based on the hostname, but without specifying
    the `Host` header. Try it out by running the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Expect the same responses as previously, `200 OK` and `418 I'm a teapot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wrap up the tests by shutting down the system landscape with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clean up the `/etc/hosts` file from the DNS name translation we added for the
    hostnames, `i.feel.lucky` and `im.a.teapot`. Edit the `/etc/hosts` file and remove
    the line we added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These tests of the routing capabilities in the edge server end the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how Spring Cloud Gateway can be used as an edge
    server to control what services are allowed to be called from outside of the system
    landscape. Based on predicates, filters, and destination URIs, we can define routing
    rules in a very flexible way. If we want to, we can configure Spring Cloud Gateway
    to use a discovery service such as Netflix Eureka to look up the target microservice
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: An important topic we still need address is how we prevent unauthorized access
    to the APIs exposed by the edge server, and how we can prevent third parties from
    intercepting traffic.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can secure access to the edge server
    using standard security mechanisms, such as HTTPS, OAuth, and OpenID Connect.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the elements used to build a routing rule in Spring Cloud Gateway called?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the aforementioned elements used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can we instruct Spring Cloud Gateway to locate microservice instances through
    a discovery service such as Netflix Eureka?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a Docker environment, how can we ensure that external HTTP requests to the
    Docker engine can only reach the edge server?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we change the routing rules so that the edge server accepts calls to
    the `product-composite` service on the `http://$HOST:$PORT/api/product` URL instead
    of the currently used `http://$HOST:$PORT/product-composite`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Join our community on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussion with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/SpringBoot3e](https://packt.link/SpringBoot3e)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code1849216352344398875.png)'
  prefs: []
  type: TYPE_IMG
