<html><head></head><body><h1 id="e-jV5W">Chapter 5. Creating Plugins and Modules</h1>
<p id="e-ZKVE">In this chapter, we will cover the following recipes:</p>
<ul id="e-gTvV">
<li id="e-INxQ">Creating and using your own plugin</li>
<li id="e-JTq2">Building a flexible registration module</li>
<li id="e-PDbA">Using the same model for different applications</li>
<li id="e-mUb7">Managing module dependencies</li>
<li id="e-Ettu">Adding private module repositories using Amazon S3</li>
</ul>
<h1 id="e-moWD">Introduction</h1>
<p id="e-BcjO">In this chapter, we will look at how we can break down our Play 2.0 web applications into modular, reusable components. We will look at how we can create plugins and modules as a Play 2.0 subproject and as an independent module published in an internal module repository.</p>
<p id="e-Rrm1">A Play 2.0 plugin can be useful when creating independent services and initializing shared resources such as database connections and Akka actor references. Other examples of useful Play plugins include the  <strong>play.i18n.MessagesPlugin</strong>, which manages internationalization of text, and the <strong>play.api.db.DBPlugin,</strong> which abstracts how a Play web application connects and interfaces with databases.</p>
<p id="e-D2RQ">A Play 2.0 module is useful to create smaller, logical subcomponents of a larger application; this promotes better code maintenance and isolation of tests.</p>

<h1 id="e-GW1i">Creating and using your own plugin</h1>
<p id="e-kWdn">In this recipe, we will explore how to use the Play 2.0 plugin that will monitor the filesystem for a specified file. We will initialize our plugin as part of the Play web application lifecycle, and the main plugin logic will be triggered on application startup.</p>
<h2 id="e-xwZy">How to do it…</h2>
<p id="e-AvtT">For Java, we need to perform the following steps:</p>
<ol id="e-TQ5r">
<li id="e-VexJ">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-qZ8t">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-nmgW">Create the modules directory inside <code>foo_java</code>:<pre id="e-SKjK">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir modules&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-xmQF">Generate the project directory for our first plugin inside <code>foo_java/modules</code>:<pre id="e-m2O8">&lt;span class="strong"&gt;&lt;strong&gt;    activator new filemon play-java&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-s2qC">Remove the contents of the <code>modules/filemon/conf/application.conf</code> file, as these settings will conflict with the main configuration file that we have defined in the project root:<pre id="e-UmWA">echo "" &amp;gt; modules/filemon/conf/application.conf</pre>
</li>
<li id="e-t12e">Remove the contents of the <code>modules/filemon/conf/routes</code> file and rename it to <code>filemon.routes</code>:<pre id="e-WHe1">echo "" &amp;gt; modules/filemon/conf/routes &amp;amp;&amp;amp; mv modules/filemon/conf/routes modules/filemon/conf/filemon.routes</pre>
</li>
<li id="e-pUw9">Remove the views directory from <code>modules/filemon/app</code>:<pre id="e-JpZY">&lt;span class="strong"&gt;&lt;strong&gt;    rm -rf modules/filemon/app/views&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-w1gO">Remove the file <code>modules/filemon/app/controller/Application.java</code>using the following command:<pre id="e-NihZ">&lt;span class="strong"&gt;&lt;strong&gt;    rm modules/filemon/app/controllers/Application.java&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-B7q7">Create a new package inside <code>modules/filemon/app</code>/:<pre id="e-ki3N">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir modules/filemon/app/filemon&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-wQl9">Create the <code>FileMonitor</code> plugin inside <code>modules/filemon/app/FileMonitor.java</code> with the following content:<pre id="e-l67J">package filemon;
     import java.io.*;
    import java.util.concurrent.TimeUnit;
    import akka.actor.ActorSystem;
    import play.Plugin;
    import play.Application;
    import play.libs.Akka;
    import scala.concurrent.duration.Duration;
     public class FileMonitor extends Plugin {
        private Application app;
        private ActorSystem actorSystem = ActorSystem.create("filemon");
        private File file = new File("/var/tmp/foo");
         public FileMonitor(Application app) {
            this.app = app;
        }
       @Override
        public void onStart() {
            actorSystem.scheduler().schedule(
                Duration.create(0, TimeUnit.SECONDS),
                Duration.create(1, TimeUnit.SECONDS),
                new Runnable() {
                    public void run() {
                        if (file.exists()) {
                            System.out.println(file.toString() + " exists..");
                        } else {
                            System.out.println(file.toString() + " does not exist..");    
                        }
                    }
                },
                Akka.system().dispatcher()
            );
        }
       @Override
        public void onStop() {
            actorSystem.shutdown();
        }
       @Override
        public boolean enabled() {
            return true;
        }
    }</pre>
</li>
<li id="e-CxB8">Enable the plugin from the <code>foo_java</code> application by creating the plugin's configuration file, <code>foo_java/conf/play.plugins</code>, and declaring our plugin there:<pre id="e-JDLH">echo "1001:filemon.FileMonitor" &amp;gt; conf/play.plugins</pre>
</li>
<li id="e-bCDa">Add the dependency between the root project (<code>foo_java</code>) and the module (<code>filemon</code>) in <code>build.sbt</code>, and add the <code>aggregate()</code> setting to ensure that activator tasks called from the project root, <code>foo_java</code>, are also invoked on the child module, <code>filemon</code>:<pre id="e-xAyu">lazy val root = (project in file("."))
      .enablePlugins(PlayJava)
      .aggregate(filemon)
      .dependsOn(filemon)
     lazy val filemon = (project in file("modules/filemon"))
      .enablePlugins(PlayJava)</pre>
</li>
<li id="e-Ev4J">Start the <code>foo_java</code> application:<pre id="e-aUAR">&lt;span class="strong"&gt;&lt;strong&gt;    activator clean "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-nYTn">Request the default route and initialize our app:<pre id="e-NdzQ">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-nT4N">Confirm that the file monitor is running by looking at the console log of the <code>foo_java</code> application:<pre id="e-pG3X">&lt;span class="strong"&gt;&lt;strong&gt;(Server started, use Ctrl+D to stop and go back to the console...)&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;[info] Compiling 5 Scala sources and 1 Java source to ...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[success] Compiled in 4s&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Starting file mon&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[info] play - Application started (Dev)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found.. &lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-AcKC">For Scala, we need to perform the following steps:</p>
<ol id="e-TFP9">
<li id="e-ye0I">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-HgFL">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-UqtV">Create the modules directory inside <code>foo_scala</code>:<pre id="e-zbRM">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir modules&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Zf5Q">Generate the project directory for our first plugin inside <code>foo_scala/modules</code>:<pre id="e-PLoa">&lt;span class="strong"&gt;&lt;strong&gt;    activator new filemon play-scala&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-MW3Q">Remove the contents of the <code>modules/filemon/conf/application.conf</code> file:<pre id="e-b33i">&lt;span class="strong"&gt;&lt;strong&gt;    echo "" &amp;gt; modules/filemon/conf/application.conf&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Kxne">Remove the contents of the <code>modules/filemon/conf/routes</code> file and rename it to <code>filemon.routes</code>:<pre id="e-JcoB">echo "" &amp;gt; modules/filemon/conf/routes &amp;amp;&amp;amp; mv modules/filemon/conf/routes  modules/filemon/conf/filemon.routes</pre>
</li>
<li id="e-Zbqj">Remove the views directory from <code>modules/filemon/app</code>:<pre id="e-asBX">&lt;span class="strong"&gt;&lt;strong&gt;    rm -rf modules/filemon/app/views&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-K90v">Remove the file <code>modules/filemon/app/controller/Application.scala</code> using the following command:<pre id="e-bhSY">&lt;span class="strong"&gt;&lt;strong&gt;    rm modules/filemon/app/controllers/Application.scala&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-txnG">Create a new package inside <code>modules/filemon/app/</code>:<pre id="e-ZjA8">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir modules/filemon/app/filemon&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-j1uQ">Create the <code>FileMonitor</code> plugin inside <code>modules/filemon/app/FileMonitor.scala</code> with the following contents:<pre id="e-wQry">package filemon
     import java.io.File
    import scala.concurrent.duration._
    import akka.actor.ActorSystem
    import play.api.{Plugin, Application}
    import play.api.libs.concurrent.Execution.Implicits._
     class FileMonitor(app: Application) extends Plugin {
      val system = ActorSystem("filemon")
      val file = new File("/var/tmp/foo")
       override def onStart() = {
        println("Starting file mon")
        system.scheduler.schedule(0 second, 1 second) {
          if (file.exists()) {
            println("%s exists..".format(file))
          } else {
            println("%s not found..".format(file))
          }
        }
      }
       override def onStop() = {
        println("Stopping file mon")
        system.shutdown()
      }
       override def enabled = true
    }</pre>
</li>
<li id="e-SDSB">Enable the plugin from the <code>foo_scala</code> application by creating the plugin's configuration file, <code>foo_scala/conf/play.plugins</code>, and declaring our plugin there:<pre id="e-EMFc">&lt;span class="strong"&gt;&lt;strong&gt;    echo "1001:filemon.FileMonitor" &amp;gt; conf/play.plugins&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-QhDI">Add the dependency between the root project (<code>foo_scala</code>) and the module (<code>filemon</code>) in <code>build.sbt</code>, and add the <code>aggregate()</code> setting to ensure that activator tasks called from the project root, <code>foo_java</code>, are also invoked on the child module, <code>filemon</code>:<pre id="e-aXQD">lazy val root = (project in file("."))
      .enablePlugins(PlayScala)
      .aggregate(filemon)
      .dependsOn(filemon)
     lazy val filemon = (project in file("modules/filemon"))
      .enablePlugins(PlayScala)</pre>
</li>
<li id="e-UYYJ">Start the <code>foo_scala</code> application:<pre id="e-ZteM">&lt;span class="strong"&gt;&lt;strong&gt;    activator clean "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-zAOD">Request our default route and initialize our app:<pre id="e-IqFn">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-k1Zq">Confirm that the file monitor is running by looking at the console log of the <code>foo_scala</code> application:<pre id="e-va0A">&lt;span class="strong"&gt;&lt;strong&gt;(Server started, use Ctrl+D to stop and go back to the console...)&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;[info] Compiling 5 Scala sources and 1 Java source to ...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[success] Compiled in 4s&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Starting file mon&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[info] play - Application started (Dev)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;/var/tmp/foo not found.. &lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-fiZv">How it works…</h2>
<p id="e-MKhk">In this recipe, we set up our first Play 2.0 plugin. The plugin simply checks for a file or directory in the local filesystem and logs in the console whether the file is found or not. We set up our plugin by creating the plugin project inside the newly created directory in the project root modules in <code>foo_java/modules</code> and <code>foo_scala/modules</code>:</p>
<pre id="e-l2p6">&lt;span class="strong"&gt;&lt;strong&gt;    $ ls&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    LICENSE                     conf&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    README                      logs&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    activator                   modules&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    activator-launch-1.2.10.jar project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    activator.bat               public&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    app                         target&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    build.sbt                   test&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ ls modules/filemon&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    LICENSE                     build.sbt&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    README                      conf&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    activator                   project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    activator-launch-1.2.10.jar public&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    activator.bat               target&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    app                         test&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-wCqy">Once the plugin project is created, we need to remove some boilerplate files and configurations to ensure that the plugin does not conflict with the root projects, <code>foo_java</code> and <code>foo_scala</code>.</p>
<p id="e-sVsW">We then created the <code>FileMonitor</code> plugin in <code>modules/filemon/app/filemon/FileMonitor.scala</code>, extending the <code>play.api.Plugin</code> trait, which upon startup, creates a scheduled job which in turn checks for the existence of a local file every second:</p>
<pre id="e-F5YN">override def onStart() = {
      println("Starting file mon")
      system.scheduler.schedule(0 second, 1 second) {
        if (file.exists()) {
          println("%s exists..".format(file))
        } else {
          println("%s not found..".format(file))
        }
      }
    }</pre>
<p id="e-hBXL">Once we had our plugin in place, we activated it by declaring it in the <code>conf/play.plugins</code> file in the root projects, <code>foo_java</code> and <code>foo_scala</code>, which follow the notation <code>&amp;lt;Priority Level&amp;gt;:&amp;lt;Plugin&amp;gt;</code>:</p>
<pre id="e-TGJT">1001:filemon.FileMonitor</pre>
<p id="e-OUgx">In our case, we used <code>1001</code> as the priority level to ensure that the Akka Play 2.0 plugin loads first. Refer to the official Play documentation for additional guidelines for declaring your plugins in the <code>play.plugins</code> configuration file:</p>
<p id="e-gbjd"><a href="https://www.playframework.com/documentation/2.3.x/JavaPlugins">https://www.playframework.com/documentation/2.3.x/JavaPlugins</a></p>
<p id="e-OhBa"><a href="https://www.playframework.com/documentation/2.3.x/ScalaPlugins">https://www.playframework.com/documentation/2.3.x/ScalaPlugins</a></p>
<p id="e-g4tT">Finally, we ran the web application and confirmed our plugin to be running by watching the console log:</p>
<pre id="e-D62A">&lt;span class="strong"&gt;&lt;strong&gt;    Starting file mon&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-moXe">You can confirm the behavior of your plugin by creating or deleting the monitor file, in this example, <code>/var/tmp/foo</code>:</p>
<pre id="e-IOwe">&lt;span class="strong"&gt;&lt;strong&gt;    # Create foo file then delete after 3 seconds&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    touch /var/tmp/foo &amp;amp;&amp;amp; sleep 3 &amp;amp;&amp;amp; rm /var/tmp/foo&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-zWfw">You will see the output in the logs change accordingly:</p>
<pre id="e-Zrg3">&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo exists..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo exists..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo exists..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    /var/tmp/foo not found..&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-jdAW">Building a flexible registration module</h1>
<p id="e-evrY">In this recipe, we will create a new registration module that will manage user registration and authentication requests. Creating a module for this allows us to reuse a very common workflow in the modern web application.</p>
<h2 id="e-U8ZA">How to do it…</h2>
<p id="e-Bk6M">For Java, we need to perform the following steps:</p>
<ol id="e-xPuP">
<li id="e-JGyj">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-ykJC">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-I5da">Inside the modules directory, <code>foo_java/modules</code>, generate the registration module project using the <code>activator</code>:<pre id="e-QJa8">&lt;span class="strong"&gt;&lt;strong&gt;    activator new registration play-java&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Nhrz">Add the dependency between the root project, <code>foo_java</code>, and the module, <code>registration</code>, in <code>foo_java/build.sbt</code>:<pre id="e-jCPd">lazy val root = (project in file("."))
      .enablePlugins(PlayJava)
      .aggregate(filemon)
      .dependsOn(filemon)
&lt;span class="strong"&gt;&lt;strong&gt;      .aggregate(registration)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;      .dependsOn(registration)&lt;/strong&gt;&lt;/span&gt;
     lazy val filemon = (project in file("modules/filemon"))
      .enablePlugins(PlayJava)
 &lt;span class="strong"&gt;&lt;strong&gt;    lazy val registration = (project in file("modules/registration"))&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;      .enablePlugins(PlayJava)&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-FEAP">Remove all the unnecessary boilerplate files and configurations from the registration module:<pre id="e-s4i1">&lt;span class="strong"&gt;&lt;strong&gt;    rm -rf app/views app/controllers&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    rm conf/routes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    mkdir app/registration&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    echo "" &amp;gt; conf/application.conf&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Sqaf">Create the registration plugin in <code>module/registration/app/registration/RegistrationPlugin.java</code> with the following content:<pre id="e-Iv9J">package registration;
     import play.Application;
    import play.Plugin;
     public class RegistrationPlugin extends Plugin {
        private Application app;
        private RegistrationService registrationService;
         public RegistrationPlugin(Application app) {
            this.app = app;
        }
       @Override
        public void onStart() {
            registrationService = new RegistrationServiceImpl();
            registrationService.init();
        }
        @Override
        public void onStop() {
            registrationService.shutdown();
        }
       @Override
        public boolean enabled() {
            return true;
        }
         public RegistrationService getRegistrationService() {
            return registrationService;
        }
    }</pre>
</li>
<li id="e-r1uf">Next, create the <code>RegistrationService</code> interface and implementation class referred to by the <code>Registration</code> plugin:<pre id="e-jFYO">// In modules/registration/app/registration/RegistrationService.java
     package registration;
     public interface RegistrationService {
        void init();
        void shutdown();
        void create(User user);
        Boolean auth(String username, String password);
    }
     // In modules/registration/app/registration/RegistrationServiceImpl.java    
    package registration;
     import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.UUID;
     public class RegistrationServiceImpl implements RegistrationService {
        private Map&amp;lt;String, User&amp;gt; registrations;
         @Override
        public void create(User user) {
            final String id = UUID.randomUUID().toString();
            registrations.put(id, new User(id, user.getUsername(), user.getPassword()));
        }
         @Override
        public Boolean auth(String username, String password) {
            for(Map.Entry&amp;lt;String, User&amp;gt; entry : registrations.entrySet()) {
                if (entry.getValue().getUsername().equals(username) &amp;amp;&amp;amp;
                    entry.getValue().getPassword().equals(password)) {
                    return true;
                }
            }
            return false;
        }
         @Override
        public void init() {
            registrations = new LinkedHashMap&amp;lt;String, User&amp;gt;();
        }
         @Override
        public void shutdown() {
            registrations.clear();
        }
    }</pre>
</li>
<li id="e-tn3L">Create the <code>User</code> model entity in <code>modules/registration/app/registration/User.java</code>:<pre id="e-EhGb">package registration;
     public class User {
        private String id;
        private String username;
        private String password;
         public User() {}
        public User(String id, String username, String password) {
            this.id = id;
            this.username = username;
            this.password = password;
        }
         public String getId() {
            return id;
        }
        public void setId(String id) {
            this.id = id;
        }
        public String getUsername() {
            return username;
        }
        public void setUsername(String username) {
            this.username = username;
        }
        public String getPassword() {
            return password;
        }
        public void setPassword(String password) {
            this.password = password;
        }
    }</pre>
</li>
<li id="e-n1wJ">Create the <code>Registration</code> controller and routes that will handle registration and login requests in the project root, <code>foo/java/app/controllers/Registrations.java</code>:<pre id="e-YpPR">package controllers;
     import play.Play;
    import play.data.Form;
    import play.mvc.BodyParser;
    import play.mvc.Controller;
    import play.mvc.Result;
    import registration.RegistrationPlugin;
    import registration.RegistrationService;
    import registration.User;
    import static play.libs.Json.toJson;
     public class Registrations extends Controller {
        private static RegistrationService registrationService =          Play.application().plugin(RegistrationPlugin.class).getRegistrationService();
         @BodyParser.Of(BodyParser.Json.class)
        public static Result register() {
            try {
                Form&amp;lt;User&amp;gt; form = Form.form(User.class).bindFromRequest();
                User user = form.get();
                registrationService.create(user);
                return created(toJson(user));
            } catch (Exception e) {
                return internalServerError(e.getMessage());
            }
        }
         @BodyParser.Of(BodyParser.Json.class)
        public static Result login() {
            try {
                Form&amp;lt;User&amp;gt; form = Form.form(User.class).bindFromRequest();
                User user = form.get();
                if (registrationService.auth(user.getUsername(), user.getPassword())) {
                    return ok();
                } else {
                    return forbidden();
                }
            } catch (Exception e) {
                return internalServerError(e.getMessage());
            }
        }
    }</pre>
</li>
<li id="e-n9n2">Add the routes for the newly added <code>Registration</code> actions in the project root, <code>foo_java/conf/routes</code>:<pre id="e-GViR">POST    /register   controllers.Registrations.register
    POST    /auth       controllers.Registrations.login</pre>
</li>
<li id="e-aFNR">Finally, declare the registration plugin in the project root <code>foo_java/conf/play.plugins</code> file:<pre id="e-g8b0">599:registration.RegistrationPlugin</pre>
</li>
<li id="e-oaDB">Using <code>curl</code>, submit a new registration and log in with the specified registration details; verify that our endpoint responds with an HTTP status 200 for successful operations by inspecting the response headers:<pre id="e-AQ0r">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST --header "Content-type: application/json"  http://localhost:9000/register -d '{"username":"ned@flanders.com", "password":"password"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /register HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 54&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 54 out of 54 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 63&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"id":null,"username":"ned@flanders.com","password":"password"}%&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST --header "Content-type: application/json"  http://localhost:9000/auth -d '{"username":"ned@flanders.com", "password":"password"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /auth HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 54&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 54 out of 54 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-DUMm">For Scala, we need to perform the following steps:</p>
<ol id="e-Cicj">
<li id="e-e3Gh">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-Oxx7">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-AHhg">Inside the modules directory (<code>foo_scala/modules</code>), generate our registration module project using the <code>activator</code>:<pre id="e-kDSg">&lt;span class="strong"&gt;&lt;strong&gt;    activator new registration play-scala&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-NmnZ">Add the dependency between the root project, <code>foo_scala</code>, and the module, <code>registration</code>, in <code>build.sbt</code>:<pre id="e-D7yq">lazy val root = (project in file("."))
      .enablePlugins(PlayScala)
      .aggregate(filemon)
      .dependsOn(filemon)
&lt;span class="strong"&gt;&lt;strong&gt;      .aggregate(registration)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;      .dependsOn(registration)&lt;/strong&gt;&lt;/span&gt;
     lazy val filemon = (project in file("modules/filemon"))
      .enablePlugins(PlayScala)
 &lt;span class="strong"&gt;&lt;strong&gt;    lazy val registration = (project in file("modules/registration"))&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;      .enablePlugins(PlayScala)&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-pAjb">Remove all the unnecessary boilerplate files and configurations from the registration module:<pre id="e-m8nV">&lt;span class="strong"&gt;&lt;strong&gt;    rm -rf app/views app/controllers&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    rm conf/routes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    mkdir app/registration&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    echo "" &amp;gt; conf/application.conf&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-B2Wo">Create the registration plugin in <code>module/registration/app/registration/RegistrationPlugin.scala</code> with the following content:<pre id="e-r6Ge">package registration
     import play.api.{Application, Plugin}
     class RegistrationPlugin(app: Application) extends Plugin {
      val registrationService = new RegistrationService
       override def onStart() = {
        registrationService.init
      }
       override def onStop() = {
        registrationService.shutdown
      }
       override def enabled = true
    }</pre>
</li>
<li id="e-hccA">Next, create the <code>RegistrationService</code> class referred to by the <code>Registration</code> plugin:<pre id="e-XXjr">// In modules/registration/app/registration/RegistrationService.scala
     package registration
     import java.util.UUID
     class RegistrationService {
      type ID = String
      private val registrations = scala.collection.mutable.Map[ID, User]()
       def init = {
        registrations.clear()
      }
       def create(user: User) = {
        val id: ID = UUID.randomUUID().toString
        registrations += (id -&amp;gt; user.copy(Some(id), user.username, user.password))
      }
       def auth(username: String, password: String) = registrations.find(_._2.username equals username) match {
        case Some(reg) =&amp;gt; {
          if (reg._2.password equals password) {
            Some(reg._2)
          } else {
            None
          }
        }
        case None =&amp;gt; None
      }
       def shutdown = {
        registrations.clear()
      }
    }</pre>
</li>
<li id="e-dr6j">Create the <code>User</code> model entity in <code>modules/registration/app/registration/User.scala</code>:<pre id="e-N1BV">package registration
     case class User(id: Option[String], username: String, password: String)</pre>
</li>
<li id="e-iO6Z">Create the <code>Registration</code> controller and routes that will handle registration and login requests in the project root, <code>foo_scala/app/controllers/Registrations.scala</code>:<pre id="e-aqFE">package controllers
     import play.api.Play.current
    import play.api.Play
    import play.api.libs.json.{JsError, Json}
    import play.api.mvc.{BodyParsers, Action, Controller}
    import registration.{RegistrationPlugin, User, RegistrationService}
     object Registrations extends Controller {
      implicit private val writes = Json.writes[User]
      implicit private val reads = Json.reads[User]
      private val registrationService: RegistrationService = Play.application.plugin[RegistrationPlugin]
    .getOrElse(throw new IllegalStateException("RegistrationService is required!"))
    .registrationService
       def register = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
        val post = request.body.validate[User]
         post.fold(
          errors =&amp;gt; BadRequest(JsError.toFlatJson(errors)),
          u =&amp;gt; {
            registrationService.create(u)
            Created(Json.toJson(u))
          }
        )
      }
       def login = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
        val login = request.body.validate[User]
         login.fold(
          errors =&amp;gt; BadRequest(JsError.toFlatJson(errors)),
          u =&amp;gt; {
            registrationService.auth(u.username, u.password) match {
              case Some(user) =&amp;gt; Ok
              case None =&amp;gt; Forbidden
            }
          }
        )
      }
    }</pre>
</li>
<li id="e-h3DE">Add the routes for the newly added <code>Registration</code> actions:<pre id="e-hnYV">POST    /register   controllers.Registrations.register
    POST    /auth       controllers.Registrations.login</pre>
</li>
<li id="e-LWC9">Finally, declare the registration plugin in the project root, <code>foo_scala/conf/play.plugins</code> file:<pre id="e-FHIM">599:registration.RegistrationPlugin</pre>
</li>
<li id="e-GVdA">Using <code>curl</code>, submit a new registration and login with the specified registration details; verify that our endpoint responds with an HTTP status 200 for successful operations by inspecting the response headers:<pre id="e-vxpA">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST --header "Content-type: application/json"  http://localhost:9000/register -d '{"username":"ned@flanders.com", "password":"password"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /register HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 54&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 54 out of 54 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 63&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"id":null,"username":"ned@flanders.com","password":"password"}%&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST --header "Content-type: application/json"  http://localhost:9000/auth -d '{"username":"ned@flanders.com", "password":"password"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /auth HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 54&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 54 out of 54 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-ZsCy">How it works…</h2>
<p id="e-HUHN">In this recipe, we created a module that will handle registration functions, such as signup and login. We created it as a Play plugin so that it can not only be maintainable but also reusable in other applications. Another advantage of using modules is that when writing unit tests, we can isolate its execution in its enclosed subproject only and not the entire project.</p>
<p id="e-zAIl">We created the <code>registration</code> plugin inside the modules directory in our project root directory. We declared the dependency between the module and the main project in <code>build.sbt</code>:</p>
<pre id="e-N6pp">lazy val root = (project in file("."))
      .enablePlugins(PlayScala)
      .aggregate(filemon)
      .dependsOn(filemon)
      .aggregate(registration)
      .dependsOn(registration)</pre>
<p id="e-Snip">We then enabled the plugin in <code>conf/play.plugins</code> using the priority level <code>599</code>, within the 500-600 range for data-related plugins:</p>
<pre id="e-oWSY">599:registration.RegistrationPlugin</pre>
<p id="e-us0x">We then grabbed a reference to the <code>RegistrationService</code> interface from the <code>Registration</code> plugin inside the controller:</p>
<pre id="e-DYK8">// Java
    private static RegistrationService registrationService =
            Play.application().plugin(RegistrationPlugin.class).getRegistrationService();
     // Scala
    private val registrationService: RegistrationService = Play.application.plugin[RegistrationPlugin]
    .getOrElse(throw new IllegalStateException("RegistrationService is required!"))
    .registrationService</pre>
<p id="e-Qd4T">Once we established the reference, all registration functions were simply delegated to the <code>RegistrationService</code> interface from the controller:</p>
<pre id="e-ufPb">// Java
    registrationService.create(user);
     // Scala
    registrationService.create(u)</pre>
<p id="e-RSjj">Using <code>curl</code>, we can also validate that our registration controller responds correctly to bad authentication:</p>
<pre id="e-Eqls">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST --header "Content-type: application/json"  http://localhost:9000/auth -d '{"username":"ned@flanders.com", "password":"passwordz"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /auth HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 55&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 55 out of 55 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 403 Forbidden&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-cEZa">Using the same model for different applications</h1>
<p id="e-lzvt">For this recipe, we will create a new standalone module that will contain product-related functions and data model classes, and we will publish it on a local repository:</p>
<h2 id="e-MPWK">How to do it…</h2>
<p id="e-kI50">For Java, we need to perform the following steps:</p>
<ol id="e-yrb0">
<li id="e-w4Dt">Create a new Play 2 project in the same directory level as <code>foo_java</code>:<pre id="e-A9u9">&lt;span class="strong"&gt;&lt;strong&gt;    activator new product-contrib play-java&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-JnfI">Create our default module package inside the app directory, <code>product-contrib/app</code>:<pre id="e-HCB3">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir app/productcontrib&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-coWu">Create the models package, which will contain all the data model classes:<pre id="e-Fypa">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir app/productcontrib/models&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-FXzv">Remove the contents of the <code>conf/application.conf</code> file:<pre id="e-Wect">echo "" &amp;gt; conf/application.conf</pre>
</li>
<li id="e-mtGh">Remove the contents of the <code>conf/routes</code> file and rename it to <code>productcontrib.routes</code>:<pre id="e-oXsW">echo "" &amp;gt; conf/routes &amp;amp;&amp;amp; mv conf/routes  modules/filemon/conf/productcontrib.routes</pre>
</li>
<li id="e-cYka">Remove the views directory from <code>modules/filemon/app</code>:<pre id="e-xfxm">&lt;span class="strong"&gt;&lt;strong&gt;    rm -rf app/views&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-PM4G">Remove the file <code>app/controller/Application.java</code>:<pre id="e-N0I2">&lt;span class="strong"&gt;&lt;strong&gt;    rm app/controllers/Application.java&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-DoRj">Create the product model in <code>app/productcontrib/models/Product.java</code> with the following contents:<pre id="e-Zb75">package productcontrib.models;
     import java.io.Serializable;
     public class Product implements Serializable {
        private String sku;
        private String title;
        private Double price;
         public String getSku() {
            return sku;
        }
        public void setSku(String sku) {
            this.sku = sku;
        }
        public String getTitle() {
            return title;
        }
        public void setTitle(String title) {
            this.title = title;
        }
        public Double getPrice() {
            return price;
        }
        public void setPrice(Double price) {
            this.price = price;
        }
    }</pre>
</li>
<li id="e-jC1d">Create the <code>ProductService</code> interface (<code>ProductService.java</code>) and In implementation class (<code>ProductServiceImpl.java</code>) in the package <code>app/productcontrib/services</code>:<pre id="e-iMDA">// ProductService.java
    package productcontrib.services;
     public interface ProductService {
        String generateProductId();
    }
     // ProductServiceImpl.java 
   package productcontrib.services;
     import java.util.UUID;
     public class ProductServiceImpl implements ProductService {
        @Override
        public String generateProductId() {
            return UUID.randomUUID().toString();
        }
    }</pre>
</li>
<li id="e-dVT0">Insert additional module package settings in the <code>build.sbt</code> file:<pre id="e-J0ug">name := """product-contrib"""
  version := "1.0-SNAPSHOT"
  organization := "foojava"</pre>
</li>
<li id="e-HMHq">Using the activator, build the <code>contrib.jar</code> and publish it to the remote internal repository:<pre id="e-FYvd">&lt;span class="strong"&gt;&lt;strong&gt;    activator clean publish-local&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-FaSz">You should be able to confirm in the console logs whether the upload was successful or not:<pre id="e-iQPJ">&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published product-contrib_2.11 to /.ivy2/local/foojava/product-contrib_2.11/1.0-SNAPSHOT/poms/product-contrib_2.11.pom&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published product-contrib_2.11 to /.ivy2/local/foojava/product-contrib_2.11/1.0-SNAPSHOT/jars/product-contrib_2.11.jar&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published product-contrib_2.11 to /.ivy2/local/foojava/product-contrib_2.11/1.0-SNAPSHOT/srcs/product-contrib_2.11-sources.jar&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published product-contrib_2.11 to /.ivy2/local/foojava/product-contrib_2.11/1.0-SNAPSHOT/docs/product-contrib_2.11-javadoc.jar&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published ivy to /.ivy2/local/foojava/product-contrib_2.11/1.0-SNAPSHOT/ivys/ivy.xml&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-DNDn">For Scala, we need to perform the following steps:</p>
<ol id="e-yN7p">
<li id="e-YWhI">Create a new Play 2 project in the same directory level as <code>foo_scala</code>:<pre id="e-Eb4L">&lt;span class="strong"&gt;&lt;strong&gt;    activator new user-contrib play-scala&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-dDTg">Create the default module package inside the app directory, <code>user-contrib/app</code>:<pre id="e-Nixq">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir app/usercontrib&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-PjUc">Create the models package that will contain all the data model classes:<pre id="e-CGNy">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir app/usercontrib/models&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-JyIp">Remove the contents of the <code>conf/application.conf</code> file:<pre id="e-Zh0h">echo "" &amp;gt; conf/application.conf</pre>
</li>
<li id="e-WiVE">Remove the contents of the <code>conf/routes</code> file and rename it to <code>usercontrib.routes</code>:<pre id="e-uMGD">echo "" &amp;gt; conf/routes &amp;amp;&amp;amp; mv conf/routes  modules/filemon/conf/usercontrib.routes</pre>
</li>
<li id="e-Sx7S">Remove the views directory from <code>modules/filemon/app</code>:<pre id="e-yWhM">&lt;span class="strong"&gt;&lt;strong&gt;    rm -rf app/views&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-jCva">Remove the file <code>app/controller/Application.scala</code>:<pre id="e-DFfV">&lt;span class="strong"&gt;&lt;strong&gt;    rm app/controllers/Application.scala&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-HoOB">Create the <code>User</code> model in <code>app/usercontrib/models/User.scala</code> with the following content:<pre id="e-t0T9">package usercontrib.models
     import java.util.UUID
     case class User(id: Option[String], username: String, password: String)
     object User {
      def generateId = UUID.randomUUID().toString
    }</pre>
</li>
<li id="e-z7ju">Insert additional module package settings in the <code>build.sbt</code> file:<pre id="e-zh1b">name := """product-contrib"""
  version := "1.0-SNAPSHOT"
  organization := "foojava"</pre>
</li>
<li id="e-mMeP">Using the activator, build the <code>contrib.jar</code> and publish it to the remote internal repository:<pre id="e-iM8k">&lt;span class="strong"&gt;&lt;strong&gt;    activator clean publish-local&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-PyMu">You should be able to confirm in the console logs whether the upload was successful or not:<pre id="e-T5hg">&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published user-contrib_2.11 to ivy/fooscala/user-contrib_2.11/1.0-SNAPSHOT/user-contrib_2.11-1.0-SNAPSHOT.pom&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published user-contrib_2.11 to ivy/fooscala/user-contrib_2.11/1.0-SNAPSHOT/user-contrib_2.11-1.0-SNAPSHOT.jar&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published user-contrib_2.11 to ivy/fooscala/user-contrib_2.11/1.0-SNAPSHOT/user-contrib_2.11-1.0-SNAPSHOT-sources.jar&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published user-contrib_2.11 to ivy/fooscala/user-contrib_2.11/1.0-SNAPSHOT/user-contrib_2.11-1.0-SNAPSHOT-javadoc.jar&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-eZmz">How it works…</h2>
<p id="e-CM7r">In this recipe, we created a new Play 2.0 module with the intention of packaging and publishing the module in our local repository. This makes the Play module available to the other Play web applications we will be working on. We created our model and service classes for a product that will be part of our module:</p>
<pre id="e-bMww"># Java 
     $ find app/productcontrib
    app/productcontrib
    app/productcontrib/models
    app/productcontrib/models/Product.java
    app/productcontrib/services
    app/productcontrib/services/ProductService.java
    app/productcontrib/services/ProductServiceImpl.java
     # Scala
  $ find app/usercontrib
    app/usercontrib
    app/usercontrib/models
    app/usercontrib/models/User.scala</pre>
<p id="e-BWtL">We built and published both modules into an internal repository using the <code>activator</code> publish command:</p>
<pre id="e-jQWL">&lt;span class="strong"&gt;&lt;strong&gt;    activator clean publish-local&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-aDBv">Once these modules were published in the internal repository, we then declared them as dependencies to Maven-based Java projects, not limited to Play 2.0 applications, in our case, <code>build.sbt</code>:</p>
<pre id="e-Bpae">// Java 
    "foojava" %% "product-contrib" % "1.0-SNAPSHOT"
     // Scala
    "fooscala" %% "user-contrib" % "1.0-SNAPSHOT"</pre>

<h1 id="e-xNj3">Managing module dependencies</h1>
<p id="e-UkKJ">In this recipe, we will tackle the topic of adding Play modules to your Play 2.0 application, which further demonstrates how powerful the Play 2.0 ecosystem is. This recipe requires the previous recipe to be run and assumes that you have followed on.</p>
<h2 id="e-wPoz">How to do it…</h2>
<p id="e-lDJh">For Java, we need to perform the following steps:</p>
<ol id="e-lPwn">
<li id="e-KYhw">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-Yxcc">activator "~run"</pre>
</li>
<li id="e-ZQjg">Add the <code>fooscala user-contrib</code> module as a project dependency in <code>build.sbt</code>:<pre id="e-usIM">"fooscala" %% "user-contrib" % "1.0-SNAPSHOT",
    "foojava" %% "product-contrib" % "1.0-SNAPSHOT"</pre>
</li>
<li id="e-TKdA">Modify <code>foo_java/app/controllers/Application.java</code> by adding the following action:<pre id="e-fuE4">// Add the required imports  
    import productcontrib.services.ProductService;
    import productcontrib.services.ProductServiceImpl;
    import usercontrib.models.User;
     // Add the necessary Action methods and helper
    private static ProductService productService = new ProductServiceImpl();
     public static Result generateProductId() {
        return ok("Your generated product id: " + productService.generateProductId());
    }
     public static Result generateUserId() {
        return ok("Your generated product id: " + User.generateId());
    }</pre>
</li>
<li id="e-ee5k">Add a new route for the newly added action in <code>foo_java/conf/routes</code>:<pre id="e-EyPR">GET     /generate-product-id       controllers.Application.generateProductId()
    GET     /generate-user-id          controllers.Application.generateUserId()</pre>
</li>
<li id="e-XkuZ">Using <code>curl</code>, we will be able to display the product and user Ids generated from the product and <code>user contrib</code> modules:<pre id="e-x9b4">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl http://localhost:9000/generate-product-id&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Your generated product id: 3acd3f36-6ee6-45ce-af07-faa257724b1e%                &lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ curl http://localhost:9000/generate-user-id&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Your generated product id: ffca654e-35d8-48cd-9acd-9ea9fe567ba7%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-CdMe">For Scala, we need to perform the following steps:</p>
<ol id="e-H4Jh">
<li id="e-zlGj">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-id5n">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-DXrE">Add the <code>foojava productcontrib</code> module as a project dependency in <code>build.sbt</code>:<pre id="e-A6wt">"foojava" %% "product-contrib" % "1.0-SNAPSHOT",
  "fooscala" %% "user-contrib" % "1.0-SNAPSHOT"</pre>
</li>
<li id="e-WDWO">Modify <code>foo_scala/app/controllers/Application.scala</code> by adding the following action:<pre id="e-vrXG">import productcontrib.services.{ProductServiceImpl, ProductService}
    import usercontrib.models.User
     def productService: ProductService = new ProductServiceImpl
     def generateProductId = Action {
      Ok("Your generated product id: " + productService.generateProductId())
    }
     def generateUserId = Action {
      Ok("Your generated product id: " + User.generateId);
    }</pre>
</li>
<li id="e-znfJ">Add a new route for the newly added action in <code>foo_scala/conf/routes</code>:<pre id="e-ccXX">GET     /generate-product-id       controllers.Application.generateProductId()
    GET     /generate-user-id          controllers.Application.generateUserId()</pre>
</li>
<li id="e-vUQt">Using <code>curl</code>, we will be able to display the product and user Ids generated from the product and user contrib modules:<pre id="e-xsnQ">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl http://localhost:9000/generate-product-id&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Your generated product id: 3acd3f36-6ee6-45ce-af07-faa257724b1e%                &lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ curl http://localhost:9000/generate-user-id&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;Your generated product id: ffca654e-35d8-48cd-9acd-9ea9fe567ba7%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-pLQZ">How it works…</h2>
<p id="e-dGM6">In this recipe, we explored how to include other modules into our Play 2.0 web application. With this recipe, we also displayed how Play Scala apps can work side by side with Play Java modules and vice versa.</p>
<p id="e-jxJr">We first declared that our root project will use both user and product contrib modules in <code>build.sbt</code>:</p>
<pre id="e-vWVZ">libraryDependencies ++= Seq(
      "foojava" %% "product-contrib" % "1.0-SNAPSHOT",
      "fooscala" %% "user-contrib" % "1.0-SNAPSHOT"
    )</pre>
<p id="e-Uqay">We then added the import statements to our controller so we could invoke their ID generation functions:</p>
<pre id="e-MULe">// Java
    import productcontrib.services.ProductService;
    import productcontrib.services.ProductServiceImpl;
    import usercontrib.models.User;
     // Invoke the contrib functions in foo_java
    return ok("Your generated product id: " + productService.generateProductId());
    return ok("Your generated product id: " + User.generateId());
    
     // Scala
    import productcontrib.services.{ProductServiceImpl, ProductService}
    import usercontrib.models.User
     // Invoke the contrib functions in foo_scala:
    Ok("Your generated product id: " + productService.generateProductId())
    Ok("Your generated product id: " + User.generateId);</pre>
<p id="e-lXBg">Finally, we used <code>curl</code> to request our new routes to see the generated Ids in action.</p>

<h1 id="e-xWC8">Adding private module repositories using Amazon S3</h1>
<p id="e-N5Rq">In this recipe, we will explore how we can use an external module repository to publish and resolve internal modules in the interest of distributing our modules. In this recipe, we will use Amazon S3, a popular cloud storage service, to store our ivy-style repository assets. You will need a valid AWS account to follow this recipe, ensure that you sign up for one at <a href="http://aws.amazon.com/">http://aws.amazon.com/</a>.</p>
<p id="e-Jhdf">Please refer to S3's online documentation for more information:</p>
<p id="e-xnbu"><a href="http://aws.amazon.com/s3/">http://aws.amazon.com/s3/</a></p>
<h2 id="e-zAzl">How to do it…</h2>
<p id="e-fMjj">We need to perform the following steps:</p>
<ol id="e-BfoS">
<li id="e-aLP0">Open the <code>product-contrib</code> project and run the application with Hot-Reloading enabled:<pre id="e-ps2D">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-IEJd">Edit the plugins config file in <code>project/plugins.sbt</code> and add the following plugin and resolver:<pre id="e-qUOF">resolvers += "Era7 maven releases" at "http://releases.era7.com.s3.amazonaws.com"
     addSbtPlugin("ohnosequences" % "sbt-s3-resolver" % "0.12.0")</pre>
</li>
<li id="e-gcgC">Edit the build config file in <code>build.sbt</code> to specify the settings we'll use for the S3 resolver plugin:<pre id="e-T6nd">S3Resolver.defaults
     s3credentials := file(System.getProperty("user.home")) / ".sbt" / ".s3credentials"
     publishMavenStyle := false
     publishTo := {
      val prefix = if (isSnapshot.value) "snapshots" else "releases"
      Some(s3resolver.value(prefix+" S3 bucket",     s3(prefix+".YOUR-S3-BUCKET-NAME-HERE.amazonaws.com")) withIvyPatterns)
    }</pre>
</li>
<li id="e-pqbc">Specify your Amazon S3 API keys in the file <code>~/.sbt/.s3credentials</code>:<pre id="e-Rcr7">accessKey = &amp;lt;YOUR S3 API ACCESS KEY&amp;gt;
    secretKey = &amp;lt;YOUR S3 API SECRET KEY&amp;gt;</pre>
</li>
<li id="e-XmB2">Next, publish the <code>product-contrib</code> snapshot using the activator:<pre id="e-bg6J">&lt;span class="strong"&gt;&lt;strong&gt;    activator clean publish&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-gzRo">You will see the success status message of the upload in the console logs:<pre id="e-fi8s">&lt;span class="strong"&gt;&lt;strong&gt;    [info]   published ivy to s3://snapshots.XXX.XXX.amazonaws.com/foojava/product-contrib_2.11/1.0-SNAPSHOT/ivys/ivy.xml&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 58 s, completed 02 3, 15 9:39:44 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-eRhR">We will now use this repository in a new Play 2.0 application:<pre id="e-y9uj">&lt;span class="strong"&gt;&lt;strong&gt;    activator new s3deps play-scala&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-x8HJ">Edit the plugins config file in <code>s3deps/project/plugins.sbt</code> and add the following plugin and resolver:<pre id="e-jehK">resolvers += "Era7 maven releases" at "http://releases.era7.com.s3.amazonaws.com"
    addSbtPlugin("ohnosequences" % "sbt-s3-resolver" % "0.12.0")</pre>
</li>
<li id="e-yfSp">Edit the build config file in <code>build.sbt</code> to specify the settings we'll use for the S3 resolver plugin:<pre id="e-lokV">S3Resolver.defaults
     resolvers ++= Seq[Resolver](
      s3resolver.value("Snapshots resolver", s3("YOUR-S3-BUCKET-NAME-HERE.amazonaws.com")) withIvyPatterns
    )
     libraryDependencies ++= Seq(
      "foojava" %% "product-contrib" % "1.0-SNAPSHOT"
    )</pre>
</li>
<li id="e-Jrmu">Retrieve the product-contrib module using the activator:<pre id="e-zYN0">activator clean dependencies
   ...
    com.typesafe.play:play-java-ws_2.11:2.3.7
    com.typesafe.play:play-java-jdbc_2.11:2.3.7
    foojava:product-contrib_2.11:1.0-SNAPSHOT</pre>
</li>
</ol>
<h2 id="e-vqKC">How it works…</h2>
<p id="e-sn5C">In this recipe, we used the sbt-s3-resolver plugin to publish and resolve dependencies using Amazon S3. We included the <code>sbt</code> plugin in the file <code>project/plugins.sbt</code>:</p>
<pre id="e-OCBq">resolvers += "Era7 maven releases" at "http://releases.era7.com.s3.amazonaws.com"
     addSbtPlugin("ohnosequences" % "sbt-s3-resolver" % "0.12.0")</pre>
<p id="e-JpKR">We specify our Amazon S3 API keys in the <code>.s3credentials</code> files in <code>~/.sbt directory</code>:</p>
<pre id="e-KqS9">accessKey = &amp;lt;ACCESS KEY&amp;gt;
    secretKey = &amp;lt;SECRET KEY&amp;gt;</pre>
<p id="e-NBy1">For publishing, we specify the resolver repository in <code>build.sbt</code> of the publishing project (product-contrib):</p>
<pre id="e-TCiv">S3Resolver.defaults
     s3credentials := file(System.getProperty("user.home")) / ".sbt" / ".s3credentials"
     publishMavenStyle := false
     publishTo := {
      val prefix = if (isSnapshot.value) "snapshots" else "releases"
      Some(s3resolver.value(prefix+" S3 bucket",     s3(prefix+".achiiva.devint.amazonaws.com")) withIvyPatterns)
    }</pre>
<p id="e-UcjM">To resolve dependencies, we specify the following in <code>build.sbt</code> of the consuming project (s3deps):</p>
<pre id="e-A0Aw">S3Resolver.defaults
     resolvers ++= Seq[Resolver](
  s3resolver.value("Snapshots resolver", s3("YOUR-S3-BUCKET-NAME-HERE.amazonaws.com")) withIvyPatterns
    )
     libraryDependencies ++= Seq(
      "foojava" %% "product-contrib" % "1.0-SNAPSHOT"
    )</pre>
</body></html>