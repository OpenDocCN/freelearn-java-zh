- en: Chapter 11. JSF 2.2 Resource Library Contracts – Themes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with version 2.0, JSF developers exploit Facelets as the default **View
    Declaration Language** (**VDL**). Facelets provide many advantages, but we are
    especially interested in using **Facelet templates**, which represent a mix of
    XHTML and other resources such as CSS, JS, and images. A Facelet template acts
    as a base (or a model) for the application pages. Practically, it represents a
    piece of reusable code that serves as a consistent and standard look and feel
    for the application pages. In the final chapter of this book, we will get more
    into the details of Facelets and templating, while in this chapter we will focus
    on the new JSF 2.2 feature known as **Resource Library Contracts**.
  prefs: []
  type: TYPE_NORMAL
- en: This new feature fortifies and simplifies the implementation of **themes** (such
    as PrimeFaces or RichFaces) by allowing us to easily decorate and use Facelet
    templates over the entire application in a reusable and flexible approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will see how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Work with contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style the JSF tables and UI components using contracts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Style contracts across different kinds of devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write contracts for composite components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a theme switcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure contracts in XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package contracts in JARs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Further, keep in mind to correctly interpret the *contracts* word in the current
    context. It can be used to define the concepts such as the `contracts` folder,
    the `contracts` attribute, or the `<contracts>` tag. Sometimes, it may get confusing.
  prefs: []
  type: TYPE_NORMAL
- en: Working with contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contracts consist of templates and CSS files that are grouped under the `contracts`
    folder. In order to define contracts, we need to respect some conventions under
    the root directory of Web application. The most important conventions (for example,
    names, structure, and content) concern folders that are involved in the defining
    of contracts. All contracts are stored under a special folder—named `contracts`—placed
    directly under the Web root of the application, or under the `META-INF` folder
    that resides in a JAR file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can alter the location and the name of this folder via `WEBAPP_CONTRACTS_DIRECTORY_PARAM_NAME`
    context parameter. The value of this context parameter must not start with a slash
    (`/`), though it may contain a slash. The runtime will interpret this value as
    a path relative to the Web root of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Commonly, under the `contracts` folder, we define a subfolder for each contract
    (the subfolder's name represents the contract's name), which contains the contract's
    artifacts such as the CSS, JS, images, and XHTML templates (you can separate resources
    such as CSS, JS, and images from the XHTML templates by adding them into representative
    subfolders).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see the folder structure for two contracts
    (`rafa1` and `rafa2`) in the same application, named `ch11_1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with contracts](img/6466EN_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In our example, the source code for `rafa1/template.xhtml` and `rafa2/template.xhtml`
    is identical (of course, this is not mandatory); however, they just use different
    CSS files. These XHTML files serve as templates for the application pages. The
    listing of `rafa1/template.xhtml` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, you can use the contracts directly in the application web pages, thanks
    to the new JSF 2.2 attribute of the `<f:view>` tag named `contracts` (this has
    to be placed in the template client). The value of this attribute should be the
    contract name that you want to use. For example, if you want to use the contract
    named `rafa2`, you can write this in the `index.xhtml` page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In order to use the contract named `rafa1`, you just need to specify this name
    as the value of the `contracts` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch11_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Styling tables with contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you know how to write and use contracts, you can try to play around
    with this great feature for creating different kinds of styles/themes for your
    pages. Most of the time, creating cool themes involves two things: having a cool
    and flexible templating mechanism and having solid knowledge of CSS and JS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can try to write two cool themes for the JSF tables. First,
    we''ll define two contracts named `tableBlue` and `tableGreen`. The XHTML template,
    in both the cases, will have the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can use the `tableBlue` or `tableGreen` contract, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling tables with contracts](img/6466EN_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, there is no need to specify a class or a style attribute for
    `<h:dataTable>`. The idea is pretty simple; JSF renders `<h:dataTable>` using
    HTML tags such as `<table>`, `<tr>`, `<td>`, `<tbody>`, `<thead>`, and `<tfoot>`.
    So, if we write a CSS style sheet that customizes the aspect of these HTML tags,
    then we will obtain the desired results. For `<h:dataTable>`, a basic CSS may
    contain the following classes (`content` matches the value of the `name` attribute
    of the `<ui:define>` component):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you may need to add pagination to your tables. JSF doesn''t provide
    attributes for this task (unlike the `<p:dataTable>` tag in PrimeFaces). But,
    as an example, you may fix this issue if you write a footer, like the following
    code snippet—of course, the `<div>` content should be dynamically generated and
    controlled (for more details, see [Chapter 6](ch06.html "Chapter 6. Working with
    Tabular Data"), *Working with Tabular Data*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you need to add a few CSS classes to control the pagination aspect, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling tables with contracts](img/6466EN_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Special thanks to Eli Geske, the author of *Learning DHTMLX Suite UI* ([http://www.packtpub.com/learning-dhtmlx-suite-ui/book](http://www.packtpub.com/learning-dhtmlx-suite-ui/book)).
    His free online CSS3 table generator (you can find HTML Table Style Generator
    at [http://tablestyler.com/](http://tablestyler.com/)) was really useful to accomplish
    the result in this section.
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch11_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Styling UI components with contracts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Based on the preceding example, we can write styles/themes for all the JSF
    UI components. In this section, you can see an example that focuses on JSF UI
    components that usually appear in forms such as `<h:inputText>`, `<h:inputTextarea>`,
    `<h:selectOneMenu>`, `<h:selectManyCheckbox>`, and so on. Practically, we want
    to obtain something like the following screenshot (this is just a sample form):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling UI components with contracts](img/6466EN_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We start by defining a new contract named `jsfui`. The template is pretty simple,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we just need to write the CSS classes that correspond to the HTML elements
    rendered by JSF, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can easily add CSS classes for the rest of UI components. Further, you
    can write JSF forms with a custom theme, just by specifying the theme name as
    the value of the `contracts` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch11_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Styling contracts across different devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding examples, we saw how to write the JSF contracts and how to
    use them by explicitly setting them by name in the `contracts` attribute of the
    `<f:view>` tag. Sometimes, you may need to dynamically set a contract (theme);
    for example, you may need to choose the right contract based on the device type
    that should display the application (PC, tablet, smartphone, mobile phone, and
    so on). In this case, you need to provide the `contracts` attribute value from
    a managed bean.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is beyond the scope of this book to provide a powerful code (or algorithm)
    for detecting device types, resolutions, and so on. With minimum involvement in
    the mobile area, we will try to write a JSF application capable of choosing the
    right contract depending on the device type. Practically, we will define the following
    four contracts (do not consider the following associations between resolutions
    and devices as a certified or authorized decision):'
  prefs: []
  type: TYPE_NORMAL
- en: '`contracts/browserpc`: This contract applies to PCs (it will be the default)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contracts/Device640`: This contract applies to tablets (we suppose that, for
    any kind of tablet, a resolution of 640 pixels width is a reasonable choice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contracts/Device480`: This contract applies to smartphones (we suppose that,
    for any kind of smartphone, a resolution of 480 pixels width is a reasonable choice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contracts/Device320`: This contract applies to normal mobile phones (we suppose
    that, for any kind of mobile phone, a resolution of 320 pixels width is a reasonable
    choice)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we will write a simple managed bean that will detect the device type based
    on the helper class named `UAgentInfo` (visit [http://blog.mobileesp.com/](http://blog.mobileesp.com/)).
    Basically, this class detects different kinds of devices based on the HTTP request
    headers, `User-Agent` and `Accept`. Based on this detection, we can set a managed
    bean property with the name of the correct contract. The managed bean code is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of these contracts contains an XHTML template and a CSS file named `styles.css`.
    Each CSS file contains classes for styling the output for a resolution type. The
    template is the same for all contracts and is pretty simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let's take a simple page, as shown in the following screenshot. (The JSF code
    is straightforward and you can see it in the complete application named `ch11_4`.)
    This view is for desktop browsers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling contracts across different devices](img/6466EN_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The relevant JSF code for this page consists of adding the right contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! Now, you can easily perform some test using a mobile emulator, such as
    Opera Mobile Operator. In the following screenshot, you can see the same page
    as that on a Samsung Galaxy Tab, at a resolution of 1024x600 (PPI: 240):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling contracts across different devices](img/6466EN_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Further, the same page can be rendered for mobile phone devices: shown on the
    left is Motorola Atrix4G at a resolution of 540x960 (PPI: 267) and on the right
    is a Nokia N9 mobile phone at resolution of 320x480 (PPI: 252):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Styling contracts across different devices](img/6466EN_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice that we can reduce the preceding example to a single contract and without
    a managed bean, by using responsive CSS. Instead of using four contracts (`browserpc`,
    `Device640`, `Device480`, and `Device320`), you can use a single contract; let''s
    name it `alldevices`. We place two CSS files under the `alldevices` contract:
    a general CSS file (`styles.css`) and the responsive CSS file (`responsive.css`).
    Further, we modify the `template.xhtml` file to load both the CSS files using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the final step, we set this contract on the JSF page of the application,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Done! The complete application is named `ch11_5`.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach consists of writing a custom `RenderKitFactory` class, a custom
    `RenderKit` class and a set of custom `Renderers` classes—one for each device.
    For example, using these artifacts, the application named `ch11_15` shows you
    how to render, for different devices, the Temperature custom component developed
    in [Chapter 10](ch10.html "Chapter 10. JSF Custom Components"), *JSF Custom Components*.
  prefs: []
  type: TYPE_NORMAL
- en: Writing contracts for composite components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, you will see how to write contracts for composite components.
    For this, we will use the Temperature composite component developed in [Chapter
    10](ch10.html "Chapter 10. JSF Custom Components"), *JSF Custom Components*. The
    implementation section in the code is given as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The IDs of subcomponents are used to define the CSS file used for styling the
    composite component. Therefore, we need to write the following CSS classes. Notice
    how we exploit CSS wildcards to find the subcomponents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we place this CSS file under the same contract with the following
    XHTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, use the composite component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we have defined two contracts: `tempStyleGray` (first bar in the
    following screenshot) and `tempStyleGreen` (second bar in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing contracts for composite components](img/6466EN_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The complete application is named `ch11_6`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a theme switcher
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a PrimeFaces fan, then I'm sure you have seen the PrimeFaces theme
    switcher. Basically, a theme switcher is represented by a drop-down menu that
    contains themes' names and thumbnails. End users can switch between application's
    themes just by selecting it from the list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will see how to develop a theme switcher using the JSF
    2.2 contracts. The goal is to obtain a theme switcher so that:'
  prefs: []
  type: TYPE_NORMAL
- en: It can be added as a JAR in any JSF 2.2 application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can automatically detect and list the themes of an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can give a nice look and feel, as shown in the following screenshot (shown
    on the left-hand side is the PrimeFaces theme switcher, and on the right-hand
    side is our theme switcher)![Writing a theme switcher](img/6466EN_11_09.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, this kind of a drop-down menu cannot be generated using the built-in
    `<h:selectOneMenu>` tag. In order to customize a drop-down menu with images and
    description, we can write a dedicated `Renderer`, or try to use a JavaScript plugin
    capable of rendering it like in the preceding screenshot. Well, the second option
    is much easier to accomplish and doesn't require us to reinvent the wheel. Practically,
    we can use a free and cool jQuery plugin named **ddSlick** ([http://designwithpc.com/Plugins/ddSlick](http://designwithpc.com/Plugins/ddSlick)),
    which is a free light-weight jQuery plugin that allows you to create a custom
    drop-down menu with images and description. There are many other such plugins
    that do the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, this plugin is capable of transforming a simple drop-down menu (defined
    using `<select>` and `<option>`) into a fancy drop-down menu that contains images
    and descriptions. For this, we start with a pure HTML5 `<select>` tag, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: When this `<select>` tag passes through ddSlick, it will result in the desired
    drop-down menu. Basically, ddSlick will render the `<select>` tag as a `<ul>`
    tag and each `<option>` tag as `<li>`. The images and descriptions are rendered
    using `<img>` and `<small>`, while the option's text is rendered using `<label>`.
    Moreover, an input hidden will be generated for each `<option>` value. The HTML5
    attributes `data-imagesrc` and `data-description` are used to tell ddSlick what
    images and descriptions to use for each `<option>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to understand how ddSlick works, because we will wrap it into
    a composite component named `ThemeSwitcher`. The interface section is very simple
    and contains a single attribute named `theme`. This attribute represents the selected
    theme, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the implementation section, we accomplish several tasks. First, we load
    the JavaScript libraries needed by our component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Further, we define HTML''s `<select>` component encapsulated in `<h:form>`
    (ideally, this component is not used in `<h:form>` with other components; therefore,
    we don''t have to worry about the nested forms):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The contracts are automatically detected and added as `<option>` using the
    `<ui:repeat>` component. The selected theme (`<option>`) is submitted to a managed
    bean using a hidden field, `<h:inputHidden>`. After submission (via AJAX or non-AJAX),
    the entire page is loaded and the `contracts` attribute (of `<f:view>`) will receive
    and apply the selected theme. For this, we need a little JavaScript code. First,
    we call the `ddslick` method, which will do the magic of transforming the boring
    drop-down menu into a cool one. Further, we indicate a JavaScript callback method,
    which will be automatically called when a theme is selected. In this method, we
    refresh the value of the hidden field, and submit the form (via AJAX or non-AJAX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It was very handy to work with this callback method to submit the selected theme,
    since ddSlick provides this feature out of the box. There are many other possibilities
    such as writing a value change listener, firing a custom event, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'I''m sure that you notice that our composite components indicate the presence
    of a backing component. This component is responsible to detect the application''s
    contracts and add their names into `List`. This list is transformed in `<option>`
    by `<ui:repeat>`. Its code is pretty straightforward, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A developer who wants to use this `ThemeSwitcher` component must add, in each
    contract, a PNG image with the same name as the contract (recommended size is
    40 x 40 pixels). By convention, for each contract, the `ThemeSwitcher` component
    will look for such an image to display it next to the theme name and description.
    You can improve this backing component to ensure that such images exist. Moreover,
    you can extend its functionality in order to allow the user of the component to
    provide custom descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: Done! The complete application is named `ch11_10`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ThemeSwitcher` composite component was packaged as a JAR file and used
    as an example in the `ch11_7` application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ThemeSwitcherBean` source code is very simple, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the `ch11_7` application is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a theme switcher](img/6466EN_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you decide to programmatically alter the `contracts` attribute value of `<f:view>`,
    you don't need this bean anymore. Moreover, if you consider a disadvantage in
    loading this jQuery plugin, you can write pure JavaScript code. Or, if you want
    a JavaScript code, a custom renderer can be a good choice.
  prefs: []
  type: TYPE_NORMAL
- en: A `ThemeSwitcher` component example, based on pure JavaScript, is developed
    in the application named `ch11_11` and is exemplified as a JAR file in the application
    named `ch11_12`. The example modifies the free JavaScript UI library named `iconselect.js`
    ([http://bug7a.github.io/iconselect.js/](http://bug7a.github.io/iconselect.js/))
    and uses the complete rewritten iScroll 4 library ([http://cubiq.org/iscroll-4](http://cubiq.org/iscroll-4)).
    Both of these libraries are pure JavaScript; they don't use additional libraries
    such as jQuery. Moreover, they are very small, free to be copied, modified, distributed,
    adapted, and commercially used.
  prefs: []
  type: TYPE_NORMAL
- en: The composite component that wraps these libraries can be used as shown in the
    following code. Notice that you can customize the aspect (which is a grid) and
    you can optionally specify which contracts to be ignored (not listed in theme
    switcher).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a theme switcher](img/6466EN_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you don''t want any JavaScript code, you can write a custom `Renderer` code
    or extend the existing `MenuRenderer` code (Mojarra or MyFaces implementation)
    or write a composite component that uses the JSF UI components to create a nice
    theme switcher. Writing a custom `Renderer` code (or extending the `MenuRenderer`
    code) doesn''t seem to be an easy job, and I don''t know if it deserves the effort.
    But writing a composite component based on JSF UI components is pretty simple.
    You can see such an implementation in the application named `ch11_13` and exemplified
    as a JAR file in the application named `ch11_14`. In this example, the themes
    are listed in a `<h:dataTable>` component, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Writing a theme switcher](img/6466EN_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring contracts in XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Contracts can be associated with the JSF pages, as you saw in the previous
    sections. As an alternative, we can accomplish the same thing by configuring contracts
    in the `faces-config.xml` file. For example, let''s suppose that we have three
    contracts: `default`, `tableGreen`, and `tableBlue`. Their association with different
    pages is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `default` contract is associated with the `tables/defaultTablePage.xhtml`
    page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tableGreen` contract is associated with the `greenTablePage.xhtml` page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `tableBlue` contract is associated with the `blueTablePage.xhtml` page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In `faces-config.xml`, we can do these associations using a few tags—the following
    example code speaks for itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a note, take a quick look at the third association. Notice how you can associate
    a contract with all the XHTML pages from a folder using the `*` wildcard. Do not
    try to use EL in `<contracts>`. It will not work!
  prefs: []
  type: TYPE_NORMAL
- en: The complete application is named `ch11_8`.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging contracts in JARs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to distribute contracts, you can place them into a JAR file. This
    is a very simple job that can be accomplished in just three steps, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Consider an empty JAR file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create, in JAR, a folder named `META-INF`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `contracts` folder from your application into `META-INF`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, a JAR file that contains the `default`, `tableGreen`, and `tableBlue`
    contract folders has the structure shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Packaging contracts in JARs](img/6466EN_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A complete example that uses this JAR file is named `ch11_9`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I hope that you have enjoyed this penultimate chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The JSF 2.2 Resource Library Contracts is one of the big ticket features. For
    a long time, JSF developers requested for a mechanism that allows writing and
    using themes in JSF, just like in other systems. As you just saw, JSF 2.2 contracts
    open a door in this direction and encourage developers to write and use themes.
    Of course, there are many other things that should be added, such as a theme repository,
    administration console for themes, switch between themes on the fly, and so on.
    But, this is a good start!
  prefs: []
  type: TYPE_NORMAL
- en: See you in the final chapter where we will discuss about Facelets.
  prefs: []
  type: TYPE_NORMAL
