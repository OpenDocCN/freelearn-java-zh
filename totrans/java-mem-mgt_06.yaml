- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Configuring and Monitoring the Memory Management of the JVM
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置和监控 JVM 的内存管理
- en: So far, we have looked at the different areas of memory and how it is deallocated,
    but we have yet to look at optimizing the way a **Java Virtual Machine** (**JVM**)
    does this. The approach that the JVM uses to manage memory can be configured in
    different ways.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了内存的不同区域以及它是如何被释放的，但我们还没有探讨优化 **Java 虚拟机**（**JVM**）执行此操作的方式。JVM
    用于管理内存的方法可以通过不同的方式进行配置。
- en: There is not one obvious way to configure the JVM though. The best configuration
    really depends on the application and the requirements. Getting the best configuration
    will improve the performance of your application and minimize the memory requirements.
    Monitoring performance and memory will help discover problems before users do.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有一种明显的方式来配置 JVM，但最佳配置实际上取决于应用程序和需求。获得最佳配置将提高应用程序的性能并最小化内存需求。监控性能和内存将有助于在用户之前发现问题。
- en: 'In this chapter, we’re going to have a look at how to configure the JVM and
    monitor memory management. Changing the configurations of the JVM is typically
    done by tuning, meaning that you have an idea of where to start, then make small
    adjustments, and carefully measure their impact. Here are the topics that will
    be discussed:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何配置 JVM 和监控内存管理。调整 JVM 的配置通常是通过调优来完成的，这意味着你有一个起点，然后进行小的调整，并仔细测量它们的影响。以下是将要讨论的主题：
- en: The basics of JVM tuning for memory management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JVM 内存管理调优的基本知识
- en: Obtaining relevant metrics for memory management
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取内存管理的相关指标
- en: Profiling of the Java application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 应用程序的性能分析
- en: Tuning the configurations of the JVM
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调整 JVM 的配置
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到，链接为 [https://github.com/PacktPublishing/B18762_Java-Memory-Management](https://github.com/PacktPublishing/B18762_Java-Memory-Management)。
- en: The basics of JVM tuning for memory management
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JVM 内存管理调优的基本知识
- en: 'The first rule of JVM tuning for performance improvement is probably that it
    should be the last option for improvement. Look at this code snippet:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于性能改进的 JVM 调优，可能是最后的选择。看看这个代码片段：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Will JVM tuning help? No, because we’re stuck in an infinite loop, since `i`
    never gets increased. Of course, there are a lot of less obvious examples, but
    when code can be improved and optimized, this must be done first before thinking
    about JVM tuning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: JVM 调优有帮助吗？不，因为我们陷入了无限循环，因为 `i` 永远不会增加。当然，还有很多不那么明显的例子，但当代码可以被改进和优化时，这必须在考虑
    JVM 调优之前完成。
- en: If the hardware can realistically be optimized, this should be done before JVM
    tuning as well. By this, I don’t mean that you should fix a memory leak by just
    adding more memory; of course, that’s not a fix. But when your application accidentally
    gets very successful and things get slow, chances are that you are better off
    upgrading the hardware than diving into JVM tuning to fix this. When all the other
    factors that come into play for performance are optimized, this is when JVM tuning
    can be applied for performance improvement.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果硬件可以实际优化，这也应该在 JVM 调优之前完成。通过这种方式，我并不是说你应该通过仅仅增加更多内存来修复内存泄漏；当然，这并不是一个解决方案。但当你应用程序意外取得巨大成功而事情变得缓慢时，你升级硬件可能比深入
    JVM 调优来修复这个问题更有利。当所有其他影响性能的因素都得到优化时，这就是 JVM 调优可以应用于性能改进的时候。
- en: When we are tuning the JVM, we are setting parameters. And that’s not it; this
    needs to be carefully monitored. Before changing any settings, we must make sure
    to have a good idea of the metrics of our application. These new settings need
    to be monitored carefully. If the performance improves, you could try to change
    the parameters a bit more; if it gets worse, you should probably change it back
    at least a little to gauge the difference.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调整 JVM 时，我们正在设置参数。但这还不算完；这需要被仔细监控。在更改任何设置之前，我们必须确保对应用程序的指标有一个很好的了解。这些新设置需要被仔细监控。如果性能有所提高，你可以尝试稍微调整参数；如果它变得更差，你可能至少需要稍微改回来以衡量差异。
- en: It might sound like trial and error at this point, and to some extent it is
    – professionally conducted trial and error, that is. Let’s have a look at the
    relevant metrics to tune the memory management of the JVM.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这听起来可能像是试错，在某种程度上确实如此——这是专业进行的试错。让我们看看相关的指标来调整 JVM 的内存管理。
- en: Obtaining relevant metrics for memory management
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取内存管理的相关指标
- en: 'There are several important metrics for knowing how the memory of an application
    is doing. Understanding the following three important concepts that define the
    performance of the application is the first step here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 了解应用程序内存状况的重要指标有几个。理解以下三个定义应用程序性能的重要概念是第一步：
- en: Memory that is functioning well
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能良好的内存
- en: Normal latency
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常延迟
- en: A normal level of throughput
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常的吞吐量水平
- en: Let’s take a look at each one of these.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看这些内容。
- en: Well-functioning memory
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能良好的内存
- en: When you have experience with a specific application, you may know its stable
    memory-usage point. There needs to be more memory available than just the stable
    usage point though. Instead, a safe amount of memory needs to be available for
    the Java application, and this reserved memory should not be almost full. Conversely,
    having too much memory allocated for the Java application is also not the way
    to go. This is because the rest of the system will also need some memory for other
    processes, since the operating system is also running.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对特定应用程序有经验时，您可能知道其稳定的内存使用点。然而，需要比稳定的内存使用点更多的内存。相反，Java应用程序需要有一定的安全内存可用，并且这部分预留内存不应接近满载。相反，为Java应用程序分配过多的内存也不是一个好的选择。这是因为系统的其余部分也需要一些内存来运行其他进程，因为操作系统也在运行。
- en: If you have an idea of the normal memory metrics of your application when it’s
    performing well, this will help you measure the outcome of any adjustments that
    you might be making later.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对应用程序在良好运行时的正常内存指标有所了解，这将有助于您测量您可能后来做出的任何调整的结果。
- en: Normal latency
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 正常延迟
- en: Latency is also called the responsiveness of the application. An application
    with normal latency responds as expected and required. This can be measured in
    time – for example, the time the application takes to process a certain request
    such as processing an incoming HTTP request.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟也称为应用程序的响应性。具有正常延迟的应用程序会按预期和需求响应。这可以通过时间来衡量——例如，应用程序处理某个请求所需的时间，如处理传入的HTTP请求。
- en: Of course, measuring latency is not always as easy. If we have a standalone
    Java application, this is somewhat trivial. We know that we are measuring the
    latency of our application. If we are trying to measure the latency of an enterprise
    application, it becomes tricky. We need to make sure we are measuring the latency
    of our application and not network issues, the server side of another application,
    or any layer that we have in our enterprise application landscape. In those cases,
    issues with the latency results are likely not related to the memory management
    of our application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，测量延迟并不总是那么容易。如果我们有一个独立的Java应用程序，这相对简单。我们知道我们正在测量应用程序的延迟。如果我们试图测量企业应用程序的延迟，这就会变得复杂。我们需要确保我们测量的是应用程序的延迟，而不是网络问题、另一个应用程序的服务器端或我们企业应用程序景观中的任何层。在这些情况下，延迟结果的问题可能并不与我们的应用程序的内存管理相关。
- en: Level of throughput
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 吞吐量水平
- en: Throughput is the amount of work that can be done by the application in a certain
    amount of time. High throughput is typically what you want to aim for, but it
    does require more memory and might affect latency.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量是在一定时间内应用程序可以完成的工作量。通常，您希望追求高吞吐量，但这需要更多的内存，可能会影响延迟。
- en: Profiling Java applications
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分析Java应用程序
- en: Profiling is used to make an analysis of the runtime performance of an application.
    This is something that needs to be done carefully, since it usually has an impact
    on the application that is being profiled. It is, therefore, advisable to profile
    the development environment if possible. We are going to have a look at profiling
    with the `jstat` and `jmap` command-line tools, and the **VisualVM** application.
    The first two come with your **Java Development Kit** (**JDK**); the latter used
    to come with it but now it can be downloaded separately.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析用于分析应用程序的运行时性能。这是一项需要谨慎处理的工作，因为它通常会对被分析的应用程序产生影响。因此，如果可能的话，建议对开发环境进行性能分析。我们将探讨使用`jstat`和`jmap`命令行工具以及**VisualVM**应用程序进行性能分析。前两者包含在您的**Java开发工具包**（**JDK**）中；后者曾经包含在其中，但现在可以单独下载。
- en: Important note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 重要注意事项
- en: 'You can download VisualVM here: [https://visualvm.github.io/download.xhtml.](https://visualvm.github.io/download.xhtml.)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处下载VisualVM：[https://visualvm.github.io/download.xhtml.](https://visualvm.github.io/download.xhtml.)
- en: There are other profiles out there; some IDEs even have their own profilers
    built in, which work in a similar way.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Profiling with jstat and jmap
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the two command-line utilities, `jstat` and `jmap`, we can analyze and
    profile memory. We are going to explore how to do that.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a simple Java application:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This application is not doing a lot of interesting things, just adding a lot
    of `String` objects to our `stringList` static list.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'We can run this program and see what is going on with the memory. In order
    to do this, we need to compile the program first:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The preceding command assumes that you are in the same folder as Command Prompt
    or Terminal, since we access the file directly without any folders in front. This
    command compiles the code and stores the result in `ExampleAnalysis.class`. Let’s
    run this file by executing the following command (make sure to be one level above
    the [*Chapter* *6*](B18762_06.xhtml#_idTextAnchor086) directory):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, we’ll first need the process ID to analyze our code using `jstat`. We
    can get the process IDs of all Java processes by running the following command
    in the command line:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The command produces the following output:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Our program can be easily recognized, as it has the name of the class written
    after it. So, our process ID is `35384`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'We need this process ID to run the `jstat` analysis. This command-line tool
    has several options. We are going to start by running it like this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This will produce the result for our process with an ID of `35384`. The `-gc`
    option is one of the options available to get statistics about the garbage collected
    heap. It makes sure that it shows the behavior of the garbage collected heap.
    There are a few other flags that you could use as well; here are a few examples:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '`gccapacity`: Show data about the capacities of the generations'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcnew`: Show data about the behavior of the young generations'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcnewcapacity`: Show data about the size of the young generations'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcold`: Show data about the old generation and the Metaspace'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcoldcapacity`: Show data about the old generation'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gcutil`: Show a summary of the garbage collection data'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-t` indicates that it should print the timestamp. `1000` means that it will
    show the statistics every 1,000 milliseconds and `10` means that it will show
    10 iterations.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: 'The output will look as shown in *Figure 6**.1*:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Output showing the jstat command with options](img/Figure_6.1_B18762.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Output showing the jstat command with options
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it displays many columns. Let us see what these columns mean;
    the exact values aren’t too important for the discussion. We’ll go over them from
    left to right:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '**Timestamp**: The time since the program started running. You can see that
    it increases with seconds, which makes sense, as we asked for iterations of 1,000
    milliseconds.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S0C**: The current capacity of the survivor space 0 in KB.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S1C**: The current capacity of the survivor space 1 in KB.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**S0U**: The part of the survivor space 0 that is being used in KB.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S0U**: 在KB中使用的幸存空间0的部分。'
- en: '**S1U**: The part of the survivor space 1 that is being used in KB.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**S1U**: 在KB中使用的幸存空间1的部分。'
- en: '**EC**: The current capacity of the Eden space in KB. You can see that the
    capacity scales up when the Eden space gets fuller.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EC**: Eden空间当前容量，单位为KB。您可以看到，当Eden空间变满时，容量会扩大。'
- en: '**EU**: The part of the Eden space that is being used in KB. At the seventh
    row, it drops, and the data gets moved to the old space.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EU**: 在KB中使用的Eden空间的部分。在第7行，它下降，数据被移动到旧空间。'
- en: '**OC**: The current capacity of the old space in KB.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OC**: 旧空间当前容量，单位为KB。'
- en: '**OU**: The part of the old space that is being used in KB. You can see it
    increase during the program.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OU**: 在KB中使用的旧空间的部分。您可以看到它在程序运行期间增加。'
- en: '**MC**: The current capacity of the Metaspace in KB.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MC**: 元空间当前容量，单位为KB。'
- en: '**MU**: The part of the Metaspace that is being used in KB.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MU**: 在KB中使用的元空间的部分。'
- en: '**CCSC**: **Compressed Class Space Capacity** in KB.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CCSC**: **压缩类空间容量**，单位为KB。'
- en: '**CCSU**: **Compressed Class Space Utilized** in KB.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CCSU**: **已使用压缩类空间**，单位为KB。'
- en: '**YGC**: The number of young generation garbage collection events that happened.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YGC**: 发生的年轻代垃圾回收事件的数量。'
- en: '**YGCT**: The total time of the young generation garbage collection events.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YGCT**: 年轻代垃圾回收事件的总时间。'
- en: '**FGC**: The total number of full garbage collection events.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FGC**: 完全垃圾回收事件的总数。'
- en: '**FGCT**: The total time the full garbage collection events took.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FGCT**: 完全垃圾回收事件的总时间。'
- en: '**CGC**: **Concurrent** **Garbage Collection**.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CGC**: **并发**垃圾回收。'
- en: '**CGCT**: The total time of concurrent garbage collection.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CGCT**: 并发垃圾回收的总时间。'
- en: '**GCT**: The total garbage collection time.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GCT**: 垃圾回收的总时间。'
- en: 'With the `jmap` command, we can get more insights into the heap memory usage
    of our current process. Here is how to use it (Java 9 and later):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`jmap`命令，我们可以更深入地了解当前进程的堆内存使用情况。以下是使用方法（Java 9及以后版本）：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`jhsdb` is a JDK tool that can attach to a running Java process, perform snapshot
    debugging, and inspect the content of the core dump of a crashed JVM. This outputs
    the current heap configuration and usage. Let’s have a look at how to get a more
    visual result while Java profiling with the help of VisualVM.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`jhsdb`是一个JDK工具，可以附加到正在运行的Java进程，执行快照调试，并检查崩溃JVM的核心转储内容。这输出了当前的堆配置和用法。让我们看看如何借助VisualVM在Java分析中获得更直观的结果。'
- en: Profiling with VisualVM
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用VisualVM进行分析
- en: 'There are many profilers out there that will give a visual representation of
    memory. One of them is VisualVM. It is a tool that is suitable for getting detailed
    information about the Java applications that are running. VisualVM does not come
    by default with the JDK anymore, so it needs to be installed separately here:
    [https://visualvm.github.io/.](https://visualvm.github.io/.)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多分析器可以提供内存的视觉表示。其中之一是VisualVM。这是一个适合获取正在运行的Java应用程序详细信息的工具。VisualVM不再默认包含在JDK中，因此需要在此处单独安装：[https://visualvm.github.io/](https://visualvm.github.io/)。
- en: If your IDE supports profiling, you could work with that one too. However, the
    following examples use VisualVM, since it’s a free tool that can be easily downloaded.
    Profiling an application with VisualVM is easy. First, you start VisualVM. You
    will see a screen similar to the one in *Figure 6**.2*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的IDE支持分析，您也可以使用它。然而，以下示例使用VisualVM，因为它是一个免费工具，可以轻松下载。使用VisualVM分析应用程序很简单。首先，启动VisualVM。您将看到一个类似于**图6.2**的屏幕。
- en: '![Figure 6.2 – The startup screen of VisualVM](img/Figure_6.2_B18762.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – VisualVM的启动屏幕](img/Figure_6.2_B18762.jpg)'
- en: Figure 6.2 – The startup screen of VisualVM
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – VisualVM的启动屏幕
- en: On the screen of *Figure 6**.2*, we can check the applications that are running.
    The **Applications** tab can be found on the top left, positioned vertically.
    Here, we can see the local Java processes that are running, from where we can
    simply select the one that we need. Let’s start our example Java application,
    where we will create a huge list of strings.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图6.2**的屏幕上，我们可以检查正在运行的应用程序。**应用程序**标签位于左上角，垂直排列。在这里，我们可以看到正在运行的本地Java进程，我们可以简单地选择所需的进程。让我们开始我们的示例Java应用程序，我们将创建一个巨大的字符串列表。
- en: In the **Applications** tab, we can see the processes, as shown in *Figure 6**.3*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在**应用程序**标签中，我们可以看到进程，如图**图6.3**所示。
- en: '![Figure 6.3 – An overview of the Java processes](img/Figure_6.3_B18762.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – Java进程概述](img/Figure_6.3_B18762.jpg)'
- en: Figure 6.3 – An overview of the Java processes
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – Java进程概述
- en: We can now pick the process we want to examine. In this case, we would like
    to analyze the process with the **6450** PID. Once we click on it, we get an overview
    of the process, as shown in *Figure 6**.4*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以选择我们想要检查的进程。在这种情况下，我们想要分析具有**6450** PID的进程。一旦我们点击它，我们就会得到进程的概述，如**图6.4**所示。
- en: '![Figure 6.4 – An overview of the Java process](img/Figure_6.4_B18762.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – Java进程概述](img/Figure_6.4_B18762.jpg)'
- en: Figure 6.4 – An overview of the Java process
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – Java进程概述
- en: 'We can see a summary of the data in the overview shown in *Figure 6**.4*. We
    see the process that we are analyzing, the JVM and Java version that we are running,
    and the JVM arguments used to start the application. There is also a lot more
    detailed data we can get from VisualVM. At the top, we have several tabs: **Overview**,
    **Monitor**, **Threads**, **Sampler**, and **Profiler**. We have seen the **Overview**
    tab; in *Figure 6**.5*, let’s look at the data under the **Monitor** tab.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在**图6.4**所示的概述中看到数据摘要。我们看到我们正在分析的过程、我们运行的JVM和Java版本，以及启动应用程序时使用的JVM参数。VisualVM还可以提供更多详细的数据。在顶部，我们有几个标签页：**概述**、**监控**、**线程**、**采样器**和**分析器**。我们已经看到了**概述**标签；在**图6.5**中，让我们看看**监控**标签下的数据。
- en: '![Figure 6.5 – Monitoring the Java process using VisualVM](img/Figure_6.5_B18762.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 使用VisualVM监控Java进程](img/Figure_6.5_B18762.jpg)'
- en: Figure 6.5 – Monitoring the Java process using VisualVM
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 使用VisualVM监控Java进程
- en: 'This is where we get some serious details of what is going on in our application.
    We see four graphs. The top-left one shows **CPU usage**, and as you can see,
    we are using quite a bit of CPU for this program. This graph also shows the garbage
    collection activity, which is very low overall. This makes sense, as there is
    not a lot to be garbage-collected anyway. The garbage collection activity combined
    with the memory graph at the top right gives some great insights into how healthy
    our application is in terms of memory. If the garbage collector works really hard
    (as you can see, there is a lot of GC activity in the top-left graph) and the
    memory keeps increasing (the lower line representing **Used heap** in the top-right
    graph), it means that we are having a problem with a memory leak. Basically, if
    there are too frequent GC cycles, then it is an indication that you need to do
    some digging to see whether there is something wrong with GC and memory. After
    doing that, if there are still too frequent GC cycles and memory is also not coming
    down, then it is a red alert and you must investigate. In fact, **OutOfMemoryError:
    GC Overhead limit exceeded** is thrown by the JVM if it is spending more than
    98% of the time on GC and recovering less than 2% of the heap.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '这是我们获取应用程序中正在发生的一些重要细节的地方。我们看到四个图表。左上方的图表显示**CPU使用率**，如您所见，我们为这个程序使用了相当多的CPU。这个图表还显示了垃圾回收活动，总体上非常低。这是有道理的，因为实际上没有太多东西需要垃圾回收。垃圾回收活动与右上方的内存图表结合，为我们提供了关于应用程序内存健康状况的深刻见解。如果垃圾回收器工作非常努力（如您所见，左上方的图表中有大量的GC活动），并且内存持续增加（右上方的图表中代表**已使用堆**的较低线条），这意味着我们可能存在内存泄漏问题。基本上，如果GC周期过于频繁，那么这可能表明你需要深入挖掘，看看GC和内存是否存在问题。在这样做之后，如果GC周期仍然过于频繁，并且内存也没有下降，那么这就是一个红色警报，你必须进行调查。实际上，如果JVM在GC上花费了超过98%的时间，并且恢复的堆小于2%，则会抛出**OutOfMemoryError:
    GC Overhead limit exceeded**错误。'
- en: The two bottom graphs show the loaded Java classes (left) and the threads in
    the application (right). We can get more details on threads by moving to the **Threads**
    tab. In *Figure 6**.6*, we see an overview of the threads in our application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 两个底部的图表显示了加载的Java类（左侧）和应用程序中的线程（右侧）。我们可以通过切换到**线程**标签来获取更多关于线程的详细信息。在**图6.6**中，我们看到了我们应用程序中线程的概述。
- en: '![Figure 6.6 – Threads in our application](img/Figure_6.6_B18762.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 我们应用程序中的线程](img/Figure_6.6_B18762.jpg)'
- en: Figure 6.6 – Threads in our application
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 我们应用程序中的线程
- en: We can see the name of our threads on the far left. The bars indicate what the
    state of our threads is over time – for example, running or waiting. We can then
    see the time they have been running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在最左侧看到我们线程的名称。条形图表示我们的线程随时间的状态——例如，运行或等待。然后我们可以看到它们运行的时间。
- en: In the **Sampler** tab, shown in *Figure 6**.7*, we can see how the CPU or memory
    is doing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在**采样器**标签页中，如**图6.7**所示，我们可以看到CPU或内存的表现情况。
- en: '![Figure 6.7 – The Sampler tab in VisualVM](img/Figure_6.7_B18762.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – VisualVM中的采样器标签页](img/Figure_6.7_B18762.jpg)'
- en: Figure 6.7 – The Sampler tab in VisualVM
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – VisualVM中的采样标签页
- en: We are now looking at memory sampling, which shows how many live objects there
    are and how much space is being occupied by a certain class. Here, the `byte`
    array is the biggest one. This makes sense because the value of a string is stored
    in a byte array. You can also filter this overview per thread or have a look at
    how the CPU is performing.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正在查看内存采样，它显示了有多少活动对象以及某个类占用了多少空间。在这里，`byte`数组是最大的。这很有道理，因为字符串的值存储在`byte`数组中。您还可以按线程过滤此概述，或查看CPU的性能。
- en: In the last tab, we can see profiling. Profiling and sampling are used for similar
    purposes, but the process is different. Sampling is done by making thread dumps
    and analyzing these thread dumps. Profiling requires adding a bit of logic to
    an application so that it gives a signal when something happens. This affects
    the performance of the application quite a bit. Therefore, this is not something
    you’d want to be doing on applications that are running in production. It can
    give a lot of insights though.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一个标签页中，我们可以看到剖析。剖析和采样用于类似的目的，但过程不同。采样是通过制作线程转储并分析这些转储来完成的。剖析需要在应用程序中添加一些逻辑，以便在发生某些事情时发出信号。这将对应用程序的性能产生相当大的影响。因此，您不希望在运行中的应用程序上执行此操作。尽管如此，它可以提供很多见解。
- en: You can see the result of profiling all the classes in *Figure 6**.8*. Here,
    you can see a similar result to what we were getting for the sampling (though
    it had fewer objects being allocated at that point in time). In this case, sampling
    would have worked just as well.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在*图6.8*中看到对所有类进行剖析的结果。在这里，您可以看到与采样（尽管在那个时间点分配的对象较少）相似的结果。在这种情况下，采样同样有效。
- en: VisualVM is great to get quick, visual insights on what is going on with the
    memory of your application. This is going to be especially useful while tuning
    the JVM and checking the results. In the next section, we are going to do exactly
    that – learn how to adjust the configuration of the JVM and see the impact of
    these adjustments.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: VisualVM非常适合快速直观地了解应用程序内存的情况。在调整JVM和检查结果时，这将特别有用。在下一节中，我们将做的是——学习如何调整JVM的配置并查看这些调整的影响。
- en: '![Figure 6.8 – Profiling all the classes](img/Figure_6.8_B18762.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 分析所有类](img/Figure_6.8_B18762.jpg)'
- en: Figure 6.8 – Profiling all the classes
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 分析所有类
- en: Tuning the configurations of the JVM
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调整JVM的配置
- en: The settings of JVM can be adjusted. The process of adjusting the settings of
    JVM is called **tuning**. The idea of these adjustments is to boost the performance
    of the JVM. Once again, tuning should not be the first step in improving performance.
    Good code should always come first.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: JVM的设置可以调整。调整JVM设置的过程称为**调整**。这些调整的想法是提高JVM的性能。再次强调，调整不应是提高性能的第一步。好的代码始终应该是首要的。
- en: 'We are going to have a look at the settings that are related to memory management:
    the heap size, Metaspace, and the garbage collector.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将查看与内存管理相关的设置：堆大小、元空间和垃圾收集器。
- en: Tuning the heap size and thread stack size
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整堆大小和线程栈大小
- en: The heap size can be changed. It is generally best practice to not set the heap
    size to more than half of what is available on the server. This could lead to
    performance issues, as the server will be having other processes running as well.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 堆大小可以更改。通常，将堆大小设置为服务器可用内存的一半以下是一个最佳实践。这可能会导致性能问题，因为服务器还将运行其他进程。
- en: 'The default size depends on the system. This command will show the defaults
    on a Windows system:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 默认大小取决于系统。此命令将在Windows系统上显示默认值：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This command shows the default output for a macOS system:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示了macOS系统的默认输出：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The output is displayed in bytes. You can see the output for my computer in
    *Figure 6**.9*.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输出以字节为单位显示。您可以在*图6.9*中看到我电脑的输出。
- en: '![Figure 6.9 – Output as seen on the macOS system](img/Figure_6.9_B18762.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – macOS系统上的输出](img/Figure_6.9_B18762.jpg)'
- en: Figure 6.9 – Output as seen on the macOS system
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – macOS系统上的输出
- en: The size of the heap influences garbage collection. This might seem counterintuitive
    at first, but let’s do a little thought experiment here. If we had unlimited heap
    memory, would we need garbage collection? No, right? Why run such an expensive
    process if we don’t need to free up memory anyway?
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 堆的大小会影响垃圾收集。这乍一看可能有些反直觉，但让我们在这里进行一个小小的思维实验。如果我们有无限的堆内存，我们需要垃圾收集吗？不，对吧？为什么运行这样一个昂贵的进程，如果我们根本不需要释放内存呢？
- en: The smaller the heap, the more we will need the garbage collector active because
    it would need to work harder to have space available, since memory gets filled
    up easier. However, the bigger the heap, the longer one full cycle of garbage
    collection takes. There’s simply more to scan for garbage. A good rule of thumb
    is that you want to have less than 5% of application execution time spent on garbage
    collection.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 堆越小，我们越需要垃圾收集器活跃，因为它需要更努力地工作以保持空间可用，因为内存更容易被填满。然而，堆越大，完整的垃圾收集周期就越长。需要扫描的垃圾就越多。一个很好的经验法则是，你希望应用程序执行时间中少于5%用于垃圾收集。
- en: The actual tuning works differently for different servers. Here, we are going
    to see how to do so using the command line when starting the application. Please
    note that the names of the options that we are setting are the same between different
    servers, but how or where to set them might vary.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的调整对于不同的服务器可能不同。在这里，我们将通过启动应用程序时使用命令行来展示如何进行。请注意，我们设置的选项名称在不同的服务器之间是相同的，但设置它们的方式或位置可能不同。
- en: 'When we start the Java application, we can work with different options for
    the memory. We can specify a memory pool start size, a maximum memory pool, and
    the thread stack size. Here’s how to set all to 1,024 MB:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们启动Java应用程序时，我们可以使用不同的内存选项。我们可以指定内存池的起始大小、最大内存池和线程栈大小。以下是设置所有为1,024 MB的方法：
- en: '`-Xms1024m` (initial size heap)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Xms1024m`（初始堆大小）'
- en: '`-Xmx1024m` (maximum size heap)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Xmx1024m`（最大堆大小）'
- en: '`-Xss1024m` (thread stack size)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-Xss1024m`（线程栈大小）'
- en: 'If you want to set it to a different size, choose a different size and just
    adjust the option accordingly. You can use the following command to start a Java
    application with adjusted memory settings (on a 64-bit system):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将其设置为不同的大小，选择一个不同的大小，并相应地调整选项。你可以使用以下命令以调整后的内存设置启动Java应用程序（在64位系统上）：
- en: '[PRE29]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will start our example Java application with an initial heap size of 4
    GB and a maximum of 6 GB.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们的示例Java应用程序以4 GB的初始堆大小和6 GB的最大堆大小启动。
- en: 'Similar to the way you can bind the total heap size using `–Xmx` and `–Xms`,
    you can bind the young generation size using the following:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 与你可以使用`–Xmx`和`–Xms`绑定总堆大小的方式类似，你可以使用以下方式绑定年轻代大小：
- en: '`-XX:MaxNewSize=1024m` (maximum new size)'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxNewSize=1024m`（最大新大小）'
- en: '`-XX:NewSize=1024m` (minimum new size)'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:NewSize=1024m`（最小新大小）'
- en: Here, we are setting the minimum and the maximum size to 1,024 MB. We may run
    out of memory. This will result in `OutOfMemoryError`. Let’s see how to get a
    heap dump when this happens so that we can inspect what went wrong.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将最小和最大内存大小设置为1,024 MB。我们可能会耗尽内存。这将导致`OutOfMemoryError`错误。让我们看看当这种情况发生时如何获取堆转储，以便我们可以检查出了什么问题。
- en: Logging low memory
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录低内存
- en: It is very helpful to get a **heap dump** when an application ends with an out-of-memory
    error. A heap dump is a snapshot of the objects in the memory of the application.
    In this case, we can inspect the objects in the application that were present
    at the moment we ran out of memory. This way, we can use it to see which object
    is likely to overflow the memory.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序因内存不足错误而结束时，获取**堆转储**非常有帮助。堆转储是应用程序内存中对象的快照。在这种情况下，我们可以检查在内存不足时存在于应用程序中的对象。这样，我们可以用它来查看哪个对象可能溢出内存。
- en: 'If you want the JVM to create the heap dump whenever there is an `OutOfMemoryError`
    exception, then you can use the following JVM argument while starting the JVM:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望JVM在发生`OutOfMemoryError`异常时创建堆转储，那么你可以在启动JVM时使用以下JVM参数：
- en: '[PRE30]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also specify the path:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以指定路径：
- en: '[PRE31]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this, the heap dumps will be stored in the specified path. There are different
    ways to create a heap dump – for example, `jmap` can also be used to create a
    heap dump of the application, if it didn’t crash because of `OutOfMemoryError`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方式，堆转储将被存储在指定的路径中。创建堆转储有不同的方法——例如，如果应用程序不是因为`OutOfMemoryError`而崩溃，`jmap`也可以用来创建应用程序的堆转储。
- en: Next, let’s see how to configure the Metaspace.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何配置Metaspace。
- en: Tuning the Metaspace
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整Metaspace
- en: 'The default behavior of Metaspace is quite peculiar, as it seems to have a
    limit. This is easy to interpret in the wrong way because this limit is not a
    real limit. If it reaches this limit, it will see what it can do in terms of garbage
    collection, and then it expands. Therefore, it is important to set the following
    variables carefully:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Metaspace 的默认行为相当特殊，因为它似乎有一个限制。由于这个限制不是真正的限制，因此很容易误解，如果达到这个限制，它将查看在垃圾回收方面可以做什么，然后它就会扩展。因此，仔细设置以下变量很重要：
- en: Maximum size, using `-XX:MaxMetaspaceSize=2048m`
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-XX:MaxMetaspaceSize=2048m` 设置最大空间大小为 2048 兆字节
- en: Threshold for garbage collection, using `-XX:MetaspaceSize=1024m`
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `-XX:MetaspaceSize=1024m` 设置垃圾回收的阈值大小为 1024 兆字节
- en: 'Minimum and maximum free ratio, using the following:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用以下设置最小和最大空闲比率：
- en: '`-``XX:MinMetaspaceFreeRatio=50`'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MinMetaspaceFreeRatio=50` 设置最小空间使用率阈值为 50%'
- en: '`-``XX:MaxMetaspaceFreeRatio=50`'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:MaxMetaspaceFreeRatio=50` 的最大空间使用率设置为 50%'
- en: The minimum and maximum free ratios are great for when you are planning to load
    a lot of classes dynamically. By making sure there is enough memory available,
    you can increase the speed to load classes dynamically. This is because the freeing
    up of memory for classes that need to be loaded takes some CPU time. We can skip
    the step that requires assigning additional memory by choosing a large enough
    free ratio and making sure memory is available. In the preceding example, they
    are set to 50%.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 最小和最大空闲比率非常适合您计划动态加载大量类的情况。通过确保有足够的内存可用，您可以提高动态加载类的速度。这是因为为需要加载的类释放内存需要一些 CPU
    时间。我们可以通过选择足够大的空闲比率并确保内存可用来跳过需要分配额外内存的步骤。在先前的示例中，它们被设置为 50%。
- en: Garbage collection tuning
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收调优
- en: 'As you may have realized by now, garbage collection is an expensive process.
    Optimizing it can really help the performance of an application. You cannot trigger
    garbage collection yourself; this is the decision of the JVM. You may have heard
    of the following way to suggest garbage collection to the JVM:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如您现在可能已经意识到的，垃圾回收是一个昂贵的进程。优化它确实可以帮助提高应用程序的性能。您不能自己触发垃圾回收；这是 JVM 的决定。您可能已经听说过以下建议
    JVM 进行垃圾回收的方法：
- en: '[PRE32]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This does not guarantee that garbage collection will take place. So, you cannot
    trigger garbage collection, but you can influence the way the JVM deals with it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不保证会发生垃圾回收。因此，您不能触发垃圾回收，但您可以影响 JVM 处理垃圾回收的方式。
- en: However, before tweaking anything in relation to garbage collection, it is important
    to make sure that you understand what you are doing exactly. For this, you’ll
    need solid knowledge about the garbage collector.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在调整与垃圾回收相关的任何设置之前，确保您确切了解您正在做什么非常重要。为此，您需要关于垃圾收集器的扎实知识。
- en: Also, before adjusting anything, you must have a look at memory usage. Make
    sure to know what spaces are filled and when this is happening. A heap that’s
    healthy will look a bit like a saw in VisualVM. It goes up and down, creating
    spikes, resembling the teeth of a saw. It has a certain amount of used memory,
    and then the garbage collection comes around and decreases the used memory to
    a certain base level. It grows again, and then at around the same usage level,
    the garbage collection comes around and decreases it to its base level, and so
    on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在调整任何设置之前，您必须查看内存使用情况。确保了解哪些空间被填满以及何时发生这种情况。一个健康的堆在 VisualVM 中看起来有点像一把锯子。它上下波动，形成尖峰，类似于锯齿。它有一定量的已使用内存，然后垃圾回收器出现并将已使用内存降低到一定的基础水平。它再次增长，然后在大约相同的使用水平上，垃圾回收器再次出现并将它降低到基础水平，以此类推。
- en: 'If you see the memory growing over time and garbage collection ends at a slightly
    higher base level every time, you probably have a memory leak that needs to be
    dealt with. As we saw in [*Chapter 4*](B18762_04.xhtml#_idTextAnchor057), there
    are several different garbage collector implementations available. When starting
    the JVM, we can also choose which garbage collector we want it to use:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看到内存随着时间的推移而增长，并且每次垃圾回收结束时都略微高于基础水平，那么您可能有一个需要处理的内存泄漏。正如我们在 [*第 4 章*](B18762_04.xhtml#_idTextAnchor057)
    中所看到的，有几种不同的垃圾收集器实现可用。在启动 JVM 时，我们还可以选择希望它使用的垃圾收集器：
- en: '`-``XX:+UseSerialGC`'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+UseSerialGC` 使用串行垃圾回收器'
- en: '`-``XX:-UseParallelGC`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:-UseParallelGC` 禁用并行垃圾回收器'
- en: '`-``XX:+UseConcMarkSweepGC`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+UseConcMarkSweepGC` 使用并发标记清除垃圾回收器'
- en: '`-``XX:+G1GC`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+G1GC` 使用 G1 垃圾回收器'
- en: '`-``XX:+UseZGC`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-XX:+UseZGC` 使用 ZGC 垃圾回收器'
- en: 'This is not possible for every system, and all these garbage collection choices
    come with their own extra options as well. For example, we can choose the parallel
    garbage collector and specify the number of threads for the garbage collector:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是每个系统都能做到的，所有这些垃圾回收选择都附带了自己的额外选项。例如，我们可以选择并行垃圾回收器并指定垃圾回收器的线程数：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This is how to start an application using the parallel garbage collector and
    giving it four threads to work with. The options for all the garbage collectors
    are too elaborate to discuss in detail. Details can be found in the official documentation
    of the Java implementation that you are using. Here is the link to the Oracle
    implementation, although it’s possible that newer versions will have been released
    by the time you are reading this book: [https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm.](https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm.)'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何使用并行垃圾回收器启动应用程序，并给它分配四个线程来工作。所有垃圾回收器的选项过于复杂，无法详细讨论。详细信息可以在您使用的Java实现的官方文档中找到。以下是Oracle实现的链接，尽管在您阅读这本书的时候，可能会有更新的版本发布：[https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm.](https://docs.oracle.com/javase/9/gctuning/introduction-garbage-collection-tuning.htm.)
- en: Summary
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we saw what to keep in mind when tuning the JVM. We need to
    focus on memory functioning, latency, and throughput.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了在调整JVM时需要注意的事项。我们需要关注内存功能、延迟和吞吐量。
- en: In order to monitor how our application is doing, we can use profiles. We have
    seen how to use the `jstat` command-line tool that comes with the JDK by default.
    After that, we saw how to use VisualVM to get a better visual representation of
    what is going on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控我们的应用程序表现如何，我们可以使用配置文件。我们已经看到了如何使用JDK默认提供的`jstat`命令行工具。之后，我们看到了如何使用VisualVM来更好地可视化正在发生的事情。
- en: Next, we saw how we could adjust the heap, Metaspace, and the garbage collector
    of our application. We also saw the effects for our simple example application.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到了如何调整我们的应用程序的堆、元空间和垃圾回收器。我们也看到了这些调整对我们简单示例应用程序的影响。
- en: To reiterate, please bear in mind that adjusting the JVM to boost performance
    should always be the last step, and more obvious actions, such as improving code,
    should always be taken first.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，请记住，调整JVM以提升性能应该是最后的步骤，并且应该首先采取更明显的行动，例如改进代码。
- en: Having covered this, you are now ready to look at how to avoid memory leaks
    in the next chapter.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍完这些内容后，您现在可以查看如何在下一章中避免内存泄漏。
