- en: Chapter 4. JSF Configurations Using XML Files and Annotations – Part 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with JSF 2.0, there is no need to create the configuration file, `faces-config.xml`.
    Well, this affirmation is partially true, because JSF annotations still don't
    cover several configurations, such as resource bundles, factories, phase listeners,
    and so on. Usually, JSF annotations provide sufficient support for our applications;
    however, as you will see in this chapter, there are still many cases when `faces-config.xml`
    is mandatory, or additional configurations must be added in the `web.xml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, JSF 2.2 provides a programmatic approach that can be used to reproduce
    `faces-config.xml`, without writing it in the classical approach. Later in this
    chapter, you will see how to take advantage of this new feature. For now, you
    will see a mix of creating and configuring different kinds of JSF artifacts. They
    will be arbitrarily presented—some of them are well known, from JSF 1.x and 2.0,
    while others are new, starting with JSF 2.2\. Since these configurations are straightforward,
    they can be listed as barren documentation, but gluing each configuration into
    an example is more useful and provides a good point to start when you need to
    use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in this chapter you will learn about JSF artifacts'' configurations,
    but you will also see some examples of working with these artifacts. The following
    is a short overview of what we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.2 new namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSF 2.2 programmatic configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring managed beans in XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with multiple configuration files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring locales and resource bundles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring validators and converters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring action listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring system event listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring phase listeners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `@ListenerFor` and `@ListenersFor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Obviously, we have a lot of work to do and a lot of JSF 2.2 features to cover
    (for example, JSF 2.2 injection in more artifacts then before), so let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: JSF 2.2 new namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSF 2.2 modified the existing JSF namespaces, as you can see in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Namespace | Before JSF 2.2 | JSF 2.2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Faces Core | `http://java.sun.com/jsf/core` | `http://xmlns.jcp.org/jsf/core`
    |'
  prefs: []
  type: TYPE_TB
- en: '| HTML_BASIC | `http://java.sun.com/jsf/html` | `http://xmlns.jcp.org/jsf/html`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Facelets Templating | `http://java.sun.com/jsf/facelets` | `http://xmlns.jcp.org/jsf/facelets`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Composite Components | `http://java.sun.com/jsf/composite` | `http://xmlns.jcp.org/jsf/composite`
    |'
  prefs: []
  type: TYPE_TB
- en: '| JSTL Core | `http://java.sun.com/jsp/jstl/core` | `http://xmlns.jcp.org/jsp/jstl/core`
    |'
  prefs: []
  type: TYPE_TB
- en: '| JSTL Functions | `http://java.sun.com/jsp/jstl/functions` | `http://xmlns.jcp.org/jsp/jstl/functions`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pass Through Attributes | `http://java.sun.com/jsf/passthrough` | `http://xmlns.jcp.org/jsf/passthrough`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Pass Through Elements | `http://java.sun.com/jsf` | `http://xmlns.jcp.org/jsf`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `@FacesComponent` default namespace |   | `http://xmlns.jcp.org/jsf/component`
    |'
  prefs: []
  type: TYPE_TB
- en: JSF 2.2 programmatic configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can programmatically reproduce the content and tasks
    of `faces-config.xml`. The starting point consists of a callback method, named
    `populateApplicationConfiguration`, which gets a single argument of type `org.w3c.dom.Document`—this
    class belongs to DOM API. Basically, a `Document` (tree node) is a representation
    in memory of an XML document, and we can manipulate it by adding, removing, importing,
    or adopting nodes, elements, and text. For each of these operations, there are
    dedicated methods. For some JSF developers, this API can be something new that
    should be learned; therefore, this can be a drawback of programmatic configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s resume the dissertation from the callback method. The `populateApplicationConfiguration`
    method is provided by a class that extends and implements the abstract class `ApplicationConfigurationPopulator`
    found in the `javax.faces.application` package. In order to tell JSF about this
    class, you need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JAR package (for example, `faces-config.jar` or by using any other
    name).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this JAR package, create a folder named `META-INF`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `META-INF` folder, create a folder named `services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `services` folder, create an empty file named `javax.faces.application.ApplicationConfigurationPopulator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this file, write the fully qualified name of the class that extends and implements
    the abstract class `ApplicationConfigurationPopulator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the JAR root, place the class that extends and implements the abstract class
    `ApplicationConfigurationPopulator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Done! Now when you add this JAR package in your project `CLASSPATH`, JSF will
    process it and apply the found configurations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing that the class that extends and implements the abstract class `ApplicationConfigurationPopulator`
    is named `faces.config.Initializer` (you can use any other name), then the JAR
    content will look like in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![JSF 2.2 programmatic configuration](img/6466EN_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this chapter, you will see some programmatic examples as an alternative
    to classical `faces-config.xml`. When we are working directly on a DOM tree node,
    we tend to make stupid mistakes, like forgetting to add the text of an element,
    or placing an element in an improper place, and so on. In order to eliminate these
    errors without headaches, you can write a simple method to serialize the DOM in
    an XML file, which can be easily debugged visually or using a specialized tool.
    The following method accomplishes this task, and you will find it in all the examples
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Configuring managed beans in XML
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JSF managed bean configuration was essentially improved starting with JSF 2.0\.
    Most commonly, a managed bean is annotated with `@ManagedBean` and another annotation
    indicating a JSF scope (for example, `@RequestScoped`). But managed beans can
    be configured in `faces-config.xml` as well, and this approach is not deprecated
    or obsolete. The simplest configuration contains the managed bean''s name, class,
    and scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In case that you need a managed bean that should be eagerly initialized, you
    can use the `eager` attribute of the `<managed-bean>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Managed beans'' properties can be initialized from `faces-config.xml` using
    the `<managed-property>` tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside the `<value>` tag, we can use EL expressions as well. For example, we
    can initialize a property of managed bean `A` with the value of a property belonging
    to managed bean `B`. But, it is important to know that JSF doesn't support cyclic
    dependency for managed bean reference—you cannot refer managed bean `A` from managed
    bean `B`, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interesting case involves setting a property with the value of a context
    initialization parameter. Such parameters are configured in the deployment descriptor
    (`web.xml`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmatically, these kinds of parameters can be extracted through the initialization
    map or by their name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'These parameters can be accessed from `faces-config.xml` using the EL implicit
    object, `initParam`. JSF provides the ability to reference EL implicit objects
    from a managed bean property, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From `faces-config.xml`, we can initialize more complex properties such as
    enumerations and collections. Consider the following enumeration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding property can be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of collections, we can easily initialize maps and lists. A map (`java.util.Map`)
    can be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While a list `java.util.List` (or array) can be initialized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A property can be initialized with a `null` value by using the `<null-value/>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to configure managed beans in the XML descriptor (instead of
    using annotations), then it is a good practice is to place them into another descriptor
    and not in `faces-config.xml`. Keep this descriptor for application-level configurations.
    For example, you can name it `faces-beans.xml`. JSF will know how to use this
    file when it inspects the application descriptor, `web.xml`, for the following
    predefined context parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now you can keep `faces-config.xml` for other configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, it is much easier to use annotations instead of tags, but sometimes
    this approach can be really useful. For example, you can have some annotated managed
    beans whose behavior you want to change, but for different reasons you cannot
    edit the source code. In such a scenario, you can write the modifications in an
    XML file, because at runtime, configurations from the XML file will take precedence
    against annotations.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example, named `ch4_12`, is available in the code bundle of this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSF 2.2 programmatic approach can reproduce the configuration file of the
    `ch4_12` application as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch4_14_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with multiple configuration files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.0 provides support for ordering the configuration resources. We can use
    **partial ordering** (represented by the `<ordering>` tag) and **absolute ordering**
    (represented by the `<absolute-ordering>` tag).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each document that is involved in the ordering plan is identified by the top-level
    tag, `<name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Partial ordering is specific to a single configuration document. We can use
    the `<before>` and `<after>` tags to indicate that a certain document should be
    processed before or after another document. Nested inside the `<before>` and `<after>`
    tags, we may have the `<others/>` tag, which indicates that a certain document
    should be processed before (respectively after) all the other documents that are
    sorted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listed here is an example where we have documents `A`, `B`, `C`, and `faces-config.xml`
    alias `D`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Document `C` needs to be executed before others; hence, it will be executed
    first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Document `B` has no specified order; hence, it will be executed second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Document `A` needs to be executed after document `B`; hence, it will be executed
    third:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Document `D` (`faces-config.xml`) is executed last and doesn't need any ordering
    specifications.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The order will be implementation-specific configuration resource, that is, `C`,
    `B`, `A`, and `faces-config.xml` (`D`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ordering process (partial or absolute) has no effect over two documents:
    the respective implementation''s (Mojarra or MyFaces) default configuration resource
    is always processed first, and `faces-config.xml` (if exists) is always processed
    last.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple test can be performed using several phase listeners and firing some
    customized messages. Each phase listener is configured in a separate document
    and some partial ordering schema is applied. A complete example can be found in
    the code bundle of this chapter and is named `ch4_13_1`. The console output will
    reveal the effect of partial ordering.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a document has ordering requirements, but no name, then the ordering requirements
    will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The absolute ordering is accomplished by the `<absolute-ordering>` tag. This
    tag can appear only in `faces-config.xml` and provides us control over the order
    that configuration documents will be processed. For example, we have added the
    absolute ordering in the `faces-config.xml` document (alias document `D`) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the processing order is: implementation specific configuration resource
    , `C`, `B`, `A`, and `faces-config.xml` (`D`).'
  prefs: []
  type: TYPE_NORMAL
- en: The complete example for absolute ordering is named, `ch4_13_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring locales and resource bundles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A properties file that contains messages can be named `PlayerMessages.properties`.
    When we have messages in several languages, we can create a properties file for
    each language and name it accordingly. For example, for English it will be `PlayerMessages_en.properties`,
    and for French it will be `PlayerMessages_fr.properties`. A convenient place to
    store them is in the application source folder directly or in subfolders (or,
    in NetBeans, under `Other Sources` folder in a Maven web application project).
    A resource bundle is capable of loading and displaying messages from these files.
  prefs: []
  type: TYPE_NORMAL
- en: 'A resource bundle can be configured locally or globally. A local resource bundle
    loads the properties file for the specified page only. For this, use the `<f:loadBundle>`
    tag as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'A global resource bundle loads the properties file for all the JSF pages. In
    this case, we need a declarative loading in `faces-config.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'When we have files for multiple languages, we also have to indicate the locale.
    Locally, this is accomplished in the `<f:view>` tag by adding the locale attribute,
    as follows (here we indicate the French language):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Globally, in `faces-config.xml`, we indicate the default locale via `<default-locale>`
    and the list of supported locales using the `<supported-locale>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Programmatically, we may depict the locale as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'A simple entry in the properties file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The messages will be displayed using the `msg` variable (declared by the `var`
    attribute or the `<var>` tag):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'But, messages can be more complex than static text. For example, they can be
    parameterized, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And parameters can be replaced using the `<h:outputFormat>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But, how about a message of the following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'When you have one player, the message will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is grammatically incorrect; therefore, you need to use a pattern similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will fix the problem. The arguments used here are explained as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0, choice`: Take the first parameter and base the output on a choice of available
    formats'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0#players`: If the first parameter contains 0 (or below), then it should print
    "players"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1#player`: If the first parameter contains 1, then it should print "player"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2#players`: If the first parameter contains 2 (or above), then it should print
    "players"'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the complete example under the name `ch4_4`, in the code bundle
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not confuse the `<resource-bundle>` tag with `<message-bundle>`. The former
    is used for registering custom localized static text, while the latter is used
    for registering custom error/info/warn messages, which are displayed by `<h:message>`
    and `<h:messages>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<message-bundle>` option is ideally used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The message file can be loaded with the `<f:loadBundle>` tag.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring validators and converters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data validation is an important part of a JSF application (which has existed
    since JSF 1.2), because it allows us to separate the business logic from the tedious
    checks that help us to obtain only valid information from the user. Data is validated
    in the *Process Validations* phase (if the `immediate` attribute is set to `true`,
    this processing will occur at the end of the *Apply Request Values* phase instead)
    and should be valid and ready to be used before the *Update Model Values* phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the built-in validators, we can write our own customized validators.
    A public class that implements the `Validator` interface and overrides the `validate`
    method is recognized by JSF as a **validator**. There are two ways to configure
    a validator in JSF: using the `@FacesValidator` annotation or the `<validator>`
    tag in `faces-config.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that we have the following e-mail validator configured using `@FacesValidator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In JSF 2.2, the name can now be omitted from components, converters, and validators,
    so the preceding code will become `@FacesValidator`. Here, we need to note that
    when the name is omitted, JSF will use the class name, without the package name,
    with the first letter de-capitalized.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you prefer to use `faces-config.xml`, then `EmailValidator` can be configured
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can easily link `validator` to an input component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternate way to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The complete example of `EmailValidator` is available in the code bundle of
    this chapter and is named `ch4_3_1`. Besides this application, consider, as a
    bonus, two applications that are useful when validators are involved. The first
    one is named `ch4_2`, and requires passing extra parameters to a validator using
    `<f:attribute>`, and the other one is named `ch4_11`, which is an example of validating
    multiple fields using a custom validator and the `<f:attribute>` tag. The latter
    one is also developed using the `PostValidateEvent` system event—check the *Configuring
    system event listeners* section later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Well, there are many articles about JSF validators, but just a few discuss injection
    in JSF validators. By default, JSF 2.0 does not support injection in validators,
    since only managed beans are injection targets, but there are several tricks that
    can bring dependency injection in discussion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to obtain a validator eligible for injection, you need to apply the
    following modifications, which basically transform the validator into a bean:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `@FacesValidator` annotation with `@Named` or `@ManagedBean` (or
    even with a Spring annotation, `@Component`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the bean in a request scope (use the proper `@RequestScoped` annotation)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refer to it using the proper EL expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Done! Now, you can use `@Inject` in this validator.
  prefs: []
  type: TYPE_NORMAL
- en: The complete example is available in the code bundle of this chapter and is
    named `ch4_3_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more complicated task is to use `@EJB` for injecting **Enterprise JavaBeans**
    (**EJB**) session beans. In this case, we need to manually lookup the EJB session
    bean from **Java Naming and Directory Interface** (**JNDI**). When the EJBs are
    deployed in **Web application ARchive** (**WAR**) the lookup generally is of the
    following type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'When the EJBs are in an **Enterprise ARchive** (**EAR**), the common lookup
    type is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When EJBs are deployed in WAR, use the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'When EJBs are deployed in the EAR, use the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete examples in the code bundle of this chapter. The example
    for EJBs deployed in the WAR is named `ch4_3_5`, and the EJBs deployed in EAR
    case is named `ch4_3_6`.
  prefs: []
  type: TYPE_NORMAL
- en: These approaches are just some engrafts for bringing dependency injection in
    validators and this seems to be the only workaround in JSF 2.0\. Starting with
    JSF 2.2, injection is possible in many more artifacts, but as the specification
    says, converters and validators are still not injection targets. It seems that
    this will be available from JSF 2.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrary to this affirmation, I tried to write a validator and use the injection
    as it should natively work. I used `@Inject` as follows where `LoginBean` is a
    CDI application scoped bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, I also tried to inject an EJB using `@EJB` and `@Inject` where `LoginEJBBean`
    is a stateless session bean, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: I have to admit that I was expecting to see a `null` value for the injected
    resource, but surprisingly, everything worked as expected in all cases. There
    are rumors that, initially, the injection mechanism for validators and convertors
    was added in JSF 2.2, but it was removed at the last moment because some tests
    failed. Even if the preceding examples worked fine, it doesn't mean that is a
    good practice to use this approach in production. You'd better wait until it is
    guaranteed by the JSF team.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are a fan of OmniFaces, then you can use `@Inject` and `@EJB` with `@FacesValidator`.
    This great facility was added starting with Version 1.6 ([http://showcase.omnifaces.org/cdi/FacesValidator](http://showcase.omnifaces.org/cdi/FacesValidator)).
    Moreover, MyFaces CODI ([http://myfaces.apache.org/extensions/cdi/](http://myfaces.apache.org/extensions/cdi/))
    can also be a workaround, but it requires an additional `@Advanced` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: The complete examples are available in the code bundle of this chapter and they
    are named `ch4_3_3` (web application) and `ch4_3_4` (enterprise application),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: When discussing **converters**, let's remember that the conversion between two
    `UIInput` instances happens in the *Process Validations* phase (default), which
    can be moved to *Apply Request Values* phase using the `immediate` attribute set
    to `true`. For `UIOutput`, the conversion happens in the *Render Response* phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beside the built-in converters, we can write our custom converters. A public
    class that implements the `Converter` interface and overrides the `getAsObject`
    and `getAsString` methods is recognized by JSF as a **converter**. There are two
    ways to configure a converter in JSF: using the `@FacesConverter` annotation or
    the `<converter>` tag in `faces-config.xml`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Concerning we have the following converter configured using `@FacesConverter`
    (remember that JSF 2.2 doesn''t need the `value` attribute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you prefer to use `faces-config.xml`, then `PlayerConverter` can be configured
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can easily link the converter to an input component as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternate way to do this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, you can write this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you configure the converter using the `forClass` attribute, skip the `value`
    attribute as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The complete example of `PlayerConverter` is available in the code bundle of
    this chapter and it is named `ch4_6_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking about dependency injection, having converters as targets is pretty
    similar with the situation of validators:'
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `@FacesConverter` annotation with `@Named` and `@ManagedBean` (for
    Spring, you can use `@Component` also)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the bean in the request scope (use the proper `@RequestScoped` annotation)
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Refer to it using the proper EL expression as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The complete example can be found in the code bundle of this chapter and it
    is named `ch4_6_2`. EJBs can be injected in converters by looking up the EJB session
    bean from JNDI. Refer to the examples `ch4_6_5` (EJBs in EAR) and `ch4_6_6` (EJBs
    in WAR).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code in the `ch4_6_5` application; `RandomEJBBean` is
    a stateless session bean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following block of code in the `ch4_6_6` application; `RandomEJBBean` is
    a stateless session bean:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Moreover, under GlassFish 4.0 and Mojarra 2.2.x, I was able to successfully
    run two applications that use injection in converters without any fancy workaround.
    See examples `ch4_6_3` and `ch4_6_4`. Do remember that this approach is not officially
    adopted, however.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JSF 2, navigation became much easier. Navigation can be accomplished
    using:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preemptive navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatic navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can talk for hours and hours about JSF navigation, but there are a few golden
    rules that save us from falling for the most common mistakes when we need to choose
    between `GET` and `POST`. It might be useful to know that:'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to use the `GET` request for page-to-page navigation, search
    forms, URLs that you want to be visible and bookmarkable, and, in general, for
    any idempotent request. By specification, `GET`, `HEAD`, `PUT`, `DELETE`, `OPTIONS`,
    and `TRACE` are idempotent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For requests that shouldn't be bookmarkable, use the same view repeatedly (use
    forward, not redirect).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For requests that shouldn't be bookmarkable, but have bookmarkable targets,
    use `POST` and redirect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Implicit navigation** interprets navigation outcomes as target view IDs.
    The simplest implicit navigation case is accomplished by JSF itself whenever you
    perform an action and no navigation is indicated. In this case, JSF will post
    a form (via `HTTP POST`) back to the current view (render the current view again).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Without declarative navigation in `faces-config.xml`, we can easily write navigation
    cases, such as the following where JSF 2 knows how to treat `outcome` (or the
    `action` value) as the targeted page name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the `success.xhtml` page exists, then all the given examples will navigate
    to this page. The `<h:outputLink>` element will navigate independently of JSF
    (that means it doesn''t interact with JSF). The `<h:link>` and `<h:button>` elements
    will navigate via a bookmarkable `GET` request and aren''t capable of form submissions
    (as you will see, this is actually preemptive navigation). The `<h:commandButton>`
    and `<h:commandLink>` elements are the main components for navigating within a
    JSF application. They fire `POST` requests and are capable of form submissions.
    Whenever you want to add the application context path in a URL (for example, the
    URL generated via `<h:outputLink>`, you can use the `ExternalContext.getApplicationContextPath`
    method of JSF 2.2\. For example, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The declarative version of this is as follows—thanks to implicit navigation,
    this code is not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The outcome of `<h:link>` and `<h:button>` are evaluated during the *Render
    Response* phase; therefore, the URLs are available right from the start of the
    corresponding view. On the other hand, when the button (`<h:commandButton>`) or
    link (`<h:commandLink>`) is clicked, JSF will merge the `action` value `success`
    with the XHTML extension and find the view name `success.xhtml` in the current
    page directory.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wildcard ("*") is supported to specify a navigation rule that applies to all
    pages. It can be useful for a logout page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation case can also pass through a bean method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the `PlayerBean` method is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In these examples, the `outcome`/`action` values and the target view ID matches.
    However, the `outcome`/`action` values and target view ID are not always that
    simple. The `outcome`/`action` values are used to determine the target view ID
    even if they don''t have the same root. For example, refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code indicates the `done.xhtml` page, but this page doesn''t
    exist; therefore, no navigation happens. We need to add a declarative navigation
    rule in `faces-config.xml` in order to link the `action` value (or the `outcome`
    value that is fetched via preemptive navigation, which we will see soon), `done`,
    with target view ID, `success.xhtml`. This navigation rule can be seen in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'If the bean method returns the outcome `done`, then the navigation rules are
    modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: By default, between **forward** and **redirect**, JSF will navigate from one
    page to another using the forward mechanism (`HTTP POST`). When JSF receives the
    user action, it will forward the user to the determined target page, which means
    that the URL displayed by the browser will not be updated to reflect the current
    target. Keeping the browser URL updated implies the page redirectionmechanism;
    in this case, JSF, delegates the browser to send a separate `GET` request to the
    target page.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the page redirection mechanism by attaching the `faces-redirect=true`
    parameter to the outcome query string as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you can use the `<redirect/>` tag inside the navigation rule
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the forward case, the browser URL is not updated (is with a step behind navigation
    URL), but there is a single request. In the redirect case, the browser URL is
    up to date, but there are two requests. Since forward needs a single request,
    it is faster than page redirection. The speed is lower, but page redirection solves
    the duplicated form submission problem found in the Post-Redirect-Get design pattern.
    Of course, this is not the case for `<h:link>`, `<h:button>`, and `<h:outputLink>`.
  prefs: []
  type: TYPE_NORMAL
- en: These examples are grouped in the `ch4_5_1` application in the code bundle of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Conditional navigation** allows us to specify preconditions for choosing
    the desired navigation case; a precondition must be met in order for the navigation
    case to be accepted. For this, we use the `<if>` tag as a child of the `<navigation-case>`
    tag and use an EL expression that can be evaluated to a Boolean value; here the
    `true` value matches the navigation case.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a simple button that logs the user into the application. This is
    done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'When the **Login** button is clicked, JSF will call the `playerLogin` method.
    This method will not return an outcome, actually it returns `void`. In this example,
    we simulate a login process through a random number and set a Boolean value, `login`,
    accordingly, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can use the `<if>` tag to decide if we navigate to the `success.xhtml`
    page (equivalent to `login` equals `true`) or to the `failed.xhtml` page (equivalent
    to `login` equals `false`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In conditional navigation, the navigation cases are evaluated even when the
    outcome is `null` or `void`. Notice that there is no `<else>` tag or multiple
    conditional checking; therefore, in such cases, you have to emulate a `switch`
    statement. If you want to simply match the `null` outcome in any case, then you
    can use a condition of type: `<if>#{true}</if>`.'
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the sequence of the navigation rule affects the navigation flow; therefore,
    it is a good practice to prioritize conditions.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example in the code bundle of this chapter, under
    the name `ch4_5_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write conditional navigation cases without the `<if>` tag by delegating
    the decision of choosing the navigation case to a bean method. For this, we have
    to replace the static value of the `<to-view-id>` tag with an EL expression, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that this is not a real conditional navigation (since `<if>` is missing);
    therefore, we need to return an outcome from the `playerLogin` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `login` property is set and the outcome `done` is returned, JSF will
    follow the preceding navigation case and reach for the `navigateHelper` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In a real application, the method that returns the outcome and the method that
    chooses the navigation case will probably be in different beans. If you take into
    account that you can pass arguments to the decisional method, then many navigation
    cases can be solved.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example in the code bundle of this chapter, under
    the name `ch4_5_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Preemptive navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Preemptive navigation** is available starting with JSF 2.0\. The navigation
    rules are more permissive and they are evaluated during the *Render Response*
    phase instead of the *Invoke Application* phase.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is known as predetermined navigation or preemptive navigation. The current
    view ID and specified outcome are used to determine the target view ID. Afterwards,
    the target view ID is translated into a bookmarkable URL and used as the hyperlink's
    target. Practically, the URL is prepared without user interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main usage of preemptive navigation appears in bookmarkable component tags,
    `<h:link>` and `<h:button>`. For example, the following are two classical examples
    of preemptive navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: When the application starts, you can check the source code of the page to see
    how the corresponding URLs were mapped in the HTML tag `<a>` in case of `<h:link>`,
    and the HTML tag `<input type="button">` in case of `<h:button>`. Even if you
    never use those URLs, they are ready to serve.
  prefs: []
  type: TYPE_NORMAL
- en: Well, before JSF 2.0, navigation rules were explicitly the domain of `POST`
    requests (`NavigationHandler.handleNavigation` was doing the dirty job behind
    the scene), but the new support for GET-based navigation and bookmarkability takes
    navigation to another level of flexibility and transparency (for example, the
    `ConfigurableNavigationHandler` API).
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part here is how the query string of a URL is assembled. The
    simplest case consists of the implicit query string parameter as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: In [Chapter 2](ch02.html "Chapter 2. Communication in JSF"), *Communication
    in JSF*, you saw how to build the query string using `<f:param>` and `<f:viewParam>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way consists in using the `<view-param>` tag nested in a `<redirect>`
    tag in a navigation case. For example, we can add query string parameters to a
    redirect URL in the navigation rules. Let''s create the following button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, a silly method named `playerDone` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can add the `player` property value (of course, you can add any other
    value) as a parameter in the query string of the redirection navigation URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: A URL like this will be of the format (notice how the request parameter was
    attached based on the navigation rule) `http://`*host*`:`*port*`/`*app-name*`/faces/success.xhtml?playerparam=Rafael+Nadal`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `playerparam` value will be available through the `param` implicit object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: You can find the complete example in the code bundle of this chapter, under
    the name `ch4_5_4`.
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic Navigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to control navigation directly from the application. JSF
    provides the `NavigationHandler` and `ConfigurableNavigationHandler` APIs that
    can be used for tasks such as accessing navigation cases, customizing navigation
    handlers, conditional navigations, and so on. It is good to know that, programmatically
    speaking, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain access to navigation handler (`NavigationHandler`) using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke navigation case using `NavigationHandler` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access the `ConfigurableNavigationHandler` API using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Invoke navigation case using `ConfigurableNavigationHandler` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve one `NavigationCase` object by the action expression signature and
    outcome as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Access all navigation rules into `Map<String, Set<NavigationCase>>`, where
    the keys are the `<from-view-id>` values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we have **wrappers** for many classes that provide basic
    implementations and help developers to extend those classes and override only
    the necessary methods. Among them, we have a wrapper class for `NavigationHandler`,
    named `NavigationHandlerWrapper`, one for `ConfigurableNavigationHandler`, named
    `ConfigurableNavigationHandlerWrapper`, and one for `NavigationCase`, named `NavigationCaseWrapper`.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. JSF Scopes – Lifespan and Use in Managed
    Beans Communication"), *JSF Scopes – Lifespan and Use in Managed Beans Communication*,
    you saw a custom implementation of `ConfigurableNavigationHandler` in *The flow
    scope* section, and you saw a custom implementation of `NavigationHandler` in
    the *Controlling the custom scope lifespan with the navigation handler* section.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring action listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Action listeners are a great facility provided by JSF for dealing with action
    events. Commonly, action listeners are attached to command buttons (`<h:commandButton>`)
    or command links (`<h:commandLink>`) using the `actionListener` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: When a button/link is clicked, JSF calls the action listener during the *Invoke
    Application* phase. Notice that if you are using `immediate="true"`, then the
    action listener is called during the *Apply Request Values* phase. The method,
    indicated as a listener, should be public, should return `void`, and should accept
    an `ActionEvent` object (this object can be used to access the component that
    invoked the action), which can perform specific tasks. When its execution has
    finished, JSF will call the method bound by the `action` attribute (if it exists!).
    This method is responsible to indicate the navigation case. The action listener
    method can alter the response returned by the action method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a practice, `actionListener` is used to have some "fun" before the real business
    and navigation task, which is the responsibility of `action`. So, do not abuse
    `actionListener` for solving business logic tasks!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an example of a simple command button that uses an action listener,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PlayerBean` contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the log messages reveal the order of calls as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This kind of listener doesn't need any special configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of listener can be written by implementing the `ActionListener`
    interface and overriding the `processAction` method. In this case, we need to
    use the `<f:actionListener>` tag for attaching the action listener to a command
    button/link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, the `PlayerListener` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And, the output of the log messages will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Again, these kinds of listeners do not need any special configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2 the `ActionListener` interface was wrapped in a simple
    implementation named, `ActionListenerWrapper`. You need to extend this class and
    override `getWrapped` to return the wrapped instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `PlayerListener` may be called via the following wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even combine these two listeners into a single command button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the log messages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Well, this example gives us an important rule: the action listeners are invoked
    before `action` and in the same order as they are declared inside the component.'
  prefs: []
  type: TYPE_NORMAL
- en: Application action listeners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far so good! The last category of action listeners are known as application
    action listeners. They are set on the application level and are called by JSF
    even for command buttons/links that do not specify any action listener explicitly.
    Such an action listener may look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'This action listener will be called for a command button/link even if it doesn''t
    specify it, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'In JSF 2.2, we can write this implementation by extending `ActionListenerWrapper`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application action listeners are called after the action listeners that are
    explicitly set via the `actionListener` attribute or the `<f:actionListener>`
    tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be called, such listeners must be configured in `faces-config.xml`.
    For example, the preceding listener can be configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you are using application action listeners, it is important to keep in
    mind a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: Application action listeners cannot invoke other listeners.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application action listeners are responsible for processing the `action` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application action listeners cannot catch events from other listeners.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have probably noticed that an action listener throws an `AbortProcessingException`
    exception. When this exception appears, JSF will directly jump to render the response
    and ignore further action listeners. The error is *swallowed* by default, so don't
    expect to see it! You can make it visible by altering the default mechanism of
    treating exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that action listeners rock! Wait till you see this starting
    with JSF 2.2\. We can use the injection mechanism for injecting CDI managed beans
    and EJBs in action listener classes. For example, the simple bean shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'This bean can be injected in our application action listener as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this facility opens new perspectives in implementing applications.
    And, as you will see next, injection mechanism is available for many other JSF
    artifacts that do not support it in JSF 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: A complete example named `ch4_1`, is available in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring system event listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.0 allows us to use **system events**. These are events that can be fired
    by arbitrary objects at arbitrary points during the request processing lifecycle.
    Since the number of these events is quite big, you will not see them entirely
    covered here, but the next five examples should clarify the basic aspects of system
    events. You can find all of them in the `javax.faces.event` package.
  prefs: []
  type: TYPE_NORMAL
- en: Using <f:event>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to use system event listeners consists in passing the name
    of the managed bean method in the `listener` attribute of the `<f:event>` tag.
    For example, `PostValidateEvent` is a system event that gets fired after all components
    are validated. This can be useful to validate multiple components. Suppose, that
    a user submits a form that contains his name, surname, bank account, and the confirmation
    of that bank account (like a password that should be typed twice for confirmation).
    In order to check if the same bank account was typed in both fields, we can use
    `PostValidateEvent`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in `PlayersBean`, we need to implement the `validateAccount` method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Done! If you don't provide the same bank account, then you will see the corresponding
    message. The complete application is named `ch4_7`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SystemEventListener
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another approach of handling system events is based on the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `SystemEventListener` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding the `processEvent` and `isListenerForSource` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the listener in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The registered system event can be fired by many kinds of sources (components).
    We can sort and accept certain sources in the `isListenerForSource` method. It
    returns `true` when the listener should receive events from the source passed
    to it as an argument (usually a simple test using the `instanceof` operator should
    do the work). When a source is accepted, the `processEvent` method is called and
    we can add a custom behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that we want to remove certain resources included
    by JSF, such as CSS style sheets or JS scripts (it could be even resources added
    by third-party libraries). Speaking about CSS resources, they are always rendered
    in the `HEAD` section of an HTML page. Knowing that, we can configure our listener
    to be executed if the event source is a `UIViewRoot` instance. Further, we exploit
    JSF API to loop through the CSS resources and remove some of them (or, all of
    them). The code of our listener is pretty simple, as you can see in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The listener should be configured in `faces-config.xml`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'So, even if initially we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'JSF will render the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<source-class>` tag is actually overriding the condition from the `isListenerForSource`
    method. So, you can always return `true` from the `isListenerForSource` method
    and use this tag, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example under the name `ch4_9_1`, in the code bundle
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see another example. A common approach, when some form input fields
    are invalid, is to color the background in red. In JSF 2.0, we can do that using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, that is really cool! But, if the form has several input fields, then
    we have to repeat the condition again and again, which isn''t cool anymore! But,
    with a little magic, we can generalize this behavior. We can write a listener
    that will be executed only from the `UIInput` objects and modify their `styleClass`
    attribute based on the result returned by the `isValid` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, this is simple and there is nothing to explain. Actually, the key
    lies in the configuration file, because we have to choose the right system event
    from the plethora of available events. Since we need to color the background of
    invalid input fields in red, the right choice should be `PostValidateEvent`, as
    shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Done! A functional example is available in the code bundle of this chapter
    and is named `ch4_9_3`. The JSF 2.2 programmatic reflection of this configuration
    is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch4_14_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection in system event listeners(`@Inject`
    and `@EJB`). For example, instead of hardcoding the CSS resources that we need
    to remove from `HEAD`, we can pass them through injection of a CDI bean or an
    EJB session bean. You can see a complete example in the code bundle of this chapter.
    This one is named `ch4_9_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you map the CSS classes names in a CDI bean (for example `StyleResourcesBean`)
    or EJB bean (for example `StyleResourcesEJBBean`), you can use any of the following
    injections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the injection facility, JSF 2.2 comes with a set of four brand new
    system events dedicated to Flash scope. These are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostKeepFlashValueEvent`: This event is fired when a value is kept in the
    Flash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostPutFlashValueEvent`: This event is fired when a value is stored in the
    Flash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreClearFlashEvent`: This event is fired before the Flash is cleared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreRemoveFlashValueEvent`: This event is fired when a value is removed from
    the Flash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember that in [Chapter 2](ch02.html "Chapter 2. Communication in JSF"),
    *Communication in JSF*, you saw an application based on the Flash scope. In this
    chapter, we will write a system event listener to monitor two of these events,
    `PostKeepFlashValueEvent` and `PreClearFlashEvent`. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Do not forget to configure the listener in `faces-config.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: A functional example is available in the code bundle of this chapter, and is
    named `ch4_9_4`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, from JSF 2.2 onwards, the `PostRestoreStateEvent` system
    event is published using `Application.publishEvent` without making `UIComponents`
    default listeners, but still doing the traditional tree traversal. This event
    was an exception for the rule in the previous JSF versions!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring phase listeners
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, a **phase listener** is capable to listen to the start
    and end of each of the six JSF life-cycle phases (a detailed diagram of how JSF
    phases interact with each other is available in [Appendix](apa.html "Appendix A. The
    JSF Life Cycle"), *The JSF Life Cycle*):'
  prefs: []
  type: TYPE_NORMAL
- en: Restore the View phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the Request Values phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the Validations phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the Model Values phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the Application phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the Response phase
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can easily capture the events of each phase by following these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `PhaseListener` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding the `afterPhase`, `beforePhase`, and `getPhaseId` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the phase listener in `faces-config.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A good point to start is a simple but useful `PhaseListener` that can be used
    to debug the phases. If you ever had the curiosity to see what is happening in
    JSF request lifecycle, then you can use this phase listener, which is defined
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, configure the custom phase listener in `faces-config.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Now, you can play different scenarios with different pages and components to
    see the output. A simple scenario consists in an implicit navigation case, as
    you can see in application `ch4_8_3`, available in the code bundle of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmatic reflection of this configuration in JSF 2.2 is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch4_14_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getPhaseId` method is used to determine the phases that pass through the
    listener. For capturing all the phase events, the method needs to return `PhaseId.ANY_PHASE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase listeners can also be used to alter components. For example, you can
    color the background of `UIInput`, based on the submitted value, by intercepting
    the *Render Response* phase as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch4_8_1`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection in phase listeners (`@Inject`
    and `@EJB`). For example, instead of hardcoding the CSS classes or the text against
    which we choose the CSS class, we can pass them through the injection of a CDI
    bean or an EJB session bean. You can see a complete example in the code bundle
    of this chapter under the name `ch4_8_2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you map the CSS class'' names in a CDI bean (for example, `StyleResourcesBean`)
    or an EJB bean (for example, `StyleResourcesEJBBean`), you can use any of the
    following injections in the phase listener as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: A phase listener can alter many kinds of JSF artifacts, not just UI components.
    For example, the following phase listener collects all `FacesMessages` and modifies
    the global ones. Obviously, you can choose to do anything else such as filter
    them by ID or save them in a special place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is named `ch4_15`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with @ListenerFor and @ListenersFor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@ListenerFor` annotation is an interesting annotation available from JSF
    2.0\. This annotation allows a component to subscribe to particular events with
    the component itself being the listener. For this, we need to follow the ensuing
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `ComponentSystemEventListener` interface (the name indicates that
    the event will always be associated with a `UIComponent` instance).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `processEvent` method (here we can *play* with the component).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `@ListenerFor` to indicate the event that the UI component will subscribe
    for, and the source class of the UI component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, the `UIInput` component can subscribe to the `PostAddToViewEvent`
    event for adding attributes to the component, for example, following is a case,
    where we add some CSS to each `UIInput` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle of this chapter and
    is named `ch4_10_1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@ListenersFor` annotation allows a component to subscribe to more than
    one event. In the previous example, we have added some CSS to each `UIInput` component.
    Next, we want to extend this functionality by adding a separate CSS to the invalid
    `UIInput` components. For this, the `UIInput` components must subscribe to `PostValidateEvent`.
    This approach will help us to distinguish between the valid `UIInput` instances
    and invalid `UIInput` instances. The code for the same is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The complete application is available in the code bundle of this chapter and
    is named `ch4_10_2`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with `@ListenerFor`/`@ListenersFor`
    (`@Inject` and `@EJB`). For example, instead of hardcoding the CSS classes from
    the previous examples, we can pass them through injection of a CDI bean or an
    EJB session bean. You can see a complete example in the code bundle of this chapter,
    under the name `ch4_10_3`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, this was a pretty heavy chapter, but many of the important aspects in
    JSF were touched upon here. You learned how to create, extend, and configure several
    of the main JSF 2.x artifacts and how they have been improvised upon by JSF 2.2,
    especially with the dependency injection mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: There are still a lot of things that were not discussed here; however, in the
    next chapter, we will continue this journey and cover other things, such as renders,
    handlers, and factories.
  prefs: []
  type: TYPE_NORMAL
