- en: Chapter 4. JSF Configurations Using XML Files and Annotations – Part 1
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章. 使用 XML 文件和注解的 JSF 配置 – 第 1 部分
- en: Starting with JSF 2.0, there is no need to create the configuration file, `faces-config.xml`.
    Well, this affirmation is partially true, because JSF annotations still don't
    cover several configurations, such as resource bundles, factories, phase listeners,
    and so on. Usually, JSF annotations provide sufficient support for our applications;
    however, as you will see in this chapter, there are still many cases when `faces-config.xml`
    is mandatory, or additional configurations must be added in the `web.xml` file.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 从 JSF 2.0 开始，不再需要创建配置文件 `faces-config.xml`。好吧，这个断言部分是正确的，因为 JSF 注解仍然没有涵盖几个配置，例如资源包、工厂、阶段监听器等。通常，JSF
    注解为我们提供了足够的应用支持；然而，正如你将在本章中看到的，仍然有许多情况下 `faces-config.xml` 是必需的，或者必须在 `web.xml`
    文件中添加额外的配置。
- en: Nevertheless, JSF 2.2 provides a programmatic approach that can be used to reproduce
    `faces-config.xml`, without writing it in the classical approach. Later in this
    chapter, you will see how to take advantage of this new feature. For now, you
    will see a mix of creating and configuring different kinds of JSF artifacts. They
    will be arbitrarily presented—some of them are well known, from JSF 1.x and 2.0,
    while others are new, starting with JSF 2.2\. Since these configurations are straightforward,
    they can be listed as barren documentation, but gluing each configuration into
    an example is more useful and provides a good point to start when you need to
    use them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，JSF 2.2 提供了一种程序化方法，可以用来重新生成 `faces-config.xml`，而不必使用经典方法。在本章的后面部分，你将看到如何利用这个新特性。现在，你将看到创建和配置不同类型
    JSF 艺术品的混合示例。它们将被任意展示——其中一些是众所周知的，来自 JSF 1.x 和 2.0，而另一些则是新的，从 JSF 2.2 开始。由于这些配置很简单，它们可以被视为空白的文档，但将每个配置粘合到示例中更有用，并提供了一个当你需要使用它们时的良好起点。
- en: 'Therefore, in this chapter you will learn about JSF artifacts'' configurations,
    but you will also see some examples of working with these artifacts. The following
    is a short overview of what we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，你将了解 JSF 艺术品的配置，但你也会看到一些使用这些艺术品的示例。以下是我们将要涵盖的简要概述：
- en: JSF 2.2 new namespaces
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF 2.2 新命名空间
- en: JSF 2.2 programmatic configuration
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSF 2.2 程序化配置
- en: Configuring managed beans in XML
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 XML 中配置管理 Bean
- en: Working with multiple configuration files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个配置文件
- en: Configuring locales and resource bundles
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置区域设置和资源包
- en: Configuring validators and converters
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置验证器和转换器
- en: Configuring navigation
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置导航
- en: Configuring action listeners
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置动作监听器
- en: Configuring system event listeners
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置系统事件监听器
- en: Configuring phase listeners
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置阶段监听器
- en: Working with `@ListenerFor` and `@ListenersFor`
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@ListenerFor` 和 `@ListenersFor`
- en: Obviously, we have a lot of work to do and a lot of JSF 2.2 features to cover
    (for example, JSF 2.2 injection in more artifacts then before), so let's begin!
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们有很多工作要做，也有很多 JSF 2.2 特性需要覆盖（例如，比之前更多的 JSF 2.2 注入），所以让我们开始吧！
- en: JSF 2.2 new namespaces
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 2.2 新命名空间
- en: 'JSF 2.2 modified the existing JSF namespaces, as you can see in the following
    table:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 修改了现有的 JSF 命名空间，如下表所示：
- en: '| Namespace | Before JSF 2.2 | JSF 2.2 |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 命名空间 | 在 JSF 2.2 之前 | JSF 2.2 |'
- en: '| --- | --- | --- |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Faces Core | `http://java.sun.com/jsf/core` | `http://xmlns.jcp.org/jsf/core`
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| Faces 核心库 | `http://java.sun.com/jsf/core` | `http://xmlns.jcp.org/jsf/core`
    |'
- en: '| HTML_BASIC | `http://java.sun.com/jsf/html` | `http://xmlns.jcp.org/jsf/html`
    |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| HTML_BASIC | `http://java.sun.com/jsf/html` | `http://xmlns.jcp.org/jsf/html`
    |'
- en: '| Facelets Templating | `http://java.sun.com/jsf/facelets` | `http://xmlns.jcp.org/jsf/facelets`
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| Facelets 模板 | `http://java.sun.com/jsf/facelets` | `http://xmlns.jcp.org/jsf/facelets`
    |'
- en: '| Composite Components | `http://java.sun.com/jsf/composite` | `http://xmlns.jcp.org/jsf/composite`
    |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 组合组件 | `http://java.sun.com/jsf/composite` | `http://xmlns.jcp.org/jsf/composite`
    |'
- en: '| JSTL Core | `http://java.sun.com/jsp/jstl/core` | `http://xmlns.jcp.org/jsp/jstl/core`
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| JSTL 核心库 | `http://java.sun.com/jsp/jstl/core` | `http://xmlns.jcp.org/jsp/jstl/core`
    |'
- en: '| JSTL Functions | `http://java.sun.com/jsp/jstl/functions` | `http://xmlns.jcp.org/jsp/jstl/functions`
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| JSTL 函数 | `http://java.sun.com/jsp/jstl/functions` | `http://xmlns.jcp.org/jsp/jstl/functions`
    |'
- en: '| Pass Through Attributes | `http://java.sun.com/jsf/passthrough` | `http://xmlns.jcp.org/jsf/passthrough`
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 透传属性 | `http://java.sun.com/jsf/passthrough` | `http://xmlns.jcp.org/jsf/passthrough`
    |'
- en: '| Pass Through Elements | `http://java.sun.com/jsf` | `http://xmlns.jcp.org/jsf`
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 透传元素 | `http://java.sun.com/jsf` | `http://xmlns.jcp.org/jsf` |'
- en: '| `@FacesComponent` default namespace |   | `http://xmlns.jcp.org/jsf/component`
    |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `@FacesComponent` 默认命名空间 |   | `http://xmlns.jcp.org/jsf/component` |'
- en: JSF 2.2 programmatic configuration
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JSF 2.2程序化配置
- en: Starting with JSF 2.2, we can programmatically reproduce the content and tasks
    of `faces-config.xml`. The starting point consists of a callback method, named
    `populateApplicationConfiguration`, which gets a single argument of type `org.w3c.dom.Document`—this
    class belongs to DOM API. Basically, a `Document` (tree node) is a representation
    in memory of an XML document, and we can manipulate it by adding, removing, importing,
    or adopting nodes, elements, and text. For each of these operations, there are
    dedicated methods. For some JSF developers, this API can be something new that
    should be learned; therefore, this can be a drawback of programmatic configuration.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从JSF 2.2版本开始，我们可以通过编程方式重现`faces-config.xml`的内容和任务。起点是一个名为`populateApplicationConfiguration`的回调方法，它接受一个类型为`org.w3c.dom.Document`的单个参数——这个类属于DOM
    API。基本上，一个`Document`（树节点）是XML文档在内存中的表示，我们可以通过添加、删除、导入或采用节点、元素和文本来操作它。对于这些操作中的每一个，都有专门的方法。对于一些JSF开发者来说，这个API可能是一些新的东西，应该学习；因此，这可能是程序化配置的缺点。
- en: 'For now, let''s resume the dissertation from the callback method. The `populateApplicationConfiguration`
    method is provided by a class that extends and implements the abstract class `ApplicationConfigurationPopulator`
    found in the `javax.faces.application` package. In order to tell JSF about this
    class, you need to:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从回调方法中继续讨论论文。`populateApplicationConfiguration`方法由一个扩展并实现`javax.faces.application`包中找到的抽象类`ApplicationConfigurationPopulator`的类提供。为了告诉JSF这个类，您需要：
- en: Create a JAR package (for example, `faces-config.jar` or by using any other
    name).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个JAR包（例如，`faces-config.jar`或使用任何其他名称）。
- en: In this JAR package, create a folder named `META-INF`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此JAR包中，创建一个名为`META-INF`的文件夹。
- en: In the `META-INF` folder, create a folder named `services`.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`META-INF`文件夹中，创建一个名为`services`的文件夹。
- en: In the `services` folder, create an empty file named `javax.faces.application.ApplicationConfigurationPopulator`.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`services`文件夹中，创建一个名为`javax.faces.application.ApplicationConfigurationPopulator`的空文件。
- en: In this file, write the fully qualified name of the class that extends and implements
    the abstract class `ApplicationConfigurationPopulator`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件中，写入扩展并实现抽象类`ApplicationConfigurationPopulator`的类的完全限定名称。
- en: In the JAR root, place the class that extends and implements the abstract class
    `ApplicationConfigurationPopulator`.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在JAR根目录下，放置扩展并实现抽象类`ApplicationConfigurationPopulator`的类。
- en: Done! Now when you add this JAR package in your project `CLASSPATH`, JSF will
    process it and apply the found configurations.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在当您将此JAR包添加到项目的`CLASSPATH`中时，JSF将处理它并应用找到的配置。
- en: 'Supposing that the class that extends and implements the abstract class `ApplicationConfigurationPopulator`
    is named `faces.config.Initializer` (you can use any other name), then the JAR
    content will look like in the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设扩展并实现抽象类`ApplicationConfigurationPopulator`的类命名为`faces.config.Initializer`（您可以使用任何其他名称），那么JAR内容将如下截图所示：
- en: '![JSF 2.2 programmatic configuration](img/6466EN_04_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![JSF 2.2程序化配置](img/6466EN_04_01.jpg)'
- en: 'In this chapter, you will see some programmatic examples as an alternative
    to classical `faces-config.xml`. When we are working directly on a DOM tree node,
    we tend to make stupid mistakes, like forgetting to add the text of an element,
    or placing an element in an improper place, and so on. In order to eliminate these
    errors without headaches, you can write a simple method to serialize the DOM in
    an XML file, which can be easily debugged visually or using a specialized tool.
    The following method accomplishes this task, and you will find it in all the examples
    in this chapter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将看到一些程序化示例，作为经典`faces-config.xml`的替代方案。当我们直接在DOM树节点上工作时，我们往往会犯一些愚蠢的错误，比如忘记添加元素的文本，或者将元素放置在不适当的位置，等等。为了在没有头痛的情况下消除这些错误，您可以编写一个简单的方法将DOM序列化到XML文件中，这可以很容易地通过视觉或使用专用工具进行调试。以下方法完成了这个任务，您将在本章的所有示例中找到它：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Configuring managed beans in XML
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在XML中配置托管Bean
- en: 'JSF managed bean configuration was essentially improved starting with JSF 2.0\.
    Most commonly, a managed bean is annotated with `@ManagedBean` and another annotation
    indicating a JSF scope (for example, `@RequestScoped`). But managed beans can
    be configured in `faces-config.xml` as well, and this approach is not deprecated
    or obsolete. The simplest configuration contains the managed bean''s name, class,
    and scope:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 管理Bean配置从JSF 2.0开始得到了本质上的改进。最常见的情况是，一个管理Bean被注解为`@ManagedBean`，并使用另一个注解来指定JSF的作用域（例如，`@RequestScoped`）。但是，管理Bean也可以在`faces-config.xml`中进行配置，并且这种方法并没有被弃用或过时。最简单的配置包括管理Bean的名称、类和作用域：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case that you need a managed bean that should be eagerly initialized, you
    can use the `eager` attribute of the `<managed-bean>` tag:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要急切初始化的管理Bean，可以使用`<managed-bean>`标签的`eager`属性：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Managed beans'' properties can be initialized from `faces-config.xml` using
    the `<managed-property>` tag as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`<managed-property>`标签从`faces-config.xml`中初始化管理Bean的属性，如下所示：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Inside the `<value>` tag, we can use EL expressions as well. For example, we
    can initialize a property of managed bean `A` with the value of a property belonging
    to managed bean `B`. But, it is important to know that JSF doesn't support cyclic
    dependency for managed bean reference—you cannot refer managed bean `A` from managed
    bean `B`, and vice versa.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<value>`标签内部，我们也可以使用EL表达式。例如，我们可以使用属于管理Bean`B`的属性值来初始化管理Bean`A`的属性。但是，重要的是要知道JSF不支持管理Bean引用的循环依赖——你不能从管理Bean`A`引用管理Bean`B`，反之亦然。
- en: 'An interesting case involves setting a property with the value of a context
    initialization parameter. Such parameters are configured in the deployment descriptor
    (`web.xml`):'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有趣的案例涉及设置一个具有上下文初始化参数值的属性。这些参数在部署描述符（`web.xml`）中配置：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Programmatically, these kinds of parameters can be extracted through the initialization
    map or by their name, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序上，这些类型的参数可以通过初始化映射或通过它们的名称来提取，如下所示：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'These parameters can be accessed from `faces-config.xml` using the EL implicit
    object, `initParam`. JSF provides the ability to reference EL implicit objects
    from a managed bean property, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些参数可以通过`faces-config.xml`使用EL隐式对象`initParam`来访问。JSF提供了从管理Bean属性中引用EL隐式对象的能力，如下所示：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From `faces-config.xml`, we can initialize more complex properties such as
    enumerations and collections. Consider the following enumeration:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从`faces-config.xml`中，我们可以初始化更复杂的属性，例如枚举和集合。考虑以下枚举：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The preceding property can be initialized as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述属性可以按照以下方式初始化：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In case of collections, we can easily initialize maps and lists. A map (`java.util.Map`)
    can be initialized as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合的情况下，我们可以轻松地初始化映射和列表。一个映射（`java.util.Map`）可以按照以下方式初始化：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'While a list `java.util.List` (or array) can be initialized as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个列表`java.util.List`（或数组）可以按照以下方式初始化时：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A property can be initialized with a `null` value by using the `<null-value/>`
    tag.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`<null-value/>`标签来使用`null`值初始化一个属性。
- en: 'If you prefer to configure managed beans in the XML descriptor (instead of
    using annotations), then it is a good practice is to place them into another descriptor
    and not in `faces-config.xml`. Keep this descriptor for application-level configurations.
    For example, you can name it `faces-beans.xml`. JSF will know how to use this
    file when it inspects the application descriptor, `web.xml`, for the following
    predefined context parameter:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢在XML描述符中配置管理Bean（而不是使用注解），那么将它们放置在另一个描述符中而不是`faces-config.xml`中是一个好的做法。保留这个描述符用于应用程序级别的配置。例如，你可以将其命名为`faces-beans.xml`。当JSF检查应用程序描述符`web.xml`时，它将知道如何使用这个文件，因为它检查以下预定义的上下文参数：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now you can keep `faces-config.xml` for other configurations.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以保留`faces-config.xml`用于其他配置。
- en: Obviously, it is much easier to use annotations instead of tags, but sometimes
    this approach can be really useful. For example, you can have some annotated managed
    beans whose behavior you want to change, but for different reasons you cannot
    edit the source code. In such a scenario, you can write the modifications in an
    XML file, because at runtime, configurations from the XML file will take precedence
    against annotations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，使用注解而不是标签要容易得多，但有时这种方法确实非常有用。例如，你可以有一些注解管理Bean，你想要改变它们的行为，但由于不同的原因你不能编辑源代码。在这种情况下，你可以在一个XML文件中编写修改，因为在运行时，XML文件中的配置将优先于注解。
- en: A complete example, named `ch4_12`, is available in the code bundle of this
    chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 本章代码包中提供了一个名为 `ch4_12` 的完整示例。
- en: 'The JSF 2.2 programmatic approach can reproduce the configuration file of the
    `ch4_12` application as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.2 的程序化方法可以按照以下方式重现 `ch4_12` 应用程序的配置文件：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The complete application is named `ch4_14_1`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 完整应用程序命名为 `ch4_14_1`。
- en: Working with multiple configuration files
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与多个配置文件一起工作
- en: JSF 2.0 provides support for ordering the configuration resources. We can use
    **partial ordering** (represented by the `<ordering>` tag) and **absolute ordering**
    (represented by the `<absolute-ordering>` tag).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: JSF 2.0 提供了对配置资源排序的支持。我们可以使用 **部分排序**（由 `<ordering>` 标签表示）和 **绝对排序**（由 `<absolute-ordering>`
    标签表示）。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each document that is involved in the ordering plan is identified by the top-level
    tag, `<name>`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参与订单计划的文档都通过顶级标签 `<name>` 进行标识。
- en: Partial ordering is specific to a single configuration document. We can use
    the `<before>` and `<after>` tags to indicate that a certain document should be
    processed before or after another document. Nested inside the `<before>` and `<after>`
    tags, we may have the `<others/>` tag, which indicates that a certain document
    should be processed before (respectively after) all the other documents that are
    sorted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 部分排序是针对单个配置文档的。我们可以使用 `<before>` 和 `<after>` 标签来指示某个文档应该在另一个文档之前或之后处理。在 `<before>`
    和 `<after>` 标签内部，我们可能有 `<others/>` 标签，它表示某个文档应该在所有其他排序的文档之前（或之后）处理。
- en: 'Listed here is an example where we have documents `A`, `B`, `C`, and `faces-config.xml`
    alias `D`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例，其中包含文档 `A`、`B`、`C` 和别名 `D` 的 `faces-config.xml`：
- en: 'Document `C` needs to be executed before others; hence, it will be executed
    first:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档 `C` 需要在其他文档之前执行；因此，它将被首先执行：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Document `B` has no specified order; hence, it will be executed second:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档 `B` 没有指定顺序；因此，它将被执行第二个：
- en: '[PRE14]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Document `A` needs to be executed after document `B`; hence, it will be executed
    third:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档 `A` 需要在文档 `B` 之后执行；因此，它将被执行第三个：
- en: '[PRE15]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Document `D` (`faces-config.xml`) is executed last and doesn't need any ordering
    specifications.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文档 `D` (`faces-config.xml`) 最后执行，不需要任何排序规范。
- en: The order will be implementation-specific configuration resource, that is, `C`,
    `B`, `A`, and `faces-config.xml` (`D`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序将是实现特定的配置资源，即 `C`、`B`、`A` 和 `faces-config.xml` (`D`)。
- en: Note
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The ordering process (partial or absolute) has no effect over two documents:
    the respective implementation''s (Mojarra or MyFaces) default configuration resource
    is always processed first, and `faces-config.xml` (if exists) is always processed
    last.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 排序过程（部分或绝对）对两个文档没有影响：相应实现（Mojarra 或 MyFaces）的默认配置资源始终首先处理，并且如果存在，`faces-config.xml`
    始终最后处理。
- en: A simple test can be performed using several phase listeners and firing some
    customized messages. Each phase listener is configured in a separate document
    and some partial ordering schema is applied. A complete example can be found in
    the code bundle of this chapter and is named `ch4_13_1`. The console output will
    reveal the effect of partial ordering.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用几个阶段监听器和一些自定义消息来执行一个简单的测试。每个阶段监听器都在一个单独的文档中进行配置，并应用了一些部分排序方案。一个完整的示例可以在本章代码包中找到，并命名为
    `ch4_13_1`。控制台输出将揭示部分排序的效果。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a document has ordering requirements, but no name, then the ordering requirements
    will be ignored.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个文档有排序要求但没有名称，则排序要求将被忽略。
- en: 'The absolute ordering is accomplished by the `<absolute-ordering>` tag. This
    tag can appear only in `faces-config.xml` and provides us control over the order
    that configuration documents will be processed. For example, we have added the
    absolute ordering in the `faces-config.xml` document (alias document `D`) as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对排序是通过 `<absolute-ordering>` 标签实现的。此标签只能出现在 `faces-config.xml` 中，并为我们提供了控制配置文档处理顺序的能力。例如，我们在
    `faces-config.xml` 文档（别名文档 `D`）中添加了绝对排序，如下所示：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And, the processing order is: implementation specific configuration resource
    , `C`, `B`, `A`, and `faces-config.xml` (`D`).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，处理顺序是：实现特定的配置资源，`C`、`B`、`A` 和 `faces-config.xml` (`D`)。
- en: The complete example for absolute ordering is named, `ch4_13_2`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对排序的完整示例命名为 `ch4_13_2`。
- en: Configuring locales and resource bundles
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置区域设置和资源包
- en: A properties file that contains messages can be named `PlayerMessages.properties`.
    When we have messages in several languages, we can create a properties file for
    each language and name it accordingly. For example, for English it will be `PlayerMessages_en.properties`,
    and for French it will be `PlayerMessages_fr.properties`. A convenient place to
    store them is in the application source folder directly or in subfolders (or,
    in NetBeans, under `Other Sources` folder in a Maven web application project).
    A resource bundle is capable of loading and displaying messages from these files.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 包含消息的属性文件可以命名为 `PlayerMessages.properties`。当我们有几种语言的消息时，我们可以为每种语言创建一个属性文件，并相应地命名。例如，对于英语，它将是
    `PlayerMessages_en.properties`，对于法语，它将是 `PlayerMessages_fr.properties`。一个方便的存储位置是在应用程序源文件夹中直接或是在子文件夹中（或者在NetBeans中，在Maven
    Web应用程序项目的`Other Sources`文件夹下）。资源包能够从这些文件中加载和显示消息。
- en: 'A resource bundle can be configured locally or globally. A local resource bundle
    loads the properties file for the specified page only. For this, use the `<f:loadBundle>`
    tag as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 资源包可以在本地或全局配置。本地资源包只为指定的页面加载属性文件。为此，使用以下 `<f:loadBundle>` 标签：
- en: '[PRE17]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A global resource bundle loads the properties file for all the JSF pages. In
    this case, we need a declarative loading in `faces-config.xml`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 全局资源包为所有JSF页面加载属性文件。在这种情况下，我们需要在 `faces-config.xml` 中进行声明性加载：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When we have files for multiple languages, we also have to indicate the locale.
    Locally, this is accomplished in the `<f:view>` tag by adding the locale attribute,
    as follows (here we indicate the French language):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有多语言文件时，我们也必须指明区域设置。在本地，这通过在 `<f:view>` 标签中添加区域设置属性来完成，如下所示（这里我们指明法语）：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Globally, in `faces-config.xml`, we indicate the default locale via `<default-locale>`
    and the list of supported locales using the `<supported-locale>` tag:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在全局上，在 `faces-config.xml` 中，我们通过 `<default-locale>` 指示默认区域设置，并通过 `<supported-locale>`
    标签指示支持的区域设置列表：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Programmatically, we may depict the locale as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程方式，我们可以如下表示区域设置：
- en: '[PRE21]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'A simple entry in the properties file will be as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件中的简单条目如下所示：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The messages will be displayed using the `msg` variable (declared by the `var`
    attribute or the `<var>` tag):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 消息将使用 `msg` 变量（由 `var` 属性或 `<var>` 标签声明）显示：
- en: '[PRE23]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'But, messages can be more complex than static text. For example, they can be
    parameterized, as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，消息可以比静态文本更复杂。例如，它们可以按如下方式参数化：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'And parameters can be replaced using the `<h:outputFormat>` tag:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 并且可以使用 `<h:outputFormat>` 标签替换参数：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'But, how about a message of the following type:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，关于以下类型的消息怎么办：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When you have one player, the message will be as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个玩家时，消息如下所示：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is grammatically incorrect; therefore, you need to use a pattern similar
    to the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这在语法上是错误的；因此，你需要使用类似于以下模式的模式：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will fix the problem. The arguments used here are explained as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解决问题。这里使用的参数解释如下：
- en: '`0, choice`: Take the first parameter and base the output on a choice of available
    formats'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0, choice`: 取第一个参数并根据可用的格式选择输出'
- en: '`0#players`: If the first parameter contains 0 (or below), then it should print
    "players"'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0#players`: 如果第一个参数包含0（或以下），则应打印 "players"'
- en: '`1#player`: If the first parameter contains 1, then it should print "player"'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`1#player`: 如果第一个参数包含1，则应打印 "player"'
- en: '`2#players`: If the first parameter contains 2 (or above), then it should print
    "players"'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`2#players`: 如果第一个参数包含2（或以上），则应打印 "players"'
- en: You can find the complete example under the name `ch4_4`, in the code bundle
    of this chapter.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在本章节的代码包中找到名为 `ch4_4` 的完整示例。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do not confuse the `<resource-bundle>` tag with `<message-bundle>`. The former
    is used for registering custom localized static text, while the latter is used
    for registering custom error/info/warn messages, which are displayed by `<h:message>`
    and `<h:messages>`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将 `<resource-bundle>` 标签与 `<message-bundle>` 标签混淆。前者用于注册自定义本地化静态文本，而后者用于注册自定义错误/信息/警告消息，这些消息由
    `<h:message>` 和 `<h:messages>` 显示。
- en: 'The `<message-bundle>` option is ideally used as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`<message-bundle>` 选项理想的使用方式如下：'
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The message file can be loaded with the `<f:loadBundle>` tag.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 消息文件可以使用 `<f:loadBundle>` 标签加载。
- en: Configuring validators and converters
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置验证器和转换器
- en: Data validation is an important part of a JSF application (which has existed
    since JSF 1.2), because it allows us to separate the business logic from the tedious
    checks that help us to obtain only valid information from the user. Data is validated
    in the *Process Validations* phase (if the `immediate` attribute is set to `true`,
    this processing will occur at the end of the *Apply Request Values* phase instead)
    and should be valid and ready to be used before the *Update Model Values* phase.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据验证是JSF应用程序（自JSF 1.2以来存在）的一个重要部分，因为它允许我们将业务逻辑与帮助我们从用户那里获取仅有效信息的繁琐检查分离。数据在*过程验证*阶段进行验证（如果将`immediate`属性设置为`true`，则此处理将在*应用请求值*阶段结束时发生）并且应在*更新模型值*阶段之前有效且准备好使用。
- en: 'Besides the built-in validators, we can write our own customized validators.
    A public class that implements the `Validator` interface and overrides the `validate`
    method is recognized by JSF as a **validator**. There are two ways to configure
    a validator in JSF: using the `@FacesValidator` annotation or the `<validator>`
    tag in `faces-config.xml`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内置验证器之外，我们可以编写自己的自定义验证器。一个实现了`Validator`接口并重写`validate`方法的公共类被JSF识别为**验证器**。在JSF中有两种配置验证器的方式：使用`@FacesValidator`注解或`faces-config.xml`中的`<validator>`标签。
- en: 'Suppose that we have the following e-mail validator configured using `@FacesValidator`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们使用`@FacesValidator`配置了以下电子邮件验证器：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In JSF 2.2, the name can now be omitted from components, converters, and validators,
    so the preceding code will become `@FacesValidator`. Here, we need to note that
    when the name is omitted, JSF will use the class name, without the package name,
    with the first letter de-capitalized.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在JSF 2.2中，现在可以省略组件、转换器和验证器的名称，因此前面的代码将变为`@FacesValidator`。在这里，我们需要注意，当省略名称时，JSF将使用不带包名的类名，并且首字母小写。
- en: 'If you prefer to use `faces-config.xml`, then `EmailValidator` can be configured
    as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更喜欢使用`faces-config.xml`，那么`EmailValidator`可以配置如下：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, you can easily link `validator` to an input component:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以轻松地将`validator`链接到输入组件：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'An alternate way to do this is as follows:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事的另一种方法是：
- en: '[PRE33]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The complete example of `EmailValidator` is available in the code bundle of
    this chapter and is named `ch4_3_1`. Besides this application, consider, as a
    bonus, two applications that are useful when validators are involved. The first
    one is named `ch4_2`, and requires passing extra parameters to a validator using
    `<f:attribute>`, and the other one is named `ch4_11`, which is an example of validating
    multiple fields using a custom validator and the `<f:attribute>` tag. The latter
    one is also developed using the `PostValidateEvent` system event—check the *Configuring
    system event listeners* section later in this chapter.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`EmailValidator`的完整示例可以在本章的代码包中找到，命名为`ch4_3_1`。除了这个应用程序，作为一个额外的考虑，考虑两个当涉及验证器时有用的应用程序。第一个命名为`ch4_2`，需要使用`<f:attribute>`向验证器传递额外参数，另一个命名为`ch4_11`，它是使用自定义验证器和`<f:attribute>`标签验证多个字段的示例。后者也是使用`PostValidateEvent`系统事件开发的——稍后在本章的*配置系统事件监听器*部分查看。'
- en: Well, there are many articles about JSF validators, but just a few discuss injection
    in JSF validators. By default, JSF 2.0 does not support injection in validators,
    since only managed beans are injection targets, but there are several tricks that
    can bring dependency injection in discussion.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，关于JSF验证器的文章有很多，但只有少数讨论了JSF验证器中的注入。默认情况下，JSF 2.0不支持验证器中的注入，因为只有管理Bean是注入目标，但有一些技巧可以将依赖注入纳入讨论。
- en: 'In order to obtain a validator eligible for injection, you need to apply the
    following modifications, which basically transform the validator into a bean:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得一个可用于注入的验证器，你需要应用以下修改，这基本上将验证器转换成一个Bean：
- en: Replace the `@FacesValidator` annotation with `@Named` or `@ManagedBean` (or
    even with a Spring annotation, `@Component`).
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@FacesValidator`注解替换为`@Named`或`@ManagedBean`（甚至可以使用Spring注解`@Component`）。
- en: Put the bean in a request scope (use the proper `@RequestScoped` annotation)
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Bean放入请求作用域（使用适当的`@RequestScoped`注解）。
- en: '[PRE34]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Refer to it using the proper EL expression:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用适当的EL表达式引用它：
- en: '[PRE35]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Done! Now, you can use `@Inject` in this validator.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 完成！现在，你可以在验证器中使用`@Inject`。
- en: The complete example is available in the code bundle of this chapter and is
    named `ch4_3_2`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例可以在本章的代码包中找到，命名为`ch4_3_2`。
- en: 'A more complicated task is to use `@EJB` for injecting **Enterprise JavaBeans**
    (**EJB**) session beans. In this case, we need to manually lookup the EJB session
    bean from **Java Naming and Directory Interface** (**JNDI**). When the EJBs are
    deployed in **Web application ARchive** (**WAR**) the lookup generally is of the
    following type:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更复杂的任务是使用`@EJB`注入**企业JavaBean**（**EJB**）会话bean。在这种情况下，我们需要从**Java命名和目录接口**（**JNDI**）手动查找EJB会话bean。当EJB部署在**Web应用程序存档**（**WAR**）中时，查找通常是以下类型：
- en: '[PRE36]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'When the EJBs are in an **Enterprise ARchive** (**EAR**), the common lookup
    type is as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当EJB位于**企业存档**（**EAR**）中时，常见的查找类型如下：
- en: '[PRE37]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When EJBs are deployed in WAR, use the following approach:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当EJB部署在WAR中时，使用以下方法：
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'When EJBs are deployed in the EAR, use the following approach:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当EJB部署在EAR中时，使用以下方法：
- en: '[PRE39]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: You can find the complete examples in the code bundle of this chapter. The example
    for EJBs deployed in the WAR is named `ch4_3_5`, and the EJBs deployed in EAR
    case is named `ch4_3_6`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这个章节的代码包中找到完整的示例。部署在WAR中的EJB示例命名为`ch4_3_5`，而部署在EAR情况下的EJB命名为`ch4_3_6`。
- en: These approaches are just some engrafts for bringing dependency injection in
    validators and this seems to be the only workaround in JSF 2.0\. Starting with
    JSF 2.2, injection is possible in many more artifacts, but as the specification
    says, converters and validators are still not injection targets. It seems that
    this will be available from JSF 2.3.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法只是将依赖注入引入验证器的一些附加方法，这似乎是JSF 2.0中唯一的解决方案。从JSF 2.2开始，注入可以在许多更多的地方实现，但正如规范所说，转换器和验证器仍然不是注入目标。这似乎将在JSF
    2.3中可用。
- en: 'Contrary to this affirmation, I tried to write a validator and use the injection
    as it should natively work. I used `@Inject` as follows where `LoginBean` is a
    CDI application scoped bean:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 与这种肯定相反，我尝试编写一个验证器并使用注入，就像它应该原生工作一样。我使用了`@Inject`如下，其中`LoginBean`是一个CDI应用范围bean：
- en: '[PRE40]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Moreover, I also tried to inject an EJB using `@EJB` and `@Inject` where `LoginEJBBean`
    is a stateless session bean, as shown in the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还尝试使用`@EJB`和`@Inject`注入EJB，其中`LoginEJBBean`是一个无状态会话bean，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: I have to admit that I was expecting to see a `null` value for the injected
    resource, but surprisingly, everything worked as expected in all cases. There
    are rumors that, initially, the injection mechanism for validators and convertors
    was added in JSF 2.2, but it was removed at the last moment because some tests
    failed. Even if the preceding examples worked fine, it doesn't mean that is a
    good practice to use this approach in production. You'd better wait until it is
    guaranteed by the JSF team.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我必须承认，我原本期待看到注入的资源为`null`值，但令人惊讶的是，在所有情况下，一切工作都如预期般顺利。有传言称，最初，验证器和转换器的注入机制是在JSF
    2.2中添加的，但在最后一刻因为一些测试失败而被移除。即使前面的示例工作得很好，这也并不意味着在生产中使用这种方法是一个好习惯。你最好等到JSF团队保证后再使用。
- en: Note
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are a fan of OmniFaces, then you can use `@Inject` and `@EJB` with `@FacesValidator`.
    This great facility was added starting with Version 1.6 ([http://showcase.omnifaces.org/cdi/FacesValidator](http://showcase.omnifaces.org/cdi/FacesValidator)).
    Moreover, MyFaces CODI ([http://myfaces.apache.org/extensions/cdi/](http://myfaces.apache.org/extensions/cdi/))
    can also be a workaround, but it requires an additional `@Advanced` annotation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢OmniFaces，那么你可以使用`@Inject`和`@EJB`与`@FacesValidator`。这个伟大的功能是从版本1.6开始添加的（[http://showcase.omnifaces.org/cdi/FacesValidator](http://showcase.omnifaces.org/cdi/FacesValidator)）。此外，MyFaces
    CODI（[http://myfaces.apache.org/extensions/cdi/](http://myfaces.apache.org/extensions/cdi/））也可以作为一个解决方案，但它需要一个额外的`@Advanced`注解。
- en: The complete examples are available in the code bundle of this chapter and they
    are named `ch4_3_3` (web application) and `ch4_3_4` (enterprise application),
    respectively.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的示例可以在本章的代码包中找到，它们分别命名为`ch4_3_3`（Web应用程序）和`ch4_3_4`（企业应用程序）。
- en: When discussing **converters**, let's remember that the conversion between two
    `UIInput` instances happens in the *Process Validations* phase (default), which
    can be moved to *Apply Request Values* phase using the `immediate` attribute set
    to `true`. For `UIOutput`, the conversion happens in the *Render Response* phase.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论**转换器**时，让我们记住，两个`UIInput`实例之间的转换发生在*处理验证*阶段（默认），可以通过将`immediate`属性设置为`true`将其移动到*应用请求值*阶段。对于`UIOutput`，转换发生在*渲染响应*阶段。
- en: 'Beside the built-in converters, we can write our custom converters. A public
    class that implements the `Converter` interface and overrides the `getAsObject`
    and `getAsString` methods is recognized by JSF as a **converter**. There are two
    ways to configure a converter in JSF: using the `@FacesConverter` annotation or
    the `<converter>` tag in `faces-config.xml`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Concerning we have the following converter configured using `@FacesConverter`
    (remember that JSF 2.2 doesn''t need the `value` attribute):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If you prefer to use `faces-config.xml`, then `PlayerConverter` can be configured
    as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, you can easily link the converter to an input component as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'An alternate way to do this is as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Moreover, you can write this as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you configure the converter using the `forClass` attribute, skip the `value`
    attribute as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The complete example of `PlayerConverter` is available in the code bundle of
    this chapter and it is named `ch4_6_1`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking about dependency injection, having converters as targets is pretty
    similar with the situation of validators:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Replace the `@FacesConverter` annotation with `@Named` and `@ManagedBean` (for
    Spring, you can use `@Component` also)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Put the bean in the request scope (use the proper `@RequestScoped` annotation)
    as follows:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Refer to it using the proper EL expression as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The complete example can be found in the code bundle of this chapter and it
    is named `ch4_6_2`. EJBs can be injected in converters by looking up the EJB session
    bean from JNDI. Refer to the examples `ch4_6_5` (EJBs in EAR) and `ch4_6_6` (EJBs
    in WAR).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The following block of code in the `ch4_6_5` application; `RandomEJBBean` is
    a stateless session bean:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The following block of code in the `ch4_6_6` application; `RandomEJBBean` is
    a stateless session bean:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Moreover, under GlassFish 4.0 and Mojarra 2.2.x, I was able to successfully
    run two applications that use injection in converters without any fancy workaround.
    See examples `ch4_6_3` and `ch4_6_4`. Do remember that this approach is not officially
    adopted, however.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Configuring navigation
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Starting with JSF 2, navigation became much easier. Navigation can be accomplished
    using:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Implicit navigation
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditional navigation
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preemptive navigation
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programmatic navigation
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can talk for hours and hours about JSF navigation, but there are a few golden
    rules that save us from falling for the most common mistakes when we need to choose
    between `GET` and `POST`. It might be useful to know that:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended to use the `GET` request for page-to-page navigation, search
    forms, URLs that you want to be visible and bookmarkable, and, in general, for
    any idempotent request. By specification, `GET`, `HEAD`, `PUT`, `DELETE`, `OPTIONS`,
    and `TRACE` are idempotent.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For requests that shouldn't be bookmarkable, use the same view repeatedly (use
    forward, not redirect).
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For requests that shouldn't be bookmarkable, but have bookmarkable targets,
    use `POST` and redirect.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit navigation
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Implicit navigation** interprets navigation outcomes as target view IDs.
    The simplest implicit navigation case is accomplished by JSF itself whenever you
    perform an action and no navigation is indicated. In this case, JSF will post
    a form (via `HTTP POST`) back to the current view (render the current view again).'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Without declarative navigation in `faces-config.xml`, we can easily write navigation
    cases, such as the following where JSF 2 knows how to treat `outcome` (or the
    `action` value) as the targeted page name:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the `success.xhtml` page exists, then all the given examples will navigate
    to this page. The `<h:outputLink>` element will navigate independently of JSF
    (that means it doesn''t interact with JSF). The `<h:link>` and `<h:button>` elements
    will navigate via a bookmarkable `GET` request and aren''t capable of form submissions
    (as you will see, this is actually preemptive navigation). The `<h:commandButton>`
    and `<h:commandLink>` elements are the main components for navigating within a
    JSF application. They fire `POST` requests and are capable of form submissions.
    Whenever you want to add the application context path in a URL (for example, the
    URL generated via `<h:outputLink>`, you can use the `ExternalContext.getApplicationContextPath`
    method of JSF 2.2\. For example, take a look at the following code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The declarative version of this is as follows—thanks to implicit navigation,
    this code is not needed:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The outcome of `<h:link>` and `<h:button>` are evaluated during the *Render
    Response* phase; therefore, the URLs are available right from the start of the
    corresponding view. On the other hand, when the button (`<h:commandButton>`) or
    link (`<h:commandLink>`) is clicked, JSF will merge the `action` value `success`
    with the XHTML extension and find the view name `success.xhtml` in the current
    page directory.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Wildcard ("*") is supported to specify a navigation rule that applies to all
    pages. It can be useful for a logout page.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The navigation case can also pass through a bean method, as follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Also, the `PlayerBean` method is defined as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In these examples, the `outcome`/`action` values and the target view ID matches.
    However, the `outcome`/`action` values and target view ID are not always that
    simple. The `outcome`/`action` values are used to determine the target view ID
    even if they don''t have the same root. For example, refer to the following code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The preceding code indicates the `done.xhtml` page, but this page doesn''t
    exist; therefore, no navigation happens. We need to add a declarative navigation
    rule in `faces-config.xml` in order to link the `action` value (or the `outcome`
    value that is fetched via preemptive navigation, which we will see soon), `done`,
    with target view ID, `success.xhtml`. This navigation rule can be seen in the
    following code:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'If the bean method returns the outcome `done`, then the navigation rules are
    modified as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: By default, between **forward** and **redirect**, JSF will navigate from one
    page to another using the forward mechanism (`HTTP POST`). When JSF receives the
    user action, it will forward the user to the determined target page, which means
    that the URL displayed by the browser will not be updated to reflect the current
    target. Keeping the browser URL updated implies the page redirectionmechanism;
    in this case, JSF, delegates the browser to send a separate `GET` request to the
    target page.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the page redirection mechanism by attaching the `faces-redirect=true`
    parameter to the outcome query string as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Alternatively, you can use the `<redirect/>` tag inside the navigation rule
    as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the forward case, the browser URL is not updated (is with a step behind navigation
    URL), but there is a single request. In the redirect case, the browser URL is
    up to date, but there are two requests. Since forward needs a single request,
    it is faster than page redirection. The speed is lower, but page redirection solves
    the duplicated form submission problem found in the Post-Redirect-Get design pattern.
    Of course, this is not the case for `<h:link>`, `<h:button>`, and `<h:outputLink>`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: These examples are grouped in the `ch4_5_1` application in the code bundle of
    this chapter.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: Conditional navigation
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Conditional navigation** allows us to specify preconditions for choosing
    the desired navigation case; a precondition must be met in order for the navigation
    case to be accepted. For this, we use the `<if>` tag as a child of the `<navigation-case>`
    tag and use an EL expression that can be evaluated to a Boolean value; here the
    `true` value matches the navigation case.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a simple button that logs the user into the application. This is
    done using the following code:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When the **Login** button is clicked, JSF will call the `playerLogin` method.
    This method will not return an outcome, actually it returns `void`. In this example,
    we simulate a login process through a random number and set a Boolean value, `login`,
    accordingly, as shown in the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Next, we can use the `<if>` tag to decide if we navigate to the `success.xhtml`
    page (equivalent to `login` equals `true`) or to the `failed.xhtml` page (equivalent
    to `login` equals `false`):'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In conditional navigation, the navigation cases are evaluated even when the
    outcome is `null` or `void`. Notice that there is no `<else>` tag or multiple
    conditional checking; therefore, in such cases, you have to emulate a `switch`
    statement. If you want to simply match the `null` outcome in any case, then you
    can use a condition of type: `<if>#{true}</if>`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the sequence of the navigation rule affects the navigation flow; therefore,
    it is a good practice to prioritize conditions.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example in the code bundle of this chapter, under
    the name `ch4_5_2`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write conditional navigation cases without the `<if>` tag by delegating
    the decision of choosing the navigation case to a bean method. For this, we have
    to replace the static value of the `<to-view-id>` tag with an EL expression, as
    follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Notice that this is not a real conditional navigation (since `<if>` is missing);
    therefore, we need to return an outcome from the `playerLogin` method:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When the `login` property is set and the outcome `done` is returned, JSF will
    follow the preceding navigation case and reach for the `navigateHelper` method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In a real application, the method that returns the outcome and the method that
    chooses the navigation case will probably be in different beans. If you take into
    account that you can pass arguments to the decisional method, then many navigation
    cases can be solved.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example in the code bundle of this chapter, under
    the name `ch4_5_3`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Preemptive navigation
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Preemptive navigation** is available starting with JSF 2.0\. The navigation
    rules are more permissive and they are evaluated during the *Render Response*
    phase instead of the *Invoke Application* phase.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is known as predetermined navigation or preemptive navigation. The current
    view ID and specified outcome are used to determine the target view ID. Afterwards,
    the target view ID is translated into a bookmarkable URL and used as the hyperlink's
    target. Practically, the URL is prepared without user interaction.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'The main usage of preemptive navigation appears in bookmarkable component tags,
    `<h:link>` and `<h:button>`. For example, the following are two classical examples
    of preemptive navigation:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: When the application starts, you can check the source code of the page to see
    how the corresponding URLs were mapped in the HTML tag `<a>` in case of `<h:link>`,
    and the HTML tag `<input type="button">` in case of `<h:button>`. Even if you
    never use those URLs, they are ready to serve.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Well, before JSF 2.0, navigation rules were explicitly the domain of `POST`
    requests (`NavigationHandler.handleNavigation` was doing the dirty job behind
    the scene), but the new support for GET-based navigation and bookmarkability takes
    navigation to another level of flexibility and transparency (for example, the
    `ConfigurableNavigationHandler` API).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'The interesting part here is how the query string of a URL is assembled. The
    simplest case consists of the implicit query string parameter as shown in the
    following code:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: In [Chapter 2](ch02.html "Chapter 2. Communication in JSF"), *Communication
    in JSF*, you saw how to build the query string using `<f:param>` and `<f:viewParam>`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way consists in using the `<view-param>` tag nested in a `<redirect>`
    tag in a navigation case. For example, we can add query string parameters to a
    redirect URL in the navigation rules. Let''s create the following button:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Also, a silly method named `playerDone` is as follows:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, we can add the `player` property value (of course, you can add any other
    value) as a parameter in the query string of the redirection navigation URL:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: A URL like this will be of the format (notice how the request parameter was
    attached based on the navigation rule) `http://`*host*`:`*port*`/`*app-name*`/faces/success.xhtml?playerparam=Rafael+Nadal`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: 'The `playerparam` value will be available through the `param` implicit object:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: You can find the complete example in the code bundle of this chapter, under
    the name `ch4_5_4`.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Programmatic Navigation
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you need to control navigation directly from the application. JSF
    provides the `NavigationHandler` and `ConfigurableNavigationHandler` APIs that
    can be used for tasks such as accessing navigation cases, customizing navigation
    handlers, conditional navigations, and so on. It is good to know that, programmatically
    speaking, we can do the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Obtain access to navigation handler (`NavigationHandler`) using the following
    code:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Invoke navigation case using `NavigationHandler` as follows:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Access the `ConfigurableNavigationHandler` API using the following code:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Invoke navigation case using `ConfigurableNavigationHandler` as follows:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Retrieve one `NavigationCase` object by the action expression signature and
    outcome as shown in the following code:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Access all navigation rules into `Map<String, Set<NavigationCase>>`, where
    the keys are the `<from-view-id>` values as follows:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Note
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we have **wrappers** for many classes that provide basic
    implementations and help developers to extend those classes and override only
    the necessary methods. Among them, we have a wrapper class for `NavigationHandler`,
    named `NavigationHandlerWrapper`, one for `ConfigurableNavigationHandler`, named
    `ConfigurableNavigationHandlerWrapper`, and one for `NavigationCase`, named `NavigationCaseWrapper`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. JSF Scopes – Lifespan and Use in Managed
    Beans Communication"), *JSF Scopes – Lifespan and Use in Managed Beans Communication*,
    you saw a custom implementation of `ConfigurableNavigationHandler` in *The flow
    scope* section, and you saw a custom implementation of `NavigationHandler` in
    the *Controlling the custom scope lifespan with the navigation handler* section.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Configuring action listeners
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Action listeners are a great facility provided by JSF for dealing with action
    events. Commonly, action listeners are attached to command buttons (`<h:commandButton>`)
    or command links (`<h:commandLink>`) using the `actionListener` attribute.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: When a button/link is clicked, JSF calls the action listener during the *Invoke
    Application* phase. Notice that if you are using `immediate="true"`, then the
    action listener is called during the *Apply Request Values* phase. The method,
    indicated as a listener, should be public, should return `void`, and should accept
    an `ActionEvent` object (this object can be used to access the component that
    invoked the action), which can perform specific tasks. When its execution has
    finished, JSF will call the method bound by the `action` attribute (if it exists!).
    This method is responsible to indicate the navigation case. The action listener
    method can alter the response returned by the action method.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a practice, `actionListener` is used to have some "fun" before the real business
    and navigation task, which is the responsibility of `action`. So, do not abuse
    `actionListener` for solving business logic tasks!
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use an example of a simple command button that uses an action listener,
    as shown in the following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The `PlayerBean` contains the following code:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Well, the log messages reveal the order of calls as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This kind of listener doesn't need any special configuration.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of listener can be written by implementing the `ActionListener`
    interface and overriding the `processAction` method. In this case, we need to
    use the `<f:actionListener>` tag for attaching the action listener to a command
    button/link:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Well, the `PlayerListener` is defined as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'And, the output of the log messages will be as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Again, these kinds of listeners do not need any special configurations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2 the `ActionListener` interface was wrapped in a simple
    implementation named, `ActionListenerWrapper`. You need to extend this class and
    override `getWrapped` to return the wrapped instance.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the `PlayerListener` may be called via the following wrapper:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'You can even combine these two listeners into a single command button, as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'In this case, the log messages are as follows:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Well, this example gives us an important rule: the action listeners are invoked
    before `action` and in the same order as they are declared inside the component.'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Application action listeners
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far so good! The last category of action listeners are known as application
    action listeners. They are set on the application level and are called by JSF
    even for command buttons/links that do not specify any action listener explicitly.
    Such an action listener may look like the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'This action listener will be called for a command button/link even if it doesn''t
    specify it, as shown in the following code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'The output will be as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'In JSF 2.2, we can write this implementation by extending `ActionListenerWrapper`
    as follows:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Application action listeners are called after the action listeners that are
    explicitly set via the `actionListener` attribute or the `<f:actionListener>`
    tag.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to be called, such listeners must be configured in `faces-config.xml`.
    For example, the preceding listener can be configured as follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Note
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you are using application action listeners, it is important to keep in
    mind a few things:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Application action listeners cannot invoke other listeners.
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application action listeners are responsible for processing the `action` attribute.
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application action listeners cannot catch events from other listeners.
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have probably noticed that an action listener throws an `AbortProcessingException`
    exception. When this exception appears, JSF will directly jump to render the response
    and ignore further action listeners. The error is *swallowed* by default, so don't
    expect to see it! You can make it visible by altering the default mechanism of
    treating exceptions.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'You might think that action listeners rock! Wait till you see this starting
    with JSF 2.2\. We can use the injection mechanism for injecting CDI managed beans
    and EJBs in action listener classes. For example, the simple bean shown in the
    following code:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'This bean can be injected in our application action listener as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Obviously, this facility opens new perspectives in implementing applications.
    And, as you will see next, injection mechanism is available for many other JSF
    artifacts that do not support it in JSF 2.0.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: A complete example named `ch4_1`, is available in the code bundle of this chapter.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: Configuring system event listeners
  id: totrans-357
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSF 2.0 allows us to use **system events**. These are events that can be fired
    by arbitrary objects at arbitrary points during the request processing lifecycle.
    Since the number of these events is quite big, you will not see them entirely
    covered here, but the next five examples should clarify the basic aspects of system
    events. You can find all of them in the `javax.faces.event` package.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: Using <f:event>
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to use system event listeners consists in passing the name
    of the managed bean method in the `listener` attribute of the `<f:event>` tag.
    For example, `PostValidateEvent` is a system event that gets fired after all components
    are validated. This can be useful to validate multiple components. Suppose, that
    a user submits a form that contains his name, surname, bank account, and the confirmation
    of that bank account (like a password that should be typed twice for confirmation).
    In order to check if the same bank account was typed in both fields, we can use
    `PostValidateEvent`, as follows:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now, in `PlayersBean`, we need to implement the `validateAccount` method as
    follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Done! If you don't provide the same bank account, then you will see the corresponding
    message. The complete application is named `ch4_7`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Implementing SystemEventListener
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another approach of handling system events is based on the following steps:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `SystemEventListener` interface.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding the `processEvent` and `isListenerForSource` methods.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the listener in `faces-config.xml`.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The registered system event can be fired by many kinds of sources (components).
    We can sort and accept certain sources in the `isListenerForSource` method. It
    returns `true` when the listener should receive events from the source passed
    to it as an argument (usually a simple test using the `instanceof` operator should
    do the work). When a source is accepted, the `processEvent` method is called and
    we can add a custom behavior.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s suppose that we want to remove certain resources included
    by JSF, such as CSS style sheets or JS scripts (it could be even resources added
    by third-party libraries). Speaking about CSS resources, they are always rendered
    in the `HEAD` section of an HTML page. Knowing that, we can configure our listener
    to be executed if the event source is a `UIViewRoot` instance. Further, we exploit
    JSF API to loop through the CSS resources and remove some of them (or, all of
    them). The code of our listener is pretty simple, as you can see in the following
    code:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The listener should be configured in `faces-config.xml`, as follows:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'So, even if initially we write the following code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'JSF will render the following code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `<source-class>` tag is actually overriding the condition from the `isListenerForSource`
    method. So, you can always return `true` from the `isListenerForSource` method
    and use this tag, or vice versa.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: You can find the complete example under the name `ch4_9_1`, in the code bundle
    of this chapter.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see another example. A common approach, when some form input fields
    are invalid, is to color the background in red. In JSF 2.0, we can do that using
    the following code:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'Well, that is really cool! But, if the form has several input fields, then
    we have to repeat the condition again and again, which isn''t cool anymore! But,
    with a little magic, we can generalize this behavior. We can write a listener
    that will be executed only from the `UIInput` objects and modify their `styleClass`
    attribute based on the result returned by the `isValid` method:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Of course, this is simple and there is nothing to explain. Actually, the key
    lies in the configuration file, because we have to choose the right system event
    from the plethora of available events. Since we need to color the background of
    invalid input fields in red, the right choice should be `PostValidateEvent`, as
    shown in the following code:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Done! A functional example is available in the code bundle of this chapter
    and is named `ch4_9_3`. The JSF 2.2 programmatic reflection of this configuration
    is listed as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: The complete application is named `ch4_14_2`.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection in system event listeners(`@Inject`
    and `@EJB`). For example, instead of hardcoding the CSS resources that we need
    to remove from `HEAD`, we can pass them through injection of a CDI bean or an
    EJB session bean. You can see a complete example in the code bundle of this chapter.
    This one is named `ch4_9_2`.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'After you map the CSS classes names in a CDI bean (for example `StyleResourcesBean`)
    or EJB bean (for example `StyleResourcesEJBBean`), you can use any of the following
    injections:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Note
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides the injection facility, JSF 2.2 comes with a set of four brand new
    system events dedicated to Flash scope. These are:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '`PostKeepFlashValueEvent`: This event is fired when a value is kept in the
    Flash'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostPutFlashValueEvent`: This event is fired when a value is stored in the
    Flash'
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreClearFlashEvent`: This event is fired before the Flash is cleared'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PreRemoveFlashValueEvent`: This event is fired when a value is removed from
    the Flash'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember that in [Chapter 2](ch02.html "Chapter 2. Communication in JSF"),
    *Communication in JSF*, you saw an application based on the Flash scope. In this
    chapter, we will write a system event listener to monitor two of these events,
    `PostKeepFlashValueEvent` and `PreClearFlashEvent`. The code for this is as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Do not forget to configure the listener in `faces-config.xml` as follows:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: A functional example is available in the code bundle of this chapter, and is
    named `ch4_9_4`.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Generally speaking, from JSF 2.2 onwards, the `PostRestoreStateEvent` system
    event is published using `Application.publishEvent` without making `UIComponents`
    default listeners, but still doing the traditional tree traversal. This event
    was an exception for the rule in the previous JSF versions!
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Configuring phase listeners
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the name suggests, a **phase listener** is capable to listen to the start
    and end of each of the six JSF life-cycle phases (a detailed diagram of how JSF
    phases interact with each other is available in [Appendix](apa.html "Appendix A. The
    JSF Life Cycle"), *The JSF Life Cycle*):'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Restore the View phase
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply the Request Values phase
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process the Validations phase
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the Model Values phase
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invoke the Application phase
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Render the Response phase
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can easily capture the events of each phase by following these three steps:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the `PhaseListener` interface.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Overriding the `afterPhase`, `beforePhase`, and `getPhaseId` methods.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the phase listener in `faces-config.xml`.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A good point to start is a simple but useful `PhaseListener` that can be used
    to debug the phases. If you ever had the curiosity to see what is happening in
    JSF request lifecycle, then you can use this phase listener, which is defined
    as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Finally, configure the custom phase listener in `faces-config.xml` as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Now, you can play different scenarios with different pages and components to
    see the output. A simple scenario consists in an implicit navigation case, as
    you can see in application `ch4_8_3`, available in the code bundle of this chapter.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'The programmatic reflection of this configuration in JSF 2.2 is as follows:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The complete application is named `ch4_14_3`.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `getPhaseId` method is used to determine the phases that pass through the
    listener. For capturing all the phase events, the method needs to return `PhaseId.ANY_PHASE`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'Phase listeners can also be used to alter components. For example, you can
    color the background of `UIInput`, based on the submitted value, by intercepting
    the *Render Response* phase as follows:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The complete example is available in the code bundle of this chapter, and is
    named `ch4_8_1`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection in phase listeners (`@Inject`
    and `@EJB`). For example, instead of hardcoding the CSS classes or the text against
    which we choose the CSS class, we can pass them through the injection of a CDI
    bean or an EJB session bean. You can see a complete example in the code bundle
    of this chapter under the name `ch4_8_2`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: 'After you map the CSS class'' names in a CDI bean (for example, `StyleResourcesBean`)
    or an EJB bean (for example, `StyleResourcesEJBBean`), you can use any of the
    following injections in the phase listener as follows:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: A phase listener can alter many kinds of JSF artifacts, not just UI components.
    For example, the following phase listener collects all `FacesMessages` and modifies
    the global ones. Obviously, you can choose to do anything else such as filter
    them by ID or save them in a special place.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The complete application is named `ch4_15`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: Working with @ListenerFor and @ListenersFor
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `@ListenerFor` annotation is an interesting annotation available from JSF
    2.0\. This annotation allows a component to subscribe to particular events with
    the component itself being the listener. For this, we need to follow the ensuing
    steps:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: Implement the `ComponentSystemEventListener` interface (the name indicates that
    the event will always be associated with a `UIComponent` instance).
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `processEvent` method (here we can *play* with the component).
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `@ListenerFor` to indicate the event that the UI component will subscribe
    for, and the source class of the UI component.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, the `UIInput` component can subscribe to the `PostAddToViewEvent`
    event for adding attributes to the component, for example, following is a case,
    where we add some CSS to each `UIInput` component:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: The complete application is available in the code bundle of this chapter and
    is named `ch4_10_1`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: 'The `@ListenersFor` annotation allows a component to subscribe to more than
    one event. In the previous example, we have added some CSS to each `UIInput` component.
    Next, we want to extend this functionality by adding a separate CSS to the invalid
    `UIInput` components. For this, the `UIInput` components must subscribe to `PostValidateEvent`.
    This approach will help us to distinguish between the valid `UIInput` instances
    and invalid `UIInput` instances. The code for the same is as follows:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: The complete application is available in the code bundle of this chapter and
    is named `ch4_10_2`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Starting with JSF 2.2, we can use dependency injection with `@ListenerFor`/`@ListenersFor`
    (`@Inject` and `@EJB`). For example, instead of hardcoding the CSS classes from
    the previous examples, we can pass them through injection of a CDI bean or an
    EJB session bean. You can see a complete example in the code bundle of this chapter,
    under the name `ch4_10_3`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-453
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, this was a pretty heavy chapter, but many of the important aspects in
    JSF were touched upon here. You learned how to create, extend, and configure several
    of the main JSF 2.x artifacts and how they have been improvised upon by JSF 2.2,
    especially with the dependency injection mechanism.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: There are still a lot of things that were not discussed here; however, in the
    next chapter, we will continue this journey and cover other things, such as renders,
    handlers, and factories.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
