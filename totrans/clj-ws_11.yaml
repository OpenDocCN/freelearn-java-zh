- en: 11\. Macros
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning objectives
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how Clojure macros work and how to write them.
    Macros are a very powerful feature of Clojure that simply does not exist in many
    other non-Lisp languages. Writing macros requires learning some new concepts and
    some new skills. This chapter will take you through the basic concepts: distinguishing
    between compile-time and run-time execution, quoting strategies and macro hygiene.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to automatically generate functions
    and craft custom environments to streamline your code.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Macros** have been a distinctive feature of Lisps for decades. They are sometimes
    presented as a superpower native to the world of Lisp. While macros do exist in
    other languages, for many decades, Lisps have had the most complete macro systems.
    Why is this? Languages from the Lisp family share the ability to write code that
    modifies itself. People often talk about "code as data": Lisp programs, with their
    nested sets of parentheses called **s-expressions**, are in fact lists. And Lisps,
    as languages, are good at manipulating lists. The name "Lisp" originally came
    from "LISt Processor" when the language was first invented in 1958\. As a result,
    Lisps can be made to operate on the code of Lisp programs. Usually, this means
    that a program modifies its own code.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The term **homoiconicity** is often applied to Lisps. While the exact meaning
    of this term depends on who is talking, it generally means that Lisps are written
    in forms that they can manipulate themselves and that these same structures are
    more or less mirrored inside the Lisp interpreter or compiler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, this is called **metaprogramming**: writing a program that will
    write your program for you. If that sounds too good to be true, it''s because
    it is. Macros can''t do everything for you, of course. They can write parts of
    your program, though, and make your code easier to write by removing some of the
    boilerplate and other forms of repetition, or by transforming the language''s
    syntax to better fit the problem at hand.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Has this ever happened to you? You''re working on a large project and you find
    yourself writing function after function, method after method, and they are almost
    identical. You know the DRY principle: *Don''t Repeat Yourself*. "Maybe I''m missing
    an abstraction here, maybe I could simplify this," you think to yourself. Yet
    when you try, there is always *one* piece of code that needs to be different and
    can''t be abstracted away. It might be some conditional logic that is different
    each time. So, you give up on a cleaner solution and keep typing away. Macros
    might have helped.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a slightly more concrete scenario. You''re writing code with a lot
    of Boolean logic. After a few days, it starts to feel as though just about every
    function in your code base has a few of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The logic is slightly different each time, so you can't write a function, yet
    the logic is so similar each time that you feel like you're constantly repeating
    yourself. What if you could just write this instead?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Well, you can. With a macro.
  prefs: []
  type: TYPE_NORMAL
- en: This eliminates one level of nested parentheses, so it's easier to type. It
    might even be easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of reasons this would be impossible with a function. The
    most important reason is that a macro such as `and-ors` preserves the "short-circuiting"
    property of `and` (which is a macro itself). As soon as one of the conditions
    fails, evaluation stops and the remaining conditions are ignored, with possible
    performance benefits, or to avoid possible side effects. The other reason is that
    we're able to use `|` as a separation symbol without having to define it before
    using the macro. It's like being able to define our own language operators.
  prefs: []
  type: TYPE_NORMAL
- en: This kind of "magic" is possible because macros are executed before your code
    is compiled. Their purpose is to transform your source code before it goes to
    the compiler. If this sounds complicated and confusing, well, sometimes, it is.
    By building on concrete examples, however, you'll quickly realize that though
    macros aren't magical, they can be useful. And though they can be very complex,
    they don't always have to be. Understanding how they work will also help you avoid
    using them when they are not the best solution.
  prefs: []
  type: TYPE_NORMAL
- en: Clojure provides a modern macro system that is largely based on – and improves
    – the Common Lisp macro system, and as such, it is an extremely powerful tool.
    In spite of this power, Clojure programmers generally write far fewer macros than
    Common Lisp programmers, or Scheme or Racket programmers. The reasons for this
    are probably varied. Most books about macros, in any Lisp, start out by warning
    that macros should only be used when you're absolutely sure that a function will
    not work. Often, Clojure's functional programming is useful and powerful enough
    that writing a macro isn't really necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, though, a macro can be the best solution to a problem or can help
    simplify code that would otherwise be complicated and/or repetitive. Learning
    to write macros is also a rite of passage for any self-respecting Clojure programmer.
    So, let's go!
  prefs: []
  type: TYPE_NORMAL
- en: What is a Macro?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A macro is a piece of code that is executed before your code is compiled. The
    code contained inside a macro call is transformed into something different and
    then passed on to the compiler. In Clojure, macros are defined by calling `defmacro`.
    A call to `defmacro` looks fairly similar to a call to `defn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite this apparent similarity, there is a huge difference between macros
    and functions. Unlike functions, macros are not called at runtime. When your program
    finally starts running, the macros have already been called. The code they produce
    has already been included in your program *as if you had typed it in yourself*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Separating compile time from runtime is the key to understanding
    macros'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_11_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.1: Separating compile time from runtime is the key to understanding
    macros'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep this idea in mind while you think about and work with macros: any macro
    in your code could, in principle, be replaced by code that you type out yourself.
    Some macros are very complex and it would be extremely difficult and painstaking
    to replace them with hand-written code, but with enough time, patience, and expertise,
    it would theoretically be possible. Just as you write your code before you run
    it, macros are expanded before your code is run.'
  prefs: []
  type: TYPE_NORMAL
- en: A Very Minimal Macro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with a very simple, and not very useful, macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a lot like a function definition. We could just as easily write
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run both of these at the REPL, the results are also identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There is only one meaningful difference between these two definitions, and it
    is a very small one. Do you see it? It's the `'`, which is shorthand for the `quote`
    special form. Despite its small size, it makes a huge difference.
  prefs: []
  type: TYPE_NORMAL
- en: When we run `minimal-function`, the Clojure runtime simply executes the call
    to `println`. When we run `minimal-macro`, the macro actually inserts the `(println
    "I'm trapped inside a macro!")` statement into your source code before the Clojure
    runtime reads it. To be more precise, we say that Clojure **expands** the macro.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to appreciate the difference between `minimal-macro` and `minimal-function`
    is to use Clojure's `macroexpand` function, which translates a call to a macro
    into actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the result of calling `macroexpand` on a call to `minimal-function`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This seems a little redundant, and for good reason: `(minimal-function)` is
    not a macro, and so only expands into itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When calling `macroexpand`, it's important to quote the form you are expanding.
    Otherwise, `macroexpand` will try to expand the results of the call to `minimal-function`.
    Because `println` returns `nil`, the result would be `nil`, and there would be
    nothing to expand. Whenever you get surprising results from `macroexpand`, make
    sure that you haven't forgotten to quote the macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding `(minimal-macro)` is quite different, though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When we type `(minimal-macro)` at the REPL, it is expanded into the `println`
    expression, exactly as if you had typed it out yourself. Notice that the expanded
    form is no longer quoted. (As you're probably starting to guess, quoting is an
    important part of macro writing.)
  prefs: []
  type: TYPE_NORMAL
- en: Compile Time and Run Time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the importance of quoting, let''s try writing a macro without the `''`
    at the beginning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling this macro in the REPL yields the same results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s wrong with that? `mistaken-macro` seems to work just as well as the
    others… Or does it? Let''s try expanding it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: That's strange! The output is the same as when we call the macro directly, yet
    it is totally different from both `minimal-function`, which just expanded to itself,
    and `minimal-macro`, which expanded into the `println` expression. So, what is
    really going on here? And why did removing the `quote` apostrophe make such a
    difference?
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that calling `(mistaken-macro)` produces the same output as the other
    forms could almost be called a coincidence. The call to `println` happens, but
    it happens at compile time. And because `println` returns nil, `(mistaken-macro)`
    expands to exactly that: `nil`. This is also why we see the `"I''m trapped…"`
    message when we call `macroexpand`: that message is a side effect of the macro
    expansion!'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `minimal-macro` and `mistaken-macro` is that the former,
    by quoting the form, actually returns a `println` symbol and the message string.
    `mistaken-macro`, on the other hand, expands to `nil` because it calls `println`
    immediately, at expansion time.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several important points here that we will build on in the rest of
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Code is actually run when macros are expanded, and when the code is run. This
    is why `mistaken-macro` actually prints out a message.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the difference between compile time and runtime is important.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting is important because it is one of the ways that you, as a programmer,
    control which code is executed when the macro is expanded, and which code is run
    at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Remember: a macro is code that writes code. Let''s write a slightly more sophisticated
    macro that will expand to an arbitrary number of `println` calls. Our goal is
    for the macro to expand to this if we provide `3` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When working with macros, it is always a good idea to start by thinking about
    the code you want the macro to produce and then work back to how you will produce
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than thinking of this as a series of steps to execute, it's best to think
    of it as a list containing a symbol (`do`) and a series of sub-lists, each containing
    a symbol and a string. Thinking of `do` and `println` as symbols rather than a
    special form and a function is a good approach because, at expansion time, we
    just want to make sure that the form we end up producing has the correct symbols
    in the right order. Thinking of `println` as "just a symbol" is how the macroexpansion
    code "thinks" about it too if it is quoted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce a list of lists, we might use `repeat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There's that single quotation mark again. If we left it out, we would get `(nil
    nil nil nil nil)`. And thanks to quoting, none of those calls to `println` are
    ever called. We are getting close to our target code and we haven't even called
    `defmacro` yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing missing is the initial `do` symbol. Adding a value to the front
    of a list is fairly easy too, as long as we quote it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s our code! All that''s left is to wrap this up as a macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call the macro directly, it seems to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'And `macroexpand` confirms it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The point here is to show that a macro is code that writes code. The contents
    of `multi-minimal` don''t look very much like the output. We could even go further
    and wrap them in a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we'll see later, some macros look a little bit like templates, but there
    is nothing that requires their definitions to resemble the code that is output.
    Breaking the code-building code out into a separate function can be a useful pattern,
    especially for debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Obviously, we can't expect this particular macro to be very useful. Still, it
    would be nice if it would print something besides "macro." What if we gave it
    a second parameter – a string to be passed on to all those `println` calls? There's
    already one parameter; adding a second one should be easy enough… right?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try just adding a parameter and passing that to `println`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this doesn''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s wrong? As always, when we don''t understand what is wrong with a macro,
    we reach for `macroexpand`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: By the time the macro has been expanded, the `s` parameter has disappeared.
    Where did it go? Unlike `defn`, `defmacro` does not provide a context for runtime
    variable bindings. The original `n-times` parameter is available while the macro
    is being expanded, but afterward, the macro itself has been replaced by the code
    it produced. There is no trace left of `n-times`, or `s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, there must be a way around this, since macros would be rather useless
    if they didn''t accept parameters. If we want there to be a context, we just need
    to create that context explicitly ourselves in quoted code that will still be
    present at runtime. In a case like this, the simplest solution would be a `let`
    binding. We need to change our target code to something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Why is the `let` binding called `string-to-print` and not `s`? Remember that
    when the code is finally run, `s` and `n-times` are no longer present as symbols.
    `n-times` is present in a way since it is what determined how many `println` calls
    end up in the expanded expression. The `s` parameter from the call to the macro
    needs to live on, not as `string-to-print`, but as the string bound to `string-to-print`.
    In other words, in the preceding target code, `s` is there: it''s `"My own text"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by using some of Clojure''s list-manipulating power to carefully
    build the exact code that we need, that is, a `let` binding containing a sub-list
    of `println` expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll check to make sure it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This time, `s` is not quoted when we bind it to `string-to-print`. When the
    macro is expanded, the value of `s` will be inserted into the list that the macro
    is going to return. Items such as `let` and `string-to-print` are quoted, because
    we don't want their values in the macro expansion; we want them to appear as symbols.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we've had to do some tricky quoting, applying a single quote
    to some items and not to others. This is why we used `list` instead of `'()`.
    The single quote is a shortcut for writing `(quote…)`. `quote` is a special form
    and its effect is to quote everything inside the parentheses, including sub-lists.
    Sometimes, this is exactly what we want, as with `'(println string-to-print)`.
    We need both items in that list to appear as symbols, not as values. `list` simply
    returns a list. By using `list`, we can choose which items should be quoted or
    not.
  prefs: []
  type: TYPE_NORMAL
- en: This is not an optimal quoting solution. Shortly, we'll see that Clojure proposes
    another more sophisticated syntax that makes this easier. The underlying principles
    are the same, however, so it's good to see how the mechanics of quoting work.
  prefs: []
  type: TYPE_NORMAL
- en: There is one more noteworthy (or simply strange) thing in this version of the
    macro. Why are we using `concat` to join the list and the results of the call
    to `repeat`? Previously, we wrapped all the `println` calls inside a `do` expression.
    Now that we have a `let` block, this isn't necessary anymore. At the same time,
    we still need to make sure that the `println` calls aren't wrapped in a list.
    Using `concat` solves the immediate problem but it is not an elegant solution.
    In the next section, the new quoting syntax will make this easier as well.
  prefs: []
  type: TYPE_NORMAL
- en: Syntax Quoting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of the art of writing macros lies in mastering the separation between
    expansion code and output code. A lot of the control over that separation depends
    on deciding what gets quoted when the macro is expanded and what does not get
    quoted. The previous example started to reveal the limits of the standard `quote`
    special form. Once a list has been quoted, all its symbols and sub-lists are `quote`d
    as well. As such, `quote` is a fairly heavy-handed tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, Clojure, like many Lisps, provides a more sophisticated quoting
    mechanism called `''`, the backtick character, instead of the standard single
    quote. When used by itself, the backtick has more or less the same behavior as
    `quote`: all symbols and sub-lists are quoted by default. The difference is that
    syntax quoting allows us to mark certain forms, sub-lists, or symbols that should
    not be quoted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With syntax quoting, we can simplify our macro from the previous section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'How does this work? There are three new things here:'
  prefs: []
  type: TYPE_NORMAL
- en: The `syntax-quote` backtick, in front of the `do` form and the `println` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `~`, the tilde, in front of the `s` symbol
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `~@` in front of the `repeat` form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `syntax-quote` backticks initiate syntax quoting. Then, we can see two
    different ways of preventing quoting on child elements. The simplest of the two
    is the tilde in `''(println ~s)`: the `println` symbol, where the list itself
    will be quoted when the macro is expanded, but `~s` will evaluate to the value
    of `s`. The tilde is called `unquote`. Thanks to `unquote`, we can now insert
    the value of `s` into each `println` call and we no longer need to wrap the entire
    expression in a `let` expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '`~@` is called `unquote-splicing` and does two things at once. Like `unquote`,
    it prevents quoting on the expression it is attached to. Unlike `unquote`, though,
    it only works on lists because its role is to splice the contents of the list
    into the containing list. Before, we had to use `cons` or `concat` to avoid ending
    up with all the `(println "String!")` expressions wrapped inside a list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanded, a call to the new macro looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice a slight difference relative to some of the previous macro expansions:
    the `println` symbols are namespaced! This is an important feature for writing
    robust macros that we will explore shortly when we get to the topic of macro hygiene.
    First, though, let''s practice using our new macro skills.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.01: The and-ors Macro'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the beginning of this chapter, to whet your appetite for macro magic, we
    showed you a macro called `and-ors`. Its purpose was to make it easier to write
    nested Boolean logic when you have lots of expressions with or contained in an
    overarching `and` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this function (hopefully, real code would have more descriptive parameter
    names!):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Logic like this is inherently hard to read, especially when there are lots of
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s suppose that you are writing a library that will contain lots of important
    business logic that is mostly expressed with a long series of Boolean operators,
    as in the preceding function. Anything we can do to make it simpler will help
    the overall readability of your code base. The `and-ors` macro would be a welcome
    improvement. Instead of the nested `or` expressions in the preceding function,
    you could write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an admittedly minor improvement, but it does remove some parentheses
    and generally helps put the accent on the logical expressions themselves. Now,
    we just need to figure out how to make this work:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with a skeleton for `defmacro`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just like with functions, macros can be variadic and accept an unknown number
    of arguments. This is exactly what we need here since we don't know how many `or`
    expressions there will be.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the logic that will split the list of `or-exps` each time there is a
    `|` symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Breaking the list of arguments in `or-exps` into sub-lists is a simple sequence
    operation. There are several ways to do this, including writing a small external
    function. Here, we've chosen to use `partition-by`. Remember, `partition-by` takes
    a function that it uses to decide where to break a list. The list is broken every
    time the function returns a different response. We only care about whether the
    current item is `|` or something else, which is exactly what `(partial = '|)`
    will do. The only trick here is that we need to quote the `|` symbol to make sure
    that we are talking about the symbol itself and not its value. (Which is good,
    since it doesn't have a value.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Splitting on the `|` symbols leaves the symbols as sub-lists. You can try this
    in the REPL if you quote the `|` symbol in the input:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to remove the `(|)` sublist from the results. We''ll use `remove` for
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `|` symbol has now disappeared from our code. It will not be present in
    any way in the compiled code. This is why we don't have to worry about it being
    defined or namespaced. From the point of view of the compiled code, it's like
    it was never there in the first place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we have our `groups` binding, which contains a list of lists.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Prepare to output the outer `and` expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The structure we want to create is that of an `and` expression containing zero
    or more expressions. So first, we need the `and` expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the important thing is the quoting. The backtick in front of `(and…)`
    starts the syntax quoting. This ensures, first of all, that the `(and…)` form
    will be output, and secondly that we will be able to use `splice-insert` to include
    the new `or` expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Convert each sub-list into an `or` expression.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the complete macro:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The call to `map` will return a list. Since we don't want an extra set of parentheses
    inside the `(and…)` expression, we use `insert-splice` here. Inside the anonymous
    mapping function, we need to start syntax quoting again since it was suspended
    by the `~@` in front of `(map…)`. That's why we've put the backtick in front of
    `(or…)`. The same process is more or less repeated since each element in `groups`
    is a list of items to be placed inside an `(or…)` expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test and macroexpand your new macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It seems to work. Let''s try it with nested `and-ors`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Macroexpansion will show us whether we are getting exactly what we originally
    wanted. To avoid expanding the `and` and `or` macros, we''ll use a different version
    of `macroexpand` here, called `macroexpand-1`. The difference between the two
    is that, when a macro expansion contains other macros, `macroexpand` will continue,
    recursively, to expand all of the nested macros, while `macroexpand-1` will stop
    after the first macro. When writing your own macros, `macroexpand-1` is often
    more intuitive because it prevents us from seeing the details of built-in macros,
    such as `let` or, as in this example, `and` or `or`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This exercise shows how even a four-line macro can allow you to introduce what
    could be a useful syntactical improvement. The decision to write a macro such
    as `and-ors` would be based on whether or not it was starting to be painful to
    write all those repetitive Booleans in your code base.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Exercise 11.02: An Automatic HTML Library'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, you will write a macro that, given a list of items, automatically
    creates a function for each item. This can be useful in situations where you need
    a large number of very similar functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in *Chapter 6*, *Recursion and Looping*, you built a library that translated
    Clojure vectors into HTML, using keywords to identify the HTML tags. In that system,
    an HTML element would be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Recently, a co-worker decided to rewrite the library using functions rather
    than vectors. With this new approach, an HTML element would be written as a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Functions can be nested so that developers can write entire HTML pages in their
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, your co-worker left before they could finish the project and
    you've been asked to take over.
  prefs: []
  type: TYPE_NORMAL
- en: You can view what the new library looks like at [https://packt.live/2Gf4bn9](https://packt.live/2Gf4bn9).
  prefs: []
  type: TYPE_NORMAL
- en: As you read through the code, you start to see how the library was supposed
    to work, and also why it was abandoned. You realize that, like your former colleague,
    you don't feel like writing out a separate function for every element in the HTML
    spec! It would be a long, buggy process of copying and pasting hard-to-maintain
    code. Looking closer, you start to suspect that your former colleague had the
    same idea. The last function, `tag-fn`, looks suspiciously like an attempt to
    generalize the approach. It also includes a rather clever use of `mapcat`, similar
    to the wrap-unwrap technique from *Chapter 4*, *Mapping and Filtering*, so that
    a list of items can be spliced into a containing list. Unfortunately, the file
    ends there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `tag-fn` to produce a function for each element seems like a good idea.
    It still means defining a `var` for each kind of HTML element. Your code would
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This is a lot better than typing out all those functions, but it still seems
    too repetitive. Maybe a macro could help?
  prefs: []
  type: TYPE_NORMAL
- en: 'With the right macro, we could just copy a list of elements from the HTML specification,
    wrap them in quotes, and run our macro once while loading the source file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be a series of `def` expressions, just like what we have in
    the preceding code. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a new project directory with an empty `deps.edn`. Copy the `htmlgen.clj`
    file from this book's GitHub repository ([https://packt.live/2Gf4bn9](https://packt.live/2Gf4bn9)).
    You will add your code to the bottom of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, sketch out the code you want to produce. Because we need to be able
    to produce an arbitrary number of functions, our macro will return a list of `def`
    forms. It will be simpler to enclose those forms in a `do` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the skeleton for the macro with syntax quoting applied to the `do` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We give the macro a `[& tags]`. We'll come back to this later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Map over the arguments in `tags` to produce a series of `def` expressions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are several things to note here. Look carefully at what is quoted and
    what is not: the use of `unquote-splice` (`~@`) ensures that the elements returned
    by `map` are the direct children of the `do` expression. Then, with `syntax-quote`
    (`''`), we quote the entire `def` expression, except for what is going to become
    the name of the var we are defining, which we protect from quoting with `unquote`
    (`~`). Finally, the `tag-fn` expression inherits its quoting from the backtick
    in front of `def`. We still need to use `unquote` so that the `tagname` value,
    something like `"h1"`, is inserted rather than just the `tagname` symbol itself.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `symbol` function is needed here because the input is a string. `tag-fn`
    takes a string, but its name needs to be a symbol.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the new macro. Evaluate the macro definition and then use it to define
    some HTML element functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By copying an official list of HTML tags, you can quickly implement the entire
    standard. From inside the `packt-clojure.htmlgen` namespace, you are now able
    to generate HTML elements with your new functions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It works. You've fulfilled the requirements of the assignment and management
    is satisfied… for now, at least.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Automatically producing a large number of functions is a task that macros are
    well adapted for. A macro like this one is little more than a template for a function.
    Macros can do much more, of course, but sometimes, mass-producing simple functions
    is exactly what you need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this exercise, the macro we wrote was variadic. It accepts a variable number
    of arguments and its parameter list looks like this: `[& tag]`. It might be tempting
    to rewrite the macro so that it accepts a list or a vector of tag names. That
    way, we could define our list and then call the macro on it separately. Here''s
    our macro, rewritten to accept a list instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this doesn''t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: At compile time, a symbol such as heading-tags is just a symbol,
    not a list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_11_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.2: At compile time, a symbol such as heading-tags is just a symbol,
    not a list'
  prefs: []
  type: TYPE_NORMAL
- en: The macro fails because, at compile time, `heading-tags` is not a list yet.
    The macro only "sees" a symbol and, just like the error says, it doesn't know
    how to create a sequence from a symbol. The macro code in the exercise needs access
    to the actual tag name at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one reason why `apply` can''t be used on macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: By the time the call to `apply` is made, the code is already running and it's
    too late for the macro to be expanded. For the same reason, a macro cannot be
    passed as an argument to a function such as `map` or `filter`. While macros bring
    great flexibility to a language, there is always a cost to using a macro instead
    of a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.03: Expanding the HTML Library'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your team was impressed with how quickly you implemented all the known HTML
    elements as functions and now, the HTML generating library is becoming more popular
    inside your organization. As often happens with successful libraries, the developers
    using it are starting to run into problems. One of the most common frustrations
    that's expressed by members of your team is that it is awkward to wrap a list
    of elements inside a containing element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a simple example of a common use case: creating an unordered list (`<ul>`)
    by mapping over a list of strings, transforming each string into a list item (`<li>`).
    Thanks to how the original `tag-fn` was written to handle sequences as well as
    strings, the code for creating an HTML list from a vector of items is fairly simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: However, this pattern arises so often in your co-workers' code that they are
    starting to complain that your library forces them to be redundant. "Why," they
    ask, "can't this be simpler? We know that a `ul`, when given a list, will result
    in a `(map li…)` call. Can't that be automatic?"
  prefs: []
  type: TYPE_NORMAL
- en: '"Well," you reply, "of course it can." After some thought, you decide that
    you want your colleagues to be able to write this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'And this won''t just apply to `ul`. `ol->li` would be just as useful. Some
    of the table elements could use the same thing: `table->tr` and `tbody->tr` would
    be quite useful for lists of table rows (`<tr>`), as would `tr->td` for table
    rows (`<tr>`) containing lists of table cells (`<td>`). You decide to write a
    second, specialized macro called `define-html-list-tags` that will take tag name
    pairs and define the corresponding functions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same file as the previous exercise, define a helper function to build
    the new functions. It will be called `subtag-fn` and will be simpler than `tag-fn`
    because it doesn''t need to handle as many different cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The contents of the function should appear relatively familiar. The only new
    piece of code here is `(map subtag content)`. For a function such as `ul→li`,
    the `li` function (which we assume is already defined – make sure `define-html-tags`
    is called first!) is called on each item in the `content` argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the helper function. The helper function will be called at runtime, so
    it is easy to test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note again that this works because the `li` function has already been defined.
    We pass it in as a symbol – `li`, without quotes – and not as a string like `"ul"`.
    The `ul` function won't be defined until after the macro has been run.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'There is one small problem here, however: we can''t optionally pass in a map
    of attributes. This breaks the interface we''ve established for the other functions,
    so we need to fix that before moving on.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a second arity to the anonymous function returned by `subtag-fn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code highlights two interesting features of anonymous functions. First
    of all, they support multiple arities, which makes them just as flexible as their
    `defn` defined counterparts. Secondly, despite being anonymous, they can have
    names. This feature exists in other languages, such as JavaScript, and can be
    useful for debugging purposes. When reading error messages, having a function
    name can be a big help. Naming an anonymous function in Clojure has another advantage,
    in that the function can refer to itself this way. Thus, in the preceding code,
    the single version of the function can fill in the `attrs` argument with `nil`
    and then call the double argument version. This way, we don't have to write the
    function's logic twice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Test the new `subtag-fn`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This works. Now, let''s try the single-argument form:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It still works too!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Write the macro that will define functions such as `ul->li`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As always, the first step in designing a macro is to decide how it should be
    called. A call to this macro should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To understand what is happening here, let''s start from inside the anonymous
    function that''s been passed to `map`. The first line should look familiar:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is exactly the same as in the `define-html-tags` macro from the previous
    exercise. Even though we're going to define `ul->li`, we still need to define
    the `ul` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next line is where we define functions such as `ul->li`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This definition follows the same pattern as in the preceding code, except that
    we use `str` to build the symbol that will be the name of the function and we
    turn the subtag string into a symbol as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Both of these definitions are wrapped in a `do` expression, and the output
    from `map` is, in turn, wrapped in a single `do`. Expanded, it looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the new macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the previous exercise, it may seem inelegant to use nested `do` expressions.
    We would certainly never write code this way by hand! For code produced by a macro,
    however, it really isn't a problem. This doesn't mean that macros should expand
    into convoluted code. Simple is always better. However, most of the time, no human
    will need to read this code. Someone (probably you) might have to read and debug
    the code of your macro, so keeping it as simple as possible will generally be
    worth it, even at the cost of a few extra nested `do` expressions or some other
    repetitive code oddity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could, of course, use `mapcat` to create a flat list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: There is a subtle difference here, in that the syntax-quoting has been moved
    from the containing `(do…)` expression to the `(def…)` expressions themselves.
    At runtime, the vector will no longer exist, so we don't want to quote it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This version produces nicer code when expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Your mileage may vary, but in general, simplifying your macro code is more important
    than producing elegant expansions. The macro is the code you will need to debug.
  prefs: []
  type: TYPE_NORMAL
- en: In this and the previous exercise, we used `def`, along with helper functions
    that built new functions. Nothing prevents you from writing macros that define
    new functions with `defn`.
  prefs: []
  type: TYPE_NORMAL
- en: Macros in ClojureScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The distinction between **compile time** and **runtime** is perhaps the most
    important concept to grasp when learning about macros. Before going further into
    the consequences of this distinction, it's worth looking at how it affects macros
    in ClojureScript, where compilation and execution have a slightly more complex
    relationship than they do in JVM Clojure.
  prefs: []
  type: TYPE_NORMAL
- en: ClojureScript runs in a JavaScript runtime, like the browser or Node.js. This
    is possible because ClojureScript code is first compiled by the ClojureScript
    compiler, which is a program written in Clojure and runs on the JVM. This means
    that ClojureScript programs, once they're compiled and running, no longer have
    access to the compilation phase.
  prefs: []
  type: TYPE_NORMAL
- en: This has several consequences for working with macros in ClojureScript, the
    most important of which is that ClojureScript macros cannot be defined in `.cljs`
    files
  prefs: []
  type: TYPE_NORMAL
- en: alongside other ClojureScript code. Instead, they are defined in separate files
    with either the `.clj` file extension or the cross-compiling `.cljc` extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GitHub repository accompanying this book, there is a minimal `ClojureScript
    project` that illustrates this. It contains two namespaces: `minmacros/core.cljs`
    and `minmacros/macros.cljc`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `minmacros/core.cljs` namespace uses special syntax to require the macros
    in `minmacros/macros.cljc`. Here''s the entire content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the only situation where specifying `:require-macros` is necessary.
    It does not exist in JVM Clojure, only in ClojureScript. If `minmacros/macros.cljc`
    contained functions that we also wanted to import, we would have to require the
    namespace separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that we can use the same namespace alias in both cases. This is because
    the macroexpansion phase is totally separate from the code execution phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see these macros in action, copy the complete `Chapter11/minmacros` directory
    from GitHub ([https://packt.live/2TQHTjQ](https://packt.live/2TQHTjQ)). In your
    Terminal, change to the `minmacros` directory. From there, you can run this from
    the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'If you''re on Windows, you''ll need to download a copy of `cljs.jar` from [https://packt.live/36m0O8q](https://packt.live/36m0O8q).
    Then, assuming that `cljs.jar` is in your working directory, you can run this
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'In your Terminal, the output from `println` should appear before the REPL prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3: Output on the Terminal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_11_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.3: Output on the Terminal'
  prefs: []
  type: TYPE_NORMAL
- en: The second of these, `minmacros/macros.cljc`, is written just like any other
    Clojure namespace. This is, in fact, a requirement, since it will be compiled
    on the JVM. Even if the macros here target a JavaScript *runtime*, the macroexpansion
    code can't contain any JavaScript-specific code. However, the expanded code can
    contain ClojureScript-specific code, since it will be run in the browser or in
    an environment such as Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, using JavaScript''s native string functions inside your macro
    would not work. Consider this (admittedly contrived) example, where we try to
    use the JavaScript string method called `includes` as a test in the macroexpansion
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Java strings do not have an `includes` method, so when we try to invoke this
    macro at the REPL, we get an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The Java-based ClojureScript compiler cannot use a JavaScript string method;
    thus, the macroexpansion fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'While using JavaScript-specific code during macroexpansion is impossible, it
    is perfectly fine to use a macro to create code that will only *run* on a JavaScript
    platform. Here''s an equally contrived macro that does just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'In the REPL, we can define and call a function that returns either `"Found
    it!"` or `"Not here…"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In practice, this kind of issue will rarely arise. It would be extremely rare
    for macroexpansion code to require some kind of help from the underlying platform.
    If you find yourself doing this, on either platform, it's probably a sign that
    you need to rethink what you're trying to accomplish with your macro. The point
    of these examples is to help illustrate how the details of the ClojureScript compilation
    process can be important when writing macros. When writing macros, it's always
    very important to distinguish between compile time and runtime; with ClojureScript,
    the distance between the two is much greater. Once these issues are accounted
    for, though, the actual process of writing macros in ClojureScript is identical
    to writing Clojure macros.
  prefs: []
  type: TYPE_NORMAL
- en: Macro Hygiene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like most programming languages, Clojure provides a lot of resources for avoiding
    name collisions. Namespaces, `let` bindings, and lexical scope, all help to make
    it fairly difficult to override variables by choosing the wrong name. Because
    they operate in a different space, and at a different time, macros have the potential
    to go around some of those guardrails. **Macro hygiene** is the art of writing
    macros that avoid **variable capture**. Variable capture is what happens when
    a symbol produced by a macro coincides with a macro in the surrounding environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The term **variable capture** has its origins in other languages of the Lisp
    family. Unlike Clojure, most Lisps do not have immutable data structures, so the
    word "variable" is perfectly appropriate. We'll continue to say "variable capture,"
    even though most Clojure "variables" aren't really variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick example. Earlier in this chapter, we tried to write a macro
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro didn''t work. It produced this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The reason for this was that the `s` parameter disappears after expansion.
    As a result, `(println s)` fails because, at runtime, there is no `s`. What if
    `s` is already defined, though? We can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Even though there is no syntax error, this really is *wrong*. Depending on the
    context, this macro will not behave the same way. The real argument, "`Right`",
    is obscured by a variable in the environment, "`Wrong`". It's easy to imagine
    how code like this could produce wildly unpredictable results. The macro writer
    has no knowledge of or control over whatever `s` might be bound to in the environment
    where the macro is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Clojure macro system provides some protection against this kind of problem.
    We''ve already seen one of them. The `syntax-quote` backtick causes symbols to
    be assigned to the namespace where the macro is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This provides an initial degree of protection against variable capture since
    a namespaced symbol can't be confused with core Clojure functions or with local
    `let` bindings. The `let` macro, in fact, won't allow a namespaced symbol to be
    used as a binding.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When looking at the expansion of a macro you are working on, if you see symbols
    that have been assigned to the current namespace, it's probably a sign that those
    symbols are vulnerable to variable capture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try a slightly more realistic example. Here''s a macro that defines
    a `let`-like environment where the `body` parameter can be evaluated. This is
    a common structure for macros, where the macro sets up and possibly tears down
    a specialized environment. The environment might be a database connection, an
    open file or, like in this example, just a series of bindings that make it easier
    to write your code. This macro will take an integer and symbol and then provide
    an environment with automatic bindings for the integer as a string, as an integer,
    and as a Java `double`. The symbol parameter is then used to define the `-as-string`,
    `-as-int`, and `-as-double` bindings, which can be used in the code provided as
    the `body`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'In a simple case, the `let-int` macro could be used like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: This result just shows that `my-int-as-string` is indeed defined and that the
    integer `5` has been coerced into a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look what happens, though, when one of the internal bindings is already defined
    and is used in the macro parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Even when working with macros, 1,000 divided by 2 should be 500 and not 250!
    What happened? The problem here is that with a macro, the `(/ my-int-as-int 2)`
    parameter is not evaluated before being passed to the macro. The macro doesn''t
    "know" about the value 500\. It only "sees" the code that is present at compile
    time. The expanded version of this macro call provides a better view of what is
    happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to notice is that `(/ my-int-as-int 2)` appears three times.
    When `my-int-as-double` is defined, the local binding, `my-int-as-int`, supersedes
    the original binding. If the original binding was 1,000, the local `my-int-as-int`
    is defined as 500\. When `my-int-as-double` is defined, `my-int-as-int` becomes
    500, which is then divided by two one more time.
  prefs: []
  type: TYPE_NORMAL
- en: This is a subtle variable capture bug that could have disastrous consequences.
    Most of the time, everything would work correctly. Then, from time to time, the
    results would be inexplicably incorrect. Staring for hours at the source code
    would not help since the actual bug is only visible when the code is expanded.
    While it may seem like a strange edge case, a bug like this could actually occur
    fairly easily with nested `let-number` macros.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding Variable Capture with Automatic Gensyms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Luckily, there is a solution for a macro such as `let-number`, which is to
    evaluate the argument only once and then store the result in a local binding that
    can then be used for further calculations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In the first line of the `let` bindings, the calculation represented by `n`
    is performed and bound to `result#`. All of the following bindings then use `result#`
    to produce their particular versions: `string`, `integer`, `double`. This is a
    very good habit to have when writing macros: avoid calculating things twice.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make sure this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: That's better. The `(/ my-int-as-int 2)` expression is only evaluated once and
    the result is correct now. Multiple evaluations of code inside a macro could have
    other unintended consequences if the repeated code has side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one remaining question, though: why do we write `result#` instead
    of just `result`? This is an example of Clojure''s macro system helping us avoid
    other kinds of errors. The suffix on the `result` symbol has a special meaning
    when it''s used in a syntax-quoted expression. In those cases, Clojure''s syntax
    quoting transforms `result` into what is called a `let-number` macro, you won''t
    see a binding to a symbol named `result` or even `result#`. Instead, there will
    be something like `result__15090__auto__`. That''s a generated, unique symbol.
    Gensyms are a key component in Clojure''s macro system because, when used effectively,
    they prevent name collisions between symbols that have been produced by a macro
    and symbols present in the environment where the macro is called, or in code that
    is a macro argument. In the REPL, you can produce your own gensyms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Each time, a different symbol is produced, unless the symbols are in the same
    syntax-quoted expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: This is what allows gensyms to be used to refer to the same thing. It can also
    be a limitation since, often, you need to use more than one syntax-quoted expression
    inside a macro. We'll show you how to deal with those cases a little later.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the importance of this, imagine a version of `let-number` where
    the result of `n` was assigned to `result` without the `#` suffix. Because of
    this, the `result` binding would be available inside the code in the `body` parameter.
    Most of the time, this would not be a problem, as long as the `body` code did
    not use a value named `result`. If there was a collision, though, the direct consequence
    would be a very nasty bug.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this use of the macro while using `result` without the protection afforded
    by the `#` suffix. To do that, we need to insert the literal result symbol into
    the expanded code. This will require using a little macro trick where we unquote
    and then quote the symbol, like this `~'result`. The initial unquote suspends
    the syntax quoting and then the single quotation mark applies a standard quote
    that does not use namespacing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The unquote-quote pattern should generally be avoided because gensyms are much
    safer. However, a simple quoted symbol can be useful in certain cases, especially
    when a symbol is supposed to have a special syntactical meaning inside the macro,
    as we saw with the `|` in *Exercise 11.01*, *The and-ors Macro*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We get the following macro code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this macro could be dangerous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: This would be extremely confusing. We expect the `result` in the initial `let`
    binding to be the same as the `result` in the `let-number` binding. Debugging
    this error would require exploring the inner workings of the macro and would probably
    be a long, painful process. Gensyms protect against this kind of problem and Clojure
    makes them easy to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all Lisps have automatic gensyms. In Common Lisp, macro writers have to
    call the `gensym` function explicitly. Clojure also has a `gensym` function, which
    can be used to create gensyms outside of a syntax-quoted environment. We'll use
    the `gensym` function ourselves a little later
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, any bindings in a macro that are not part of the exposed
    interface should be defined with gensyms. In the `let-number` macro, bindings
    such as `my-int-as-string` are an exposed part of the interface and, as such,
    require real symbol names. Bindings such as `result#`, which only are used "behind
    the scenes" (at compile time), should be protected with gensyms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 11.04: Monitoring Functions'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will write a macro for creating functions. The functions
    will be wrapped inside logic that adds some extra behavior to an otherwise ordinary
    function.
  prefs: []
  type: TYPE_NORMAL
- en: These days, you're working for a company that provides Software as a Service
    to other companies. Management wants to rethink the prices that are charged to
    customers. They want to know, at a very fine-grained level, which services are
    the most expensive to provide and which customers are consuming the most resources.
  prefs: []
  type: TYPE_NORMAL
- en: Your job is to develop a system for logging the computation time of some of
    the important, high-level functions in the code base. At first, you thought that
    you would have to go through the entire code base and add timing and reporting
    logic every time one of these high-level functions is called. Then, you remembered
    macros. You've decided to write a proof-of-concept macro to show to your boss.
  prefs: []
  type: TYPE_NORMAL
- en: The high-level functions you want to measure all have, among others, a `client-id`
    parameter. You'll use that parameter to provide feedback to the monitoring framework.
    One requirement is that the data will be sent, even if an exception is thrown.
    Collecting detailed error statistics will be useful for monitoring and diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: 'The macro will be invoked instead of `defn` when defining the functions. In
    addition to the standard arguments to `defn`, the macro will also take a function
    that will be called to send data to the monitoring system. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a REPL, set up an outline for the macro:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This means that, when defining a function that needs to be monitored, we''ll
    write something like this, assuming that `send-to-framework` is a function that
    has already been defined:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Calling the function will be no different from calling any other function,
    as long as there is a `client-id` argument:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Establish the basic layout of the macro''s internals. There will be two parts:
    on the outside, some compile-time `let` bindings, and on the inside, a syntax-quoted
    `(defn…)` expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The outer `let` bindings will set up some of the values that will be used in
    the more "template"-like `defn` part.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ve placed the `fn-name`, unquoted, and an empty parameter list inside the
    call to `defn`. Even if it doesn''t do anything yet, the macro should already
    compile, and you should be able to use it to define a function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you already know, the Clojure `defn` macro allows us to define multiple
    arities for the same function. This really means that there are two different
    structures that a function definition can have. First there is the single arity
    that we use most of the time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Multiple arity functions have several "bodies." Each "body" is a list that
    starts out with the argument list, which is specific to that arity, and then includes
    the corresponding code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because we want `defmonitored` to act as a replacement for `defn`, we need to
    be able to handle these two different structures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Much of what we are going to do now requires us to have access to the code inside
    each of the function bodies, if there are multiple arities. To avoid having to
    deal with two separate cases, that is, single and multiple arities, we are going
    to check to see which kind we have. If we have just one arity, we will wrap the
    argument list and the function body in a list so that it has the same structure
    as the multiple arity variety.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A function like this is correct, even if it only has one arity:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To do this, we add a `vector?` check:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the first item in `fn-content` is an argument list, we use syntax quoting,
    and then `unquote`, to enclose the function body in a list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To handle the multiple arities, we need to deal with each function body separately.
    This sounds like a good time to write a function that can be called on each one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We'll call the `wrap-fn-body` function to deal with this. Even though this is
    a function and not a macro, it will be called at compile time, so all our macro-writing
    skills are still applicable here.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The function will repeat the basic structure of the macro: `let` bindings on
    the outside and a syntax-quoted "template" on the inside. This time, we''ll start
    with the bindings:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We know that the first item in a function body is the argument list. That's
    easy to extract, just like `fn-body`, which is everything that's not the argument
    list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a check for the `client-id` parameter in the argument list. Our goal is
    to be able to measure function use per client, so we absolutely need a `client-id`
    argument. If it''s missing, the code should fail. To do this, we''ll simply check
    the `arg-list` binding:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can safely use the "unquote/quote" pattern here on the `client-id` symbol,
    rather than a gensym, because we know the `client-id` will not be picked up accidentally
    from the surrounding code, precisely because it will be in the argument list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'It''s finally time to write the "template" part. This is a longer block of
    code, but it is really quite simple. We''ll come back and explain some of the
    quoting strategies here later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The overall pattern is fairly simple. The heart of the function is in the inner
    `let` binding, where, in the expanded code, we will bind the `result#` gensym
    to the output resulting from calling the actual code, which is still in `fn-body`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once we have that result, we send off some information to `tx-fn` by using `System/nanoTime`
    as our `:end-time`. This "heart" of the function is then wrapped in two things,
    the first of which is a `try`/`catch` form. If there's an exception, we send a
    slightly different message via `tx-fn`. And finally, the outer `let` binding is
    where we establish the `start-time#` binding so that we can also report when the
    function started.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that we were required to use several automatic gensyms: `start-time#`,
    `end-time#`, `results#`, and even `e#`, the exception.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Put it all back together.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here''s the complete `wrap-fn-body` function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, call `wrap-fn-body` from the final `defmonitored` macro. You can do this
    by mapping over the list of function bodies. Naturally, `map` will wrap them in
    a list, which we don''t want, so we "unquote-splice" (`~@`) the list:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test the macro, using `println` as the reporting function. First, define a
    simple function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `my-func` function seems to work:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s try some problematic cases. We''ll start by throwing an exception:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 11.4: An exception, timed, recorded, and reported'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_11_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.4: An exception, timed, recorded, and reported'
  prefs: []
  type: TYPE_NORMAL
- en: What about if we try to define a function that doesn't have a `client-id` argument?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5: The exception we threw during macroexpansion appears as a syntax
    error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_11_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.5: The exception we threw during macroexpansion appears as a syntax
    error'
  prefs: []
  type: TYPE_NORMAL
- en: The `defmonitored` macro shows how macros can be used to modify Clojure itself.
    The situation called for a `defn` with extra capabilities, so that is what we
    wrote. It would, of course, be possible to accomplish the same thing by wrapping
    functions inside a "timing and reporting" function. But this would be much more
    intrusive than simply writing `defmonitored` instead of `defn`.
  prefs: []
  type: TYPE_NORMAL
- en: When to Use Manual gensyms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using Clojure''s automatic gensyms, such as `result#`, it''s important
    to remember that they are a feature of syntax quoting. Writing `result#` outside
    of a syntax-quoted expression won''t throw an exception, but none of the magic
    happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, if we syntax-quote `my-number#`, the "magic" comes back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'This will usually not be a problem. It''s easy to remember that automatic gensyms
    only work inside syntax quoting. There is another important thing to remember,
    though: an automatic gensym is only valid inside the scope of the syntax-quoted
    expression where it was originally defined. This means that, with nested syntax-quoted
    expressions, a `result#` in the outer expression will not expand to the same gensym
    as a `result#` in the inner expression. Let''s try an example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this little macro:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'This macro is supposed to allow us to define multiple functions inside a `let`
    block so that each function refers, via a **closure**, to the same binding. We
    want it to produce code that, conceptually, at least, looks roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'To define those functions, we would write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The `symbol-fn-pairs` argument is expected to be an alternating series of symbols
    that will become the names of the functions, and some will become functions as
    well. We then use `partition-by` in the body of the macro to organize this list
    into pairs. (In production code, we would probably want to check that `symbol-fn-pairs`
    contains an even number of items, just as `let` complains if there is an odd number
    of items in its bindings.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if this macro works as advertised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Oh no! What happened?
  prefs: []
  type: TYPE_NORMAL
- en: Before we use `macroexpand` to start debugging, we can tell that the problem
    is related in some way to the `v#` binding because the `v__14896__auto__` gensym
    is prefixed with a `v`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Macro expansions are hard to read, especially when there are a lot of gensyms,
    which are, let''s face it, hardly things of beauty when expanded. Start by trying
    to find the symbol mentioned in the syntax error message. We''ll use `macroexpand-1`
    here, to avoid expanding the `let` and `defn` macros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that, in the initial `let` binding, `v#` becomes `v__14897__auto__`.
    Later, inside each of the function definitions, we want to use that binding, but
    unfortunately, in each of the functions, `v#` has been replaced with a slightly
    different gensym, which is `v__14896__auto__`. Suddenly, the syntax error makes
    more sense: in each function, we''re trying to use a non-existent binding.'
  prefs: []
  type: TYPE_NORMAL
- en: Why did `v#` fail in this case? The problem here is that we have two separate
    syntax-quoted expressions. The first is the top-level `let`, where `v#` is used
    initially. Then, we use `unquote-splice` to splice the list of functions into
    the `let` expression. Inside the anonymous function that's passed to `map`, we
    use the syntax-quoting backtick one more time to return the `defn` form. And this
    is where we get into trouble. Because we are no longer in the same syntax-quoted
    expression, `v#` does not expand to the same gensym. As a result, the two symbols
    are treated as totally separate values and we get a syntax error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a time when we can''t use automatic gensyms. Instead, we''ll have to
    do this the old-fashioned way and use the `gensym` function ourselves. Here''s
    how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: The primary difference here is that we've wrapped the body of the first version
    of the macro in a separate `let` expression that is not quoted. This means that
    it will be present at compile time but will disappear at runtime in the expanded
    code. In this outer `let` expression, we call `gensym` and assign its value to
    `common-val-gensym`. At compile time, we'll refer to the gensym with this symbol.
    Because our `let` expression wraps the entire body of the macro, `common-val-gensym`
    will have the same value throughout the entire macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Any reasonably complex macro will likely have more than one syntax-quoted expression,
    so knowing when to manually create and assign gensyms can be important. This knowledge
    can help avoid some hard-to-debug situations where your code looks correct but
    just doesn't work.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a side note, the `fn-context` macro could easily be replaced with a functional
    solution by using the `partial` function. Remember, `partial` takes a function
    and one or more arguments and returns a function identical to the original, except
    that the first one or more arguments are already "filled in." Thus, instead of
    using a macro and `defn` forms, we can simply define new functions using `def`
    and `partial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'The possibilities offered by functional programming in Clojure are such that
    it is fairly rare to find a problem, in day-to-day coding, that can only be expressed
    as a macro. Authors of libraries will tend to use macros slightly more often,
    for those times when it is important to have a very clear interface for some code.
    Perhaps the greatest advantage of Clojure macros is that most of the time, we
    don''t need to write them: either library authors have already done so or there
    is a solution on the functional side. And then, of course, if we really must write
    a macro, Clojure provides some excellent tools for doing so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ve taken a close look at several of the most common traps
    in macro writing. By taking these into consideration, you should be able to write
    effective macros. They should also serve as a reminder of why macros should be
    avoided when it is convenient to do so: writing and debugging macros can be a
    difficult and error-prone task. In the right circumstances, macros can be an extremely
    powerful tool for removing boilerplate and other forms of repetition from source
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 11.01: A Tennis CSV Macro'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In some of the earlier chapters, we worked with tennis data contained in CSV
    files. Each time, we used a standard Clojure macro called `with-open`, and each
    time, we followed an almost identical pattern where the file''s contents are threaded
    (with the `->>` macro) through a series of transformations:'
  prefs: []
  type: TYPE_NORMAL
- en: Read the contents using the `clojure.data.csv` library's `read-csv` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transform each line from the input file into a map using the `semantic-csv`
    library's `mappify` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cast some of the fields to numeric values using `semantic-csv`'s `cast-with`
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove some of the unnecessary data fields by using `map` to call `select-keys`
    on each item in the dataset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: End with a call to `doall` to make sure we avoid returning a lazy sequence that
    would not be able to be completed once the file had been closed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each of these steps added some repetitious boilerplate to your code. The result
    is that each time you want to write a function that analyzes one of these CSV
    files, you end up repeating the same code over and over again, which is tedious
    and error-prone to write, and hard to read because the important logic in your
    code is buried in boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the success of the tennis data on the data-driven sports journalism website
    you work for, you now write a lot of functions with this identical pattern. You've
    decided it's time to make your life easier by cleaning up this code with a nice
    macro called `with-tennis-csv`.
  prefs: []
  type: TYPE_NORMAL
- en: Your goal is to write a macro called `with-tennis-csv` that will encapsulate
    most or all of the repetitive steps for accessing the CSV data.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The macro should accept the following as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The CSV filename (a string).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mappings from field names to types for `cast-with` (a map of keywords to
    functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of keywords to keep. If an empty list is supplied, all the keywords will
    be kept.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An arbitrary number of Clojure forms. These forms must accept and return a list
    of maps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Clojure forms will be inserted in the middle of the `->>` chain of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6: Inserting the Clojure form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_11_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 11.6: Inserting the Clojure form'
  prefs: []
  type: TYPE_NORMAL
- en: The macro caller will supply the forms that will be placed inside the chain
    of transformations.
  prefs: []
  type: TYPE_NORMAL
- en: Because the Clojure forms will be used inside a double-arrow threading macro,
    `->>` their final argument must be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `blowout` function illustrates a possible use of the macro you
    want to write. The function takes a CSV file path and a threshold and then returns
    a list of matches where the winner won by more than `threshold` games. The results
    are narrowed to three fields: the names of the two players and the number of games
    by which the winner defeated the loser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The central challenge here is making sure that the forms are correctly inserted
    into the `->>` threading macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that none of the arguments are evaluated more than once inside the
    macro:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by determining what the call to `with-tennis-csv` should expand to in
    the preceding example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up your project with the necessary dependencies in a `deps.edn` file and
    require the necessary libraries in a `tennis-macro` namespace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Determine what the arguments to your macro will be. Don't forget that it should
    accept an arbitrary number of forms to be threaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In your macro, as a syntax-quoted "template," insert all the parts of the target
    code that will always be present, no matter how the macro is called.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Insert the expressions to be threaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find a way to only apply `select-keys` if keys have been supplied and can be
    selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To test your macro, you can use the CSV files we''ve been using all along:
    [https://packt.live/2Rn7PSx](https://packt.live/2Rn7PSx).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 733.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've explored Clojure's macro system, as well as many of the
    issues surrounding macros. By now, you should have a grasp of the fundamental
    concepts of macros, starting with the difference between compile-time and runtime
    evaluation, and have a mental model that will allow you to move on to writing
    your own macros if necessary, or to understand macros that have been written by
    others. The problems of macro hygiene, variable capture, and double evaluation
    are at the heart of the macro writing process. Knowing all of this will help you
    write macros, read macros, and, most of all, decide when to write a macro and
    when not to.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of whether or not you go on to use macros to write your own **Domain-Specific
    Languages** (**DSL**) in Clojure, you'll already benefit from Clojure macros.
    The flexibility they provide allows Clojure to be extended by library authors
    in ways that would simply be impossible without macros. Many commonly used Clojure
    libraries, such as the Ring HTTP server, which you'll learn about in *Chapter
    14*, *HTTP with Ring*, make extensive use of macros to make life simpler for developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we are going to explore another one of Clojure''s strong
    points: dealing with concurrency.'
  prefs: []
  type: TYPE_NORMAL
