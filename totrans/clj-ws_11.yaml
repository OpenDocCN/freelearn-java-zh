- en: 11\. Macros
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 11. 宏
- en: Learning objectives
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 学习目标
- en: 'In this chapter, you will learn how Clojure macros work and how to write them.
    Macros are a very powerful feature of Clojure that simply does not exist in many
    other non-Lisp languages. Writing macros requires learning some new concepts and
    some new skills. This chapter will take you through the basic concepts: distinguishing
    between compile-time and run-time execution, quoting strategies and macro hygiene.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习Clojure宏的工作原理以及如何编写它们。宏是Clojure的一个非常强大的特性，在许多其他非Lisp语言中根本不存在。编写宏需要学习一些新的概念和一些新的技能。本章将带你了解基本概念：区分编译时和运行时执行、引用策略和宏卫生。
- en: By the end of this chapter, you will be able to automatically generate functions
    and craft custom environments to streamline your code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够自动生成函数并创建自定义环境以简化你的代码。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: '**Macros** have been a distinctive feature of Lisps for decades. They are sometimes
    presented as a superpower native to the world of Lisp. While macros do exist in
    other languages, for many decades, Lisps have had the most complete macro systems.
    Why is this? Languages from the Lisp family share the ability to write code that
    modifies itself. People often talk about "code as data": Lisp programs, with their
    nested sets of parentheses called **s-expressions**, are in fact lists. And Lisps,
    as languages, are good at manipulating lists. The name "Lisp" originally came
    from "LISt Processor" when the language was first invented in 1958\. As a result,
    Lisps can be made to operate on the code of Lisp programs. Usually, this means
    that a program modifies its own code.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**宏**是Lisp几十年来的一大特色。它们有时被描绘为Lisp世界的一种超级能力。虽然其他语言中也有宏，但几十年来，Lisp拥有最完整的宏系统。为什么是这样？Lisp家族的语言共享编写修改自身代码的能力。人们经常谈论“代码即数据”：Lisp程序，其嵌套的括号称为**s表达式**，实际上就是列表。作为语言，Lisp擅长操作列表。Lisp这个名字最初来自“LISt
    Processor”，当这种语言在1958年首次发明时。因此，Lisp可以操作Lisp程序的代码。通常，这意味着程序修改了自己的代码。'
- en: Note
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term **homoiconicity** is often applied to Lisps. While the exact meaning
    of this term depends on who is talking, it generally means that Lisps are written
    in forms that they can manipulate themselves and that these same structures are
    more or less mirrored inside the Lisp interpreter or compiler.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 术语**同构性**通常应用于Lisp语言。虽然这个术语的确切含义取决于说话者是谁，但通常意味着Lisp是用它们可以自己操作的形式编写的，并且这些相同的结构在Lisp解释器或编译器内部或多或少是镜像的。
- en: 'Sometimes, this is called **metaprogramming**: writing a program that will
    write your program for you. If that sounds too good to be true, it''s because
    it is. Macros can''t do everything for you, of course. They can write parts of
    your program, though, and make your code easier to write by removing some of the
    boilerplate and other forms of repetition, or by transforming the language''s
    syntax to better fit the problem at hand.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，这被称为**元编程**：编写一个将为你编写程序的程序。如果这听起来太好了而不真实，那是因为它确实如此。当然，宏不能为你做所有事情。不过，它们可以编写你的程序的一部分，通过移除一些样板代码和其他重复形式，或者通过变换语言的语法以更好地适应手头的任务，使你的代码更容易编写。
- en: 'Has this ever happened to you? You''re working on a large project and you find
    yourself writing function after function, method after method, and they are almost
    identical. You know the DRY principle: *Don''t Repeat Yourself*. "Maybe I''m missing
    an abstraction here, maybe I could simplify this," you think to yourself. Yet
    when you try, there is always *one* piece of code that needs to be different and
    can''t be abstracted away. It might be some conditional logic that is different
    each time. So, you give up on a cleaner solution and keep typing away. Macros
    might have helped.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否曾经发生在你身上？你正在处理一个大项目，你发现自己一个接一个地编写函数和方法，它们几乎完全相同。你知道DRY原则：*不要重复自己*。“也许我这里缺少一个抽象，也许我可以简化这个，”你对自己想。“然而，当你尝试时，总是有*一个*需要不同且不能抽象掉的代码片段。这可能是每次都不同的条件逻辑。所以，你放弃了更干净的解决方案，继续敲击键盘。宏可能有所帮助。”
- en: 'Here''s a slightly more concrete scenario. You''re writing code with a lot
    of Boolean logic. After a few days, it starts to feel as though just about every
    function in your code base has a few of these:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个稍微更具体的场景。你正在编写包含大量布尔逻辑的代码。几天后，你感觉你的代码库中的几乎每个函数都有几个这样的：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The logic is slightly different each time, so you can't write a function, yet
    the logic is so similar each time that you feel like you're constantly repeating
    yourself. What if you could just write this instead?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每次逻辑都略有不同，因此你不能编写一个函数，然而每次逻辑都如此相似，以至于你感觉自己在不断地重复自己。如果你可以只写这个会怎么样呢？
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Well, you can. With a macro.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，你可以。使用宏。
- en: This eliminates one level of nested parentheses, so it's easier to type. It
    might even be easier to read.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这消除了嵌套括号的一层，因此更容易输入。甚至可能更容易阅读。
- en: There are a couple of reasons this would be impossible with a function. The
    most important reason is that a macro such as `and-ors` preserves the "short-circuiting"
    property of `and` (which is a macro itself). As soon as one of the conditions
    fails, evaluation stops and the remaining conditions are ignored, with possible
    performance benefits, or to avoid possible side effects. The other reason is that
    we're able to use `|` as a separation symbol without having to define it before
    using the macro. It's like being able to define our own language operators.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因使得这在使用函数时变得不可能。最重要的原因是像`and-ors`这样的宏保留了`and`（它本身也是一个宏）的“短路”属性。一旦某个条件失败，评估就会停止，剩余的条件将被忽略，这可能会带来性能上的好处，或者避免可能的副作用。另一个原因是，我们能够在使用宏之前不需要定义`|`作为分隔符号。这就像能够定义我们自己的语言运算符一样。
- en: This kind of "magic" is possible because macros are executed before your code
    is compiled. Their purpose is to transform your source code before it goes to
    the compiler. If this sounds complicated and confusing, well, sometimes, it is.
    By building on concrete examples, however, you'll quickly realize that though
    macros aren't magical, they can be useful. And though they can be very complex,
    they don't always have to be. Understanding how they work will also help you avoid
    using them when they are not the best solution.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“魔法”之所以可能，是因为宏是在你的代码编译之前执行的。它们的目的是在代码传递给编译器之前对其进行转换。如果这听起来复杂且令人困惑，那么，有时确实如此。然而，通过构建具体的例子，你很快就会意识到，尽管宏不是魔法的，但它们是有用的。而且，尽管它们可能非常复杂，但并不总是必须如此。了解它们的工作原理也将帮助你避免在不应该是最佳解决方案时使用它们。
- en: Clojure provides a modern macro system that is largely based on – and improves
    – the Common Lisp macro system, and as such, it is an extremely powerful tool.
    In spite of this power, Clojure programmers generally write far fewer macros than
    Common Lisp programmers, or Scheme or Racket programmers. The reasons for this
    are probably varied. Most books about macros, in any Lisp, start out by warning
    that macros should only be used when you're absolutely sure that a function will
    not work. Often, Clojure's functional programming is useful and powerful enough
    that writing a macro isn't really necessary.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure提供了一个基于——并改进了——Common Lisp宏系统的现代宏系统，因此它是一个非常强大的工具。尽管如此，Clojure程序员通常编写的宏比Common
    Lisp、Scheme或Racket程序员要少得多。原因可能多种多样。任何关于宏的书籍，在任何Lisp中，通常都会首先警告说，只有在你绝对确定一个函数不会工作的时候才应该使用宏。通常，Clojure的函数式编程足够有用和强大，以至于编写宏实际上并不是必需的。
- en: Sometimes, though, a macro can be the best solution to a problem or can help
    simplify code that would otherwise be complicated and/or repetitive. Learning
    to write macros is also a rite of passage for any self-respecting Clojure programmer.
    So, let's go!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，尽管如此，宏可能是解决问题的最佳解决方案，或者可以帮助简化原本可能复杂和/或重复的代码。学习编写宏也是任何自重的Clojure程序员必经的仪式。那么，让我们开始吧！
- en: What is a Macro?
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是宏？
- en: 'A macro is a piece of code that is executed before your code is compiled. The
    code contained inside a macro call is transformed into something different and
    then passed on to the compiler. In Clojure, macros are defined by calling `defmacro`.
    A call to `defmacro` looks fairly similar to a call to `defn`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 宏是在你的代码编译之前执行的一段代码。宏调用中包含的代码被转换成不同的东西，然后传递给编译器。在Clojure中，宏是通过调用`defmacro`来定义的。对`defmacro`的调用看起来与对`defn`的调用相当相似：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Despite this apparent similarity, there is a huge difference between macros
    and functions. Unlike functions, macros are not called at runtime. When your program
    finally starts running, the macros have already been called. The code they produce
    has already been included in your program *as if you had typed it in yourself*:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管表面上看起来相似，但宏和函数之间存在着巨大的差异。与函数不同，宏不是在运行时被调用的。当你的程序最终开始运行时，宏已经被调用。它们产生的代码已经包含在你的程序中，*就像你亲自输入一样*：
- en: '![Figure 11.1: Separating compile time from runtime is the key to understanding
    macros'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1：将编译时与运行时分开是理解宏的关键'
- en: '](img/B14502_11_01.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_11_01.jpg]'
- en: 'Figure 11.1: Separating compile time from runtime is the key to understanding
    macros'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：将编译时与运行时分开是理解宏的关键
- en: 'Keep this idea in mind while you think about and work with macros: any macro
    in your code could, in principle, be replaced by code that you type out yourself.
    Some macros are very complex and it would be extremely difficult and painstaking
    to replace them with hand-written code, but with enough time, patience, and expertise,
    it would theoretically be possible. Just as you write your code before you run
    it, macros are expanded before your code is run.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你思考和使用宏时，请记住这个想法：你代码中的任何宏原则上都可以被你自己输入的代码所替换。有些宏非常复杂，用手工代码替换它们会非常困难且耗时，但只要有足够的时间、耐心和专业知识，理论上是可以做到的。就像你在运行代码之前先写代码一样，宏在代码运行之前会被展开。
- en: A Very Minimal Macro
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个非常简单的宏
- en: 'Let''s start with a very simple, and not very useful, macro:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个非常简单且不太有用的宏开始：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This looks a lot like a function definition. We could just as easily write
    this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很像一个函数定义。我们也可以这样写：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run both of these at the REPL, the results are also identical:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 REPL 中运行这两个，结果也是相同的：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There is only one meaningful difference between these two definitions, and it
    is a very small one. Do you see it? It's the `'`, which is shorthand for the `quote`
    special form. Despite its small size, it makes a huge difference.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个定义之间只有一个有意义的区别，而且这个区别非常小。你看到它了吗？是那个 `'`，它是 `quote` 特殊形式的缩写。尽管它很小，但它产生了巨大的影响。
- en: When we run `minimal-function`, the Clojure runtime simply executes the call
    to `println`. When we run `minimal-macro`, the macro actually inserts the `(println
    "I'm trapped inside a macro!")` statement into your source code before the Clojure
    runtime reads it. To be more precise, we say that Clojure **expands** the macro.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行 `minimal-function` 时，Clojure 运行时只是简单地执行对 `println` 的调用。当我们运行 `minimal-macro`
    时，宏实际上在 Clojure 运行时读取源代码之前，将 `(println "I'm trapped inside a macro!")` 语句插入到你的源代码中。更准确地说，我们说
    Clojure **展开**了宏。
- en: The best way to appreciate the difference between `minimal-macro` and `minimal-function`
    is to use Clojure's `macroexpand` function, which translates a call to a macro
    into actual code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的方法是通过使用 Clojure 的 `macroexpand` 函数来欣赏 `minimal-macro` 和 `minimal-function`
    之间的区别，这个函数将宏调用转换成实际的代码。
- en: 'Here''s the result of calling `macroexpand` on a call to `minimal-function`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是调用 `macroexpand` 在 `minimal-function` 调用上的结果：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This seems a little redundant, and for good reason: `(minimal-function)` is
    not a macro, and so only expands into itself.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来有点多余，而且有很好的理由：`(minimal-function)` 不是一个宏，所以它只会展开成它自己。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When calling `macroexpand`, it's important to quote the form you are expanding.
    Otherwise, `macroexpand` will try to expand the results of the call to `minimal-function`.
    Because `println` returns `nil`, the result would be `nil`, and there would be
    nothing to expand. Whenever you get surprising results from `macroexpand`, make
    sure that you haven't forgotten to quote the macro.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `macroexpand` 时，引用你正在展开的表式非常重要。否则，`macroexpand` 将尝试展开对 `minimal-function`
    的调用。因为 `println` 返回 `nil`，所以结果将是 `nil`，也就没有东西可以展开。每次当你从 `macroexpand` 得到令人惊讶的结果时，确保你没有忘记引用宏。
- en: 'Expanding `(minimal-macro)` is quite different, though:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 展开 `(minimal-macro)` 的过程相当不同：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When we type `(minimal-macro)` at the REPL, it is expanded into the `println`
    expression, exactly as if you had typed it out yourself. Notice that the expanded
    form is no longer quoted. (As you're probably starting to guess, quoting is an
    important part of macro writing.)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 REPL 中输入 `(minimal-macro)` 时，它会被展开成 `println` 表达式，就像你亲自输入一样。注意，展开后的形式不再被引用。（正如你可能开始猜测的那样，引用是宏编写的一个重要部分。）
- en: Compile Time and Run Time
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编译时与运行时
- en: 'To see the importance of quoting, let''s try writing a macro without the `''`
    at the beginning:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到引用的重要性，让我们尝试编写一个不带开头的 `'` 的宏：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Calling this macro in the REPL yields the same results:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中调用这个宏会产生相同的结果：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What''s wrong with that? `mistaken-macro` seems to work just as well as the
    others… Or does it? Let''s try expanding it:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么问题？`mistaken-macro` 似乎和其他宏一样好使……或者不是吗？让我们尝试展开它：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That's strange! The output is the same as when we call the macro directly, yet
    it is totally different from both `minimal-function`, which just expanded to itself,
    and `minimal-macro`, which expanded into the `println` expression. So, what is
    really going on here? And why did removing the `quote` apostrophe make such a
    difference?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这很奇怪！输出与直接调用宏时的输出相同，但它与 `minimal-function`（它只是展开成自身）和 `minimal-macro`（它展开成 `println`
    表达式）都完全不同。那么，这里到底发生了什么？为什么移除 `quote` 引号会有如此大的差异？
- en: 'The fact that calling `(mistaken-macro)` produces the same output as the other
    forms could almost be called a coincidence. The call to `println` happens, but
    it happens at compile time. And because `println` returns nil, `(mistaken-macro)`
    expands to exactly that: `nil`. This is also why we see the `"I''m trapped…"`
    message when we call `macroexpand`: that message is a side effect of the macro
    expansion!'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `(mistaken-macro)` 产生与其它形式相同的输出几乎可以称为巧合。`println` 的调用发生了，但它发生在编译时。由于 `println`
    返回 `nil`，`(mistaken-macro)` 展开成正好是 `nil`。这也是为什么我们在调用 `macroexpand` 时看到 `"I'm trapped…"`
    消息的原因：那条消息是宏展开的副作用！
- en: The difference between `minimal-macro` and `mistaken-macro` is that the former,
    by quoting the form, actually returns a `println` symbol and the message string.
    `mistaken-macro`, on the other hand, expands to `nil` because it calls `println`
    immediately, at expansion time.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`minimal-macro` 和 `mistaken-macro` 之间的区别在于前者通过引用形式实际上返回了一个 `println` 符号和消息字符串。另一方面，`mistaken-macro`
    展开成 `nil`，因为它在展开时立即调用 `println`。'
- en: 'There are several important points here that we will build on in the rest of
    this chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个重要的观点，我们将在本章的其余部分进行阐述：
- en: Code is actually run when macros are expanded, and when the code is run. This
    is why `mistaken-macro` actually prints out a message.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宏展开时和代码运行时实际上会运行代码。这就是为什么 `mistaken-macro` 实际上会打印出一条消息。
- en: Understanding the difference between compile time and runtime is important.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解编译时间和运行时间之间的区别是很重要的。
- en: Quoting is important because it is one of the ways that you, as a programmer,
    control which code is executed when the macro is expanded, and which code is run
    at runtime.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用很重要，因为它是你作为程序员控制宏展开时执行哪些代码以及运行时运行哪些代码的方式之一。
- en: 'Remember: a macro is code that writes code. Let''s write a slightly more sophisticated
    macro that will expand to an arbitrary number of `println` calls. Our goal is
    for the macro to expand to this if we provide `3` as a parameter:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：宏是编写代码的代码。让我们编写一个稍微复杂一点的宏，它将展开成任意数量的 `println` 调用。我们的目标是，如果我们提供 `3` 作为参数，宏将展开成这样：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When working with macros, it is always a good idea to start by thinking about
    the code you want the macro to produce and then work back to how you will produce
    it.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当与宏一起工作时，始终先思考宏要生成的代码，然后再考虑如何生成它是一个好主意。
- en: Rather than thinking of this as a series of steps to execute, it's best to think
    of it as a list containing a symbol (`do`) and a series of sub-lists, each containing
    a symbol and a string. Thinking of `do` and `println` as symbols rather than a
    special form and a function is a good approach because, at expansion time, we
    just want to make sure that the form we end up producing has the correct symbols
    in the right order. Thinking of `println` as "just a symbol" is how the macroexpansion
    code "thinks" about it too if it is quoted.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与将其视为一系列执行步骤相比，最好将其视为包含一个符号（`do`）和一系列子列表的列表，每个子列表包含一个符号和一个字符串。将 `do` 和 `println`
    视为符号而不是特殊形式和函数是一个好方法，因为在展开时，我们只想确保最终生成的形式具有正确的符号并按正确的顺序排列。如果引用了 `println`，那么宏展开代码也是这样看待它的。
- en: 'To produce a list of lists, we might use `repeat`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成一个列表的列表，我们可以使用 `repeat`：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There's that single quotation mark again. If we left it out, we would get `(nil
    nil nil nil nil)`. And thanks to quoting, none of those calls to `println` are
    ever called. We are getting close to our target code and we haven't even called
    `defmacro` yet.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那个单引号又出现了。如果我们省略它，我们会得到 `(nil nil nil nil nil)`。多亏了引用，那些 `println` 调用中没有一个被调用。我们正在接近我们的目标代码，甚至还没有调用
    `defmacro`。
- en: 'The only thing missing is the initial `do` symbol. Adding a value to the front
    of a list is fairly easy too, as long as we quote it:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一缺少的是初始的 `do` 符号。只要我们引用它，向列表的头部添加一个值也是相当容易的：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There''s our code! All that''s left is to wrap this up as a macro:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码！剩下要做的就是将其封装成一个宏：
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When we call the macro directly, it seems to work:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们直接调用宏时，它似乎可以工作：
- en: '[PRE15]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'And `macroexpand` confirms it:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`macroexpand`确认了这一点：'
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The point here is to show that a macro is code that writes code. The contents
    of `multi-minimal` don''t look very much like the output. We could even go further
    and wrap them in a function:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的目的是表明宏是写代码的代码。`multi-minimal`的内容看起来并不像输出。我们甚至可以更进一步，将它们包装在一个函数中：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we'll see later, some macros look a little bit like templates, but there
    is nothing that requires their definitions to resemble the code that is output.
    Breaking the code-building code out into a separate function can be a useful pattern,
    especially for debugging.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们稍后将要看到的，一些宏看起来有点像模板，但没有任何东西要求它们的定义与输出的代码相似。将代码构建代码分离到单独的函数中可以是一个有用的模式，特别是对于调试。
- en: Runtime Parameters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行时参数
- en: Obviously, we can't expect this particular macro to be very useful. Still, it
    would be nice if it would print something besides "macro." What if we gave it
    a second parameter – a string to be passed on to all those `println` calls? There's
    already one parameter; adding a second one should be easy enough… right?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们无法期望这个特定的宏非常有用。然而，如果它能打印出除了“宏”之外的内容那就很好了。如果我们给它一个第二个参数——一个要传递给所有`println`调用的字符串呢？已经有一个参数了；添加第二个参数应该很容易……对吧？
- en: 'Let''s try just adding a parameter and passing that to `println`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试只添加一个参数并将其传递给`println`：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Unfortunately, this doesn''t work:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不起作用：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'What''s wrong? As always, when we don''t understand what is wrong with a macro,
    we reach for `macroexpand`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在哪里？像往常一样，当我们不理解宏的问题时，我们会求助于`macroexpand`：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: By the time the macro has been expanded, the `s` parameter has disappeared.
    Where did it go? Unlike `defn`, `defmacro` does not provide a context for runtime
    variable bindings. The original `n-times` parameter is available while the macro
    is being expanded, but afterward, the macro itself has been replaced by the code
    it produced. There is no trace left of `n-times`, or `s`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当宏展开完成后，`s`参数已经消失了。它去哪里了？与`defn`不同，`defmacro`不提供运行时变量绑定的上下文。在宏展开期间，原始的`n-times`参数是可用的，但在之后，宏本身已经被它产生的代码所取代。`n-times`或`s`都没有留下任何痕迹。
- en: 'Of course, there must be a way around this, since macros would be rather useless
    if they didn''t accept parameters. If we want there to be a context, we just need
    to create that context explicitly ourselves in quoted code that will still be
    present at runtime. In a case like this, the simplest solution would be a `let`
    binding. We need to change our target code to something like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，肯定有绕过这个问题的方法，因为如果宏不接受参数，它们将变得相当无用。如果我们想要有一个上下文，我们只需要在运行时仍然存在的引用代码中显式地创建那个上下文。在这种情况下，最简单的解决方案是一个`let`绑定。我们需要将我们的目标代码更改为如下所示：
- en: '[PRE21]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Why is the `let` binding called `string-to-print` and not `s`? Remember that
    when the code is finally run, `s` and `n-times` are no longer present as symbols.
    `n-times` is present in a way since it is what determined how many `println` calls
    end up in the expanded expression. The `s` parameter from the call to the macro
    needs to live on, not as `string-to-print`, but as the string bound to `string-to-print`.
    In other words, in the preceding target code, `s` is there: it''s `"My own text"`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么`let`绑定被称为`string-to-print`而不是`s`？记住，当代码最终运行时，`s`和`n-times`不再作为符号存在。`n-times`以一种方式存在，因为它决定了有多少`println`调用最终出现在展开表达式中。从宏调用中来的`s`参数需要继续存在，不是作为`string-to-print`，而是作为绑定给`string-to-print`的字符串。换句话说，在先前的目标代码中，`s`是存在的：它是`"My
    own text"`。
- en: 'We can do this by using some of Clojure''s list-manipulating power to carefully
    build the exact code that we need, that is, a `let` binding containing a sub-list
    of `println` expressions:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用Clojure的一些列表操作能力来仔细构建我们需要的精确代码，也就是说，一个包含`println`表达式子列表的`let`绑定：
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We''ll check to make sure it works:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将检查以确保它工作：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This time, `s` is not quoted when we bind it to `string-to-print`. When the
    macro is expanded, the value of `s` will be inserted into the list that the macro
    is going to return. Items such as `let` and `string-to-print` are quoted, because
    we don't want their values in the macro expansion; we want them to appear as symbols.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当我们将其绑定到`string-to-print`时，`s`没有被引用。当宏展开时，`s`的值将被插入到宏将要返回的列表中。像`let`和`string-to-print`这样的项被引用，因为我们不希望在宏展开中包含它们的值；我们希望它们以符号的形式出现。
- en: To achieve this, we've had to do some tricky quoting, applying a single quote
    to some items and not to others. This is why we used `list` instead of `'()`.
    The single quote is a shortcut for writing `(quote…)`. `quote` is a special form
    and its effect is to quote everything inside the parentheses, including sub-lists.
    Sometimes, this is exactly what we want, as with `'(println string-to-print)`.
    We need both items in that list to appear as symbols, not as values. `list` simply
    returns a list. By using `list`, we can choose which items should be quoted or
    not.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们不得不做一些巧妙的引号操作，对某些项应用单引号，而对其他项不应用。这就是为什么我们使用 `list` 而不是 `'()``。单引号是
    `(quote...)` 的快捷方式。`quote` 是一个特殊形式，其效果是引号括号内的所有内容，包括子列表。有时，这正是我们想要的，比如 `'(println
    string-to-print)`。我们需要列表中的两个项都作为符号出现，而不是作为值。`list` 简单地返回一个列表。通过使用 `list`，我们可以选择哪些项应该被引号引用，哪些不应该。
- en: This is not an optimal quoting solution. Shortly, we'll see that Clojure proposes
    another more sophisticated syntax that makes this easier. The underlying principles
    are the same, however, so it's good to see how the mechanics of quoting work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个最优的引号解决方案。简而言之，我们将看到 Clojure 提供了另一种更复杂的语法，这使得这更加容易。然而，基本原理是相同的，所以了解引号的工作机制是很好的。
- en: There is one more noteworthy (or simply strange) thing in this version of the
    macro. Why are we using `concat` to join the list and the results of the call
    to `repeat`? Previously, we wrapped all the `println` calls inside a `do` expression.
    Now that we have a `let` block, this isn't necessary anymore. At the same time,
    we still need to make sure that the `println` calls aren't wrapped in a list.
    Using `concat` solves the immediate problem but it is not an elegant solution.
    In the next section, the new quoting syntax will make this easier as well.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个宏版本的另一个值得注意（或者简单地说，奇怪）的事情是：为什么我们使用 `concat` 来连接列表和 `repeat` 调用的结果？之前，我们是在
    `do` 表达式内部包裹所有的 `println` 调用。现在有了 `let` 块，这不再是必要的了。同时，我们仍然需要确保 `println` 调用没有被包裹在列表中。使用
    `concat` 解决了眼前的问题，但这并不是一个优雅的解决方案。在下一段中，新的引号语法也会使这变得更加容易。
- en: Syntax Quoting
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 语法引号
- en: A lot of the art of writing macros lies in mastering the separation between
    expansion code and output code. A lot of the control over that separation depends
    on deciding what gets quoted when the macro is expanded and what does not get
    quoted. The previous example started to reveal the limits of the standard `quote`
    special form. Once a list has been quoted, all its symbols and sub-lists are `quote`d
    as well. As such, `quote` is a fairly heavy-handed tool.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 编写宏的艺术中，很大一部分在于掌握扩展代码和输出代码之间的分离。对这种分离的控制很大程度上取决于在宏展开时决定什么被引号引用，什么没有被引号引用。之前的例子开始揭示了标准
    `quote` 特殊形式的局限性。一旦列表被引号引用，它的所有符号和子列表也会被 `quote`。因此，`quote` 是一个相当直接的工具。
- en: 'For this reason, Clojure, like many Lisps, provides a more sophisticated quoting
    mechanism called `''`, the backtick character, instead of the standard single
    quote. When used by itself, the backtick has more or less the same behavior as
    `quote`: all symbols and sub-lists are quoted by default. The difference is that
    syntax quoting allows us to mark certain forms, sub-lists, or symbols that should
    not be quoted.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Clojure，像许多 Lisps 一样，提供了一个更复杂的引号机制，称为 `'`，即反引号字符，而不是标准的单引号。当单独使用时，反引号的行为与
    `quote` 大致相同：默认情况下，所有符号和子列表都会被引号引用。区别在于，语法引号允许我们标记某些形式、子列表或符号，这些不应该被引号引用。
- en: 'With syntax quoting, we can simplify our macro from the previous section:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用语法引号，我们可以简化之前章节中的宏：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'How does this work? There are three new things here:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何工作的？这里有三点新内容：
- en: The `syntax-quote` backtick, in front of the `do` form and the `println` form
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `do` 形式和 `println` 形式前面的 `syntax-quote` 反引号
- en: The `~`, the tilde, in front of the `s` symbol
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `s` 符号前面的 `~`
- en: The `~@` in front of the `repeat` form
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `repeat` 形式前面的 `~@`
- en: 'The `syntax-quote` backticks initiate syntax quoting. Then, we can see two
    different ways of preventing quoting on child elements. The simplest of the two
    is the tilde in `''(println ~s)`: the `println` symbol, where the list itself
    will be quoted when the macro is expanded, but `~s` will evaluate to the value
    of `s`. The tilde is called `unquote`. Thanks to `unquote`, we can now insert
    the value of `s` into each `println` call and we no longer need to wrap the entire
    expression in a `let` expression.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`syntax-quote` 反引号开始语法引用。然后，我们可以看到两种防止对子元素进行引用的不同方式。其中最简单的是 `''(println ~s)`
    中的波浪号：`println` 符号，当宏展开时，列表本身将被引用，但 `~s` 将评估为 `s` 的值。波浪号被称为 `unquote`。多亏了 `unquote`，我们现在可以将
    `s` 的值插入到每个 `println` 调用中，我们不再需要将整个表达式包裹在一个 `let` 表达式中。'
- en: '`~@` is called `unquote-splicing` and does two things at once. Like `unquote`,
    it prevents quoting on the expression it is attached to. Unlike `unquote`, though,
    it only works on lists because its role is to splice the contents of the list
    into the containing list. Before, we had to use `cons` or `concat` to avoid ending
    up with all the `(println "String!")` expressions wrapped inside a list.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`~@` 被称为 `unquote-splicing`，一次做两件事。像 `unquote` 一样，它防止对其附加的表达式进行引用。然而，与 `unquote`
    不同的是，它只适用于列表，因为它的作用是将列表的内容拼接到包含列表中。在此之前，我们必须使用 `cons` 或 `concat` 来避免所有 `(println
    "String!")` 表达式都被包裹在一个列表中。'
- en: 'Expanded, a call to the new macro looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 展开后，对新宏的调用看起来像这样：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'You may notice a slight difference relative to some of the previous macro expansions:
    the `println` symbols are namespaced! This is an important feature for writing
    robust macros that we will explore shortly when we get to the topic of macro hygiene.
    First, though, let''s practice using our new macro skills.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到与之前的一些宏展开相比有细微的差别：`println` 符号被命名空间化了！这是编写健壮宏的一个重要特性，我们将在探讨宏卫生问题时进一步探讨。首先，让我们先练习使用我们新的宏技能。
- en: 'Exercise 11.01: The and-ors Macro'
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.01：and-ors 宏
- en: At the beginning of this chapter, to whet your appetite for macro magic, we
    showed you a macro called `and-ors`. Its purpose was to make it easier to write
    nested Boolean logic when you have lots of expressions with or contained in an
    overarching `and` expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头，为了激发你对宏魔法的兴趣，我们向你展示了一个名为 `and-ors` 的宏。它的目的是在有许多表达式包含在顶层 `and` 表达式中时，使编写嵌套布尔逻辑更容易。
- en: 'Consider this function (hopefully, real code would have more descriptive parameter
    names!):'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个函数（希望，真正的代码会有更具描述性的参数名！）：
- en: '[PRE26]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Logic like this is inherently hard to read, especially when there are lots of
    conditions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的逻辑本身很难阅读，尤其是在有很多条件的情况下。
- en: 'Let''s suppose that you are writing a library that will contain lots of important
    business logic that is mostly expressed with a long series of Boolean operators,
    as in the preceding function. Anything we can do to make it simpler will help
    the overall readability of your code base. The `and-ors` macro would be a welcome
    improvement. Instead of the nested `or` expressions in the preceding function,
    you could write this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个将包含大量重要业务逻辑的库，这些逻辑大多用一系列布尔运算符表达，就像前面的函数那样。我们可以做的任何使它更简单的事情都将有助于提高你的代码库的可读性。`and-ors`
    宏将是一个受欢迎的改进。在前面函数中，你可以用以下方式代替嵌套的 `or` 表达式：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is an admittedly minor improvement, but it does remove some parentheses
    and generally helps put the accent on the logical expressions themselves. Now,
    we just need to figure out how to make this work:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个诚实的微小改进，但它确实去除了一些括号，并且通常有助于将重点放在逻辑表达式本身上。现在，我们只需要弄清楚如何使这个工作：
- en: 'Start with a skeleton for `defmacro`:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `defmacro` 的骨架开始：
- en: '[PRE28]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Just like with functions, macros can be variadic and accept an unknown number
    of arguments. This is exactly what we need here since we don't know how many `or`
    expressions there will be.
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像函数一样，宏可以是可变参数的，可以接受未知数量的参数。这正是我们在这里需要的，因为我们不知道会有多少 `or` 表达式。
- en: 'Write the logic that will split the list of `or-exps` each time there is a
    `|` symbol:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写逻辑，每次在 `or-exps` 列表中出现 `|` 符号时，将其分割：
- en: '[PRE29]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Breaking the list of arguments in `or-exps` into sub-lists is a simple sequence
    operation. There are several ways to do this, including writing a small external
    function. Here, we've chosen to use `partition-by`. Remember, `partition-by` takes
    a function that it uses to decide where to break a list. The list is broken every
    time the function returns a different response. We only care about whether the
    current item is `|` or something else, which is exactly what `(partial = '|)`
    will do. The only trick here is that we need to quote the `|` symbol to make sure
    that we are talking about the symbol itself and not its value. (Which is good,
    since it doesn't have a value.)
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将 `or-exps` 的参数列表拆分成子列表是一个简单的序列操作。有几种方法可以做到这一点，包括编写一个小的外部函数。在这里，我们选择使用 `partition-by`。记住，`partition-by`
    接收一个函数，该函数用于决定在哪里拆分列表。每当函数返回不同的响应时，列表就会被拆分。我们只关心当前项是 `|` 还是其他东西，这正是 `(partial
    = '|)` 要做的。这里的唯一技巧是我们需要引用 `|` 符号，以确保我们谈论的是符号本身，而不是它的值。（这是好事，因为它没有值。）
- en: 'Splitting on the `|` symbols leaves the symbols as sub-lists. You can try this
    in the REPL if you quote the `|` symbol in the input:'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 根据 `|` 符号进行拆分会将符号作为子列表留下。你可以在 REPL 中尝试这个，如果你在输入中引用了 `|` 符号：
- en: '[PRE30]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We need to remove the `(|)` sublist from the results. We''ll use `remove` for
    this:'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要从结果中移除 `(|)` 子列表。我们将使用 `remove` 来完成这个任务：
- en: '[PRE31]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The `|` symbol has now disappeared from our code. It will not be present in
    any way in the compiled code. This is why we don't have to worry about it being
    defined or namespaced. From the point of view of the compiled code, it's like
    it was never there in the first place.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`|` 符号现在已从我们的代码中消失。它将以任何方式都不会出现在编译后的代码中。这就是为什么我们不必担心它被定义或命名空间化。从编译后的代码的角度来看，它就像它从一开始就不在那里一样。'
- en: Now, we have our `groups` binding, which contains a list of lists.
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们有 `groups` 绑定，它包含一个列表的列表。
- en: Prepare to output the outer `and` expression.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备输出外部的 `and` 表达式。
- en: 'The structure we want to create is that of an `and` expression containing zero
    or more expressions. So first, we need the `and` expression:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们想要创建的结构是包含零个或多个表达式的 `and` 表达式。所以首先，我们需要 `and` 表达式：
- en: '[PRE32]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, the important thing is the quoting. The backtick in front of `(and…)`
    starts the syntax quoting. This ensures, first of all, that the `(and…)` form
    will be output, and secondly that we will be able to use `splice-insert` to include
    the new `or` expressions.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，重要的是引用。`(and…)` 前面的反引号开始语法引用。这首先确保 `(and…)` 形式将被输出，其次确保我们能够使用 `splice-insert`
    来包含新的 `or` 表达式。
- en: Convert each sub-list into an `or` expression.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个子列表转换为 `or` 表达式。
- en: 'Here is the complete macro:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是完整的宏：
- en: '[PRE33]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The call to `map` will return a list. Since we don't want an extra set of parentheses
    inside the `(and…)` expression, we use `insert-splice` here. Inside the anonymous
    mapping function, we need to start syntax quoting again since it was suspended
    by the `~@` in front of `(map…)`. That's why we've put the backtick in front of
    `(or…)`. The same process is more or less repeated since each element in `groups`
    is a list of items to be placed inside an `(or…)` expression.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`map` 的调用将返回一个列表。由于我们不想在 `(and…)` 表达式内部有额外的括号，所以我们在这里使用 `insert-splice`。在匿名映射函数内部，我们需要再次开始语法引用，因为前面的
    `~@` 暂停了它。这就是为什么我们在 `(or…)` 前面放上了反引号。同样的过程在 `groups` 的每个元素中都会重复，因为每个元素都是一个要放在
    `(or…)` 表达式内部的项列表。'
- en: 'Test and macroexpand your new macro:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试并宏展开你的新宏：
- en: '[PRE34]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It seems to work. Let''s try it with nested `and-ors`:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它似乎有效。让我们用嵌套的 `and-ors` 来试一试：
- en: '[PRE35]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Macroexpansion will show us whether we are getting exactly what we originally
    wanted. To avoid expanding the `and` and `or` macros, we''ll use a different version
    of `macroexpand` here, called `macroexpand-1`. The difference between the two
    is that, when a macro expansion contains other macros, `macroexpand` will continue,
    recursively, to expand all of the nested macros, while `macroexpand-1` will stop
    after the first macro. When writing your own macros, `macroexpand-1` is often
    more intuitive because it prevents us from seeing the details of built-in macros,
    such as `let` or, as in this example, `and` or `or`:'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 宏展开将告诉我们我们是否得到了我们最初想要的。为了避免展开 `and` 和 `or` 宏，我们在这里使用 `macroexpand` 的不同版本，称为
    `macroexpand-1`。这两个之间的区别是，当一个宏展开包含其他宏时，`macroexpand` 将递归地继续展开所有嵌套的宏，而 `macroexpand-1`
    将在第一个宏之后停止。在编写自己的宏时，`macroexpand-1` 通常更直观，因为它阻止我们看到内置宏的细节，例如 `let` 或，如本例中的 `and`
    或 `or`：
- en: '[PRE36]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This exercise shows how even a four-line macro can allow you to introduce what
    could be a useful syntactical improvement. The decision to write a macro such
    as `and-ors` would be based on whether or not it was starting to be painful to
    write all those repetitive Booleans in your code base.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个练习展示了即使是四行的宏也能让你引入可能是有用的语法改进。是否编写像`and-ors`这样的宏的决定将基于是否在代码库中编写所有那些重复的布尔值变得痛苦。
- en: 'Exercise 11.02: An Automatic HTML Library'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习11.02：自动HTML库
- en: In this exercise, you will write a macro that, given a list of items, automatically
    creates a function for each item. This can be useful in situations where you need
    a large number of very similar functions.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你需要编写一个宏，给定一个项目列表，自动为每个项目创建一个函数。这在需要大量非常相似函数的情况下非常有用。
- en: 'Back in *Chapter 6*, *Recursion and Looping*, you built a library that translated
    Clojure vectors into HTML, using keywords to identify the HTML tags. In that system,
    an HTML element would be written like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 回到*第6章*，*递归和循环*，你构建了一个库，将Clojure向量转换为HTML，使用关键字来识别HTML标签。在那个系统中，HTML元素会写成这样：
- en: '[PRE37]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The output would be as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE38]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Recently, a co-worker decided to rewrite the library using functions rather
    than vectors. With this new approach, an HTML element would be written as a function:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，一位同事决定用函数而不是向量重写这个库。使用这种新方法，HTML元素会写成函数的形式：
- en: '[PRE39]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Functions can be nested so that developers can write entire HTML pages in their
    source code.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 函数可以嵌套，这样开发者就可以在源代码中编写整个HTML页面。
- en: Unfortunately, your co-worker left before they could finish the project and
    you've been asked to take over.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 很不幸，你的同事在完成项目之前就离开了，现在你需要接手这个项目。
- en: You can view what the new library looks like at [https://packt.live/2Gf4bn9](https://packt.live/2Gf4bn9).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.live/2Gf4bn9](https://packt.live/2Gf4bn9)查看新库的样子。
- en: As you read through the code, you start to see how the library was supposed
    to work, and also why it was abandoned. You realize that, like your former colleague,
    you don't feel like writing out a separate function for every element in the HTML
    spec! It would be a long, buggy process of copying and pasting hard-to-maintain
    code. Looking closer, you start to suspect that your former colleague had the
    same idea. The last function, `tag-fn`, looks suspiciously like an attempt to
    generalize the approach. It also includes a rather clever use of `mapcat`, similar
    to the wrap-unwrap technique from *Chapter 4*, *Mapping and Filtering*, so that
    a list of items can be spliced into a containing list. Unfortunately, the file
    ends there.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读代码时，你开始看到库是如何工作的，以及为什么它会被放弃。你意识到，就像你的前同事一样，你不想为HTML规范中的每个元素编写单独的函数！这将是一个漫长且容易出错的复制粘贴过程，难以维护。仔细观察后，你开始怀疑你的前同事也有同样的想法。最后一个函数`tag-fn`看起来像是对这种方法的一种尝试性概括。它还包括了类似于*第4章*中wrap-unwrap技术的`mapcat`的巧妙使用，以便将项目列表插入到包含列表中。不幸的是，文件就到这里结束了。
- en: 'Using `tag-fn` to produce a function for each element seems like a good idea.
    It still means defining a `var` for each kind of HTML element. Your code would
    look like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tag-fn`为每个元素生成一个函数似乎是个好主意。这意味着仍然需要为每种HTML元素定义一个`var`。你的代码看起来会是这样：
- en: '[PRE40]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This is a lot better than typing out all those functions, but it still seems
    too repetitive. Maybe a macro could help?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做比手动编写所有函数要好得多，但仍然显得过于重复。也许宏可以帮助解决这个问题？
- en: 'With the right macro, we could just copy a list of elements from the HTML specification,
    wrap them in quotes, and run our macro once while loading the source file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的宏，我们只需从HTML规范中复制一个元素列表，将它们用引号括起来，然后在加载源文件时运行一次宏：
- en: '[PRE41]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output would be a series of `def` expressions, just like what we have in
    the preceding code. Let''s have a look:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是一系列`def`表达式，就像我们在前面的代码中所看到的那样。让我们看看：
- en: Set up a new project directory with an empty `deps.edn`. Copy the `htmlgen.clj`
    file from this book's GitHub repository ([https://packt.live/2Gf4bn9](https://packt.live/2Gf4bn9)).
    You will add your code to the bottom of the file.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个新的项目目录，并创建一个空的`deps.edn`文件。从本书的GitHub仓库（[https://packt.live/2Gf4bn9](https://packt.live/2Gf4bn9)）复制`htmlgen.clj`文件。你将在文件的底部添加你的代码。
- en: 'First, sketch out the code you want to produce. Because we need to be able
    to produce an arbitrary number of functions, our macro will return a list of `def`
    forms. It will be simpler to enclose those forms in a `do` expression:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，勾勒出你想要生成的代码。因为我们需要能够生成任意数量的函数，所以我们的宏将返回一个`def`形式的列表。将这些形式包含在`do`表达式中会更简单：
- en: '[PRE42]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Write the skeleton for the macro with syntax quoting applied to the `do` expression:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用语法引用将`syntax-quote`应用于`do`表达式来编写宏的骨架：
- en: '[PRE43]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Note
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We give the macro a `[& tags]`. We'll come back to this later.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们给宏一个`[& tags]`。我们稍后会回到这一点。
- en: 'Map over the arguments in `tags` to produce a series of `def` expressions:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`tags`中的参数进行映射，以生成一系列`def`表达式：
- en: '[PRE44]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'There are several things to note here. Look carefully at what is quoted and
    what is not: the use of `unquote-splice` (`~@`) ensures that the elements returned
    by `map` are the direct children of the `do` expression. Then, with `syntax-quote`
    (`''`), we quote the entire `def` expression, except for what is going to become
    the name of the var we are defining, which we protect from quoting with `unquote`
    (`~`). Finally, the `tag-fn` expression inherits its quoting from the backtick
    in front of `def`. We still need to use `unquote` so that the `tagname` value,
    something like `"h1"`, is inserted rather than just the `tagname` symbol itself.'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里有几个需要注意的地方。仔细看看哪些是引用的，哪些不是：使用`unquote-splice`（`~@`）确保`map`返回的元素是`do`表达式的直接子元素。然后，使用`syntax-quote`（`'`），我们引用整个`def`表达式，除了将要成为我们定义的变量名称的部分，我们使用`unquote`（`~`）来保护它不被引用。最后，`tag-fn`表达式从`def`前的反引号继承其引用。我们仍然需要使用`unquote`，以便将`tagname`值（例如`"h1"`）插入，而不是仅仅插入`tagname`符号本身。
- en: The `symbol` function is needed here because the input is a string. `tag-fn`
    takes a string, but its name needs to be a symbol.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里需要`symbol`函数，因为输入是一个字符串。`tag-fn`接受一个字符串，但它的名称需要是一个符号。
- en: 'Test the new macro. Evaluate the macro definition and then use it to define
    some HTML element functions:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试新的宏。评估宏定义，然后使用它来定义一些HTML元素函数：
- en: '[PRE45]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'By copying an official list of HTML tags, you can quickly implement the entire
    standard. From inside the `packt-clojure.htmlgen` namespace, you are now able
    to generate HTML elements with your new functions:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过复制官方的HTML标签列表，你可以快速实现整个标准。现在，你可以在`packt-clojure.htmlgen`命名空间内部使用你的新函数来生成HTML元素：
- en: '[PRE46]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It works. You've fulfilled the requirements of the assignment and management
    is satisfied… for now, at least.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它工作了。你已经满足了作业和管理的要求……至少目前是这样。
- en: Automatically producing a large number of functions is a task that macros are
    well adapted for. A macro like this one is little more than a template for a function.
    Macros can do much more, of course, but sometimes, mass-producing simple functions
    is exactly what you need.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自动生成大量函数是宏非常适合的任务。这样的宏不过是函数的一个模板。当然，宏可以做更多的事情，但有时，大量生成简单的函数正是你所需要的。
- en: 'In this exercise, the macro we wrote was variadic. It accepts a variable number
    of arguments and its parameter list looks like this: `[& tag]`. It might be tempting
    to rewrite the macro so that it accepts a list or a vector of tag names. That
    way, we could define our list and then call the macro on it separately. Here''s
    our macro, rewritten to accept a list instead:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们编写的宏是可变参数的。它接受可变数量的参数，其参数列表如下：`[& tag]`。可能会有人想重写宏，使其接受标签名称的列表或向量。这样，我们就可以定义我们的列表，然后单独对它调用宏。这是我们的宏，重写为接受列表：
- en: '[PRE47]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Unfortunately, this doesn''t work:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这不起作用：
- en: '![Figure 11.2: At compile time, a symbol such as heading-tags is just a symbol,
    not a list'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2：在编译时，像heading-tags这样的符号只是一个符号，不是一个列表]'
- en: '](img/B14502_11_02.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.2](img/B14502_11_02.jpg)'
- en: 'Figure 11.2: At compile time, a symbol such as heading-tags is just a symbol,
    not a list'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.2：在编译时，像heading-tags这样的符号只是一个符号，不是一个列表
- en: The macro fails because, at compile time, `heading-tags` is not a list yet.
    The macro only "sees" a symbol and, just like the error says, it doesn't know
    how to create a sequence from a symbol. The macro code in the exercise needs access
    to the actual tag name at compile time.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 宏失败了，因为在编译时，`heading-tags`还不是列表。宏只能“看到”一个符号，就像错误信息所说的那样，它不知道如何从一个符号创建一个序列。练习中的宏代码需要在编译时访问实际的标签名称。
- en: 'This is one reason why `apply` can''t be used on macros:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么不能在宏上使用`apply`的原因：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: By the time the call to `apply` is made, the code is already running and it's
    too late for the macro to be expanded. For the same reason, a macro cannot be
    passed as an argument to a function such as `map` or `filter`. While macros bring
    great flexibility to a language, there is always a cost to using a macro instead
    of a function.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `apply` 调用发生时，代码已经运行，此时宏展开已经太晚了。同样，宏不能作为 `map` 或 `filter` 等函数的参数传递。虽然宏为语言带来了极大的灵活性，但使用宏而不是函数总是有代价的。
- en: 'Exercise 11.03: Expanding the HTML Library'
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.03：扩展 HTML 库
- en: Your team was impressed with how quickly you implemented all the known HTML
    elements as functions and now, the HTML generating library is becoming more popular
    inside your organization. As often happens with successful libraries, the developers
    using it are starting to run into problems. One of the most common frustrations
    that's expressed by members of your team is that it is awkward to wrap a list
    of elements inside a containing element.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你的团队对你的快速实现所有已知的 HTML 元素作为函数印象深刻，现在，HTML 生成库在你的组织中变得越来越受欢迎。正如成功的库经常发生的那样，使用它的开发者开始遇到问题。你的团队中最常见的挫败感之一是，在包含元素内部包裹元素列表很尴尬。
- en: 'Here is a simple example of a common use case: creating an unordered list (`<ul>`)
    by mapping over a list of strings, transforming each string into a list item (`<li>`).
    Thanks to how the original `tag-fn` was written to handle sequences as well as
    strings, the code for creating an HTML list from a vector of items is fairly simple:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个常见用例的简单示例：通过映射字符串列表来创建无序列表（`<ul>`），将每个字符串转换为一个列表项（`<li>`）。多亏了原始 `tag-fn`
    的编写方式，它能够处理序列以及字符串，因此从项目向量创建 HTML 列表的代码相当简单：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, this pattern arises so often in your co-workers' code that they are
    starting to complain that your library forces them to be redundant. "Why," they
    ask, "can't this be simpler? We know that a `ul`, when given a list, will result
    in a `(map li…)` call. Can't that be automatic?"
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种模式在你的同事的代码中出现的频率如此之高，以至于他们开始抱怨你的库迫使他们重复。他们问道：“为什么不能更简单一些？我们知道当给 `ul` 一个列表时，将会产生一个
    `(map li…)` 调用。这不能是自动的吗？”
- en: '"Well," you reply, "of course it can." After some thought, you decide that
    you want your colleagues to be able to write this instead:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: “嗯，”你回答，“当然可以。”经过一番思考，你决定想让你的同事能够编写以下内容：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'And this won''t just apply to `ul`. `ol->li` would be just as useful. Some
    of the table elements could use the same thing: `table->tr` and `tbody->tr` would
    be quite useful for lists of table rows (`<tr>`), as would `tr->td` for table
    rows (`<tr>`) containing lists of table cells (`<td>`). You decide to write a
    second, specialized macro called `define-html-list-tags` that will take tag name
    pairs and define the corresponding functions:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅适用于 `ul`。`ol->li` 也会非常有用。一些表格元素也可以使用相同的方法：`table->tr` 和 `tbody->tr` 对于表格行列表（`<tr>`）非常有用，同样，`tr->td`
    对于包含表格单元格列表（`<td>`）的表格行（`<tr>`）也非常有用。你决定编写第二个、专门的宏 `define-html-list-tags`，它将接受标签名对并定义相应的函数：
- en: 'In the same file as the previous exercise, define a helper function to build
    the new functions. It will be called `subtag-fn` and will be simpler than `tag-fn`
    because it doesn''t need to handle as many different cases:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在上一个练习的同一文件中，定义一个辅助函数来构建新的函数。它将被命名为 `subtag-fn`，并且比 `tag-fn` 更简单，因为它不需要处理那么多不同的情况：
- en: '[PRE51]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The contents of the function should appear relatively familiar. The only new
    piece of code here is `(map subtag content)`. For a function such as `ul→li`,
    the `li` function (which we assume is already defined – make sure `define-html-tags`
    is called first!) is called on each item in the `content` argument.
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数的内容看起来相对熟悉。这里唯一的新代码片段是 `(map subtag content)`。对于像 `ul→li` 这样的函数，`li` 函数（我们假设它已经定义好了——确保首先调用
    `define-html-tags`！）将在 `content` 参数的每个项上被调用。
- en: 'Test the helper function. The helper function will be called at runtime, so
    it is easy to test:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试辅助函数。辅助函数将在运行时被调用，因此很容易测试：
- en: '[PRE52]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note again that this works because the `li` function has already been defined.
    We pass it in as a symbol – `li`, without quotes – and not as a string like `"ul"`.
    The `ul` function won't be defined until after the macro has been run.
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次注意，这是因为 `li` 函数已经定义好了。我们将其作为符号传递——`li`，不带引号——而不是像 `"ul"` 这样的字符串。`ul` 函数将在宏运行之后才会被定义。
- en: 'There is one small problem here, however: we can''t optionally pass in a map
    of attributes. This breaks the interface we''ve established for the other functions,
    so we need to fix that before moving on.'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这里有一个小问题：我们无法可选地传递一个属性映射。这破坏了我们为其他函数建立的接口，所以我们需要在继续之前修复它。
- en: 'Add a second arity to the anonymous function returned by `subtag-fn`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `subtag-fn` 返回的匿名函数添加第二个参数：
- en: '[PRE53]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This code highlights two interesting features of anonymous functions. First
    of all, they support multiple arities, which makes them just as flexible as their
    `defn` defined counterparts. Secondly, despite being anonymous, they can have
    names. This feature exists in other languages, such as JavaScript, and can be
    useful for debugging purposes. When reading error messages, having a function
    name can be a big help. Naming an anonymous function in Clojure has another advantage,
    in that the function can refer to itself this way. Thus, in the preceding code,
    the single version of the function can fill in the `attrs` argument with `nil`
    and then call the double argument version. This way, we don't have to write the
    function's logic twice.
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码突出了匿名函数的两个有趣特性。首先，它们支持多个参数，这使得它们与 `defn` 定义的对应函数一样灵活。其次，尽管是匿名的，但它们可以有名字。这种特性存在于其他语言中，如
    JavaScript，并且对于调试目的可能很有用。在阅读错误消息时，有一个函数名可以大有帮助。在 Clojure 中给匿名函数命名还有一个优点，即函数可以通过这种方式引用自己。因此，在前面的代码中，单个版本的函数可以用
    `nil` 填充 `attrs` 参数，然后调用双参数版本。这样，我们就不必两次编写函数的逻辑。
- en: 'Test the new `subtag-fn`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试新的 `subtag-fn`：
- en: '[PRE54]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This works. Now, let''s try the single-argument form:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这有效。现在，让我们尝试单参数形式：
- en: '[PRE55]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It still works too!
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它仍然有效！
- en: Write the macro that will define functions such as `ul->li`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写将定义如 `ul->li` 这样的函数的宏：
- en: 'As always, the first step in designing a macro is to decide how it should be
    called. A call to this macro should look like this:'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设计宏的第一步通常是决定如何调用它。对这个宏的调用应该看起来像这样：
- en: '[PRE56]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To understand what is happening here, let''s start from inside the anonymous
    function that''s been passed to `map`. The first line should look familiar:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要理解这里发生的事情，让我们从传递给 `map` 的匿名函数内部开始。第一行应该看起来很熟悉：
- en: '[PRE57]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This is exactly the same as in the `define-html-tags` macro from the previous
    exercise. Even though we're going to define `ul->li`, we still need to define
    the `ul` function.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与之前练习中的 `define-html-tags` 宏完全相同。即使我们要定义 `ul->li`，我们仍然需要定义 `ul` 函数。
- en: 'The next line is where we define functions such as `ul->li`:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一条是定义如 `ul->li` 这样的函数的地方：
- en: '[PRE58]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This definition follows the same pattern as in the preceding code, except that
    we use `str` to build the symbol that will be the name of the function and we
    turn the subtag string into a symbol as well.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个定义与前面的代码遵循相同的模式，只是我们使用 `str` 来构建将成为函数名的符号，并将子标签字符串也转换成符号。
- en: 'Both of these definitions are wrapped in a `do` expression, and the output
    from `map` is, in turn, wrapped in a single `do`. Expanded, it looks like this:'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个定义都被 `do` 表达式包裹，`map` 的输出反过来又被单个 `do` 表达式包裹。展开后，它看起来像这样：
- en: '[PRE59]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Test the new macro:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试新的宏：
- en: '[PRE60]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It works.
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它有效。
- en: In the previous exercise, it may seem inelegant to use nested `do` expressions.
    We would certainly never write code this way by hand! For code produced by a macro,
    however, it really isn't a problem. This doesn't mean that macros should expand
    into convoluted code. Simple is always better. However, most of the time, no human
    will need to read this code. Someone (probably you) might have to read and debug
    the code of your macro, so keeping it as simple as possible will generally be
    worth it, even at the cost of a few extra nested `do` expressions or some other
    repetitive code oddity.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，使用嵌套的 `do` 表达式可能看起来不够优雅。我们当然永远不会手动以这种方式编写代码！然而，对于由宏生成的代码，这真的不是问题。这并不意味着宏应该扩展成复杂的代码。简单总是更好。然而，大多数时候，没有人需要阅读这段代码。有人（可能是你）可能需要阅读和调试宏的代码，所以尽可能保持代码简单通常是值得的，即使是以牺牲一些额外的嵌套
    `do` 表达式或其他重复代码怪癖为代价。
- en: 'We could, of course, use `mapcat` to create a flat list:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然可以使用 `mapcat` 来创建一个扁平列表：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: There is a subtle difference here, in that the syntax-quoting has been moved
    from the containing `(do…)` expression to the `(def…)` expressions themselves.
    At runtime, the vector will no longer exist, so we don't want to quote it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个微妙的不同之处，即语法引用已经从包含的 `(do…)` 表达式移动到了 `(def…)` 表达式本身。在运行时，向量将不再存在，所以我们不想引用它。
- en: 'This version produces nicer code when expanded:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此版本在展开时生成更美观的代码：
- en: '[PRE62]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Your mileage may vary, but in general, simplifying your macro code is more important
    than producing elegant expansions. The macro is the code you will need to debug.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你的体验可能会有所不同，但一般来说，简化宏代码比生成优雅的展开更重要。宏是你要调试的代码。
- en: In this and the previous exercise, we used `def`, along with helper functions
    that built new functions. Nothing prevents you from writing macros that define
    new functions with `defn`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个和上一个练习中，我们使用了`def`以及构建新函数的辅助函数。没有什么阻止你使用`defn`编写定义新函数的宏。
- en: Macros in ClojureScript
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ClojureScript中的宏
- en: The distinction between **compile time** and **runtime** is perhaps the most
    important concept to grasp when learning about macros. Before going further into
    the consequences of this distinction, it's worth looking at how it affects macros
    in ClojureScript, where compilation and execution have a slightly more complex
    relationship than they do in JVM Clojure.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习宏时，区分**编译时间**和**运行时间**可能是最重要的概念。在进一步探讨这一区别的后果之前，值得看看它如何影响ClojureScript中的宏，在ClojureScript中，编译和执行之间的关系比在JVM
    Clojure中要复杂一些。
- en: ClojureScript runs in a JavaScript runtime, like the browser or Node.js. This
    is possible because ClojureScript code is first compiled by the ClojureScript
    compiler, which is a program written in Clojure and runs on the JVM. This means
    that ClojureScript programs, once they're compiled and running, no longer have
    access to the compilation phase.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: ClojureScript在JavaScript运行时中运行，如浏览器或Node.js。这是可能的，因为ClojureScript代码首先由ClojureScript编译器编译，该编译器是一个用Clojure编写的程序，在JVM上运行。这意味着一旦ClojureScript程序编译并运行，就不再能访问编译阶段。
- en: This has several consequences for working with macros in ClojureScript, the
    most important of which is that ClojureScript macros cannot be defined in `.cljs`
    files
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这对在ClojureScript中使用宏有几个后果，其中最重要的是ClojureScript宏不能定义在`.cljs`文件中
- en: alongside other ClojureScript code. Instead, they are defined in separate files
    with either the `.clj` file extension or the cross-compiling `.cljc` extension.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他ClojureScript代码并排。相反，它们是在单独的文件中定义的，这些文件具有`.clj`文件扩展名或跨编译的`.cljc`扩展名。
- en: 'In the GitHub repository accompanying this book, there is a minimal `ClojureScript
    project` that illustrates this. It contains two namespaces: `minmacros/core.cljs`
    and `minmacros/macros.cljc`.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书配套的GitHub仓库中，有一个最小的`ClojureScript项目`展示了这一点。它包含两个命名空间：`minmacros/core.cljs`和`minmacros/macros.cljc`。
- en: 'The `minmacros/core.cljs` namespace uses special syntax to require the macros
    in `minmacros/macros.cljc`. Here''s the entire content:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`minmacros/core.cljs`命名空间使用特殊语法来引入`minmacros/macros.cljc`中的宏。以下是全部内容：'
- en: '[PRE63]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This is the only situation where specifying `:require-macros` is necessary.
    It does not exist in JVM Clojure, only in ClojureScript. If `minmacros/macros.cljc`
    contained functions that we also wanted to import, we would have to require the
    namespace separately:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在唯一需要指定`:require-macros`的情况。在JVM Clojure中不存在，只有ClojureScript中存在。如果`minmacros/macros.cljc`包含我们也想导入的函数，我们必须单独引入命名空间：
- en: '[PRE64]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that we can use the same namespace alias in both cases. This is because
    the macroexpansion phase is totally separate from the code execution phase.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以在两种情况下使用相同的命名空间别名。这是因为宏展开阶段与代码执行阶段是完全独立的。
- en: 'To see these macros in action, copy the complete `Chapter11/minmacros` directory
    from GitHub ([https://packt.live/2TQHTjQ](https://packt.live/2TQHTjQ)). In your
    Terminal, change to the `minmacros` directory. From there, you can run this from
    the command line:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这些宏的实际效果，请从GitHub复制完整的`Chapter11/minmacros`目录（[https://packt.live/2TQHTjQ](https://packt.live/2TQHTjQ)）。在你的终端中，切换到`minmacros`目录。从那里，你可以从命令行运行以下命令：
- en: '[PRE65]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'If you''re on Windows, you''ll need to download a copy of `cljs.jar` from [https://packt.live/36m0O8q](https://packt.live/36m0O8q).
    Then, assuming that `cljs.jar` is in your working directory, you can run this
    command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Windows，你需要从[https://packt.live/36m0O8q](https://packt.live/36m0O8q)下载一份`cljs.jar`。然后，假设`cljs.jar`在你的工作目录中，你可以运行以下命令：
- en: '[PRE66]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In your Terminal, the output from `println` should appear before the REPL prompt:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的终端中，`println`的输出应该出现在REPL提示符之前：
- en: '![Figure 11.3: Output on the Terminal'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.3：终端输出'
- en: '](img/B14502_11_03.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_11_03.jpg)'
- en: 'Figure 11.3: Output on the Terminal'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.3：终端输出
- en: The second of these, `minmacros/macros.cljc`, is written just like any other
    Clojure namespace. This is, in fact, a requirement, since it will be compiled
    on the JVM. Even if the macros here target a JavaScript *runtime*, the macroexpansion
    code can't contain any JavaScript-specific code. However, the expanded code can
    contain ClojureScript-specific code, since it will be run in the browser or in
    an environment such as Node.js.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 其中第二个，`minmacros/macros.cljc`，就像任何其他 Clojure 命名空间一样编写。实际上，这是一个要求，因为它将在 JVM 上编译。即使这里的宏针对
    JavaScript **运行时**，宏展开代码也不能包含任何 JavaScript 特定的代码。然而，展开后的代码可以包含 ClojureScript 特定的代码，因为它将在浏览器或
    Node.js 等环境中运行。
- en: 'For example, using JavaScript''s native string functions inside your macro
    would not work. Consider this (admittedly contrived) example, where we try to
    use the JavaScript string method called `includes` as a test in the macroexpansion
    code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在宏定义中使用 JavaScript 的原生字符串函数是不行的。考虑以下（虽然有些人为）的例子，我们在宏展开代码中尝试使用名为 `includes`
    的 JavaScript 字符串方法作为测试：
- en: '[PRE67]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Java strings do not have an `includes` method, so when we try to invoke this
    macro at the REPL, we get an error:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: Java 字符串没有 `includes` 方法，所以当我们尝试在 REPL 中调用这个宏时，我们会得到一个错误：
- en: '[PRE68]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The Java-based ClojureScript compiler cannot use a JavaScript string method;
    thus, the macroexpansion fails.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 Java 的 ClojureScript 编译器不能使用 JavaScript 字符串方法；因此，宏展开失败。
- en: 'While using JavaScript-specific code during macroexpansion is impossible, it
    is perfectly fine to use a macro to create code that will only *run* on a JavaScript
    platform. Here''s an equally contrived macro that does just that:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在宏展开期间使用 JavaScript 特定的代码是不可能的，但使用宏创建仅在 JavaScript 平台上运行的代码是完全可行的。这里有一个同样人为的宏，它正是这样做的：
- en: '[PRE69]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In the REPL, we can define and call a function that returns either `"Found
    it!"` or `"Not here…"`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 中，我们可以定义并调用一个函数，该函数返回 `"Found it!"` 或 `"Not here…"`：
- en: '[PRE70]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: In practice, this kind of issue will rarely arise. It would be extremely rare
    for macroexpansion code to require some kind of help from the underlying platform.
    If you find yourself doing this, on either platform, it's probably a sign that
    you need to rethink what you're trying to accomplish with your macro. The point
    of these examples is to help illustrate how the details of the ClojureScript compilation
    process can be important when writing macros. When writing macros, it's always
    very important to distinguish between compile time and runtime; with ClojureScript,
    the distance between the two is much greater. Once these issues are accounted
    for, though, the actual process of writing macros in ClojureScript is identical
    to writing Clojure macros.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这类问题很少出现。宏展开代码需要底层平台帮助的情况极为罕见。如果你发现自己在这两个平台上都在这样做，那可能是一个迹象，表明你需要重新思考你试图通过宏实现的目标。这些例子的目的是帮助说明
    ClojureScript 编译过程的细节在编写宏时是如何重要的。在编写宏时，始终非常重要地区分编译时间和运行时；在 ClojureScript 中，两者之间的距离要大得多。一旦考虑到这些问题，ClojureScript
    中编写宏的实际过程与编写 Clojure 宏是相同的。
- en: Macro Hygiene
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 宏卫生
- en: Like most programming languages, Clojure provides a lot of resources for avoiding
    name collisions. Namespaces, `let` bindings, and lexical scope, all help to make
    it fairly difficult to override variables by choosing the wrong name. Because
    they operate in a different space, and at a different time, macros have the potential
    to go around some of those guardrails. **Macro hygiene** is the art of writing
    macros that avoid **variable capture**. Variable capture is what happens when
    a symbol produced by a macro coincides with a macro in the surrounding environment.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数编程语言一样，Clojure 提供了许多资源来避免名称冲突。命名空间、`let` 绑定和词法作用域都有助于使选择错误名称覆盖变量变得相当困难。因为它们在不同的空间和不同的时间操作，宏有绕过一些安全栏的可能性。"**宏卫生**"
    是编写避免 **变量捕获** 的宏的艺术。变量捕获发生在宏产生的符号与周围环境中的宏相同时。
- en: Note
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term **variable capture** has its origins in other languages of the Lisp
    family. Unlike Clojure, most Lisps do not have immutable data structures, so the
    word "variable" is perfectly appropriate. We'll continue to say "variable capture,"
    even though most Clojure "variables" aren't really variables.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 **变量捕获** 来自 Lisp 家族的其他语言。与 Clojure 不同，大多数 Lisp 语言没有不可变的数据结构，所以“变量”这个词非常合适。尽管大多数
    Clojure “变量”实际上并不是变量，我们仍将继续说“变量捕获”。
- en: 'Here''s a quick example. Earlier in this chapter, we tried to write a macro
    like this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个快速示例。在本章的早期，我们尝试编写一个这样的宏：
- en: '[PRE71]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This macro didn''t work. It produced this error:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏不起作用。它产生了这个错误：
- en: '[PRE72]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The reason for this was that the `s` parameter disappears after expansion.
    As a result, `(println s)` fails because, at runtime, there is no `s`. What if
    `s` is already defined, though? We can do the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是`s`参数在展开后消失了。结果，`(println s)`失败了，因为在运行时没有`s`。但是，如果`s`已经定义了呢？我们可以这样做：
- en: '[PRE73]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Even though there is no syntax error, this really is *wrong*. Depending on the
    context, this macro will not behave the same way. The real argument, "`Right`",
    is obscured by a variable in the environment, "`Wrong`". It's easy to imagine
    how code like this could produce wildly unpredictable results. The macro writer
    has no knowledge of or control over whatever `s` might be bound to in the environment
    where the macro is called.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有语法错误，但这实际上是非常错误的。根据上下文，这个宏的行为可能不会相同。真正的参数，“`Right`”，被环境中的变量“`Wrong`”所掩盖。很容易想象这样的代码可能会产生极其不可预测的结果。宏编写者对宏被调用时的环境中`s`可能绑定到什么没有任何了解或控制。
- en: 'The Clojure macro system provides some protection against this kind of problem.
    We''ve already seen one of them. The `syntax-quote` backtick causes symbols to
    be assigned to the namespace where the macro is defined:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure宏系统提供了一些防止这类问题的保护措施。我们已经看到了其中之一。`syntax-quote`反引号将符号分配到宏定义的命名空间中：
- en: '[PRE74]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This provides an initial degree of protection against variable capture since
    a namespaced symbol can't be confused with core Clojure functions or with local
    `let` bindings. The `let` macro, in fact, won't allow a namespaced symbol to be
    used as a binding.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种对变量捕获的初步保护，因为命名空间中的符号不会与核心Clojure函数或局部`let`绑定混淆。实际上，`let`宏不允许使用命名空间符号作为绑定。
- en: Note
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When looking at the expansion of a macro you are working on, if you see symbols
    that have been assigned to the current namespace, it's probably a sign that those
    symbols are vulnerable to variable capture.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在查看你正在工作的宏的展开时，如果你看到被分配给当前命名空间的符号，这可能是一个迹象，表明这些符号容易受到变量捕获的影响。
- en: 'Let''s try a slightly more realistic example. Here''s a macro that defines
    a `let`-like environment where the `body` parameter can be evaluated. This is
    a common structure for macros, where the macro sets up and possibly tears down
    a specialized environment. The environment might be a database connection, an
    open file or, like in this example, just a series of bindings that make it easier
    to write your code. This macro will take an integer and symbol and then provide
    an environment with automatic bindings for the integer as a string, as an integer,
    and as a Java `double`. The symbol parameter is then used to define the `-as-string`,
    `-as-int`, and `-as-double` bindings, which can be used in the code provided as
    the `body`:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试一个稍微更现实的例子。这是一个定义类似于`let`的环境的宏，其中`body`参数可以被评估。这是宏的常见结构，其中宏设置并可能拆除一个专门的环境。这个环境可能是一个数据库连接、一个打开的文件，或者像这个例子中一样，只是一系列绑定，这使得编写代码更容易。这个宏将接受一个整数和一个符号，然后提供一个环境，其中自动绑定整数为一个字符串、一个整数和一个Java
    `double`。符号参数用于定义`-as-string`、`-as-int`和`-as-double`绑定，这些绑定可以在提供的`body`代码中使用：
- en: '[PRE75]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In a simple case, the `let-int` macro could be used like this:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个简单的情况下，`let-int`宏可以这样使用：
- en: '[PRE76]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This result just shows that `my-int-as-string` is indeed defined and that the
    integer `5` has been coerced into a string.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果只是表明`my-int-as-string`确实被定义了，并且整数`5`已经被强制转换为字符串。
- en: 'Look what happens, though, when one of the internal bindings is already defined
    and is used in the macro parameter:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当其中一个内部绑定已经定义并在宏参数中使用时，看看会发生什么：
- en: '[PRE77]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Even when working with macros, 1,000 divided by 2 should be 500 and not 250!
    What happened? The problem here is that with a macro, the `(/ my-int-as-int 2)`
    parameter is not evaluated before being passed to the macro. The macro doesn''t
    "know" about the value 500\. It only "sees" the code that is present at compile
    time. The expanded version of this macro call provides a better view of what is
    happening:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在使用宏时，1000除以2应该是500，而不是250！发生了什么？这里的问题是，在宏中，`(/ my-int-as-int 2)`参数在传递给宏之前没有被评估。宏“不知道”500这个值。它“只看到”编译时存在的代码。这个宏调用展开的版本提供了更好的视角来了解正在发生的事情：
- en: '[PRE78]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: The first thing to notice is that `(/ my-int-as-int 2)` appears three times.
    When `my-int-as-double` is defined, the local binding, `my-int-as-int`, supersedes
    the original binding. If the original binding was 1,000, the local `my-int-as-int`
    is defined as 500\. When `my-int-as-double` is defined, `my-int-as-int` becomes
    500, which is then divided by two one more time.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是 `(/ my-int-as-int 2)` 出现了三次。当 `my-int-as-double` 被定义时，局部绑定 `my-int-as-int`
    会覆盖原始绑定。如果原始绑定是 1,000，那么局部的 `my-int-as-int` 被定义为 500。当 `my-int-as-double` 被定义时，`my-int-as-int`
    变为 500，然后再次除以二。
- en: This is a subtle variable capture bug that could have disastrous consequences.
    Most of the time, everything would work correctly. Then, from time to time, the
    results would be inexplicably incorrect. Staring for hours at the source code
    would not help since the actual bug is only visible when the code is expanded.
    While it may seem like a strange edge case, a bug like this could actually occur
    fairly easily with nested `let-number` macros.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个微妙的变量捕获错误，可能会产生灾难性的后果。大多数时候，一切都会正常工作。然后，偶尔，结果会变得无法解释地不正确。长时间盯着源代码看也不会有帮助，因为实际的错误只有在代码展开时才会显现。虽然这看起来像是一个奇怪的边缘情况，但这样的错误实际上在嵌套
    `let-number` 宏中很容易发生。
- en: Avoiding Variable Capture with Automatic Gensyms
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自动 gensyms 避免变量捕获
- en: 'Luckily, there is a solution for a macro such as `let-number`, which is to
    evaluate the argument only once and then store the result in a local binding that
    can then be used for further calculations:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，对于像 `let-number` 这样的宏，有一个解决方案，即只评估一次参数，然后将结果存储在局部绑定中，这样就可以用于进一步的计算：
- en: '[PRE79]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'In the first line of the `let` bindings, the calculation represented by `n`
    is performed and bound to `result#`. All of the following bindings then use `result#`
    to produce their particular versions: `string`, `integer`, `double`. This is a
    very good habit to have when writing macros: avoid calculating things twice.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `let` 绑定的第一行，由 `n` 表示的计算被执行并绑定到 `result#`。所有后续的绑定都使用 `result#` 来产生它们的特定版本：`string`、`integer`、`double`。在编写宏时养成避免重复计算的好习惯是非常好的。
- en: 'First, let''s make sure this works:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保这能正常工作：
- en: '[PRE80]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That's better. The `(/ my-int-as-int 2)` expression is only evaluated once and
    the result is correct now. Multiple evaluations of code inside a macro could have
    other unintended consequences if the repeated code has side effects.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。表达式 `(/ my-int-as-int 2)` 只被评估了一次，现在结果也是正确的。如果宏内部的重复代码有副作用，多次评估代码可能会产生其他未预料到的后果。
- en: 'There is one remaining question, though: why do we write `result#` instead
    of just `result`? This is an example of Clojure''s macro system helping us avoid
    other kinds of errors. The suffix on the `result` symbol has a special meaning
    when it''s used in a syntax-quoted expression. In those cases, Clojure''s syntax
    quoting transforms `result` into what is called a `let-number` macro, you won''t
    see a binding to a symbol named `result` or even `result#`. Instead, there will
    be something like `result__15090__auto__`. That''s a generated, unique symbol.
    Gensyms are a key component in Clojure''s macro system because, when used effectively,
    they prevent name collisions between symbols that have been produced by a macro
    and symbols present in the environment where the macro is called, or in code that
    is a macro argument. In the REPL, you can produce your own gensyms:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一个问题：为什么我们写 `result#` 而不是仅仅 `result`？这是一个 Clojure 宏系统帮助我们避免其他类型错误的例子。当在语法引用表达式中使用时，`result`
    符号的后缀有一个特殊的意义。在这种情况下，Clojure 的语法引用会将 `result` 转换为所谓的 `let-number` 宏，你不会看到绑定到名为
    `result` 或 `result#` 的符号。相反，会有类似 `result__15090__auto__` 的东西。这是一个生成的、唯一的符号。Gensyms
    是 Clojure 宏系统的一个关键组件，因为当有效地使用时，它们可以防止宏产生的符号与环境中的符号或宏参数中的代码中的符号发生名称冲突。在 REPL 中，你可以生成自己的
    gensyms：
- en: '[PRE81]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Each time, a different symbol is produced, unless the symbols are in the same
    syntax-quoted expression:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 每次都会产生不同的符号，除非这些符号在同一个语法引用表达式中：
- en: '[PRE82]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is what allows gensyms to be used to refer to the same thing. It can also
    be a limitation since, often, you need to use more than one syntax-quoted expression
    inside a macro. We'll show you how to deal with those cases a little later.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 gensyms 可以用来引用同一事物。这也可能是一个限制，因为通常你需要在宏内部使用多个语法引用表达式。我们稍后会展示如何处理这些情况。
- en: To understand the importance of this, imagine a version of `let-number` where
    the result of `n` was assigned to `result` without the `#` suffix. Because of
    this, the `result` binding would be available inside the code in the `body` parameter.
    Most of the time, this would not be a problem, as long as the `body` code did
    not use a value named `result`. If there was a collision, though, the direct consequence
    would be a very nasty bug.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点的重要性，想象一下 `let-number` 的一个版本，其中 `n` 的结果被分配给 `result` 而没有 `#` 后缀。由于这个原因，`result`
    绑定将可以在 `body` 参数内的代码中使用。大多数时候，这不会成为问题，只要 `body` 代码没有使用名为 `result` 的值。但如果发生冲突，直接后果将是非常棘手的错误。
- en: Consider this use of the macro while using `result` without the protection afforded
    by the `#` suffix. To do that, we need to insert the literal result symbol into
    the expanded code. This will require using a little macro trick where we unquote
    and then quote the symbol, like this `~'result`. The initial unquote suspends
    the syntax quoting and then the single quotation mark applies a standard quote
    that does not use namespacing.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `result` 而没有 `#` 后缀提供的保护时，请考虑这种宏的使用。为此，我们需要将字面结果符号插入到展开的代码中。这需要使用一点宏技巧，即先取消引用然后再次引用符号，如下所示
    `~'result`。初始的取消引用暂停了语法引用，然后单引号应用了一个不使用命名空间的常规引用。
- en: Note
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The unquote-quote pattern should generally be avoided because gensyms are much
    safer. However, a simple quoted symbol can be useful in certain cases, especially
    when a symbol is supposed to have a special syntactical meaning inside the macro,
    as we saw with the `|` in *Exercise 11.01*, *The and-ors Macro*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应避免使用取消引用-引用模式，因为 gensyms 要安全得多。然而，在某些情况下，简单的引用符号可能很有用，特别是当符号在宏内部应该具有特殊的语法意义时，正如我们在
    *练习 11.01*，*The and-ors Macro* 中看到的 `|` 一样。
- en: 'We get the following macro code:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到以下宏代码：
- en: '[PRE83]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Using this macro could be dangerous:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个宏可能会有危险：
- en: '[PRE84]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This would be extremely confusing. We expect the `result` in the initial `let`
    binding to be the same as the `result` in the `let-number` binding. Debugging
    this error would require exploring the inner workings of the macro and would probably
    be a long, painful process. Gensyms protect against this kind of problem and Clojure
    makes them easy to use.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这会非常令人困惑。我们期望初始 `let` 绑定中的 `result` 与 `let-number` 绑定中的 `result` 相同。调试这个错误需要探索宏的内部工作原理，这可能会是一个漫长而痛苦的过程。Gensyms
    可以防止这类问题，Clojure 也使得它们易于使用。
- en: Note
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Not all Lisps have automatic gensyms. In Common Lisp, macro writers have to
    call the `gensym` function explicitly. Clojure also has a `gensym` function, which
    can be used to create gensyms outside of a syntax-quoted environment. We'll use
    the `gensym` function ourselves a little later
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有的 Lisp 都有自动的 gensyms。在 Common Lisp 中，宏编写者必须显式调用 `gensym` 函数。Clojure 也有一个
    `gensym` 函数，可以在语法引用环境之外创建 gensyms。我们稍后会使用 `gensym` 函数。
- en: As a general rule, any bindings in a macro that are not part of the exposed
    interface should be defined with gensyms. In the `let-number` macro, bindings
    such as `my-int-as-string` are an exposed part of the interface and, as such,
    require real symbol names. Bindings such as `result#`, which only are used "behind
    the scenes" (at compile time), should be protected with gensyms.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，任何不是暴露接口部分的宏绑定都应该使用 gensyms 定义。在 `let-number` 宏中，如 `my-int-as-string`
    这样的绑定是接口的一部分，因此需要真实的符号名称。像 `result#` 这样的绑定仅在“幕后”使用（在编译时），应该使用 gensyms 进行保护。
- en: 'Exercise 11.04: Monitoring Functions'
  id: totrans-320
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11.04：监控函数
- en: In this exercise, we will write a macro for creating functions. The functions
    will be wrapped inside logic that adds some extra behavior to an otherwise ordinary
    function.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个创建函数的宏。这些函数将被包裹在添加了一些额外行为的逻辑中，而原本的函数是普通的。
- en: These days, you're working for a company that provides Software as a Service
    to other companies. Management wants to rethink the prices that are charged to
    customers. They want to know, at a very fine-grained level, which services are
    the most expensive to provide and which customers are consuming the most resources.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这些天，你为一家向其他公司提供软件即服务（Software as a Service）的公司工作。管理层希望重新思考向客户收取的价格。他们想知道，在非常细粒度的层面上，哪些服务提供成本最高，哪些客户消耗了最多的资源。
- en: Your job is to develop a system for logging the computation time of some of
    the important, high-level functions in the code base. At first, you thought that
    you would have to go through the entire code base and add timing and reporting
    logic every time one of these high-level functions is called. Then, you remembered
    macros. You've decided to write a proof-of-concept macro to show to your boss.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是开发一个系统来记录代码库中一些重要、高级函数的计算时间。一开始，你以为你不得不遍历整个代码库，并在每次调用这些高级函数时添加计时和报告逻辑。然后，你想起了宏。你已经决定写一个概念验证宏来向你的老板展示。
- en: The high-level functions you want to measure all have, among others, a `client-id`
    parameter. You'll use that parameter to provide feedback to the monitoring framework.
    One requirement is that the data will be sent, even if an exception is thrown.
    Collecting detailed error statistics will be useful for monitoring and diagnostics.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要衡量的所有高级函数都有，包括其他参数，一个`client-id`参数。你将使用该参数向监控框架提供反馈。一个要求是，即使抛出异常，数据也将被发送。收集详细的错误统计信息将有助于监控和诊断。
- en: 'The macro will be invoked instead of `defn` when defining the functions. In
    addition to the standard arguments to `defn`, the macro will also take a function
    that will be called to send data to the monitoring system. Let''s get started:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义函数时，将调用宏而不是`defn`。除了`defn`的标准参数外，宏还将接受一个函数，该函数将被调用来向监控系统发送数据。让我们开始吧：
- en: 'In a REPL, set up an outline for the macro:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中设置宏的概要：
- en: '[PRE85]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'This means that, when defining a function that needs to be monitored, we''ll
    write something like this, assuming that `send-to-framework` is a function that
    has already been defined:'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着，当定义一个需要监控的函数时，我们将编写如下内容，假设`send-to-framework`是一个已经定义好的函数：
- en: '[PRE86]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Calling the function will be no different from calling any other function,
    as long as there is a `client-id` argument:'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调用该函数将与调用任何其他函数没有区别，只要有一个`client-id`参数：
- en: '[PRE87]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Establish the basic layout of the macro''s internals. There will be two parts:
    on the outside, some compile-time `let` bindings, and on the inside, a syntax-quoted
    `(defn…)` expression:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立宏内部的基本布局。它将有两个部分：在外部，一些编译时的`let`绑定，在内部，一个语法引用的`(defn…)`表达式：
- en: '[PRE88]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: The outer `let` bindings will set up some of the values that will be used in
    the more "template"-like `defn` part.
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 外部的`let`绑定将设置一些将在更“模板”式的`defn`部分中使用的值。
- en: 'We''ve placed the `fn-name`, unquoted, and an empty parameter list inside the
    call to `defn`. Even if it doesn''t do anything yet, the macro should already
    compile, and you should be able to use it to define a function:'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在`defn`调用中放置了未引用的`fn-name`和一个空参数列表。即使它目前还没有做任何事情，宏应该已经可以编译，你应该能够用它来定义一个函数：
- en: '[PRE89]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As you already know, the Clojure `defn` macro allows us to define multiple
    arities for the same function. This really means that there are two different
    structures that a function definition can have. First there is the single arity
    that we use most of the time:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所知，Clojure的`defn`宏允许我们为同一个函数定义多个参数数量。这实际上意味着函数定义可以有两种不同的结构。首先是我们大多数时候使用的单个参数数量：
- en: '[PRE90]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Multiple arity functions have several "bodies." Each "body" is a list that
    starts out with the argument list, which is specific to that arity, and then includes
    the corresponding code:'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多参数函数有几个“主体”。每个“主体”都是一个以参数列表开头的列表，该参数列表特定于该参数数量，然后包括相应的代码：
- en: '[PRE91]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Because we want `defmonitored` to act as a replacement for `defn`, we need to
    be able to handle these two different structures.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因为我们要让`defmonitored`充当`defn`的替代品，所以我们需要能够处理这两种不同的结构。
- en: Much of what we are going to do now requires us to have access to the code inside
    each of the function bodies, if there are multiple arities. To avoid having to
    deal with two separate cases, that is, single and multiple arities, we are going
    to check to see which kind we have. If we have just one arity, we will wrap the
    argument list and the function body in a list so that it has the same structure
    as the multiple arity variety.
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们现在将要做的许多事情都需要我们能够访问每个函数主体内部的代码，如果有多个参数数量。为了避免处理两个不同的案例，即单参数和多个参数，我们将检查我们有哪些类型。如果我们只有一个参数数量，我们将把参数列表和函数主体包裹在一个列表中，使其具有与多个参数数量相同的结构。
- en: 'A function like this is correct, even if it only has one arity:'
  id: totrans-343
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这样的函数是正确的，即使它只有一个参数数量：
- en: '[PRE92]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'To do this, we add a `vector?` check:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要添加一个`vector?`检查：
- en: '[PRE93]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When the first item in `fn-content` is an argument list, we use syntax quoting,
    and then `unquote`, to enclose the function body in a list.
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`fn-content`的第一个项目是一个参数列表时，我们使用语法引用，然后`unquote`来将函数体包含在一个列表中。
- en: To handle the multiple arities, we need to deal with each function body separately.
    This sounds like a good time to write a function that can be called on each one.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理多种参数数量，我们需要分别处理每个函数体。这似乎是编写一个可以应用于每个函数体的函数的好时机。
- en: We'll call the `wrap-fn-body` function to deal with this. Even though this is
    a function and not a macro, it will be called at compile time, so all our macro-writing
    skills are still applicable here.
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将调用`wrap-fn-body`函数来处理这个问题。即使这是一个函数而不是宏，它也会在编译时被调用，所以我们的所有宏编写技巧在这里仍然适用。
- en: 'The function will repeat the basic structure of the macro: `let` bindings on
    the outside and a syntax-quoted "template" on the inside. This time, we''ll start
    with the bindings:'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数将重复宏的基本结构：外部的`let`绑定和内部的语法引用“模板”。这次，我们将从绑定开始：
- en: '[PRE94]'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We know that the first item in a function body is the argument list. That's
    easy to extract, just like `fn-body`, which is everything that's not the argument
    list.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们知道函数体中的第一个项目是参数列表。这很容易提取，就像`fn-body`一样，它是一切不是参数列表的东西。
- en: 'Add a check for the `client-id` parameter in the argument list. Our goal is
    to be able to measure function use per client, so we absolutely need a `client-id`
    argument. If it''s missing, the code should fail. To do this, we''ll simply check
    the `arg-list` binding:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在参数列表中添加对`client-id`参数的检查。我们的目标是能够按客户端测量函数的使用情况，所以我们绝对需要一个`client-id`参数。如果它缺失，代码应该失败。为此，我们将简单地检查`arg-list`绑定：
- en: '[PRE95]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: We can safely use the "unquote/quote" pattern here on the `client-id` symbol,
    rather than a gensym, because we know the `client-id` will not be picked up accidentally
    from the surrounding code, precisely because it will be in the argument list.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以安全地在这里使用“unquote/quote”模式在`client-id`符号上，而不是生成符号，因为我们知道`client-id`不会意外地从周围的代码中提取出来，正是因为它会在参数列表中。
- en: 'It''s finally time to write the "template" part. This is a longer block of
    code, but it is really quite simple. We''ll come back and explain some of the
    quoting strategies here later:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终于到了编写“模板”部分的时候了。这是一段较长的代码块，但实际上非常简单。我们稍后会回来解释这里的一些引用策略：
- en: '[PRE96]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The overall pattern is fairly simple. The heart of the function is in the inner
    `let` binding, where, in the expanded code, we will bind the `result#` gensym
    to the output resulting from calling the actual code, which is still in `fn-body`.
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 整体模式相当简单。函数的核心在于内部的`let`绑定，在展开的代码中，我们将`result#`生成符号绑定到实际代码调用产生的输出，该代码仍然在`fn-body`中。
- en: Once we have that result, we send off some information to `tx-fn` by using `System/nanoTime`
    as our `:end-time`. This "heart" of the function is then wrapped in two things,
    the first of which is a `try`/`catch` form. If there's an exception, we send a
    slightly different message via `tx-fn`. And finally, the outer `let` binding is
    where we establish the `start-time#` binding so that we can also report when the
    function started.
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦我们得到这个结果，我们就会通过使用`System/nanoTime`作为我们的`:end-time`来向`tx-fn`发送一些信息。这个函数的“核心”随后被两个东西包裹起来，第一个是一个`try`/`catch`形式。如果有异常，我们会通过`tx-fn`发送一个稍微不同的消息。最后，外部的`let`绑定是我们建立`start-time#`绑定的地方，这样我们也可以报告函数开始的时间。
- en: 'Note that we were required to use several automatic gensyms: `start-time#`,
    `end-time#`, `results#`, and even `e#`, the exception.'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们被要求使用几个自动生成符号：`start-time#`、`end-time#`、`results#`，甚至还有`e#`，异常。
- en: Put it all back together.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有这些放在一起。
- en: 'Here''s the complete `wrap-fn-body` function:'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是完整的`wrap-fn-body`函数：
- en: '[PRE97]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now, call `wrap-fn-body` from the final `defmonitored` macro. You can do this
    by mapping over the list of function bodies. Naturally, `map` will wrap them in
    a list, which we don''t want, so we "unquote-splice" (`~@`) the list:'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，从最终的`defmonitored`宏中调用`wrap-fn-body`。你可以通过映射函数体列表来完成这个操作。自然地，`map`会将它们包裹在一个列表中，而我们不想这样，所以我们“unquote-splice”(`~@`)列表：
- en: '[PRE98]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Test the macro, using `println` as the reporting function. First, define a
    simple function:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试这个宏，使用`println`作为报告函数。首先，定义一个简单的函数：
- en: '[PRE99]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `my-func` function seems to work:'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`my-func`函数似乎工作正常：'
- en: '[PRE100]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let''s try some problematic cases. We''ll start by throwing an exception:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们尝试一些有问题的案例。我们首先抛出一个异常：
- en: '[PRE101]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'The output is as follows:'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 11.4: An exception, timed, recorded, and reported'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.4：一个异常，计时，记录和报告'
- en: '](img/B14502_11_04.jpg)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_11_04.jpg)'
- en: 'Figure 11.4: An exception, timed, recorded, and reported'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4：一个异常，计时、记录和报告
- en: What about if we try to define a function that doesn't have a `client-id` argument?
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试定义一个没有 `client-id` 参数的函数会怎样呢？
- en: '[PRE102]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The output is as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![Figure 11.5: The exception we threw during macroexpansion appears as a syntax
    error'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.5：在宏展开期间抛出的异常表现为语法错误'
- en: '](img/B14502_11_05.jpg)'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_11_05.jpg)'
- en: 'Figure 11.5: The exception we threw during macroexpansion appears as a syntax
    error'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：在宏展开期间抛出的异常表现为语法错误
- en: The `defmonitored` macro shows how macros can be used to modify Clojure itself.
    The situation called for a `defn` with extra capabilities, so that is what we
    wrote. It would, of course, be possible to accomplish the same thing by wrapping
    functions inside a "timing and reporting" function. But this would be much more
    intrusive than simply writing `defmonitored` instead of `defn`.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`defmonitored` 宏展示了如何使用宏来修改 Clojure 本身。这种情况下需要一个具有额外功能的 `defn`，所以我们就是这样写的。当然，通过将函数包裹在一个“计时和报告”函数内部，也可以完成相同的事情。但这样做会比简单地用
    `defmonitored` 替换 `defn` 要侵入性大得多。'
- en: When to Use Manual gensyms
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用手动 gensyms
- en: 'When using Clojure''s automatic gensyms, such as `result#`, it''s important
    to remember that they are a feature of syntax quoting. Writing `result#` outside
    of a syntax-quoted expression won''t throw an exception, but none of the magic
    happens:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Clojure 的自动 gensyms，如 `result#` 时，重要的是要记住它们是语法引用的一个特性。在语法引用表达式之外写入 `result#`
    不会抛出异常，但不会有任何魔法发生：
- en: '[PRE103]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'On the other hand, if we syntax-quote `my-number#`, the "magic" comes back:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们语法引用 `my-number#`，那种“魔法”就会回来：
- en: '[PRE104]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'This will usually not be a problem. It''s easy to remember that automatic gensyms
    only work inside syntax quoting. There is another important thing to remember,
    though: an automatic gensym is only valid inside the scope of the syntax-quoted
    expression where it was originally defined. This means that, with nested syntax-quoted
    expressions, a `result#` in the outer expression will not expand to the same gensym
    as a `result#` in the inner expression. Let''s try an example.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常不会成为问题。记住自动 gensyms 只在语法引用内部工作是很简单的。不过，还有另一件重要的事情需要记住：自动 gensym 只在它最初定义的语法引用表达式的范围内有效。这意味着，在嵌套的语法引用表达式中，外部表达式中的
    `result#` 不会展开成与内部表达式中的 `result#` 相同的 gensym。让我们通过一个例子来试试。
- en: 'Consider this little macro:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这个小程序：
- en: '[PRE105]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This macro is supposed to allow us to define multiple functions inside a `let`
    block so that each function refers, via a **closure**, to the same binding. We
    want it to produce code that, conceptually, at least, looks roughly like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 这个宏应该允许我们在 `let` 块内部定义多个函数，以便每个函数通过 **闭包** 引用相同的绑定。我们希望它生成的代码，至少在概念上，看起来大致如下：
- en: '[PRE106]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'To define those functions, we would write this:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义这些函数，我们会写出这个：
- en: '[PRE107]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The `symbol-fn-pairs` argument is expected to be an alternating series of symbols
    that will become the names of the functions, and some will become functions as
    well. We then use `partition-by` in the body of the macro to organize this list
    into pairs. (In production code, we would probably want to check that `symbol-fn-pairs`
    contains an even number of items, just as `let` complains if there is an odd number
    of items in its bindings.)
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '`symbol-fn-pairs` 参数预期是一个交替序列的符号，这些符号将成为函数的名称，其中一些也将成为函数。然后我们在宏的主体中使用 `partition-by`
    来组织这个列表成对。（在生产代码中，我们可能希望检查 `symbol-fn-pairs` 是否包含偶数个项，就像 `let` 如果其绑定中有奇数个项会抱怨一样。）'
- en: 'Let''s see if this macro works as advertised:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个宏是否按预期工作：
- en: '[PRE108]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Oh no! What happened?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，不！发生了什么？
- en: Before we use `macroexpand` to start debugging, we can tell that the problem
    is related in some way to the `v#` binding because the `v__14896__auto__` gensym
    is prefixed with a `v`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用 `macroexpand` 开始调试之前，我们可以确定问题与 `v#` 绑定有关，因为 `v__14896__auto__` gensym
    前缀是 `v`。
- en: 'Macro expansions are hard to read, especially when there are a lot of gensyms,
    which are, let''s face it, hardly things of beauty when expanded. Start by trying
    to find the symbol mentioned in the syntax error message. We''ll use `macroexpand-1`
    here, to avoid expanding the `let` and `defn` macros:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 宏展开很难阅读，尤其是在有很多 gensyms 的情况下，坦白说，当它们展开时，几乎算不上是美观的东西。首先尝试找到语法错误消息中提到的符号。在这里，我们将使用
    `macroexpand-1` 来避免展开 `let` 和 `defn` 宏：
- en: '[PRE109]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The problem here is that, in the initial `let` binding, `v#` becomes `v__14897__auto__`.
    Later, inside each of the function definitions, we want to use that binding, but
    unfortunately, in each of the functions, `v#` has been replaced with a slightly
    different gensym, which is `v__14896__auto__`. Suddenly, the syntax error makes
    more sense: in each function, we''re trying to use a non-existent binding.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题在于，在初始的`let`绑定中，`v#`变成了`v__14897__auto__`。后来，在函数定义的内部，我们想要使用那个绑定，但不幸的是，在每个函数中，`v#`已经被替换成了一个稍微不同的gensym，即`v__14896__auto__`。突然，语法错误变得更有意义：在每个函数中，我们试图使用一个不存在的绑定。
- en: Why did `v#` fail in this case? The problem here is that we have two separate
    syntax-quoted expressions. The first is the top-level `let`, where `v#` is used
    initially. Then, we use `unquote-splice` to splice the list of functions into
    the `let` expression. Inside the anonymous function that's passed to `map`, we
    use the syntax-quoting backtick one more time to return the `defn` form. And this
    is where we get into trouble. Because we are no longer in the same syntax-quoted
    expression, `v#` does not expand to the same gensym. As a result, the two symbols
    are treated as totally separate values and we get a syntax error.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么在这个情况下`v#`失败了？这里的问题是，我们有两个独立的语法引用表达式。第一个是顶级的`let`，其中`v#`最初被使用。然后，我们使用`unquote-splice`将函数列表拼接到`let`表达式中。在传递给`map`的匿名函数内部，我们再次使用语法引用的背单引号来返回`defn`形式。而且这就是我们遇到麻烦的地方。因为我们不再处于同一个语法引用表达式中，`v#`不会展开到相同的gensym。结果，这两个符号被当作完全不同的值来处理，我们得到了一个语法错误。
- en: 'This is a time when we can''t use automatic gensyms. Instead, we''ll have to
    do this the old-fashioned way and use the `gensym` function ourselves. Here''s
    how:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们不能使用自动gensym的时候。相反，我们将不得不以老式的方式来做这件事，并亲自使用`gensym`函数。下面是如何做的：
- en: '[PRE110]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: The primary difference here is that we've wrapped the body of the first version
    of the macro in a separate `let` expression that is not quoted. This means that
    it will be present at compile time but will disappear at runtime in the expanded
    code. In this outer `let` expression, we call `gensym` and assign its value to
    `common-val-gensym`. At compile time, we'll refer to the gensym with this symbol.
    Because our `let` expression wraps the entire body of the macro, `common-val-gensym`
    will have the same value throughout the entire macro.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里的主要区别在于，我们将宏的第一版本的主体包裹在一个单独的未引用的`let`表达式中。这意味着它将在编译时存在，但在展开的代码中将在运行时消失。在这个外部的`let`表达式中，我们调用`gensym`并将它的值赋给`common-val-gensym`。在编译时，我们将使用这个符号来引用gensym。因为我们的`let`表达式包裹了整个宏的主体，所以`common-val-gensym`在整个宏中都将保持相同的值。
- en: 'Let''s test it:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下：
- en: '[PRE111]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Any reasonably complex macro will likely have more than one syntax-quoted expression,
    so knowing when to manually create and assign gensyms can be important. This knowledge
    can help avoid some hard-to-debug situations where your code looks correct but
    just doesn't work.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 任何相对复杂的宏都可能包含多个语法引用表达式，因此知道何时手动创建和分配gensym可能很重要。这种知识可以帮助避免一些难以调试的情况，在这些情况下，你的代码看起来是正确的，但就是不起作用。
- en: 'As a side note, the `fn-context` macro could easily be replaced with a functional
    solution by using the `partial` function. Remember, `partial` takes a function
    and one or more arguments and returns a function identical to the original, except
    that the first one or more arguments are already "filled in." Thus, instead of
    using a macro and `defn` forms, we can simply define new functions using `def`
    and `partial`:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条旁注，`fn-context`宏可以通过使用`partial`函数轻松地被功能解决方案所替代。记住，`partial`接受一个函数和一个或多个参数，并返回一个与原始函数相同的函数，除了第一个一个或多个参数已经被“填充”了。因此，而不是使用宏和`defn`形式，我们可以简单地使用`def`和`partial`来定义新的函数：
- en: '[PRE112]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The possibilities offered by functional programming in Clojure are such that
    it is fairly rare to find a problem, in day-to-day coding, that can only be expressed
    as a macro. Authors of libraries will tend to use macros slightly more often,
    for those times when it is important to have a very clear interface for some code.
    Perhaps the greatest advantage of Clojure macros is that most of the time, we
    don''t need to write them: either library authors have already done so or there
    is a solution on the functional side. And then, of course, if we really must write
    a macro, Clojure provides some excellent tools for doing so.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 函数式编程提供的可能性如此之大，以至于在日常编码中，几乎很少遇到只能用宏来表示的问题。库的作者倾向于在需要有一个非常清晰的代码接口时稍微更频繁地使用宏。Clojure
    宏的最大优势可能是，大多数时候，我们不需要编写它们：要么库的作者已经这样做了，要么在函数式方面有一个解决方案。当然，如果我们真的必须编写一个宏，Clojure
    提供了一些非常出色的工具来完成这项工作。
- en: 'In this chapter, we''ve taken a close look at several of the most common traps
    in macro writing. By taking these into consideration, you should be able to write
    effective macros. They should also serve as a reminder of why macros should be
    avoided when it is convenient to do so: writing and debugging macros can be a
    difficult and error-prone task. In the right circumstances, macros can be an extremely
    powerful tool for removing boilerplate and other forms of repetition from source
    code.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们仔细研究了宏编写中最常见的几个陷阱。通过考虑这些因素，你应该能够编写有效的宏。它们还应该作为提醒，为什么在方便的时候应该避免使用宏：编写和调试宏可能是一项困难且容易出错的任务。在适当的条件下，宏可以是一个非常强大的工具，用于从源代码中删除样板代码和其他重复形式。
- en: 'Activity 11.01: A Tennis CSV Macro'
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 11.01：网球 CSV 宏
- en: 'In some of the earlier chapters, we worked with tennis data contained in CSV
    files. Each time, we used a standard Clojure macro called `with-open`, and each
    time, we followed an almost identical pattern where the file''s contents are threaded
    (with the `->>` macro) through a series of transformations:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些早期的章节中，我们处理了包含在 CSV 文件中的网球数据。每次，我们都使用一个标准的 Clojure 宏 `with-open`，并且每次都遵循几乎相同的模式，其中文件的
    内容通过 `->>` 宏传递给一系列转换：
- en: Read the contents using the `clojure.data.csv` library's `read-csv` function.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `clojure.data.csv` 库的 `read-csv` 函数读取内容。
- en: Transform each line from the input file into a map using the `semantic-csv`
    library's `mappify` function.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `semantic-csv` 库的 `mappify` 函数将输入文件的每一行转换成一个映射。
- en: Cast some of the fields to numeric values using `semantic-csv`'s `cast-with`
    function.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `semantic-csv` 的 `cast-with` 函数将一些字段转换为数值类型。
- en: Remove some of the unnecessary data fields by using `map` to call `select-keys`
    on each item in the dataset.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用 `map` 调用 `select-keys` 对数据集中的每个项目进行选择，删除一些不必要的字段。
- en: End with a call to `doall` to make sure we avoid returning a lazy sequence that
    would not be able to be completed once the file had been closed.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `doall` 函数调用结束，以确保我们避免返回一个一旦文件关闭就无法完成的惰性序列。
- en: Each of these steps added some repetitious boilerplate to your code. The result
    is that each time you want to write a function that analyzes one of these CSV
    files, you end up repeating the same code over and over again, which is tedious
    and error-prone to write, and hard to read because the important logic in your
    code is buried in boilerplate.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤中的每一个都给你的代码添加了一些重复的样板。结果是，每次你想编写一个分析这些 CSV 文件之一的函数时，你都会重复相同的代码，这既繁琐又容易出错，而且难以阅读，因为你的代码中的重要逻辑被埋在样板代码中。
- en: Due to the success of the tennis data on the data-driven sports journalism website
    you work for, you now write a lot of functions with this identical pattern. You've
    decided it's time to make your life easier by cleaning up this code with a nice
    macro called `with-tennis-csv`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你工作的数据驱动体育新闻网站上网球数据的成功，你现在编写了很多具有这种相同模式的函数。你已经决定是时候通过一个名为 `with-tennis-csv`
    的良好宏来简化你的生活，以清理这段代码。
- en: Your goal is to write a macro called `with-tennis-csv` that will encapsulate
    most or all of the repetitive steps for accessing the CSV data.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目标是编写一个名为 `with-tennis-csv` 的宏，它将封装访问 CSV 数据的大部分或所有重复步骤。
- en: Interface Design
  id: totrans-424
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口设计
- en: 'The macro should accept the following as arguments:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 该宏应接受以下作为参数：
- en: The CSV filename (a string).
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CSV 文件名（一个字符串）。
- en: The mappings from field names to types for `cast-with` (a map of keywords to
    functions).
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cast-with` 的字段名到类型的映射（一个关键字到函数的映射）。'
- en: A list of keywords to keep. If an empty list is supplied, all the keywords will
    be kept.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要保留的关键字列表。如果提供了空列表，则保留所有关键字。
- en: An arbitrary number of Clojure forms. These forms must accept and return a list
    of maps.
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任意数量的 Clojure 表达式。这些表达式必须接受并返回一个映射列表。
- en: 'The Clojure forms will be inserted in the middle of the `->>` chain of expressions:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure 表达式将被插入到 `->>` 表达式链的中间：
- en: '![Figure 11.6: Inserting the Clojure form'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.6：插入 Clojure 表达式'
- en: '](img/B14502_11_06.jpg)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_11_06.jpg)'
- en: 'Figure 11.6: Inserting the Clojure form'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：插入 Clojure 表达式
- en: The macro caller will supply the forms that will be placed inside the chain
    of transformations.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 宏调用者将提供将被放置在转换链中的表单。
- en: Because the Clojure forms will be used inside a double-arrow threading macro,
    `->>` their final argument must be omitted.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Clojure 表达式将在双箭头串联宏内部使用，所以它们的最终参数必须省略。
- en: 'The following `blowout` function illustrates a possible use of the macro you
    want to write. The function takes a CSV file path and a threshold and then returns
    a list of matches where the winner won by more than `threshold` games. The results
    are narrowed to three fields: the names of the two players and the number of games
    by which the winner defeated the loser:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `blowout` 函数展示了你想要编写的宏的可能用途。该函数接收一个 CSV 文件路径和一个阈值，然后返回一个匹配列表，其中胜者通过超过 `threshold`
    场比赛获胜。结果被缩小到三个字段：两位选手的姓名和胜者击败败者的比赛数：
- en: '[PRE113]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Implementation
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: The central challenge here is making sure that the forms are correctly inserted
    into the `->>` threading macro.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要挑战是确保表单被正确地插入到 `->>` 串联宏中。
- en: 'Make sure that none of the arguments are evaluated more than once inside the
    macro:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在宏内部没有对任何参数进行多次评估：
- en: Start by determining what the call to `with-tennis-csv` should expand to in
    the preceding example.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，确定在先前的例子中 `with-tennis-csv` 的调用应该扩展成什么样子。
- en: Set up your project with the necessary dependencies in a `deps.edn` file and
    require the necessary libraries in a `tennis-macro` namespace.
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `deps.edn` 文件设置你的项目，并在 `tennis-macro` 命名空间中引入必要的库。
- en: Determine what the arguments to your macro will be. Don't forget that it should
    accept an arbitrary number of forms to be threaded.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定你的宏的参数将是什么。别忘了它应该接受任意数量的要串联的表单。
- en: In your macro, as a syntax-quoted "template," insert all the parts of the target
    code that will always be present, no matter how the macro is called.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的宏中，作为一个语法引用的“模板”，插入目标代码中始终存在的所有部分，无论宏如何调用。
- en: Insert the expressions to be threaded.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 插入要串联的表达式。
- en: Find a way to only apply `select-keys` if keys have been supplied and can be
    selected.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到一个方法，只有在提供了键并且可以选中时才应用 `select-keys`。
- en: 'To test your macro, you can use the CSV files we''ve been using all along:
    [https://packt.live/2Rn7PSx](https://packt.live/2Rn7PSx).'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的宏，你可以使用我们一直在使用的 CSV 文件：[https://packt.live/2Rn7PSx](https://packt.live/2Rn7PSx)。
- en: Note
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 733.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 733 页找到。
- en: Summary
  id: totrans-450
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we've explored Clojure's macro system, as well as many of the
    issues surrounding macros. By now, you should have a grasp of the fundamental
    concepts of macros, starting with the difference between compile-time and runtime
    evaluation, and have a mental model that will allow you to move on to writing
    your own macros if necessary, or to understand macros that have been written by
    others. The problems of macro hygiene, variable capture, and double evaluation
    are at the heart of the macro writing process. Knowing all of this will help you
    write macros, read macros, and, most of all, decide when to write a macro and
    when not to.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Clojure 的宏系统，以及许多与宏相关的问题。到现在，你应该已经掌握了宏的基本概念，从编译时和运行时评估的区别开始，并有一个心理模型，这将允许你在必要时编写自己的宏，或者理解他人编写的宏。宏的卫生问题、变量捕获和双重评估是宏编写过程的核心。了解所有这些将帮助你编写宏、阅读宏，最重要的是，决定何时编写宏以及何时不编写。
- en: Regardless of whether or not you go on to use macros to write your own **Domain-Specific
    Languages** (**DSL**) in Clojure, you'll already benefit from Clojure macros.
    The flexibility they provide allows Clojure to be extended by library authors
    in ways that would simply be impossible without macros. Many commonly used Clojure
    libraries, such as the Ring HTTP server, which you'll learn about in *Chapter
    14*, *HTTP with Ring*, make extensive use of macros to make life simpler for developers.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否打算在 Clojure 中使用宏来编写自己的**领域特定语言**（**DSL**），你都将从 Clojure 宏中受益。它们提供的灵活性使得库作者能够以没有宏就无法实现的方式扩展
    Clojure。许多常用的 Clojure 库，例如你将在第 14 章“使用 Ring 的 HTTP”中学习的 Ring HTTP 服务器，都广泛地使用了宏来简化开发者的工作。
- en: 'In the next chapter, we are going to explore another one of Clojure''s strong
    points: dealing with concurrency.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨 Clojure 的另一个强项：处理并发。
