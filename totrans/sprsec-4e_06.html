<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer051">
<h1 class="chapter-number" id="_idParaDest-132"><a id="_idTextAnchor180"/>6</h1>
<h1 id="_idParaDest-133"><a id="_idTextAnchor181"/>LDAP Directory Services</h1>
<p>In this chapter, we will review the <strong class="bold">Lightweight Directory Access Protocol</strong><strong class="source-inline"> </strong>(<strong class="bold">LDAP</strong>) and learn <a id="_idIndexMarker330"/>how it can be integrated into a Spring Security-enabled application to provide authentication, authorization, and <span class="No-Break">user information.</span></p>
<p>During the course of this chapter, we will cover the <span class="No-Break">following topics:</span></p>
<ul>
<li>Learning some of the basic concepts related to the LDAP protocol and <span class="No-Break">server implementations</span></li>
<li>Configuring a self-contained LDAP server within <span class="No-Break">Spring Security</span></li>
<li>Enabling LDAP authentication <span class="No-Break">and authorization</span></li>
<li>Understanding the model behind LDAP search and <span class="No-Break">user matching</span></li>
<li>Retrieving additional user details from standard <span class="No-Break">LDAP structures</span></li>
<li>Differentiating between LDAP authentication methods and evaluating the pros and cons of <span class="No-Break">each type</span></li>
<li>Explicitly configuring Spring Security LDAP using Spring <span class="No-Break">bean declarations</span></li>
<li>Connecting to external <span class="No-Break">LDAP directories</span></li>
<li>Exploring the built-in support for <span class="No-Break">Microsoft AD</span></li>
<li>We will also explore how to customize Spring Security for more flexibility when dealing with custom <span class="No-Break">AD deployments</span></li>
</ul>
<p>This chapter’s code in action link is <span class="No-Break">here: </span><a href="https://packt.link/f2tf1"><span class="No-Break">https://packt.link/f2tf1</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-134"><a id="_idTextAnchor182"/>Understanding LDAP</h1>
<p>LDAP has its <a id="_idIndexMarker331"/>roots in logical directory models dating back over 30 years, conceptually akin to a combination of an organizational chart and an address book. Today, LDAP is used more and more to centralize corporate user information, partition thousands of users into logical groups, and allow unified sharing of user information between many <span class="No-Break">disparate systems.</span></p>
<p>For security purposes, LDAP is quite commonly used to facilitate centralized username and password authentication—user credentials are stored in the LDAP directory, and authentication requests can be made against the directory on the user’s behalf. This eases management for administrators, as user credentials—login ID, password, and other details—are stored in a single location in the LDAP directory. Additionally, organizational information, such as group or team assignments, geographic location, and corporat<a id="_idTextAnchor183"/>e hierarchy membership, are defined based on the user’s location in <span class="No-Break">the directory.</span></p>
<h2 id="_idParaDest-135"><a id="_idTextAnchor184"/>LDAP</h2>
<p>At this point, if you have never used <a id="_idIndexMarker332"/>LDAP before, you may be wondering what it is. We’ll illustrate a sample LDAP schema with a screenshot from the Apache Directory Server <span class="No-Break">example directory:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<img alt="Figure 6.1 – Example of LDAP directory structure" height="352" src="image/B21757_06_01.jpg" width="506"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Example of LDAP directory structure</p>
<p>Starting at a particular user entry for <strong class="source-inline">uid=admin1@example.com</strong> (highlighted in the preceding screenshot), we can infer the organizational membership of <strong class="source-inline">admin1</strong> by starting at this node in the tree and moving upward. We can see that the user <strong class="source-inline">aeinstein</strong> is a member of the <strong class="source-inline">users</strong> organizational unit (<strong class="source-inline">ou=users</strong>), which itself is a part of the <strong class="source-inline">example.com</strong> domain (the abbreviation <strong class="source-inline">dc</strong> shown in the preceding screenshot stands<a id="_idIndexMarker333"/> for <span class="No-Break"><strong class="bold">domain component</strong></span><span class="No-Break">).</span></p>
<p>Preceding this are the organizational elements (<strong class="source-inline">DIT</strong> and <strong class="source-inline">Root</strong> <strong class="source-inline">DSE</strong>) of the LDAP tree itself, which don’t concern us in the context of Spring Security. The position of the user <strong class="source-inline">aeinstein</strong> in the<a id="_idIndexMarker334"/> LDAP hierarchy is semantically and definitively meaningful—you can imagine a much more complex hierarchy easily illustrating the organizational and departmental boundaries of a <span class="No-Break">huge organization.</span></p>
<p>The complete top-to-bottom path formed by walking down the tree to an individual leaf node forms a string composed of all intervening nodes along the way, as with the node path of <strong class="source-inline">admin1</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
uid=admin1,ou=users,dc=example,dc=com</pre> <p>The preceding node path is unique and is known as a node’s <strong class="bold">Distinguished Name</strong> (<strong class="bold">DN</strong>). The DN is akin to<a id="_idIndexMarker335"/> a database primary key, allowing a node to be uniquely identified and located in a complex tree structure. We’ll see a node’s DN used extensively throughout the authentication and searching process with Spring Security <span class="No-Break">LDAP integration.</span></p>
<p>Note that there are several other users listed at the same level of organization as <strong class="source-inline">admin1</strong>. All of these users are assumed to be within the same organizational position as <strong class="source-inline">admin1</strong>. Although this example organization is relatively simple and flat, the structure of LDAP is arbitrarily flexible, with many levels of nesting and logical <span class="No-Break">organization possible.</span></p>
<p>Spring Security LDAP support is assisted by the<a id="_idIndexMarker336"/> Spring LDAP module (<a href="https://spring.io/projects/spring-ldap">https://spring.io/projects/spring-ldap</a>), which is a separate project from the core Spring Framework and Spring Security projects. It’s considered to be stable and provides a he<a id="_idTextAnchor185"/>lpful set of wrappers around the standard Java <span class="No-Break">LDAP functionality.</span></p>
<h3>Common LDAP attribute names</h3>
<p>Each entry in the tree is defined <a id="_idIndexMarker337"/>by one or more object classes. An object class is a logical unit of organization, grouping a set of semantically related attributes. By declaring an entry in the tree as an instance of a particular object class, such as a person, the organizer of the LDAP directory can provide users of the directory with a clear indication of what each element of the <span class="No-Break">directory represents.</span></p>
<p>LDAP has a rich set <a id="_idIndexMarker338"/>of standard schemas covering the available LDAP object classes and their applicable attributes (along with gobs of other information). If you are planning on doing extensive work with LDAP, it’s highly advised that you review a good reference guide, such as the <a href="B21757_20.xhtml#_idTextAnchor642"><em class="italic">Appendix</em></a> of the book <em class="italic">Zytrax </em><span class="No-Break"><em class="italic">OpenLDAP</em></span><span class="No-Break"> (</span><a href="https://www.zytrax.com/books/ldap/ape/"><span class="No-Break">https://www.zytrax.com/books/ldap/ape/</span></a><span class="No-Break">).</span></p>
<p>In the previous section, we were introduced to the fact that each entry in an LDAP tree has a DN, which uniquely identifies it in the tree. The DN is composed of a series of attributes, one (or more) of which is used to uniquely identify the path down the tree of the entry represented by the DN. As each segment of the path described by the DN represents an LDAP attribute, you could refer to the available, well-defined LDAP schemas and object classes to determine what each of the attributes in any given <span class="No-Break">DN means.</span></p>
<p>We’ve included <a id="_idIndexMarker339"/>some of the common attributes and their meanings in the following table. These attributes tend to be organizing attributes—meaning that they are typically used to define the organizational structure of the LDAP tree—and are ordered from top to bottom in the structure that you’re likely to see in a typical <span class="No-Break">LDAP installation:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Attribute name</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">dc</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Domain component: Generally, the highest level of organization in an <span class="No-Break">LDAP hierarchy.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">dc=jbcpcalendar,dc=com</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">c</strong></p>
</td>
<td class="No-Table-Style">
<p>Country: Some LDAP hierarchies are structured at a high level <span class="No-Break">by country.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">c=US</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="source-inline">o</strong></p>
</td>
<td class="No-Table-Style">
<p>Organization name: This is a parent business organization used for classifying <span class="No-Break">LDAP resources.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">o=Oracle Corporation</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ou</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Organizational unit: This is a divisional business organization that is generally within <span class="No-Break">an organization.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ou=Product Development</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">cn</strong></span></p>
</td>
<td class="No-Table-Style">
<p>Common name: This is a common name or a unique or human-readable name for the object. For humans, this is usually the person’s full name, while for other resources in LDAP (computers, and so on), it’s typically <span class="No-Break">the hostname.</span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">cn=Super Visor </strong><span class="No-Break"><strong class="source-inline">cn=Jim Bob</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">uid</strong></span></p>
</td>
<td class="No-Table-Style">
<p>User ID: Although not organizational in nature, the <strong class="source-inline">uid</strong> attribute is generally what Spring looks for during user authentication <span class="No-Break">and search.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">uid=svisor</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">userPassword</strong></span></p>
</td>
<td class="No-Table-Style">
<p>User password: This attribute stores the password for the person object to which this attribute is associated. It is typically one-way hashed using SHA or <span class="No-Break">something similar.</span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">userPassword=plaintext userPassword={SHA}cryptval</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – Example of LDAP directory structure</p>
<p>The<a id="_idIndexMarker340"/> attributes in the preceding table do, however, tend to be organizing attributes on the directory tree and, as such, will probably form various search expressions or mappings that you will use to configure Spring Security to interact with the <span class="No-Break">LDAP server.</span></p>
<p class="callout-heading">Important note<a id="_idTextAnchor186"/></p>
<p class="callout">Remember that there are hundreds of standard LDAP attributes—these represent a very small fraction of those you are likely to see when integrating with a fully populated <span class="No-Break">LDAP server.</span></p>
<h3>Updating our dependencies</h3>
<p>We have already <a id="_idIndexMarker341"/>included all of the dependencies you need for this chapter, so you will not need to make any updates to your <strong class="source-inline">build.gradle</strong> file. However, if you were just adding LDAP support to your own application, you would need to add <strong class="source-inline">spring-security-ldap</strong> as a dependency in <strong class="source-inline">build.gradle</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
// LDAP
    implementation 'org.springframework.security:spring-security-ldap'
...
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">Remember that there are hundreds of standard LDAP attributes—these represent a very small fraction of those you are likely to see when integrating with a fully populated <span class="No-Break">LDAP server.</span></p>
<p>As mentioned <a id="_idIndexMarker342"/>previously, Spring Security’s LDAP support is built on top of Spring LDAP. Gradle will automatically bring this dependency in as a transitive dependency, so there is no need to explicitly <span class="No-Break">list it.</span></p>
<h3>Configuring embedded LDAP integration</h3>
<p>Let’s now enable the <a id="_idIndexMarker343"/>JBCP calendar application to support LDAP-based authentication. Fortunately, this is a relatively simple exercise, using the embedded LDAP server and a<a id="_idIndexMarker344"/> sample <strong class="bold">LDAP Data Interchange Format</strong> (<strong class="bold">LDIF</strong>) file. For this exercise, we will be using an LDIF file created for this book that’s intended to capture many of the common configuration scenarios with LDAP and Spring Security. We have included several more sample LDIF files for an embedded <strong class="source-inline">UnboundID</strong> server. This is done by adding an <strong class="source-inline">unboundid-ldapsdk</strong> dependency in <strong class="source-inline">build.gradle</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//build.gradle
dependencies {
...
// LDAP
    implementation 'com.unboundid:unboundid-ldapsdk'
...
}</pre> <h3>Configuring an LDAP server reference</h3>
<p>The first step is to<a id="_idIndexMarker345"/> configure the embedded LDAP server. Spring Boot will automatically configure an embedded LDAP server, but we will need to tweak the configuration a bit. Make the following updates to your <span class="No-Break"><strong class="source-inline">application.yml</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
spring:
   ldap:
     base: dc=jbcpcalendar,dc=com
     embedded:
       ldif: classpath:/ldif/calendar.ldif
       baseDn: ${spring.ldap.base}
       port: 33389</pre> <p class="callout-heading">Important note</p>
<p class="callout">You should be starting with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter06.00-calendar</strong></span><span class="No-Break">.</span></p>
<p>We are loading the <strong class="source-inline">calendar.ldif</strong> file from <strong class="source-inline">classpath</strong> and using it to populate the LDAP server. The <strong class="source-inline">root</strong> attribute declares the root of the LDAP directory using the specified DN. This should correspond to the logical root DN in the LDIF file <span class="No-Break">we’re using.</span></p>
<p class="callout-heading">Tip</p>
<p class="callout">Be aware that for embedded LDAP servers, the <strong class="source-inline">base-dn</strong> attribute is required. If it is not specified or is specified incorrectly, you may receive several odd errors upon initialization. Also, be aware that the <strong class="source-inline">ldif</strong> resource should only load a single <strong class="source-inline">ldif</strong>, otherwise the server will fail to start up. Spring Security requires a single resource, since using something such as <strong class="source-inline">classpath*:calendar.ldif</strong> does not provide the deterministic ordering that <span class="No-Break">is required.</span></p>
<p>We’ll reuse the bean ID<a id="_idIndexMarker346"/> defined here later, in the Spring Security configuration files, when we declare the LDAP user service and other configuration elements. All other attributes on the <strong class="source-inline">&lt;ldap-server&gt;</strong> declaration are optional when using the embedded <span class="No-Break">LDAP mode.</span></p>
<h3>Enabling the LDAP AuthenticationManager interface</h3>
<p>Next, we’ll need to <a id="_idIndexMarker347"/>configure another <strong class="source-inline">AuthenticationManager</strong> interface that checks user credentials against the LDAP provider. Simply update the Spring Security configuration to use an <strong class="source-inline">o.s.s.ldap.authentication.</strong> <strong class="source-inline">AuthenticationManager</strong> reference, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) {
    LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);
    factory.setUserSearchBase("");
    factory.setUserSearchFilter("(uid={0})");
    factory.setLdapAuthoritiesPopulator(authorities);
    return factory.createAuthenticationManager();
}</pre> <h3>Configuring the LdapAuthoritiesPopulator interface</h3>
<p>Spring <a id="_idIndexMarker348"/>Security’s <strong class="source-inline">LdapAuthoritiesPopulator</strong> is used to determine what authorities are returned for the user. The following example shows how to <span class="No-Break">configure </span><span class="No-Break"><strong class="source-inline">LdapAuthoritiesPopulator</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
    String groupSearchBase = "ou=Groups";
    DefaultLdapAuthoritiesPopulator authorities =
          new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase);
    authorities.setGroupSearchFilter("(uniqueMember={0})");
    return authorities;
}</pre> <p>In addition, we have deleted all the references to <strong class="source-inline">PasswordEncoder</strong> Bean and the <span class="No-Break">class </span><span class="No-Break"><strong class="source-inline">CalendarUserDetailsService</strong></span><span class="No-Break">.</span></p>
<p>We’ll discuss these attributes a bit more later. For now, get the application back up and running, and try logging in with <strong class="source-inline">admin1@example.com</strong> as the username and <strong class="source-inline">admin1</strong> as the password. You should be <span class="No-Break">logged in!</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should be starting with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter06.01-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-136"><a id="_idTextAnchor187"/>Troubleshooting embedded LDAP</h2>
<p>It is quite possible that you will<a id="_idIndexMarker349"/> run into hard-to-debug problems with embedded LDAP. If you are getting a <strong class="source-inline">404</strong> error when trying to access the application in your browser, there is a good chance that things did not start up properly. Some things to double-check if you can’t get this simple example running are <span class="No-Break">as follows:</span></p>
<ul>
<li>Ensure the <strong class="source-inline">baseDn</strong> attribute is set in your configuration file, and make sure it matches the root defined in the LDIF file that’s loaded at startup. If you get errors referencing missing partitions, it’s likely that either the root attribute was missed or doesn’t match your <span class="No-Break">LDIF file.</span></li>
<li>Be aware that a failure starting up the embedded LDAP server is not a fatal failure. In order to diagnose errors loading LDIF files, you will need to ensure that the appropriate log settings, including logging for the LDAP server, are enabled, at least at the <span class="No-Break">error level.</span></li>
<li>If the application server shuts down non-gracefully, you may be required to delete some files in your temporary directory (<strong class="source-inline">%TEMP%</strong> on Windows systems or <strong class="source-inline">/tmp</strong> on Linux-based systems) in order to start the server again. The error messages regarding this are (fortunately) fairly clear. Unfortunately, embedded LDAP isn’t as seamless and easy to use as the embedded H2 database, but it is still quite a bit easier than trying to download and configure many of the freely available external <span class="No-Break">LDAP servers.</span></li>
</ul>
<p>An excellent tool for troubleshooting or accessing LDAP servers in general is the Apache Directory Studio project, which offers standalone and Eclipse plugin versions. The free download is<a id="_idIndexMarker350"/> available <span class="No-Break">at </span><a href="http://jxplorer.org/"><span class="No-Break">http://jxplorer.org/</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor188"/>Understanding how Spring LDAP authentication works</h1>
<p>We saw that we were<a id="_idIndexMarker351"/> able to log in using a user-defined in the LDAP directory. But what exactly happens when a user issues a login request for a user in LDAP? There are the following three basic steps to the LDAP <span class="No-Break">authentication process:</span></p>
<ol>
<li>Authenticate the credentials supplied by the user against the <span class="No-Break">LDAP directory.</span></li>
<li>Determine the <strong class="source-inline">GrantedAuthority</strong> object that the user has, based on their information <span class="No-Break">in LDAP.</span></li>
<li>Pre-load information from the LDAP entry for the user into a custom <strong class="source-inline">UserDetails</strong> object<a id="_idIndexMarker352"/> for further use by <span class="No-Break">the application.</span></li>
</ol>
<h2 id="_idParaDest-138"><a id="_idTextAnchor189"/>Authenticating user credentials</h2>
<p>For the <a id="_idIndexMarker353"/>first step, authentication against the LDAP directory, a custom authentication provider is wired into <strong class="source-inline">AuthenticationManager</strong>. The <strong class="source-inline">o.s.s.ldap.authentication.LdapAuthenticationProvider</strong> interface takes the user’s provided credentials and verifies them against the LDAP directory, as illustrated in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<img alt="Figure 6.2 – Spring Security LDAP authentication workflow" height="1162" src="image/B21757_06_02.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Spring Security LDAP authentication workflow</p>
<p>We can see that the <strong class="source-inline">o.s.s.ldap.authentication.LdapAuthenticator</strong> interface defines a delegate<a id="_idIndexMarker354"/> to allow the provider to make the authentication request in a customizable way. The implementation that we’ve implicitly configured to this point, <strong class="source-inline">o.s.s.ldap.authentication.BindAuthenticator</strong>, attempts to use the user’s credentials to bind (log in) to the LDAP server as if it were the user themselves making a connection. For an embedded server, this is sufficient for our authentication needs; however, external LDAP servers may be stricter, and in these, users may not be allowed to bind to the LDAP directory. Fortunately, an alternative method of authentication exists, which we will explore later in <span class="No-Break">this chapter.</span></p>
<p>As noted in the preceding diagram, keep in mind that the search is performed under an LDAP context created by the credentials specified in the <strong class="source-inline">DefaultSpringSecurityContextSource</strong> reference’s <strong class="source-inline">baseDn</strong> attribute. With an embedded server, we don’t use this information, but with an external server reference, unless <strong class="source-inline">baseDn</strong> is supplied, anonymous binding is used. Retaining some control over the public availability of information in the directory is very common for organizations that require valid credentials to search an LDAP directory, and as such, <strong class="source-inline">baseDn</strong> will be almost always required in real-world scenarios. The <strong class="source-inline">baseDn</strong> attribute represents the<a id="_idTextAnchor190"/> full DN of<a id="_idIndexMarker355"/> a user with valid access to bind the directory and <span class="No-Break">perform searches.</span></p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor191"/>Demonstrating authentication with JXplorer</h2>
<p>We are going to <a id="_idIndexMarker356"/>demonstrate how the authentication process works by<a id="_idIndexMarker357"/> using <strong class="source-inline">JXplorer</strong> to connect to our embedded LDAP instance and perform the same steps that Spring Security is performing. We will use <strong class="source-inline">user1@example.com</strong> throughout the simulation. These steps will help to ensure a firm grasp of what is happening behind the scenes and will help if you are having difficulty figuring out the <span class="No-Break">correct configuration.</span></p>
<p>Ensure that the calendar application is started up and work<a id="_idTextAnchor192"/>ing. Next, <span class="No-Break">start </span><span class="No-Break"><strong class="source-inline">Jxplorer</strong></span><span class="No-Break">.</span></p>
<h3>Binding anonymously to LDAP</h3>
<p>The first step is to <a id="_idIndexMarker358"/>bind anonymously to LDAP. The bind is done anonymously because we did not specify the <strong class="source-inline">baseDn</strong> and <strong class="source-inline">password</strong> attributes on our <strong class="source-inline">DefaultSpringSecurityContextSource</strong> object. Within <strong class="source-inline">Jxplorer</strong>, create a connection using the <span class="No-Break">following steps:</span></p>
<ol>
<li>Click on <strong class="bold">File</strong> | <span class="No-Break"><strong class="bold">Connect</strong></span><span class="No-Break">.</span></li>
<li>Enter the <span class="No-Break">following information:</span><ul><li> <span class="No-Break">Hostname: </span><span class="No-Break"><strong class="source-inline">localhost</strong></span></li><li> <span class="No-Break">Port: </span><span class="No-Break"><strong class="source-inline">33389</strong></span></li></ul></li>
<li>We did not specify <strong class="source-inline">baseDn</strong>, so select <strong class="bold">No Authentication</strong> as the <span class="No-Break"><strong class="bold">Authentication Method</strong></span><span class="No-Break">.</span></li>
<li>Click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span><p class="list-inset">You can safely ignore the message indicating no default schema information <span class="No-Break">is present.</span></p></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer042">
<img alt="Figure 6.3 – Binding anonymously to LDAP" height="335" src="image/B21757_06_03.jpg" width="447"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Binding anonymo<a id="_idTextAnchor193"/>usly to LDAP</p>
<p>You should <a id="_idIndexMarker359"/>now see that you are connected to the embedded <span class="No-Break">LDAP instance.</span></p>
<h3>Searching for the user</h3>
<p>Now that we <a id="_idIndexMarker360"/>have a connection, we can use it to look up the user’s DN that we wish to bind to, by performing the <span class="No-Break">following steps:</span></p>
<ol>
<li>Right-click on <strong class="bold">World</strong> and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Search</strong></span><span class="No-Break">.</span></li>
<li>Enter a search base of <strong class="source-inline">dc=jbcpcalendar,dc=com</strong>. This corresponds to the <strong class="source-inline">baseDn</strong> attribute of our <strong class="source-inline">spring.ldap.base</strong> property that <span class="No-Break">we specified.</span></li>
<li>Enter a filter of <strong class="source-inline">uid=user1@example.com</strong>. This corresponds to the value we specified for the <strong class="source-inline">userSearchFilter</strong> method <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">AuthenticationManagerBuilder</strong></span><span class="No-Break">.</span></li>
<li>Click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">Search</strong></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer043">
<img alt="Figure 6.4 – Search for the user" height="399" src="image/B21757_06_04.jpg" width="556"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Search for the user</p>
<ol>
<li value="5">Click on <strong class="bold">Copy DN</strong> of the single<a id="_idIndexMarker361"/> result returned by our search. You can now see that our LDAP user is displayed. Note that this DN matches the value we searched for. Remember this DN, as it will be used in our <span class="No-Break">next step.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer044">
<img alt="Figure 6.5 – Search for the user" height="292" src="image/B21757_06_05.jpg" width="347"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Search for the user</p>
<h3>Binding as a user to LDAP</h3>
<p>Now that we have<a id="_idIndexMarker362"/> found the full DN of our user, we need to try to bind to LDAP as that user to validate the submitted password. These steps are the same as in the anonymous bind we already did, except that we will specify the credentials of the user that we <span class="No-Break">are authenticating.</span></p>
<p>Within <strong class="source-inline">Jxplorer</strong>, create a connection using the <span class="No-Break">following steps:</span></p>
<ol>
<li>Click on <strong class="bold">File</strong> | <span class="No-Break"><strong class="bold">Connect</strong></span><span class="No-Break">.</span></li>
<li>Enter the <span class="No-Break">following information:</span><ul><li> <span class="No-Break">Hostname: </span><span class="No-Break"><strong class="bold">localhost</strong></span></li><li> <span class="No-Break">Port: </span><span class="No-Break"><strong class="bold">33389</strong></span></li></ul></li>
<li>Set <strong class="bold">Security Level</strong> to <strong class="bold">User + </strong><span class="No-Break"><strong class="bold">Password</strong></span><span class="No-Break">.</span></li>
<li>Enter the DN from our search result as <strong class="bold">User DN</strong>. The value should <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">uid=admin1@example.com,ou=Administrators,ou=Users,dc=jbcpcalendar,dc=com</strong></span><span class="No-Break">.</span></li>
<li>The password should be the password that was submitted at the time of login. In our case, we want to use <strong class="bold">admin1</strong> to successfully authenticate. If the wrong password was entered, we would fail to connect and Spring Security would report <span class="No-Break">an </span><span class="No-Break"><a id="_idIndexMarker363"/></span><span class="No-Break">error.</span></li>
<li>Click <span class="No-Break">on </span><span class="No-Break"><strong class="bold">OK</strong></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer045">
<img alt="Figure 6.6 – Binding as a user to LDAP" height="334" src="image/B21757_06_06.jpg" width="444"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Binding as a user to LDAP</p>
<p>Spring Security will determine that the username and password were correct for this user when it is able to successfully bind with the provided username and password (similar to how we were able to create a connection). Spring Security will then proceed with determining the user’s <span class="No-Break">role membership.</span></p>
<h3>Determining the user’s role membership</h3>
<p>After the<a id="_idIndexMarker364"/> user has been successfully authenticated against the LDAP server, authorization information must be determined next. Authorization is defined by a principal’s list of roles, and an LDAP-authenticated user’s role membership is determined as illustrated in the <span class="No-Break">following diagram:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<img alt="Figure 6.7 – User role membership" height="896" src="image/B21757_06_07.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – User role membership</p>
<p>We can see that after authenticating the user against LDAP, <strong class="source-inline">LdapAuthenticationProvider</strong> delegates to <strong class="source-inline">LdapAuthoritiesPopulator</strong>. The <strong class="source-inline">DefaultLdapAuthoritiesPopulator</strong> interface will attempt to locate the authenticated user’s DN in an attribute located at or below another entry in the LDAP hierarchy. The DN of the location searched for user role assignments is defined in the <strong class="source-inline">groupSearchBase</strong> method; in our sample, we set this to <strong class="source-inline">groupSearchBase("ou=Groups")</strong>. When the user’s DN is located within an LDAP entry below the DN of <strong class="source-inline">groupSearchBase</strong>, an attribute on the entry in which their DN is found is used to confer a role <span class="No-Break">to them.</span></p>
<p>How Spring <a id="_idIndexMarker365"/>Security roles are associated with LDAP users can be a little confusing, so let’s look at the JBCP calendar LDAP repository and see how the association of a user with a role works. The <strong class="source-inline">DefaultLdapAuthoritiesPopulator</strong> interface uses several methods of the <strong class="source-inline">AuthenticationManagerBuilder</strong> declaration to govern searching for roles for the user. These attributes are used approximately in the <span class="No-Break">following order:</span></p>
<ol>
<li><strong class="source-inline">groupSearchBase</strong>: This defines the base DN under which the LDAP integration should look for one or more matches for the user’s DN. The default value performs a search from the LDAP root, which may <span class="No-Break">be expensive.</span></li>
<li><strong class="source-inline">groupSearchFilter</strong>: This defines the LDAP search filter used to match the user’s DN to an attribute of an entry located under <strong class="source-inline">groupSearchBase</strong>. This search filter is parameterized with two parameters—the first <strong class="source-inline">({0})</strong> being the user’s DN, and the second <strong class="source-inline">({1})</strong> being the user’s username. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">uniqueMember={0}</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">groupRoleAttribute</strong>: This defines the attribute of the matching entries, which will be used to compose the user’s <strong class="source-inline">GrantedAuthority</strong> object. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">cn</strong></span><span class="No-Break">.</span></li>
<li><strong class="source-inline">rolePrefix</strong>: This is the prefix that will be prepended to the value found in <strong class="source-inline">groupRoleAttribute</strong>, to make a Spring Security <strong class="source-inline">GrantedAuthority</strong> object. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">ROLE_</strong></span><span class="No-Break">.</span></li>
</ol>
<p>This can be a little<a id="_idIndexMarker366"/> abstract and hard for new developers to follow because it’s very different from anything we’ve seen so far with our JDBC and JPA-based <strong class="source-inline">UserDetailsService</strong> implementations. Let’s continue walking through the login process with our <strong class="source-inline">user1@example.com</strong> user in the JBCP calendar <span class="No-Break">LDAP directory.</span></p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor194"/>Determining roles with Jxplorer</h1>
<p>We will now try to<a id="_idIndexMarker367"/> determine the roles for our user with <strong class="source-inline">Jxplorer</strong>. Using the <a id="_idIndexMarker368"/>connection, we created previously, perform the <span class="No-Break">following steps:</span></p>
<ol>
<li>Right-click on <strong class="bold">World</strong> and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Search</strong></span><span class="No-Break">.</span></li>
<li>Enter a search base of <strong class="source-inline">ou=Groups,dc=jbcpcalendar,dc=com</strong>. This corresponds to the <strong class="source-inline">baseDn</strong> attribute of the <strong class="source-inline">DefaultSpringSecurityContextSource</strong> object we specified, plus the <strong class="source-inline">groupSearchBase</strong> attribute we specified for the <span class="No-Break"><strong class="source-inline">AuthenticationManagerBuilder</strong></span><span class="No-Break"> object.</span></li>
<li>Enter a text filter of <strong class="source-inline">uniqueMember=uid=user1@example.com,ou=Users,dc=jbcpcalendar,dc= com</strong>. This corresponds to the default <strong class="source-inline">groupSearchFilter</strong> attribute of <strong class="source-inline">(uniqueMember={0})</strong>. Notice that we have substituted the full DN of the user we found in our previous exercise for the <strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">0}</strong></span><span class="No-Break"> value.</span></li>
<li>Click <span class="No-Break">on</span><span class="No-Break"> </span><span class="No-Break"><strong class="bold">Search</strong></span><span class="No-Break">.</span></li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer047">
<img alt="Figure 6.8 – Role search" height="399" src="image/B21757_06_08.jpg" width="543"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Role search</p>
<ol>
<li value="5">You will observe that the <strong class="bold">User</strong> group is the only group returned in our search results. Click on copy DN of the single result returned by our search. You can now see the <strong class="bold">User</strong> group displayed in <strong class="source-inline">Jxplorer</strong>. Note that the group has a <strong class="source-inline">uniqueMember</strong> attribute with the full DN of our user and <span class="No-Break">other users.</span></li>
</ol>
<p>Spring Security <a id="_idIndexMarker369"/>now creates the <strong class="source-inline">GrantedAuthority</strong> object for<a id="_idIndexMarker370"/> each result by forcing the name of the group that was found into uppercase and prepending <strong class="source-inline">ROLE_</strong> to the group name. The pseudocode would look similar to the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
foreach group in groups:
authority = ("ROLE_"+group).upperCase()
grantedAuthority = new GrantedAuthority(authority)</pre> <p class="callout-heading">Tip</p>
<p class="callout">Spring LDAP is as flexible as your gray matter. Keep in mind that, although this is one way to organize an LDAP directory to be compatible with Spring Security, typical usage scenarios are exactly the opposite—an LDAP directory already exists that Spring Security needs to be wired into. In many cases, you will be able to reconfigure Spring Security to deal with the hierarchy of the LDAP server; however, it’s key that you plan effectively and understand how Spring works with LDAP when it’s querying. Use your brain, map out the user search and group search, and come up with the most optimal plan you can think of—keep the scope of searches as minimal and as precise <span class="No-Break">as possible.</span></p>
<p>Can you describe how the results of the login process would differ for our <strong class="source-inline">admin1@example.com</strong> user? If you are confused at this point, we’d suggest that you take a breather and try using <strong class="source-inline">Jxplorer</strong> to work through browsing the embedded LDAP server, configured by the running of an application. It can be easier to grasp the flow of Spring Security’s LDAP configuration if you attempt to search th<a id="_idTextAnchor195"/>e directory yourself by following the algorithm <span class="No-Break">described previously.</span></p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor196"/>Mapping additional attributes of UserDetails</h2>
<p>Finally, once the LDAP<a id="_idIndexMarker371"/> lookup has assigned the user a set of the <strong class="source-inline">GrantedAuthority</strong> objects, <strong class="source-inline">o.s.s.ldap.userdetails.LdapUserDetailsMapper</strong> will consult <strong class="source-inline">o.s.s.ldap.userdetails.UserDetailsContextMapper</strong> to retrieve any additional details to populate the <strong class="source-inline">UserDetails</strong> object for <span class="No-Break">application use.</span></p>
<p>Using <strong class="source-inline">AuthenticationManagerBuilder</strong>, we’ve configured up until this point that <strong class="source-inline">LdapUserDetailsMapper</strong> will be used to populate a <strong class="source-inline">UserDetails</strong> object with information gleaned from the user’s entry in the <span class="No-Break">LDAP directory:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<img alt="Figure 6.9 – Mapping additional attributes of UserDetails" height="958" src="image/B21757_06_09.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Mapping additional attributes of UserDetails</p>
<p>We’ll see in a moment how <strong class="source-inline">UserDetailsContextMapper</strong> can be configured to pull a wealth of information from the standard LDAP <strong class="source-inline">person</strong> and <strong class="source-inline">inetOrgPerson</strong> objects. With the baseline <strong class="source-inline">LdapUserDetailsMapper</strong>, little more than <strong class="source-inline">username</strong>, <strong class="source-inline">password</strong>, and <strong class="source-inline">GrantedAuthority</strong> <span class="No-Break">are stored.</span></p>
<p>Although there is more machinery involved behind the scenes in LDAP user authentication and detail retrieval, you’ll notice that the overall process seems somewhat similar to the JDBC authentication that we studied in <a href="B21757_04.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">JDBC-based Authentication</em> (authenticating the user and populating <strong class="source-inline">GrantedAuthority</strong>). As with JDBC authentication, there is the ability to perform advanced configuration of<a id="_idIndexMarker372"/> LDAP integration. Let’s dive deeper and see <span class="No-Break">what’s possible!</span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor197"/>Advanced LDAP configuration</h2>
<p>Once we get beyond the <a id="_idIndexMarker373"/>basics of LDAP integration, there’s a plethora of additional configuration capabilities in the Spring Security LDAP module that are still within the security <strong class="source-inline">SecurityFilterChain</strong> bean. These include retrieval of user personal information, additional options for user authentication, and the use of LDAP as the <strong class="source-inline">UserDetailsService</strong> interface in conjunction with a standard <span class="No-Break"><strong class="source-inline">DaoAuth<a id="_idTextAnchor198"/><a id="_idTextAnchor199"/>enticationProvider</strong></span><span class="No-Break"> class.</span></p>
<h3>Sample JBCP LDAP users</h3>
<p>We’ve supplied a <a id="_idIndexMarker374"/>number of different users in the <a id="_idIndexMarker375"/>JBCP calendar LDIF file. The following quick reference chart may help you with the advanced configuration exercises, or <span class="No-Break">with self-exploration:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Username/password</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Role(s)</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Password encoding</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">admin1@example.com/admin1</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ROLE_ADMIN, ROLE_USER</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Plaintext</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">user1@example.com/user1</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ROLE_USER</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">Plaintext</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">shauser@example.com/shauser</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ROLE_USER</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">sha}</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">sshauser@example.com/sshauser</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ROLE_USER</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">{</strong><span class="No-Break"><strong class="source-inline">ssha}</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">hasphone@example.com/hasphone</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">ROLE_USER</strong></span></p>
</td>
<td class="No-Table-Style">
<p><strong class="source-inline">Plaintext (in the </strong><span class="No-Break"><strong class="source-inline">telephoneNumber attribute)</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor200"/>Table 6.2 – List of LDAP users</p>
<p>We’ll explain why password encoding matters in the <span class="No-Break">next section.</span></p>
<h3><a id="_idTextAnchor201"/>Password comparison versus bind authentication</h3>
<p>Some LDAP servers<a id="_idIndexMarker376"/> will be configured so that certain individual users are not allowed to bind directly to the server, or so that anonymous binding (what we have been using for user search up until this point) is disabled. This tends to occur in very large organizations that want a restricted set of users to be able to read information from <span class="No-Break">the directory.</span></p>
<p>In these cases, the standard Spring Security LDAP authentication strategy will not work, and an alternative strategy must be used, implemented by <strong class="source-inline">o.s.s.ldap.authentication.PasswordComparisonAuthenticator</strong> (a sibling class <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">BindAuthenticator</strong></span><span class="No-Break">):</span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<img alt="Figure 6.10 – Password comparison versus bind authentication" height="1988" src="image/B21757_06_10.jpg" width="1643"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Password comparison versus bind authentication</p>
<p>The <strong class="source-inline">PasswordComparisonAuthenticator</strong> interface binds to LDAP and searches for the DN matching the username provided by the user. It then compares the user-supplied <a id="_idIndexMarker377"/>password with the <strong class="source-inline">userPassword</strong> attribute stored on the matching LDAP entry. If the encoded password matches, the user is authenticated and the flow proceeds, as <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">BindAuthenticator</strong></span><span class="No-Break">.</span></p>
<h3>Configuring basic password comparison</h3>
<p>Configuring<a id="_idIndexMarker378"/> password comparison authentication instead of bind authentication is as simple as adding a method to the <strong class="source-inline">AuthenticationManager</strong> declaration. Update the <strong class="source-inline">SecurityConfig.java</strong> file <span class="No-Break">as follows:</span></p>
<pre class="source-code">
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) {
    LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(
          contextSource, new LdapShaPasswordEncoder());
    factory.setUserSearchBase("");
    factory.setUserSearchFilter("(uid={0})");
    factory.setLdapAuthoritiesPopulator(authorities);
    factory.setPasswordAttribute("userPassword");
    return factory.createAuthenticationManager();
}</pre> <p>The <strong class="source-inline">PasswordCompareConfigurer</strong> class, that is used by declaring the <strong class="source-inline">passwordCompare</strong> method, uses <strong class="source-inline">PlaintextPasswordEncoder</strong> for password encoding. To use the <strong class="source-inline">SHA-1</strong> password algorithm, we need to set a password encoder, and we can use <strong class="source-inline">o.s.s.a.encoding.LdapShaPasswordEncoder</strong> for <strong class="source-inline">SHA</strong> support (recall that we discussed the <strong class="source-inline">SHA-1</strong> password algorithm extensively in <a href="B21757_04.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <span class="No-Break"><em class="italic">JDBC-based Authentication</em></span><span class="No-Break">).</span></p>
<p>In our <strong class="source-inline">calendar.ldif</strong> file, we have the <strong class="source-inline">password</strong> field set to <strong class="source-inline">userPassword</strong>. The default <strong class="source-inline">password</strong> attribute for the <strong class="source-inline">PasswordCompareConfigurer</strong> class is <strong class="source-inline">password</strong>. So, we also need to override the <strong class="source-inline">password</strong> attribute with the <span class="No-Break"><strong class="source-inline">passwordAttribute</strong></span><span class="No-Break"> method.</span></p>
<p>After restarting the server, you can attempt to log in using <strong class="source-inline">shauser@example.com</strong> as the <strong class="source-inline">username</strong> and <strong class="source-inline">shauser</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">password</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">You should start with the source <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">chapter06.02-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor202"/>LDAP password encoding and storage</h2>
<p>LDAP has general <a id="_idIndexMarker379"/>support for a variety of password encoding algorithms, ranging from plaintext to one-way hash algorithms—similar to those we explored in the previous chapter—with database-backed authentication. The most common storage formats for LDAP passwords are <strong class="source-inline">SHA</strong> (<strong class="source-inline">SHA-1</strong> one-way hashed) and <strong class="source-inline">SSHA</strong> (<strong class="source-inline">SHA-1</strong> one-way hashed with a salt value). Other password formats often supported by many LDAP implementations are thoroughly documented in <em class="italic">RFC 2307</em>, <em class="italic">An Approach to Using LDAP as a Network Information Service</em> (<a href="http://tools.ietf.org/html/rfc2307">http://tools.ietf.org/html/rfc2307</a>). The designers of <em class="italic">RFC 2307</em> did a very clever thing with regard to password storage. Passwords retained in the directory are, of course, encoded with whatever algorithm is appropriate (<strong class="source-inline">SHA</strong> and so on), but then, they are prefixed with the algorithm used to encode the password. This makes it very easy for the LDAP server to support multiple algorithms for password encoding. For example, an <strong class="source-inline">SHA</strong> encoded password is stored in the directory <span class="No-Break">as follows:</span></p>
<pre class="source-code">
{SHA}5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8</pre> <p>We can see that the password storage algorithm is very clearly indicated with the <strong class="source-inline">{SHA}</strong> notation and stored along with <span class="No-Break">the password.</span></p>
<p>The <strong class="source-inline">SSHA</strong> notation is an attempt to combine the strong <strong class="source-inline">SHA-1</strong> hash algorithm with password salting to prevent dictionary attacks. As with password salting, which we reviewed in the previous chapter, the salt is added to the password prior to calculating the hash. When the hashed password is stored in the directory, the salt value is appended to the hashed password. The password is prepended with <strong class="source-inline">{SSHA}</strong> so that the LDAP directory knows that the user-supplied password needs to be compared differently. Most modern LDAP servers utilize <strong class="source-inline">SSHA</strong> as their default password <span class="No-Break">storage algorithm.</span></p>
<h3>The drawbacks of a password comparison authenticator</h3>
<p>Now that you know a bit about<a id="_idIndexMarker380"/> how LDAP uses passwords, and we have <strong class="source-inline">PasswordComparisonAuthenticator</strong> set up, what do you think will happen if you log in using our <strong class="source-inline">sshauser@example.com</strong> user with their password, stored in <span class="No-Break"><strong class="source-inline">SSHA</strong></span><span class="No-Break"> format?</span></p>
<p>Go ahead, put the book aside and try it, and then come back. Your login was denied, right? And yet you were still able to log in as the user with the SHA-encoded password. Why? The password encoding and storage didn’t matter when we were using bind authentication. Why do you think <span class="No-Break">that is?</span></p>
<p>The reason it didn’t matter with bind authentication was that the LDAP server was taking care of the authentication and validation of the user’s password. With password compare authentication, Spring Security LDAP is responsible for encoding the password in the format expected by the directory and then matching it against the directory to validate <span class="No-Break">the authentication.</span></p>
<p>For security purposes, password comparison authentication can’t actually read the password from the directory (reading directory passwords is often denied by the security policy). Instead, <strong class="source-inline">PasswordComparisonAuthenticator</strong> performs an LDAP search, rooted at the user’s directory entry, attempting to match with a <strong class="source-inline">password</strong> attribute and value as determined by the password that’s been encoded by <span class="No-Break">Spring Security.</span></p>
<p>So, when we try to log in with <strong class="source-inline">sshauser@example.com</strong>, <strong class="source-inline">PasswordComparisonAuthenticator</strong> encodes the password using the configured <strong class="source-inline">SHA</strong> algorithm and attempts to do a simple match, which fails, as the directory password for this user is stored in the <span class="No-Break"><strong class="source-inline">SSHA</strong></span><span class="No-Break"> format.</span></p>
<p>Our current configuration, using <strong class="source-inline">LdapShaPasswordEncoder</strong>, already supports <strong class="source-inline">SHA</strong> and <strong class="source-inline">SSHA</strong>, so currently, it still doesn’t work. Let’s think why that might be. Remember that <strong class="source-inline">SSHA</strong> uses a salted password, with the salt value stored in the LDAP directory along with the password. However, <strong class="source-inline">PasswordComparisonAuthenticator</strong> is coded so that it cannot read anything from the LDAP server (this typically violates the security policy with companies that don’t allow binding). Thus, when <strong class="source-inline">PasswordComparisonAuthenticator</strong> computes the hashed password, it has no way to <a id="_idIndexMarker381"/>determine what salt value <span class="No-Break">to use.</span></p>
<p>In conclusion, <strong class="source-inline">PasswordComparisonAuthenticator</strong> is valuable in certain limited circumstances where the security of the directory itself is a concern, but it will never b<a id="_idTextAnchor203"/>e as flexible as straight <span class="No-Break">bind authentication.</span></p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor204"/>Configuring the UserDetailsContextMapper object</h1>
<p>As we noted earlier, an <a id="_idIndexMarker382"/>instance of the <strong class="source-inline">o.s.s.ldap.userdetails.UserDetailsContextMapper</strong> interface is used to map a user’s entry into the LDAP server to a <strong class="source-inline">UserDetails</strong> object in memory. The default <strong class="source-inline">UserDetailsContextMapper</strong> object behaves similarly to <strong class="source-inline">JpaDaoImpl</strong>, given the level of detail that is populated on the returned <strong class="source-inline">UserDetails</strong> object—that is to say, not a lot of information is returned besides the username <span class="No-Break">and password.</span></p>
<p>However, an LDAP directory potentially contains many more details about individual users than usernames, passwords, and roles. Spring Security ships with two additional methods of pulling more user data from two of the standard LDAP object schemas—<strong class="source-inline">person</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">inetOrgPerson</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor205"/>Implicit configuration of UserDetailsContextMapper</h2>
<p>In order to configure a <a id="_idIndexMarker383"/>different <strong class="source-inline">UserDetailsContextMapper</strong> implementation than the default, we simply need to declare which <strong class="source-inline">LdapUserDetails</strong> class we want <strong class="source-inline">LdapAuthenticationProvider</strong> to return. The security namespace parser will be smart enough to instantiate the correct <strong class="source-inline">UserDetailsContextMapper </strong>implementation based on the type of the <strong class="source-inline">LdapUserDetails</strong> <span class="No-Break">interface requested.</span></p>
<p>Let’s reconfigure our <strong class="source-inline">SecurityConfig.java</strong> file to use the <strong class="source-inline">inetOrgPerson</strong> version of the mapper. Update the <strong class="source-inline">SecurityConfig.java</strong> file, as illustrated in the <span class="No-Break">following code:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
LdapAuthoritiesPopulator authorities(BaseLdapPathContextSource contextSource) {
    String groupSearchBase = "ou=Groups";
    DefaultLdapAuthoritiesPopulator authorities =
          new DefaultLdapAuthoritiesPopulator(contextSource, groupSearchBase);
    authorities.setGroupSearchFilter("(uniqueMember={0})");
    return authorities;
}</pre> <p class="callout-heading">Important note</p>
<p class="callout">If we remove the <strong class="source-inline">passwordEncoder</strong> method, then the LDAP users that are using <strong class="source-inline">SHA</strong> passwords will fail <span class="No-Break">to authenticate.</span></p>
<p>If you were to<a id="_idIndexMarker384"/> restart the application and attempt to log in as an LDAP user, you would see that nothing changed. In fact, <strong class="source-inline">UserDetailsContextMapper</strong> has changed behind the scenes to read the additional details in the case where attributes from the <strong class="source-inline">inetOrgPerson</strong> schema are available in the user’s <span class="No-Break">directory entry.</span></p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor206"/>Viewing additional user details</h2>
<p>To assist <a id="_idIndexMarker385"/>you in this area, we’ll add the ability to view the current account to the JBCP calendar application. We’ll use this page to illustrate how the richer person and the <strong class="source-inline">inetOrgPerson</strong> LDAP schemas can provide additional (optional) information to your <span class="No-Break">LDAP-enabled application.</span></p>
<p>You may have noticed that this chapter came with an additional controller named <strong class="source-inline">AccountController</strong>. You can see the relevant code, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/controllers/AccountControll er.java
@Controller
public class AccountController {
    @RequestMapping("/accounts/my")
    public String view(Model model) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if(authentication == null) {
            throw new IllegalStateException("authentication cannot be null. Make sure you are logged in.");
        }
        Object principal = authentication.getPrincipal();
        model.addAttribute("user", principal);
        model.addAttribute("isLdapUserDetails", principal instanceof LdapUserDetails);
        model.addAttribute("isLdapPerson", principal instanceof Person);
        model.addAttribute("isLdapInetOrgPerson", principal instanceof InetOrgPerson);
        return "accounts/show";
    }
}</pre> <p>The preceding code will retrieve the <strong class="source-inline">UserDetails</strong> object (principal) stored in the <strong class="source-inline">Authentication</strong> object by <strong class="source-inline">LdapAuthenticationProvider</strong> and determine what type of <strong class="source-inline">LdapUserDetailsImplinterface</strong> it is. The page code itself will then display various details depending on the type of <strong class="source-inline">UserDetails</strong> object that has been bound to the user’s<a id="_idIndexMarker386"/> authentication information, as we see in the following JSP code. We have already included JSP <span class="No-Break">as well:</span></p>
<pre class="source-code">
//src/main/resources/templates/accounts/show.xhtml
&lt;dl&gt;
    &lt;dt&gt;Username&lt;/dt&gt;
    &lt;dd id="username" th:text="${user.username}"&gt;ChuckNorris&lt;/dd&gt;
    &lt;dd&gt;&amp;nbsp;&lt;/dd&gt;
    &lt;dt&gt;DN&lt;/dt&gt;
    &lt;dd id="dn" th:text="${user.dn}"&gt;&lt;/dd&gt;
    &lt;dd&gt;&amp;nbsp;&lt;/dd&gt;
    &lt;span th:if="${isLdapPerson}"&gt;
        &lt;dt&gt;Description&lt;/dt&gt;
        &lt;dd id="description" th:text="${user.description}"&gt;&lt;/dd&gt;
        &lt;dd&gt;&amp;nbsp;&lt;/dd&gt;
        &lt;dt&gt;Telephone&lt;/dt&gt;
        &lt;dd id="telephoneNumber" th:text="${user.telephoneNumber}"&gt;&lt;/dd&gt;
        &lt;dd&gt;&amp;nbsp;&lt;/dd&gt;
        &lt;dt&gt;Full Name(s)&lt;/dt&gt;
        &lt;span th:each="cn : ${user.cn}"&gt;
            &lt;dd th:text="${cn}"&gt;&lt;/dd&gt;
        &lt;/span&gt;
        &lt;dd&gt;&amp;nbsp;&lt;/dd&gt;
    &lt;/span&gt;
    &lt;span th:if="${isLdapInetOrgPerson}"&gt;
        &lt;dt&gt;Email&lt;/dt&gt;
        &lt;dd id="email" th:text="${user.mail}"&gt;&lt;/dd&gt;
        &lt;dd&gt;&amp;nbsp;&lt;/dd&gt;
        &lt;dt&gt;Street&lt;/dt&gt;
        &lt;dd id="street" th:text="${user.street}"&gt;&lt;/dd&gt;
        &lt;dd&gt;&amp;nbsp;&lt;/dd&gt;
    &lt;/span&gt;
&lt;/dl&gt;</pre> <p>The only work that <a id="_idIndexMarker387"/>actually needs to be done is to add a link in our <strong class="source-inline">header.xhtml</strong> file, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/resources/templates/fragments/header.xhtml
&lt;li class="nav-item"&gt;
    &lt;a class="nav-link" th:href="@{/accounts/my}"&gt;Welcome &lt;span class="navbar-text"
                                      th:text="${#authentication.name}"&gt;&lt;/span&gt;&lt;/a&gt;
&lt;/li&gt;</pre> <p>We’ve added the following two more users that you can use to examine the differences in the available <span class="No-Break">data elements:</span></p>
<table class="No-Table-Style _idGenTablePara-1" id="table003-1">
<colgroup>
<col/>
<col/>
<col/>
</colgroup>
<thead>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Username</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Password</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="bold">Type</strong></span></p>
</td>
</tr>
</thead>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">shainet@example.com</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">shainet</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">inetOrgPerson</strong></span></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">shaperson@example.com</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">shaperson</strong></span></p>
</td>
<td class="No-Table-Style">
<p><span class="No-Break"><strong class="source-inline">person</strong></span></p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.3 – List of newly added LDAP users</p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter06.03-calendar</strong></span><span class="No-Break">.</span></p>
<p>Restart the <a id="_idIndexMarker388"/>server and examine the <strong class="source-inline">Account Details</strong> page for each of the types of users by clicking on <strong class="source-inline">username</strong> in the upper-right corner. You’ll note that when <strong class="source-inline">UserDetails</strong> class is configured to use <strong class="source-inline">inetOrgPerson</strong>, although <strong class="source-inline">o.s.s.ldap.userdetails.InetOrgPerson</strong> is what is returned, the fields may or may not be populated depending on the available attributes in the <span class="No-Break">directory entry.</span></p>
<p>In fact, <strong class="source-inline">inetOrgPerson</strong> has many more attributes that we’ve illustrated on this simple page. You can review the full list in <em class="italic">RFC 2798</em>, <em class="italic">Definition of the inetOrgPerson LDAP Object </em><span class="No-Break"><em class="italic">Class</em></span><span class="No-Break"> (</span><a href="http://tools.ietf.org/html/rfc2798"><span class="No-Break">http://tools.ietf.org/html/rfc2798</span></a><span class="No-Break">).</span></p>
<p>One thing you may notice is that there is no facility to support additional attributes that may be specified on an object entry, but don’t fall into a standard schema. The standard <strong class="source-inline">UserDetailsContextMapper</strong> interfaces don’t support arbitrary lists of attributes, but it is possible nonetheless to customize it with a reference to your own <strong class="source-inline">UserDetailsContextMapper</strong> interface using the <span class="No-Break"><strong class="source-inline">userDetailsContextMapper</strong></span><span class="No-Break"> method.</span></p>
<h3>Using an alternate password attribute</h3>
<p>In some cases, it<a id="_idIndexMarker389"/> may be necessary to use an alternate LDAP attribute instead of <strong class="source-inline">userPassword</strong>, for authentication purposes. This can happen during occasions when companies have deployed custom LDAP schemas or don’t have the requirement for strong password management (arguably, this is never a good idea, but it definitely does occur in the <span class="No-Break">real world).</span></p>
<p>The <strong class="source-inline">PasswordComparisonAuthenticator</strong> interface also supports the ability to verify the user’s password against an alternate LDAP entry attribute instead of the standard <strong class="source-inline">userPassword</strong> attribute. This is very easy to configure, and we can demonstrate a simple example using the plaintext <strong class="source-inline">telephoneNumber</strong> attribute. Update the <strong class="source-inline">SecurityConfig.java</strong> <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) {
    LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(
          contextSource, new LdapShaPasswordEncoder());
    factory.setUserSearchBase("");
    factory.setUserDetailsContextMapper(new InetOrgPersonContextMapper());
    factory.setUserSearchFilter("(uid={0})");
    factory.setLdapAuthoritiesPopulator(authorities);
    factory.setPasswordAttribute("telephoneNumber");
    return factory.createAuthenticationManager();
}</pre> <p>We can restart<a id="_idIndexMarker390"/> the server and attempt to log in with <strong class="source-inline">hasphone@example.com</strong> as the <strong class="source-inline">username</strong> attribute and <strong class="source-inline">0123456789</strong> as the <strong class="source-inline">password</strong> (telephone <span class="No-Break">number) attribute.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter06.04-calendar</strong></span><span class="No-Break">.</span></p>
<p>Of course, this type of authentication has all of the perils we discussed earlier regarding authentication based on <strong class="source-inline">PasswordComparisonAuthenticator</strong>; however, it’s good to be aware of it on the off-chance that it comes up with an <span class="No-Break">LDAP implementation.</span></p>
<h3>Using LDAP as UserDetailsService</h3>
<p>One thing to <a id="_idIndexMarker391"/>note is that LDAP may also be used as <strong class="source-inline">UserDetailsService</strong>. As we will discuss later in the book, <strong class="source-inline">UserDetailsService</strong> is required to enable various other bits of functionality in the Spring Security infrastructure, including the remember-me and OpenID <span class="No-Break">authentication features.</span></p>
<p>We will modify our <strong class="source-inline">AccountController</strong> object to use the <strong class="source-inline">LdapUserDetailsService</strong> interface to obtain the user. Before doing this, make sure to remove the <strong class="source-inline">passwordCompare</strong> method, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
AuthenticationManager authenticationManager(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) {
    LdapBindAuthenticationManagerFactory factory = new LdapBindAuthenticationManagerFactory(contextSource);
    factory.setUserSearchBase("");
    factory.setUserSearchFilter("(uid={0})");
    factory.setLdapAuthoritiesPopulator(authorities);
    factory.setUserDetailsContextMapper(new InetOrgPersonContextMapper());
    return factory.createAuthenticationManager();
}</pre> <h2 id="_idParaDest-147"><a id="_idTextAnchor207"/>Configuring LdapUserDetailsService</h2>
<p>The configuration of<a id="_idIndexMarker392"/> LDAP as a <strong class="source-inline">UserDetailsService</strong> function is very similar to the configuration of an LDAP <strong class="source-inline">AuthenticationProvider</strong>. Like the JDBC <strong class="source-inline">UserDetailsService</strong>, an LDAP <strong class="source-inline">UserDetailsService</strong> interface is configured as a sibling to the <strong class="source-inline">&lt;</strong>http&gt; declaration. Make the following updates to the <span class="No-Break"><strong class="source-inline">SecurityConfig.java</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public UserDetailsService userDetailsService(BaseLdapPathContextSource contextSource, LdapAuthoritiesPopulator authorities) {
    return new LdapUserDetailsService(new FilterBasedLdapUserSearch("", "(uid={0})", contextSource), authorities);
}</pre> <p>Functionally, <strong class="source-inline">o.s.s.ldap.userdetails.LdapUserDetailsService</strong> is configured in almost exactly the same way as <strong class="source-inline">LdapAuthenticationProvider</strong>, with the exception that there is no attempt to use the principal’s username to bind to LDAP. Instead, the credentials are supplied by the <strong class="source-inline">DefaultSpringSecurityContextSource</strong> reference and are used to perform the <span class="No-Break">user</span><span class="No-Break"><a id="_idIndexMarker393"/></span><span class="No-Break"> lookup.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Do not make the very common mistake of configuring <strong class="source-inline">AuthenticationManagerBuilder</strong> with the <strong class="source-inline">UserDetailsService</strong> referring to <strong class="source-inline">LdapUserDetailsService</strong> if you intend to authenticate the user against LDAP itself! As discussed previously, the <strong class="source-inline">password</strong> attribute often cannot be retrieved from LDAP due to security reasons, which makes <strong class="source-inline">UserDetailsService</strong> useless for authenticating. As noted previously, <strong class="source-inline">LdapUserDetailsService</strong> uses the <strong class="source-inline">baseDn</strong> attribute supplied with the <strong class="source-inline">DefaultSpringSecurityContextSource</strong> declaration to get its information—this means that it does not attempt to bind the user to<a id="_idTextAnchor208"/> LDAP and, as such, may not behave as <span class="No-Break">you expect.</span></p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor209"/>Updating AccountController to use LdapUserDetailsService</h1>
<p>We will <a id="_idIndexMarker394"/>now update the <strong class="source-inline">AccountController</strong> object to use the<strong class="source-inline"> LdapDetailsUserDetailsService</strong> interface to look up the user that <span class="No-Break">it displays:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/controllers/AccountControll er.java
@Controller
public class AccountController {
    private final UserDetailsService userDetailsService;
    public AccountController(UserDetailsService userDetailsService) {
       if (userDetailsService == null) {
          throw new IllegalArgumentException("userDetailsService cannot be null");
       }
       this.userDetailsService = userDetailsService;
    }
    @RequestMapping("/accounts/my")
    public String view(Model model) {
       Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
       if(authentication == null) {
          throw new IllegalStateException("authentication cannot be null. Make sure you are logged in.");
       }
       Object principal = userDetailsService.loadUserByUsername(authentication.getName());
       model.addAttribute("user", principal);
       model.addAttribute("isLdapUserDetails", principal instanceof LdapUserDetails);
       model.addAttribute("isLdapPerson", principal instanceof Person);
       model.addAttribute("isLdapInetOrgPerson", principal instanceof InetOrgPerson);
       return "accounts/show";
    }
}</pre> <p>Obviously, this <a id="_idIndexMarker395"/>example is a bit silly, but it demonstrates the use of <strong class="source-inline">LdapUserDetailsService</strong>. Go ahead and restart the application and give this a try with the <strong class="source-inline">username</strong> as <strong class="source-inline">admin1@example.com</strong> and the <strong class="source-inline">password</strong> as <strong class="source-inline">admin1</strong>. Can you figure out how to modify the controller to display an arbitrary <span class="No-Break">user’s information?</span></p>
<p>Can you figure out how you should modify the security settings to restrict access to <span class="No-Break">an administrator?</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter06.05-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-149"><a id="_idTextAnchor210"/>Integrating Spring Security with an external LDAP server</h2>
<p>It is likely that once<a id="_idIndexMarker396"/> you test basic<a id="_idIndexMarker397"/> integration with the embedded LDAP server, you will want to interact with an external LDAP server. Fortunately, this is very straightforward and can be done using a slightly different syntax along with <span class="No-Break">the same</span></p>
<p>Update the<a id="_idIndexMarker398"/> Spring Security configuration <a id="_idIndexMarker399"/>to connect to an external LDAP server on port<strong class="source-inline"> 33389</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
AuthenticationManager authenticationManager(LdapAuthoritiesPopulator authorities) {
    BaseLdapPathContextSource contextSource=  new DefaultSpringSecurityContextSource(
          List.of("ldap://localhost:" + LDAP_PORT + "/"), "dc=jbcpcalendar,dc=com"){{
       setUserDn("uid=admin,ou=system");
       setPassword("secret");
    }};
    LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(
          contextSource, new LdapShaPasswordEncoder());
    factory.setUserSearchBase("");
    factory.setUserDetailsContextMapper(new InetOrgPersonContextMapper());
    factory.setUserSearchFilter("(uid={0})");
    factory.setLdapAuthoritiesPopulator(authorities);
    factory.setPasswordAttribute("userPassword");
    return factory.createAuthenticationManager();
}</pre> <p>The<a id="_idIndexMarker400"/> notable differences here (aside from the LDAP URL) are that the DN and password for an account are provided. The <a id="_idIndexMarker401"/>account (which is actually optional) should be allowed to bind to the directory and perform searches across all relevant DNs for user and group information. The binding resulting from the application of these credentials against the LDAP server URL is used for the remaining LDAP operations across the <span class="No-Break">LDAP-secured system.</span></p>
<p>Be aware that many LDAP servers also <a id="_idIndexMarker402"/>support <strong class="bold">SSL-encrypted LDAP</strong> (<strong class="bold">LDAPS</strong>)—this is, of course, preferred for security purposes and is supported by the Spring LDAP stack. Simply use <strong class="source-inline">ldaps://</strong> at the beginning of the LDAP server URL. LDAPS typically runs on TCP port <strong class="source-inline">636</strong>. Note that there are many commercial and non-commercial implementations <span class="No-Break">of LDAP.</span></p>
<p>The exact configuration parameters that you will use for connectivity, user binding, and the population of <strong class="source-inline">GrantedAuthoritys</strong> will wholly depend on both the vendor and the structure of the directory. We will cover one very common LDAP implementation, Microsoft AD, in the <span class="No-Break">next section.</span></p>
<p>If you do not have an LDAP server handy and would like to give this a try, go ahead and add the following code to your <strong class="source-inline">SecurityConfig.java</strong> file, which starts up the embedded LDAP server we have <span class="No-Break">been using:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
private BaseLdapPathContextSource getDefaultSpringSecurityContextSource () {
    DefaultSpringSecurityContextSource defaultSpringSecurityContextSource =     new DefaultSpringSecurityContextSource(
          List.of("ldap://localhost:" + LDAP_PORT), "dc=jbcpcalendar,dc=com");
    defaultSpringSecurityContextSource.setUserDn("uid=admin,ou=system");
    defaultSpringSecurityContextSource.setPassword("secret");
    defaultSpringSecurityContextSource.afterPropertiesSet();
    return defaultSpringSecurityContextSource;
}
@Bean
LdapAuthoritiesPopulator authorities() {
    String groupSearchBase = "ou=Groups";
    DefaultLdapAuthoritiesPopulator authorities =
          new DefaultLdapAuthoritiesPopulator(this.getDefaultSpringSecurityContextSource(), groupSearchBase);
    authorities.setGroupSearchFilter("(uniqueMember={0})");
    return authorities;
}
@Bean
AuthenticationManager authenticationManager(LdapAuthoritiesPopulator authorities) {
    LdapPasswordComparisonAuthenticationManagerFactory factory = new LdapPasswordComparisonAuthenticationManagerFactory(
          this.getDefaultSpringSecurityContextSource(), new LdapShaPasswordEncoder());
    factory.setUserSearchBase("");
    factory.setUserDetailsContextMapper(new InetOrgPersonContextMapper());
    factory.setUserSearchFilter("(uid={0})");
    factory.setLdapAuthoritiesPopulator(authorities);
    factory.setPasswordAttribute("userPassword");
    return factory.createAuthenticationManager();
}
@Bean
public UserDetailsService userDetailsService(LdapAuthoritiesPopulator authorities) {
    return new LdapUserDetailsService(new FilterBasedLdapUserSearch("", "(uid={0})", this.getDefaultSpringSecurityContextSource()), authorities);
}</pre> <p>If this isn’t <a id="_idIndexMarker403"/>convincing, start up your <a id="_idIndexMarker404"/>LDAP server import <strong class="source-inline">calendar.ldif</strong> into it. You can then connect to the external LDAP server. Go ahead and restart the application and give this a try with the <strong class="source-inline">username</strong> as <strong class="source-inline">shauser@example.com</strong> and the <strong class="source-inline">password</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">shauser</strong></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter06.06-calendar</strong></span><span class="No-Break">.</span></p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor211"/>Explicit LDAP bean configuration</h1>
<p>In this section, we’ll lead <a id="_idIndexMarker405"/>you through the set of bean configurations required to explicitly configure both a connection to an external LDAP server and the <strong class="source-inline">LdapAuthenticationProvider</strong> interface required to support authentication against an external server. As with other explicit bean-based configurations, you really want to avoid doing this unless you find yourself in a situation where the capabilities of the security namespace style of configuration will not support your business <a id="_idTextAnchor212"/>or your <a id="_idIndexMarker406"/>technical requirements, in wh<a id="_idTextAnchor213"/>ich case, <span class="No-Break">read on!</span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor214"/>Configuring an external LDAP server reference</h2>
<p>To implement this <a id="_idIndexMarker407"/>configuration, we’ll assume that we have a local LDAP server running on port <strong class="source-inline">33389</strong>, with the same configuration corresponding to the <strong class="source-inline">DefaultSpringSecurityContextSource</strong> interface example provided in the previous section. The required bean definition is provided in the <strong class="source-inline">SecurityConfig.java</strong> file. In fact, to keep things simple, we have provided the entire <strong class="source-inline">SecurityConfig.java</strong> file. Review the LDAP server reference in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public DefaultSpringSecurityContextSource contextSource() {
    DefaultSpringSecurityContextSource defaultSpringSecurityContextSource =     new DefaultSpringSecurityContextSource(
          List.of("ldap://localhost:" + LDAP_PORT), "dc=jbcpcalendar,dc=com");
    defaultSpringSecurityContextSource.setUserDn("uid=admin,ou=system");
    defaultSpringSecurityContextSource.setPassword("secret");
    return defaultSpringSecurityContextSource;
}</pre> <p>Next, we’ll explore how we can perform a search to locate the user in the <span class="No-Break">LDAP directory.</span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor215"/>Performing a search to locate the user in the LDAP directory</h2>
<p>If you’ve read<a id="_idIndexMarker408"/> and understood the explanations throughout this chapter describing how Spring Security LDAP authentication works behind the scenes, this bean configuration will be perfectly understandable, with the <span class="No-Break">following characteristics:</span></p>
<ul>
<li>User credential binding authentication (not <span class="No-Break">password comparison)</span></li>
<li>Use of <strong class="source-inline">InetOrgPerson</strong> <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">UserDetailsContextMapper</strong></span></li>
</ul>
<p>Take a look at the <span class="No-Break">following steps:</span></p>
<ol>
<li>The first bean provided for us is <strong class="source-inline">BindAuthenticator</strong>, and the <span class="No-Break">supporting </span><span class="No-Break"><strong class="source-inline">FilterBased</strong></span><strong class="source-inline">
LdapUserSearch</strong> bean is used to locate the user’s DN in the LDAP directory prior to binding, <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public BindAuthenticator bindAuthenticator(FilterBasedLdapUserSearch userSearch, BaseLdapPathContextSource contextSource){
    BindAuthenticator bindAuthenticator = new BindAuthenticator(contextSource);
    bindAuthenticator.setUserSearch(userSearch);
    return bindAuthenticator;
}
@Bean
public FilterBasedLdapUserSearch filterBasedLdapUserSearch(BaseLdapPathContextSource contextSource){
    return new FilterBasedLdapUserSearch("", //user-search-base
          "(uid={0})", //user-search-filter
          contextSource); //ldapServer
}</pre></li> <li>Second, <strong class="source-inline">LdapAuthoritiesPopulator</strong> and <strong class="source-inline">UserDetailsContextMapper</strong> perform the roles we<a id="_idIndexMarker409"/> examined earlier in <span class="No-Break">the chapter:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public LdapAuthoritiesPopulator authoritiesPopulator(BaseLdapPathContextSource contextSource){
    DefaultLdapAuthoritiesPopulator defaultLdapAuthoritiesPopulator = new DefaultLdapAuthoritiesPopulator(contextSource,"ou=Groups");
    defaultLdapAuthoritiesPopulator.setGroupSearchFilter("(uniqueMember={0})");
    return defaultLdapAuthoritiesPopulator;
}
@Bean
public UserDetailsContextMapper userDetailsContextMapper(){
    return new InetOrgPersonContextMapper();
}</pre></li> <li>Finally, we<a id="_idIndexMarker410"/> must update Spring Security to utilize our explicitly configured <strong class="source-inline">UserDetailsService</strong> bean <span class="No-Break">as follows:</span><pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public UserDetailsService userDetailsService(FilterBasedLdapUserSearch filterBasedLdapUserSearch,
       LdapAuthoritiesPopulator authoritiesPopulator, UserDetailsContextMapper userDetailsContextMapper) {
    LdapUserDetailsService ldapUserDetailsService = new LdapUserDetailsService(filterBasedLdapUserSearch, authoritiesPopulator);
    ldapUserDetailsService.setUserDetailsMapper(userDetailsContextMapper);
    return ldapUserDetailsService;
}</pre></li> <li>At this point, we have fully configured LDAP authentication with explicit Spring bean notation. Employing this technique in the LDAP integration is useful in a few cases, such as when the security namespace does not expose certain configuration attributes, or when custom implementation classes are required to provide functionality tailored to a particular business scenario. We’ll explore one such scenario later in this chapter when we examine how to connect to Microsoft AD <span class="No-Break">via LDAP.</span></li>
<li>Go ahead and start the application and give the configuration a try with the <strong class="source-inline">username</strong> as <strong class="source-inline">shauser@example.com</strong> and the <strong class="source-inline">password</strong> <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">shauser</strong></span><span class="No-Break">.</span><p class="list-inset">Assuming you have an external LDAP server running, or you have kept the configured in-memory <strong class="source-inline">DefaultSpringSecurityContextSource</strong> object, everything <a id="_idIndexMarker411"/>should still <span class="No-Break">be working.</span></p></li>
</ol>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter06.07-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor216"/>Delegating role discovery to UserDetailsService</h2>
<p>One technique for <a id="_idIndexMarker412"/>populating user roles that are <a id="_idIndexMarker413"/>available to use with explicit bean configuration is implementing the support for looking up a user by username in <strong class="source-inline">UserDetailsService</strong> and getting the <strong class="source-inline">GrantedAuthority</strong> objects from <span class="No-Break">this source.</span></p>
<p>The configuration is as simple as replacing the bean with the <strong class="source-inline">ldapAuthoritiesPopulator</strong> ID bean with an updated <strong class="source-inline">UserDetailsService</strong> and <strong class="source-inline">LdapAuthoritiesPopulator</strong> object, with a reference to <strong class="source-inline">UserDetailsService</strong>. Make the following updates to the <strong class="source-inline">SecurityConfig.java</strong> file, ensuring you remove the previous <strong class="source-inline">ldapAuthoritiesPopulator</strong> <span class="No-Break">bean definition:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public BindAuthenticator bindAuthenticator(FilterBasedLdapUserSearch userSearch, BaseLdapPathContextSource contextSource){
    BindAuthenticator bindAuthenticator = new BindAuthenticator(contextSource);
    bindAuthenticator.setUserSearch(userSearch);
    return bindAuthenticator;
}
@Bean
public FilterBasedLdapUserSearch filterBasedLdapUserSearch(BaseLdapPathContextSource contextSource){
    return new FilterBasedLdapUserSearch("", //user-search-base
          "(uid={0})", //user-search-filter
          contextSource); //ldapServer
}
@Bean
public LdapAuthoritiesPopulator authoritiesPopulator(UserDetailsService userDetailsService){
    return new UserDetailsServiceLdapAuthoritiesPopulator(userDetailsService);
}</pre> <p>We will <a id="_idIndexMarker414"/>also need to ensure that we have<a id="_idIndexMarker415"/> defined <strong class="source-inline">userDetailsService</strong>. To keep things simple, add an in-memory <strong class="source-inline">UserDetailsService</strong> interface, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public UserDetailsManager userDetailsService() {
    InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
    manager.createUser(User.withUsername("user1@example.com").password("user1").roles("USER").build());
    manager.createUser(User.withUsername("admin1@example.com").password("admin1").roles("USER", "ADMIN").build());
    return manager;
}</pre> <p>At the end, we <a id="_idIndexMarker416"/>configured a custom <strong class="source-inline">LdapAuthenticationProvider</strong> interface, <span class="No-Break">as </span><span class="No-Break"><a id="_idIndexMarker417"/></span><span class="No-Break">follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/ SecurityConfig.java
@Bean
public LdapAuthenticationProvider authenticationProvider(BindAuthenticator ba,
       LdapAuthoritiesPopulator lap,
       UserDetailsContextMapper cm){
    LdapAuthenticationProvider ldapAuthenticationProvider =  new LdapAuthenticationProvider(ba, lap);
    ldapAuthenticationProvider.setUserDetailsContextMapper(cm);
    return ldapAuthenticationProvider;
}</pre> <p>If you have it, you will want to remove the references to <strong class="source-inline">UserDetailsService</strong> from <strong class="source-inline">AccountController</strong>, <span class="No-Break">as follows:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/web/controllers/AccountController.java
@Controller
public class AccountController {
    @RequestMapping("/accounts/my")
    public String view(Model model) {
       Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
       if(authentication == null) {
          throw new IllegalStateException("authentication cannot be null. Make sure you are logged in.");
       }
       Object principal = authentication.getPrincipal();
       model.addAttribute("user", principal);
       model.addAttribute("isLdapUserDetails", principal instanceof LdapUserDetails);
       model.addAttribute("isLdapPerson", principal instanceof Person);
       model.addAttribute("isLdapInetOrgPerson", principal instanceof InetOrgPerson);
       return "accounts/show";
    }
}</pre> <p>You should <a id="_idIndexMarker418"/>now be able to authenticate<a id="_idIndexMarker419"/> with <strong class="source-inline">admin1@example.com</strong> as the <strong class="source-inline">username</strong> and <strong class="source-inline">admin1</strong> as the <strong class="source-inline">password</strong>. Naturally, we could also substitute this in-memory <strong class="source-inline">UserDetailsService</strong> interface for the JDBC or JPA-based one we discussed in <a href="B21757_04.xhtml#_idTextAnchor106"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">JDBC-based Authentication</em>, and in <a href="B21757_05.xhtml#_idTextAnchor150"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Authentication with </em><span class="No-Break"><em class="italic">Spring Data</em></span><span class="No-Break">.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter06.08-calendar</strong></span><span class="No-Break">.</span></p>
<p>The<a id="_idIndexMarker420"/> logistical and managerial problem you <a id="_idIndexMarker421"/>may notice with this is that the usernames and roles must be managed both in the LDAP server and the repository used by <strong class="source-inline">UserDetailsService</strong>—this is probably not a scalable model for a large <span class="No-Break">user base.</span></p>
<p>The more common use of this scenario is when LDAP authentication is required to ensure that users of the secured application are valid corporate users, but the application itself wants to store authorization information. This keeps potentially application-specific data out of the LDAP directory, which can be a beneficial separation <span class="No-Break">of concerns.</span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor217"/>Integrating with Microsoft Active Directory via LDAP</h1>
<p>One of the<a id="_idIndexMarker422"/> convenient features of Microsoft AD is not only its seamless integration with Microsoft Windows-based network architectures, but also that it can be configured to expose the contents of AD using the LDAP protocol. If you are working in a company that is heavily leveraging Microsoft Windows, it is probable that any LDAP integration you do will be against your <span class="No-Break">AD instance.</span></p>
<p>Depending on your configuration of Microsoft AD (and the directory administrator’s willingness to configure it to support Spring Security LDAP), you may have a difficult time, not with the authentication and binding process, but with the mapping of AD information to the user’s <strong class="source-inline">GrantedAuthority</strong> objects within the Spring <span class="No-Break">Security system.</span></p>
<p>The sample AD LDAP tree for JBCP calendar corporate within our LDAP browser looks like the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<img alt="Figure 6.11 – Example of a Microsoft Active Directory structure" height="1141" src="image/B21757_06_11.jpg" width="1317"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Example of a Microsoft Active Directory structure</p>
<p>What you do not see <a id="_idIndexMarker423"/>here is <strong class="source-inline">ou=Groups</strong>, which we saw in our sample LDAP structure earlier; this is because AD stores group membership as attributes on the LDAP entries of the <span class="No-Break">users themselves.</span></p>
<p>We need to alter our configuration to support our AD structure. Assuming we are starting with the bean configuration detailed in the previous section, make the <span class="No-Break">following updates:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.java
@Bean
public AuthenticationProvider authenticationProvider(){
    ActiveDirectoryLdapAuthenticationProvider ap = new ActiveDirectoryLdapAuthenticationProvider(
          "corp.jbcpcalendar.com",
          "ldap://corp.jbcpcalendar.com");
    ap.setConvertSubErrorCodesToExceptions(true);
    return ap;
}
@Bean
public DefaultSpringSecurityContextSource contextSource() {
    DefaultSpringSecurityContextSource defaultSpringSecurityContextSource =     new DefaultSpringSecurityContextSource(
          List.of("ldap://corp.jbcpcalendar.com"), "dc=corp,dc=jbcpcalendar,dc=com");
    defaultSpringSecurityContextSource.setUserDn("CN=bnl,CN=Users,DC=corp,DC=jbcpcalendar,DC=com");
    defaultSpringSecurityContextSource.setPassword("admin123!");
    return defaultSpringSecurityContextSource;
}
@Bean
public FilterBasedLdapUserSearch filterBasedLdapUserSearch(BaseLdapPathContextSource contextSource) {
    return new FilterBasedLdapUserSearch("CN=Users", //user-search-base
          "(sAMAccountName={0})", //user-search-filter
          contextSource); //ldapServer
}</pre> <p>If you have it defined, you will want to remove the <strong class="source-inline">UserDetailsService</strong> declaration in the <strong class="source-inline">SecurityConfig.java</strong> file. Finally, you will want to remove the references to <strong class="source-inline">UserDetailsService</strong> <span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">AccountController</strong></span><span class="No-Break">.</span></p>
<p>The <strong class="source-inline">sAMAccountName</strong> attribute is the AD equivalent of the <strong class="source-inline">uid</strong> attribute we use in a standard LDAP entry. Although most<a id="_idIndexMarker424"/> AD LDAP integrations are likely to be more complex than this example, this should give you a starting point to jump off and explore your conceptual understanding of the inner workings of Spring Security LDAP integration; supporting even a complex integration will be <span class="No-Break">much easier.</span></p>
<p class="callout-heading">Important note</p>
<p class="callout">If you want to run this sample, you will need an instance of AD up and running that matches the schema displayed in the screenshot. The alternative is to adjust the configuration to match your AD schema. A simple way to play around with AD is to install <strong class="source-inline">Active Directory Lightweight Directory Services</strong>, which can be found at <a href="https://www.microsoft.com/fr-FR/download/details.aspx?id=1451">https://www.microsoft.com/fr-FR/download/details.aspx?id=1451</a>. Your code should look <span class="No-Break">like </span><span class="No-Break"><strong class="source-inline">chapter06.09-calendar</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor218"/>Built-in AD support in Spring Security 6.1</h2>
<p>Active Directory supports<a id="_idIndexMarker425"/> its own non-standard authentication <a id="_idIndexMarker426"/>options, and the normal usage pattern does not fit too cleanly with the standard <strong class="source-inline">LdapAuthenticationProvider</strong>. Typically, authentication is performed by using the domain username (in the form of <strong class="source-inline">user@domain</strong>), rather than using an LDAP distinguished name. To make this easier, Spring Security has an authentication provider that is customized for a typical Active <span class="No-Break">Directory setup.</span></p>
<p>Configuring <strong class="source-inline">ActiveDirectoryLdapAuthenticationProvider</strong> is quite straightforward. You need only supply the domain name and an LDAP URL that supplies the address of the server as we have covered in the previous sections. A reminder of what the configuration looks like can be found in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
//src/main/java/com/packtpub/springsecurity/configuration/SecurityConfig.ja
@Bean
public AuthenticationProvider authenticationProvider(){
    ActiveDirectoryLdapAuthenticationProvider ap = new ActiveDirectoryLdapAuthenticationProvider(
          "corp.jbcpcalendar.com",
          "ldap://corp.jbcpcalendar.com");
    ap.setConvertSubErrorCodesToExceptions(true);
    return ap;
}</pre> <p>There are a few things that should be noted about the <span class="No-Break">provided</span><span class="No-Break"><strong class="source-inline"> ActiveDirectory</strong></span><strong class="source-inline">
LdapAuthenticationProvider</strong> class, <span class="No-Break">as follows:</span></p>
<ul>
<li>The users that need to be authenticated must be able to bind to AD (there is no <span class="No-Break">manager user)</span></li>
<li>The default method for populating user authorities is to search the users <span class="No-Break"><strong class="source-inline">memberOf</strong></span><span class="No-Break"> attributes</span></li>
<li>Users must <a id="_idIndexMarker427"/>contain an attribute named <strong class="source-inline">userPrincipalName</strong>, which<a id="_idIndexMarker428"/> is in the <span class="No-Break"><strong class="source-inline">username@&lt;domain&gt;</strong></span><span class="No-Break"> format</span></li>
</ul>
<p>Due to the complex LDAP deployments that occur in the real world, the built-in support will most likely provide a guide to as how you can integrate with your custom <span class="No-Break">LDAP schema.</span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor219"/>Summary</h1>
<p>We have seen that LDAP servers can be relied on to provide authentication and authorization information, as well as rich user profile information when requested. In this chapter, we covered the LDAP terminology and concepts, and how LDAP directories might be commonly organized to work with Spring Security. We also explored the configuration of both standalone (embedded) and external LDAP servers from a Spring Security <span class="No-Break">configuration file.</span></p>
<p>We covered the authentication and authorization of users against LDAP repositories, and their subsequent mapping to Spring Security actors. We also saw the differences in authentication schemes, password storage, and security mechanisms in LDAP, and how they are treated in Spring Security. We also learned to map user detail attributes from the LDAP directory to the <strong class="source-inline">UserDetails</strong> object for rich information exchange between LDAP and the Spring-enabled application. We also explained bean configuration for LDAP and the pros and cons of this approach. Lastly, we also covered integration with <span class="No-Break">Microsoft AD.</span></p>
<p>In the next chapter, we will discuss Spring Security’s <strong class="source-inline">remember-me</strong> feature, which allows a user’s session to securely persist even after closing <span class="No-Break">the browser.</span></p>
</div>
</div></body></html>