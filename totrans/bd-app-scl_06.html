<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0; Persistence with Slick" id="aid-23MNU1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6.  Persistence with Slick </h1></div></div></div><p>In the previous chapters, you learned to bootstrap your application using Activator, we developed our web application using Scala and Play framework, and we added Reactive microservices calls using RxScala for data flow computations. We performed unit tests and controller testing using the BDD and Play frameworks.</p><p>In this chapter, you will learn how to achieve relational database persistence. So far, we have our application up and running. However, we are using in-memory persistence with HashMap. Now we will upgrade our application to use proper persistence. In order to achieve this, we will use a reactive database persistence framework called Slick.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Principles of database persistence with Slick</li><li class="listitem">Working with Functional Relational Mapping in our application</li><li class="listitem">Creating Queries with SQL support</li><li class="listitem">Improving code with Async database operations</li></ul></div><p>We will do some refactoring in our application. Step-by-step, we will create all the tables and persistence classes that we need to have Slick working with our Play framework application. Tests will be refactored as well in order to test the application logic, and skip the database persistence part.</p><div class="section" title="Introducing the Slick framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec63"/>Introducing the Slick framework</h1></div></div></div><p>
<span class="strong"><strong>Scala Language Integrated Connection Kit</strong></span> (<span class="strong"><strong>Slick</strong></span>) is a Scala modern framework, which allows working with data using abstractions that are very similar to Scala collections. You can write database queries in both SQL and Scala code. Writing Scala code instead of SQL is better, because we leverage the compiler, and hence, this approach is less error-prone. Also, it becomes easier to maintain the code, since the compiler will help you by pointing out where the code breaks, if it happens.</p><p>Slick is a <span class="strong"><strong>Functional Relational Mapping</strong></span> (<span class="strong"><strong>FRM</strong></span>) library. Those of you who come from a Java background, and are familiar with <span class="strong"><strong>Object Relational Mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>) frameworks such as Hibernate, will see that Slick has similar concepts. Basically, you create a Scala class, which will explicitly map to a relational table. Slick FRM ideas are inspired by Microsoft's LINQ framework.</p><p>Slick is reactive by design, and works in an asynchronous non-blocking IO model. Using Slick you have the following advantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>Resilience</strong></span>: A common issue is that a heavy load on the DB and application creates more threads, and makes the situation worse. Slick can fix this problem, because it queues database operations in the DB.</li><li class="listitem"><span class="strong"><strong>Efficient Resources utilization</strong></span>: Slick can be tuned for parallelism in terms of the number of active jobs and suspended database sessions. Slick also has a clean demarcation between I/O and CPU-intensive code.</li></ul></div></div></div>
<div class="section" title="MySQL setup" id="aid-24L8G1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec64"/>MySQL setup</h1></div></div></div><p>We will use Slick with MySQL 5.6. However, Slick supports other relational databases like Oracle, SQL Server, DB2, and Postgres. First of all, we need to install MySQL in our machine. Open the console, and perform the following steps (for Ubuntu Linux, other OS (Windows/Mac), and distros, check out <a class="ulink" href="http://dev.mysql.com/downloads/mysql/">http://dev.mysql.com/downloads/mysql/</a>):</p><pre class="programlisting">
<span class="strong"><strong>$ sudo apt-get install mysql-server -y</strong></span>
<span class="strong"><strong>$ mysql --version</strong></span>
<span class="strong"><strong>$ service mysql status</strong></span>
</pre><p>After installation with <code class="literal">apt-get</code>, when you run the other two commands, you should see an output like this:</p><p>
</p><div class="mediaobject"><img src="../Images/image00290.jpeg" alt="MySQL setup"/><div class="caption"><p>MySQL Installation</p></div></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once the installation is done and the MySQL server is up and running, we can move on and create the database. In order to get this, we will need to open the MySQL console. For development reasons, I did not put a password for root. However, for production, it is strongly recommended that you do use a strong password.</p><p>Execute the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ mysql -u root -p</strong></span>
</pre><p>This will give output as follows:</p><p>
</p><div class="mediaobject"><img src="../Images/image00291.jpeg" alt="MySQL setup"/><div class="caption"><p>MySQL Console</p></div></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Once you enter the MySQL console, you can create the database. We will create a database named <code class="literal">RWS_DB</code> using the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ CREATE DATABASE RWS_DB; </strong></span>
</pre><p>You will see the following result:</p><p>
</p><div class="mediaobject"><img src="../Images/image00292.jpeg" alt="MySQL setup"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>You can type <code class="literal">$ SHOW DATABASES;</code> in order to get a list of all the available databases in MySQL. All set, we have our database up and running.</p></div>
<div class="section" title="Configuring Slick in our Play framework app" id="aid-25JP21"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec65"/>Configuring Slick in our Play framework app</h1></div></div></div><p>First, we need to add dependencies to the <code class="literal">build.sbt</code> file. We will need to remove or comment a library called <code class="literal">JDBC</code> and add the <code class="literal">play-slick</code> libraries and MySQL java driver.</p><p>This is done as follows:</p><pre class="programlisting">    name := """ReactiveWebStore""" 
    version := "1.0-SNAPSHOT" 
    lazy val root = (project in file(".")).enablePlugins(PlayScala) 
    scalaVersion := "2.11.7" 
    libraryDependencies ++= Seq(   //jdbc, 
      cache, 
      ws, 
      "org.scalatestplus.play" %% "scalatestplus-play" % "1.5.1" %  
      Test, 
      "com.netflix.rxjava" % "rxjava-scala" % "0.20.7", 
      "com.typesafe.play" %% "play-slick" % "2.0.0", 
      "com.typesafe.play" %% "play-slick-evolutions" % "2.0.0", 
      "mysql" % "mysql-connector-java" % "6.0.3" 
    ) 
    resolvers += "scalaz-bintray" at "http://dl.bintray.com/scalaz/releases" 
    resolvers += DefaultMavenRepository 
</pre><p>As you can see in the preceding code, we comment out the <code class="literal">JDBC</code> library, and add three new dependencies:</p><pre class="programlisting">    "com.typesafe.play" %% "play-slick" % "2.0.0", 
    "com.typesafe.play" %% "play-slick-evolutions" % "2.0.0", 
    "mysql" % "mysql-connector-java" % "6.0.3" 
</pre><p>You can go to the console and run the commands <code class="literal">$ activator</code>, <code class="literal">$ reload</code>, and <code class="literal">$ compile</code> in order to get SBT to download all the new dependencies.</p><div class="section" title="Configure the database connection"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec91"/>Configure the database connection</h2></div></div></div><p>Slick needs to be configured to access the MySQL database that we created. Under the folder <code class="literal">ReactiveWebStore/conf</code>, we need to edit the <code class="literal">application.conf</code> file and add the database connection URL and settings as follows:</p><pre class="programlisting">    # Default database configuration 
    slick.dbs.default.driver="slick.driver.MySQLDriver$" 
    slick.dbs.default.db.driver="com.mysql.cj.jdbc.Driver" 
    slick.dbs.default.db.url="jdbc:mysql://127.0.0.1:3306/RWS_DB?
    useUnicode=true&amp;useJDBCCompliantTimezoneShift=
    true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=UTC" 
    slick.dbs.default.db.user="root" 
    slick.dbs.default.db.password="" 
</pre></div></div>
<div class="section" title="FPM Mapping"><div class="titlepage" id="aid-26I9K2"><div><div><h1 class="title"><a id="ch06lvl1sec66"/>FPM Mapping</h1></div></div></div><p>The next step is to create FPM mapping between our Scala code and MySQL tables under <code class="literal">ReactiveWebStore/app</code>, we will create a new package called <code class="literal">dao</code>. DAO stands for <span class="strong"><strong>Database Access Object</strong></span> (<span class="strong"><strong>DAO</strong></span>), and is a well-known OO pattern. So we will create some DAO classes here. First we will define a base trait, which will define the behavior and code capability for each of our <code class="literal">dao</code> packages.</p><p>We will start with <code class="literal">BaseDao.scala</code>:</p><pre class="programlisting">    package dao 
    import slick.lifted.TableQuery 
    import scala.concurrent.Future 
    /** 
    * Defines base dao structure every dao should have. 
    */ 
    trait BaseDao[T] { 
      def toTable():TableQuery[_]   
      def findAll():Future[Seq[T]] 
      def remove(id:Long):Future[Int] 
      def insert(o:T):Future[Unit] 
      def update(o:T):Future[Unit] 
      def findById(id:Long):Future[Option[T]] 
    } 
</pre><p>We will have three <code class="literal">dao</code> packages: <code class="literal">ProductDao</code>, <code class="literal">ImageDao</code>, and <code class="literal">ReviewDao</code>. Each <code class="literal">dao</code> will be able to perform  an operation, but over a different MySQL table. According to the trait we just defined, we will be able to do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong>findAll</strong></span>: Find all data for a specific table</li><li class="listitem"><span class="strong"><strong>remove</strong></span>: Delete an item in a table by ID</li><li class="listitem"><span class="strong"><strong>insert</strong></span>: Add new data to a table</li><li class="listitem"><span class="strong"><strong>update</strong></span>: Update data in a table</li><li class="listitem"><span class="strong"><strong>findbyId</strong></span>: Get a specific record in a table, filtered by ID</li><li class="listitem"><span class="strong"><strong>toTable</strong></span>: Return the table FRM mapping for that <code class="literal">dao</code>.</li></ul></div><div class="section" title="ProductDao"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec92"/>ProductDao</h2></div></div></div><p>We will start with having a look at <code class="literal">ProductDao.scala</code>:</p><pre class="programlisting">    package dao 
    trait IProductDao extends BaseDao[Product]{ 
      def findAll(): Future[Seq[Product]] 
      def findById(id:Long): Future[Option[Product]] 
      def remove(id:Long): Future[Int] 
      def insert(p:Product): Future[Unit] 
      def update(p2:Product): Future[Unit] 
    } 
    class ProductDao @Inject() (protected val dbConfigProvider: DatabaseConfigProvider)  
    extends  
    HasDatabaseConfigProvider[JdbcProfile] with IProductDao { 
      import driver.api._   
      class ProductTable(tag: Tag) extends Table[Product](tag,  
      models.ProductDef.toTable) { 
        def id = column[Option[Long]]("ID", O.PrimaryKey) 
        def name = column[String]("NAME") 
        def details = column[String]("DETAILS") 
        def price = column[BigDecimal]("PRICE") 
        def * = (id, name, details, price) &lt;&gt; (Product.tupled,  
        Product.unapply _) 
      } 
      override def toTable = TableQuery[ProductTable] 
      private val Products = toTable() 
      override def findAll(): Future[Seq[Product]] =  
      db.run(Products.result)  
      override def findById(id:Long): Future[Option[Product]] =  
      db.run(Products.filter( _.id === id).result.headOption) 
      override def remove(id:Long): Future[Int] =  
      db.run(Products.filter( _.id === id).delete)  
      override def insert(p:Product): Future[Unit] = db.run(Products    
      += p).map { _ =&gt; () } 
      override def update(p2:Product) = Future[Unit] { 
        db.run( 
          Products.filter(_.id === p2.id) 
          .map(p =&gt; (p.name,p.details, p.price)) 
          .update((p2.name,p2.details,p2.price)) 
        ) 
      } 
    } 
</pre><p>This is the <code class="literal">dao</code> implementation for <code class="literal">Product</code>. We have lots of new concepts here, so let's take a look at each step, one at a time. As you can see, a trait called <code class="literal">IProductDao</code> which extends from <code class="literal">BaseDao</code> using generics to specify the model <code class="literal">Product</code>.</p><p>This trait is important for dependency injection using Guice. We will have two <code class="literal">dao</code> implementations for each model: one implementation using Slick and MySQL, and the other using our previous <code class="literal">inMemory</code> database for testing purpose.</p><p>There is a class there called <code class="literal">ProductDao</code> which is the <code class="literal">dao</code> implementation using Slick. We need Guice to inject a class here, called <code class="literal">DatabaseConfigProvider</code>, which will be used to perform the database operations. <code class="literal">ProductDao</code> also needs to extend <code class="literal">HasDatabaseConfigProvider[JdbcProfile]</code> to work with the database.</p><p>We also need to import the <code class="literal">driver</code> api via the following command:</p><pre class="programlisting">
<span class="strong"><strong>Import driver.api._</strong></span>
</pre><p>The next step is to create FRM mapping with a class called <code class="literal">ProductTable</code>, which extends table passing the model, which in our case is a product. You also need to announce the name of the MySQL table. In order to get the table name, we use a companion object, which we need to create around our models. We do it this way in order to avoid duplicating the MySQL table name everywhere.</p><p>In the <code class="literal">ProductTable</code> table, you can see some functions such as <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">price</code>, and <code class="literal">details</code>. These are the exact name of the fields of <code class="literal">model.Product</code>. However, we have to add the mapping to the MySQL table on the right side. We do it using a function called <code class="literal">column</code> where we pass the type and the exact MySQL field name.</p><p>Finally, we need to run a special projection function called <code class="literal">*</code> to pass all the fields on the model, which are being mapped to the relational database.</p><p>Now we can move to the <code class="literal">dao</code> operations. As you can see, all the functions use <code class="literal">db.run</code> to perform data access. This is great because, as you can realize, they return a Future so the <code class="literal">dao</code> won't be blocking, and you can do something else, for instance, more database operations, pre-optimizations, and validations.</p><p>Once we have a <code class="literal">ProductTable</code> table, we can create a Slick <code class="literal">TableQuery</code> with it to perform database operations as if they are Scala functions. In order to list all the available products, we just use this command:</p><pre class="programlisting">
<span class="strong"><strong>db.run(Products.result)</strong></span>
</pre><p>It is as simple as that. This code will return a <code class="literal">Future [Seq[Products]]</code>. We can also filter by ID using this:</p><pre class="programlisting">
<span class="strong"><strong>db.run(Products.filter( _.id === id).result.headOption)</strong></span>
</pre><p>So, <code class="literal">first _.id</code> is the <code class="literal">id</code> on the database, and <code class="literal">id</code> is the one that comes by parameter. After getting the result, you can see that we called another function called <code class="literal">headOption</code>, which makes sure that we get the result as an option. This is a great pattern to rely on, since the data might not be there on the table, and we avoid getting <code class="literal">NoSuchElementException</code>.</p><p>Removing a product is fairly trivial as well. We just use the following:</p><pre class="programlisting">
<span class="strong"><strong>db.run(Products.filter( _.id === id).delete)</strong></span>
</pre><p>This preceding code returns <code class="literal">Future[Int]</code>, counting the number of items that were deleted. If the record ID is not found in the database, the result will be <code class="literal">0</code>. We expect it to be always <code class="literal">1</code>, since we are going to delete by ID. However, the API is generic, and if, let's say, you delete by name or another field, you might have multiple deletes. That's why it is an <code class="literal">Int</code> and not a Boolean.</p><p>Inserting data is easy too; we just give the following command:</p><pre class="programlisting">
<span class="strong"><strong>db.run(Products += p).map { _ =&gt; () }</strong></span>
</pre><p>As you can see, it is a very simple <code class="literal">map</code> function as if we were adding an element to a list. This code returns unit, which means nothing. However, we still have a Future, so this code is not blocking.</p><p>To perform an update, there is a little bit more code, but it is still simple at the end of the day.</p><pre class="programlisting">    db.run( 
      Products.filter(_.id === p2.id) 
      .map(p =&gt; (p.name,p.details, p.price)) 
      .update((p2.name,p2.details,p2.price)) 
    ) 
</pre><p>First we need to apply a filter to select the records that we will update. We pass the ID, because we just want to update a single record. Then we need to apply a <code class="literal">map</code> function to pick the fields that we want to update;  finally, we perform the update, passing the new values to the <code class="literal">update</code> function.</p><p>Let's take a look at the companion object for the product model.</p><p>Here is the code for <code class="literal">Models.Product.scala</code>:</p><pre class="programlisting">    object ProductDef{ 
      def toTable:String = "Product" 
    } 
</pre><p>As you can see, this is a simple helper companion object to hold the MySQL table name.</p></div><div class="section" title="ReviewDAO"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec93"/>ReviewDAO</h2></div></div></div><p>We are done with <code class="literal">ProductDao</code>, and now we need to move to the review model and create <code class="literal">dao</code> for reviews. We will perform steps similar to the ones we did for the product.</p><p>
<code class="literal">ReviewDao.scala</code> is as follows:</p><pre class="programlisting">    package dao 
    trait IReviewDao extends BaseDao[Review]{ 
      def findAll(): Future[Seq[Review]] 
      def findById(id:Long): Future[Option[Review]] 
      def remove(id:Long): Future[Int] 
      def insert(p:Review): Future[Unit] 
      def update(p2:Review): Future[Unit] 
    } 
    class ReviewDao @Inject() (protected val dbConfigProvider: DatabaseConfigProvider)  
    extends HasDatabaseConfigProvider[JdbcProfile] with IReviewDao { 
      import driver.api._ 
      class ReviewTable(tag: Tag) extends Table[Review](tag,  
      models.ReviewDef.toTable) { 
        def id = column[Option[Long]]("ID", O.PrimaryKey)   
        def productId = column[Option[Long]]("PRODUCT_ID") 
        def author = column[String]("AUTHOR") 
        def comment = column[String]("COMMENT") 
        def * = (id, productId, author,comment) &lt;&gt; (Review.tupled,  
        Review.unapply _) 
      } 
      override def toTable = TableQuery[ReviewTable] 
      private val Reviews = toTable() 
      override def findAll(): Future[Seq[Review]] =  
      db.run(Reviews.result)  
      override def findById(id:Long): Future[Option[Review]] =  
      db.run(Reviews.filter( _.id === id).result.headOption) 
      override def remove(id:Long): Future[Int] =  
      db.run(Reviews.filter( _.id === id).delete) 
      override def insert(r:Review): Future[Unit] =  
      db.run(Reviews += r).map { _ =&gt; () } 
      override def update(r2:Review) = Future[Unit] { 
        db.run( 
          Reviews.filter(_.id === r2.id) 
          .map(i =&gt; (i.productId,i.author, i.comment)) 
          .update((r2.productId,r2.author,r2.comment)) 
        ) 
      } 
    } 
</pre><p>In the preceding code, we have the elements that we saw in <code class="literal">ProductDao</code>. There is an interface for <code class="literal">dao</code> called <code class="literal">IReviewDao</code>, which extends <code class="literal">BaseDao</code> using the review model. We have the <code class="literal">ReviewDao</code> implementation with the <code class="literal">ReviewTable</code> FRM mapping. We also have a companion object for the review model.</p><p>
<code class="literal">Review.scala</code> is as follows:</p><pre class="programlisting">    object ReviewDef{ 
      def toTable:String = "Review" 
    } 
</pre></div><div class="section" title="ImageDao"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec94"/>ImageDao</h2></div></div></div><p>Now we need to move to our last <code class="literal">dao</code>, <code class="literal">ImageDao</code>. Like <code class="literal">ProductDao</code> and <code class="literal">ReviewDao</code>, we will go through the same ideas and concepts as implementation too.</p><p>We will now look at <code class="literal">ImageDao.scala</code>:</p><pre class="programlisting">    package dao 
    trait IImageDao extends BaseDao[Image]{ 
      def findAll(): Future[Seq[Image]] 
      def findById(id:Long): Future[Option[Image]] 
      def remove(id:Long): Future[Int] 
      def insert(p:Image): Future[Unit] 
      def update(p2:Image): Future[Unit] 
    } 
    class ImageDao @Inject() (protected val dbConfigProvider: DatabaseConfigProvider)  
    extends    
    HasDatabaseConfigProvider[JdbcProfile]  
    with IImageDao { 
      import driver.api._ 
      class ImageTable(tag: Tag) extends Table[Image](tag,  
      models.ImageDef.toTable) {  
        def id = column[Option[Long]]("ID", O.PrimaryKey) 
        def productId = column[Option[Long]]("PRODUCT_ID")  
        def url = column[String]("URL") 
        def * = (id, productId, url) &lt;&gt; (Image.tupled, Image.unapply  
        _) 
      } 
      override def toTable = TableQuery[ImageTable] 
      private val Images = toTable() 
      override def findAll(): Future[Seq[Image]] =  
      db.run(Images.result) 
      override def findById(id:Long): Future[Option[Image]] =  
      db.run(Images.filter( _.id === id).result.headOption) 
      override def remove(id:Long): Future[Int] =  
      db.run(Images.filter( _.id === id).delete) 
      override def insert(i:Image): Future[Unit] =  
      db.run(Images += i).map { _ =&gt; () } 
      override def update(i2:Image) = Future[Unit]  
      {db.run( 
        Images.filter(_.id === i2.id)   
        .map(i =&gt; (i.productId,i.url))   
        .update((i2.productId,i2.url)) 
      )} 
    } 
</pre><p>We also need to have a companion object helper for the image.</p><p>
<code class="literal">Image.scala</code> is as follows:</p><pre class="programlisting">    object ImageDef{ 
      def toTable:String = "Image" 
    } 
</pre></div></div>
<div class="section" title="Slick evolutions" id="aid-27GQ61"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec67"/>Slick evolutions</h1></div></div></div><p>Slick won't create the table for us, unless we create an evolution. Slick keeps track of the database state and creates and applies SQL commands for us. Evolutions need be located at <code class="literal">ReactiveWebStore/conf/evolutions/default</code>, where <code class="literal">default</code> is the name of the database we configured in <code class="literal">application.conf</code>. Evolutions need to be named in a sequential way so that we can preserve order and Slick can keep track of the changes. Right now, we will create an evolution for <code class="literal">ProductDao</code>, because we need a product table.</p><p>The code will be as follows with the name <code class="literal">1.sql</code>:</p><pre class="programlisting">
<span class="strong"><strong># --- !Ups</strong></span>
<span class="strong"><strong>CREATE TABLE Product (ID INT NOT NULL AUTO_INCREMENT,NAME VARCHAR(100) NOT NULL,DETAILS VARCHAR(250),PRICE DOUBLE NOT NULL,PRIMARY KEY ( ID ));</strong></span>
<span class="strong"><strong># --- !Downs</strong></span>
<span class="strong"><strong># drop table "Product";</strong></span>
</pre><p>We need evolutions for th review and image as well. So we need to create <code class="literal">2.sql</code> for the image and <code class="literal">3.sql</code> for the review.</p><p>The code will be as follows for <code class="literal">2.sql</code>:</p><pre class="programlisting">
<span class="strong"><strong># --- !Ups</strong></span>
<span class="strong"><strong>CREATE TABLE Image (ID INT NOT NULL AUTO_INCREMENT,PRODUCT_ID INT NOT NULL,URL VARCHAR(250),PRIMARY KEY ( ID ));</strong></span>
<span class="strong"><strong># --- !Downs</strong></span>
<span class="strong"><strong># drop table "Product";</strong></span>
</pre><p>The code will be as follows with the name <code class="literal">3.sql</code>:</p><pre class="programlisting">
<span class="strong"><strong># --- !Ups</strong></span>
<span class="strong"><strong>CREATE TABLE Review (ID INT NOT NULL AUTO_INCREMENT,PRODUCT_ID INT NOT NULL,AUTHOR VARCHAR(250),COMMENT VARCHAR(250),PRIMARY KEY ( ID ));</strong></span>
<span class="strong"><strong># --- !Downs</strong></span>
<span class="strong"><strong># drop table "Review";</strong></span>
</pre></div>
<div class="section" title="Refactoring services" id="aid-28FAO1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec68"/>Refactoring services</h1></div></div></div><p>We need to change the default base trait for our <code class="literal">dao</code> packages to return Futures now.</p><p>Let's start with <code class="literal">BaseServices.scala</code>:</p><pre class="programlisting">    package services 
    import scala.concurrent.Future 
    trait BaseService[A] { 
      def insert(a:A):Future[Unit] 
      def update(id:Long,a:A):Future[Unit] 
      def remove(id:Long):Future[Int] 
      def findById(id:Long):Future[Option[A]] 
      def findAll():Future[Option[Seq[A]]] 
    } 
</pre><p>This last implementation reflects what's happening in the <code class="literal">dao</code> packages. Now we can move to the services implementation, and proceed with our refactoring.</p><p>Next we see <code class="literal">ProductService.scala</code>:</p><pre class="programlisting">    package services 
    trait IProductService extends BaseService[Product]{ 
      def insert(product:Product):Future[Unit] 
      def update(id:Long,product:Product):Future[Unit] 
      def remove(id:Long):Future[Int] 
      def findById(id:Long):Future[Option[Product]] 
      def findAll():Future[Option[Seq[Product]]] 
      def findAllProducts():Seq[(String,String)] 
    } 
    @Singleton 
    class ProductService  
    @Inject() (dao:IProductDao)  
    extends IProductService{ 
      import play.api.libs.concurrent.Execution.Implicits. 
      defaultContext 
      def insert(product:Product):Future[Unit] = { 
        dao.insert(product); 
      } 
      def update(id:Long,product:Product):Future[Unit] = { 
        product.id = Option(id.toInt) 
        dao.update(product) 
      } 
      def remove(id:Long):Future[Int] = { 
        dao.remove(id) 
      } 
      def findById(id:Long):Future[Option[Product]] = { 
        dao.findById(id) 
      } 
      def findAll():Future[Option[Seq[Product]]] = { 
        dao.findAll().map { x =&gt; Option(x) } 
      } 
      private def validateId(id:Long):Unit = { 
        val future = findById(id) 
        val entry = Awaits.get(5, future)   
        if (entry==null || entry.equals(None)) throw new  
        RuntimeException("Could not find Product: " + id) 
      } 
      def findAllProducts():Seq[(String,String)] = { 
        val future = this.findAll() 
        val result = Awaits.get(5, future)   
        val products:Seq[(String,String)] = result 
        .getOrElse(Seq(Product(Some(0),"","",0))) 
        .toSeq 
        .map { product =&gt; (product.id.get.toString,product.name) } 
        return products 
      } 
    } 
</pre><p>There are a couple of changes here. First, we inject an <code class="literal">IProductDao</code>, and let Guice figure out the right injection that we need to be able to test with our old <code class="literal">in-memory</code> HashMap implementation, which will be covered later in this chapter.</p><p>The changes involve new function signatures, using <code class="literal">Awaits</code>, and using <code class="literal">Seq</code> instead of <code class="literal">List</code>.</p><p>Let's move to on <code class="literal">ReviewService.scala</code> now.</p><pre class="programlisting">    package services 
    trait IReviewService extends BaseService[Review]{ 
      def insert(review:Review):Future[Unit] 
      def update(id:Long,review:Review):Future[Unit] 
      def remove(id:Long):Future[Int] 
      def findById(id:Long):Future[Option[Review]] 
      def findAll():Future[Option[Seq[Review]]] 
    } 
    @Singleton 
    class ReviewService @Inject() (dao:IReviewDao)  
    extends IReviewService{ 
      import play.api.libs.concurrent.Execution. 
      Implicits.defaultContext 
      def insert(review:Review):Future[Unit] = { 
      dao.insert(review);} 
      def update(id:Long,review:Review):Future[Unit] = { 
        review.id = Option(id.toInt) 
        dao.update(review)   
      } 
      def remove(id:Long):Future[Int] = { 
        dao.remove(id) 
      } 
      def findById(id:Long):Future[Option[Review]] = { 
        dao.findById(id) 
      } 
      def findAll():Future[Option[Seq[Review]]] = { 
        dao.findAll().map { x =&gt; Option(x) } 
      } 
      private def validateId(id:Long):Unit = { 
        val future = findById(id) 
        val entry = Awaits.get(5, future) 
        if (entry==null || entry.equals(None)) throw new  
        RuntimeException("Could not find Review: " + id) 
      }  
    }     
</pre><p>In the preceding code, we have the same kind of changes that we made for the product. Let's move to <code class="literal">ImageService.scala</code>, which is our last service.</p><pre class="programlisting">    package services 
    trait IImageService extends BaseService[Image]{ 
      def insert(image:Image):Future[Unit] 
      def update(id:Long,image:Image):Future[Unit] 
      def remove(id:Long):Future[Int] 
      def findById(id:Long):Future[Option[Image]] 
      def findAll():Future[Option[Seq[Image]]] 
    } 
    @Singleton 
    class ImageService @Inject() (dao:IImageDao)  
    extends IImageService { 
      import play.api.libs.concurrent.Execution. 
      Implicits.defaultContext 
      def insert(image:Image):Future[Unit] = { 
        dao.insert(image) 
      } 
      def update(id:Long,image:Image):Future[Unit] = { 
        image.id = Option(id.toInt) 
        dao.update(image)  
      } 
      def remove(id:Long):Future[Int] = { 
        dao.remove(id) 
      } 
      def findById(id:Long):Future[Option[Image]] = { 
        dao.findById(id) 
      } 
      def findAll():Future[Option[Seq[Image]]] = { 
        dao.findAll().map { x =&gt; Option(x) } 
      } 
      private def validateId(id:Long):Unit = { 
        val future = findById(id) 
        val entry = Awaits.get(5, future) 
        if (entry==null ||entry.equals(None) ) throw new  
        RuntimeException("Could not find Image: " + id)  
      } 
    } 
</pre><p>We have refactored all services to use the new <code class="literal">dao</code> packages implementation. Now the next step is the move to the controllers.</p></div>
<div class="section" title="Refactoring controllers" id="aid-29DRA1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec69"/>Refactoring controllers</h1></div></div></div><p>Now we have all the <code class="literal">dao</code> packages implemented with the respective database evolutions. However, our services expected a different contract, since we were using an in-memory database before. Let's refactor the product controller:</p><pre class="programlisting">    package controllers 
    @Singleton 
    class ProductController @Inject() (val messagesApi:MessagesApi,val service:IProductService)  
    extends Controller with I18nSupport { 
      val productForm: Form[Product] = Form( 
        mapping( 
          "id" -&gt; optional(longNumber), 
          "name" -&gt; nonEmptyText, 
          "details" -&gt; text, 
          "price" -&gt; bigDecimal 
        )(models.Product.apply)(models.Product.unapply) 
      ) 
      def index = Action { implicit request =&gt; 
        val products = Awaits.get(5,service.findAll()) 
        .getOrElse(Seq())   
        Logger.info("index called. Products: " + products) 
        Ok(views.html.product_index(products)) 
      } 
      def blank = Action { implicit request =&gt; 
        Logger.info("blank called. ") 
        Ok(views.html.product_details(None, productForm)) 
      } 
      def details(id: Long) = Action { implicit request =&gt; 
        Logger.info("details called. id: " + id) 
        val product = Awaits.get(5,service.findById(id)).get 
        Ok(views.html.product_details(Some(id),  
        productForm.fill(product))) 
      } 
      def insert()= Action { implicit request =&gt; 
        Logger.info("insert called.") 
        productForm.bindFromRequest.fold( 
          form =&gt; {  
            BadRequest(views.html.product_details(None, form)) 
          }, 
          product =&gt; {  
            service.insert(product) 
            Redirect(routes.ProductController.index). 
            flashing("success" -&gt; Messages("success.insert",  
            "new product created")) 
          } 
        ) 
      } 
      def update(id: Long) = Action { implicit request =&gt; 
        Logger.info("updated called. id: " + id) 
        productForm.bindFromRequest.fold( 
          form =&gt; { 
            Ok(views.html.product_details(Some(id),  
            form)).flashing("error" -&gt; "Fix the errors!") 
          }, 
          product =&gt; { 
            service.update(id,product)  
            Redirect(routes.ProductController.index).flashing  
            ("success" -&gt; Messages("success.update", product.name)) 
          } 
        ) 
      } 
      def remove(id: Long)= Action { 
        import play.api.libs.concurrent.Execution. 
        Implicits.defaultContext 
        val result = Awaits.get(5,service.findById(id)) 
        result.map { product =&gt; 
          service.remove(id) 
          Redirect(routes.ProductController.index).flashing("success"  
          -&gt; Messages("success.delete", product.name)) 
        }.getOrElse(NotFound) 
      } 
    } 
</pre><p>There are two big changes in the preceding code despite the new function signatures. First, we use a utility function called <code class="literal">get</code> from a class called <code class="literal">Awaits</code>. This is needed so that we wait for the result to come back from the database. Second, when we flash the result, we no longer show the <code class="literal">id</code>, we just display a text message. Let's take a look at the <code class="literal">Awaits</code> implementation in <code class="literal">Utils.Awaits.scala</code>, which is as follows:</p><pre class="programlisting">    package utils 
    object Awaits { 
      def get[T](sec:Int,f:Future[T]):T = { 
        Await.result[T](f, sec seconds) 
      } 
    } 
</pre><p>
<code class="literal">Awaits</code> is just a simple utility class that waits for a period of time to get a Future result. We need to add some tweaks in <code class="literal">ReviewController</code> and <code class="literal">ImageController</code> as well.</p><p>We will first explore <code class="literal">ReviewController.scala</code>:</p><pre class="programlisting">    package controllers 
    @Singleton 
    class ReviewController @Inject() 
    (val messagesApi:MessagesApi,val productService:IProductService, 
    val service:IReviewService) 
    extends Controller with I18nSupport { 
      val reviewForm:Form[Review] = Form( 
        mapping( 
          "id" -&gt; optional(longNumber), 
          "productId" -&gt; optional(longNumber), 
          "author" -&gt; nonEmptyText, 
          "comment" -&gt; nonEmptyText 
        )(models.Review.apply)(models.Review.unapply)  
      ) 
      def index = Action { implicit request =&gt; 
        val reviews = Awaits.get(5,service.findAll()).getOrElse(Seq()) 
        Logger.info("index called. Reviews: " + reviews) 
        Ok(views.html.review_index(reviews)) 
      } 
      def blank = Action { implicit request =&gt; 
        Logger.info("blank called. ") 
        Ok(views.html.review_details(None,  
        reviewForm,productService.findAllProducts)) 
      } 
      def details(id: Long) = Action { implicit request =&gt; 
        Logger.info("details called. id: " + id) 
        val review = Awaits.get(5,service.findById(id)).get 
        Ok(views.html.review_details(Some(id),  
        reviewForm.fill(review),productService.findAllProducts)) 
      } 
      def insert()= Action { implicit request =&gt; 
        Logger.info("insert called.") 
        reviewForm.bindFromRequest.fold( 
          form =&gt; { 
            BadRequest(views.html.review_details(None,  
            form,productService.findAllProducts)) 
          }, 
          review =&gt; { 
            if (review.productId==null || review.productId.isEmpty) { 
              Redirect(routes.ReviewController.blank).flashing("error"  
              -&gt; "Product ID Cannot be Null!") 
            }else { 
              Logger.info("Review: " + review) 
              if (review.productId==null ||  
              review.productId.getOrElse(0)==0) throw new  
              IllegalArgumentException("Product Id Cannot Be Null") 
              service.insert(review)   
              Redirect(routes.ReviewController.index). 
              flashing("success" -&gt; Messages("success.insert",  
              "new Review")) 
            } 
          } 
        ) 
      } 
      def update(id: Long) = Action { implicit request =&gt; 
        Logger.info("updated called. id: " + id)  
        reviewForm.bindFromRequest.fold( 
          form =&gt; { 
            Ok(views.html.review_details(Some(id),  
            form,productService.findAllProducts)). 
            flashing("error" -&gt; "Fix the errors!") 
          }, 
          review =&gt; { 
            service.update(id,review)  
            Redirect(routes.ReviewController.index). 
            flashing("success" -&gt; Messages("success.update",  
            review.productId)) 
          } 
        ) 
      } 
      def remove(id: Long)= Action {  
        import play.api.libs.concurrent.Execution. 
        Implicits.defaultContext 
        val result = Awaits.get(5,service.findById(id)) 
        result.map { review =&gt; 
          service.remove(id) 
          Redirect(routes.ReviewController.index).flashing("success" - 
          &gt; Messages("success.delete", review.productId)) 
        }.getOrElse(NotFound) 
      } 
    } 
</pre><p>For <code class="literal">ReviewController</code>, we have made the same changes that we did for the product, that is, the use of <code class="literal">Awaits</code> and labels on flash returns.</p><p>Let's move on to the final controller: <code class="literal">ImageController.scala.</code>
</p><pre class="programlisting">    package controllers 
    @Singleton 
    class ImageController @Inject() 
    (val messagesApi:MessagesApi, 
    val productService:IProductService, 
    val service:IImageService) 
    extends Controller with I18nSupport { 
      val imageForm:Form[Image] = Form( 
        mapping( 
          "id" -&gt; optional(longNumber), 
          "productId" -&gt; optional(longNumber), 
          "url" -&gt; text 
        )(models.Image.apply)(models.Image.unapply) 
      ) 
      def index = Action { implicit request =&gt; 
        val images = Awaits.get(5,service.findAll()).getOrElse(Seq()) 
        Logger.info("index called. Images: " + images) 
        Ok(views.html.image_index(images)) 
      } 
      def blank = Action { implicit request =&gt; 
        Logger.info("blank called. ") 
        Ok(views.html.image_details(None,  
        imageForm,productService.findAllProducts)) 
      } 
      def details(id: Long) = Action { implicit request =&gt; 
        Logger.info("details called. id: " + id) 
        val image = Awaits.get(5,service.findById(id)).get 
        Ok(views.html.image_details(Some(id),  
        imageForm.fill(image),productService.findAllProducts)) 
      } 
      def insert()= Action { implicit request =&gt; 
        Logger.info("insert called.") 
        imageForm.bindFromRequest.fold( 
          form =&gt; { 
            BadRequest(views.html.image_details(None, form,  
            productService.findAllProducts)) 
          }, 
          image =&gt; { 
            if (image.productId==null ||  
            image.productId.getOrElse(0)==0) { 
              Redirect(routes.ImageController.blank).flashing 
              ("error" -&gt; "Product ID Cannot be Null!") 
            }else { 
              if (image.url==null || "".equals(image.url))  
              image.url = "/assets/images/default_product.png" 
              service.insert(image) 
              Redirect(routes.ImageController.index). 
              flashing("success" -&gt; Messages("success.insert",  
              "new image")) 
            } 
          } 
        ) 
      } 
      def update(id: Long) = Action { implicit request =&gt; 
        Logger.info("updated called. id: " + id) 
        imageForm.bindFromRequest.fold( 
          form =&gt; { 
            Ok(views.html.image_details(Some(id), form,  
            null)).flashing("error" -&gt; "Fix the errors!") 
          }, 
          image =&gt; { 
            service.update(id,image) 
            Redirect(routes.ImageController.index).flashing 
            ("success" -&gt; Messages("success.update", image.id)) 
          } 
        ) 
      } 
      def remove(id: Long)= Action { 
        import play.api.libs.concurrent.Execution. 
        Implicits.defaultContext 
        val result = Awaits.get(5,service.findById(id)) 
        result.map { image =&gt; 
          service.remove(id) 
          Redirect(routes.ImageController.index).flashing("success"  
          -&gt; Messages("success.delete", image.id)) 
        }.getOrElse(NotFound) 
      } 
    } 
</pre></div>
<div class="section" title="Configuring DAO packages in Guice" id="aid-2ACBS1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec70"/>Configuring DAO packages in Guice</h1></div></div></div><p>We need to configure the injections for the three new <code class="literal">dao</code> packages that we created. So we to need to add three lines in the file <code class="literal">Module.scala</code>. Please open the file in your IDE, and add the following content:</p><pre class="programlisting">    bind(classOf[IProductDao]).to(classOf[ProductDao]).asEagerSingleton() 
    bind(classOf[IImageDao]).to(classOf[ImageDao]).asEagerSingleton() 
    bind(classOf[IReviewDao]).to(classOf[ReviewDao]).asEagerSingleton 
</pre><p>The whole file, <code class="literal">Module.scala</code>, should look like this:</p><pre class="programlisting">    /** 
    * This class is a Guice module that tells Guice how to bind several 
    * different types. This Guice module is created when the Play 
    * application starts. 
    * Play will automatically use any class called `Module` that is in 
    * the root package. You can create modules in other locations by 
    * adding `play.modules.enabled` settings to the `application.conf` 
    * configuration file. 
    */ 
    class Module extends AbstractModule { 
      override def configure() = { 
        // Use the system clock as the default implementation of Clock 
        bind(classOf[Clock]).toInstance(Clock.systemDefaultZone) 
        // Ask Guice to create an instance of ApplicationTimer when  
        //the application starts. 
        bind(classOf[ApplicationTimer]).asEagerSingleton() 
        bind(classOf[IProductService]). 
        to(classOf[ProductService]).asEagerSingleton() 
        bind(classOf[IReviewService]). 
        to(classOf[ReviewService]).asEagerSingleton() 
        bind(classOf[IImageService]). 
        to(classOf[ImageService]).asEagerSingleton() 
        bind(classOf[IPriceSerice]). 
        to(classOf[PriceService]).asEagerSingleton() 
        bind(classOf[IRndService]). 
        to(classOf[RndService]).asEagerSingleton() 
        bind(classOf[IProductDao]). 
        to(classOf[ProductDao]).asEagerSingleton() 
        bind(classOf[IImageDao]). 
        to(classOf[ImageDao]).asEagerSingleton() 
        bind(classOf[IReviewDao]). 
        to(classOf[ReviewDao]).asEagerSingleton() 
      } 
    } 
</pre></div>
<div class="section" title="Refactoring tests" id="aid-2BASE1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec71"/>Refactoring tests</h1></div></div></div><p>As you might expect, most tests are no longer working. We will need to perform some refactoring here as well. We will refactor our former <code class="literal">dao</code> to make it generic, and it will be used in integration tests (end-to-end tests).</p><p>Since we will create a generic dao system in memory for end-to-end testing purposes, we need to change our models a little bit. First, we need to create a base trait for all the models. This is needed so we can treat our models as equals.</p><p>Let's have a look at <code class="literal">models.BaseModel.scala</code>:</p><pre class="programlisting">    package models 
    trait BaseModel { 
      def getId:Option[Long] 
      def setId(id:Option[Long]):Unit 
    } 
</pre><p>We also need to make all our models implement this new trait. So we will need to change the Scala code for the product, image, and review. This is very trivial: we just add a getter and a setter for the <code class="literal">id</code> field. You can also use <code class="literal">scala.bean.BeanProperty</code> instead of writing one by yourself.</p><p>Your <code class="literal">models.Product.scala</code> file should look something like this:</p><pre class="programlisting">    package models 
    case class Product 
    ( var id:Option[Long], 
      var name:String, 
      var details:String, 
    var price:BigDecimal ) 
    extends BaseModel{ 
      override def toString:String = { 
        "Product { id: " + id.getOrElse(0) + ",name: " + name + ",  
        details: "+ details + ", price: " + price + "}" 
      } 
      override def getId:Option[Long] = id 
      override def setId(id:Option[Long]):Unit = this.id = id 
    } 
    object ProductDef{ 
      def toTable:String = "Product" 
    } 
</pre><p>As you can see in the preceding code, we extend the <code class="literal">BaseModel</code> method, and implement <code class="literal">getId</code> and <code class="literal">setId</code>. We need to do the same for the review and image models.</p><p>Your <code class="literal">models.Review.scala</code> file should look like this:</p><pre class="programlisting">    package models 
    case class Review 
    (var id:Option[Long], 
      var productId:Option[Long], 
      var author:String, 
    var comment:String) 
    extends BaseModel{ 
      override def toString:String = { 
        "Review { id: " + id + " ,productId: " +  
          productId.getOrElse(0) + ",author: " + author + ",comment: "  
        + comment + " }" 
      } 
      override def getId:Option[Long] = id  
      override def setId(id:Option[Long]):Unit = this.id = id 
    } 
    object ReviewDef{ 
      def toTable:String = "Review" 
    } 
</pre><p>Now we move on to the last model. We need to implement it in <code class="literal">Image.scala</code>.</p><p>Your <code class="literal">models.Image.scala</code> file should look like this:</p><pre class="programlisting">package models 
case class Image 
(var id:Option[Long],  
  var productId:Option[Long], 
var url:String) 
extends BaseModel { 
  override def toString:String = { 
    "Image { productId: " + productId.getOrElse(0) + ",url: " +  
    url + "}" 
  } 
  override def getId:Option[Long] = id 
  override def setId(id:Option[Long]):Unit = this.id = id 
} 
object ImageDef{ 
  def toTable:String = "Image" 
} 
</pre></div>
<div class="section" title="Generic mocks" id="aid-2C9D01"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec72"/>Generic mocks</h1></div></div></div><p>Now we have all that we need to create a generic mock implementation and mock all the <code class="literal">dao</code> packages. Under the location <code class="literal">ReactiveWebStore/test/</code>, we will create a package called mocks, and create a call, <code class="literal">GenericMockedDao</code>.</p><p>Your <code class="literal">GenericMockedDao.scala</code> file should look like this:</p><pre class="programlisting">package mocks 
import models.BaseModel 
class GenericMockedDao[T &lt;: BaseModel] { 
  import java.util.concurrent.atomic.AtomicLong 
  import scala.collection.mutable.HashMap 
  import scala.concurrent._ 
  import play.api.libs.concurrent.Execution. 
  Implicits.defaultContext 
  var inMemoryDB = new HashMap[Long,T] 
  var idCounter = new AtomicLong(0) 
  def findAll(): Future[Seq[T]] = { 
    Future { 
      if (inMemoryDB.isEmpty) Seq() 
      inMemoryDB.values.toSeq 
    } 
  } 
  def findById(id:Long): Future[Option[T]] = { 
    Future { 
      inMemoryDB.get(id) 
    } 
  } 
  def remove(id:Long): Future[Int] = { 
    Future { 
      validateId(id) 
      inMemoryDB.remove(id) 
      1 
    } 
  } 
  def insert(t:T): Future[Unit] = { 
    Future { 
      val id = idCounter.incrementAndGet(); 
      t.setId(Some(id)) 
      inMemoryDB.put(id, t) 
      Unit 
    } 
  } 
  def update(t:T): Future[Unit] = { 
    Future { 
      validateId(t.getId.get) 
      inMemoryDB.put(t.getId.get, t) 
      Unit 
    } 
  } 
  private def validateId(id:Long):Unit = { 
    val entry = inMemoryDB.get(id) 
    if (entry==null || entry.equals(None)) throw new  
    RuntimeException("Could not find Product: " + id) 
  } 
} 
</pre><p>So the <code class="literal">GenericMockedDao</code> call expects the <code class="literal">Generic</code> parameter, which could be any class extending from <code class="literal">BaseModel</code>. Then we use an in-memory HashMap implementation and a counter to simulate database operations. We run all the operations inside Futures, so we don't break the new signature the code is expecting. Now we can create three <code class="literal">MockedDaos</code> for each model we need: product, review, and image.</p><p>Your <code class="literal">mocks.ProductMockedDao.scala</code> file should look like this:</p><pre class="programlisting">package mocks 
class ProductMockedDao extends IProductDao { 
  val dao:GenericMockedDao[Product] = new  
  GenericMockedDao[Product]() 
  override def findAll(): Future[Seq[Product]] = { 
    dao.findAll() 
  } 
  override def findById(id:Long): Future[Option[Product]] = { 
    dao.findById(id) 
  } 
  override def remove(id:Long): Future[Int] = { 
    dao.remove(id) 
  } 
  override def insert(p:Product): Future[Unit] = { 
    dao.insert(p) 
  } 
  override def update(p2:Product): Future[Unit] = { 
    dao.update(p2) 
  } 
  override def toTable:TableQuery[_] = { 
    null 
  } 
} 
</pre><p>As you can see here, we implement the <code class="literal">IProdutDao</code> trait, and we delegate all operations to <code class="literal">genericMockedDao</code>. Since everything is in-memory, we don't need to implement the <code class="literal">toTable</code> function. We need to do the same for the review and image.</p><p>Your <code class="literal">mocks.ReviewMockedDao.scala</code> file should look like this:</p><pre class="programlisting">package mocks 
class ReviewMockedDao extends IReviewDao { 
  val dao:GenericMockedDao[Review] = new  
  GenericMockedDao[Review]() 
  override def findAll(): Future[Seq[Review]] = { 
    dao.findAll() 
  } 
  override def findById(id:Long): Future[Option[Review]] = { 
    dao.findById(id) 
  } 
  override def remove(id:Long): Future[Int] = { 
    dao.remove(id) 
  } 
  override def insert(p:Review): Future[Unit] = { 
    dao.insert(p) 
  } 
  override def update(p2:Review): Future[Unit] = { 
    dao.update(p2) 
  } 
  override def toTable:TableQuery[_] = { 
    null 
  } 
} 
</pre><p>Exactly like product, we delegate all operations to <code class="literal">GenericMockedDao</code>. Now let's move to the last one, the image, and then we can fix the tests.</p><p>Your <code class="literal">mocks.ImageMockedDao.scala</code> file should look like this:</p><pre class="programlisting">package mocks 
class ImageMockedDao extends IImageDao { 
  val dao:GenericMockedDao[Image] = new GenericMockedDao[Image]() 
  override def findAll(): Future[Seq[Image]] = { 
    dao.findAll() 
  } 
  override def findById(id:Long): Future[Option[Image]] = { 
    dao.findById(id) 
  } 
  override def remove(id:Long): Future[Int] = { 
    dao.remove(id) 
  } 
  override def insert(p:Image): Future[Unit] = { 
    dao.insert(p) 
  } 
  override def update(p2:Image): Future[Unit] = { 
    dao.update(p2) 
  } 
  override def toTable:TableQuery[_] = { 
    null 
  } 
} 
</pre><p>Okay, we have all the mocks that we need for now. We can move on to fix the test specs. We need to fix services tests and controller test. Services tests will use mocks. Controllers tests, however, will use the real database implementation. We need to use other utility classes for controller tests. Located in the test source folder, we need to create a package called <code class="literal">utils</code>.</p><p>Your <code class="literal">utils.DBCleaner.scala</code> file should look like this:</p><pre class="programlisting">    package utils 
    object DBCleaner { 
      val pool = Executors.newCachedThreadPool() 
      implicit val ec = ExecutionContext.fromExecutorService(pool) 
      def cleanUp():Unit = { 
        Class.forName("com.mysql.cj.jdbc.Driver") 
        val db =   Database.forURL 
        ("jdbc:mysql://127.0.0.1:3306/RWS_DB?useUnicode= 
        true&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=     
        false&amp;serverTimezone=UTC", 
        "root", "") 
        try{ 
          Await.result( 
            db.run( 
              DBIO.seq( 
                sqlu""" DELETE FROM Product; """, 
                sqlu""" DELETE FROM Image; """, 
                sqlu""" DELETE FROM Review; """, 
                sqlu""" ALTER TABLE Product AUTO_INCREMENT = 1 """, 
                sqlu""" ALTER TABLE Image AUTO_INCREMENT = 1 """, 
                sqlu""" ALTER TABLE Review AUTO_INCREMENT = 1 """ 
              ) 
            ) 
          ,20 seconds) 
        }catch{ 
          case e:Exception =&gt; Unit 
        } 
      } 
    } 
</pre><p>
<code class="literal">DBCleaner</code> will connect to the real database and perform delete statements to clean up all table data. After deleting all data in the tables, we also reset the sequence in the database; otherwise, our tests will not have the predictability we need to do assertions.</p><p>As you can see in <code class="literal">db.run</code>, we can use <code class="literal">DBIO.seq</code>, which allows us to execute multiple instructions on the database. Here we are not using Scala code. We are using pure SQL statements, since we need to use very specific MySQL functions to reset the sequences.</p><p>If you need, you could use all these functions in your application. This is useful if you need to use a specific database function, if you have a very complex query, or sometimes, because there is a performance issue.</p><p>Most fixes we do now center around using <code class="literal">Awaits</code> to wait for the Future result, and also using our new mocks. For the controller test, we need to call the <code class="literal">DBCleaner</code> function as well.</p></div>
<div class="section" title="Service tests" id="aid-2D7TI1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec73"/>Service tests</h1></div></div></div><p>Now we will create tests for services to test them. So let's get started.</p><p>Your <code class="literal">ProductServiceTestSpec.scala</code> file should look like this:</p><pre class="programlisting">    class ProductServiceTestSpec extends PlaySpec { 
      "ProductService" must { 
        val service:IProductService = new ProductService(new  
        ProductMockedDao) 
        "insert a product properly" in { 
          val product = new models.Product(Some(1),"Ball","Awesome  
          Basketball",19.75) 
          service.insert(product) 
        } 
        "update a product" in { 
          val product = new models.Product(Some(1),"Blue  
          Ball","Awesome Blue Basketball",19.99) 
          service.update(1, product) 
        } 
        "not update because does not exit" in { 
          intercept[RuntimeException]{ 
            service.update(333,null) 
          } 
        } 
        "find the product 1" in { 
          val product = Awaits.get(5, service.findById(1)) 
          product.get.id mustBe Some(1) 
          product.get.name mustBe "Blue Ball" 
          product.get.details mustBe "Awesome Blue Basketball" 
          product.get.price mustBe 19.99 
        } 
        "find all" in { 
          val products = Awaits.get(5, service.findAll()) 
          products.get.length mustBe 1 
          products.get(0).id mustBe Some(1) 
          products.get(0).name mustBe "Blue Ball" 
          products.get(0).details mustBe "Awesome Blue Basketball" 
          products.get(0).price mustBe 19.99 
        } 
        "find all products" in { 
          val products = service.findAllProducts() 
          products.length mustBe 1 
          products(0)._1 mustBe "1" 
          products(0)._2 mustBe "Blue Ball" 
        } 
        "remove 1 product" in { 
          val product = Awaits.get(5, service.remove(1)) 
          product mustBe 1 
          val oldProduct = Awaits.get(5,service.findById(1)) 
          oldProduct mustBe None 
        } 
        "not remove because does not exist" in { 
          intercept[RuntimeException]{ 
            Awaits.get(5,service.remove(-1)) 
          } 
        } 
      } 
    } 
</pre><p>As you can see in the preceding code, most fixes center around the new signatures and the fact we are using Futures and need to use the <code class="literal">Awaits</code> utility and mocks. We test the service without the database call via this code:</p><pre class="programlisting">val service:IProductService = new ProductService(new ProductMockedDao) 
</pre><p>We can move on to the next service, which will be the review.</p><p>Your <code class="literal">ReviewServiceTestSpec.scala</code> file should look like this:</p><pre class="programlisting">    class ReviewServiceTestSpec extends PlaySpec { 
      "ReviewService" must { 
        val service:IReviewService = new ReviewService(new  
        ReviewMockedDao) 
        "insert a review properly" in { 
          val review = new models.Review 
          (Some(1),Some(1),"diegopacheco","Testing is Cool") 
          service.insert(review) 
        } 
        "update a reviewt" in { 
          val review = new models.Review 
          (Some(1),Some(1),"diegopacheco","Testing so so Cool") 
          service.update(1, review) 
        } 
        "not update because does not exist" in { 
          intercept[RuntimeException]{ 
            Awaits.get(5, service.update(333,null)) 
          } 
        } 
        "find the review 1" in { 
          val review = Awaits.get(5,service.findById(1)) 
          review.get.id mustBe Some(1) 
          review.get.author mustBe "diegopacheco" 
          review.get.comment mustBe "Testing so so Cool" 
          review.get.productId mustBe Some(1) 
        } 
        "find all" in { 
          val reviews = Awaits.get(5,service.findAll()) 
          reviews.get.length mustBe 1 
          reviews.get(0).id mustBe Some(1) 
          reviews.get(0).author mustBe "diegopacheco" 
          reviews.get(0).comment mustBe "Testing so so Cool" 
          reviews.get(0).productId mustBe Some(1) 
        } 
        "remove 1 review" in { 
          val review = Awaits.get(5, service.remove(1)) 
          review mustBe 1 
          val oldReview= Awaits.get(5, service.findById(1)) 
          oldReview mustBe None 
        } 
        "not remove because does not exist" in { 
          intercept[RuntimeException]{ 
            Awaits.get(5, service.remove(-1)) 
          } 
        } 
      } 
    } 
</pre><p>That was the review spec service test code. We apply the same changes as we did for product. Now we need to move on to the last service test, which will be the image.</p><p>Your <code class="literal">ImageServiceTestSpec.scala</code> file should look like this:</p><pre class="programlisting">    class ImageServiceTestSpec extends PlaySpec { 
      "ImageService" must { 
        val service:IImageService = new ImageService(new  
        ImageMockedDao) 
        "insert a image properly" in { 
          val image = new models.Image 
          (Some(1),Some(1),"http://www.google.com.br/myimage") 
          service.insert(image) 
        } 
        "update a image" in { 
          val image = new models.Image 
          (Some(2),Some(1),"http://www.google.com.br/myimage") 
          service.update(1, image) 
        } 
        "not update because does not exist" in { 
          intercept[RuntimeException]{ 
            Awaits.get(5, service.update(333,null)) 
          } 
        } 
        "find the image" in { 
          val image = Awaits.get(5,service.findById(1)) 
          image.get.id mustBe Some(1) 
          image.get.productId mustBe Some(1) 
          image.get.url mustBe "http://www.google.com.br/myimage" 
        } 
        "find all" in { 
          val reviews = Awaits.get(5,service.findAll()) 
          reviews.get.length mustBe 1 
          reviews.get(0).id mustBe Some(1) 
          reviews.get(0).productId mustBe Some(1) 
          reviews.get(0).url mustBe "http://www.google.com.br/myimage" 
        } 
        "remove 1 image" in { 
          val image = Awaits.get(5,service.remove(1)) 
          image mustBe 1 
          val oldImage = Awaits.get(5,service.findById(1)) 
          oldImage mustBe None 
        } 
        "not remove because does not exist" in { 
          intercept[RuntimeException]{ 
            Awaits.get(5,service.remove(-1)) 
          } 
        } 
      } 
    } 
</pre><p>We have fixed all the services tests. Now we need to fix the controller tests.</p></div>
<div class="section" title="Controller tests"><div class="titlepage" id="aid-2E6E42"><div><div><h1 class="title"><a id="ch06lvl1sec74"/>Controller tests</h1></div></div></div><p>Now let's fix the controller tests. The first one will be the product controller.</p><p>Your <code class="literal">ProductControllerTestSpec.scala</code> file should look like this:</p><pre class="programlisting">    class ProductControllerTestSpec 
    extends  
    PlaySpec  
    with OneServerPerSuite with OneBrowserPerSuite with HtmlUnitFactory { 
      "ProductController" should { 
        DBCleaner.cleanUp() 
        "insert a new product should be ok" in { 
          goTo(s"http://localhost:${port}/product/add") 
          click on id("name") 
          enter("Blue Ball") 
          click on id("details") 
          enter("Blue Ball is a Awesome and simple product") 
          click on id("price") 
          enter("17.55") 
          submit() 
        } 
        "details from the product 1 should be ok" in { 
          goTo(s"http://localhost:${port}/product/details/1") 
          textField("name").value mustBe "Blue Ball" 
          textField("details").value mustBe "Blue Ball is a Awesome  
          and simple product" 
          textField("price").value mustBe "17.55" 
        } 
        "update product 1 should be ok" in { 
          goTo(s"http://localhost:${port}/product/details/1") 
          textField("name").value = "Blue Ball 2" 
          textField("details").value = "Blue Ball is a Awesome and  
          simple product 2 " 
          textField("price").value = "17.66" 
          submit() 
          goTo(s"http://localhost:${port}/product/details/1") 
          textField("name").value mustBe "Blue Ball 2" 
          textField("details").value mustBe "Blue Ball is a Awesome  
          and simple product 2 " 
          textField("price").value mustBe "17.66" 
        } 
        "delete a product should be ok" in { 
          goTo(s"http://localhost:${port}/product/add") 
          click on id("name") 
          enter("Blue Ball") 
          click on id("details") 
          enter("Blue Ball is a Awesome and simple product") 
          click on id("price") 
          enter("17.55") 
          submit() 
          goTo(s"http://localhost:${port}/product") 
          click on id("btnDelete") 
        } 
        "Cleanup db in the end" in { 
          DBCleaner.cleanUp() 
        } 
      } 
    } 
</pre><p>The Controller product test needs to call the <code class="literal">DBCleaner</code> function at the beginning of the test to make sure that the database is in a well-known state; additionally, and after running all the tests, we need to clean up the database just to be safe.</p><p>We will now apply the same changes for the review and image controller tests.</p><p>Your <code class="literal">ReviewControllerTestSpec</code> file should look like this:</p><pre class="programlisting">    class ReviewControllerTestSpec  
    extends PlaySpec  
    with OneServerPerSuite with OneBrowserPerSuite with HtmlUnitFactory { 
      DBCleaner.cleanUp() 
      "ReviewController" should { 
        "insert a new review should be ok" in { 
          goTo(s"http://localhost:${port}/product/add") 
          click on id("name") 
          enter("Blue Ball") 
          click on id("details") 
          enter("Blue Ball is a Awesome and simple product") 
          click on id("price") 
          enter("17.55") 
          submit() 
          goTo(s"http://localhost:${port}/review/add") 
          singleSel("productId").value = "1" 
          click on id("author") 
          enter("diegopacheco") 
          click on id("comment") 
          enter("Tests are amazing!") 
          submit() 
        } 
        "details from the review 1 should be ok" in { 
          goTo(s"http://localhost:${port}/review/details/1") 
          textField("author").value mustBe "diegopacheco" 
          textField("comment").value mustBe "Tests are amazing!" 
        } 
        "update review 1 should be ok" in { 
          goTo(s"http://localhost:${port}/review/details/1") 
          textField("author").value = "diegopacheco2" 
          textField("comment").value = "Tests are amazing 2!" 
          submit() 
          goTo(s"http://localhost:${port}/review/details/1") 
          textField("author").value mustBe "diegopacheco2" 
          textField("comment").value mustBe "Tests are amazing 2!" 
        } 
        "delete a review should be ok" in { 
          goTo(s"http://localhost:${port}/review/add") 
          singleSel("productId").value = "1" 
          click on id("author") 
          enter("diegopacheco") 
          click on id("comment") 
          enter("Tests are amazing!") 
          submit() 
          goTo(s"http://localhost:${port}/review") 
        click on id("btnDelete")} 
        "Cleanup db in the end" in { 
          DBCleaner.cleanUp() 
        } 
      } 
    } 
</pre><p>Alright, we have the tests for the review controller fixed. Now we can move to the last controller test for the image.</p><p>Your <code class="literal">ImageControllerTestSpec.scala</code> file should look like this:</p><pre class="programlisting">    class ImageControllerTestSpec  
    extends PlaySpec  
    with OneServerPerSuite with OneBrowserPerSuite with HtmlUnitFactory { 
      DBCleaner.cleanUp() 
      "ImageController" should { 
        "insert a new image should be ok" in { 
          goTo(s"http://localhost:${port}/product/add") 
          click on id("name") 
          enter("Blue Ball") 
          click on id("details") 
          enter("Blue Ball is a Awesome and simple product") 
          click on id("price") 
          enter("17.55") 
          submit() 
          goTo(s"http://localhost:${port}/image/add") 
          singleSel("productId").value = "1" 
          click on id("url") 
          enter("https://thegoalisthering.files.wordpress.com/2012/01/       
          bluetennisball_display_image.jpg") 
          submit() 
        } 
        "details from the image 1 should be ok" in { 
          goTo(s"http://localhost:${port}/image/details/1") 
          textField("url").value mustBe             
          "https://thegoalisthering.files.wordpress.com/2012/01/       
          bluetennisball_display_image.jpg" 
        } 
        "update image 1 should be ok" in { 
          goTo(s"http://localhost:${port}/image/details/1") 
          textField("url").value =        
          "https://thegoalisthering.files.wordpress.com/2012/01/       
          bluetennisball_display_image2.jpg" 
          submit() 
          goTo(s"http://localhost:${port}/image/details/1") 
          textField("url").value mustBe        
          "https://thegoalisthering.files.wordpress.com/2012/01/      
          bluetennisball_display_image2.jpg" 
        } 
        "delete a image should be ok" in { 
          goTo(s"http://localhost:${port}/image/add") 
          singleSel("productId").value = "1" 
          click on id("url") 
          enter("https://thegoalisthering.files.wordpress.com/2012/01/       
          bluetennisball_display_image.jpg") 
          submit() 
          goTo(s"http://localhost:${port}/image") 
          click on id("btnDelete") 
        } 
        "Cleanup db in the end" in { 
          DBCleaner.cleanUp() 
        } 
      } 
    } 
</pre><p>All right, all the controller tests are fixed now. We can run all the tests to double check whether everything is OK.</p><p>Run the following command:</p><pre class="programlisting">
<span class="strong"><strong>$ activator test</strong></span>
</pre><p>You get output as shown in the following screenshot:</p><p>
</p><div class="mediaobject"><img src="../Images/image00293.jpeg" alt="Controller tests"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>If you have problems running the application (covered in the next section), apply the evolution, and then you can run the tests again. Tests might take some time, depending on your hardware.</p></div>
<div class="section" title="Running the application" id="aid-2F4UM1"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec75"/>Running the application</h1></div></div></div><p>Now it is time to run the application using <code class="literal">$ activator run</code>. Open your web browser, and go to <code class="literal">http://localhost:9000/</code>. Once you do that, Play will detect that the application needs evolutions, and will apply the three evolutions we have (<code class="literal">1.sql</code>, <code class="literal">2.sql</code>, and <code class="literal">3.sql</code>). However, you will need to click on the button to apply the evolution.</p><p>
</p><div class="mediaobject"><img src="../Images/image00294.jpeg" alt="Running the application"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>After you click on the red button, <span class="strong"><strong>Apply this script now!</strong></span>, Slick will create the tables, and redirect you to the application.</p><p>
</p><div class="mediaobject"><img src="../Images/image00295.jpeg" alt="Running the application"/></div><p style="clear:both; height: 1em;"> </p><p>
</p></div>
<div class="section" title="Summary" id="aid-2G3F81"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec76"/>Summary</h1></div></div></div><p>With this, we reach the end of the chapter. You learned how to perform database persistence using Slick. You also learned how to do FRM mapping, and we refactored our application and tests so they work with reactive persistence and the Play framework. We then explained how to access the database using Scala code, and perform operations using SQL.</p><p>In the following chapter, we will see more about reports, and we will use our database to generate reports based on our Play framework application.</p></div></body></html>