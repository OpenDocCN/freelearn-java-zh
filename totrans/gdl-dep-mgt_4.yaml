- en: Chapter 4. Publishing Artifacts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 发布工件
- en: In the previous chapters, we learned how to define and use dependencies in our
    projects. However, the code we write in our projects can also be a dependency
    for another project. In order for another project to use our code as a dependency,
    we should publish our code as a dependency artifact so that it can be used by
    other projects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何在项目中定义和使用依赖关系。然而，我们在项目中编写的代码也可以成为另一个项目的依赖。为了使另一个项目能够将我们的代码作为依赖使用，我们应该将我们的代码发布为依赖项工件，以便其他项目可以使用它。
- en: In this chapter, you will learn how you can define artifacts in your project.
    These artifacts need to be published for others to use them. We first publish
    them using a filesystem, so the artifacts can be used from the same computer or
    even if we use a network share on an intranet. In later chapters, we will see
    how to publish our artifacts to a Maven repository, an Ivy repository, and Bintray.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何在你的项目中定义工件。这些工件需要发布以便其他人可以使用它们。我们首先使用文件系统发布它们，这样工件就可以在同一台计算机上使用，甚至如果我们使用内网上的网络共享。在后面的章节中，我们将看到如何将我们的工件发布到Maven仓库、Ivy仓库和Bintray。
- en: Defining artifact configurations
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义工件配置
- en: A Gradle project can contain artifacts we want to publish. An artifact can be
    a ZIP or JAR archive file or any other file. We can define one or more artifacts
    in one project. Thus, we don't have to create two different projects if we want
    to have two different artifacts from the same source tree.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Gradle项目可以包含我们想要发布的工件。一个工件可以是ZIP或JAR存档文件或任何其他文件。我们可以在一个项目中定义一个或多个工件。因此，如果我们想要从同一个源树中获取两个不同的工件，我们不需要创建两个不同的项目。
- en: In Gradle, we group artifacts using configurations. We used configurations to
    define dependencies for our project, but now we will use the configurations to
    group our artifacts that can be dependencies for others. So a configuration can
    contain both dependencies and artifacts. If we apply the Java plugin to our project,
    we get a configuration named `archives`, that contains the default JAR artifact
    for the project.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在Gradle中，我们使用配置来分组工件。我们曾使用配置来定义项目的依赖关系，但现在我们将使用配置来分组我们的工件，这些工件可以是其他项目的依赖项。因此，一个配置可以包含依赖项和工件。如果我们将Java插件应用到我们的项目中，我们得到一个名为`archives`的配置，它包含项目的默认JAR工件。
- en: 'In the following example Gradle build file, we use the Java plugin. We add
    a task to display the filename of the artifact that belongs to the `archives`
    configuration. The following code shows this:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例Gradle构建文件中，我们使用了Java插件。我们添加了一个任务来显示属于`archives`配置的工件文件名。以下代码展示了这一点：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'When we run the `artifactsInfo` task from the command line, we see the `java_lib.jar`
    filename in the output. The following code shows this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们从命令行运行`artifactsInfo`任务时，我们在输出中看到`java_lib.jar`文件名。以下代码展示了这一点：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'For each configuration in our project, Gradle adds two tasks to the project:
    `build<ConfigurationName>` and `upload<ConfigurationName>`. The `build<ConfigurationName>`
    task creates the artifacts for the given configuration name. The `upload<ConfigurationName>`
    task creates and uploads the artifacts for the given configuration name. The `upload<ConfigurationName>`
    task needs extra configuration to know where to upload the artifacts. We will
    see later in this chapter how to configure the task.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们项目中的每个配置，Gradle都会为项目添加两个任务：`build<ConfigurationName>`和`upload<ConfigurationName>`。`build<ConfigurationName>`任务为给定的配置名称创建工件。`upload<ConfigurationName>`任务为给定的配置名称创建和上传工件。`upload<ConfigurationName>`任务需要额外的配置来知道上传工件的位置。我们将在本章后面看到如何配置这个任务。
- en: 'In our example project, we have the `buildArchives` and `uploadArchives` tasks.
    Let''s run the `buildArchives` task for our example project and see which tasks
    are executed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们有`buildArchives`和`uploadArchives`任务。让我们运行我们的示例项目的`buildArchives`任务，看看哪些任务被执行：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, we can see that first everything is prepared in our Java project to create
    the JAR artifact. The JAR artifact is then added to the `artifacts` configuration.
    The `java_lib.jar` JAR file that is created can be found in the `build/libs` directory.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到首先在我们的Java项目中准备了一切以创建JAR工件。然后，JAR工件被添加到`artifacts`配置中。创建的`java_lib.jar`
    JAR文件可以在`build/libs`目录中找到。
- en: 'If we set the `version` property for our project, then it will be used in the
    name of our created artifact. In the next example build file, we will set the
    `version` property and look at the name that is created for the artifact:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为我们的项目设置 `version` 属性，那么它将被用于我们创建的工件名称中。在下一个示例构建文件中，我们将设置 `version` 属性并查看为工件创建的名称：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s run the `artifactsInfo` task to see the name of our artifact:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行 `artifactsInfo` 任务来查看我们工件的名称：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining artifacts
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义工件
- en: In the previous section, you learned that the Java plugin adds an `archives`
    configuration that is used to group artifacts from the project. Just as we created
    configurations for dependencies in our project, we can also create our own configurations
    for its artifacts. To assign an archive or file to this configuration, we must
    use the `artifacts` configuration block in our build script. Inside the configuration
    closure, we use the name of the configuration followed by the artifact. We can
    also further customize the artifact definition inside the `artifacts` block.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你了解到 Java 插件添加了一个 `archives` 配置，用于从项目中分组工件。就像我们在项目中创建依赖项配置一样，我们也可以为其工件创建自己的配置。要将归档或文件分配给此配置，我们必须在我们的构建脚本中使用
    `artifacts` 配置块。在配置闭包内部，我们使用配置名称后跟工件名称。我们还可以在 `artifacts` 块内部进一步自定义工件定义。
- en: 'We can define artifacts with the following three types:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下三种类型来定义工件：
- en: '| Type | Description |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 描述 |'
- en: '| --- | --- |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `AbstractArchiveTask` | The information for the artifact is extracted from
    the archive task. The artifact is an instance of `PublishArtifact` in the `org.gradle.api.artifact`
    `s` package. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `AbstractArchiveTask` | 工件的信息是从归档任务中提取的。工件是 `org.gradle.api.artifact` 包中的
    `PublishArtifact` 的一个实例。 |'
- en: '| `File` | The information for the artifact is extracted from the filename.
    The artifact is an instance of `ConfigurablePublishArtifact` that extends `PublishArtifact`.
    |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `File` | 工件的信息是从文件名中提取的。工件是扩展 `PublishArtifact` 的 `ConfigurablePublishArtifact`
    的一个实例。 |'
- en: '| `Map` | This is another way to define a file artifact. The map must contain
    a `file` key, and other properties are used to further configure the artifact.
    |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `Map` | 这是定义文件工件的另一种方式。该映射必须包含一个 `file` 键，其他属性用于进一步配置工件。 |'
- en: Using the archive task
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用归档任务
- en: 'In the next example build file, we will use an archive task to define the artifacts
    for the project. It is important to remember to apply the Gradle base plugin to
    the project because the base plugin adds the task rules for `build<ConfigurationName>`
    and `upload<ConfigurationName>`. The following code shows this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将使用归档任务来定义项目的工件。记住将 Gradle 基础插件应用到项目中非常重要，因为基础插件为 `build<ConfigurationName>`
    和 `upload<ConfigurationName>` 添加了任务规则。以下代码展示了这一点：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'When we use an archive task to define the artifact for a configuration, Gradle
    also adds a task dependency for the artifact. This means that, if we invoke the
    `buildManualDistribution` task, Gradle also invokes the `manual` task that generates
    the archive for the artifact configuration. We see this when we execute the task
    from the command line. The following command shows this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用归档任务来定义配置的工件时，Gradle 也会为该工件添加一个任务依赖。这意味着，如果我们调用 `buildManualDistribution`
    任务，Gradle 也会调用生成工件配置归档的 `manual` 任务。当我们从命令行执行任务时，我们会看到这一点。以下命令展示了这一点：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Using artifact files
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工件文件
- en: 'Besides archive tasks, we can use a file as an artifact. Gradle will use the
    properties of the file to define the artifact name, type, and extension. In the
    following example build file, we use a file as an artifact:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了归档任务之外，我们还可以使用文件作为工件。Gradle 将使用文件属性来定义工件名称、类型和扩展名。在以下示例构建文件中，我们使用文件作为工件：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can add an extra configuration closure when we use the file artifact notation.
    In the closure, we can set the name, type, extension, and classifier attributes.
    The following code shows this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用文件工件表示法时，我们可以添加一个额外的配置闭包。在闭包中，我们可以设置名称、类型、扩展和分类器属性。以下代码展示了这一点：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: One interesting method we can use in the file artifact configuration closure
    is the `builtBy` method. This method accepts one or more task names that are responsible
    for building the artifact. If we use this method, Gradle can determine the tasks
    that need to be executed when we run the `build<ConfigurationName>` or `upload<ConfigurationName>`
    task.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件艺术品配置闭包中，我们可以使用的一个有趣的方法是 `builtBy` 方法。此方法接受一个或多个负责构建艺术品的任务名称。如果我们使用此方法，Gradle
    可以确定当我们运行 `build<ConfigurationName>` 或 `upload<ConfigurationName>` 任务时需要执行的任务。
- en: 'We will use the `builtBy` method in the next example build file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将使用 `builtBy` 方法：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To ensure that the `docFiles` task is added as a task dependency, we run the
    `buildReadmeDistribution` from the command line. The following command shows this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `docFiles` 任务被添加为任务依赖项，我们从命令行运行 `buildReadmeDistribution`。以下命令展示了这一点：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we can use a map notation when we define a file artifact. We use the
    `file` attribute to define the file. We can also use the `name`, `extension`,
    `type`, `classifier`, and `builtBy` keys for the definition. In the following
    example build file, we use the map notation:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当我们定义文件艺术品时，我们可以使用映射符号。我们使用 `file` 属性来定义文件。我们还可以使用 `name`、`extension`、`type`、`classifier`
    和 `builtBy` 键来定义。在以下示例构建文件中，我们使用了映射符号：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating artifacts
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建艺术品
- en: We saw how to define artifacts, but we also need to create artifacts in our
    build files. We can either use an archive task to create the artifact or a file
    can be an artifact. Most of the time, when we use Gradle in a Java project, we
    build an archive with compiled classes and resources. Actually, the Java plugin
    adds a `jar` task to our project that will just do that. The JAR file created
    is then added to the `archives` configuration.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何定义艺术品，但我们也需要在我们的构建文件中创建艺术品。我们可以使用归档任务来创建艺术品，或者文件本身可以是一个艺术品。大多数时候，当我们使用
    Gradle 进行 Java 项目开发时，我们会构建一个包含编译类和资源的归档。实际上，Java 插件会为我们项目添加一个 `jar` 任务，它只会做这件事。创建的
    JAR 文件随后被添加到 `archives` 配置中。
- en: 'In the next example build file, we will use the Java plugin and simply rely
    on the default artifact configuration and tasks. The following code shows this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将使用 Java 插件并简单地依赖默认的艺术品配置和任务。以下代码展示了这一点：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We can now run the `buildArchives` task and check the artifacts with the `artifactsInfo`
    task from the command line:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行 `buildArchives` 任务，并从命令行使用 `artifactsInfo` 任务检查艺术品：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, we have a single artifact; however, in the same project we can
    have more than one artifact when we use Gradle. For example, we might want to
    have our source packaged into a JAR file and our generated documentation as well.
    Both JAR files should be part of the `archives` configuration so that, when we
    execute the `buildArchives` task, all the tasks necessary to create these JAR
    files are executed.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个单一的艺术品；然而，当我们使用 Gradle 时，在同一个项目中我们可以有多个艺术品。例如，我们可能想要将我们的源打包到一个 JAR
    文件中，以及我们的生成文档。这两个 JAR 文件都应该包含在 `archives` 配置中，这样当我们执行 `buildArchives` 任务时，所有创建这些
    JAR 文件所需的任务都会执行。
- en: 'We extend our previous example build file, add the code to create two extra
    JAR files, and add them to the `archives` artifact configuration. The following
    code shows this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展了之前的构建文件示例，添加了创建两个额外 JAR 文件的代码，并将它们添加到 `archives` 艺术品配置中。以下代码展示了这一点：
- en: '[PRE14]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We will now execute the `buildArchives` and `artifactsInfo` tasks. We see in
    the output that our two new tasks, `sourcesJar` and `javadocJar`, are executed.
    And the generated artifact files are `sample-2.1.jar`, `sample-2.1-sources.jar`,
    and `sample-2.1-javadoc.jar`. The following command shows this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将执行 `buildArchives` 和 `artifactsInfo` 任务。我们在输出中看到我们的两个新任务 `sourcesJar` 和
    `javadocJar` 已执行。生成的艺术品文件是 `sample-2.1.jar`、`sample-2.1-sources.jar` 和 `sample-2.1-javadoc.jar`。以下命令展示了这一点：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the preceding example, we have a Java project and, from the same source
    set, we want to create two different archive files. The source set contains a
    few API classes and implementation classes. We want to have a JAR file with the
    API classes and a JAR file, along with the implementation classes. The following
    code shows this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们有一个 Java 项目，并且从同一个源集中，我们想要创建两个不同的归档文件。源集包含一些 API 类和实现类。我们想要有一个包含 API
    类的 JAR 文件，以及一个包含实现类的 JAR 文件。以下代码展示了这一点：
- en: '[PRE16]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We will now run the `buildArchives` task and see that all the tasks necessary
    to create the JAR file with the classes from the `api` source set are executed:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将运行 `buildArchives` 任务，并查看创建包含 `api` 源集类别的 JAR 文件所需的所有任务是否都已执行：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Publishing artifacts to the local directory
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将工件发布到本地目录
- en: We now know how to create one or more artifacts and how to use artifact configurations
    to group them. In this section, we will see how we can copy our artifacts to a
    local directory or network share. Remember that, for each artifact's configuration,
    Gradle adds a `build<ConfigurationName>` task and an `upload<ConfigurationName>`
    task. Now it is time to learn more about the `upload<ConfigurationName>` task
    so that we can copy our artifacts. In the following chapters we will also learn
    how to deploy to a Maven repository, an Ivy repository, and to Bintray.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道了如何创建一个或多个工件，以及如何使用工件配置来分组它们。在本节中，我们将了解如何将我们的工件复制到本地目录或网络共享。请记住，对于每个工件的配置，Gradle都会添加一个`build<ConfigurationName>`任务和一个`upload<ConfigurationName>`任务。现在是时候更多地了解`upload<ConfigurationName>`任务，以便我们可以复制我们的工件。在接下来的章节中，我们还将学习如何部署到Maven仓库、Ivy仓库以及Bintray。
- en: 'For each `upload<ConfigurationName>` task, we must configure a repository definition.
    The repository definition is basically the destination of our artifacts when we
    upload or publish them. In this section, we use a local directory, so we define
    a repository using the `flatDir` method. We specify a name and the directory so
    that Gradle knows where the output of the `upload<ConfigurationName>` task needs
    to go. In Gradle projects where we have applied the Java plugin, we already have
    the `archives` artifact configuration and the `uploadArchives` task. We must configure
    the `uploadArchives` task and define the repository that needs to be used. In
    the next example build file, we will use the `lib-repo` local directory as the
    repository directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个`upload<ConfigurationName>`任务，我们必须配置一个仓库定义。仓库定义基本上是我们上传或发布工件时的目的地。在本节中，我们使用本地目录，因此我们使用`flatDir`方法定义一个仓库。我们指定一个名称和目录，以便Gradle知道`upload<ConfigurationName>`任务的输出需要放在哪里。在我们应用了Java插件的Gradle项目中，我们已经有`archives`工件配置和`uploadArchives`任务。我们必须配置`uploadArchives`任务并定义需要使用的仓库。在下一个示例构建文件中，我们将使用`lib-repo`本地目录作为仓库目录：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s see the output when we execute the `uploadArchives` task and check the
    files in the `lib-repo` directory:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看执行`uploadArchives`任务时的输出，并检查`lib-repo`目录中的文件：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In our `lib-repo` directory, for our artifact, we have an Ivy descriptor file
    named `ivy-2.1.xml` and, for this descriptor file, a checksum file named `ivy-2.1.xml.sha1`.
    Also, we see our `sample-2.1.jar` artifact and the `sample-2.1.jar.sha1` checksum
    file for our artifact. The Ivy descriptor file contains basic information about
    our artifact. This is shown by the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`lib-repo`目录中，对于我们的工件，我们有一个名为`ivy-2.1.xml`的Ivy描述符文件，以及一个名为`ivy-2.1.xml.sha1`的校验和文件。我们还看到了我们的`sample-2.1.jar`工件及其`sample-2.1.jar.sha1`校验和文件。Ivy描述符文件包含有关我们的工件的基本信息。以下代码展示了这一点：
- en: '[PRE20]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have configured the repository inside the `uploadArchives` task configuration.
    However, we can also refer to an existing repository definition that was configured
    in our project using the `repositories` configuration block. This is a good practice
    because we only have to define the repository once and can reuse it in multiple
    tasks in our build files. Let''s rewrite our previous example build file, define
    the repository in a `repositories` configuration block, and refer to it from the
    `uploadArchives` task. The following code shows this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`uploadArchives`任务配置中配置了仓库。然而，我们也可以通过使用`repositories`配置块来引用项目中配置的现有仓库定义。这是一个好习惯，因为我们只需要定义一次仓库，就可以在构建文件中的多个任务中重用它。让我们重写之前的示例构建文件，在`repositories`配置块中定义仓库，并在`uploadArchives`任务中引用它。以下代码展示了这一点：
- en: '[PRE21]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Excluding the descriptor file
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 排除描述符文件
- en: By default, an Ivy descriptor file is added to the upload location. If we don't
    want it, we can set the `uploadDescriptor` property for the `Upload` task.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ivy描述符文件会被添加到上传位置。如果我们不希望它被添加，我们可以为`Upload`任务设置`uploadDescriptor`属性。
- en: 'In the following example build file, we set the `uploadDescriptor` property
    to `false` in the `uploadArchives` task:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例构建文件中，我们在`uploadArchives`任务中将`uploadDescriptor`属性设置为`false`：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When we execute the task and look at the files in the `lib-repo` directory,
    we see that the descriptor file is not added. The following code shows this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们执行任务并查看`lib-repo`目录中的文件时，我们看到描述符文件没有被添加。以下代码展示了这一点：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Signing artifacts
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 签署工件
- en: We can digitally sign artifacts in Gradle with the signing plugin. The plugin
    supports generating **Pretty Good Privacy** (**PGP**) signatures. This signature
    format is also required for publication to Maven Central Repository. To create
    a PGP signature, we must install a few PGP tools on our computer. Installation
    of the tools is different for each operating system. On Unix-like systems, the
    software is probably available via a package manager. With the PGP software, we
    need to create a key pair that we can use to sign artifacts.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 Gradle 的签名插件对工件进行数字签名。该插件支持生成 **Pretty Good Privacy** (**PGP**) 签名。这种签名格式也是发布到
    Maven Central 仓库所必需的。要创建 PGP 签名，我们必须在我们的计算机上安装一些 PGP 工具。这些工具的安装方式因操作系统而异。在类 Unix
    系统上，软件可能通过包管理器提供。使用 PGP 软件，我们需要创建一个密钥对，我们可以使用它来签名工件。
- en: To sign artifacts, we must apply the signing plugin to our project. Then we
    must configure the plugin using a `signing` configuration block. We need to at
    least add information about our PGP key pair. We need the hexadecimal representation
    of the public key, the path to the secret key ring file with our private key,
    and the passphrase used to protect the private key. We assign this information
    to the `keyId`, `secretKeyRingFile`, and `password` properties of the signing
    plugin configuration. These values shouldn't be part of the Gradle build file
    because they are secret, so it is better to store them in a `gradle.properties`
    file and apply secure file permissions to the file. Also, we do not add this file
    to our version control system.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要对工件进行签名，我们必须将签名插件应用到我们的项目中。然后我们必须使用 `signing` 配置块来配置插件。我们需要至少添加有关我们的 PGP 密钥对的信息。我们需要公钥的十六进制表示，包含我们的私钥的秘密密钥环文件的路径，以及用于保护私钥的密码短语。我们将这些信息分配给签名插件配置的
    `keyId`、`secretKeyRingFile` 和 `password` 属性。这些值不应包含在 Gradle 构建文件中，因为它们是秘密的，所以最好将它们存储在
    `gradle.properties` 文件中，并对该文件应用安全的文件权限。此外，我们不应将此文件添加到我们的版本控制系统中。
- en: 'In the following example `gradle.properties` file, we set the properties. The
    values are sample values and are different for each user:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例 `gradle.properties` 文件中，我们设置了属性。这些值是示例值，并且对每个用户都不同：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Using configurations to sign
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用配置进行签名
- en: We are ready to sign our artifacts. We need to configure which artifacts we
    want to be signed using the `signing` configuration block. We must specify the
    name of the artifact configuration that contains the artifacts to be signed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好对工件进行签名。我们需要使用 `signing` 配置块来配置我们想要签名的工件。我们必须指定包含要签名的工件的工件配置名称。
- en: 'When we apply the Java plugin to our project, we get the `archives` artifact
    configuration. We want to sign the artifacts assigned to this configuration. In
    the next example build file, we apply both the Java and signing plugins. In the
    `signing` configuration block, we define that we want to sign the artifacts belonging
    to the `archives` configuration:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 Java 插件应用到我们的项目中时，我们会得到 `archives` 工件配置。我们希望对这个配置分配的工件进行签名。在下一个示例构建文件中，我们应用了
    Java 和签名插件。在 `signing` 配置块中，我们定义了我们要对属于 `archives` 配置的工件进行签名：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The signing plugin also adds a new task rule to our project—`sign<ConfigurationName>`.
    The name of the configuration is what we define in the `signing` configuration
    block. We defined the `archives` configuration so, in our project, we can now
    execute the `signArchives` task. The task is also added as a task dependency to
    the assemble task; thus, every time we invoke the `assemble` task, Gradle makes
    sure the `signArchives` task is invoked as well.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 签名插件还为我们项目添加了一个新的任务规则——`sign<ConfigurationName>`。配置的名称是我们定义在 `signing` 配置块中的名称。我们定义了
    `archives` 配置，因此，在我们的项目中，我们现在可以执行 `signArchives` 任务。该任务也被添加为 `assemble` 任务的依赖项；因此，每次我们调用
    `assemble` 任务时，Gradle 都会确保 `signArchives` 任务也被调用。
- en: 'Here, we run the `uploadArchives` task to see which files are put in the repository
    directory:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们运行 `uploadArchives` 任务以查看哪些文件被放入了仓库目录：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We notice that a signature file, `sample-2.1.asc`, is created together with
    the `sample-2.1.asc.sha1` checksum file for the signature file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到，与签名文件 `sample-2.1.asc` 一起创建了一个用于签名文件的校验和文件 `sample-2.1.asc.sha1`。
- en: Using archive tasks to sign
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用存档任务进行签名
- en: To sign an artifact that is not part of an artifact configuration, we must configure
    the signing plugin differently. In the `signing` configuration block, we assigned
    a configuration in the previous section, but we can also use an archive task.
    The output of this archive task will be signed when we invoke the `sign<TaskName>`
    task rule.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要对不属于工件配置的工件进行签名，我们必须对签名插件进行不同的配置。在`signing`配置块中，我们在上一节中分配了一个配置，但我们也可以使用归档任务。当我们调用`sign<TaskName>`任务规则时，这个归档任务的输出将被签名。
- en: 'In the next example build file, we will create a ZIP file with the `manualZip`
    task. We will configure the signing plugin for the `manualZip` task so that this
    ZIP file is signed:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例构建文件中，我们将使用`manualZip`任务创建一个ZIP文件。我们将为`manualZip`任务配置签名插件，以便这个ZIP文件被签名：
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'All `sign<TaskName>` tasks automatically have a task dependency on the archive
    task identifier by `<TaskName>`. So, we can now simply invoke the `uploadManualDistribution`
    task, and the ZIP file is created, signed, and uploaded to the `repo` directory.
    The following code shows this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`sign<TaskName>`任务自动具有对归档任务标识符的任务依赖，通过`<TaskName>`。因此，我们现在可以简单地调用`uploadManualDistribution`任务，ZIP文件将被创建、签名并上传到`repo`目录。以下代码展示了这一点：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In the previous chapters, you learned how to use external dependencies. In this
    chapter, you learned how you can define artifact configurations to assign your
    own artifacts. These artifacts can be dependencies for other developers on other
    projects and applications.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何使用外部依赖。在本章中，你学习了如何定义工件配置以分配你自己的工件。这些工件可以是其他项目和其他应用中其他开发者的依赖。
- en: You also learned how to create a default artifact when you use the Java plugin.
    Next, we saw how to create more than one artifact from the same project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了在使用Java插件时如何创建默认工件。接下来，我们看到了如何从一个项目中创建多个工件。
- en: You then learned how to configure an `Upload` task, so you can upload your artifacts
    to a local directory. This directory could also be a network share accessible
    to other development teams.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你随后学习了如何配置一个`上传`任务，以便你可以将你的工件上传到本地目录。这个目录也可以是其他开发团队可访问的网络共享。
- en: Finally, you learned how you can sign your artifacts using the signing plugin.
    This could be useful when you want to provide some extra confidence to people
    using the artifacts.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了如何使用签名插件对你的工件进行签名。当你希望向使用工件的人提供额外信心时，这可能很有用。
- en: In the next chapters, you will see how you can upload your artifacts to a Maven
    repository, an Ivy repository, and Bintray.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将看到如何将你的工件上传到Maven仓库、Ivy仓库和Bintray。
