- en: Chapter 4. Publishing Artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we learned how to define and use dependencies in our
    projects. However, the code we write in our projects can also be a dependency
    for another project. In order for another project to use our code as a dependency,
    we should publish our code as a dependency artifact so that it can be used by
    other projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how you can define artifacts in your project.
    These artifacts need to be published for others to use them. We first publish
    them using a filesystem, so the artifacts can be used from the same computer or
    even if we use a network share on an intranet. In later chapters, we will see
    how to publish our artifacts to a Maven repository, an Ivy repository, and Bintray.
  prefs: []
  type: TYPE_NORMAL
- en: Defining artifact configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Gradle project can contain artifacts we want to publish. An artifact can be
    a ZIP or JAR archive file or any other file. We can define one or more artifacts
    in one project. Thus, we don't have to create two different projects if we want
    to have two different artifacts from the same source tree.
  prefs: []
  type: TYPE_NORMAL
- en: In Gradle, we group artifacts using configurations. We used configurations to
    define dependencies for our project, but now we will use the configurations to
    group our artifacts that can be dependencies for others. So a configuration can
    contain both dependencies and artifacts. If we apply the Java plugin to our project,
    we get a configuration named `archives`, that contains the default JAR artifact
    for the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example Gradle build file, we use the Java plugin. We add
    a task to display the filename of the artifact that belongs to the `archives`
    configuration. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the `artifactsInfo` task from the command line, we see the `java_lib.jar`
    filename in the output. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For each configuration in our project, Gradle adds two tasks to the project:
    `build<ConfigurationName>` and `upload<ConfigurationName>`. The `build<ConfigurationName>`
    task creates the artifacts for the given configuration name. The `upload<ConfigurationName>`
    task creates and uploads the artifacts for the given configuration name. The `upload<ConfigurationName>`
    task needs extra configuration to know where to upload the artifacts. We will
    see later in this chapter how to configure the task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example project, we have the `buildArchives` and `uploadArchives` tasks.
    Let''s run the `buildArchives` task for our example project and see which tasks
    are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that first everything is prepared in our Java project to create
    the JAR artifact. The JAR artifact is then added to the `artifacts` configuration.
    The `java_lib.jar` JAR file that is created can be found in the `build/libs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we set the `version` property for our project, then it will be used in the
    name of our created artifact. In the next example build file, we will set the
    `version` property and look at the name that is created for the artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the `artifactsInfo` task to see the name of our artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Defining artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you learned that the Java plugin adds an `archives`
    configuration that is used to group artifacts from the project. Just as we created
    configurations for dependencies in our project, we can also create our own configurations
    for its artifacts. To assign an archive or file to this configuration, we must
    use the `artifacts` configuration block in our build script. Inside the configuration
    closure, we use the name of the configuration followed by the artifact. We can
    also further customize the artifact definition inside the `artifacts` block.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can define artifacts with the following three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AbstractArchiveTask` | The information for the artifact is extracted from
    the archive task. The artifact is an instance of `PublishArtifact` in the `org.gradle.api.artifact`
    `s` package. |'
  prefs: []
  type: TYPE_TB
- en: '| `File` | The information for the artifact is extracted from the filename.
    The artifact is an instance of `ConfigurablePublishArtifact` that extends `PublishArtifact`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Map` | This is another way to define a file artifact. The map must contain
    a `file` key, and other properties are used to further configure the artifact.
    |'
  prefs: []
  type: TYPE_TB
- en: Using the archive task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the next example build file, we will use an archive task to define the artifacts
    for the project. It is important to remember to apply the Gradle base plugin to
    the project because the base plugin adds the task rules for `build<ConfigurationName>`
    and `upload<ConfigurationName>`. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use an archive task to define the artifact for a configuration, Gradle
    also adds a task dependency for the artifact. This means that, if we invoke the
    `buildManualDistribution` task, Gradle also invokes the `manual` task that generates
    the archive for the artifact configuration. We see this when we execute the task
    from the command line. The following command shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using artifact files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides archive tasks, we can use a file as an artifact. Gradle will use the
    properties of the file to define the artifact name, type, and extension. In the
    following example build file, we use a file as an artifact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add an extra configuration closure when we use the file artifact notation.
    In the closure, we can set the name, type, extension, and classifier attributes.
    The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: One interesting method we can use in the file artifact configuration closure
    is the `builtBy` method. This method accepts one or more task names that are responsible
    for building the artifact. If we use this method, Gradle can determine the tasks
    that need to be executed when we run the `build<ConfigurationName>` or `upload<ConfigurationName>`
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `builtBy` method in the next example build file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that the `docFiles` task is added as a task dependency, we run the
    `buildReadmeDistribution` from the command line. The following command shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use a map notation when we define a file artifact. We use the
    `file` attribute to define the file. We can also use the `name`, `extension`,
    `type`, `classifier`, and `builtBy` keys for the definition. In the following
    example build file, we use the map notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Creating artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how to define artifacts, but we also need to create artifacts in our
    build files. We can either use an archive task to create the artifact or a file
    can be an artifact. Most of the time, when we use Gradle in a Java project, we
    build an archive with compiled classes and resources. Actually, the Java plugin
    adds a `jar` task to our project that will just do that. The JAR file created
    is then added to the `archives` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example build file, we will use the Java plugin and simply rely
    on the default artifact configuration and tasks. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the `buildArchives` task and check the artifacts with the `artifactsInfo`
    task from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have a single artifact; however, in the same project we can
    have more than one artifact when we use Gradle. For example, we might want to
    have our source packaged into a JAR file and our generated documentation as well.
    Both JAR files should be part of the `archives` configuration so that, when we
    execute the `buildArchives` task, all the tasks necessary to create these JAR
    files are executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We extend our previous example build file, add the code to create two extra
    JAR files, and add them to the `archives` artifact configuration. The following
    code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now execute the `buildArchives` and `artifactsInfo` tasks. We see in
    the output that our two new tasks, `sourcesJar` and `javadocJar`, are executed.
    And the generated artifact files are `sample-2.1.jar`, `sample-2.1-sources.jar`,
    and `sample-2.1-javadoc.jar`. The following command shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we have a Java project and, from the same source
    set, we want to create two different archive files. The source set contains a
    few API classes and implementation classes. We want to have a JAR file with the
    API classes and a JAR file, along with the implementation classes. The following
    code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now run the `buildArchives` task and see that all the tasks necessary
    to create the JAR file with the classes from the `api` source set are executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Publishing artifacts to the local directory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now know how to create one or more artifacts and how to use artifact configurations
    to group them. In this section, we will see how we can copy our artifacts to a
    local directory or network share. Remember that, for each artifact's configuration,
    Gradle adds a `build<ConfigurationName>` task and an `upload<ConfigurationName>`
    task. Now it is time to learn more about the `upload<ConfigurationName>` task
    so that we can copy our artifacts. In the following chapters we will also learn
    how to deploy to a Maven repository, an Ivy repository, and to Bintray.
  prefs: []
  type: TYPE_NORMAL
- en: 'For each `upload<ConfigurationName>` task, we must configure a repository definition.
    The repository definition is basically the destination of our artifacts when we
    upload or publish them. In this section, we use a local directory, so we define
    a repository using the `flatDir` method. We specify a name and the directory so
    that Gradle knows where the output of the `upload<ConfigurationName>` task needs
    to go. In Gradle projects where we have applied the Java plugin, we already have
    the `archives` artifact configuration and the `uploadArchives` task. We must configure
    the `uploadArchives` task and define the repository that needs to be used. In
    the next example build file, we will use the `lib-repo` local directory as the
    repository directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the output when we execute the `uploadArchives` task and check the
    files in the `lib-repo` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `lib-repo` directory, for our artifact, we have an Ivy descriptor file
    named `ivy-2.1.xml` and, for this descriptor file, a checksum file named `ivy-2.1.xml.sha1`.
    Also, we see our `sample-2.1.jar` artifact and the `sample-2.1.jar.sha1` checksum
    file for our artifact. The Ivy descriptor file contains basic information about
    our artifact. This is shown by the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We have configured the repository inside the `uploadArchives` task configuration.
    However, we can also refer to an existing repository definition that was configured
    in our project using the `repositories` configuration block. This is a good practice
    because we only have to define the repository once and can reuse it in multiple
    tasks in our build files. Let''s rewrite our previous example build file, define
    the repository in a `repositories` configuration block, and refer to it from the
    `uploadArchives` task. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Excluding the descriptor file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, an Ivy descriptor file is added to the upload location. If we don't
    want it, we can set the `uploadDescriptor` property for the `Upload` task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example build file, we set the `uploadDescriptor` property
    to `false` in the `uploadArchives` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the task and look at the files in the `lib-repo` directory,
    we see that the descriptor file is not added. The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Signing artifacts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can digitally sign artifacts in Gradle with the signing plugin. The plugin
    supports generating **Pretty Good Privacy** (**PGP**) signatures. This signature
    format is also required for publication to Maven Central Repository. To create
    a PGP signature, we must install a few PGP tools on our computer. Installation
    of the tools is different for each operating system. On Unix-like systems, the
    software is probably available via a package manager. With the PGP software, we
    need to create a key pair that we can use to sign artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: To sign artifacts, we must apply the signing plugin to our project. Then we
    must configure the plugin using a `signing` configuration block. We need to at
    least add information about our PGP key pair. We need the hexadecimal representation
    of the public key, the path to the secret key ring file with our private key,
    and the passphrase used to protect the private key. We assign this information
    to the `keyId`, `secretKeyRingFile`, and `password` properties of the signing
    plugin configuration. These values shouldn't be part of the Gradle build file
    because they are secret, so it is better to store them in a `gradle.properties`
    file and apply secure file permissions to the file. Also, we do not add this file
    to our version control system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example `gradle.properties` file, we set the properties. The
    values are sample values and are different for each user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Using configurations to sign
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are ready to sign our artifacts. We need to configure which artifacts we
    want to be signed using the `signing` configuration block. We must specify the
    name of the artifact configuration that contains the artifacts to be signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we apply the Java plugin to our project, we get the `archives` artifact
    configuration. We want to sign the artifacts assigned to this configuration. In
    the next example build file, we apply both the Java and signing plugins. In the
    `signing` configuration block, we define that we want to sign the artifacts belonging
    to the `archives` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The signing plugin also adds a new task rule to our project—`sign<ConfigurationName>`.
    The name of the configuration is what we define in the `signing` configuration
    block. We defined the `archives` configuration so, in our project, we can now
    execute the `signArchives` task. The task is also added as a task dependency to
    the assemble task; thus, every time we invoke the `assemble` task, Gradle makes
    sure the `signArchives` task is invoked as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we run the `uploadArchives` task to see which files are put in the repository
    directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We notice that a signature file, `sample-2.1.asc`, is created together with
    the `sample-2.1.asc.sha1` checksum file for the signature file.
  prefs: []
  type: TYPE_NORMAL
- en: Using archive tasks to sign
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To sign an artifact that is not part of an artifact configuration, we must configure
    the signing plugin differently. In the `signing` configuration block, we assigned
    a configuration in the previous section, but we can also use an archive task.
    The output of this archive task will be signed when we invoke the `sign<TaskName>`
    task rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next example build file, we will create a ZIP file with the `manualZip`
    task. We will configure the signing plugin for the `manualZip` task so that this
    ZIP file is signed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'All `sign<TaskName>` tasks automatically have a task dependency on the archive
    task identifier by `<TaskName>`. So, we can now simply invoke the `uploadManualDistribution`
    task, and the ZIP file is created, signed, and uploaded to the `repo` directory.
    The following code shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned how to use external dependencies. In this
    chapter, you learned how you can define artifact configurations to assign your
    own artifacts. These artifacts can be dependencies for other developers on other
    projects and applications.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to create a default artifact when you use the Java plugin.
    Next, we saw how to create more than one artifact from the same project.
  prefs: []
  type: TYPE_NORMAL
- en: You then learned how to configure an `Upload` task, so you can upload your artifacts
    to a local directory. This directory could also be a network share accessible
    to other development teams.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned how you can sign your artifacts using the signing plugin.
    This could be useful when you want to provide some extra confidence to people
    using the artifacts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, you will see how you can upload your artifacts to a Maven
    repository, an Ivy repository, and Bintray.
  prefs: []
  type: TYPE_NORMAL
