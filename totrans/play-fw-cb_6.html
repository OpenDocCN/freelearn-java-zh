<html><head></head><body><h1 id="e-dFCN">Chapter 6. Practical Module Examples</h1>
<p id="e-Sxee">In this chapter, we will cover the following recipes:</p>
<ul id="e-noCr">
<li id="e-SmeH">Integrating a Play application with message queues</li>
<li id="e-dO6Q">Integrating a Play application with ElasticSearch</li>
<li id="e-KAnv">Implementing token authentication using JWT</li>
</ul>
<h1 id="e-OSZU">Introduction</h1>
<p id="e-ZaVQ">In this chapter, we will look further into integrating a Play application with other essential services and tools for the modern web application. Specifically, we will look into how we can integrate an external message queue service with a Play plugin. We will use the popular cloud service <strong>IronMQ</strong> for this.</p>
<p id="e-tPi9">We will also look into integrating a full text search engine service with a Play application using <strong>ElasticSearch</strong> and <strong>Docker</strong>.</p>
<p id="e-RLIf">Finally, we will implement our own Play wrappers for the integration of token authentication using <strong>JSON Web Tokens</strong> (<strong>JWT</strong>).</p>

<h1 id="e-k8wi">Integrating a Play application with message queues</h1>
<p id="e-aCL0">In this recipe, we will explore how to use Play 2.0 to integrate with IronMQ, a popular cloud message queue service. We will use IronMQ's Java libraries, which can be found here:</p>
<p id="e-brhQ"><a href="https://github.com/iron-io/iron_mq_java">https://github.com/iron-io/iron_mq_java</a></p>
<p id="e-i7j1">We will use a Play plugin to initialize our IronMQ client and queue objects, and will expose helper methods to send and retrieve messages. We will then use this plugin in a Play controller that will allow clients to post messages and retrieve messages using the HTTP method, <code>GET</code>.</p>
<h2 id="e-HWh1">How to do it…</h2>
<p id="e-Vs6L">For Java, we need to perform the following steps:</p>
<ol id="e-qzQt">
<li id="e-BKgl">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-bNxd">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-obT4">Create an IronMQ account on <a href="http://www.iron.io/">http://www.iron.io/</a> and create an IronMQ project; make a note of your project ID and token</li>
<li id="e-r2G7">Import the official IronMQ java libraries as app dependencies in <code>build.sbt</code>:<pre id="e-y2fe">libraryDependencies ++= Seq(
      "io.iron.ironmq" % "ironmq" % "0.0.19"
    )</pre>
</li>
<li id="e-LVPP">Create the plugins package inside <code>foo_java/app</code>:<pre id="e-ncGg">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir plugins&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-MCZS">Create our plugin class, MQPlugin, in the <code>foo_java/app/plugins</code> directory:<pre id="e-pMdf">package plugins;
     import io.iron.ironmq.Client;
    import io.iron.ironmq.Message;
    import io.iron.ironmq.Messages;
    import io.iron.ironmq.Queue;
    import play.Application;
    import play.Logger;
    import play.Plugin;
    import java.util.UUID;
     public class MQPlugin extends Plugin {
        final private Integer messageSize = 10;
        private Client client;
        private Queue queue;
         public MQPlugin(Application app) {
            super();
            client = new Client(
                app.configuration().getString("mq.projectId"),
                app.configuration().getString("mq.token")
            );
        }
         public void onStart() {
            queue = client.queue(UUID.randomUUID().toString());
        }
         public void onStop() {
            try {
                queue.clear();
                queue.destroy();
                client = null;
            } catch(Exception e) {
                Logger.error(e.toString());
            }
        }
         public void send(String msg) throws Exception {
            queue.push(msg);
        }
         public Message[] retrieve() throws Exception {
            Messages messages = queue.get(messageSize);
            if (messages.getSize() &amp;gt; 0) {
                Message[] msgArray = messages.getMessages();
                 for(Message m : msgArray) {
                    queue.deleteMessage(m);
                }
                 return msgArray;
            }
             return new Message[] {};
        }
         public boolean enabled() {
            return true;
        }
    }</pre>
</li>
<li id="e-YtU6">Modify <code>conf/application.conf</code> and add your IronMQ project ID and token:<pre id="e-kegz">mq.projectId="YOUR PROJECT ID"
    mq.token="YOUR TOKEN"</pre>
</li>
<li id="e-cLad">Initialize the MQPlugin by declaring it in the <code>conf/play.plugins</code> file:<pre id="e-hRIg">599:plugins.MQPlugin</pre>
</li>
<li id="e-vq7L">Create a <code>Messenger</code> controller class in <code>app/controllers</code>:<pre id="e-hpzA">package controllers;
     import play.Logger;
    import play.Play;
    import play.data.Form;
    import play.mvc.BodyParser;
    import play.mvc.Controller;
    import play.mvc.Result;
    import plugins.MQPlugin;
    import java.util.HashMap;
    import java.util.Map;
     import static play.libs.Json.toJson;
     public class Messenger extends Controller {
        private static MQPlugin mqPlugin = Play.application().plugin(MQPlugin.class);
         @BodyParser.Of(BodyParser.Json.class)
        public static Result sendMessage() {
            try {
                Form&amp;lt;Message&amp;gt; form = Form.form(Message.class).bindFromRequest();
                Message m = form.get();
                mqPlugin.send(m.getBody());
                 Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
                map.put("status", "Message sent.");
                return created(toJson(map));
             } catch (Exception e) {
                return internalServerError(e.getMessage());
            }
        }
         public static Result getMessages() {
            try {
                return ok(toJson(mqPlugin.retrieve()));
            } catch (Exception e) {
                Logger.error(e.toString());
                return internalServerError();
            }
        }
    }</pre>
</li>
<li id="e-l3Hk">Add new routes for the <code>Messenger</code> controller actions:<pre id="e-fN0L">POST    /messages/send       controllers.Messenger.sendMessage
    GET     /messages            controllers.Messenger.getMessages</pre>
</li>
<li id="e-ZltE">Using <code>curl</code>, let's send and retrieve messages:<pre id="e-yc4V">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST http://localhost:9000/messages/send --header "Content-type: application/json" -d '{"body":"Her mouth the mischief he doth seek"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /messages/send HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 46&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 46 out of 46 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 26&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"status":"Message sent."}%&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/messages&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /messages HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 95&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"messages":["Her mouth the mischief he doth seek","Her heart the captive of which he speaks"]}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-ePrM">In the IronMQ Web Console, you can also confirm the queue message size to confirm that we were able to post a message:<img data-width="800" data-height="525" src="CiOxgcxa.jpg"/>
</li>
</ol>
<p id="e-hDSv">For Scala, we need to perform the following steps:</p>
<ol id="e-SLdQ">
<li id="e-l1qk">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-gGZX">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-uqbh">Create an IronMQ account on <a href="http://www.iron.io/">http://www.iron.io/</a> and create an IronMQ project; make a note of your project ID and token.</li>
<li id="e-Jz53">Import the official IronMQ java libraries as app dependencies in <code>build.sbt</code>:<pre id="e-yPzB">libraryDependencies ++= Seq(
      "io.iron.ironmq" % "ironmq" % "0.0.19"
    )</pre>
</li>
<li id="e-rDDJ">Create the plugins package in <code>foo_scala/app</code>:<pre id="e-Alrb">&lt;span class="strong"&gt;&lt;strong&gt;    mkdir plugins&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Oodi">Create our plugin class, MQPlugin, in the <code>foo_scala/app/plugins</code> directory:<pre id="e-VMpx">package plugins
     import java.util.UUID
    import io.iron.ironmq.{Client, Queue}
    import play.api.Play.current
    import play.api.{Application, Play, Plugin}
    import play.api.libs.concurrent.Execution.Implicits._
    import scala.concurrent.Future
     class MQPlugin(app: Application) extends Plugin {
      private val messageSize = 10
      private var client: Client = null
      private var queue: Queue = null
       override def onStart() = {
        client = new Client(
          Play.configuration.getString("mq.projectId").get,
          Play.configuration.getString("mq.token").get
        )
        queue = client.queue(UUID.randomUUID().toString)
      }
       override def onStop() = {
        queue.clear()
        queue.destroy()
        client = null
      }
       def send(msg: String) = queue.push(msg)
       def retrieve = {
        val list = queue.get(messageSize)
        Future {
          list.getMessages.map(queue.deleteMessage(_))
        }
        list.getMessages.map(_.getBody)
      }
    override def enabled = true
    }</pre>
</li>
<li id="e-Renz">Modify <code>conf/application.conf</code> and add your IronMQ project ID and token:<pre id="e-VqUR">mq.projectId="YOUR PROJECT ID"
    mq.token="YOUR TOKEN"</pre>
</li>
<li id="e-L0Ga">Initialize the MQPlugin by declaring it in the <code>conf/play.plugins</code> file:<pre id="e-zpxs">599:plugins.MQPlugin</pre>
</li>
<li id="e-Gda0">Create a <code>Messenger</code> controller class in <code>app/controllers</code>:<pre id="e-qXBp">package controllers
     import play.api.Play.current
    import play.api.Play
    import play.api.libs.json.{JsError, Json}
    import play.api.mvc.{BodyParsers, Action, Controller}
    import plugins.MQPlugin
     case class Message(body: String)
     object Messenger extends Controller {
      implicit private val writes = Json.writes[Message]
      implicit private val reads = Json.reads[Message]
      private val mqPlugin = Play.application.plugin[MQPlugin].get
       def sendMessage = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
        val post = request.body.validate[Message]
         post.fold(
          errors =&amp;gt; BadRequest(JsError.toFlatJson(errors)),
          p =&amp;gt; {
            mqPlugin.send(p.body)
            Created(Json.obj("status" -&amp;gt; "Message sent."))
          }
        )
      }
       def getMessages = Action {
        Ok(Json.obj("messages" -&amp;gt; mqPlugin.retrieve))
      }
    }</pre>
</li>
<li id="e-Q2Hy">Add new routes for the <code>Messenger</code> controller actions:<pre id="e-Fcyb">POST    /messages/send       controllers.Messenger.sendMessage
    GET     /messages            controllers.Messenger.getMessages</pre>
</li>
<li id="e-tcdw">Using <code>curl</code>, let's send and retrieve messages:<pre id="e-pG9Q">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v -X POST http://localhost:9000/messages/send --header "Content-type: application/json" -d '{"body":"Her mouth the mischief he doth seek"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /messages/send HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 46&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 46 out of 46 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 201 Created&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 26&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"status":"Message sent."}%&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/messages&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /messages HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 95&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    {"messages":["Her mouth the mischief he doth seek","Her heart the captive of which he speaks"]}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-sxD3">In the IronMQ Web Console, you can also check the queue message size to confirm that we were able to post a message:<img data-width="800" data-height="524" src="CZSpoQpf.jpg"/>
</li>
</ol>
<h2 id="e-gneA">How it works…</h2>
<p id="e-HPX7">In this recipe, we set up the message queue plugin by first importing the official IronMQ Java library to <code>build.sbt</code>. We will also need to log in to IronMQ to create our IronMQ project and to retrieve our project tokens:</p>
<img data-width="800" data-height="525" src="RBXJtXDJ.jpg"/><p id="e-qeOv">We configured the Play application by adding our IronMQ credentials to <code>conf/application.conf</code>:</p>
<pre id="e-JZIP">mq.projectId="YOUR PROJECT ID"
    mq.token="YOUR TOKEN"</pre>
<p id="e-GqoG">We then implemented the <code>MQPlugin</code> class by retrieving the project ID and token from the config file and passing that to an instance of <code>io.iron.ironmq.Client</code>:</p>
<pre id="e-UnLk">// Java 
    public MQPlugin(Application app) {
        super();
        client = new Client(
            app.configuration().getString("mq.projectId"),
            app.configuration().getString("mq.token")
        );
    }
     // Scala
    override def onStart() = {
      client = new Client(
        Play.configuration.getString("mq.projectId").get,
        Play.configuration.getString("mq.token").get
      )
    }</pre>
<p id="e-UX4e">We created our dynamic message queue in the <code>onStart</code> method as well, passing a <code>UUID</code> parameter as the default queue name:</p>
<pre id="e-nCWz">// Java 
    public void onStart() {
        queue = client.queue(UUID.randomUUID().toString());
    }
     // Scala
    queue = client.queue(UUID.randomUUID().toString)</pre>
<p id="e-lglT">We then declared the two methods that will facilitate message sending and retrieval:</p>
<pre id="e-ZT8b">// Java
    public void send(String msg) throws Exception {
        queue.push(msg);
    }
     public Message[] retrieve() throws Exception {
        Messages messages = queue.get(messageSize);
        if (messages.getSize() &amp;gt; 0) {
            Message[] msgArray = messages.getMessages();
             for(Message m : msgArray) {
                queue.deleteMessage(m);
            }
             return msgArray;
        }
         return new Message[] {};
    }    
     // Scala
    def send(msg: String) = queue.push(msg)
     def retrieve = {
      val list = queue.get(messageSize)
      Future {
        list.getMessages.map(queue.deleteMessage(_))
      }
      list.getMessages.map(_.getBody)
    }</pre>
<p id="e-LyzB">We wanted to be able to remove read messages from the queue and run an asynchronous function to delete them here:</p>
<pre id="e-cLRX">// Scala
    import play.api.libs.concurrent.Execution.Implicits._
    import scala.concurrent.Future
     Future {
      list.getMessages.map(queue.deleteMessage(_))
    }</pre>
<p id="e-vNyk">For Java, deleting the message will happen synchronously:</p>
<pre id="e-mC00">for(Message m : msgArray) {
      queue.deleteMessage(m);
    }</pre>
<p id="e-zC5V">Lastly, we implement the endpoints by creating the controller class, <code>Messenger</code>, which exposes two actions; one for message retrieval and another for messaging posting:</p>
<pre id="e-ZrV3">// Java 
    private static MQPlugin mqPlugin = Play.application().plugin(MQPlugin.class);
     @BodyParser.Of(BodyParser.Json.class)
    public static Result sendMessage() {
        try {
            Form&amp;lt;Message&amp;gt; form = Form.form(Message.class).bindFromRequest();
            Message m = form.get();
            mqPlugin.send(m.getBody());
             Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            map.put("status", "Message sent.");
            return created(toJson(map));
         } catch (Exception e) {
            return internalServerError(e.getMessage());
        }
    }
     public static Result getMessages() {
        try {
            return ok(toJson(mqPlugin.retrieve()));
        } catch (Exception e) {
            Logger.error(e.toString());
            return internalServerError();
        }
    }    
    // Scala
    implicit private val writes = Json.writes[Message]
    implicit private val reads = Json.reads[Message]
    private val mqPlugin = Play.application.plugin[MQPlugin].get
     def sendMessage = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
      val post = request.body.validate[Message]
       post.fold(
        errors =&amp;gt; BadRequest(JsError.toFlatJson(errors)),
        p =&amp;gt; {
          mqPlugin.send(p.body)
          Created(Json.obj("status" -&amp;gt; "Message sent."))
        }
      )
    }
     def getMessages = Action {
      Ok(Json.obj("messages" -&amp;gt; mqPlugin.retrieve))
    }</pre>
<p id="e-Thyc">And finally, add the respective routes to <code>conf/routes</code>:</p>
<pre id="e-AfID">POST    /messages/send       controllers.Messenger.sendMessage
    GET     /messages            controllers.Messenger.getMessages</pre>

<h1 id="e-pzOP">Integrating a Play application with ElasticSearch</h1>
<p id="e-p6Wq">In this recipe, we will create a very common web application functionality to create, index, and search, in our case, products. We will use ElasticSearch as our search service. We will use Docker to create our local ElasticSearch container and to run all search operations.</p>
<p id="e-dus7">A prerequisite for this recipe is having access to an ElasticSearch instance, either local or remote, in our recipe, as well as having Docker installed in the local development machine:</p>
<pre id="e-Zhrq">&lt;span class="strong"&gt;&lt;strong&gt;    $ docker -v&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    Docker version 1.3.3, build d344625&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-uKGe">We used Docker to deploy our local ElasticSearch instance using the command: </p>
<pre id="e-W6DG">&lt;span class="strong"&gt;&lt;strong&gt;    docker run -d -p 9200:9200 -p 9300:9300 dockerfile/elasticsearch&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-tAIX">The preceding command instructs <code>docker</code> to run the <code>elasticsearch</code> container as a detached service and that ports <code>9200</code> and <code>9300</code> in the container should be accessible from the corresponding ports in the host.</p>
<p id="e-KElD">We will use an open source Play module, <strong>play2-elasticsearch</strong>, to wrap our calls to the ElasticSearch instance. This recipe assumes some familiarity in Docker and full-text searching services. More information about play2-elasticsearch can be found at <a href="https://github.com/cleverage/play2-elasticsearch">https://github.com/cleverage/play2-elasticsearch</a>.</p>
<h3 id="e-lZbr">Note</h3>
<p id="e-XgtK">For more information regarding Docker and how to install it, please refer to their online documentation at <a href="https://docs.docker.com/installation/">https://docs.docker.com/installation/</a>.</p>
<h2 id="e-vUbN">How to do it…</h2>
<p id="e-x9Fk">For Java, we need to perform the following steps:</p>
<ol id="e-gnpO">
<li id="e-NcgN">First, let's fire up a local ElasticSearch container using Docker:<pre id="e-MUNk">&lt;span class="strong"&gt;&lt;strong&gt;    $ docker run -d -p 9200:9200 -p 9300:9300 dockerfile/elasticsearch&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-EuRE">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-ct88">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-bOy4">Add the play2-elasticsearch dependency in <code>build.sbt</code>. It is important to note that as of writing this, support for Play 2.3.x has not been released for play2-elasticsearch, hence, the need to exclude dependencies to older Play libraries:<pre id="e-HZiC">resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
     libraryDependencies ++= Seq(
      ("com.clever-age" % "play2-elasticsearch" % "1.4-SNAPSHOT")
        .exclude("com.typesafe.play", "play-functional_2.10")
        .exclude("com.typesafe.akka", "akka-actor_2.10")
        .exclude("com.typesafe.play", "play-json_2.10")
        .exclude("com.typesafe.play", "play_2.10")
        .exclude("com.typesafe.play", "play-iteratees_2.10")
        .exclude("com.typesafe.akka", "akka-slf4j_2.10")
        .exclude("org.scala-stm", "scala-stm_2.10")
        .exclude("com.typesafe.play", "play-datacommons_2.10")
     .exclude("com.typesafe.play", "play-java_2.10")
    )</pre>
</li>
<li id="e-pBk8">Declare the play2-elasticsearch plugin in <code>conf/play.plugins</code>:<pre id="e-uRNt">9000:com.github.cleverage.elasticsearch.plugin.IndexPlugin</pre>
</li>
<li id="e-JeVL">Add play2-elasticsearch configuration parameters to <code>conf/application.conf</code>:<pre id="e-xabo">elasticsearch.local=false
    elasticsearch.client="&amp;lt;YOUR ELASTIC SEARCH HOST HERE&amp;gt;:9300"
    elasticsearch.sniff=false
    elasticsearch.index.name="test"
    elasticsearch.index.settings="{ analysis: { analyzer: { my_analyzer: { type: \"custom\", tokenizer: \"standard\" } } } }"
    elasticsearch.index.clazzs="models.*"
    elasticsearch.index.show_request=true
    elasticsearch.cluster.name=elasticsearch</pre>
</li>
<li id="e-HIrT">Create the product model in <code>app/models/Product.java</code>:<pre id="e-Hu0M">package models;
     import com.github.cleverage.elasticsearch.Index;
    import com.github.cleverage.elasticsearch.IndexQuery;
    import com.github.cleverage.elasticsearch.IndexResults;
    import com.github.cleverage.elasticsearch.Indexable;
    import com.github.cleverage.elasticsearch.annotations.IndexType;
    import org.elasticsearch.index.query.QueryBuilders;
    import java.util.HashMap;
    import java.util.Map;
     @IndexType(name = "product")
    public class Product extends Index {
        private String id;
        private String title;
        private String shortDesc;
         public Product() {}
         public Product(String id, String title, String shortDesc) {
            this.id = id;
            this.title = title;
            this.shortDesc = shortDesc;
        }
         public String getId() {
            return id;
        }
         public void setId(String id) {
            this.id = id;
        }
         public String getTitle() {
            return title;
        }
         public void setTitle(String title) {
            this.title = title;
        }
         public String getShortDesc() {
            return shortDesc;
        }
         public void setShortDesc(String shortDesc) {
            this.shortDesc = shortDesc;
        }
         public static Finder&amp;lt;Product&amp;gt; find = new Finder&amp;lt;&amp;gt;(Product.class);
         @Override
        public Map toIndex() {
            Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
            map.put("id", this.id);
            map.put("title", this.title);
            map.put("description", this.getShortDesc());
            return map;
        }
         @Override
        public Indexable fromIndex(Map map) {
            Product p = new Product();
            p.setId((String) map.get("id"));
            p.setTitle((String) map.get("title"));
            p.setShortDesc((String) map.get("description"));
            return p;
        }
         public static IndexResults&amp;lt;Product&amp;gt; doSearch(String keyword) {
            IndexQuery&amp;lt;Product&amp;gt; indexQuery = Product.find.query();
            indexQuery.setBuilder(QueryBuilders.multiMatchQuery(keyword, "title", "description"));
            return Product.find.search(indexQuery);
        }
    }</pre>
</li>
<li id="e-CcUt">Next, create the products endpoint that will serve the creation and searching of products in <code>app/controllers/Products.java</code>:<pre id="e-oQEC">package controllers;
     import com.github.cleverage.elasticsearch.IndexResults;
    import models.Product;
    import play.data.Form;
    import play.mvc.BodyParser;
    import play.mvc.Controller;
    import play.mvc.Result;
    import java.util.HashMap;
    import java.util.Map;
     import static play.libs.Json.toJson;
     public class Products extends Controller {
        @BodyParser.Of(BodyParser.Json.class)
        public static Result create() {
            try {
                Form&amp;lt;Product&amp;gt; form = Form.form(Product.class).bindFromRequest();
                Product product = form.get();
                product.index();
                 return created(toJson(product));
             } catch (Exception e) {
                return internalServerError(e.getMessage());
            }
        }
         @BodyParser.Of(BodyParser.Json.class)
        public static Result search() {
            try {
                Form&amp;lt;Search&amp;gt; form = Form.form(Search.class).bindFromRequest();
                Search search = form.get();
                 IndexResults&amp;lt;Product&amp;gt; results = Product.doSearch(search.getKeyword());
                Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
                map.put("total", results.getTotalCount());
                map.put("products", results.getResults());
                 return ok(toJson(map));
             } catch (Exception e) {
                return internalServerError(e.getMessage());
            }
        }
    }</pre>
</li>
<li id="e-eXaJ">Let's also add the <code>Search</code> class from the helper class to <code>app/controllers/Search.java</code>:<pre id="e-KWVK">package controllers;
     public class Search {
        private String keyword;
         public String getKeyword() {
            return keyword;
        }
        public void setKeyword(String keyword) {
            this.keyword = keyword;
        }
    }</pre>
</li>
<li id="e-fnDk">Finally, let's add the routes to the product controller actions to <code>conf/routes</code>:<pre id="e-wksI">POST    /products            controllers.Products.create
    GET     /products/search     controllers.Products.search</pre>
</li>
<li id="e-qI3r">Using <code>curl</code>, we can test product creation and indexing as follows:<pre id="e-msHa">&lt;span class="strong"&gt;&lt;strong&gt;    # Let's insert 2 products:&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    curl -v -X POST http://localhost:9000/products --header "Content-type: application/json" -d '{"id":"1001", "title":"Intel Core i7-4790K Processor", "shortDesc": "New Unlocked 4th Gen Intel Core Processors deliver 4 cores of up to 4 GHz base frequency providing blazing-fast computing performance for the most demanding users"}'&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    curl -v -X POST http://localhost:9000/products --header "Content-type: application/json" -d '{"id":"1002", "title": "AMD FD6300WMHKBOX FX-6300 6-Core Processor", "shortDesc": "AMD FX 6-Core Processor Unlocked Black Edition. AMDs next-generation architecture takes 8-core processing to a new level. Get up to 24% better frame rates in some of the most demanding games at stunning resolutions. Get faster audio encoding so you can enjoy your music sooner. Go up to 5.0 GHz with aggressive cooling solutions from AMD."}'&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-fVAT">We can also use <code>curl</code> to execute product searches:<pre id="e-vRHM">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -X GET http://localhost:9000/products/search --header "Content-type: application/json" -d '{"keyword":"processor"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"total":2,"products":[{"id":"1001","title":"Intel Core i7-4790K Processor","shortDesc":"New Unlocked 4th Gen Intel Core Processors deliver 4 cores of up to 4 GHz base frequency providing blazing-fast computing performance for the most demanding users"},{"id":"1002","title":"AMD FD6300WMHKBOX FX-6300 6-Core Processor","shortDesc":"AMD FX 6-Core Processor Unlocked Black Edition. AMDs next-generation architecture takes 8-core processing to a new level. Get up to 24% better frame rates in some of the most demanding games at stunning resolutions. Get faster audio encoding so you can enjoy your music sooner. Go up to 5.0 GHz with aggressive cooling solutions from AMD."}]}%&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl -X GET http://localhost:9000/products/search --header "Content-type: application/json" -d '{"keyword":"amd"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"total":1,"products":[{"id":"1002","title":"AMD FD6300WMHKBOX FX-6300 6-Core Processor","shortDesc":"AMD FX 6-Core Processor Unlocked Black Edition. AMDs next-generation architecture takes 8-core processing to a new level. Get up to 24% better frame rates in some of the most demanding games at stunning resolutions. Get faster audio encoding so you can enjoy your music sooner. Go up to 5.0 GHz with aggressive cooling solutions from AMD."}]}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-qxdm">For Scala, we need to perform the following steps:</p>
<ol id="e-zrWy">
<li id="e-U308">First, let's fire up a local ElasticSearch container using Docker:<pre id="e-dh6u">&lt;span class="strong"&gt;&lt;strong&gt;    $ docker run -d -p 9200:9200 -p 9300:9300 dockerfile/elasticsearch&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-gaIF">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-Ucvm">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-mWRw">Add the play2-elasticsearch dependency in <code>build.sbt</code>. It is important to note that as of writing this, support for Play 2.3.x has not been released for play2-elasticsearch, hence the need to exclude dependencies from older Play libraries:<pre id="e-VEem">resolvers += "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
     libraryDependencies ++= Seq(
      ("com.clever-age" % "play2-elasticsearch" % "1.4-SNAPSHOT")
        .exclude("com.typesafe.play", "play-functional_2.10")
        .exclude("com.typesafe.akka", "akka-actor_2.10")
        .exclude("com.typesafe.play", "play-json_2.10")
        .exclude("com.typesafe.play", "play_2.10")
        .exclude("com.typesafe.play", "play-iteratees_2.10")
        .exclude("com.typesafe.akka", "akka-slf4j_2.10")
        .exclude("org.scala-stm", "scala-stm_2.10")
        .exclude("com.typesafe.play", "play-datacommons_2.10")
    )</pre>
</li>
<li id="e-fcii">Declare the play2-elasticsearch plugin in <code>conf/play.plugins</code>:<pre id="e-vLdl">9000:com.github.cleverage.elasticsearch.plugin.IndexPlugin</pre>
</li>
<li id="e-Ysw4">Add play2-elasticsearch configuration parameters to <code>conf/application.conf</code>:<pre id="e-fOr1">elasticsearch.local=false
    elasticsearch.client="&amp;lt;YOUR_ELASTICSEARCH_HOST_HERE&amp;gt;:9300"
    elasticsearch.sniff=false
    elasticsearch.index.name="test"
    elasticsearch.index.settings="{ analysis: { analyzer: { my_analyzer: { type: \"custom\", tokenizer: \"standard\" } } } }"
    elasticsearch.index.clazzs="models.*"
    elasticsearch.index.show_request=true
    elasticsearch.cluster.name=elasticsearch</pre>
</li>
<li id="e-rPb2">Create our product model and the <code>ProductManager</code> class in <code>app/models/Product.scala</code>:<pre id="e-ailb">package models
     import com.github.cleverage.elasticsearch.ScalaHelpers.{IndexQuery,     IndexableManager, Indexable}
    import org.elasticsearch.index.query.QueryBuilders
    import play.api.libs.json.{Writes, Json, Reads}
     case class Product(id: String, title: String, shortDesc: String) extends Indexable
     object ProductManager extends IndexableManager[Product] {
      override val indexType: String = "string"
      override val reads: Reads[Product] = Json.reads[Product]
      override val writes: Writes[Product] = Json.writes[Product]
       def doSearch(keyword: String) = {
        val indexQuery = new IndexQuery[Product]()
          .withBuilder(QueryBuilders.multiMatchQuery(keyword, "title", "description"))
         search(indexQuery)
      }
    }</pre>
</li>
<li id="e-Pwje">Next, create the products endpoint that will serve the creation and searching of products in <code>app/controllers/Products.scala</code>:<pre id="e-nMAf">package controllers
     import models.{Product, ProductManager}
    import play.api.libs.json.{JsError, Json}
    import play.api.mvc.{BodyParsers, Action, Controller}
     case class Search(keyword: String)
     object Products extends Controller {
      implicit private val productWrites = Json.writes[Product]
      implicit private val productReads = Json.reads[Product]
      implicit private val searchWrites = Json.writes[Search]
      implicit private val searchReads = Json.reads[Search]
       def create = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
        val post = request.body.validate[Product]
         post.fold(
          errors =&amp;gt; BadRequest(JsError.toFlatJson(errors)),
          p =&amp;gt; {
            ProductManager.index(p)
            Created(Json.toJson(p))
          }
        )
      }
       def search = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
        request.body.validate[Search].fold(
          errors =&amp;gt; BadRequest(JsError.toFlatJson(errors)),
          search =&amp;gt; {
            val results = ProductManager.doSearch(search.keyword)
            Ok(Json.obj(
              "total" -&amp;gt; results.totalCount,
              "products" -&amp;gt; results.results
            ))
          }
        )
      }
    }</pre>
</li>
<li id="e-acyl">Finally, let's add the routes to the product controller actions to <code>conf/routes</code>:<pre id="e-sSWc">POST    /products            controllers.Products.create
    GET     /products/search     controllers.Products.search</pre>
</li>
<li id="e-tnQM">Using <code>curl</code>, we can test product creation and indexing as follows:<pre id="e-t13Q">&lt;span class="strong"&gt;&lt;strong&gt;    # Let's insert 2 products:&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    curl -v -X POST http://localhost:9000/products --header "Content-type: application/json" -d '{"id":"1001", "title":"Intel Core i7-4790K Processor", "shortDesc": "New Unlocked 4th Gen Intel Core Processors deliver 4 cores of up to 4 GHz base frequency providing blazing-fast computing performance for the most demanding users"}'&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    curl -v -X POST http://localhost:9000/products --header "Content-type: application/json" -d '{"id":"1002", "title": "AMD FD6300WMHKBOX FX-6300 6-Core Processor", "shortDesc": "AMD FX 6-Core Processor Unlocked Black Edition. AMDs next-generation architecture takes 8-core processing to a new level. Get up to 24% better frame rates in some of the most demanding games at stunning resolutions. Get faster audio encoding so you can enjoy your music sooner. Go up to 5.0 GHz with aggressive cooling solutions from AMD."}'&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-HYdC">We can also use <code>curl</code> to execute product searches:<pre id="e-dM0W">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -X GET http://localhost:9000/products/search --header "Content-type: application/json" -d '{"keyword":"processor"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"total":2,"products":[{"id":"1001","title":"Intel Core i7-4790K Processor","shortDesc":"New Unlocked 4th Gen Intel Core Processors deliver 4 cores of up to 4 GHz base frequency providing blazing-fast computing performance for the most demanding users"},{"id":"1002","title":"AMD FD6300WMHKBOX FX-6300 6-Core Processor","shortDesc":"AMD FX 6-Core Processor Unlocked Black Edition. AMDs next-generation architecture takes 8-core processing to a new level. Get up to 24% better frame rates in some of the most demanding games at stunning resolutions. Get faster audio encoding so you can enjoy your music sooner. Go up to 5.0 GHz with aggressive cooling solutions from AMD."}]}%&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl -X GET http://localhost:9000/products/search --header "Content-type: application/json" -d '{"keyword":"amd"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"total":1,"products":[{"id":"1002","title":"AMD FD6300WMHKBOX FX-6300 6-Core Processor","shortDesc":"AMD FX 6-Core Processor Unlocked Black Edition. AMDs next-generation architecture takes 8-core processing to a new level. Get up to 24% better frame rates in some of the most demanding games at stunning resolutions. Get faster audio encoding so you can enjoy your music sooner. Go up to 5.0 GHz with aggressive cooling solutions from AMD."}]}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-kVpB">How it works…</h2>
<p id="e-chY3">In this recipe, we created endpoints for product creation and product search utilizing ElasticSearch as the underlying search service. A prerequisite for this recipe is having access to an ElasticSearch instance, either local or remote, in our recipe, as well as having Docker installed in the local development machine:</p>
<pre id="e-mm8f">&lt;span class="strong"&gt;&lt;strong&gt;    $ docker -v&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    Docker version 1.3.3, build d344625&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-Sw6C">We used Docker to deploy our local ElasticSearch instance using the following command:</p>
<pre id="e-CSh1">&lt;span class="strong"&gt;&lt;strong&gt;    docker run -d -p 9200:9200 -p 9300:9300 dockerfile/elasticsearch&lt;/strong&gt;&lt;/span&gt;</pre>
<p id="e-uv91">The preceding command instructs <code>docker</code> to run the <code>elasticsearch</code> container as a detached service and that ports <code>9200</code> and <code>9300</code> in the container should be accessible from the corresponding ports in the host.</p>
<p id="e-iOwu">We start by importing an open source play module, play2-elasticsearch, by declaring it in the <code>build.sbt</code> file:</p>
<pre id="e-epKo">resolvers +=   "Sonatype OSS Snapshots" at "https://oss.sonatype.org/content/repositories/snapshots"
     libraryDependencies ++= Seq(
      "io.iron.ironmq" % "ironmq" % "0.0.19",
      ("com.clever-age" % "play2-elasticsearch" % "1.4-SNAPSHOT")
        .exclude("com.typesafe.play", "play-functional_2.10")
        .exclude("com.typesafe.akka", "akka-actor_2.10")
        .exclude("com.typesafe.play", "play-json_2.10")
        .exclude("com.typesafe.play", "play_2.10")
        .exclude("com.typesafe.play", "play-iteratees_2.10")
        .exclude("com.typesafe.akka", "akka-slf4j_2.10")
        .exclude("org.scala-stm", "scala-stm_2.10")
        .exclude("com.typesafe.play", "play-datacommons_2.10")
    )</pre>
<p id="e-P7SO">We activate the plugin in <code>conf/play.plugins</code> and specify the configuration parameters in <code>conf/application.conf</code>:</p>
<pre id="e-MWAU">// conf/play.plugins
    9000:com.github.cleverage.elasticsearch.plugin.IndexPlugin
    // conf/application.conf
    elasticsearch.local=false
    elasticsearch.client="192.168.59.103:9300"
    elasticsearch.sniff=false
    elasticsearch.index.name="test"
    elasticsearch.index.settings="{ analysis: { analyzer: { my_analyzer: { type: \"custom\", tokenizer: \"standard\" } } } }"
    elasticsearch.index.clazzs="models.*"
    elasticsearch.index.show_request=true
    elasticsearch.cluster.name=elasticsearch</pre>
<p id="e-l2WO">We then created our product model, extending the play2-elasticsearch class, Indexable, and a search manager class, which extends the play2-elasticsearch IndexableManager class. We wrote a helper method to execute a multifield query to search the title and description fields by keyword:</p>
<pre id="e-B7DH">// Java 
    IndexQuery&amp;lt;Product&amp;gt; indexQuery = Product.find.query();
    indexQuery.setBuilder(QueryBuilders.multiMatchQuery(keyword, "title", "description"));    
     // Scala
    val indexQuery = new IndexQuery[Product]()
      .withBuilder(QueryBuilders.multiMatchQuery(keyword, "title", "description"))</pre>
<p id="e-Mrjz">Finally, in our controller class, <code>Products</code>, we invoked the appropriate product manager methods for the creation and search actions:</p>
<pre id="e-dCjA">// Java
    @BodyParser.Of(BodyParser.Json.class)
    public static Result create() {
     ..
     product.index();
     ..
    }
     @BodyParser.Of(BodyParser.Json.class)
    public static Result search() {
        .. 
        Product.doSearch(search.getKeyword());
        ..
    }    
     // Scala
    def create = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
   ..
      ProductManager.index(p)
      ..
    }
     def search = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
      ..
      val results = ProductManager.doSearch(search.keyword)
      ..
    }</pre>
<p id="e-Kgm3">Upon the web application's start up or reload, you will be able to see logging information regarding the initialization of the play2-elasticsearch plugin:</p>
<pre id="e-BGlx">&lt;span class="strong"&gt;&lt;strong&gt;[info] application - Elasticsearch : Settings  {client.transport.sniff=false, cluster.name=elasticsearch}&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[info] application - ElasticSearch : Starting in Client Mode&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[info] application - ElasticSearch : Client - Host: 192.168.59.103 Port: 9300&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[info] application - ElasticSearch : Started in Client Mode&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[info] application - ElasticSearch : Plugin has started&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;[info] play - Application started (Dev)&lt;/strong&gt;&lt;/span&gt;</pre>

<h1 id="e-yvD4">Implementing token authentication using JWT</h1>
<p id="e-b2ba">In this recipe, we integrate the widely-used user authentication strategy, Token authentication, with authenticate requests to protected Play actions and endpoints. We will use the open source library, <strong>nimbus-jose-jwt</strong>, by Connect2Id to sign-in and verify JWT for successful user logins.</p>
<p id="e-Pano">Subsequent requests to other protected endpoints and actions will now only require the JWT to be added to the request header using the authorization header. Signed JWTs will, however, have a prescribed expiration date and we will ensure that we validate this for each JWT signed request.</p>
<h3 id="e-nNaf">Note</h3>
<p id="e-wlqq">More information about Connect2id and nimbus-jose-jwt can be found here:</p>
<p id="e-gg7U"><a href="http://connect2id.com/products/nimbus-jose-jwt">http://connect2id.com/products/nimbus-jose-jwt</a></p>
<p id="e-Pxtd">More information about JWT is available here:</p>
<p id="e-zYSh"><a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html">http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html</a></p>
<h2 id="e-QKKv">How to do it…</h2>
<p id="e-BcON">For Java, we need to perform the following steps:</p>
<ol id="e-RebE">
<li id="e-EsGO">Run the <code>foo_java</code> application with Hot-Reloading enabled:<pre id="e-iAlJ">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-lDjL">Add the <code>nimbus-jose-jwt</code> dependency in <code>build.sbt</code>:<pre id="e-wDwg">libraryDependencies ++= Seq(
      "com.nimbusds" % "nimbus-jose-jwt" % "3.8.2"
    )</pre>
</li>
<li id="e-ekuV">Using <code>activator</code>, generate a new application secret, as follows:<pre id="e-OkTZ">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator play-generate-secret&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Loading project definition from /Users/ginduc/Developer/workspace/bitbucket/Play2.0CookbookRecipes/Ch06/foo_java/project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Set current project to foo_java (in build file:/Users/ginduc/Developer/workspace/bitbucket/Play2.0CookbookRecipes/Ch06/foo_java/)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Generated new secret: DDqEUkPssmdHOL=U`XMANZAPYG4fUYA5QwGtK49[PmUh2kAH/IpHuHuLIuNgv_o_&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 0 s, completed 02 24, 15 11:44:42 AM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-jPGO">Add the required configuration parameters to <code>conf/application.conf</code> using the generated secret from the previous step as the value for <code>jwt.sharedSecret</code>. As for issuer and audience, based on the JWT spec, the issuer is the principal issuing the token and the audience is the intended recipient of the token:<pre id="e-tgzV">jwt.sharedSecret = "DDqEUkPssmdHOL=U`XMANZAPYG4fUYA5QwGtK49[PmUh2kAH/IpHuHuLIuNgv_o_"
    jwt.issuer=&amp;lt;YOUR_ISSUER&amp;gt;
    jwt.expiryInSecs=600
    jwt.audience=&amp;lt;YOUR_AUDIENCE&amp;gt;</pre>
</li>
<li id="e-WjE4">Create the JWT Plugin class in <code>app/plugins/JWTPlugin.java</code>:<pre id="e-MaiU">package plugins;
     import com.nimbusds.jose.JWSAlgorithm;
    import com.nimbusds.jose.JWSHeader;
    import com.nimbusds.jose.crypto.MACSigner;
    import com.nimbusds.jose.crypto.MACVerifier;
    import com.nimbusds.jwt.JWTClaimsSet;
    import com.nimbusds.jwt.SignedJWT;
    import play.Application;
    import play.Logger;
    import play.Plugin;
    import java.util.Date;
     public class JWTPlugin extends Plugin {
        final private String tokenPrefix = "Bearer ";
         private String issuer;
        private String sharedSecret;
        private Integer expiryTime;
        private String audience;
        private JWSHeader algorithm;
        private MACSigner signer;
        private MACVerifier verifier;
         public JWTPlugin(Application app) {
            super();
             issuer = app.configuration().getString("jwt.issuer");
            sharedSecret = app.configuration().getString("jwt.sharedSecret");
            expiryTime = app.configuration().getInt("jwt.expiryInSecs");
            audience = app.configuration().getString("jwt.audience");
        }
         public void onStart() {
            algorithm = new JWSHeader(JWSAlgorithm.HS256);
            signer = new MACSigner(sharedSecret);
            verifier = new MACVerifier(sharedSecret);
        }
         public void onStop() {
            algorithm = null;
            signer = null;
            verifier = null;
        }
         public boolean verify(String token) {
            try {
                final JWTClaimsSet payload = decode(token);
                 // Check expiration date
                if (!new Date().before(payload.getExpirationTime())) {
                    Logger.error("Token expired: " + payload.getExpirationTime());
                    return false;
                }
                 // Match Issuer
                if (!payload.getIssuer().equals(issuer)) {
                    Logger.error("Issuer mismatch: " + payload.getIssuer());
                    return false;
                }
                 // Match Audience
                if (payload.getAudience() != null &amp;amp;&amp;amp; payload.getAudience().size() &amp;gt; 0) {
                    if (!payload.getAudience().get(0).equals(audience)) {
                        Logger.error("Audience mismatch: " + payload.getAudience().get(0));
                        return false;
                    }
                } else {
                    Logger.error("Audience is required");
                    return false;
                }
                 return true;
            } catch(Exception e) {
                return false;
            }
        }
         public JWTClaimsSet decode(String token) throws Exception {
            Logger.debug("Verifying: " + token.substring(tokenPrefix.length()));
            SignedJWT signedJWT = SignedJWT.parse(token.substring(tokenPrefix.length()));
             if (!signedJWT.verify(verifier)) {
                throw new IllegalArgumentException("Json Web Token cannot be verified!");
            }
             return (JWTClaimsSet) signedJWT.getJWTClaimsSet();
        }
         public String sign(String userInfo) throws Exception {
            final JWTClaimsSet claimsSet = new JWTClaimsSet();
            claimsSet.setSubject(userInfo);
            claimsSet.setIssueTime(new Date());
            claimsSet.setIssuer(issuer);
            claimsSet.setAudience(audience);
            claimsSet.setExpirationTime(
                new Date(claimsSet.getIssueTime().getTime() + (expiryTime * 1000))
            );
             SignedJWT signedJWT = new SignedJWT(algorithm, claimsSet);
            signedJWT.sign(signer);
            return signedJWT.serialize();
        }
         public boolean enabled() {
            return true;
        }
    }</pre>
</li>
<li id="e-b6VY">Initialize the JWT Plugin in <code>conf/play.plugins</code>:<pre id="e-QPRK">10099:plugins.JWTPlugin</pre>
</li>
<li id="e-qifV">Create an action class inheriting from the <code>Simple Action</code> class that we will use to secure actions with JWT in <code>app/controllers/JWTSigned.java</code>:<pre id="e-C9rr">package controllers;
     import play.*;
    import play.mvc.*;
    import play.libs.*;
    import play.libs.F.*;
    import plugins.JWTPlugin;
     public class JWTSigned extends play.mvc.Action.Simple {
        private static final String AUTHORIZATION = "Authorization";
        private static final String WWW_AUTHENTICATE = "WWW-Authenticate";
        private static final String APP_REALM = "Protected Realm";
        private static final String AUTH_HEADER_PREFIX = "Bearer ";
        private static JWTPlugin jwt = Play.application().plugin(JWTPlugin.class);
         public F.Promise&amp;lt;Result&amp;gt; call(Http.Context ctx) throws Throwable {
            try {
                final String authHeader = ctx.request().getHeader(AUTHORIZATION);
                 if (authHeader != null &amp;amp;&amp;amp; authHeader.startsWith(AUTH_HEADER_PREFIX)) {
                    if (jwt.verify(authHeader)) {
                        return delegate.call(ctx);
                    }
                } else {
                    return Promise.pure((Result) unauthorized());
                }
            } catch (Exception e) {
                Logger.error("Error during session authentication: " + e);
            }
             ctx.response().setHeader(WWW_AUTHENTICATE, APP_REALM);
            return Promise.pure((Result) forbidden());
        }
    }</pre>
</li>
<li id="e-cvg7">Create our test actions for logging in and token signing, and another action to be secured with <code>JWTSigned</code> in <code>app/controllers/Application.java</code>:<pre id="e-yaz3">package controllers;
     import play.*;
    import play.data.Form;
    import play.mvc.*;
     import plugins.JWTPlugin;
    import views.html.*;
     import java.util.HashMap;
    import java.util.Map;
     import static play.libs.Json.toJson;
     public class Application extends Controller {
        private static JWTPlugin jwt = Play.application().plugin(JWTPlugin.class);
         public static Result index() {
            return ok(index.render("Your new application is ready."));
        }
         @With(JWTSigned.class)
        public static Result adminOnly() {
            return ok("");
        }
         @BodyParser.Of(BodyParser.Json.class)
        public static Result auth() {
            try {
                Form&amp;lt;Login&amp;gt; form = Form.form(Login.class).bindFromRequest();
                Login login = form.get();
                if (login.getUsername().equals("ned") &amp;amp;&amp;amp; login.getPassword().equals("flanders")) {
                    final String token = jwt.sign(login.getUsername());
                    final Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
                    map.put("token", token);
                    return ok(toJson(map));
                } else {
                    return forbidden();
                }
             } catch (Exception e) {
                return internalServerError(e.getMessage());
            }
        }
    }</pre>
</li>
<li id="e-qd1V">We also need to create the <code>Login</code> model used during user authentication in <code>app/controllers/Login.java</code>:<pre id="e-lxWH">package controllers;
     public class Login {
        private String username;
        private String password;
         public Login() {}
        public Login(String username, String password) {
            this.username = username;
            this.password = password;
        }
         public String getUsername() {
            return username;
        }
         public void setUsername(String username) {
            this.username = username;
        }
         public String getPassword() {
            return password;
        }
         public void setPassword(String password) {
            this.password = password;
        }
    }</pre>
</li>
<li id="e-pkMi">Finally, we add the necessary entries to <code>conf/routes</code> for our new actions:<pre id="e-KfPd">POST    /user/auth           controllers.Application.auth
    GET     /admin               controllers.Application.adminOnly</pre>
</li>
<li id="e-gi10">Using <code>curl</code>, let's verify that the <code>/admin</code> route is gated and secured by <code>JWTSigned</code>:<pre id="e-wRzV">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/admin&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /admin HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 401 Unauthorized&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; WWW-Authenticate: Basic realm="Protected Realm"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-Oh51">Next, let's sign in and make a note of the returned token in the response body:<pre id="e-Aoy3">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/user/auth --header "Content-type: application/json" -d '{"username":"ned", "password":"flanders"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /user/auth HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 41&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 41 out of 41 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 181&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"token":"eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-gS8b">Finally, let's request the <code>/admin</code> route again, but this time, by adding the signed token using the authorization header, prefixed with <code>Bearer</code>:<pre id="e-PO6q">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/admin --header "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /admin HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-iK1t">We can also verify that the JWTPlugin handles token expiration correctly by running the previous request again after the expiration is set in the token, and it should result in something like this:<pre id="e-vrJg">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/admin --header "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /admin HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 403 Forbidden&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<p id="e-Tden">For Scala, we need to perform the following steps:</p>
<ol id="e-QneD">
<li id="e-XOew">Run the <code>foo_scala</code> application with Hot-Reloading enabled:<pre id="e-JWI1">&lt;span class="strong"&gt;&lt;strong&gt;    activator "~run"&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-hl15">Add the <code>nimbus-jose-jwt</code> dependency to <code>build.sbt</code>:<pre id="e-Gh8Z">libraryDependencies ++= Seq(
      "com.nimbusds" % "nimbus-jose-jwt" % "3.8.2"
     )</pre>
</li>
<li id="e-YgRA">Using <code>activator</code>, generate a new application secret as follows:<pre id="e-Fte9">&lt;span class="strong"&gt;&lt;strong&gt;    $ activator play-generate-secret&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Loading project definition from /Users/ginduc/Developer/workspace/bitbucket/Play2.0CookbookRecipes/Ch06/foo_scala/project&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Set current project to foo_scala (in build file:/Users/ginduc/Developer/workspace/bitbucket/Play2.0CookbookRecipes/Ch06/foo_scala/)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [info] Generated new secret: LKQhArck[KCAFcEplWDeBSV^e@a1o6X&amp;gt;2SI_D3Q^X0h`eigla5ywm^k6E9z7Nx=p&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    [success] Total time: 0 s, completed 02 23, 15 10:32:56 PM&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-MiuN">Add the required configuration parameters to <code>conf/application.conf</code> using the generated secret from the previous step as the value for <code>jwt.sharedSecret</code>. As for the issuer and audience, based on the JWT spec, the issuer is the principal issuing the token and audience is the intended recipient of the token:<pre id="e-MVLM">jwt.sharedSecret = "LKQhArck[KCAFcEplWDeBSV^e@a1o6X&amp;gt;2SI_D3Q^X0h`eigla5ywm^k6E9z7Nx=p"
    jwt.issuer=&amp;lt;YOUR_ISSUER&amp;gt;
    jwt.expiryInSecs=600
    jwt.audience=&amp;lt;YOUR_AUDIENCE&amp;gt;</pre>
</li>
<li id="e-H88x">Create the JWT Plugin class in <code>app/plugins/JWTPlugin.scala</code>:<pre id="e-CgNs">package plugins
     import java.util.Date
    import com.nimbusds.jose.crypto.{MACVerifier, MACSigner}
    import com.nimbusds.jose.{JWSAlgorithm, JWSHeader}
    import com.nimbusds.jwt.{JWTClaimsSet, SignedJWT}
    import play.api.{Logger, Play, Application, Plugin}
    import play.api.Play.current
     class JWTPlugin(app: Application) extends Plugin {
      val tokenPrefix = "Bearer "
       private val issuer = Play.application.configuration.getString("jwt.issuer").getOrElse("jwt")
      private val sharedSecret = Play.application.configuration.getString("jwt.sharedSecret")
    .getOrElse(throw new IllegalStateException("JWT Shared Secret is required!"))
      private val expiryTime = Play.application.configuration.getInt("jwt.expiryInSecs").getOrElse(60 * 60 * 24)
      private val audience = Play.application.configuration.getString("jwt.audience").getOrElse("jwt")
      private val algorithm = new JWSHeader(JWSAlgorithm.HS256)
      
      private lazy val signer: MACSigner = new MACSigner(sharedSecret)
      private lazy val verifier: MACVerifier = new MACVerifier(sharedSecret)
       override def onStart() = {
        
       signer
        verifier
      }
       override def onStop() = {
        Logger.info("Shutting down plugin")
      }
       def verify(token: String): Boolean = {
        val payload = decode(token)
         // Check expiration date
        if (!new Date().before(payload.getExpirationTime)) {
          Logger.error("Token expired: " + payload.getExpirationTime)
          return false
        }
         // Match Issuer
        if (!payload.getIssuer.equals(issuer)) {
          Logger.error("Issuer mismatch: " + payload.getIssuer)
          return false
        }
         // Match Audience
        if (payload.getAudience != null &amp;amp;&amp;amp; payload.getAudience.size() &amp;gt; 0) {
          if (!payload.getAudience.get(0).equals(audience)) {
            Logger.error("Audience mismatch: " + payload.getAudience.get(0))
            return false
          }
        } else {
          Logger.error("Audience is required")
          return false
        }
        return true
      }
       def decode(token: String) = {
        val signedJWT = SignedJWT.parse(token.substring(tokenPrefix.length))
         if (!signedJWT.verify(verifier)) {
          throw new IllegalArgumentException("Json Web Token cannot be verified!")
        }
         signedJWT.getJWTClaimsSet
      }
       def sign(userInfo: String): String = {
        val claimsSet = new JWTClaimsSet()
        claimsSet.setSubject(userInfo)
        claimsSet.setIssueTime(new Date)
        claimsSet.setIssuer(issuer)
        claimsSet.setAudience(audience)
        claimsSet.setExpirationTime(
          new Date(claimsSet.getIssueTime.getTime + (expiryTime * 1000))
        )
         val signedJWT = new SignedJWT(algorithm, claimsSet)
        signedJWT.sign(signer)
        signedJWT.serialize()
      }
    override def enabled = true
    }</pre>
</li>
<li id="e-mECG">Initialize the JWTPlugin in <code>conf/play.plugins</code>:<pre id="e-rNji">10099:plugins.JWTPlugin</pre>
</li>
<li id="e-pvh0">Create an <code>ActionBuilder</code> class that we will use to secure actions with JWT in <code>app/controllers/JWTSigned.scala</code>:<pre id="e-yOGq">package controllers
     import play.api.Play
    import play.api.mvc.{Result, WrappedRequest, Request, ActionBuilder}
    import play.api.http.HeaderNames._
    import play.api.mvc.Results._
    import play.api.Play.current
    import plugins.JWTPlugin
    import scala.concurrent.Future
     class JWTSignedRequest[A](val jwt: String, request: Request[A]) extends WrappedRequest[A](request)
     object JWTSigned extends ActionBuilder[JWTSignedRequest] {
      private val jwt = Play.application.plugin[JWTPlugin].get
       def invokeBlock[A](req: Request[A], block: (JWTSignedRequest[A]) =&amp;gt; Future[Result]) = {
        req.headers.get(AUTHORIZATION) map { token =&amp;gt;
          if (jwt.verify(token)) {
            block(new JWTSignedRequest(token, req))
          } else {
            Future.successful(Forbidden)
          }
        } getOrElse {
          Future.successful(Unauthorized.withHeaders(WWW_AUTHENTICATE -&amp;gt; """Basic realm="Protected Realm""""))
        }
      }
    }</pre>
</li>
<li id="e-gZY9">Create test actions for logging in and token signing, and another action to be secured with <code>JWTSigned</code> in <code>app/controllers/Application.scala</code>:<pre id="e-yzbH">case class Login(username: String, password: String)
  
    private val jwt = Play.application.plugin[JWTPlugin].get
    implicit private val productWrites = Json.writes[Login]
    implicit private val productReads = Json.reads[Login]
     def adminOnly = JWTSigned {
      Ok("")
    }
     def auth = Action(BodyParsers.parse.json) { implicit request =&amp;gt;
      val post = request.body.validate[Login]
       post.fold(
        errors =&amp;gt; Unauthorized,
        u =&amp;gt; {
          if (u.username.equals("ned") &amp;amp;&amp;amp; u.password.equals("flanders")) {
             Ok(Json.obj("token" -&amp;gt; jwt.sign(u.username)))
          } else {
            Forbidden
          }
        }
      )
    }</pre>
</li>
<li id="e-SRc1">Finally, we add the necessary entries to <code>conf/routes</code> for our new actions:<pre id="e-ytGm">POST    /user/auth           controllers.Application.auth
    GET     /admin               controllers.Application.adminOnly</pre>
</li>
<li id="e-QwHG">Using <code>curl</code>, let's verify that the <code>/admin</code> route is gated and secured by <code>JWTSigned</code>:<pre id="e-i2n1">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/admin&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /admin HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 401 Unauthorized&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; WWW-Authenticate: Basic realm="Protected Realm"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-UKFJ">Next, let's sign in and make a note of the returned token in the response body:<pre id="e-gVxS">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/user/auth --header "Content-type: application/json" -d '{"username":"ned", "password":"flanders"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; POST /user/auth HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-type: application/json&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Content-Length: 41&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * upload completely sent off: 41 out of 41 bytes&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: application/json; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 181&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"token":"eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc"}%&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-YpqY">Finally, let's request the <code>/admin</code> route again, but this time, adding the signed token using the authorization header, prefixed with <code>Bearer</code>:<pre id="e-sgbO">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/admin --header "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /admin HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 200 OK&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Type: text/plain; charset=utf-8&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
<li id="e-aU0I">We can also verify that the JWTPlugin handles token expiration correctly by running the previous request again after the expiration set in the token, and should result in something like this:<pre id="e-s0Dg">&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/admin --header "Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /admin HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Authorization: Bearer eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDM0NjAsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDM0MDB9.No2skaVfGeERDY6yEMJV8KiRddZsZEcW5BAH2vw99Xc&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 403 Forbidden&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</li>
</ol>
<h2 id="e-GzQD">How it works…</h2>
<p id="e-P4zq">In this recipe, we implemented the signing and verification of JWT for the purpose of securing Play actions with token authentication.</p>
<p id="e-EoMB">We created a Play plugin, <code>JWTPlugin</code>, which will load the configurations from the <code>conf/application.conf</code> file and also contain method definitions for signing, decoding, and verifying JWTs using Connect2id's nimbus-jose-jwt library:</p>
<pre id="e-ObXI">// Java 
    public JWTPlugin(Application app) {
        super();
        issuer = app.configuration().getString("jwt.issuer");
        sharedSecret = app.configuration().getString("jwt.sharedSecret");
        expiryTime = app.configuration().getInt("jwt.expiryInSecs");
        audience = app.configuration().getString("jwt.audience");
    }
     public void onStart() {
        algorithm = new JWSHeader(JWSAlgorithm.HS256);
        signer = new MACSigner(sharedSecret);
        verifier = new MACVerifier(sharedSecret);
    }    
     // Scala
    private val issuer = Play.application.configuration.getString("jwt.issuer").getOrElse("jwt")
    private val sharedSecret = Play.application.configuration.getString("jwt.sharedSecret")
    .getOrElse(throw new IllegalStateException("JWT Shared Secret is required!"))
    private val expiryTime = Play.application.configuration.getInt("jwt.expiryInSecs").getOrElse(60 * 60 * 24)
    private val audience = Play.application.configuration.getString("jwt.audience").getOrElse("jwt")
    private val algorithm = new JWSHeader(JWSAlgorithm.HS256)
    private var signer: MACSigner = null
    private var verifier: MACVerifier = null
     override def onStart() = {
      signer = new MACSigner(sharedSecret)
      verifier = new MACVerifier(sharedSecret)
    }</pre>
<p id="e-fkoh">In the preceding code, you will notice that we are utilizing HMAC using SHA-256 as the default hash algorithm.</p>
<p id="e-SNRe">For Java, add the following code:</p>
<pre id="e-F8hU">// Java
    algorithm = new JWSHeader(JWSAlgorithm.HS256);</pre>
<p id="e-cOPg">For Scala, add the following code:</p>
<pre id="e-tbsz">// Scala
    private val algorithm = new JWSHeader(JWSAlgorithm.HS256)</pre>
<p id="e-R8ef">For signing, we build the Claim Set, which is the standard set of token metadata according to the JWT spec: you can refer to the following link:</p>
<p id="e-eigg"><a href="http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims">http://self-issued.info/docs/draft-ietf-oauth-json-web-token.html#Claims</a></p>
<p id="e-kLSW">With the appropriate parameter values and adding the user information as the claim subject, we then sign and serialize it to a <code>String</code>:</p>
<pre id="e-eQm6">// Java 
    public String sign(String userInfo) throws Exception {
        final JWTClaimsSet claimsSet = new JWTClaimsSet();
        claimsSet.setSubject(userInfo);
        claimsSet.setIssueTime(new Date());
        claimsSet.setIssuer(issuer);
        claimsSet.setAudience(audience);
        claimsSet.setExpirationTime(
            new Date(claimsSet.getIssueTime().getTime() + (expiryTime * 1000))
        );
         SignedJWT signedJWT = new SignedJWT(algorithm, claimsSet);
        signedJWT.sign(signer);
        return signedJWT.serialize();
    }    
     // Scala
    def sign(userInfo: String): String = {
      val claimsSet = new JWTClaimsSet()
      claimsSet.setSubject(userInfo)
      claimsSet.setIssueTime(new Date)
      claimsSet.setIssuer(issuer)
      claimsSet.setAudience(audience)
      claimsSet.setExpirationTime(
        new Date(claimsSet.getIssueTime.getTime + (expiryTime * 1000))
      )
       val signedJWT = new SignedJWT(algorithm, claimsSet)
      signedJWT.sign(signer)
      signedJWT.serialize()
    }</pre>
<p id="e-ghin">To verify, we get the passed token decoded and verified and then proceed to verifying parts of the Claim Set. It returns the Boolean value <code>true</code> only when the token has passed all verification tests:</p>
<pre id="e-A3c5">// Java
    public boolean verify(String token) {
        try {
            final JWTClaimsSet payload = decode(token);
             // Check expiration date
            if (!new Date().before(payload.getExpirationTime())) {
                Logger.error("Token expired: " + payload.getExpirationTime());
                return false;
            }
             // Match Issuer
            if (!payload.getIssuer().equals(issuer)) {
                Logger.error("Issuer mismatch: " + payload.getIssuer());
                return false;
            }
             // Match Audience
            if (payload.getAudience() != null &amp;amp;&amp;amp; payload.getAudience().size() &amp;gt; 0) {
                if (!payload.getAudience().get(0).equals(audience)) {
                    Logger.error("Audience mismatch: " + payload.getAudience().get(0));
                    return false;
                }
            } else {
                Logger.error("Audience is required");
                return false;
            }
             return true;
        } catch(Exception e) {
            return false;
        }
    }
     // Scala
    def verify(token: String): Boolean = {
      val payload = decode(token)
       // Check expiration date
      if (!new Date().before(payload.getExpirationTime)) {
        Logger.error("Token expired: " + payload.getExpirationTime)
        return false
      }
       // Match Issuer
      if (!payload.getIssuer.equals(issuer)) {
        Logger.error("Issuer mismatch: " + payload.getIssuer)
        return false
      }
       // Match Audience
      if (payload.getAudience != null &amp;amp;&amp;amp; payload.getAudience.size() &amp;gt; 0) {
        if (!payload.getAudience.get(0).equals(audience)) {
          Logger.error("Audience mismatch: " + payload.getAudience.get(0))
          return false
        }
      } else {
        Logger.error("Audience is required")
        return false
      }
       return true
    }</pre>
<p id="e-Qpf6">We then created a <code>Simple Action</code> / <code>Action Builder</code> class that will do the actual JWT verification:</p>
<pre id="e-F19H">// Java 
    public F.Promise&amp;lt;Result&amp;gt; call(Http.Context ctx) throws Throwable {
        try {
            final String authHeader = ctx.request().getHeader(AUTHORIZATION);
             if (authHeader != null &amp;amp;&amp;amp; authHeader.startsWith(AUTH_HEADER_PREFIX)) {
                if (jwt.verify(authHeader)) {
                    return delegate.call(ctx);
                }
            }
        } catch (Exception e) {
            Logger.error("Error during session authentication: " + e);
        }
         ctx.response().setHeader(WWW_AUTHENTICATE, APP_REALM);
        return Promise.pure((Result) forbidden());
    }
     // Scala
    def invokeBlock[A](req: Request[A], block: (JWTSignedRequest[A]) =&amp;gt; Future[Result]) = {
      req.headers.get(AUTHORIZATION) map { token =&amp;gt;
        if (jwt.verify(token)) {
          block(new JWTSignedRequest(token, req))
        } else {
          Future.successful(Forbidden)
        }
      } getOrElse {
        Future.successful(Unauthorized.withHeaders(WWW_AUTHENTICATE -&amp;gt; """Basic realm="Protected Realm""""))
      }
    }</pre>
<p id="e-SHEc">The preceding code will only invoke the next request block if the token passes the verification test. It will return an <strong>Http Status Forbidden</strong> error for unsuccessful verifications and an <strong>Http Status Unauthorized</strong> error for requests that do not have the authorization header set.</p>
<p id="e-Jfnv">We are now able to secure Play controller actions using the JWTSigned <code>ActionBuilder</code> class:</p>
<pre id="e-cqVO">// Java 
    @With(JWTSigned.class)
    public static Result adminOnly() {
        return ok("");
    }
     // Scala
    def adminOnly = JWTSigned {
      Ok("")
    }</pre>
<p id="e-zRFn">Finally, what we have is a Play action returning serialized, signed JWTs, and an action utilizing the JWTSigned <code>ActionBuilder</code> class that secures the action from unauthenticated and unauthorized requests:</p>
<pre id="e-fUYj">&lt;span class="strong"&gt;&lt;strong&gt;    # Signing    &lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    $ curl http://localhost:9000/user/auth --header "Content-type: application/json" -d '{"username":"ned", "password":"flanders"}'&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;{"token":"eyJhbGciOiJIUzI1NiJ9.eyJleHAiOjE0MjQ3MDUzOTgsInN1YiI6Im5lZCIsImF1ZCI6ImFwaWNsaWVudHMiLCJpc3MiOiJwMmMiLCJpYXQiOjE0MjQ3MDUzMzh9.uE5GNQv2uXQh29sHhy_Jbg9omDhQMrnW1tjqFBrUwSs"}%&lt;/strong&gt;&lt;/span&gt;
 &lt;span class="strong"&gt;&lt;strong&gt;    # Verifying&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    $ curl -v http://localhost:9000/admin&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Hostname was NOT found in DNS cache&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    *   Trying ::1...&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connected to localhost (::1) port 9000 (#0)&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; GET /admin HTTP/1.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; User-Agent: curl/7.37.1&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Host: localhost:9000&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt; Accept: */*&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;gt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; HTTP/1.1 401 Unauthorized&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; WWW-Authenticate: Basic realm="Protected Realm"&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt; Content-Length: 0&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    &amp;lt;&lt;/strong&gt;&lt;/span&gt;
&lt;span class="strong"&gt;&lt;strong&gt;    * Connection #0 to host localhost left intact&lt;/strong&gt;&lt;/span&gt;</pre>
</body></html>