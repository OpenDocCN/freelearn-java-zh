["```java\n    switch(state){\n      case Idle:\n        forward = false;\n        backward = false;\n      break;\n    ```", "```java\n    case Follow:\n      if(target != null){\n        Vector3f dirToTarget = target.getWorldTranslation().subtract(spatial.getWorldTranslation());\n        dirToTarget.y = 0;\n        dirToTarget.normalizeLocal();\n        viewDirection.set(dirToTarget);\n    ```", "```java\n    if (distance > 20f){\n      state = State.Idle;\n      target = null;\n    } else if(distance > 5f){\n      forward = true;\n      backward = false;\n    } else if (distance < 3f){\n      forward = false;\n      backward = true;\n    } else {\n      forward = false;\n      backward = false;\n    }\n    ```", "```java\n    Vector3f modelForwardDir = spatial.getWorldRotation().mult(Vector3f.UNIT_Z);\n    ```", "```java\n    if (forward) {\n      walkDirection.addLocal(modelForwardDir.mult(3));\n    } else if (backward) {\n      walkDirection.addLocal(modelForwardDir.negate().multLocal(3));\n    }\n    physicsCharacter.setWalkDirection(walkDirection);\n    ```", "```java\n    physicsCharacter.setViewDirection(viewDirection);\n    ```", "```java\naiCharacter.addControl(new AnimationManagerControl());\n```", "```java\nif (forward) {\n            ... spatial.getControl(AnimationManagerControl.class).setAnimation(AnimationManagerControl.Animation.Walk);\n  } else if (backward) {\n            ... spatial.getControl(AnimationManagerControl.class).setAnimation(AnimationManagerControl.Animation.Walk);\n  } else {\nspatial.getControl(AnimationManagerControl.class).setAnimation(AnimationManagerControl.Animation.Idle);\n}\n```", "```java\nBulletAppState bulletAppState = new BulletAppState();\nstateManager.attach(bulletAppState);\n```", "```java\nbulletAppState.getPhysicsSpace().add(jaime);\nrootNode.attachChild(jaime);\n```", "```java\njaime.addControl(new AIControl());\n```", "```java\nCameraNode camNode = new CameraNode(\"CamNode\", cam);\ncamNode.setControlDir(CameraControl.ControlDirection.CameraToSpatial);\nrootNode.attachChild(camNode);\n```", "```java\njaime.getControl(AIControl.class).setState(AIControl.State.Follow);\njaime.getControl(AIControl.class).setTarget(camNode);\n```", "```java\n    rayDirection.set(viewDirection);\n    aimDirection.fromAngleAxis(angleX, Vector3f.UNIT_Y);\n    aimDirection.multLocal(rayDirection);\n    ```", "```java\n    CollisionResults col = new CollisionResults();\n    for(Spatial s: targetableObjects){\n      s.collideWith(ray, col);\n    }\n    ```", "```java\n    if(col.size() > 0){\n      target = col.getClosestCollision().getGeometry();\n      foundTarget = true;\n      break;\n    }\n    ```", "```java\n    case Idle:\n      if(!targetableObjects.isEmpty() && sense()){\n        state = State.Follow;\n      }\n    break;\n    ```", "```java\n    for(float x = -angle; x < angle; x+= FastMath.QUARTER_PI * 0.1f){\n    if(debug && sightLines[i] != null){\n                    ((Node)getSpatial().getParent()).detachChild(sightLines[i]);\n    }\n    ...Our sight code here...\n    if(debug){\n      Geometry line = makeDebugLine(ray);\n      sightLines[i++] = line;     ((Node)getSpatial().getParent()).attachChild(line);\n    }\n    ```", "```java\n    private Geometry makeDebugLine(Ray r){\n      Line l = new Line(r.getOrigin(), r.getOrigin().add(r.getDirection().mult(sightRange)));\n      Geometry line = new Geometry(\"\", l);\n      line.setMaterial(TestAiControl.lineMat);\n      return line;\n    }\n    ```", "```java\n    float movementSpeed = lastPosition.distance(spatial.getWorldTranslation()) / tpf;\n    ```", "```java\n    movementSpeed = Math.min(movementSpeed, maxSpeed);\n    noiseEmitted = movementSpeed / maxSpeed;\n    ```", "```java\n    float distance = s.getWorldTranslation().distance(spatial.getWorldTranslation());\n    ```", "```java\n    float distanceFactor = 1f - Math.min(distance, hearingRange) / hearingRange;\n    float soundHeard = distanceFactor * noiseEmitted;\n    ```", "```java\n    public void setEnabled(boolean enabled) {\n      if(enabled && !this.enabled){\n        stateEnter();\n      }else if(!enabled && this.enabled){\n        stateExit();\n      }\n      this.enabled = enabled;\n    }\n    ```", "```java\n    if(aiControl.getTarget() != null){\n      this.setEnabled(false);\n      Vector3f direction = aiControl.getTarget().getWorldTranslation().subtract(spatial.getWorldTranslation());\n      this.spatial.getControl(BetterCharacterControl.class).setViewDirection(direction);\n      this.spatial.getControl(AttackState.class).setEnabled(true);\n    }\n    ```", "```java\n    else if(moveTarget == null || this.spatial.getWorldTranslation().distance(moveTarget) < 1f){\n      float x = (FastMath.nextRandomFloat() - 0.5f) * 2f;\n      moveTarget = new Vector3f(x, 0, (1f - FastMath.abs(x)) - 0.5f).multLocal(5f);\n      moveTarget.addLocal(this.spatial.getWorldTranslation());\n    }\n    ```", "```java\n    else {\n      Vector3f direction = moveTarget.subtract(this.spatial.getWorldTranslation()).normalizeLocal();\n      aiControl.move(direction, true);\n    }\n    ```", "```java\n    aiControl.move(Vector3f.ZERO, false);\n    ```", "```java\n    clip = 5;\n    ammo = 10;\n    ```", "```java\n    if(clip == 0){\n      if(ammo == 0){\n        this.setEnabled(false);\n      this.spatial.getControl(RetreatState.class).setEnabled(true);\n      }\n    ```", "```java\n    else {\n      clip += 5;\n      ammo -= 5;\n      fireCooldown = 5f;\n    }\n    ```", "```java\n    else if(aiControl.getTarget() == null){\n      this.setEnabled(false);\n      this.spatial.getControl(PatrolState.class).setEnabled(true);\n    }\n    ```", "```java\n    else if(fireCooldown <= 0f && aiControl.getSpatial().getWorldTranslation().distance(aiControl.getTarget().getWorldTranslation()) < fireDistance){\n      clip--;\n      fireCooldown = 2f;\n    }\n    ```", "```java\n    else if(fireCooldown > 0f){\n      fireCooldown -= tpf;\n    }\n    ```", "```java\n    Vector3f worldTranslation = this.spatial.getWorldTranslation();\n    if (fleeTimer > 0f && aiControl.getTarget() != null) {\n      if (moveTarget == null || worldTranslation.distance(moveTarget) < 1f) {\n        moveTarget = worldTranslation.subtract(aiControl.getTarget().getWorldTranslation());\n        moveTarget.addLocal(worldTranslation);\n      }\n      fleeTimer -= tpf;\n      Vector3f direction = moveTarget.subtract(worldTranslation).normalizeLocal();\n      aiControl.move(direction, true);\n    }\n    ```", "```java\n    for(CoverPoint cover: availableCovers){\n      if(aiControl.getTarget() != null){\n        Vector3f directionToTarget = cover.getSpatial().getWorldTranslation().add(aiControl.getTarget().getWorldTranslation()).normalizeLocal();\n                    if(cover.getCoverDirection().dot(directionToTarget) > 0){\n          targetCover = cover;\n          break;\n        }\n      }\n    }\n    ```", "```java\n    public PathfinderThread(NavMesh navMesh) {\n      pathfinder = new NavMeshPathfinder(navMesh);\n      this.setDaemon(true);\n    }\n    ```", "```java\n    if (target != null) {\n      pathfinding = true;\n      pathfinder.setPosition(getSpatial().getWorldTranslation());\n      boolean success = pathfinder.computePath(target);\n      if (success) {\n        target = null;\n      }\n      pathfinding = false;\n    }\n    ```", "```java\n    pathfinder.setPosition(getSpatial().getWorldTranslation());\n    ```", "```java\n    Thread.sleep(1000);\n    ```", "```java\n    public NavMeshNavigationControl(Node world) {\n      Mesh mesh = ((Geometry) world.getChild(\"NavMesh\")).getMesh();\n      NavMesh navMesh = new NavMesh(mesh);\n      pathfinderThread = new PathfinderThread(navMesh);\n      pathfinderThread.start();\n    }\n    ```", "```java\n    public void moveTo(Vector3f target) {\n      pathfinderThread.setTarget(target);\n    }\n    ```", "```java\n    Vector2f aiPosition = new Vector2f(spatialPosition.x, spatialPosition.z);\n    Vector2f waypoint2D = new Vector2f(waypointPosition.x, waypointPosition.z);\n    float distance = aiPosition.distance(waypoint2D);\n    ```", "```java\n    if(distance > 1f){\n      Vector2f direction = waypoint2D.subtract(aiPosition);\n      direction.mult(tpf);\n      spatial.getControl(GameCharacterControl.class).setViewDirection(new Vector3f(direction.x, 0, direction.y).normalize());\n      spatial.getControl(GameCharacterControl.class).onAction(\"MoveForward\", true, 1);\n    }\n    ```", "```java\n    else if (!pathfinderThread.isPathfinding() && pathfinderThread.pathfinder.getNextWaypoint() != null && !pathfinderThread.pathfinder.isAtGoalWaypoint() ){\n      pathfinderThread.pathfinder.goToNextWaypoint();\n      waypointPosition = new Vector3f(pathfinderThread.pathfinder.getWaypointPosition());\n    }\n    ```", "```java\n    Vector3f direction = resource.getWorldTranslation().subtract(this.spatial.getWorldTranslation());\n    if(direction.length() > 1f){\n      direction.normalizeLocal();\n      aiControl.move(direction, true);\n    } else {\n      amountCarried = 10;\n    }\n    ```", "```java\n    aiControl.getAiManager().onFinishTask(this.getClass(), amountCarried);\n    amountCarried = 0;\n    ```", "```java\n    this.spatial.addControl(new GatherFoodState());\n    this.spatial.addControl(new GatherWoodState());\n    this.spatial.getControl(GatherFoodState.class).setEnabled(false);\n    this.spatial.getControl(GatherWoodState.class).setEnabled(false);\n    ```", "```java\n    public void setCurrentState(Class<? extends AIStateRTS> newState) {\n      if(this.currentState != null && this.currentState.getClass() != newState){\n        this.currentState.setEnabled(false);\n      }\n      this.currentState = state;\n      this.currentState.setEnabled(true);\n    }\n    ```", "```java\n    food -= foodConsumption * tpf;\n    food = Math.max(0, food);\n    timer-= tpf;\n    if(timer <= 0f){\n      evaluate();\n      timer = 5f;\n    }\n    ```", "```java\n    float foodRequirement = foodConsumption * 20f + minimumFoodStorage;\n    ```", "```java\n    float factorFood = 1f - (Math.min(food, foodRequirement)) / foodRequirement;\n    ```", "```java\n    int numWorkers = aiList.size();\n    int requiredFoodGatherers = (int) Math.round(numWorkers * factorFood);\n    int foodGatherers = workersByState(GatherFoodState.class);\n    ```", "```java\n    private int workersByState(Class<? extends AIStateRTS> state){\n      int amount = 0;\n      for(AIControl_RTS ai: aiList){\n        if(ai.getCurrentState() != null && ai.getCurrentState().getClass() == state){\n          amount++;\n        }\n      }\n      return amount;\n    }\n    ```", "```java\n    int foodGatherers = workersByState(GatherFoodState.class);\n    int toSet = requiredFoodGatherers – foodGatherers;\n    Class<? extends AIStateRTS> state = null;\n    if(toSet > 0){\n      state = GatherFoodState.class;\n    } else if (toSet < 0){\n      state = GatherWoodState.class;\n      toSet = -toSet;\n    }\n    ```", "```java\n    private boolean setWorkerState(Class<? extends AIStateRTS> state){\n      for(AIControl_RTS ai: aiList){\n        if(ai.getCurrentState() == null || ai.getCurrentState().getClass() != state){\n          ai.setCurrentState(state);\n          ((GatherResourceState)ai.getCurrentState()).setResource(resources.get(state));\n          return true;\n        }\n      }\n      return false;\n    }\n    ```", "```java\n    aiAppState.setResource(GatherFoodState.class, foodSpatial);\n    aiAppState.setResource(GatherWoodState.class, woodSpatial);\n    ```", "```java\n    private void pathfind() {\n      openList.add(startNode);\n      WaypointNode current;\n      while(!openList.isEmpty()) {\n        current = openList.get(0);\n        for (WaypointNode neighbor : current.getConnections()) {\n          if (!neighbor.isClosed()) {\n            if (!neighbor.isOpen()) {\n              openList.add(neighbor);\n              neighbor.setOpen(true);\n              setParent(current, neighbor);\n            } else if (current.getG() + neighbor.getPosition().distance(goalNode.getPosition()) < neighbor.getG()) { // new path is shorter\n              setParent(current, neighbor);\n            }\n          }\n        }\n          openList.remove(current);\n        current.setClosed(true);\n        if (goalNode.isClosed()) {\n          break;\n        }\n        // sort list\n        Collections.sort(openList, waypointComparator);\n      }\n      backtrack();\n    }\n    ```", "```java\n    openList.add(neighbor);\n    neighbor.setOpen(true);\n    neighbor.setParent(current);\n    ```", "```java\n    neighbor.setG(current.getG() + (int) (current.getPosition().distance(neighbor.getPosition()) * multiple));\n    ```", "```java\n    if(neighbor.getH() == 0){\n      neighbor.setH((int) (neighbor.getPosition().distance(goalNode.getPosition()) * multiple));\n    }\n    neighbor.updateF();\n    ```", "```java\n    private void backtrack() {\n      List<WaypointNode> path = new ArrayList<WaypointNode>();\n      path.add(goalNode);\n      WaypointNode parent = goalNode;\n      while (parent != null) {\n        parent = parent.getParent();\n        path.add(parent);\n      }\n    }\n    ```"]