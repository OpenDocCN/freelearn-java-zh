- en: Chapter 2. Basic Image Processing with ImageJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After following the instructions in the previous chapter, you should have a
    working and running installation of ImageJ. This chapter will deal with the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Supported image types in ImageJ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and saving images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing and obtaining pixel values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calibrating images for measurements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images in ImageJ
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ImageJ has a wide support for multiple common image formats such as JPEG, PNG,
    and TIFF. With the help of the **Bio-Formats** plugin, a wide range of proprietary
    image formats can also be loaded (for example, STK files [Metamorph], and LSM
    files [Zeiss]) as well as certain medical image formats (**Dicom**) and astronomy
    formats (**FITS**). The most recent version of Fiji comes with the Bio-Formats
    plugin and supports the files of almost all the major image formats.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will use some of the image files that are available from the sample
    images item in the **File** menu. These files are accessible from the Internet,
    so they require a functional Internet connection. The whole suite of images is
    also available as a single download from the ImageJ website. When using the Fiji
    distribution, the image set can be cached locally by going to **File** | **Open
    Samples** | **Cache Sample Images** from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by opening one of these sample images to demonstrate some of
    the features in ImageJ regarding images. To do so, start ImageJ as described in
    the previous chapter. Go to **File** | **Open Samples**, and select **Boats (356K)**.
    This image is taken from [http://imagej.nih.gov/ij/images/boats.gif](http://imagej.nih.gov/ij/images/boats.gif),
    and shows a picture of some boats in the harbor. The same image can also be loaded
    by going to **Import** | **URL** in the **File** menu and copying the earlier
    URL and pasting it in the field. The image should load and display in a new window
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images in ImageJ](img/Insert_image_B04909_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The title bar shows the filename (**boats.gif**). Just below the title bar
    is an information strip that shows the key parameters of the image: the size of
    the image (**720x576 pixels**), the image type (**8 bit**) and the file size (**405K**).
    The upcoming sections will provide more details on the basics of image types in
    ImageJ.'
  prefs: []
  type: TYPE_NORMAL
- en: Image types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An image is built up using pixels, where each pixel has a value that is encoded
    by bits. The number of bits determines the number of gray values or colors that
    can be represented. The upcoming sections will briefly explain the different image
    types that are supported by ImageJ.
  prefs: []
  type: TYPE_NORMAL
- en: Grayscale images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The boats image from the previous section was an 8-bit grayscale image, which
    means each pixel has a value between 0 (black) and 255 (white). Grayscale images
    can also be 16 bit (values between 0 and 65535) and 32 bit (floating-point images).
    The gray values of an image are represented in the **lookup table** (**LUT**).
    For 8-bit images, the LUT maps a value between 0 and 255 to an equal mix of red,
    green, and blue on your computer screen to display the gray level. For instance,
    a mid-gray level of 128 will be displayed on your screen as RGB value (128,128,128).
    It is also possible to change the mapping of the LUT to different scales for display.
    By changing the LUT, you can change the color appearance of the image on the screen.
    If you would like to give the grayscale image a green appearance, you can set
    the LUT to green. This will tell ImageJ to map the mid-gray value on your screen
    to the RGB value (0,128,0), thus appearing darker green. The same principles hold
    for 16-bit and 32-bit images, although they have more levels of gray that they
    can represent. These distinctions become important when creating macros and plugins,
    as certain processing steps can only be performed on 8-bit images.
  prefs: []
  type: TYPE_NORMAL
- en: Color images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Color images have generally two bit depths: **8-bit** and **24-bit** color.
    The 8-bit color image type is an indexed image, where the index determines the
    color of the image. An example of an 8-bit color image is the GIF file format.
    It stores up to 256 colors in its index, which results in smaller file sizes at
    the cost of a reduced number of colors. These images store a table of 256 red,
    green, and blue (RGB) values (also called the palette). Each entry in the table
    has an index that is referenced in the image for the pixels that use that specific
    color. This type is rare nowadays, as the reduced file size is no longer that
    critical due to larger storage capacity and faster Internet connections. By going
    to **Image** | **Color** | **Show LUT** from the ImageJ menu, you can view the
    palette or a list of indices from an indexed image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'RGB images such as JPG or PNG files are color images with 24 bits of information:
    8 bits each for the red, green, and blue channel. PNG files can have an additional
    8 bits for the transparency channel. Besides RGB images, it is also possible to
    generate images using different color spaces such as **L*a*b** and **HSB**. HSB
    images split the three components of a RGB image into hue, saturation, and brightness
    channels. The hue component can be compared to the color (blue, green, violet,
    and so on) of a pixel. Small hue values are used for red and orange, whereas medium
    values will represent cyan and blue. High hue values represent magenta and red.
    In this image, you can see the mapping of the hue channel to colors in an RGB
    image (the S and B channels were kept white):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color images](img/Insert_image_B04909_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the mapping of the hue channel is circular. Both pure white and pure
    black have the same color. They start at red and end at red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modifying the saturation makes the colors more or less *colored*. A small saturation
    value will make the colors look more gray, while a high saturation value will
    make the colors more pure. The following example shows a horizontal gradient for
    the hue channel and a vertical gradient for the saturation channel (the brightness
    channel was constant; the orange box delineates the different channels):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color images](img/Insert_image_B04909_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you move from the bottom of the lower panel to the top, the colors get more
    washed out, becoming less vibrant and, in this case, becoming white. The color
    of the upper part is determined by the brightness channel, which was white in
    this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing the brightness value makes the colors brighter or darker. High values
    leave the colors intact and bright, while low values make the colors appear more
    like black. The following image shows this effect, where the horizontal gradient
    is again the hue channel, while the vertical gradient is the brightness channel
    (the saturation channel was uniform white):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color images](img/Insert_image_B04909_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A real image will have combinations of gray values for hue, saturation, and
    brightness, which together result in the final color.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Converting between image types**'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to change a 16-bit image to an 8-bit image at the cost of losing
    pixel intensity information. To do so, go to **Image** | **Type** and select the
    image type you wish to convert to. However, not every conversion is possible.
    For example, an RGB image cannot be converted to an 8-bit grayscale image (directly)!
  prefs: []
  type: TYPE_NORMAL
- en: Stacks and hyperstacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The image types described in the previous sections were the basic image types
    that are supported by most graphical programs. However, ImageJ supports a different
    class of images that consists of multiple primitive image types combined into
    a single object: a **stack** or **hyperstack**. The extra dimensions have different
    names depending on the information they represent. When images are acquired in
    three dimensions by taking images at multiple levels of a volume, the resulting
    image is called a **Z-stack**. Each image in a Z-stack is referred to as a slice.
    When different colors are imaged, the stack is called a multichannel stack, and
    each image of the stack is called a channel. Finally, there is a stack that holds
    images that were acquired over time, where each image in the stack is called a
    frame. A hyperstack is a stack that contains images from more than three dimensions.
    For instance, a stack with slices, channels, and frames would be a 5D hyperstack.
    The following sections will briefly explain the different types of stacks and
    hyperstacks.'
  prefs: []
  type: TYPE_NORMAL
- en: Color images and multichannel stacks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Multichannel images contain individual channels that can each have their own
    color. An RGB image can be converted to a multichannel stack with a channel for
    red, green, and blue. An example of a multichannel image can be found in the image
    samples by selecting **Fluorescent Cells (400K)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color images and multichannel stacks](img/Insert_image_B04909_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The window looks similar to the **Boats** image. However, there is another bar
    at the bottom of the image window. This bar has a letter **C** on the left-hand
    side, indicating that it has multiple channels. Each channel has its own LUT,
    which, in this case, is Red (channel 1), Green (channel 2), and Blue (channel
    3). The bar just below the title bar now also displays some additional image information.
    It has the current channel indicated out of the total number of channels (1/3),
    and the color of the text indicates the color of the channel.
  prefs: []
  type: TYPE_NORMAL
- en: This allows for images with 16-bit information for each channel, which allows
    for images with a total of 48 bits of information in three channels. Internally,
    ImageJ can handle these files without problems, but most other programs cannot
    deal with these images. When saving these images, you may need to convert them
    to a different bit depth to use them in other programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'ImageJ allows you to change the color of multichannel images using a lookup
    table. The default is Grays, but other options include Red, Green, Blue, Cyan,
    Magenta, and Yellow. There are also multicolor LUTs that encode intensity over
    a range of colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Color images and multichannel stacks](img/Insert_image_B04909_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding image shows a few examples of a range of LUTs that are available
    in ImageJ: from left to right green, red, cyan, and spectrum.'
  prefs: []
  type: TYPE_NORMAL
- en: Z-stack images and volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When making optical sections using a microscope or an MRI machine, the resulting
    stack will contain information in three dimensions: *X*, *Y*, and *Z*. Each image
    in this Z-stack is called a slice. Multiple slices form a volume, which can be
    visualized in 3D. This will be discussed in the next chapter. The appearance of
    the image will be the same as for a multichannel image. However, instead of **C**,
    there will be a **Z** next to the slider to indicate that the stack contains slices.'
  prefs: []
  type: TYPE_NORMAL
- en: Time series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When taking images at a regular time interval, the resulting stack will be a
    time series containing an image for each time point called a **frame**. The appearance
    of the slider will be slightly different. Instead of a letter next to it, there
    will be a small play button. When you click on it, the time series will play at
    the speed that the time series was acquired (if the stack was calibrated).
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Besides multiple channels, frames (for time series) and slices (Z-stacks),
    it is also possible to combine all three dimensions into a single image file:
    a 5D image. If you open the **Mitosis (26MB, 5D stack)** sample image, a new window
    opens with two additional sliders at the bottom of the image window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multidimensional images](img/Insert_image_B04909_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The top slider is again for the channels (indicated by **C**), the middle slider
    is to navigate the slices (indicated by **Z**), and the last one is to navigate
    the time frames (indicated by the play button **►**). When you click on the play
    button, the time series will start playing like a movie, with the speed determined
    by the time interval between frames. If you wish to change the speed of playback,
    you can right-click on the play button. Alternatively, you can go to **Image**
    | **Stacks** | **Animation** | **Animation Options…** from the menu and enter
    the speed (in frames per second). Larger values mean faster playback.
  prefs: []
  type: TYPE_NORMAL
- en: The bar below the title bar, called the subtitle, again provides additional
    information. It now shows the selected channel (c:1/2), slice (z:3/5), and frame
    (t:26/51). This time, the image is also calibrated, and the subtitle also shows
    the dimensions of the image in micrometers (the size in pixels is indicated between
    braces).
  prefs: []
  type: TYPE_NORMAL
- en: Extracting image and pixel information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you wish to have more information about the image, you can press *Ctrl*
    + *I* (*⌘*+*I* on Mac) to get a new window with image information. If you do this
    for the 5D image, you will get the information shown in the previous image on
    the right-hand side. This shows a short description of the sample used as well
    as the dimensions of the image in calibrated units (micrometers) and pixels. It
    also tells you the bit depth per channel (bits per pixel: 16) and the time interval
    between frames that was used (frame interval: 0.14286 sec).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the Control key, or *⌘* (command) key on Mac, for shortcuts is optional
    by default. You can control this by going to **Edit** | **Options** | **Misc**.
    There is a checkbox labeled **Require control**/**command key** for shortcuts.
    When selected, the control/command key is required for **the shortcuts** used
    in ImageJ. When a shortcut requires the **Shift** key as well, this key is still
    required regardless of the setting! In this book, I will include the control/command
    key for shortcuts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the value of a pixel, you can place your mouse cursor over the pixel
    of interest. In the status bar of the ImageJ main window, you can see the following
    information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extracting image and pixel information](img/Insert_image_B04909_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is information about the location of the pixel (the *X* and *Y* coordinates,
    in calibrated units if the images are calibrated) and the value (intensity or
    gray value). Coordinates in ImageJ are relative to the upper-left corner (origin).
    If a Z-stack was loaded, the current *z* coordinate is also provided. In the next
    chapter, we will look at other measurements that can be obtained from images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Note on slice indexing**'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the value given for the pixel assumes that the first slice is 0, while
    the information below the title bar assumes that the first slice is 1\. When you
    start developing your own macros and plugins, this distinction can become important!
  prefs: []
  type: TYPE_NORMAL
- en: Loading and saving images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at loading images and sequences in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Loading images and sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen, we can load images from a URL by selecting it from the samples
    or going to **Import** | **URL** in the **File** menu. For files stored locally
    on the disk, we can select **File** | **Open…** and browse to a folder containing
    our images. It is also possible to drag and drop an image file onto the main ImageJ
    window to load it. If you drag and drop an entire folder onto the ImageJ window,
    all the images in that folder will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a folder containing individual pictures that you wish to open as
    a sequence, you can go to **Import** | **Image Sequence…** in the **File** menu.
    This allows you to select the first image file of the series, after which ImageJ
    determines all the images that will be loaded into a single image window. It is
    possible to use regular expressions to limit the number of images that will be
    imported.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Importing image sequences**'
  prefs: []
  type: TYPE_NORMAL
- en: When importing a sequence of images, all the images must be of the same type
    (bit depth) and have the same dimensions (width and height). If any file has dissimilar
    dimensions or bit depth, the import will fail and ImageJ will show an error. If
    other file types are in the same folder that should be ignored for importing,
    consider placing them in a different folder. Alternatively, you can use the regular
    expressions field in the import dialog to filter them out.
  prefs: []
  type: TYPE_NORMAL
- en: After the image is loaded, the window shows the filename in the title bar. When
    a filename is especially long, it may be beneficial to rename the window. Renaming
    the window can be done by selecting **Image** | **Rename…** from the menu or by
    right-clicking on the image and selecting **Rename…** from the context menu.
  prefs: []
  type: TYPE_NORMAL
- en: Saving images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ImageJ allows you to save images to different file types. The preferred file
    type used by ImageJ is TIFF, as it allows the storage of additional meta-information,
    regions of interest overlays, and calibration information. ImageJ supports a wide
    variety of image formats. When you go to **File** | **Save As**, a list of image
    formats is presented. The JPEG and PNG formats are compressed formats. They require
    less disk space for storage. This means they require smaller file sizes depending
    on the amount of compression that is selected. The TIFF format is a lossless format,
    but it can support compression.
  prefs: []
  type: TYPE_NORMAL
- en: 'When saving images, it is important to take into account what the saved image
    will be used for. When you wish to quantify the image at a later time or you have
    to repeatedly save it, a lossy compression file format such as JPEG is not recommended.
    Every time you save the image as a JPEG file, a little quality is lost. Furthermore,
    JPEG compression is optimized for smooth color gradients, generating artifacts
    when applied to fluorescent images with abrupt changes in intensity. The following
    screenshot shows an example that was opened and saved as a JPEG file 200 times.
    On the left-hand side is the original image, and on the right-hand side is the
    saved image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving images](img/Insert_image_B04909_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The most apparent problem is around the eyes, where multiple artifacts of the
    compression can be seen. In the white of the eyes, there are now spots that were
    not present in the original. The skin also shows a block-like pattern. This is
    caused by the fact that the JPEG compression is based on blocks of 8 x 8 pixels.
    In this case, the image was zoomed in to 200 percent, and for a web page, this
    image might still be acceptable. However, this image would be unacceptable for
    image quantification due to the artifacts. When you need to save the image many
    times, or when you are not sure what further processing is required, always save
    the image as a TIFF file. If you require an image for a web page or presentation,
    you can use only 8-bit grayscale or RGB images, which can be saved in TIFF, JPG,
    or PNG.
  prefs: []
  type: TYPE_NORMAL
- en: Image calibration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you perform image measurements and you wish to measure distances or areas,
    you need to make sure that your images are calibrated in the proper units. For
    2D images or 3D images, you can enter the pixel dimensions, and for time series,
    you can enter the time interval between frames. To do so, you can press *Ctrl*
    + *Shift* + *P* (*⌘* + *Shift* + *P* on Mac) to display the properties dialog.
    This allows you to set the unit of measurement (for instance, μm for micrometer)
    and the values for the width, height, and depth. The values indicate the number
    of units per pixel. For time series, the frame interval can be entered in seconds.
    When the **Global** checkbox is checked, this calibration will be applied to all
    images that are opened.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing images in ImageJ
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to examine an image in more detail, we may wish to use some of the
    tools that are available to view images in ImageJ. To show the available tools,
    let''s use the **Fluorescent Cells** images that we opened earlier. The first
    thing that you may wish to do is look at the detail in the image. This can be
    done by zooming in on the image by going to **Image** | **Zoom** | **In [+]**
    or by pressing the **+** key. When zooming in, the location of the cursor determines
    the center of the zoom. The current zoom level is indicated in the image title
    bar, and the maximum zoom level is 3200 percent. When you zoom in, the window
    rescales until it no longer fits on the desktop. When you zoom in beyond that
    point, the window size stays the same and the location of the current zoom is
    indicated in the top-left corner as an overlay:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing images in ImageJ](img/Insert_image_B04909_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The large blue square represents the entire image, while the small square inside
    indicates the current position of the zoomed display (in this case, at the lower-left
    side of the image). To zoom out, select **Image** | **Zoom** | **Out [-]** from
    the menu or use the **-** key.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you notice that the zoomed image shows some artifacts as shown in the following
    image, make sure you disabled **Interpolate zoomed images** by going to **Edit**
    | **Options** | **Appearance…**, as described in the first chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing images in ImageJ](img/Insert_image_B04909_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, when you acquire images, the exposure settings are suboptimal. This
    means you are not using the entire range of gray values available. In order to
    still see the signal, you can adjust the brightness and contrast of the image.
    To do so, select **Image** | **Adjust** | **Brightness/Contrast** from the menu
    or press *Ctrl* + *Shift* + *C*. This adjustment is non-destructive. It does not
    change the values in the image file until you press **Apply** in the **Brightness/Contrast**
    dialog for 8 and 16-bit images. The **Apply** button does not work for 32-bit
    images. If you press **Reset**, the values are restored to the initial values
    or to the values that were set after **Apply** was pressed. If you have an underexposed
    (dark) image, you can make it brighter by lowering the **Maximum** slider or increasing
    the **Brightness** slider.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Brightness/Contrast adjustments and measurements**'
  prefs: []
  type: TYPE_NORMAL
- en: When you adjust the **Brightness/Contrast** of an image and apply it, the gray
    values of the image are irreversibly modified. If you still wish to perform measurements
    that include intensity values, applying the modifications would alter your results
    (and perhaps, conclusions). Only use the **Apply** button when you create an image
    for non-critical viewing (presentations) or when measuring lengths or areas independent
    of intensity.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing multichannel images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you have a multichannel image, you may sometimes want to hide channels
    from being viewed. ImageJ allows you to show or hide any channel in a multichannel
    image by going to **Image** | **Color** | **Channels Tool…** in the menu or by
    pressing *Ctrl* + *Shift* + *Z*. A dialog opens with a checkbox for each channel.
    When the box is checked, the channel is displayed. Otherwise, it is switched off
    (hidden). It is also possible to change the order of the channels by going to
    **Image** | **Color** | **Arrange Channels…**. When modifying the **Brightness/Contrast**
    of a multichannel image, the adjustments are only applied to the current channel
    that is displayed. The currently selected channel can be checked on the info bar
    directly underneath the title bar. The color of the histogram in the **Brightness/Contrast**
    dialog also reflects the channel color selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Brightness/Contrast adjustments and the Channels Tool**'
  prefs: []
  type: TYPE_NORMAL
- en: When you have hidden channels using the **Channels Tool**, they can still be
    modified by the **Brightness/Contrast** dialog. If the hidden channel is currently
    selected when you modify the **Brightness/Contrast**, the adjustments would be
    made by ImageJ, but are not visible. Always verify the current channel before
    making adjustments!
  prefs: []
  type: TYPE_NORMAL
- en: Viewing time series
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When viewing time series, adjustments for brightness and contrast are visible
    in all frames of the time series. If you wish to apply an adjustment, ImageJ will
    ask whether you wish to do so for the current frame or for all the frames. When
    you apply the settings to all the frames, the adjustment is equal for all frames,
    irrespective of the intensity in the frame. This means that this does not help
    for time series that show a decrease in fluorescence over time (that is, bleaching).
    Bleaching is inherent in fluorescence imaging and causes a decrease in intensity
    over time. Generally speaking, this effect follows an exponential decay trend.
    Fiji has an option to correct this bleaching process by selecting **Image** |
    **Adjust** | **Bleach Correction** from the menu. For most time series that experience
    bleaching, the best correction method to select is **Exponential Fit**. This method
    is more robust against changes in intensity from sources other than bleaching.
    If the cause for the change in intensity is different, you may want to use the
    **Simple Ratio** method to correct the time series. Running this correction results
    in a new image window with the corrected data, which means that the original remains
    unaltered.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the different image types that are supported by
    ImageJ. You also saw how to load images from a disk or from a URL. We looked at
    the anatomy of an image window in ImageJ and the information that can be viewed.
    We applied a calibration to images in order to prepare for length and area measurements.
    Finally, we looked at different ways of viewing different image types. You learned
    how to adjust the brightness and contrast of the images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at ways to perform basic processing steps
    using the ImageJ interface.
  prefs: []
  type: TYPE_NORMAL
