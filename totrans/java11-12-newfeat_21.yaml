- en: Pattern Matching
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: As a Java programmer, imagine having the option of skipping usage of the `instanceof` operator
    and explicit casting operators to retrieve a value from your objects. Pattern
    matching (**JDK Enhancement Proposals** (**JEP**) 305) addresses this pain point
    by adding type test patterns and constant patterns. It enhances the Java programming
    language to introduce functionality that enables you to determine the type of
    instances and derived classes, and access their members without using explicit
    casting.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Java程序员，想象一下，如果你有选择跳过使用`instanceof`运算符和显式类型转换运算符来从你的对象中检索值。模式匹配（JDK增强提案（JEP）305）通过添加类型测试模式和常量模式来解决这个痛点。它增强了Java编程语言，引入了允许你确定实例和派生类的类型，并访问它们的成员而不使用显式类型转换的功能。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Pattern matching
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Type test patterns
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型测试模式
- en: Constant patterns
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常量模式
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code in this chapter uses the features defined in pattern matching (JEP
    305) that haven't been targeted for any JDK release version yet. To experiment
    with the code, you can clone the relevant repository.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码使用了模式匹配（JEP 305）中定义的功能，这些功能尚未针对任何JDK发布版本进行目标化。要实验代码，你可以克隆相关的仓库。
- en: All code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)[.](https://github.com/PacktPublishing/Java-11-and-12-New-Features)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有代码都可以在[https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)找到[.](https://github.com/PacktPublishing/Java-11-and-12-New-Features)
- en: Let's cover the issues with using `instanceof` and explicit type-casting operators.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论使用`instanceof`和显式类型转换运算符的问题。
- en: Pattern matching
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: Pattern matching will enhance the Java programming language. To start with,
    it will add type test patterns and constant patterns thatwill be supported by
    the `switch` statement and the `matches` expression. Later, this JEP might extend
    the supported patterns and language construct.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配将增强Java编程语言。首先，它将添加类型测试模式和常量模式，这些模式将由`switch`语句和`matches`表达式支持。随后，这个JEP可能会扩展支持的模式和语言结构。
- en: Pattern matching is an age-old technique (approximately 65 years old) that has
    been adapted and is used by various languages such as text-oriented, functional
    (Haskell), and object-oriented languages (Scala, C#).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配是一种古老的技巧（大约65年历史），它已被各种语言所采用并使用，如面向文本、函数式（Haskell）和面向对象语言（Scala、C#）。
- en: 'A pattern is a combination of the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 模式是以下组合：
- en: A predicate
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谓词
- en: A target
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个目标
- en: A set of binding variables
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组绑定变量
- en: When a predicate is successfully applied to a target, a set of binding variables
    are extracted from the target. The patterns covered in this chapter are type test
    patterns and constant patterns.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个谓词成功应用于一个目标时，会从目标中提取一组绑定变量。本章涵盖的模式包括类型测试模式和常量模式。
- en: Before working with the examples in detail, let's understand what the existing
    issues are and why we need pattern matching.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细处理示例之前，让我们了解现有问题和为什么我们需要模式匹配。
- en: Existing issues with type testing
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型测试存在的问题
- en: 'As a Java developer, you should have worked with code such as the one highlighted
    in bold in the following block:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名Java开发者，你应该已经与以下块中加粗的高亮代码一起工作过：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding code includes three steps to use the value of the `bottles` variable:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码包括三个步骤来使用`bottles`变量的值：
- en: '`obj instanceof Ocean`: Testing of the type of the `obj` variable'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`obj instanceof Ocean`：测试`obj`变量的类型'
- en: '`(Ocean)obj`: Casting of the reference variable, `obj`, to `Ocean`'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`(Ocean)obj`：将引用变量`obj`转换为`Ocean`'
- en: '`((Ocean)obj).getBottles()`: Destruction of the instance to get a value'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`((Ocean)obj).getBottles()`: 通过销毁实例来获取值'
- en: 'As developers, we have been writing similar code for a long time, but have
    also been hating it secretly. It is like repeating the same instructions again
    and again. These steps to test, cast, and deconstruct an instance to extract a
    value are unnecessarily verbose. We all know that code repetition is one of the
    best ways for errors to go unnoticed. To add to this, it only gets bigger with
    multiple instances of code repetition in one place. Take the following code sample
    as an example:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，我们长期以来一直在编写类似的代码，但也在秘密地讨厌它。这就像一遍又一遍地重复相同的指令。这些测试、铸造和分解实例以提取值的步骤是不必要的冗长。我们都知道代码重复是错误被忽视的最好方式之一。更糟糕的是，当在一个地方有多个代码重复实例时，它只会变得更糟。以下代码示例就是一个例子：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you add more occurrences of the testing-casting-instance destruction pattern
    to retrieve the field values, you lose the business logic in the complexity that
    is induced by the language. It is very common for developers to literally copy
    and paste such code and modify the pieces that aren't the same—but it is also
    common for some code parts to be left unchanged (which either become logic errors
    or should be labeled as copy and paste errors).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加更多测试-铸造-实例销毁模式的实例来检索字段值时，你会在由语言引起的复杂性中失去业务逻辑。开发者直接复制并粘贴这样的代码并修改不同的部分是非常常见的——但同样常见的是一些代码部分被保留不变（这要么成为逻辑错误，要么应该被标记为复制粘贴错误）。
- en: This code is also less optimizable; it will have *O(n)* time complexity, even
    though the underlying problem is often *O(1)*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也难以优化；即使底层问题通常是 `O(1)`，它的时间复杂度也将是 `O(n)`。
- en: Type test patterns
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型测试模式
- en: To get around the issues created by the testing-casting-instance destruction
    pattern, Java proposes to embrace pattern matching.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决测试-铸造-实例销毁模式造成的问题，Java 提议采用模式匹配。
- en: 'Here''s an example of the proposed changes to the language:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个语言提出的更改示例：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code introduces a new Java keyword, `matches`, which includes
    a **predicate **(`obj`) and a **target** (`Ocean o`). The predicate, that is,
    `obj` is applied to the target, that is, `Ocean o`, which binds the `o` variable
    to the instance referred by `obj`. If the matching is successful, you can access
    members of the instance using the `bound` variable, that is, `o`. The following
    diagram compares the code changes of using `instanceof` and `matches`. As is evident,
    the `matches` operator takes off the ugly explicit casting from the code:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码引入了一个新的 Java 关键字 `matches`，它包括一个 **谓词** (`obj`) 和一个 **目标** (`Ocean o`)。谓词，即
    `obj` 应用到目标，即 `Ocean o`，将 `o` 变量绑定到由 `obj` 指代的实例。如果匹配成功，你可以使用 `bound` 变量，即 `o`，来访问实例的成员。以下图表比较了使用
    `instanceof` 和 `matches` 的代码更改。显然，`matches` 操作符从代码中移除了丑陋的显式转换：
- en: '![](img/621278e7-de02-4d3e-86aa-84ea02e07b07.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/621278e7-de02-4d3e-86aa-84ea02e07b07.png)'
- en: 'Let''s see whether type matching eases our code with multiple occurrences:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看类型匹配是否可以简化我们代码中的多次出现：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The test pattern is not limited to the `if`-`else` statements. Let's see how
    it can be used with `switch` constructs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 测试模式不仅限于 `if`-`else` 语句。让我们看看它如何与 `switch` 构造一起使用。
- en: Using pattern matching with switch constructs
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模式匹配与 `switch` 构造
- en: The `switch` statement seems to be one of the best constructs that can use pattern
    matching. At present, a `switch` construct can match primitive literal values
    (excluding `long`, `float`, and `double`), `String`, and enum constants.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句似乎是可以使用模式匹配的最好构造之一。目前，`switch` 构造可以匹配原始字面量值（不包括 `long`、`float` 和
    `double`）、`String` 和枚举常量。'
- en: 'If a `case` label can specify a pattern, the code in the preceding section
    (the one that uses multiple instances of object checking and value extraction)
    can be modified as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `case` 标签可以指定一个模式，前面部分（使用多个对象检查和值提取的实例）的代码可以修改如下：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With pattern matching, the business logic takes the limelight. It also reduces
    the complexity of the syntax, which improves code readability. The preceding code
    is also optimizable because we are likely to dispatch in *O(1)* time.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用模式匹配，业务逻辑成为焦点。它还简化了语法的复杂性，从而提高了代码的可读性。前面的代码也是可优化的，因为我们很可能会在 `O(1)` 时间内进行调度。
- en: Under pattern matching, work is also being done on the deconstruction pattern
    (which is the opposite of instance construction).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在模式匹配中，也在对解构模式（与实例构造相反）进行工作。
- en: Summary
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you covered how pattern matching would change your everyday
    code. Pattern matching introduces a new keyword, `matches`, to ease the checking,
    casting, and retrieval of values from instances.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了模式匹配将如何改变你的日常代码。模式匹配引入了一个新的关键字`matches`，以简化从实例中检查、转换和检索值的过程。
- en: This book took you through the latest Java versions—10, 11 and 12, and also
    Project Amber. Java has a strong development road map and it continues to excite
    the developers and enterprises with its existing features and new capabilities.
    With a new six-month release cadence, Java is advancing at a fast pace that we
    haven't witnessed earlier. As developers, you get to work with newer Java features
    and improvements, sooner than ever before.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书带你了解了最新的Java版本——10、11和12，以及Amber项目。Java拥有强大的发展路线图，并且凭借其现有特性和新功能，继续激发开发者和企业的热情。随着新的六个月发布节奏，Java的发展速度之快是我们之前未曾见过的。作为开发者，你将比以往任何时候都能更早地使用到新的Java特性和改进。
- en: I encourage all developers to check out the improvements and additions to new
    Java versions, as they are released. Also, don't miss to browse through projects
    such as Valhalla, Loom, Panama, and many other projects at Oracle's website. These
    projects will advance Java's capabilities such as light-weight threading, simpler
    access to foreign libraries, and newer language candidates such as value types
    and generic specialization. Stay tuned!
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励所有开发者检查新Java版本的改进和新增功能，因为它们一旦发布。同时，也不要错过在Oracle网站上浏览诸如Valhalla、Loom、Panama以及许多其他项目。这些项目将提升Java的能力，例如轻量级线程、更简单的外部库访问，以及新的语言候选者，如值类型和泛型特化。敬请期待！
