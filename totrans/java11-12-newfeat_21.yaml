- en: Pattern Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a Java programmer, imagine having the option of skipping usage of the `instanceof` operator
    and explicit casting operators to retrieve a value from your objects. Pattern
    matching (**JDK Enhancement Proposals** (**JEP**) 305) addresses this pain point
    by adding type test patterns and constant patterns. It enhances the Java programming
    language to introduce functionality that enables you to determine the type of
    instances and derived classes, and access their members without using explicit
    casting.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type test patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constant patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this chapter uses the features defined in pattern matching (JEP
    305) that haven't been targeted for any JDK release version yet. To experiment
    with the code, you can clone the relevant repository.
  prefs: []
  type: TYPE_NORMAL
- en: All code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)[.](https://github.com/PacktPublishing/Java-11-and-12-New-Features)
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover the issues with using `instanceof` and explicit type-casting operators.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pattern matching will enhance the Java programming language. To start with,
    it will add type test patterns and constant patterns thatwill be supported by
    the `switch` statement and the `matches` expression. Later, this JEP might extend
    the supported patterns and language construct.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching is an age-old technique (approximately 65 years old) that has
    been adapted and is used by various languages such as text-oriented, functional
    (Haskell), and object-oriented languages (Scala, C#).
  prefs: []
  type: TYPE_NORMAL
- en: 'A pattern is a combination of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A predicate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A target
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of binding variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a predicate is successfully applied to a target, a set of binding variables
    are extracted from the target. The patterns covered in this chapter are type test
    patterns and constant patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Before working with the examples in detail, let's understand what the existing
    issues are and why we need pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Existing issues with type testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As a Java developer, you should have worked with code such as the one highlighted
    in bold in the following block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code includes three steps to use the value of the `bottles` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`obj instanceof Ocean`: Testing of the type of the `obj` variable'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`(Ocean)obj`: Casting of the reference variable, `obj`, to `Ocean`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`((Ocean)obj).getBottles()`: Destruction of the instance to get a value'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As developers, we have been writing similar code for a long time, but have
    also been hating it secretly. It is like repeating the same instructions again
    and again. These steps to test, cast, and deconstruct an instance to extract a
    value are unnecessarily verbose. We all know that code repetition is one of the
    best ways for errors to go unnoticed. To add to this, it only gets bigger with
    multiple instances of code repetition in one place. Take the following code sample
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you add more occurrences of the testing-casting-instance destruction pattern
    to retrieve the field values, you lose the business logic in the complexity that
    is induced by the language. It is very common for developers to literally copy
    and paste such code and modify the pieces that aren't the same—but it is also
    common for some code parts to be left unchanged (which either become logic errors
    or should be labeled as copy and paste errors).
  prefs: []
  type: TYPE_NORMAL
- en: This code is also less optimizable; it will have *O(n)* time complexity, even
    though the underlying problem is often *O(1)*.
  prefs: []
  type: TYPE_NORMAL
- en: Type test patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get around the issues created by the testing-casting-instance destruction
    pattern, Java proposes to embrace pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of the proposed changes to the language:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code introduces a new Java keyword, `matches`, which includes
    a **predicate **(`obj`) and a **target** (`Ocean o`). The predicate, that is,
    `obj` is applied to the target, that is, `Ocean o`, which binds the `o` variable
    to the instance referred by `obj`. If the matching is successful, you can access
    members of the instance using the `bound` variable, that is, `o`. The following
    diagram compares the code changes of using `instanceof` and `matches`. As is evident,
    the `matches` operator takes off the ugly explicit casting from the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/621278e7-de02-4d3e-86aa-84ea02e07b07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s see whether type matching eases our code with multiple occurrences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The test pattern is not limited to the `if`-`else` statements. Let's see how
    it can be used with `switch` constructs.
  prefs: []
  type: TYPE_NORMAL
- en: Using pattern matching with switch constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `switch` statement seems to be one of the best constructs that can use pattern
    matching. At present, a `switch` construct can match primitive literal values
    (excluding `long`, `float`, and `double`), `String`, and enum constants.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a `case` label can specify a pattern, the code in the preceding section
    (the one that uses multiple instances of object checking and value extraction)
    can be modified as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With pattern matching, the business logic takes the limelight. It also reduces
    the complexity of the syntax, which improves code readability. The preceding code
    is also optimizable because we are likely to dispatch in *O(1)* time.
  prefs: []
  type: TYPE_NORMAL
- en: Under pattern matching, work is also being done on the deconstruction pattern
    (which is the opposite of instance construction).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you covered how pattern matching would change your everyday
    code. Pattern matching introduces a new keyword, `matches`, to ease the checking,
    casting, and retrieval of values from instances.
  prefs: []
  type: TYPE_NORMAL
- en: This book took you through the latest Java versions—10, 11 and 12, and also
    Project Amber. Java has a strong development road map and it continues to excite
    the developers and enterprises with its existing features and new capabilities.
    With a new six-month release cadence, Java is advancing at a fast pace that we
    haven't witnessed earlier. As developers, you get to work with newer Java features
    and improvements, sooner than ever before.
  prefs: []
  type: TYPE_NORMAL
- en: I encourage all developers to check out the improvements and additions to new
    Java versions, as they are released. Also, don't miss to browse through projects
    such as Valhalla, Loom, Panama, and many other projects at Oracle's website. These
    projects will advance Java's capabilities such as light-weight threading, simpler
    access to foreign libraries, and newer language candidates such as value types
    and generic specialization. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
