- en: Patterns of Advanced Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级函数式编程的模式
- en: We are probably already familiar with the concept of patterns from object-oriented
    programming. Patterns are common solutions to common problems. Whenever you have
    a problem that repeats from project to project, solutions also tend to repeat.
    Similar problems are solved similarly. And hence, such solutions become patterns
    that are widely accepted.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经熟悉了来自面向对象编程的概念——模式。模式是常见问题的常见解决方案。每当你在项目之间重复遇到问题时，解决方案也倾向于重复。相似的问题以相似的方式解决。因此，这些解决方案成为广泛接受的模式。
- en: Functional programming also has its own patterns. Since it has certain problems
    and challenges unique to it, it will also have unique solutions. In this chapter,
    we will discuss solutions to common functional programming problems.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程也有自己的模式。由于它有其独特的问题和挑战，它也将有其独特的解决方案。在本章中，我们将讨论常见函数式编程问题的解决方案。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Monad Transformers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态转换器
- en: Tagless Final
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签无最终状态
- en: Type-level programming
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型级编程
- en: Monad Transformers
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态转换器
- en: Monad Transformers is an important pattern of purely functional programming
    that allows us to combine effect types. Let's now discuss it in detail.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 模态转换器是纯函数式编程的一个重要模式，它允许我们组合效果类型。现在让我们详细讨论一下。
- en: The specialization of effect types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果类型的专业化
- en: We've discussed how effect types are ubiquitous in purely functional programming
    and are used in order to abstract away side effects. You may have also noticed
    that these types are highly specialized, which means we have almost one-to-one
    mapping between side effects and effect types. For example, the ability of an
    application to return null is represented by an `Option` side effect type. `Option`
    is good for such null situations. However, it does not perform well when tasked
    with modeling errors and exceptions. This is because it does not preserve the
    information of the nature of the failure.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了效果类型在纯函数式编程中的普遍性以及它们用于抽象副作用。你可能也注意到这些类型非常专业化，这意味着我们几乎有一个副作用和效果类型之间的一对一映射。例如，应用程序返回
    null 的能力由 `Option` 效果类型表示。`Option` 对于这种 null 情况来说很好。然而，当它被用来模拟错误和异常时，表现并不好。这是因为它没有保留失败性质的信息。
- en: 'A data type that is good for modeling erroneous computation that can fail is
    `Either`. However, if you try to model a computation that returns null with `Either`,
    you will find that this data type is redundant for these purposes. This is because
    whenever you have a computation that does not return a value, you will still need
    to return something from it. In the erroneous scenario, we could have done the
    following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个适合模拟可能失败的计算的数据类型是 `Either`。然而，如果你尝试用 `Either` 模拟返回 null 的计算，你会发现这个数据类型对于这些目的来说是多余的。这是因为每当有一个不返回值的计算时，你仍然需要从它返回某些东西。在错误场景中，我们可能已经做了以下操作：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, what do you return in the same scenario with `Either`? If the correct
    result is to be modeled by `Right`, we should model an empty result with `Left`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在相同的场景下，如果你使用 `Either`，你会返回什么？如果正确的结果应该由 `Right` 模拟，我们应该用 `Left` 模拟一个空的结果：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, `Left` is also supposed to contain a value. What do we return in `Left`?
    Our best bet would be to return a string that explicitly says that the computation
    did not produce any result:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Left` 也应该包含一个值。我们在 `Left` 中返回什么？我们最好的选择是返回一个明确表示计算没有产生任何结果的字符串：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As you can see, this usage of `Either` is rather contrived in this example.
    This means we have a situation where side effects are fine-grained, and every
    side effect has its own representing effect type. This is a natural situation
    for Scala, as for any strongly-typed language. The finer your type system matches
    the side effects, the more side effects you can model out of the box.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在这个例子中，`Either` 的这种用法相当牵强。这意味着我们有一个副作用非常细粒度的情况，每个副作用都有自己的表示效果类型。这对于 Scala
    来说是一个自然的情况，对于任何强类型语言来说也是如此。你的类型系统与副作用越匹配，你就可以越容易地模拟出副作用。
- en: This also means that when we have more than one side effect, we need to think
    about how are we going to present and combine them.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着当我们有多个副作用时，我们需要考虑我们将如何展示和组合它们。
- en: An application with multiple side effects
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 具有多个副作用的应用
- en: Modern applications aim for asynchrony. This means that whenever you need to
    compute anything, and it may take a long time, you do not compute it in a synchronous
    manner. That is, you do not wait for the computation to produce a result. Instead,
    you program in a non-blocking style. This means that you schedule computations
    to run at some point in the future and wait for the result.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序追求异步。这意味着每当您需要计算任何东西，而且可能需要很长时间，您不会以同步的方式计算。也就是说，您不会等待计算产生结果。相反，您以非阻塞的方式编程。这意味着您将计算调度到未来的某个时间点，并等待结果。
- en: Asynchrony
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步
- en: 'Consider an example of a web server tasked with handling incoming HTTP requests
    in a setting of a web application that manages an online forum. Consider that
    the requests in question are to be responded to with the data about all of the
    forum posts present in the database. This means that in order to reply to any
    given HTTP request, we first need to obtain the required data from the database.
    The solution may look as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，一个网络服务器负责处理来自一个管理在线论坛的Web应用的HTTP请求。假设这些请求需要用数据库中所有论坛帖子的数据来响应。这意味着为了回复任何给定的HTTP请求，我们首先需要从数据库中获取所需的数据。解决方案可能如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, the types and methods are declared as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，类型和方法声明如下：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, this is not the only task that our application needs to do. Consider
    also that our forum is private, which means we need to authenticate a user prior
    to giving them access to the forum.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不是我们的应用程序需要完成的唯一任务。考虑一下，我们的论坛是私有的，这意味着在给用户访问论坛之前，我们需要对用户进行认证。
- en: Nowadays, a popular way to authenticate is to use a cloud solution for authentication.
    This means that people do not implement the authentication mechanism themselves
    on the server side, but outsource it to some  provider. Such a mechanism is known
    as **Authentication as a Service** (**AaaS**). A number of companies provide out-of-the-box
    services that you can use in your application to authenticate. There are many
    benefits to the approach since you do not need to waste your time implementing
    authentication logic, and it can include not only password authentication, but
    also social authentications and fancy security mechanisms such as two-factor authentication.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一种流行的认证方式是使用云认证解决方案。这意味着人们不需要在服务器端自己实现认证机制，而是将其外包给某些提供商。这种机制被称为**认证即服务**（**AaaS**）。许多公司提供现成的服务，您可以在应用程序中使用这些服务进行认证。这种方法有很多好处，因为您不需要浪费时间实现认证逻辑，它不仅包括密码认证，还包括社交认证和复杂的安全机制，如双因素认证。
- en: However, if we are using a cloud-based solution for our authentication, this
    means that we most likely need to contact the cloud every time a user tries to
    log in. Modern authentication methods, such as JWT, imply a stateless authentication.
    It is possible to produce a JSON tag that the user can pass to a server, and the
    server can verify its authenticity using a cryptography mechanism. So you do not
    need to keep a state to authenticate a person. However, even in this scenario,
    you are most likely going to need to contact your cloud-based authentication platform
    to obtain keys that you are using as well as to verify that the user is indeed
    present in their databases.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用基于云的认证解决方案，这意味着每次用户尝试登录时，我们很可能需要联系云。现代认证方法，如JWT，意味着无状态认证。可以生成一个JSON标签，用户可以将其传递给服务器，服务器可以使用加密机制验证其真实性。因此，您不需要保持状态来认证一个人。然而，即使在这种情况下，您很可能还需要联系您的基于云的认证平台，以获取您使用的密钥以及验证用户确实存在于他们的数据库中。
- en: 'How is all of the this relevant to our functional programming example? The
    thing to notice here is that we need to contact the web. The operation of contacting
    the cloud is a long-running one. For the time being, let''s assume this operation
    is done in a synchronous manner, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些与我们的函数式编程示例有什么关系？这里要注意的是，我们需要接触网络。联系云的操作是一个长时间运行的操作。暂时假设这个操作是以同步方式完成的，如下所示：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following declarations were added to our environment:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下声明被添加到我们的环境中：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code snippet, we ask the cloud-based authentication service
    whether the user is authorized to perform the action, and if they are, we reply
    with the forum post.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们询问基于云的认证服务用户是否有权限执行该操作，如果有，我们回复论坛帖子。
- en: Imagine the preceding server under a high load. Immediately, questions arise
    about the number of threads that can be used in handling the `HTTP` request. Also,
    a question arises about how fast a web server can handle any given request. Imagine
    we have four threads on the task. Imagine also that it takes roughly one second
    to handle a given request as there is latency involved in contacting the database
    and the cloud-based authentication service. How much of a load can a server tolerate?
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下服务器在高负载下的情况。立即，关于处理`HTTP`请求可以使用的线程数量的问题浮现出来。同样，还有一个问题，那就是一个网络服务器可以多快地处理任何给定的请求。假设我们有四个线程在处理任务。再想象一下，处理一个给定的请求大约需要一秒钟，因为涉及到与数据库和基于云的认证服务的联系延迟。服务器能承受多大的负载？
- en: If the load is more than four requests per second, the server will start running
    out of threads. Imagine the server handles four requests simultaneously. This
    means that all of its four threads that are allocated for handling HTTP requests
    will be busy for one second. Consequently, the server will not be able to handle
    further requests until it handles those four requests. This means that if, for
    example, five requests arrive at the same time, the first four of them will be
    handled in one second, and the fifth one will take two seconds to handle. This
    is because it will not be started until the first four requests are handled.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果负载超过每秒四个请求，服务器将开始耗尽线程。想象一下服务器同时处理四个请求。这意味着分配给处理HTTP请求的四个线程将忙一秒钟。因此，服务器在处理完这四个请求之前将无法处理进一步的请求。这意味着，例如，如果有五个请求同时到达，前四个将在一秒钟内处理，第五个将需要两秒钟来处理。这是因为它将不会开始，直到前四个请求被处理。
- en: The threads that handle this request do not really do anything the majority
    of the time. During the first call to the cloud authentication solution, the majority
    of the handling time is waiting to receive a reply from the server. And when it
    subsequently calls a database, that majority of the time it waits for the database
    to reply. If the thread spends the majority of its time waiting for the replies,
    this means that the processor does not do anything useful, that it has some free
    power and free capacity to work on some other tasks, such as maybe handling the
    other incoming requests.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个请求的线程大多数时间实际上并没有做什么。在第一次调用云认证解决方案时，大部分的处理时间是在等待服务器回复。随后，当它调用数据库时，大部分时间是在等待数据库回复。如果线程大部分时间都在等待回复，这意味着处理器没有做任何有用的事情，它有一些空闲的功率和容量来处理其他任务，比如可能处理其他传入的请求。
- en: This reasoning is precisely why the synchronous way of handling is not desirable
    in applications that are designed for high loads. An alternative is an asynchronous
    approach. In the asynchronous approach, whenever you have a long-running computation,
    you dispatch it to a thread pool using an asynchronous primitive, for example,
    a `Future`. And then, you specify what to do once the task is completed. The trick
    in an asynchronous application is to build it from asynchronous primitives that
    do not block. So, for example, the act of requesting information from the database
    should not involve blocking or waiting for a response, even on a thread within
    a future. The point is that the thread that makes a request is free to do other
    tasks once the request is made and it has nothing else to do.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种推理使得同步处理方式在为高负载设计的应用程序中不可取。一个替代方案是异步方法。在异步方法中，每当有长时间运行的计算时，你使用异步原语将其调度到线程池中，例如，使用`Future`。然后，你指定任务完成后要做什么。异步应用程序的技巧是从不阻塞的异步原语构建。例如，从数据库请求信息的操作不应该涉及阻塞或等待响应，即使在未来的线程中也不行。关键是发起请求的线程在请求发出后可以自由地做其他任务，而且没有其他事情要做。
- en: The point is to utilize a non-blocking API to perform HTTP requests and requests
    to the database so that your threads, which are quite heavyweight primitives in
    the Java world, do not block and do not wait for responses and are not wasted,
    rather, they should do something useful.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是利用非阻塞API来执行HTTP请求和对数据库的请求，这样你的线程，在Java世界中相当重型的原语，就不会阻塞，也不会等待响应，也不会浪费，相反，它们应该做些有用的事情。
- en: 'An application handler in an asynchronous style would look as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 异步风格的应用程序处理程序看起来如下：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It still takes about one second for a single request to get handled, because
    the delay that you experience once requesting external resources still exists.
    However, now the server will perform much better under high loads. This is because
    the threads themselves do not wait this entire one second on a single request.
    Instead, for them, the only time that counts is the time when they actually do
    the job, and not the time they wait on the external resource to reply to them.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 处理单个请求仍然需要大约一秒钟的时间，因为你在请求外部资源时体验到的延迟仍然存在。然而，现在服务器在高负载下将表现得更好。这是因为线程本身不会在整个一秒钟内等待单个请求。相反，对他们来说，唯一算得上时间的是他们实际工作的时间，而不是他们等待外部资源回复的时间。
- en: So, for example, if the real processing time of a given request, meaning the
    time the thread is actually doing the work and not waiting for a reply, constitutes
    10 milliseconds, then a single thread is capable of accepting and handling 100
    requests per second.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果给定请求的真实处理时间，即线程实际工作而不等待回复的时间，是10毫秒，那么单个线程每秒可以接受和处理100个请求。
- en: The preceding discussion describes why you might need the side effect of asynchrony
    and programming with callbacks in practice. And asynchrony is a side effect that
    you might want to hide behind some primitives, such as a future.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的讨论描述了为什么在实践中你可能需要异步的副作用和回调编程。并且异步性是一个你可能想要隐藏在某种原语背后的副作用。
- en: However, asynchrony is not the only side effect that you might want to abstract
    away in the case of writing an HTTP handler. Another side effect that you might
    want to abstract is the side effect of an error. Now, let's discuss this side
    effect in detail.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，异步性并不是你在编写HTTP处理器时想要抽象掉的唯一副作用。你可能还想抽象的另一个副作用是错误的副作用。现在，让我们详细讨论这个副作用。
- en: The side effect of errors
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误的副作用
- en: In the preceding example, we saw that thing do not always go smoothly. Things
    can go wrong on multiple levels. So when we connect to the cloud authentication
    service, the connection itself may go wrong. For example, the server reply times
    out. Or, your application credentials are wrong and you do not end up accessing
    the feature of the cloud authentication service that you would like to access.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们看到了事情并不总是顺利。事情可能在多个层面上出错。因此，当我们连接到云认证服务时，连接本身可能会出错。例如，服务器响应超时。或者，你的应用程序凭证错误，你最终无法访问你想要访问的云认证服务的功能。
- en: When contacting the database, things can also go wrong. For example, you may
    fail to establish a connection with the database. Or, for some reason, the data
    is not present in the database or is not in the correct format.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当联系数据库时，也可能出错。例如，你可能无法与数据库建立连接。或者，由于某种原因，数据不在数据库中，或者数据格式不正确。
- en: 'Finally, the business logic of the application allows for an error. This one
    happens when the person making the request to the server is not authorized to
    view the data they request. In such a situation, we will need to reply with an
    error message instead of the data they requested:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序的业务逻辑允许出现错误。这种情况发生在请求服务器数据的人没有权限查看他们请求的数据时。在这种情况下，我们需要回复一个错误消息而不是他们请求的数据：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: All of the cases discussed here are a clear evidence that we have a side effect
    of an error here as a potential. Normally, we would abstract away this side effect
    into an effect type. Then, we'd use the `flatMap` function in order to combine
    these computations. However, we already have one effect type, `Future`, that abstracts
    away the asynchronous nature of request-handling. How do we introduce another
    side effect here?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这里讨论的所有情况都是明确的证据，表明我们这里有一个潜在的错误的副作用。通常，我们会将这个副作用抽象成一个效果类型。然后，我们会使用`flatMap`函数来组合这些计算。然而，我们已经有了一个效果类型，`Future`，它抽象掉了请求处理的异步性。我们如何在这里引入另一个副作用呢？
- en: First of all, a note should be made that `Future` itself provides a capability
    for error reporting. However, this is a detail specific to the Future's implementation.
    It is perfectly possible to imagine asynchronous primitives that provide you with
    the abstraction of asynchrony but do not catch the errors that happen inside them.
    So here, we will be viewing the situation as if the Future does not provide the
    capability of error-handling.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应该注意的是`Future`本身提供了一种错误报告的能力。然而，这是一个与`Future`实现相关的细节。完全可能想象异步原语提供异步抽象，但不捕获其内部发生的错误。所以在这里，我们将把情况看作是`Future`没有提供错误处理能力。
- en: 'A naive way to handle that scenario would be to make the computation return
    a `Future` of an `Either` of a result. So, for example, the query to the database
    and the cloud service would look as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这种情况的一个简单方法是将计算返回一个`Future`的`Either`结果。例如，对数据库和云服务的查询将如下所示：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code, we stack the side effects one on top of another. Will
    that work in practice? In principle, it is possible to imagine a computation that
    returns an `Either` under a `Future`. Let's have a look at how we will be using
    it in combination with other complications. Previously, we used the `flatMap`
    function to combine the computations sequentially. How would such a combination
    look in the case of nested side effects?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将副作用一层层堆叠。这在实践中会工作吗？原则上，可以想象一个在`Future`下返回`Either`的计算。让我们看看我们将如何结合其他复杂情况使用它。之前，我们使用`flatMap`函数按顺序组合计算。在嵌套副作用的情况下，这种组合将如何看起来？
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code does not compile. The error is as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码无法编译。错误如下：
- en: '![](img/304daf7c-6009-442c-b238-bb47c4118f40.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![](img/304daf7c-6009-442c-b238-bb47c4118f40.png)'
- en: As you can see, the compiler says that we are using `Either` in position where
    `Boolean` is expected. So `authenticated` variable in the snippet above is `Either` 
    instead of `Boolean`. However, why would we be working on `Either` under the Monadic
    flow? Is that not a purpose of Monadic flow to abstract away the effect types
    so that we are able to deal with the computed values directly without having to
    worry about the effect types?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，编译器指出我们在期望`Boolean`的位置使用了`Either`。因此，上面代码片段中的`authenticated`变量是`Either`而不是`Boolean`。然而，为什么我们会在Monadic流中处理`Either`？难道Monadic流的目的不是抽象效果类型，以便我们能够直接处理计算值，而不必担心效果类型吗？
- en: 'Actually, we can rewrite the preceding example in terms of `flatMap` for better
    readability:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以用`flatMap`重写前面的示例，以提高可读性：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Let''s now check the signatures and types of all the values involved. First,
    let''s check the type that we are calling `flatMap` on, `Future[Either[/*...*/]]`.
    After, we are working with the result as if it were the user object retrieved
    from the cloud authentication service. However, let''s take another look at the
    signature of `flatMap` as defined by `Future`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查所有涉及值的签名和类型。首先，让我们检查我们正在调用`flatMap`的类型，`Future[Either[/*...*/]]`。之后，我们就像处理从云认证服务检索的用户对象一样处理结果。然而，让我们再次看看`Future`定义的`flatMap`的签名：
- en: '![](img/8811b158-4d18-4dc4-b28e-0a3b6524fb6c.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8811b158-4d18-4dc4-b28e-0a3b6524fb6c.png)'
- en: So the function already has a familiar signature: `A => Future[B]`. What is
    `A`? It is the type parameter of `Future`. What is the type parameter of our particular
    `Future`? This type parameter is `Either[String, User]`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该函数已经有一个熟悉的签名：`A => Future[B]`。那么`A`是什么？它是`Future`的类型参数。我们特定的`Future`的类型参数是什么？这个类型参数是`Either[String,
    User]`。
- en: 'That means that `flatMap` does not give us the user object, but `Either`. Using
    this information, we can alter the example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`flatMap`并没有给我们用户对象，而是`Either`。利用这个信息，我们可以修改示例：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we manually extract the result value from `Either`. Immediately, we can
    say that something is very wrong and needs to be corrected. The feeling of something
    wrong arises because previously we have discussed that the very point of having
    Monadic flows and the `flatMap` function is to abstract away effect types. Yet
    here, we need to work with them explicitly.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们手动从`Either`中提取结果值。立即，我们可以说有些地方非常不对，需要修正。这种感觉不对是因为我们之前讨论过，拥有Monadic流和`flatMap`函数的目的是抽象效果类型。然而，在这里，我们需要明确地处理它们。
- en: Monad Transformers
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Monadic Transformers
- en: The problem here is that the `flatMap` function is defined on the Future. It
    knows nothing about the type parameter of Future. This can be anything you can
    imagine. Implementation does not place any constraints on the type parameter.
    It also means that it knows nothing about this type signature and its properties.
    Hence, neither the Monad nor the Future default implementation of `flatMap` for
    Future is aware of the possibility that the type parameter to Future will be another
    effect type. So, when you stack our effect types in the manner discussed earlier,
    only the topmost effect type gets abstracted when we are using the `flatMap` function.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是 `flatMap` 函数是在 Future 上定义的。它对 Future 的类型参数一无所知。它可以是你能想象到的任何东西。实现没有对类型参数施加任何约束。这也意味着它对这个类型签名及其属性一无所知。因此，对于
    Future 的 `flatMap` 函数的默认实现，无论是作为 Monad 还是 Future，都没有意识到 Future 的类型参数可能是另一个效果类型。所以，当我们以前面讨论的方式堆叠我们的效果类型时，只有最顶层的效应类型在调用
    `flatMap` 函数时会被抽象化。
- en: This behavior is unnatural. We didn't get what we expected. What did we expect
    to get? We expected that not only would the side effect be unwrapped, but its
    inner side effect would also be unwrapped.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为是不自然的。我们没有得到我们期望的结果。我们期望得到什么？我们期望不仅副作用会被展开，而且其内部副作用也会被展开。
- en: When we have nested effect types, and when we expect them to be treated as one
    effect, we need Monad Transformers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们遇到嵌套的效果类型，并且期望它们被视为一个效果时，我们需要使用 Monad Transformers。
- en: 'Monad Transformers is actually a pattern that can be used to define stackable
    versions of already-existing effect types. For example, let''s have a look at
    how such a Monad Transformer is defined for the `Either` type in the `cats` library:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Monad Transformers 实际上是一种模式，可以用来定义已存在效果类型的可堆叠版本。例如，让我们看看在 `cats` 库中如何为 `Either`
    类型定义这样的 Monad Transformer：
- en: '![](img/dc4d33d9-d278-4e58-9eea-5715e0042fb0.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dc4d33d9-d278-4e58-9eea-5715e0042fb0.png)'
- en: Let's have a look at the signature of this Monad Transformer to understand what
    it is. First of all, notice the type parameters of this case class. Instead of
    the usual two type parameters of an ordinary `Either`, we have three type parameters.
    The first parameter is an `F[_]` effect type, and the last two parameters are
    ordinary left and right types. That effect type is precisely what gives this Monad
    Transformer its stackability. So, we can stack it with other effect types by pumping
    these effect types into the type variable. Notice also the argument to the constructor
    of `EitherT`. The argument in question has the `F[Either[A, B]]` type.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个 Monad Transformer 的签名，以了解它是什么。首先，注意这个案例类的类型参数。与普通 `Either` 的两个类型参数不同，我们这里有三个类型参数。第一个参数是一个
    `F[_]` 效果类型，最后两个参数是普通的左右类型。这个效果类型正是赋予这个 Monad Transformer 可堆叠性的原因。因此，我们可以通过将这些效果类型泵入类型变量来与其他效果类型堆叠。注意
    `EitherT` 构造函数的参数。该参数具有 `F[Either[A, B]]` 类型。
- en: Let's imagine that the variable effect type in the preceding example is `Future`.
    Then, the value of `EitherT` will be `Future[Either[A, B]]`. This is precisely
    the signature that we had in our preceding examples when we were trying to stack
    these two effects types.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设想在前面的例子中，变量效果类型是 `Future`。那么，`EitherT` 的值将是 `Future[Either[A, B]]`。这正是我们在前面的例子中尝试堆叠这两种效果类型时所拥有的签名。
- en: So the pattern essentially builds up on top of the naive stacking of effect
    types. However, here we have a case class defined specifically for stacking. How
    does it work, and how does it allow us to combine effect types?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个模式本质上是在效果类型的朴素堆叠之上构建的。然而，这里我们定义了一个专门用于堆叠的案例类。它是如何工作的，以及它是如何允许我们组合效果类型的？
- en: 'First of all, let''s have a look at how the `flatMap` function is defined by
    this data type:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看这个数据类型是如何定义 `flatMap` 函数的：
- en: '![](img/131e54f2-1857-4d05-891d-f87760099a3b.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/131e54f2-1857-4d05-891d-f87760099a3b.png)'
- en: As we can see in the preceding screenshot, the method takes the continuation
    function as an argument, which is something we already know. However, pay attention
    to the first argument of the continuation function. It is `B` here. `B` is the
    type of the `Right` value of `Either`. `Either` is wrapped under the `F` type.
    So, if we are going to use `EitherT` instead of a naive combination of `Future`
    and `Either`, we are going to end up with a `flatMap` function that does exactly
    what we are looking for.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的截图中所看到的，这个方法接受一个作为参数的延续函数，这是我们已知的内容。然而，请注意延续函数的第一个参数。在这里它是`B`。`B`是`Either`的`Right`值的类型。`Either`被包裹在`F`类型下。所以，如果我们打算使用`EitherT`而不是`Future`和`Either`的简单组合，我们最终会得到一个`flatMap`函数，它正好是我们所寻找的。
- en: 'However, also notice that this function implicitly depends on a Monad for the
    side effect type. Which means that in order to extract the result from `EitherT`,
    we need to know how to extract the result from the effect type you are combining
    it with:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，这个函数隐式地依赖于一个用于副作用类型的Monad。这意味着为了从`EitherT`中提取结果，我们需要知道如何从你与之组合的效果类型中提取结果：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'So, arming ourselves with `EitherT`, let''s rewrite the previous example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，武装自己使用`EitherT`，让我们重写之前的例子：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, we now have all of our computations defined in terms of the
    combined effects types. Also, we are able to leave our Monadic flow unchanged,
    meaning that we do not need to worry about extracting the results of our side
    effecting computations manually.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们现在所有的计算都是基于组合效果类型定义的。此外，我们能够保持我们的Monadic流程不变，这意味着我们不需要担心手动提取副作用计算的结果。
- en: If you have a look at the `EitherT` documentation, you will see that it also
    provides you with a bunch of other convenience methods that you can use in the
    setting of nested effect types.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`EitherT`的文档，你会看到它还为你提供了一组其他便利方法，你可以在嵌套效果类型的设置中使用这些方法。
- en: Generalizing the pattern
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式泛化
- en: Obviously, the pattern we discussed previously is not specific to `EitherT`.
    It is something we are frequently going to encounter when dealing with effect
    types. It is not about `Future` and `Either`, but about combining two independent
    types.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们之前讨论的模式并不特定于`EitherT`。这是我们处理效果类型时经常会遇到的事情。这不仅仅关于`Future`和`Either`，而是关于组合两个独立类型。
- en: Since this task repeats from effect type to effect type, it was generalized
    into a pattern. The pattern goes as follows. First, you pick up an effect type
    that you would like to be combinable with other arbitrary effect types. Then,
    you define the alternative combinable version of this type. This way, for `Either`,
    we have defined a combinable version of it, `EitherT`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个任务从效果类型到效果类型都是重复的，它被泛化为一个模式。这个模式是这样的。首先，你选择一个你希望可以与其他任意效果类型组合的效果类型。然后，你定义这个类型的替代组合版本。这样，对于`Either`，我们已经定义了一个可组合的版本，即`EitherT`。
- en: After that, you define all of the necessary type classes of the given effect
    type, optionally depending on whatever you need to make it work, including the
    type classes for the effect type you are going to combine this effect with.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你需要定义给定效果类型的所有必要的类型类，这可以根据你需要使其工作的任何内容进行选择，包括你打算与该效果类型组合的效果类型的类型类。
- en: If you have a look at the data package of the cats library, you will find that
    it has a number of other effects ending with the letter `T`. These are implementations
    of Monad Transformers for the respective effect types.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看cats库的数据包，你会发现它有其他一些以字母`T`结尾的效果。这些是针对相应效果类型的Monad Transformers的实现。
- en: The significance of having Monad Transformers in your toolbox is that now you
    are able to construct effect types from existing effect types like you would from
    Lego blocks. This greatly increases your flexibility; now you do not need to define
    dedicated effect types that would express the side effects you would like to capture.
    If these side effects are expressible as a combination of several other side effects,
    you can use Transformers to create a combined effect type and use it in your applications.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工具箱中拥有Monad Transformers的重要性在于，现在你能够像使用乐高积木一样从现有的效果类型构建效果类型。这大大增加了你的灵活性；现在你不需要定义专门的效果类型来表达你想要捕获的副作用。如果这些副作用可以表示为几个其他副作用的组合，你可以使用Transformers创建组合效果类型并在你的应用程序中使用它。
- en: 'We were observing the combination of two effect types. But, you are not limited
    to the combination of only two effects. In fact, the pattern is sufficient to
    combine any number of effect types into one. For example, this is how such a combination
    might look:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们观察了两种效果类型的组合。但，你不仅限于两种效果类型的组合。实际上，这种模式足以将任何数量的效果类型组合成一个。例如，这样的组合可能看起来是这样的：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since `ReaderT` expects an effect type, `F[_]`, as its first argument, we manually
    make a **hole** in `EitherT` by the means of the question mark—`EitherT[Future,
    String, ?]`. The syntax is not standard to Scala and comes from the Kind Projector
    plugin that is imported in the project''s `build.sbt`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ReaderT` 期望其第一个参数是一个效果类型 `F[_]`，我们通过问号——`EitherT[Future, String, ?]`——手动在
    `EitherT` 中创建一个**空位**。这种语法不是 Scala 的标准语法，而是来自在项目的 `build.sbt` 中导入的 Kind Projector
    插件：
- en: '[PRE17]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `?` in the type signature creates an unbound type variable in a type signature,
    which can be used to give the type the shape of `F[_]`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 类型签名中的 `?` 在类型签名中创建了一个未绑定的类型变量，它可以用来给类型赋予 `F[_]` 的形状。
- en: '`ReaderT[EitherT[Future, String, ?], Config, A]` is a Transformer way to express
    the following type:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReaderT[EitherT[Future, String, ?], Config, A]` 是一种 Transformer 表达方式，用于表示以下类型：'
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: So, when talking about the Monad Transformers pattern, first and foremost we
    are talking about flexibility. However, this is not the only pattern that can
    provide you with extra flexibility when writing your programs in a purely functional
    manner. Next, we will have a look at the Tagless Final.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们谈论 Monad Transformers 模式时，首先和最重要的是我们在谈论灵活性。然而，这并不是唯一可以提供额外灵活性的模式，当你在纯函数式方式编写程序时。接下来，我们将看看无标签最终。
- en: Tagless Final
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无标签最终
- en: Tagless Final is a popular pattern of advanced functional programming that can
    be used to abstract away capabilities and side effects you do not know ahead of
    time and cannot predict. As usual, the best way to see how it works and why it
    is useful is to look at some examples.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 无标签最终（Tagless Final）是高级函数式编程中的一种流行模式，可以用来抽象那些你事先不知道且无法预测的能力和副作用。通常，了解其工作原理和为什么有用的最佳方式是查看一些示例。
- en: Programming to capabilities
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于能力编程
- en: Imagine you are writing an application that is to be executed against more than
    one environment. Such scenarios are common in the real world. A good example is
    mobile applications. You can have multiple mobile platforms. However, you would
    like to publish your applications to all of them. The platforms that exist are
    quite different from each another. And usually, it is pretty tedious to reimplement
    your application for every platform separately. So, you would like to write our
    application once, and somehow make it run against all of the platforms that currently
    exist.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在编写一个需要在多个环境中执行的应用程序。在现实世界中，这样的场景很常见。一个很好的例子是移动应用程序。你可以拥有多个移动平台。然而，你希望将你的应用程序发布到所有这些平台上。现有的平台之间差异很大。通常，为每个平台单独重新实现你的应用程序是非常繁琐的。因此，你希望编写一次应用程序，并使其能够在当前所有存在的平台上运行。
- en: Another example is programming server-side software that should work against
    a wide variety of configurations. For example, the same server-side software is
    executed against different databases. Relational databases are different, and
    procedures that are applicable to one database may not be applicable to another
    database.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是编写应针对广泛配置工作的服务器端软件。例如，相同的服务器端软件针对不同的数据库执行。关系型数据库不同，适用于一个数据库的过程可能不适用于另一个数据库。
- en: In all of the preceding scenarios, you wanted your application's business logic
    not to be affected by the peculiarities of the system you are running your code
    on. In object-oriented programming, a standard way to tackle such an issue is
    to apply a Facade pattern. You declare an interface that lists all of the capabilities
    that you need from the underlying system your application is supposed to be run
    against. After that, for every specific system, you are going to provide an implementation
    of the interface.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有上述场景中，你希望应用程序的业务逻辑不受你运行代码的系统特性的影响。在面向对象编程中，处理此类问题的标准方法是通过应用外观（Facade）模式。你声明一个接口，列出所有你需要从应用程序应该运行的底层系统中获取的能力。之后，对于每个特定的系统，你将为该接口提供一个实现。
- en: The key points to notice from this discussion are the capabilities. Your application
    depends on some capabilities. It is built in terms of the methods exposed by the
    interface that specifies the capabilities in question. This idea also reiterates
    in the Tagless Final pattern.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 从这次讨论中需要注意的关键点是能力。你的应用程序依赖于某些能力。它是根据指定这些能力的接口公开的方法构建的。这个想法也在无标记最终模式中得到了重申。
- en: To make it easier to understand the pattern, let's come up with a simple example
    of an application depending on some capabilities. The first one would be to read
    a resource from the data storage of a system. A resource is a wide notion that
    may include files on one filesystem, access to data over the network on other
    environments, or access to data that is stored in a database and other environments.
    Another capability will be the notification capability, which means the application
    is able to notify the end user of whatever job it is doing with the data retrieved
    from the storage.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使模式更容易理解，让我们来一个简单的应用程序示例，这个应用程序依赖于某些能力。第一个将是从系统的数据存储中读取资源。资源是一个广泛的概念，可能包括一个文件系统上的文件，在其他环境中通过网络访问数据，或者访问存储在数据库和其他环境中的数据。另一个能力将是通知能力，这意味着应用程序能够通知最终用户它正在使用从存储中检索到的数据进行的工作。
- en: Given these two capabilities, it is possible to write a wide range of processing
    applications. Once we have abstracted away the effects of reading and notifying,
    we can build a processing application in terms of these effects.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这两个能力，我们可以编写一系列处理应用程序。一旦我们抽象掉了读取和通知的效果，我们就可以根据这些效果构建一个处理应用程序。
- en: 'How would we define such capabilities in a functional manner? What would make
    the most sense? Previously, we discussed the idea of a type class. We have also
    noted that a type class is very similar to a toolbox, which means it provides
    you with a set of tools that you can use for a certain purpose. That analogy is
    ideal for our case of storing capabilities. Capabilities are also, in a sense,
    tools, and tools can be united into toolboxes. So, it is conceivable to define
    a type class with the capabilities we need as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该如何以函数式的方式定义这样的能力？什么最有意义？之前，我们讨论了类型类的想法。我们还注意到，类型类非常类似于工具箱，这意味着它为你提供了一组你可以用于特定目的的工具。这种类比非常适合我们存储能力的案例。在某种程度上，能力也是工具，工具可以组合成工具箱。因此，我们可以定义一个类型类，其中包含我们需要的所有能力，如下所示：
- en: '[PRE19]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Notice that we define the type class for an `f` effect type. Since we are working
    in the functional paradigm, and the capabilities are likely to produce side effects,
    we are going to describe these side effects by some effect type that we may not
    know ahead of time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们为`f`效果类型定义了类型类。由于我们正在函数式范式下工作，而且能力很可能会产生副作用，我们将通过一些我们可能事先不知道的效果类型来描述这些副作用。
- en: 'Next, we can define an application in terms of these capabilities provided
    by the type class. Imagine the resources that we are going to retrieve with the
    help of our capabilities are reports of the sales of some online shopping:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以用类型类提供的这些能力来定义一个应用程序。想象一下，我们将借助我们的能力来检索的资源是一些在线购物销售的报告：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Consider that this document is updated every day, and the objective of our
    application is to calculate the amount of money the business has made over the
    day and to notify the owner about the income. We can implement it as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这份文档每天都会更新，我们应用程序的目标是计算一天内业务所赚取的金额，并通知所有者关于收入的情况。我们可以这样实现：
- en: '[PRE21]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice how the preceding method is defined in terms of the `F` effect type and
    its subclasses. Notice how we do not know ahead of time which effect type we are
    going to use here. However, we know exactly which capabilities this effect type
    must have—the capabilities that we defined earlier, but we also need a Monad.
    This is because we need to sequentially combine capabilities defined in our custom
    type class. Then, we define our application in terms of our capabilities.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面的方法是如何根据`F`效果类型及其子类来定义的。注意，我们事先并不知道我们将使用哪种效果类型。然而，我们知道这个效果类型必须具备哪些能力——就是我们之前定义的能力，但我们还需要一个Monad。这是因为我们需要按顺序组合我们在自定义类型类中定义的能力。然后，我们根据我们的能力来定义我们的应用程序。
- en: An important thing to notice here is how our capabilities become defined in
    the same language as the other type classes. This means that, potentially, we
    have the entire power of the `cats` library or any other libraries for functional
    programming.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的一个重要事项是，我们的能力是如何在与其他类型类相同的语言中定义的。这意味着，潜在地，我们拥有`cats`库或任何其他函数式编程库的全部功能。
- en: This is what makes the Tagless Final pattern different from the Facade pattern.
    In Facade, you have the interfaces that hide the complex functionality that is
    platform-specific and that you do not care about. However, this is it. Whenever
    we call such a capability, we get the result you are requesting and nothing else.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是无标签最终模式与门面模式不同的地方。在门面模式中，你有接口，这些接口隐藏了平台特定的复杂功能，这些功能你并不关心。然而，这就是全部。每次我们调用这样的能力时，我们都会得到你请求的结果，没有其他。
- en: In the Tagless Final pattern, whenever you are calling a capability method,
    you are getting a result under an effect type. An effect type is a data structure
    that has certain properties. You may not have control over exactly what result
    the capability returns because it is system-specific. However, you have control
    over the data structure in which this result is returned. The data structure in question
    is specified by the type parameter. Different data structures have different capabilities.
    In other functions, when we specified that we implicitly needed a Monad, we stated
    something about the structure we are going to work under. We can state that our
    effect type is to be sequentially composable. In the same way, by specifying implicit
    dependencies on other cats type classes, we can state other requirements of our
    data structure.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在无标签最终模式中，每次调用能力方法时，你都会在效果类型下得到一个结果。效果类型是一种具有某些属性的数据结构。你可能无法控制能力返回的确切结果，因为它具有系统特定性。然而，你控制着返回此结果的数据结构。所涉及的数据结构由类型参数指定。不同的数据结构具有不同的能力。在其他函数中，当我们指定我们隐式需要Monad时，我们陈述了关于我们将要工作的结构的一些内容。我们可以声明我们的效果类型应该是顺序可组合的。同样，通过指定对其他cats类型类的隐式依赖，我们可以声明我们对数据结构的其他要求。
- en: This control over the data structure we are working under gives us control over
    how we can compose our computation. So, in the Facade pattern, only the platform-specific
    capabilities themselves get abstracted away, and that's it. However, in the Tagless
    Final pattern, not only do the computations get abstracted away, but the way we
    compose our program gets abstracted away under the `f` effect type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对我们正在工作的数据结构的控制使我们能够控制我们的计算如何组合。因此，在门面模式中，只有平台特定的能力本身被抽象化，仅此而已。然而，在无标签最终模式中，不仅计算被抽象化，而且我们在`f`效果类型下组合程序的方式也被抽象化。
- en: Now, once we have the abstract program composed, a reasonable question to ask
    would be how do we actually run it against different environments?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们有了抽象程序的组合，一个合理的问题就是我们如何实际上在不同的环境中运行它？
- en: Implementations
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现方式
- en: In order to run this application against a given environment, we need to specify
    the effect type we are going to be working under. Besides the target effect type,
    we need to find the implementation for all of the implicit dependencies that our
    function requires. The beauty of the Tagless Final pattern is that we can run
    the function against any environment, as long as we can provide the implementation
    of our implicit dependencies for this environment and for the effect type of our
    choice.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在给定的环境中运行此应用程序，我们需要指定我们将要工作的效果类型。除了目标效果类型之外，我们还需要找到我们函数所需的全部隐式依赖的实现。无标签最终模式的美丽之处在于，只要我们能提供此环境以及我们选择的效果类型的隐式依赖实现，我们就可以在任意环境中运行该函数。
- en: 'The first step is to specify the effect type. A good choice would be Future,
    since it is a concurrency primitive, and capable of representing a wide range
    of computations. So, with the effect type set to Future, we will have our method
    called as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是指定效果类型。一个好的选择是Future，因为它是一种并发原语，能够表示广泛的计算。因此，当效果类型设置为Future时，我们的方法调用将如下所示：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: However, the preceding code will not compile since we do not yet have an implementation
    of the  `Capabilities` type class for Future.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的代码将无法编译，因为我们还没有为Future实现`Capabilities`类型类。
- en: 'Now when we are talking about the capabilities we need, we need to ask ourselves
    against which environment we are working in. Remember that the capabilities abstract
    the operations that are different from environment to environment. First, let''s
    imagine we are working against an ordinary desktop environment and a command-line
    application scenario. In this case, our retrieve resource capability would be
    simply reading a file with a given name from a standard directory. Our notification
    capability will print the output to the command line:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们讨论我们需要的能力时，我们需要问自己我们正在哪个环境中工作。记住，能力抽象了不同环境之间的不同操作。首先，让我们想象我们正在一个普通的桌面环境和一个命令行应用程序场景中工作。在这种情况下，我们的检索资源能力将仅仅是读取一个标准目录中给定名称的文件。我们的通知能力将输出打印到命令行：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We are using an Apache Commons IO library to read a file, conveniently. We are
    doing everything under the concurrency primitive future because this is the requirement
    of our application. Notice how all the technical details of notifying and reading
    the file are concentrated in that type class only, to the point where we can import
    the `File` and `FileUtils` classes only in the scope of this type class and not
    the scope of the entire file.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Apache Commons IO库方便地读取文件，我们在并发原语future下做所有的事情，因为这是我们应用程序的要求。注意，所有关于通知和读取文件的技术细节都集中在那个类型类中，以至于我们只能在类型类的范围内导入`File`和`FileUtils`类，而不能在整个文件的范围内导入。
- en: 'Once we run the preceding application against the given file, we are going
    to receive the following output:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将前面的应用程序运行在给定的文件上，我们将收到以下输出：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'What if we now need to run the application against an environment that uses
    a database to store the data? What if that notification is done via email and
    not via the command line? No problem, we still can use the same application. However,
    we will need to provide a custom implementation of the capabilities for this environment:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在需要在一个使用数据库存储数据的环境中运行应用程序怎么办？如果通知是通过电子邮件而不是通过命令行完成的怎么办？没问题，我们仍然可以使用同一个应用程序。然而，我们将需要为此环境提供一个自定义的能力实现：
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In the preceding code, we have implemented a type class in terms of stubs, because
    implementing the database query logic and an email notification logic can be pretty
    tedious. However, our application now compiles. So, if you substitute the implementation
    of the database query and email dispatch in the preceding type class, you will
    also be able to run the application successfully. Since this implementation is
    outside the scope of this book and does not bring any value to the discussion
    of the Tagless Final pattern, we will not provide the implementation here.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过桩（stubs）实现了类型类，因为实现数据库查询逻辑和电子邮件通知逻辑可能相当繁琐。然而，我们的应用程序现在可以编译了。所以，如果你替换前面类型类中的数据库查询和电子邮件分发的实现，你也将能够成功运行应用程序。由于这个实现超出了本书的范围，并且不会对Tagless
    Final模式的讨论带来任何价值，所以我们不会在这里提供实现。
- en: In a similar manner, we are able to provide the implementation for almost any
    platform that you can imagine.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们能够为几乎任何你可以想象的平台提供实现。
- en: You can also do the preceding really well with the Facade pattern. So how is
    Tagless Final more powerful than the Facade pattern? Why would you use it instead
    of the object-oriented pattern? The crucial detail in discussing the power of
    the Tagless Final pattern is to notice that our application depends not only on
    the capabilities type class but also on the Monad type class. So how does that
    bring more power than a Facade pattern? Let's have a look at it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用外观模式（Facade pattern）做得很好。那么，Tagless Final模式比外观模式更强大在哪里？为什么你会选择它而不是面向对象模式？讨论Tagless
    Final模式的力量时的关键细节是注意到我们的应用程序不仅依赖于能力类型类，还依赖于Monad类型类。那么，这如何比外观模式带来更多的力量？让我们看看。
- en: Execution semantics abstraction
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行语义抽象
- en: The capabilities type class is on equal ground with the `Monad` type class.
    The `Monad` type class defines how you would compose the computation sequentially.
    There is a saying that Monad is the semicolon of functional programming. Why would
    people say that? What is the role of a semicolon in object-oriented programming? In
    ordinary imperative programming, a semicolon is a symbol that separates one statement
    from another. The meaning of a semicolon is that one statement should be executed
    after another statement. In a sense, you can treat a semicolon as an operator
    of the sequential combination of two computation.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 能力类型类与`Monad`类型类处于同等地位。`Monad`类型类定义了您如何顺序组合计算。有句话说，单子是函数式编程的分号。人们为什么会这么说？分号在面向对象编程中扮演什么角色？在常规的命令式编程中，分号是一个分隔一个语句与另一个语句的符号。分号的意义是，一个语句应该在另一个语句之后执行。在某种意义上，您可以将分号视为两个计算顺序组合的运算符。
- en: The `flatMap` function does exactly that for the functional programming world.
    `flatMap` defines how to sequentially composed two computations. So, this makes
    it a semicolon of functional programming. Also, earlier in the book, we looked
    at the Monadic flow pattern. We know that Monadic flow relies on `flatMap` under
    the hood to represent the functional code that is composed sequentially. In this
    way, it is very similar to the imperative semicolons.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap`函数在函数式编程世界中正是为此目的而设计的。`flatMap`定义了如何顺序组合两个计算。因此，这使得它成为函数式编程中的分号。此外，在本书的早期，我们探讨了单子流模式。我们知道单子流在底层依赖于`flatMap`来表示顺序组合的函数式代码。这种方式与命令式分号非常相似。'
- en: How is that important for our discussion of the advantage of the Tagless Final
    pattern? The point is that an application that depends on Facade does not usually
    depend on any anything similar to a Monad.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于我们讨论无标签最终模式的优点有何重要意义？关键在于，依赖于外观（Facade）的应用通常不会依赖于任何类似于单子（Monad）的东西。
- en: This means that you may substitute a different Facade in your application for
    different environments. However, you will never be able to change the semantics
    of the sequential execution of your statements.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着您可以在不同的环境中用不同的外观（Facade）替换您的应用程序。然而，您永远无法改变您语句顺序执行的语义。
- en: 'Let''s see how it works on an example. Let''s say that we need to perform logging
    while executing the preceding application. What do we do to make it possible?
    We can provide a custom implementation of Monad with its `flatMap` function, the
    sequential composition operator, been overloaded to log everything we need:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来看看它是如何工作的。假设我们需要在执行前面的应用程序时进行日志记录。我们该如何实现这一点？我们可以提供一个自定义的`Monad`实现，其中包含其`flatMap`函数，顺序组合运算符被重载以记录我们所需的所有内容：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can run the application by pointing the `income` method explicitly to which
    type classes to use:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过显式地将`income`方法指向要使用的类型类来运行应用程序：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And the output will be as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果将如下所示：
- en: '![](img/a0228057-b872-4f7f-bca7-a3e59eae04b8.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a0228057-b872-4f7f-bca7-a3e59eae04b8.png)'
- en: Here, we are able to overload the very semantics of sequential composition.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们能够覆盖序列组合的语义。
- en: 'Can a similar effect be achieved in the imperative world? Let''s have a look
    at how the preceding example could be implemented with the Facade pattern:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式世界中能否实现类似的效果？让我们看看前面的例子如何使用外观（Facade）模式实现：
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we have an interface, and the method `income` depends
    on the type class that performs the computation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们有一个接口，方法`income`依赖于执行计算的类型类。
- en: We are not able to override sequential composition, because the only point of
    control is the interface. We do not have control over how the computations are
    executed and combined with one another.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无法覆盖序列组合，因为唯一的控制点在于接口。我们无法控制计算是如何执行以及如何相互组合的。
- en: But why is that possible in the functional world and not in the imperative world?
    What makes the functional approach so special that we are able to do this kind
    of abstraction of combinational semantics?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 但为什么在函数式世界中可以做到这一点，而在命令式世界中却不行？是什么使得函数式方法如此特别，使我们能够进行这种组合语义的抽象？
- en: Computation as a value
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 计算作为值
- en: When discussing side effects and abstraction, we argued that functional programming
    aims for purity. And whenever we have some computation that has a side effect,
    we are reifying this computation into some value. Here, the value is `Future`.
    All our computations are reified into Future. And we are able to combine `Future`
    using the operators defined for it.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当讨论副作用和抽象时，我们提到函数式编程追求纯净性。每当有计算带有副作用时，我们都会将这个计算具体化为某个值。在这里，这个值是`Future`。我们所有的计算都被具体化为Future。并且我们可以使用为其定义的运算符来组合`Future`。
- en: In the imperative world, we are not able to perform the similar combination
    of computations, since the computations are not reified to values. We are not
    able to play around with computations in the imperative world because computations
    are not a thing there. There is no way for us to refer to a computation. At least
    no obvious way. Of course, in Java, we can stuff the computation under the Runnable
    interface. However, it will be quite cumbersome. In the functional world, Monads
    are ubiquitous in sequential composition. Everything is composed using `flatMap`.
    In Java, wrapping everything in Runnable would introduce too much architectural
    overhead, so it is not worth it.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在命令式世界中，我们无法执行类似的计算组合，因为计算并没有被具体化为值。在命令式世界中，我们无法随意操作计算，因为那里计算并不是一个实体。我们无法引用计算，至少没有明显的方法。当然，在Java中，我们可以将计算放在Runnable接口下。然而，这将相当繁琐。在函数式世界中，Monads在顺序组合中无处不在。所有东西都是通过`flatMap`来组合的。在Java中，将所有东西都包裹在Runnable中会引入过多的架构开销，所以这并不值得。
- en: However, one might argue that Futures are not pure. Whenever we instantiate
    Future, we give an instruction for a computation to start. Is there an even stronger
    version of the Tagless Final pattern that provides us with some more expressive
    power?
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有人可能会争论Future并不纯净。每当实例化Future时，我们都会给出一个启动计算的指令。是否存在一个更强的无标记最终模式版本，为我们提供更多的表达能力？
- en: Free Monad
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Free Monad
- en: The Free Monad  pattern is a stronger version of the Tagless Final pattern.
    Actually, the free object is a structure from abstract algebra. Hence the name
    comes from this domain.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Free Monad模式是Tagless Final模式的更强版本。实际上，自由对象是来自抽象代数的一个结构。因此，这个名字来源于这个领域。
- en: The application of the pattern is rather limited, and most likely we will not
    encounter any real necessity for the pattern while only starting purely functional
    programming. So we will not go in depth about the Free Monad here. However, we
    will describe in general how it works.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式的适用范围相当有限，很可能在刚开始纯函数式编程时，我们不会遇到任何对这种模式的真实需求。所以在这里我们不会深入探讨Free Monad。然而，我们将一般性地描述它是如何工作的。
- en: Basically, the idea behind the Free Monad is that all of our computations become
    a value. The idea is that whenever we define our application, it does not really
    execute itself, but constructs an abstract syntax tree that describes the application
    that we can run later. And it is our responsibility to execute it afterward.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Free Monad背后的想法是，所有的计算都变成了一个值。这个想法是，每当定义我们的应用程序时，它实际上并没有执行自己，而是构建了一个描述我们可以稍后运行的抽象语法树。然后执行它就是我们的责任。
- en: The pattern is quite heavyweight, so the preceding example offers only the gist
    of it. Another thing to notice is that whenever we need to apply the Free Monad
    pattern, we can still leverage the Tagless Final pattern. Here, we saw how defining
    a custom implementation for the Monad can be helpful to inject custom functionality,
    such as logging. The same idea can be used to construct a tree out of our application.
    Ordinarily, the meaning of the sequential composition is to run one statement
    after another. It is easy to imagine an implementation of the sequential composition
    where the statements are not executed one after another but are reified into tree
    nodes and get injected into a tree that represents your application. Remember
    that `flatMap` has full control over how it continues the computation. So it is
    perfectly normal to imagine a `flatMap` function that does not run statements
    but uses them to construct a tree.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式相当重量级，所以前面的例子只是概述了它。另一个需要注意的事情是，无论何时我们需要应用Free Monad模式，我们仍然可以利用Tagless Final模式。在这里，我们看到了定义一个自定义的Monad实现如何有助于注入自定义功能，例如日志记录。同样的想法可以用来构建我们的应用程序的树。通常，顺序组合的意义是依次运行一个语句。很容易想象一个顺序组合的实现，其中语句不是依次执行，而是被具体化为树节点，并注入到一个代表应用程序的树中。记住，`flatMap`完全控制着如何继续计算。所以想象一个`flatMap`函数不运行语句而是使用它们来构建一个树是完全正常的。
- en: 'Why might we want to use the Free Monad pattern? The idea here is to be able
    to run the computation against more than one interpreter. A concrete example comes
    from the `doobie` library for working with SQL. In Doobie, a SQL statement can
    be written as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为什么想要使用Free Monad模式呢？这里的想法是能够对多个解释器运行计算。一个具体的例子来自用于处理SQL的`doobie`库。在Doobie中，一个SQL语句可以写成以下形式：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Here, we are using string interpolation, a feature of Scala that allows us to
    generate objects from strings on compile-time.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用字符串插值，这是Scala的一个特性，允许我们在编译时从字符串生成对象。
- en: 'After executing this statement, we will perform several calls on the object
    specifying what we want to do with the SQL statement, such as whether we want
    to query or update the database. For example, if we want to query the database,
    we can do the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 执行这个语句之后，我们将对该对象进行几次调用，以指定我们想要对SQL语句执行的操作，例如我们是否想要查询或更新数据库。例如，如果我们想要查询数据库，我们可以做以下操作：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: One common task when working with SQL from programming languages is to provide
    as much safety as possible while calling the database. For example, we might want
    to answer the question of whether our query is formed correctly. We might want
    to have an entire test suite where we have all of our queries that we are using,
    and we test them to check whether they are formed correctly and whether their
    return types are the ones that we expect.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当从编程语言处理SQL时，一个常见的任务是尽可能提供安全性，在调用数据库时。例如，我们可能想要回答我们的查询是否形成正确的问题。我们可能想要有一个完整的测试套件，其中包含我们正在使用的所有查询，并测试它们以检查它们是否形成正确，以及它们的返回类型是否是我们预期的。
- en: Internally, Doobie represents its SQL queries with free objects, which means
    that they are just data structures that specify the computation to be performed
    against a database. Since it is just a description of the computation and not
    the computation itself, we can either run it or do anything else with it. One
    of the things that we might want to do is to check whether it is correct against
    certain rules. This is done in Doobie. Here, we can either run our queries against
    an interpreter that will query the database, or that will check their correctness.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，Doobie使用自由对象来表示其SQL查询，这意味着它们只是指定对数据库执行的计算的数据结构。由于它只是计算的描述而不是计算本身，我们可以运行它或对它做任何其他事情。我们可能想要做的事情之一是检查它是否满足某些规则。这是在Doobie中完成的。在这里，我们可以运行我们的查询，要么是对查询数据库的解释器，要么是检查它们的正确性。
- en: So basically, in such situation when we have a computation that we might want
    to run against different interpreters, or we might want to pass around and modify
    by other computational, we might want to use a Free Monad.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，在这种情况下，当我们有一个可能想要在不同的解释器上运行的计算，或者我们可能想要传递并修改其他计算时，我们可能想要使用Free Monad。
- en: A word of caution should be said as the pattern is heavyweight, it should not
    be used without a good reason, or else the overhead in terms of architecture will
    be pretty high.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 应该提醒一点，这个模式相当重量级，如果没有充分的理由，就不应该使用它，否则在架构方面的开销将会相当高。
- en: Speaking of the safety of your application, you can achieve a high grade of
    safety and stability if you perform as many computations as possible at compile-time.
    The very basics of programming to type classes is having a strong compiler with
    a strong type system that is capable of injecting proper type classes for you.
    Can such a strong compiler be harnessed to perform more than just injecting capabilities
    and type classes into your computations? Let's step into the world of type-level
    programming in the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 说到应用程序的安全性，如果你尽可能在编译时执行尽可能多的计算，你就可以达到很高的安全性和稳定性。编程到类型类的基本原则是拥有一个强大的编译器，它具有强大的类型系统，能够为你注入适当的类型类。这样的强大编译器能否被用来执行不仅仅是注入能力和类型类到你的计算中呢？让我们在下一节进入类型级编程的世界。
- en: Type-level programming
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型级编程
- en: The job of the compiler is to translate your program from one set of instructions
    into another. In high-level languages, you translate higher-level instructions
    that are easy to read and write for people to lower-level instructions that are
    easy for machines to execute.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器的任务是把你编写的程序从一套指令翻译成另一套指令。在高级语言中，你将易于阅读和编写的高级指令翻译成易于机器执行的低级指令。
- en: Since the compiler needs to perform a conversion of one set of symbols into
    another set of symbols, it builds some internal model of the program that you
    are writing. In a sense, we can say that the compiler understands the program,
    for some definition of **understands**.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器需要将一套符号转换成另一套符号，它构建了你正在编写的程序的一些内部模型。从某种意义上说，我们可以认为编译器理解了程序，这里的“理解”有特定的定义。
- en: If the compiler builds an internal model or understands your program in some
    other way, we can also harness the power of compiler to make the compiler check
    for the correctness of the program. We can make the compiler impose and enforce
    certain styles or guarantees that your program must obey. We have already seen
    an example of `annotation.tailrec`. The job of the annotation was to instruct
    the compiler to check the annotated function to have certain guarantees about
    it. Concretely, the compiler checked the function to be tail-recursive.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果编译器以某种方式构建内部模型或理解你的程序，我们也可以利用编译器的力量来让编译器检查程序的正确性。我们可以让编译器强制执行某些风格或保证，你的程序必须遵守。我们已经看到了`annotation.tailrec`的例子。注解的目的是指示编译器检查注解函数并确保它具有某些保证。具体来说，编译器检查函数是否是尾递归的。
- en: To ensure correctness of your program, we may well use a strongly typed language,
    and encode the guarantees and the semantics of your program in types. The types
    are known to the compilers, and hence, it can perform certain checks on these
    types. For example, it can make sure that you supplied an argument of the correct
    type to a function because it knows the input type of the function. So, in a strongly-typed
    language, no longer can you make the mistake of passing an argument of the wrong
    type to a function.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保程序的正确性，我们可能会使用强类型语言，并在类型中编码程序的保证和语义。类型是编译器所知的，因此它可以对这些类型执行某些检查。例如，它可以确保你向函数提供了正确的类型参数，因为它知道函数的输入类型。因此，在强类型语言中，你不再可能犯向函数传递错误类型参数的错误。
- en: The advantage of having strong compilers that check the program for mistakes
    is that you are able to catch more errors at compile-time. In general, errors
    that are caught at compile-time are much easier to debug and fix. If an error
    happens at runtime, it means that it is not discovered right away. You may release
    your application to the end user, and for particularly tricky bugs, months and
    even years can pass before they are discovered. Once they are discovered, you
    need to investigate the erroneous behavior yourself throughout the codebase and
    try to reproduce it so that you can fix it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 强大的编译器检查程序中的错误的优势在于你能够在编译时捕获更多的错误。一般来说，在编译时捕获的错误更容易调试和修复。如果在运行时发生错误，这意味着它没有立即被发现。你可能会将应用程序发布给最终用户，对于特别棘手的错误，可能需要数月甚至数年才能被发现。一旦被发现，你需要自己调查整个代码库中的错误行为，并尝试重现它，以便修复它。
- en: Compile-time errors are manifested right away. When you compile the code, you
    see exactly how and where you went wrong. So there is an obvious advantage to
    making sure the compiler can catch as many errors as possible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 编译时错误立即显现。当你编译代码时，你会确切地看到你出错的地方。因此，确保编译器尽可能多地捕获错误是一个明显的优势。
- en: Can we push our compiler even further? Let's have a look at an example of the
    type-level programming in Scala. It is called type-level because we aim to encode
    as many guarantees about our program as possible in the types. This way, these
    guarantees are checked at compile-time.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否进一步推动我们的编译器？让我们看看Scala中类型级编程的一个例子。它被称为类型级编程，因为我们旨在尽可能在类型中编码关于我们程序的各种保证。这样，这些保证在编译时进行检查。
- en: A naive implementation of the heterogeneous list
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异构列表的简单实现
- en: 'Consider that we have the following list:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑我们有以下列表：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'So, in the preceding list, we have elements of different types, and hence we
    are forced to declare this list as `List[Any]`. `Fraction` is defined for the
    purpose of our example as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在前面的列表中，我们有不同类型的元素，因此我们被迫将此列表声明为`List[Any]`。`Fraction`是为了我们的示例定义的，如下所示：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that in the preceding list, each element can be represented as a floating-point
    number. They have different types, but it is possible to define certain common
    behavior on all of these types. Since the elements are very similar to each other,
    we might want to perform a common operation on them. For example, we may want
    to find the sum of all the numbers in the list:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的列表中，每个元素都可以表示为一个浮点数。它们有不同的类型，但可以在所有这些类型上定义某些共同的行为。由于元素之间非常相似，我们可能想要对它们执行一个共同的操作。例如，我们可能想要找到列表中所有数字的总和：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Notice that we are not able to sum all elements right away because the type
    of the list is `List[Any]`. We can only add up a list composed of numbers. Hence,
    we map our list so that it becomes `List[Double]`. After that, we call the same
    method on this list, which is a standard method defined for all numeric collections
    defined by the Scala collections framework.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法立即求和所有元素，因为列表的类型是`List[Any]`。我们只能加起来由数字组成的列表。因此，我们将我们的列表映射为`List[Double]`。然后，我们在这个列表上调用相同的方法，这是由Scala集合框架定义的所有数值集合的标准方法。
- en: 'In the screenshot below, we can see the output of the program:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的截图中，我们可以看到程序的输出：
- en: '![](img/01ddaf44-f7b8-42fb-b81a-8321149931b6.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/01ddaf44-f7b8-42fb-b81a-8321149931b6.png)'
- en: 'However, notice the body of the `map` method. The body of the `map` method
    is actually a partial function. A partial function is a function that is not guaranteed
    to be able to handle an entire domain on which it is defined. Let''s look at the
    signature of the `map` function, as follows:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意`map`方法的主体。`map`方法的主体实际上是一个部分函数。部分函数是一个不保证能够处理其定义在整个域上的整个函数。让我们看看`map`函数的签名，如下所示：
- en: '![](img/6dd64495-778e-488a-9d1a-24c83f9df650.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6dd64495-778e-488a-9d1a-24c83f9df650.png)'
- en: In the preceding screenshot, you can see that it expects a function from the
    type of the elements of the list to some other type, `B`. The type of our elements
    is any. However, the function that we have passed to our function is a partial
    function, meaning that it is only capable of handling a subset of all possible
    object in Scala.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图里，你可以看到它期望从列表元素的类型到某种其他类型`B`的函数。我们元素的类型是任何类型。然而，我们传递给函数的函数是一个部分函数，这意味着它只能处理Scala中所有可能对象的一个子集。
- en: 'That problem with partial functions is that they are computed at runtime. This
    means, if you forget to specify a certain clause in the partial function, you
    will not find out about that until the runtime when the application will throw
    a match error signifying that the partial function was not able to handle its
    input. Let''s simulate this situation:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 部分函数的问题在于它们是在运行时计算的。这意味着，如果你忘记在部分函数中指定某个子句，你将在运行时发现这一点，此时应用程序将抛出一个匹配错误，表示部分函数无法处理其输入。让我们模拟这种情况：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We have commented out one of the `case` clauses of our partial function that
    we used to map the list. What happens if we run this application? See the following:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经注释掉了我们用于映射列表的部分函数中的一个`case`子句。如果我们运行这个应用程序会发生什么？请看以下内容：
- en: '![](img/c3d10b5a-4c72-42c1-9299-09e167e6b7f5.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c3d10b5a-4c72-42c1-9299-09e167e6b7f5.png)'
- en: As you can see, an exception was thrown. The program was compiled successfully,
    however, when we tried to run it, we had an exception. This means something went
    wrong at runtime. Is there a way to make the compiler track these kinds of errors,
    and handle them at compile-time?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，抛出了一个异常。程序编译成功，然而，当我们尝试运行它时，我们遇到了异常。这意味着在运行时出了问题。有没有办法让编译器跟踪这些错误，并在编译时处理它们？
- en: Type-level solution to the heterogeneous list problem
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异构列表问题的类型级解决方案
- en: The strategy for solving this problem is to encode the guarantees that we want
    to have in types. We will leverage the highly-developed mechanism of implicit
    resolution to enforce that guarantee on a certain type. The general idea is to
    have a guarantee presented by an implicit value. And if we need a certain guarantee
    about our program, we make our program implicitly depend on the value that represents
    this guarantee.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的策略是将我们想要拥有的保证编码到类型中。我们将利用高度发展的隐式解析机制来强制执行对特定类型的保证。一般想法是，通过一个隐式值来表示保证。如果我们需要关于我们程序的一定保证，我们使我们的程序隐式依赖于代表这个保证的值。
- en: The catch is that the application will not compile if the compiler does not
    find any of the implicits the program depends on. So, by making the program depend
    on the implicits that represent our guarantees, and making sure these values are
    present in scope only if the guarantee is satisfied, we can make sure is that
    the compiler will not compile a program that does not satisfy this guarantees.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 但问题是，如果编译器找不到程序所依赖的任何隐式值，应用程序将无法编译。因此，通过使程序依赖于代表我们保证的隐式值，并确保这些值仅在保证得到满足的情况下存在于作用域中，我们可以确保编译器不会编译不满足这些保证的程序。
- en: 'However, first of all, we need types. The preceding solution of a `List[Any]` is
    not good for our application because the compiler does not have the information
    about the precise types of the elements of the list. Instead, we can define a
    data structure called a heterogeneous list. The code for this new list is as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，首先，我们需要类型。前面的`List[Any]`解决方案对我们应用程序来说不好，因为编译器没有关于列表元素精确类型的信息。相反，我们可以定义一个称为异构列表的数据结构。这个新列表的代码如下：
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Above, `jvm` is a package under which the JVM examples of this book are implemented.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，`jvm`是这个书中JVM示例实现的包。
- en: A heterogeneous list is a recursive data structure. If you have a look at the
    `:::` value, this `case` class is composed of a head and a tail. The head can
    be anything you like, and the tail must be another instance of the heterogeneous
    list. The terminal case of the recursive data type is `HNil`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 异构列表是一种递归数据结构。如果你看一下`:::`值，这个`case`类由头部和尾部组成。头部可以是任何你喜欢的，而尾部必须是另一个异构列表的实例。递归数据类型的终端情况是`HNil`。
- en: 'Here is how we can define such a list in your application:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在您的应用程序中定义此类列表的方法：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Notice how this list is aware of the types of each of its arguments. Also,
    notice how in Scala, we can leverage the infix notation that allows us to use
    names of types as operators. Take a look at the following type:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这个列表如何知道每个参数的类型。此外，注意在Scala中，我们可以利用中缀表示法，这允许我们使用类型名称作为运算符。看看以下类型：
- en: '[PRE37]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'It is equivalent to the following standard notation:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 它等价于以下标准表示法：
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is syntactic sugar to facilitate so-called algebraic data types. Algebraic
    data types are data types that are composed of other data types in a type-safe
    manner.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种语法糖，用于简化所谓的代数数据类型。代数数据类型是以类型安全的方式由其他数据类型组成的类型。
- en: 'Next, how would we define an application that will compute a sum on a heterogeneous
    list? Previously, in a partial function example, we saw that another problem was
    compile-time safety. And here, we would like to include certain guarantees into
    our code. We want the compiler to check these guarantees. What guarantees would
    you like to impose? First of all, we need to make sure that our list can be mapped
    to a list where everything is a double. Previously, we did it using a partial
    function that is only run on the runtime. Here, we have agreed to use implicit
    to specify the guarantees about our application. Hence, we can have our summation
    method as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们如何定义一个将在异构列表上计算总和的应用程序？之前，在一个部分函数示例中，我们看到了另一个编译时安全性的问题。在这里，我们希望将某些保证纳入我们的代码。我们希望编译器检查这些保证。你希望施加哪些保证？首先，我们需要确保我们的列表可以被映射到一个所有元素都是双精度浮点数的列表。之前，我们使用只运行在运行时的部分函数来完成这个任务。在这里，我们同意使用隐式来指定关于我们应用程序的保证。因此，我们的求和方法可以这样：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '`MapToDouble` is a type class that we have just come up with. The job of the
    type class is to convert a heterogeneous list so that all of its elements are
    doubles. Notice that we pass a type parameter to this type class. It is the `L` type,
    which extends the heterogeneous list. `L` extends the heterogeneous list and is
    an algebraic data type, which means it is a composite data type that is composed
    of the types of all of the elements of this list. This means that at compile-time,
    the type class will be aware of the types of all the elements present in this
    heterogeneous list, which means it is possible to define the type class so that
    we will not be able to resolve it if the members of the list are not convertible
    to double.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapToDouble`是我们刚刚提出的一个类型类。类型类的任务是转换一个异构列表，使其所有元素都是双精度浮点数。请注意，我们向这个类型类传递一个类型参数。它是`L`类型，它扩展了异构列表。`L`扩展了异构列表，是一个代数数据类型，这意味着它是一个复合数据类型，由这个列表中所有元素的类型组成。这意味着在编译时，类型类将知道这个异构列表中所有元素的类型，这意味着我们可以定义类型类，使得如果列表的成员不能转换为双精度浮点数，我们就无法解析它。'
- en: 'Are those all the guarantees we need? In principle, once we have a guarantee
    and a way to convert our heterogeneous list to a list of doubles, it may not be
    difficult to traverse the data structure recursively and sum up all of its values.
    So, the summation method using the `MapToDouble` type class only can be implemented
    as follows:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要的所有保证吗？原则上，一旦我们有一个保证，并且有一种方法将我们的异构列表转换为双精度浮点数列表，递归遍历数据结构并求和所有值可能并不困难。所以，使用`MapToDouble`类型类的求和方法只能实现如下：
- en: '[PRE40]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Notice that we again are using a partial function to abstract the values from
    the recursive data structure of the heterogeneous list. We terminate our or question
    once we reach `HNil`. However, we have argued previously that partial functions
    are bad because they can fail at runtime. Therefore, it can be instructive to
    see how we can avoid usage of a partial function here.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们再次使用部分函数来抽象异构列表的递归数据结构中的值。一旦我们达到`HNil`，我们就终止我们的或问题。然而，我们之前已经论证过，部分函数是糟糕的，因为它们可能在运行时失败。因此，了解我们如何避免在这里使用部分函数是有教育意义的。
- en: 'So, let''s introduce a new type class responsible for computing a sum on a
    heterogeneous list. We can do so as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们介绍一个新的类型类，它负责在异构列表上计算求和。我们可以这样做：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, we make our mapping capability and summation capability outsourced to the
    type classes we have just discussed. However, what is `Aux` at the end of the
    `MapToDouble` type class all about? Also, what is that new `LR` type parameter
    added to the type of the sum function?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将我们的映射能力和求和能力外包给刚刚讨论过的类型类。然而，`MapToDouble`类型类末尾的`Aux`是什么意思？还有，那个新添加到求和函数类型中的`LR`类型参数是什么？
- en: 'Basically,  `LR` is the type of this list mapped to by `MapToDouble`. So, for
    our list of the following type:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，`LR`是这个列表通过`MapToDouble`映射的类型。所以，对于以下类型的列表：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This type will be as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类型将是以下这样：
- en: '[PRE43]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In the preceding code, you can see the auxiliary pattern. The entire point of
    it is that we do not know the `LR` type variable and rely on the Scala compiler
    to compute it. Compiler  computes the `LR` type is by means of implicitly resolving
    the `MapToDouble` type class. The big picture is that the Scala compiler is able
    to leverage the implicit mechanism to compute entire types and store the result
    in a type argument variable, and then, we can reuse it in the implicit resolution
    of other type classes. So, we are using this type computed by the auxiliary mechanism
    to resolve the `Sum` type class.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你可以看到辅助模式。它的全部要点在于我们不知道`LR`类型变量，而是依赖Scala编译器来计算它。编译器通过隐式解析`MapToDouble`类型类来计算`LR`类型。总体来说，Scala编译器能够利用隐式机制来计算整个类型，并将结果存储在类型参数变量中，然后，我们可以在其他类型类的隐式解析中重用它。因此，我们使用这种由辅助机制计算出的类型来解析`Sum`类型类。
- en: Why do we need to compute the `HList` type if we know ahead of time that all
    of its elements are doubles? We may know the type of the elements, but we still
    need the compiler's help to know how many doubles to stack into the resulting `HList`.
    Remember that `HList` stores the type of every element, so if we say that all
    of the elements are doubles, we still need to know the length of the list to construct
    it. Here, the compiler is able to help us with this task.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们事先知道所有的元素都是双精度浮点数，为什么还需要计算`HList`类型呢？我们可能知道元素的类型，但仍然需要编译器的帮助来知道将多少个双精度浮点数堆叠到结果`HList`中。记住，`HList`存储了每个元素的类型，所以如果我们说所有的元素都是双精度浮点数，我们仍然需要知道列表的长度来构建它。在这里，编译器能够帮助我们完成这个任务。
- en: 'So how exactly does the auxiliary pattern work and how exactly is the compiler
    capable of computing new types? To answer this question, let''s proceed to the
    definition of our type classes. Let''s start with the `MapToDouble` type class:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，辅助模式究竟是如何工作的，编译器又是如何能够计算新类型的呢？为了回答这个问题，让我们继续到我们类型类的定义。让我们从`MapToDouble`类型类开始：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that the type class has two members. The first is the `Result` type,
    which represents the result type of mapping a given heterogeneous list so that
    all of its members are doubles. Then, we have the method that performs `map` in
    itself. Notice also that `MapToDouble` has only one type parameter, `L`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，类型类有两个成员。第一个是`Result`类型，它表示将给定的异构列表映射为所有成员都是双精度浮点数的结果类型。然后，我们有执行自身`map`操作的方法。注意，`MapToDouble`只有一个类型参数`L`。
- en: The `Result` type is an abstract type, which means it is up to implementations
    of the type class to define it. We'll see in a moment how to leverage this ability
    to compute the result type.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`Result`类型是一个抽象类型，这意味着它取决于类型类的实现来定义它。我们很快就会看到如何利用这种能力来计算结果类型。'
- en: 'The catch is that, technically, the result type is not reflected in the type
    of the type class. Which means, whenever we need this type class, for some `L` type,
    we can resolve it as follows:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 抓住问题的关键在于，从技术上讲，结果类型并没有反映在类型类的类型中。这意味着，每当我们需要这个类型类，对于某种`L`类型，我们都可以这样解决它：
- en: '[PRE45]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the preceding code, the implicit method is defined as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，隐式方法定义如下：
- en: '![](img/2a36e255-bccf-4b15-8c45-3361e27af4e8.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2a36e255-bccf-4b15-8c45-3361e27af4e8.png)'
- en: So basically, the method is a utility to resolve an implicit value of a certain
    type.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，这个方法是一个用于解决特定类型隐式值的实用工具。
- en: 'Notice that when we request the implicit dependency on this type class, we
    do not specify the result type, which means we are not required to know this type
    when we resolve their implicit dependency. Now, imagine that you had your type
    class defined as follows:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们请求对这个类型类的隐式依赖时，我们没有指定结果类型，这意味着我们在解决它们的隐式依赖时不需要知道这个类型。现在，想象一下，如果你的类型类定义如下：
- en: '[PRE46]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, with the preceding type class defined, we are no longer able to resolve
    it without knowing the result it is going to compute. Indeed, we have no other
    way to refer to this type class but as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了前面定义的类型类，我们不再能够不知道它将要计算的结果就解决它。实际上，我们除了以下方式外没有其他方法来引用这个类型类：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Since the type class has two type arguments, we must to provide it with both
    of them. We might know the first type argument, however, because it is present
    in our program, in the type of our `HList`. The type of our heterogeneous list
    is constructed for us by the compiler when we construct the list itself. However,
    the result of the conversion of this list to a list of doubles is not currently
    known to the compiler. And we must provide it to resolve the implicit dependency.
    Hence, we are forced to compute it ourselves.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型类有两个类型参数，我们必须提供这两个参数。我们可能知道第一个类型参数，因为它存在于我们的程序中，在我们的`HList`的类型中。我们的异构列表类型是由编译器在我们构造列表时为我们构建的。然而，将这个列表转换为双精度浮点数列表的结果目前对编译器来说并不清楚。我们必须提供它来解决隐式依赖。因此，我们被迫自己计算它。
- en: Is there a way to make the compiler compute that, similarly to how it computes
    the type of the list when you construct it? For this, we have the Aux pattern.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有一种方法可以让编译器计算，类似于它在构造列表时计算列表类型的方式？为此，我们有辅助模式。
- en: 'The auxiliary pattern looks as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助模式如下所示：
- en: '[PRE48]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: So, it is nothing more than a type definition inside the companion object of
    our type class. Notice that here we are using structural types to define our auxiliary
    type. The preceding program says that the Aux type of is `MapToDouble`, whose
    body will contain a type member of `Result` set to a certain type variable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: The catch is that we still are able to capture both of the type variables that
    are significant to us, the input and output types, in a single `Aux` type. However,
    when we are trying to resolve the type class implicitly, we are no longer obliged
    to know both of the types.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'And so, we can implicitly depend on the `Aux` type, and the compiler resolves
    this type without the knowledge of the second type parameter:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Instead, the resolution will go as follows in this case:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: The compiler will infer the first type parameter, `L`. It will infer it by looking
    at the input argument. So, you do not need to provide it explicitly.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will start the implicit resolution. First, we need `MapToDouble.Aux`. This
    type expands to the `MapToDouble[L] { type Result = LR }` type.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The compiler will interpret this as a command to resolve the `MapToDouble` type,
    whose first type argument must be `L`. The second type parameter of the `Aux`
    type is unknown, but it is not a problem, because, as we have discussed previously,
    the compiler does not need it to resolve the type class. However, this second
    type parameter has a name and is bound to a certain type, which is a member of
    the type class we are about to resolve. The compiler will, therefore, infer this
    second type parameter from the `Result` type of `MapToDouble`.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After this type class is resolved, we now have the `LR` type parameter. We can
    now use it as an input to the next implicit resolution—that of `Sum[LR]`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The reason the preceding logic works, and that the compiler does not need the
    second type parameter, `LR`, of `MapToDouble.Aux` is as follows. The type of the
    type `MapToDouble` does not include the second type parameter `LR`, and `MapToDouble.Aux`
    is an alias for `MapToDouble`. The type `L`, which is a type parameter to `MapToDouble`, is
    all that the compiler needs to resolve the type class. If you think about it,
    when resolving something implicitly, or specifying a type of some variable, you
    do not need to explicitly specify the members of this variable. Since the second
    type parameter is a member of an object to be resolved, we do not need to know
    it when resolving our type.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: The Aux pattern is used to capture the types that are structural members of
    type classes into type arguments that can be referred to from the implicit group
    of a method signature.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: So basically, it is all about having the types that we do not know on call-time
    as structural members of the type classes, not the type parameters of these type
    classes. This way, the types that we will not know ourselves and will need to
    be computed will not be members of the signature the type signature of the type
    class. And hence, we can resolve these type classes without knowing their member
    types. So, we can compute these types on implicit-resolution time, leveraging
    algebraic data types principle. We will see how exactly we can compute these types
    using the mechanism of implicit resolution in the following code snippet.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 所以基本上，这全部关于在调用时将我们不知道的类型作为类型类的结构成员，而不是这些类型类的类型参数。这样，我们将不知道并且需要计算的类型将不会是类型类签名中的成员。因此，我们可以在不知道其成员类型的情况下解决这些类型类。所以，我们可以在隐式解析时间上计算这些类型，利用代数数据类型原理。我们将在下面的代码片段中看到我们如何确切地使用隐式解析机制来计算这些类型。
- en: 'This is how the function that we have just defined can be applied to a heterogeneous
    list:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的函数如何应用于异构列表：
- en: '[PRE50]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output of running the program is as follows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行程序后的输出如下：
- en: '[PRE51]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Next, let's have a look at how the implicit mechanism resolves all of the dependencies
    we need.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看隐式机制是如何解决我们需要的所有依赖的。
- en: Reclusive implicit resolution
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 隐式解析的递归性
- en: 'Let''s get a big picture understanding of what the members of the `MapToDouble`
    companion object look like:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们大致了解一下 `MapToDouble` 伴生对象的成员看起来是什么样子：
- en: '[PRE52]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: So as you can see, we have an Aux type, and `apply` function definitions, which
    are common for the type class pattern. Also, we have two implicit members, which
    define implementations for the `MapToDouble` type class for `hlist`. Since there
    are two possible instances of `hlist`, we have two possible implementations of
    MapToDouble, both for ` :::` and `HNil`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 所以正如你所看到的，我们有一个辅助类型，以及 `apply` 函数定义，这些是类型类模式中常见的。我们还有两个隐式成员，它们为 `hlist` 定义了
    `MapToDouble` 类型类的实现。由于 `hlist` 有两种可能的实例，所以我们有两种可能的 `MapToDouble` 实现，分别是 `:::`
    和 `HNil`。
- en: 'Notice the implicit dependencies that these two implicit values have. First
    of all, `hnil` does not depend on anything. Let''s have a look at its body:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这两个隐式值所具有的隐式依赖。首先，`hnil` 不依赖于任何东西。让我们看看它的主体：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The result of mapping an empty heterogeneous list is just another empty heterogeneous
    list. This is because we do not have anything to map.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 映射一个空异构列表的结果只是另一个空异构列表。这是因为我们没有可以映射的内容。
- en: '`hcons`, however, has implicit dependencies. As you can see in the preceding
    example, it implicitly depends on two other type classes: `ToDouble` and `MapToDouble`.
    As you can see, `ToDouble` is parametrized by the `H` type. The `H` type is the
    head type of our heterogeneous list. Any heterogeneous list is defined in terms
    of its head type and its tail type only.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`hcons` 然而，有隐式依赖。正如你在前面的例子中看到的，它隐式地依赖于两个其他类型类：`ToDouble` 和 `MapToDouble`。正如你所看到的，`ToDouble`
    是由 `H` 类型参数化的。`H` 类型是我们异构列表的头部类型。任何异构列表都是根据其头部类型和尾部类型定义的。'
- en: 'The meaning of all these implicit dependencies is that we are able to convert
    any heterogeneous list that is not empty to a list of doubles if we are able to
    convert its head to double, and if we are able to map its tail to a list of doubles.
    The definition of the `ToDouble` type class is as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些隐式依赖的含义是，如果我们能够将其头部转换为双精度浮点数，并且如果我们能够将其尾部映射为双精度浮点数列表，那么我们就能将任何非空异构列表转换为双精度浮点数列表。`ToDouble`
    类型类的定义如下：
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: One critical thing to notice about these implicit dependencies is that they
    are recursive. `hcons` itself is of the `MapToDouble.Aux` type. But in order to
    generate this `MapToDouble`, we need to also have `MapToDouble` for the tail of
    the heterogeneous list in question.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这些隐式依赖的一个关键点是它们是递归的。`hcons` 本身是 `MapToDouble.Aux` 类型。但是，为了生成这个 `MapToDouble`，我们还需要对于所讨论的异构列表的尾部有
    `MapToDouble`。
- en: Since the Scala compiler is capable of resolving implicit dependencies recursively,
    we are able to make an implicit dependency of one type depend recursively on the
    implicit dependency of the same type. The only thing to watch out for here, as
    with any other recursion, is for it to be able to terminate. This means, on every
    step of recursion, we must get closer, in some defined sense, to the terminal
    case of this recursion. That terminal case of recursion in our case is `HNil`.
    And with every step, we resolve the `MapToDouble` type class for a heterogeneous
    list that is one element shorter than the previous list because we take only the
    tail without the head. This guarantees that recursion will terminate.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Scala编译器能够递归地解析隐式依赖，我们能够使一个类型的一个隐式依赖递归地依赖于同一类型的隐式依赖。在这里需要注意的，就像任何其他递归一样，是确保它能够终止。这意味着，在递归的每一步，我们必须在某种定义的意义上更接近递归的终止情况。在我们的情况下，递归的终止情况是`HNil`。并且，在每一步中，我们都会为比前一个列表少一个元素的异构列表解析`MapToDouble`类型类，因为我们只取尾部而不取头部。这保证了递归将终止。
- en: 'Now, let''s have a look at the implementation of `hcons`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`hcons`的实现：
- en: '[PRE55]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The body of the `map` function is defined in terms of the `ToDouble` type class
    that converts the head to double, and then uses the `MapToDouble` type class in
    order to convert the tail to double.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`函数的主体是用`ToDouble`类型类定义的，该类型类将头部转换为双精度浮点数，然后使用`MapToDouble`类型类将尾部转换为双精度浮点数。'
- en: 'In a similar fashion, we can define the `Sum` type class that we will be using
    in order to compute the sum of the heterogeneous list with all doubles:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，我们可以定义我们将要使用的`Sum`类型类，以便计算包含所有双精度浮点数的异构列表的总和：
- en: '[PRE56]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the companion object, we also have two cases of recursive implicit resolution—one
    terminal and one non-terminal case. The terminal case is `hnil`, and the non-terminal
    case is `hcons`. The terminal case is simple because if we take an empty list,
    its sum is always `0` because there are no elements in this list. However, if
    we have a non-empty list, our ability to compute its sum depends on our ability
    to compute the sum of its tail. If we are able to compute the sum of its tail,
    as notified by its implicit dependency, we can compute the sum of the tail, and
    add the value of the head to it.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在伴随对象中，我们也有两种递归隐式解析的情况——一种是终止情况，另一种是非终止情况。终止情况是`hnil`，非终止情况是`hcons`。终止情况很简单，因为如果我们取一个空列表，它的总和总是`0`，因为在这个列表中没有元素。然而，如果我们有一个非空列表，我们计算其总和的能力取决于我们计算其尾部总和的能力。如果我们能够根据其隐式依赖通知计算其尾部的总和，我们就可以计算尾部的总和，并将头部的值加到它上面。
- en: 'Finally, the last piece that we have not yet discussed is the implementation
    of the `ToDouble` type class:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还没有讨论的最后一块是`ToDouble`类型类的实现：
- en: '[PRE57]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: As we can see, the `ToDouble` type class is implemented for every type that
    we are going to use in practice.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`ToDouble`类型类为我们将要实际使用的每个类型都实现了。
- en: What are the benefits of using the type class approach and the type-level computations
    instead of simply doing a recursive pattern-matching using a recursive function?
    The answer is compile-time safety. Remember how at the beginning of this chapter,
    we argued that in case of recursive pattern-matching when we forgot to perform
    a pattern match on a single instance, we only found out about our mistake on runtime?
    Let's have a look at what happens if we fail to specify one case in the situation
    of type-level computations.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类型类方法和类型级计算而不是简单地使用递归函数进行递归模式匹配的好处是什么？答案是编译时安全性。记得在本章开头，我们是如何论证在递归模式匹配的情况下，如果我们忘记对一个单个实例执行模式匹配，我们只有在运行时才会发现我们的错误吗？让我们看看在类型级计算的情况下，如果我们未能指定一个情况会发生什么。
- en: 'The equivalent of pattern-matching for the type-level computation scenario
    are the `ToDouble` type class implementations. If you have a look at them, they
    specify how exactly to convert every type. Let''s have a look at what happens
    if you comment out one of the implementations that we need:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 类型级计算场景中模式匹配的等价物是`ToDouble`类型类的实现。如果你看一下它们，它们指定了如何精确地将每种类型转换。让我们看看如果我们注释掉我们需要的实现之一会发生什么：
- en: '[PRE58]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now let''s have a look at what happens when we run the program:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们运行程序时会发生什么：
- en: '![](img/a942029e-2622-44d5-b9ff-ca39f59d7548.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a942029e-2622-44d5-b9ff-ca39f59d7548.png)'
- en: The error is a compile-time error this time, so the application did not even
    compile. However, notice also that the error message is rather cryptic and hard
    to read. Next, we will have a look at how you can debug this kind of compile-time
    message. Type-level computations give rise to an entirely new style of programming
    in advanced languages such as Scala, so it is imperative that you know how to
    work with the compile-time errors in this setting.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Debugging type-level computations
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, type-level computations represent the leading edge of modern programming
    technology. The technology is rather experimental, and hence, it still does not
    have much support in terms of comprehensive error messages and tools for debugging.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: So, the preceding error message can be debugged step by step by leveraging algebraic
    data types. This means that you trace every step of recursion, and make sure that
    every implicit during every step is resolved correctly. At some point, you come
    to the place where the resolution produces errors, and then you can see which
    case produces an error.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'These checks can be done with `implicitly` keyword in Scala. The process of
    debugging with the `implicitly` function may look as follows:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The output of the preceding program''s compilation will be as follows:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/20a2629f-10e4-46cb-98cd-e313ebb74fbe.png)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
- en: So, the error is caused because the compiler is not able to find the implicit
    `ToDouble` type class for Fraction. Notice how with each statement, we gradually
    shrink the search space by reducing the size of our `HList` algebraic type. At
    each step, we are looking at whether the error will manifest itself. Finally,
    we arrive at `implicitly[ToDouble[Fraction]]`, and realize there is no such implicit
    type-class implementation in scope. Notice also that all the preceding errors
    happen at compile-time.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: The current state of affairs for the type-level computations may be not as good
    as you might want in Scala. However, you should keep in mind that the technology
    is still experimental. Scala itself is a language that is a playground for experimenting
    with new technologies. So, the main catch is the power of this new technology
    to bring the runtime errors in the scope of compile-time by leveraging the power
    of the type system and implicit resolution to specify certain guarantees about
    your program in terms of types. In Future, it is reasonable to expect that such
    kinds of technologies will get better tooling as they become more widely adopted.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Libraries for type-level programming
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the case of cats being a library for purely functional programming in
    Scala, there exist libraries that facilitate type-level programming in Scala.
    One such library is `Shapeless`. In fact, `Shapeless` is a part of the same ecosystem
    of libraries as `cats`. It provides a set of classes and types, including the
    heterogeneous list type, that facilitate some advanced purely functional programming
    on the type level.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: This approach deserves its own book, so we will not be going much deeper into
    it in this chapter. If you would like to learn more about this approach, please consult
    the official documentation and learning resources on `Shapeless`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-301
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the patterns of advanced functional programming.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: First, we looked at Monad Transformers. These are used to construct compound
    effect types. Given two independent effect types that describe their own side
    effects, you can stack them one on top of another to get a combined type from
    them.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: After that, we explored the Tagless Final pattern. The main benefit is inversion
    of control when you can have a single implementation of your business logic run
    against different effects systems to gain different semantics.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned about a pattern of type-level computations in functional
    programming. The main benefit of these is that they allow you to impose guarantees
    on your program encoded in terms of types, and have these guarantees checked at
    compile-time. This checking can be achieved with the mechanism of type-level computational,
    such as Scala implicit-conversion resolution, or any similar mechanisms that allows
    for type-level programming.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: The techniques for purely functional programming covered so far are powerful
    and promising, but are not yet widely accepted in the industry. The current de
    facto standard for concurrent programming is the actor model. In the next chapters,
    we will look at it. We will start with introduction of the model in the next chapter.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Explain the benefits of Monad Transformers.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the benefits of the Tagless Final pattern.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain the benefits of type-level computations.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
