<html><head></head><body>
		<div id="_idContainer035">
			<h1 id="_idParaDest-46"><em class="italic"><a id="_idTextAnchor045"/>Chapter 2</em>: Java Object-Oriented Programming (OOP)</h1>
			<p><strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) was born out of the necessity for better control over the concurrent modification of shared data, which was the curse of pre-OOP programming. The core of the idea was not to allow direct access to data and instead, do it only through a dedicated layer of code. Since data needs to be passed around and modified in the process, the concept of an object was conceived. In the most general sense, an <em class="italic">object</em> is a set of data that can be passed around and accessed only through the set of methods passed along too. This data is said to compose an <strong class="bold">object state</strong>, while the methods constitute the <strong class="bold">object behavior</strong>. The object state is hidden (<strong class="bold">encapsulated</strong>) from direct access.</p>
			<p>Each object is constructed based on a certain template called a <strong class="bold">class</strong>. In other words, a class defines a class of objects. Each object has a certain <strong class="bold">interface</strong>, a formal definition of the way other objects can interact with it. Originally, one object would send a message to another object by calling its method. But this terminology did not hold, especially after actual message-based protocols and systems were introduced.</p>
			<p>To avoid code duplication, a parent-child relationship between objects was introduced – one class can inherit behavior from another class. In such a relationship, the first class is called a <strong class="bold">child class</strong>, or <strong class="bold">subclass</strong>, while the second is called a <strong class="bold">parent</strong>, <strong class="bold">base class</strong>, or <strong class="bold">superclass</strong>.</p>
			<p>Another form of relationship was defined between classes and interfaces – a class can <em class="italic">implement</em> an interface. Since an interface describes how you can interact with an object but not how an object responds to the interaction, different objects can behave differently while implementing the same interface.</p>
			<p>In Java, a class can have only one direct parent but can implement many interfaces. </p>
			<p>The ability to behave like any of its ancestors and adhere to multiple interfaces is called <strong class="bold">polymorphism</strong>.</p>
			<p>In this chapter, we will look at these OOP concepts and how they are implemented in Java. The topics discussed include the following:</p>
			<ul>
				<li>OOP concepts</li>
				<li>Class</li>
				<li>Interface</li>
				<li>Overloading, overriding, and hiding</li>
				<li>The final variable, method, and class</li>
				<li>Record and sealed classes</li>
				<li>Polymorphism in action</li>
			</ul>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor046"/>Technical requirements</h1>
			<p>To be able to execute the code examples provided in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with a Microsoft Windows, Apple macOS, or Linux operating system</li>
				<li>Java SE version 17 or later</li>
				<li>An IDE or code editor that you prefer</li>
			</ul>
			<p>The instructions for how to set up a Java SE and IntelliJ IDEA editor were provided in <a href="B18388_01_ePub.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Java 17</em>, of this book. The files with the code examples for this chapter are available in the GitHub repository at <a href="https://github.com/PacktPublishing/Learn-Java-17-Programming.git">https://github.com/PacktPublishing/Learn-Java-17-Programming.git</a> in the <strong class="source-inline">examples/src/main/java/com/packt/learnjava/ch02_oop</strong> folder.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor047"/>OOP concepts</h1>
			<p>As we have already stated in the introduction, the main OOP concepts are as follows:</p>
			<ul>
				<li><strong class="bold">Class</strong>: This defines the<a id="_idIndexMarker173"/> properties and behavior (methods) of objects that<a id="_idIndexMarker174"/> are created based on this class.</li>
				<li><strong class="bold">Object</strong>: This defines a state (data) as values<a id="_idIndexMarker175"/> of its properties, adds behavior (methods) taken<a id="_idIndexMarker176"/> from a class, and holds them together.</li>
				<li><strong class="bold">Inheritance</strong>: This propagates behavior down the chain<a id="_idIndexMarker177"/> of classes connected <a id="_idIndexMarker178"/>via parent-child relationships.</li>
				<li><strong class="bold">Interface</strong>: This describes how object data and behavior can be<a id="_idIndexMarker179"/> accessed. It isolates (abstracts) an object’s appearance<a id="_idIndexMarker180"/> from its implementations (behavior).</li>
				<li><strong class="bold">Encapsulation</strong>: This hides the state<a id="_idIndexMarker181"/> and details of the<a id="_idIndexMarker182"/> implementation.</li>
				<li><strong class="bold">Polymorphism</strong>: This allows an object to assume<a id="_idIndexMarker183"/> an appearance of implemented<a id="_idIndexMarker184"/> interfaces and behave like any of the ancestor classes.</li>
			</ul>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Object/class</h2>
			<p>In principle, you can create a very powerful application with minimal usage of classes and objects. It became<a id="_idIndexMarker185"/> even easier to do this after functional programming<a id="_idIndexMarker186"/> was added to Java 8, to a JDK, which allowed you to pass around behavior<a id="_idIndexMarker187"/> as a function. Yet passing data (state) still requires classes/objects. This means<a id="_idIndexMarker188"/> that the position of Java as an OOP language remains intact.</p>
			<p>A class defines the types of all internal object properties that hold the object state. A class also defines object behavior expressed by the code of the methods. It is possible to have a class/object without a state or behavior. Java also has a provision for making the behavior accessible statically – without creating an object. But these possibilities are no more than just additions to the object/class concept that was introduced for keeping the state and behavior together.</p>
			<p>To illustrate this concept, a <strong class="source-inline">Vehicle</strong> class, for example, defines the properties and behavior of a vehicle in principle. Let’s make the model simple and assume that a vehicle has only two properties – weight and engine of a certain power. It also can have a certain behavior – it can reach a certain speed in a certain period of time, depending on the values of its two properties. This behavior can be expressed in a method that calculates the speed the vehicle can reach in a certain period of time. Every object of the <strong class="source-inline">Vehicle</strong> class will have a specific state (the values of its properties) and the speed calculation will result in a different speed in the same time period. </p>
			<p>All Java code<a id="_idIndexMarker189"/> is contained inside methods. A <strong class="bold">method</strong> is a group of statements that<a id="_idIndexMarker190"/> have (optional) input parameters<a id="_idIndexMarker191"/> and a return a value (also optional). In addition, each<a id="_idIndexMarker192"/> method can have side effects – it can display<a id="_idIndexMarker193"/> a message or write data into the database, for example. Class/object behavior is implemented in the methods.</p>
			<p>To follow our example, speed calculations can reside in a <strong class="source-inline">double calculateSpeed(float seconds)</strong> method, for instance. As you can guess, the name of the method is <strong class="source-inline">calculateSpeed</strong>. It accepts a number of seconds (with a fractional part) as a parameter and returns the speed value as <strong class="source-inline">double</strong>.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor049"/>Inheritance</h2>
			<p>As we have mentioned<a id="_idIndexMarker194"/> already, objects can establish a parent-child relationship and share properties<a id="_idIndexMarker195"/> and behavior this way. For example, we can create a <strong class="source-inline">Car</strong> class that inherits properties (weight, for example) and behavior (speed calculation) of the <strong class="source-inline">Vehicle</strong> class. In addition, the <strong class="source-inline">child</strong> class can have its own properties (the number of passengers, for example) and car-specific behavior (soft shock absorption, for example). But if we create a <strong class="source-inline">Truck</strong> class as the vehicle’s child, its additional truck-specific property (payload, for example) and behavior (hard shock absorption) will be different.</p>
			<p>It is said that each object of the <strong class="source-inline">Car</strong> or <strong class="source-inline">Truck</strong> class has a parent object of the <strong class="source-inline">Vehicle</strong> class. But objects of the <strong class="source-inline">Car</strong> and <strong class="source-inline">Truck</strong> class do not share the specific <strong class="source-inline">Vehicle</strong> object (every time a child object is created, a new parent object is created first). They share only the parent’s behavior. That is why all child objects can have the same behavior but different states. This is one way to achieve code reusability, but it may not be flexible enough when object behavior has to change dynamically. In such cases, object composition (bringing behavior from other classes) or functional programming is more appropriate (see <a href="B18388_13_ePub.xhtml#_idTextAnchor281"><em class="italic">Chapter 13</em></a>, <em class="italic">Functional Programming</em>).</p>
			<p>It is possible to make a child behave differently than the inherited behavior would do. To achieve it, the method that captures the behavior can be re-implemented in the <strong class="source-inline">child</strong> class. It is said that a child can <em class="italic">override</em> inherited behavior. We will explain how to do it shortly (see the <em class="italic">Overloading, overriding, and hiding</em> section). If, for example, the <strong class="source-inline">Car</strong> class has its own method for speed calculation, the corresponding method of the <strong class="source-inline">Vehicle</strong> parent class<a id="_idIndexMarker196"/> is not inherited, and the new speed calculation, implemented<a id="_idIndexMarker197"/> in the <strong class="source-inline">child</strong> class, is used instead.</p>
			<p>Properties of a parent class can be inherited (but not overridden) too. However, class properties are typically declared private; they cannot be inherited – that’s the point of encapsulation. See the description of various access levels – <strong class="source-inline">public</strong>, <strong class="source-inline">protected</strong>, <strong class="source-inline">default</strong>, and <strong class="source-inline">private</strong> – in the <em class="italic">Access modifiers</em> section of <a href="B18388_03_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 3</em></a>, <em class="italic">Java Fundamentals</em>.</p>
			<p>If the parent class inherits some behavior from another class, the <strong class="source-inline">child</strong> class acquires (inherits) this behavior too, unless, of course, the parent class overrides it. There is no limit to how long the chain of inheritance can be.</p>
			<p>The parent-child relationship in Java is expressed using the <strong class="source-inline">extends</strong> keyword:</p>
			<pre class="source-code">class A { }</pre>
			<pre class="source-code">class B extends A { }</pre>
			<pre class="source-code">class C extends B { }</pre>
			<pre class="source-code">class D extends C { }</pre>
			<p>In this code, the <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, <strong class="source-inline">C</strong>, and <strong class="source-inline">D</strong> classes have the following relationships:</p>
			<ul>
				<li>The <strong class="source-inline">D</strong> class inherits from the <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">C</strong> classes.</li>
				<li>The <strong class="source-inline">C</strong> class inherits from the <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> classes.</li>
				<li>The <strong class="source-inline">B</strong> class inherits from the <strong class="source-inline">A</strong> class.</li>
			</ul>
			<p>All non-private methods of the <strong class="source-inline">A</strong> class are inherited (if not overridden) by the <strong class="source-inline">B</strong>, <strong class="source-inline">C</strong>, and <strong class="source-inline">D</strong> classes.</p>
			<p>All non-private methods of the <strong class="source-inline">B</strong> class are inherited (if not overridden) by the <strong class="source-inline">C</strong> and <strong class="source-inline">D</strong> classes.</p>
			<p>All non-private methods of the <strong class="source-inline">C</strong> class are inherited (if not overridden) by the <strong class="source-inline">D</strong> class. </p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>Abstraction/interface</h2>
			<p>The name of a method<a id="_idIndexMarker198"/> and the list of its parameter types is called a <strong class="bold">method signature</strong>. It describes how the behavior<a id="_idIndexMarker199"/> of an object (of <strong class="source-inline">Car</strong> or <strong class="source-inline">Truck</strong>, in our example) can be accessed. Such a description together with a <strong class="source-inline">return</strong> type is presented as an interface. It does not say anything about the code<a id="_idIndexMarker200"/> that does calculations – only about the method name, the parameters’ types, their position in the parameter list, and the result type. All the implementation details are hidden (encapsulated) within the class that <em class="italic">implements</em> this interface.</p>
			<p>As we have mentioned already, a class can implement many different interfaces. But two different classes (and their objects) can behave differently even when they implement the same interface. </p>
			<p>Similarly to classes, interfaces can have a parent-child relationship using the <strong class="source-inline">extends</strong> keyword too:</p>
			<pre class="source-code">interface A { }</pre>
			<pre class="source-code">interface B extends A {}</pre>
			<pre class="source-code">interface C extends B {}</pre>
			<pre class="source-code">interface D extends C {}</pre>
			<p>In this code, the <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, <strong class="source-inline">C</strong>, and <strong class="source-inline">D</strong> interfaces have the following relationships:</p>
			<ul>
				<li>The <strong class="source-inline">D</strong> interface inherits from the <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, and <strong class="source-inline">C</strong> interfaces.</li>
				<li>The <strong class="source-inline">C</strong> interface inherits from the <strong class="source-inline">A</strong> and <strong class="source-inline">B</strong> interfaces.</li>
				<li>The <strong class="source-inline">B</strong> interface inherits from the <strong class="source-inline">A</strong> interface.</li>
			</ul>
			<p>All non-private methods of the <strong class="source-inline">A</strong> interface are inherited by the <strong class="source-inline">B</strong>, <strong class="source-inline">C</strong>, and <strong class="source-inline">D</strong> interfaces.</p>
			<p>All non-private methods of the <strong class="source-inline">B</strong> interface are inherited by the <strong class="source-inline">C</strong> and <strong class="source-inline">D</strong> interfaces.</p>
			<p>All non-private methods of the <strong class="source-inline">C</strong> interface are inherited by the <strong class="source-inline">D</strong> interface.</p>
			<p>Abstraction/interface also reduces dependency between different sections of the code, thus increasing its maintainability. Each class can be changed without the need to coordinate it with its clients, as long as the interface stays the same.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>Encapsulation</h2>
			<p><strong class="bold">Encapsulation</strong> is often defined either as data hiding or a bundle of publicly accessible methods and privately<a id="_idIndexMarker201"/> accessible data. In a broad sense, encapsulation is controlled<a id="_idIndexMarker202"/> access to an object’s properties. </p>
			<p>The snapshot of values of object<a id="_idIndexMarker203"/> properties is called an <strong class="bold">object state</strong>. This is data that is encapsulated. So, encapsulation addresses the main issue that motivated the creation of object-oriented programming – better management of concurrent access to shared data, such as the following:</p>
			<pre class="source-code">class A {</pre>
			<pre class="source-code">  private String prop = "init value";</pre>
			<pre class="source-code">  public void setProp(String value){</pre>
			<pre class="source-code">     prop = value;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  public String getProp(){</pre>
			<pre class="source-code">     return prop;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, to read or modify the value of the <strong class="source-inline">prop</strong> property, we cannot access it directly because of the <strong class="source-inline">private</strong> access modifier. Instead, we can do it only via the <strong class="source-inline">setProp(String value)</strong> and <strong class="source-inline">getProp()</strong>methods.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor052"/>Polymorphism</h2>
			<p>Polymorphism is the ability<a id="_idIndexMarker204"/> of an object to behave as an object of a different<a id="_idIndexMarker205"/> class or as an implementation of a different interface. It owes its existence to all the concepts that have been mentioned previously – inheritance, interface, and encapsulation. Without them, polymorphism would not be possible. </p>
			<p>Inheritance allows an object to acquire or override the behaviors of all its ancestors. An interface hides from the client code the name of the class that implemented it. The encapsulation prevents exposing the object state. </p>
			<p>In the following sections, we will demonstrate<a id="_idIndexMarker206"/> all these concepts in action and look at the specific usage of polymorphism<a id="_idIndexMarker207"/> in the <em class="italic">Polymorphism in action</em> section.</p>
			<h1 id="_idParaDest-54"><a id="_idTextAnchor053"/>Class</h1>
			<p>A Java program<a id="_idIndexMarker208"/> is a sequence of statements that express an executable action. The statements are organized in methods, and methods are organized in classes. One or more classes are stored in <strong class="source-inline">.java</strong> files. They can be compiled (transformed from the Java language into a bytecode) by the <strong class="source-inline">javac</strong> Java compiler and stored in <strong class="source-inline">.class</strong> files. Each <strong class="source-inline">.class</strong> file contains one compiled class only and can be executed by JVM.</p>
			<p>A <strong class="source-inline">java</strong> command starts JVM and tells it which class is the <strong class="source-inline">main</strong> one, the class that has the method called <strong class="source-inline">main()</strong>. The <strong class="source-inline">main</strong> method has a particular declaration – it has to be <strong class="source-inline">public static</strong>, must return <strong class="source-inline">void</strong>, has the name <strong class="source-inline">main</strong>, and accepts a single parameter of an array of a <strong class="source-inline">String</strong> type.</p>
			<p>JVM loads the main class into memory, finds the <strong class="source-inline">main()</strong> method, and starts executing it, statement by statement. The <strong class="source-inline">java</strong> command can also pass parameters (arguments) that the <strong class="source-inline">main()</strong> method receives as an array of <strong class="source-inline">String</strong> values. If JVM encounters a statement that requires the execution of a method from another class, that class (its <strong class="source-inline">.class</strong> file) is loaded into the memory too and the corresponding method is executed. So, a Java program flow is all about loading classes and executing their methods.</p>
			<p>Here is an example of the <strong class="source-inline">main</strong> class:</p>
			<pre class="source-code">public class MyApp {</pre>
			<pre class="source-code">  public static void main(String[] args){</pre>
			<pre class="source-code">     AnotherClass an = new AnotherClass();</pre>
			<pre class="source-code">     for(String s: args){</pre>
			<pre class="source-code">        an.display(s);</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>It represents a very simple<a id="_idIndexMarker209"/> application that receives any number of parameters and passes them, one by one, into the <strong class="source-inline">display()</strong> method of the <strong class="source-inline">AnotherClass</strong> class. As JVM starts, it loads the <strong class="source-inline">MyApp</strong> class from the <strong class="source-inline">MyApp.class</strong> file first. Then, it loads the <strong class="source-inline">AnotherClass</strong> class from the <strong class="source-inline">AnotherClass.class</strong> file, creates an object of this class using the <strong class="source-inline">new</strong> operator (which we will talk about shortly), and calls the <strong class="source-inline">display()</strong> method on it.</p>
			<p>Here is the <strong class="source-inline">AnotherClass</strong> class:</p>
			<pre class="source-code">public class AnotherClass {</pre>
			<pre class="source-code">   private int result;</pre>
			<pre class="source-code">   public void display(String s){</pre>
			<pre class="source-code">      System.out.println(s);</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   public int process(int i){</pre>
			<pre class="source-code">      result = i *2;</pre>
			<pre class="source-code">      return result;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">   public int getResult(){</pre>
			<pre class="source-code">      return result;</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">} </pre>
			<p>As you can see, the <strong class="source-inline">display()</strong> method is used for its side effect only – it prints out the passed-in value and returns nothing (<strong class="source-inline">void</strong>). The <strong class="source-inline">AnotherClass</strong> class has other two methods:</p>
			<ul>
				<li>The <strong class="source-inline">process()</strong> method doubles the input integer, stores it in its <strong class="source-inline">result</strong> property, and returns the value to the caller.</li>
				<li>The <strong class="source-inline">getResult()</strong> method allows you to get the result from the object at any time later.</li>
			</ul>
			<p>These two methods<a id="_idIndexMarker210"/> are not used in our demo application. We have shown them just to show that a class can have properties (<strong class="source-inline">result</strong>, in this case) and many other methods.</p>
			<p>The <strong class="source-inline">private</strong> keyword makes the value accessible only from inside the class, from its methods. The <strong class="source-inline">public</strong> keyword makes a property or a method accessible by any other class.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Method</h2>
			<p>As we have<a id="_idIndexMarker211"/> stated already, Java statements<a id="_idIndexMarker212"/> are organized as methods:</p>
			<pre class="source-code">&lt;return type&gt; &lt;method name&gt;(&lt;list of parameter types&gt;){</pre>
			<pre class="source-code">     &lt;method body that is a sequence of statements&gt;</pre>
			<pre class="source-code">}</pre>
			<p>We have seen a few examples already. A method has a name, a set of input parameters or no parameters at all, a body inside <strong class="source-inline">{}</strong> brackets, and a return type or <strong class="source-inline">void</strong> keyword that indicates that the method does not return any value.</p>
			<p>The method name and the list of parameter<a id="_idIndexMarker213"/> types together are called the <strong class="bold">method signature</strong>. The number of input<a id="_idIndexMarker214"/> parameters is called an <strong class="bold">arity</strong>.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Two methods have the same <em class="italic">signature</em> if they have the same name, the same arity, and the same sequence of types in the list of input parameters.</p>
			<p>The following two methods have the same signature:</p>
			<pre class="source-code">double doSomething(String s, int i){</pre>
			<pre class="source-code">    //some code goes here</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">double doSomething(String i, int s){</pre>
			<pre class="source-code">    //some code other code goes here</pre>
			<pre class="source-code">}</pre>
			<p>The code inside the methods<a id="_idIndexMarker215"/> may be different even if the signature<a id="_idIndexMarker216"/> is the same. </p>
			<p>The following two methods have different signatures:</p>
			<pre class="source-code">double doSomething(String s, int i){</pre>
			<pre class="source-code">    //some code goes here</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">double doSomething(int s, String i){</pre>
			<pre class="source-code">    //some code other code goes here</pre>
			<pre class="source-code">}</pre>
			<p>Just a change in the sequence of parameters makes the signature different, even if the method name remains the same.</p>
			<h3>Varargs</h3>
			<p>One particular type<a id="_idIndexMarker217"/> of parameter requires a mention because it is quite different from all the others. It is declared<a id="_idIndexMarker218"/> a type followed by three dots. It is called <strong class="bold">varargs</strong>, which stands for <strong class="bold">variable arguments</strong>. But, first, let’s briefly define what an array is in Java.</p>
			<p>An <strong class="bold">array</strong> is a data structure that holds<a id="_idIndexMarker219"/> elements of the same type. The elements are referenced by a numerical index. That’s all we need to know, for now. We will talk about arrays in more detail in <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>. </p>
			<p>Let’s start with an example. Let’s declare method parameters using <strong class="source-inline">varargs</strong>:</p>
			<pre class="source-code">String someMethod(String s, int i, double... arr){</pre>
			<pre class="source-code"> //statements that compose method body</pre>
			<pre class="source-code">}</pre>
			<p>When the <strong class="source-inline">someMethod</strong> method is called, the Java compiler matches the arguments from left<a id="_idIndexMarker220"/> to right. Once it gets to the last <strong class="source-inline">varargs</strong> parameter, it creates an array of the remaining<a id="_idIndexMarker221"/> arguments and passes it to the method. Here is a demo code:</p>
			<pre class="source-code">public static void main(String... args){</pre>
			<pre class="source-code">    someMethod("str", 42, 10, 17.23, 4);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">private static String someMethod(</pre>
			<pre class="source-code">        String s, int i, double... arr){</pre>
			<pre class="source-code">    System.out.println(arr[0] + ", " + arr[1] + ", " + arr[2]); </pre>
			<pre class="source-code">                                     //prints: 10.0, 17.23, 4.0</pre>
			<pre class="source-code">    return s;</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the <strong class="source-inline">varargs</strong> parameter acts like an array of the specified type. It can be listed as the last or the only parameter of a method. That is why, sometimes, you can see the <strong class="source-inline">main</strong> method declared, as in the preceding example.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Constructor</h2>
			<p>When an object<a id="_idIndexMarker222"/> is created, JVM uses a <strong class="bold">constructor</strong>. The purpose of a constructor is to initialize the object<a id="_idIndexMarker223"/> state to assign values to all the declared properties. If there is no constructor declared in the class, JVM just assigns default values to the properties. We have talked about the default values for primitive types – it is <strong class="source-inline">0</strong> for integral types, <strong class="source-inline">0.0</strong> for floating-point types, and <strong class="source-inline">false</strong> for Boolean types. For other Java reference types (see <a href="B18388_03_ePub.xhtml#_idTextAnchor079"><em class="italic">Chapter 3</em></a>, <em class="italic">Java Fundamentals</em>), the default value is <strong class="source-inline">null</strong>, which means that the property of a reference type is not assigned any value.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">When there is no constructor declared in a class, it is said that the class has a default constructor without parameters provided by the JVM.</p>
			<p>If necessary, it is possible<a id="_idIndexMarker224"/> to declare any number of constructors explicitly, each taking<a id="_idIndexMarker225"/> a different set of parameters to set the initial state. Here is an example:</p>
			<pre class="source-code">class SomeClass {</pre>
			<pre class="source-code">     private int prop1;</pre>
			<pre class="source-code">     private String prop2;</pre>
			<pre class="source-code">     public SomeClass(int prop1){</pre>
			<pre class="source-code">         this.prop1 = prop1;</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">     public SomeClass(String prop2){</pre>
			<pre class="source-code">         this.prop2 = prop2;</pre>
			<pre class="source-code">     }</pre>
			<pre class="source-code">     public SomeClass(int prop1, String prop2){</pre>
			<pre class="source-code">         this.prop1 = prop1;</pre>
			<pre class="source-code">         this.prop2 = prop2;</pre>
			<pre class="source-code">     }   </pre>
			<pre class="source-code">     // methods follow </pre>
			<pre class="source-code">}</pre>
			<p>If a property is not set by a constructor, the default value of the corresponding type is going to be assigned to it automatically.</p>
			<p>When several classes<a id="_idIndexMarker226"/> are related along the same line of succession, the parent object<a id="_idIndexMarker227"/> is created first. If the parent object requires the setting of non-default initial values to its properties, its constructor must be called as the first line of the child constructor using the <strong class="source-inline">super</strong> keyword, as follows:</p>
			<pre class="source-code">class TheParentClass {</pre>
			<pre class="source-code">    private int prop;</pre>
			<pre class="source-code">    public TheParentClass(int prop){</pre>
			<pre class="source-code">        this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // methods follow</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class TheChildClass extends TheParentClass{</pre>
			<pre class="source-code">    private int x;</pre>
			<pre class="source-code">    private String prop;</pre>
			<pre class="source-code">    private String anotherProp = "abc";</pre>
			<pre class="source-code">    public TheChildClass(String prop){</pre>
			<pre class="source-code">       super(42);</pre>
			<pre class="source-code">       this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public TheChildClass(int arg1, String arg2){</pre>
			<pre class="source-code">       super(arg1);</pre>
			<pre class="source-code">       this.prop = arg2;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // methods follow</pre>
			<pre class="source-code">}</pre>
			<p>In the preceding code <a id="_idIndexMarker228"/>example, we added two constructors to <strong class="source-inline">TheChildClass</strong> – one that always passes <strong class="source-inline">42</strong> to the constructor of <strong class="source-inline">TheParentClass</strong>, and another<a id="_idIndexMarker229"/> that accepts two parameters. Note that the <strong class="source-inline">x</strong> property is declared but not initialized explicitly. It is going to be set to value <strong class="source-inline">0</strong>, the default value of the <strong class="source-inline">int</strong> type, when an object of <strong class="source-inline">TheChildClass</strong> is created. Also, note that the <strong class="source-inline">anotherProp</strong> property is initialized explicitly to the value of <strong class="source-inline">"abc"</strong>. Otherwise, it would be initialized to the <strong class="source-inline">null</strong> value, the default value of any reference type, including <strong class="source-inline">String</strong>.</p>
			<p>Logically, there are three cases when an explicit definition of a constructor in the class is not required:</p>
			<ul>
				<li>When neither the object nor any of its parents have properties that need to be initialized</li>
				<li>When each property is initialized along with the type declaration (<strong class="source-inline">int x = 42</strong>, for example)</li>
				<li>When default values for the properties’ initialization are good enough </li>
			</ul>
			<p>Nevertheless, it is possible that a constructor is still implemented even when all three conditions (mentioned in the list) are met. For example, you may want to execute some statements that initialize some external resource – a file or another database – that the object will need as soon as it is created.</p>
			<p>As soon as an explicit constructor is added, the default constructor is not provided and the following code generates an error:</p>
			<pre class="source-code">class TheParentClass {</pre>
			<pre class="source-code">    private int prop;</pre>
			<pre class="source-code">    public TheParentClass(int prop){</pre>
			<pre class="source-code">        this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // methods follow</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class TheChildClass extends TheParentClass{</pre>
			<pre class="source-code">    private String prop;</pre>
			<pre class="source-code">    public TheChildClass(String prop){</pre>
			<pre class="source-code">        <strong class="bold">//super(42);</strong>  //No call to the parent's constructor</pre>
			<pre class="source-code">        this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // methods follow</pre>
			<pre class="source-code">}</pre>
			<p>To avoid the error, either add a constructor<a id="_idIndexMarker230"/> without parameters to <strong class="source-inline">TheParentClass</strong> or call an explicit<a id="_idIndexMarker231"/> constructor of the parent class as the first statement of the child’s constructor. The following code does not generate an error:</p>
			<pre class="source-code">class TheParentClass {</pre>
			<pre class="source-code">    private int prop;</pre>
			<pre class="source-code"><strong class="bold">    public TheParentClass() {}</strong></pre>
			<pre class="source-code">    public TheParentClass(int prop){</pre>
			<pre class="source-code">        this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // methods follow</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class TheChildClass extends TheParentClass{</pre>
			<pre class="source-code">    private String prop;</pre>
			<pre class="source-code">    public TheChildClass(String prop){</pre>
			<pre class="source-code">        this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    // methods follow</pre>
			<pre class="source-code">}</pre>
			<p>One important aspect to note is that constructors, although they look like methods, are not methods or even members<a id="_idIndexMarker232"/> of the class. A constructor doesn’t have a return type<a id="_idIndexMarker233"/> and always has the same name as the class. Its only purpose is to be called when a new instance of the class is created.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>The new operator</h2>
			<p>The <strong class="source-inline">new</strong> operator creates an object<a id="_idIndexMarker234"/> of a class (it also can be said that it <strong class="bold">instantiates a class</strong> or <strong class="bold">creates an instance of a class</strong>) by allocating memory for the properties<a id="_idIndexMarker235"/> of the new object and returning a reference to that memory. This memory reference is assigned to a variable of the same type as the class used to create the object or the type of its parent:</p>
			<pre class="source-code">TheChildClass ref1 = new TheChildClass("something"); </pre>
			<pre class="source-code">TheParentClass ref2 = new TheChildClass("something");</pre>
			<p>Here is an interesting observation. In the code, both the <strong class="source-inline">ref1</strong> and <strong class="source-inline">ref2</strong> object references provide access to the methods of <strong class="source-inline">TheChildClass</strong> and <strong class="source-inline">TheParentClass</strong>. For example, we can add methods to these classes, as follows:</p>
			<pre class="source-code">class TheParentClass {</pre>
			<pre class="source-code">    private int prop;</pre>
			<pre class="source-code">    public TheParentClass(int prop){</pre>
			<pre class="source-code">        this.prop = prop;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void someParentMethod(){}</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class TheChildClass extends TheParentClass{</pre>
			<pre class="source-code">    private String prop;</pre>
			<pre class="source-code">    public TheChildClass(int arg1, String arg2){</pre>
			<pre class="source-code">        super(arg1);</pre>
			<pre class="source-code">        this.prop = arg2;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void someChildMethod(){}</pre>
			<pre class="source-code">}</pre>
			<p>Then, we can call them<a id="_idIndexMarker236"/> using any of the following<a id="_idIndexMarker237"/> references:</p>
			<pre class="source-code">TheChildClass ref1 = new TheChildClass("something");</pre>
			<pre class="source-code">TheParentClass ref2 = new TheChildClass("something");</pre>
			<pre class="source-code">ref1.someChildMethod();</pre>
			<pre class="source-code">ref1.someParentMethod();</pre>
			<pre class="source-code">((TheChildClass) ref2).someChildMethod();</pre>
			<pre class="source-code">ref2.someParentMethod();</pre>
			<p>Note that, to access the child’s methods using the parent’s type reference, we had to cast it to the child’s type. Otherwise, the compiler generates an error. That is possible because we have assigned the reference to the child’s object to the parent’s type reference. That is the power of polymorphism. We will talk more about it in the <em class="italic">Polymorphism in action</em> section.</p>
			<p>Naturally, if we had assigned the parent’s object to the variable of the parent’s type, we would not be able to access the child’s method even with casting, as the following example shows:</p>
			<pre class="source-code">TheParentClass ref2 = new TheParentClass(42);</pre>
			<pre class="source-code">((TheChildClass) ref2).someChildMethod();  //compiler's error</pre>
			<pre class="source-code">ref2.someParentMethod();</pre>
			<p>The area where memory for the new<a id="_idIndexMarker238"/> object is allocated is called <strong class="bold">heap</strong>. The JVM has a process called <strong class="bold">garbage collection</strong> that watches for the usage<a id="_idIndexMarker239"/> of this area and releases memory for usage as soon as an object is not needed anymore. For example, look at the following method:</p>
			<pre class="source-code">void someMethod(){</pre>
			<pre class="source-code">   SomeClass ref = new SomeClass();</pre>
			<pre class="source-code">   ref.someClassMethod();</pre>
			<pre class="source-code">   //other statements follow</pre>
			<pre class="source-code">}</pre>
			<p>As soon as the execution of the <strong class="source-inline">someMethod()</strong> method is completed, the object of <strong class="source-inline">SomeClass</strong> is not accessible<a id="_idIndexMarker240"/> anymore. That’s what the garbage collector notices, and<a id="_idIndexMarker241"/> it releases the memory occupied by this object. We will talk about the garbage collection process in <a href="B18388_09_ePub.xhtml#_idTextAnchor205"><em class="italic">Chapter 9</em></a>, <em class="italic">JVM Structure and Garbage Collection</em>.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Class java.lang.Object</h2>
			<p>In Java, all classes<a id="_idIndexMarker242"/> are children of the <strong class="source-inline">Object</strong> class by default, even if you<a id="_idIndexMarker243"/> do not specify it implicitly. The <strong class="source-inline">Object</strong> class is declared in the <strong class="source-inline">java.lang</strong> package of the standard JDK library. We will define what a <em class="italic">package</em> is in the <em class="italic">Packages, importing, and access</em> section and describe libraries in <a href="B18388_07_ePub.xhtml#_idTextAnchor169"><em class="italic">Chapter 7</em></a>, <em class="italic">Java Standard and External Libraries</em>.</p>
			<p>Let’s look back at the example we provided in the <em class="italic">Inheritance</em> section:</p>
			<pre class="source-code">class A { }</pre>
			<pre class="source-code">class B extends A {}</pre>
			<pre class="source-code">class C extends B {}</pre>
			<pre class="source-code">class D extends C {}</pre>
			<p>All classes, <strong class="source-inline">A</strong>, <strong class="source-inline">B</strong>, <strong class="source-inline">C</strong>, and <strong class="source-inline">D</strong>, are children of the <strong class="source-inline">Object</strong> class, which has 10 methods that every class inherits:</p>
			<ul>
				<li><strong class="source-inline">public String toString()</strong></li>
				<li><strong class="source-inline">public int hashCode()</strong></li>
				<li><strong class="source-inline">public boolean equals (Object obj)</strong></li>
				<li><strong class="source-inline">public Class getClass()</strong></li>
				<li><strong class="source-inline">protected Object clone()</strong></li>
				<li><strong class="source-inline">public void notify()</strong></li>
				<li><strong class="source-inline">public void notifyAll()</strong></li>
				<li><strong class="source-inline">public void wait()</strong></li>
				<li><strong class="source-inline">public void wait(long timeout)</strong></li>
				<li><strong class="source-inline">public void wait(long timeout, int nanos)</strong></li>
			</ul>
			<p>The first three, <strong class="source-inline">toString()</strong>, <strong class="source-inline">hashCode()</strong>, and <strong class="source-inline">equals()</strong>, are the most-used methods and often re-implemented (overridden). The <strong class="source-inline">toString()</strong> method is typically<a id="_idIndexMarker244"/> used to print the state<a id="_idIndexMarker245"/> of the object. Its default implementation in JDK looks like this:</p>
			<pre class="source-code">public String toString() {</pre>
			<pre class="source-code">   return getClass().getName()+"@"+</pre>
			<pre class="source-code">                     Integer.toHexString(hashCode());</pre>
			<pre class="source-code">}</pre>
			<p>If we use it on the object of the <strong class="source-inline">TheChildClass</strong> class, the result will be as follows:</p>
			<pre class="source-code">TheChildClass ref1 = new TheChildClass("something");</pre>
			<pre class="source-code">System.out.println(ref1.toString());  </pre>
			<pre class="source-code">//prints: com.packt.learnjava.ch02_oop.</pre>
			<pre class="source-code">//Constructor$TheChildClass@72ea2f77</pre>
			<p>By the way, there is no need to call <strong class="source-inline">toString()</strong> explicitly while passing an object into the <strong class="source-inline">System.out.println()</strong> method and similar output methods because they do it inside the method anyway, and <strong class="source-inline">System.out.println(ref1)</strong>, in our case, produces the same result.</p>
			<p>So, as you can see, such an output is not human-friendly, so it is a good idea to override the <strong class="source-inline">toString()</strong> method. The easiest<a id="_idIndexMarker246"/> way to do it is by using an IDE. For example, in<a id="_idIndexMarker247"/> IntelliJ IDEA, right-click inside <strong class="source-inline">TheChildClass</strong> code, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B18388_Figure_2.1.jpg" alt=""/>
				</div>
			</div>
			<p>Select and click <strong class="bold">Generate...</strong>, and then select and click <strong class="bold">toString()</strong>, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B18388_Figure_2.2.jpg" alt=""/>
				</div>
			</div>
			<p>The new pop-up window will enable you to select the properties<a id="_idIndexMarker248"/> you wish to include in the <strong class="source-inline">toString()</strong> method. Select <a id="_idIndexMarker249"/>only the properties of <strong class="source-inline">TheChildClass</strong>, as follows:</p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B18388_Figure_2.3.jpg" alt=""/>
				</div>
			</div>
			<p>After you click the <strong class="bold">OK</strong> button, the following code will be generated:</p>
			<pre class="source-code">@Override</pre>
			<pre class="source-code">public String toString() {</pre>
			<pre class="source-code">    return "TheChildClass{" +</pre>
			<pre class="source-code">            "prop='" + prop + '\'' +</pre>
			<pre class="source-code">            '}';</pre>
			<pre class="source-code">}</pre>
			<p>If there were more properties in the class and you had selected them, more properties and their values would be included in the method output. If we print the object now, the result will be this:</p>
			<pre class="source-code">TheChildClass ref1 = new TheChildClass("something");</pre>
			<pre class="source-code">System.out.println(ref1.toString());  </pre>
			<pre class="source-code">                      //prints: TheChildClass{prop='something'}</pre>
			<p>That is why the <strong class="source-inline">toString()</strong> method is often overridden and even included in the services of an IDE.</p>
			<p>We will talk about the <strong class="source-inline">hashCode()</strong> and <strong class="source-inline">equals()</strong> methods in more detail in <a href="B18388_06_ePub.xhtml#_idTextAnchor141"><em class="italic">Chapter 6</em></a>, <em class="italic">Data Structures, Generics, and Popular Utilities</em>.</p>
			<p>The <strong class="source-inline">getClass()</strong> and <strong class="source-inline">clone()</strong> methods are not used as often. The <strong class="source-inline">getClass()</strong> method returns an object of the <strong class="source-inline">Class</strong> class that has many methods that provide various system information. The most used method is the one that returns the name of the class of the current object. The <strong class="source-inline">clone()</strong> method can be used to copy the current<a id="_idIndexMarker250"/> object. It works just fine as long as all the properties of the current object<a id="_idIndexMarker251"/> are of primitive types. But, if there is a reference type property, the <strong class="source-inline">clone()</strong> method has to be re-implemented so that the copy of the reference type can be done correctly. Otherwise, only the reference will be copied, not the object itself. Such a copy is called a <strong class="bold">shallow copy</strong>, which may be good<a id="_idIndexMarker252"/> enough in some cases. The <strong class="source-inline">protected</strong> keyword indicates that only children of the class can access it. See the <em class="italic">Packages, importing, and access</em> section.</p>
			<p>The last five of the class <strong class="source-inline">Object</strong> methods are used for communication between threads – the lightweight processes for concurrent processing. They are typically not re-implemented.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Instance and static properties and methods</h2>
			<p>So far, we have<a id="_idIndexMarker253"/> seen<a id="_idIndexMarker254"/> mostly<a id="_idIndexMarker255"/> methods<a id="_idIndexMarker256"/> that can<a id="_idIndexMarker257"/> be invoked<a id="_idIndexMarker258"/> only on<a id="_idIndexMarker259"/> an object (instance) of<a id="_idIndexMarker260"/> a class. Such methods are called <strong class="bold">instance methods</strong>. They typically use the values of the object properties (the object state). Otherwise, if they do not use the object state, they can be made <strong class="source-inline">static</strong> and invoked without creating an object. An example of such a method is the <strong class="source-inline">main()</strong> method. Here is another example:</p>
			<pre class="source-code">class SomeClass{</pre>
			<pre class="source-code">    public static void someMethod(int i){</pre>
			<pre class="source-code">        //do something</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This method can be called as follows:</p>
			<pre class="source-code">SomeClass.someMethod(42);</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Static methods can be called on an object too, but it is considered bad practice, as it hides the static nature of the method from a human trying to understand the code. Besides, it raises a compiler warning and, depending on the compiler implementation, may even generate a compiler error.</p>
			<p>Similarly, a property<a id="_idIndexMarker261"/> can be declared static<a id="_idIndexMarker262"/> and thus<a id="_idIndexMarker263"/> accessible<a id="_idIndexMarker264"/> without<a id="_idIndexMarker265"/> creating<a id="_idIndexMarker266"/> an object, such<a id="_idIndexMarker267"/> as the<a id="_idIndexMarker268"/> following:</p>
			<pre class="source-code">class SomeClass{</pre>
			<pre class="source-code">    public static String SOME_PROPERTY = "abc";</pre>
			<pre class="source-code">}</pre>
			<p>This property can be accessed directly via class too, as follows:</p>
			<pre class="source-code">System.out.println(SomeClass.SOME_PROPERTY);  //prints: abc</pre>
			<p>Having such a static property works against the idea of state encapsulation and may cause all the problems of concurrent data modification because it exists as a single copy in JVM memory, and all the methods that use it share the same value. That is why a static property is typically used for two purposes:</p>
			<ul>
				<li>To store a constant – a value<a id="_idIndexMarker269"/> that can be read but not modified (also called a <strong class="bold">read-only value</strong>)</li>
				<li>To store a stateless object that is expensive to create or that keeps read-only values</li>
			</ul>
			<p>A typical example of a constant is a name of a resource:</p>
			<pre class="source-code">class SomeClass{</pre>
			<pre class="source-code">    public static final String INPUT_FILE_NAME = "myFile.csv";</pre>
			<pre class="source-code">}</pre>
			<p>Note the <strong class="source-inline">final</strong> keyword in front of the static property. It tells the compiler and JVM that this value, once assigned, cannot change. An attempt to do it generates an error. It helps to protect the value and express clearly the intent to have this value as a constant. When a human tries to understand how the code works, such seemingly small details make the code easier to understand.</p>
			<p>That said, consider<a id="_idIndexMarker270"/> using interfaces for such<a id="_idIndexMarker271"/> a purpose. Since<a id="_idIndexMarker272"/> Java 1.8, all the fields declared<a id="_idIndexMarker273"/> in an interface<a id="_idIndexMarker274"/> are implicitly static<a id="_idIndexMarker275"/> and final, so there is less chance<a id="_idIndexMarker276"/> you’ll forget to declare a value to be final. We will talk about<a id="_idIndexMarker277"/> interfaces shortly.</p>
			<p>When an object is declared a static final class property, it does not mean all its properties become final automatically. It only protects the property from assigning another object of the same type. We will discuss the complicated procedure of concurrent access of an object property in <a href="B18388_08_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 8</em></a>, <em class="italic">Multithreading and Concurrent Processing</em>. Nevertheless, programmers often use static final objects to store the values that are read-only just by the way they are used in the application. A typical example would be application configuration information. Once created after reading from a disk, it is not changed, even if it could be. Also, caching of data is obtained from an external resource. </p>
			<p>Again, before using such a class property for this purpose, consider using an interface that provides more default behavior that supports a read-only functionality. </p>
			<p>Similar to static properties, static methods can be invoked without creating an instance of the class. Consider, for example, the following class:</p>
			<pre class="source-code">class SomeClass{</pre>
			<pre class="source-code">    public static String someMethod() {</pre>
			<pre class="source-code">        return "abc";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We<a id="_idIndexMarker278"/> can call<a id="_idIndexMarker279"/> the<a id="_idIndexMarker280"/> preceding<a id="_idIndexMarker281"/> method <a id="_idIndexMarker282"/>by using<a id="_idIndexMarker283"/> just<a id="_idIndexMarker284"/> a class<a id="_idIndexMarker285"/> name:</p>
			<pre class="source-code">System.out.println(SomeClass.someMethod()); //prints: abc</pre>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor059"/>Interface</h1>
			<p>In the <em class="italic">Abstraction/interface</em> section, we talked about an interface in general<a id="_idIndexMarker286"/> terms. In this section, we are going to describe a Java language construct that expresses it. </p>
			<p>An interface presents what can be expected of an object. It hides the implementation and exposes only method signatures with return values. For example, here is an interface that declares two abstract methods:</p>
			<pre class="source-code">interface SomeInterface {</pre>
			<pre class="source-code">    void method1();</pre>
			<pre class="source-code">    String method2(int i);</pre>
			<pre class="source-code">}</pre>
			<p>Here is a class that implements it:</p>
			<pre class="source-code">class SomeClass implements SomeInterface{</pre>
			<pre class="source-code">    public void method1(){</pre>
			<pre class="source-code">        //method body</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String method2(int i) {</pre>
			<pre class="source-code">        //method body</pre>
			<pre class="source-code">        return "abc";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>An interface<a id="_idIndexMarker287"/> cannot be instantiated. An object of an interface type can be created only by creating an object of a class that <em class="italic">implements</em> this interface:</p>
			<pre class="source-code">SomeInterface si = new SomeClass(); </pre>
			<p>If not all of the abstract methods of the interface have been implemented, the class must be declared abstract and cannot be instantiated. See the <em class="italic">Interface versus abstract class</em> section.</p>
			<p>An interface does not describe how the object of the class can be created. To discover that, you must look at the class and see what constructors it has. An interface also does not describe the static class methods. So, an interface is a public face of a class instance (object) only.</p>
			<p>With Java 8, an interface acquired the ability to have not just abstract methods (without a body) but really implemented ones. According to the Java Language Specification, “<em class="italic">the body of an interface may declare members of the interface, that is, fields, methods, classes, and interfaces</em>.” Such a broad statement brings up the question, what is the difference between an interface and a class? One principal difference that we have pointed out already is this – an interface cannot be instantiated; only a class can be instantiated.</p>
			<p>Another difference is that a non-static method implemented inside an interface is declared <strong class="source-inline">default</strong> or <strong class="source-inline">private</strong>. By contrast, a <strong class="source-inline">default</strong> declaration is not available for the class methods.</p>
			<p>Also, fields in an interface are implicitly public, static, and final. By contrast, class properties and methods are not static or final by default. The implicit (default) access modifier<a id="_idIndexMarker288"/> of a class itself, its fields, methods, and constructors are package-private, which means it is visible only within its own package. </p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Default methods</h2>
			<p>To get an idea about the function of default methods<a id="_idIndexMarker289"/> in an interface, let’s look<a id="_idIndexMarker290"/> at an example of an interface and a class that implements it, as follows:</p>
			<pre class="source-code">interface SomeInterface {</pre>
			<pre class="source-code">    void method1();</pre>
			<pre class="source-code">    String method2(int i);</pre>
			<pre class="source-code"><strong class="bold">    default int method3(){</strong></pre>
			<pre class="source-code"><strong class="bold">        return 42;</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class SomeClass implements SomeInterface{</pre>
			<pre class="source-code">    public void method1(){</pre>
			<pre class="source-code">        //method body</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String method2(int i) {</pre>
			<pre class="source-code">        //method body</pre>
			<pre class="source-code">        return "abc";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>We can now create an object of the <strong class="source-inline">SomeClass</strong> class and make the following call:</p>
			<pre class="source-code">SomeClass sc = new SomeClass();</pre>
			<pre class="source-code">sc.method1();</pre>
			<pre class="source-code">sc.method2(22);  //returns: "abc"</pre>
			<pre class="source-code">System.out.println(sc.method2(22)); //prints: abc</pre>
			<pre class="source-code">sc.method3();    //returns: 42</pre>
			<pre class="source-code">System.out.println(sc.method3());   //prints: 42</pre>
			<p>As you can see, <strong class="source-inline">method3()</strong> is not implemented in the <strong class="source-inline">SomeClass</strong> class, but it looks as if the class has it. That is one<a id="_idIndexMarker291"/> way to add a new method to an existing class without<a id="_idIndexMarker292"/> changing it – by adding the default method to the interface the class implements.</p>
			<p>Let’s now add the <strong class="source-inline">method3()</strong> implementation to the class too, as follows:</p>
			<pre class="source-code">class SomeClass implements SomeInterface{</pre>
			<pre class="source-code">    public void method1(){</pre>
			<pre class="source-code">        //method body</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String method2(int i) {</pre>
			<pre class="source-code">        //method body</pre>
			<pre class="source-code">        return "abc";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    <strong class="bold">public int method3(){</strong></pre>
			<pre class="source-code"><strong class="bold">        return 15;</strong></pre>
			<pre class="source-code"><strong class="bold">    }</strong></pre>
			<pre class="source-code">}</pre>
			<p>Now, the interface implementation of <strong class="source-inline">method3()</strong> will be ignored:</p>
			<pre class="source-code">SomeClass sc = new SomeClass();</pre>
			<pre class="source-code">sc.method1();</pre>
			<pre class="source-code">sc.method2(22);  //returns: "abc"</pre>
			<pre class="source-code"><strong class="bold">sc.method3();    //returns: 15</strong></pre>
			<pre class="source-code"><strong class="bold">System.out.println(sc.method3());      //prints: 15</strong></pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The purpose of the default method<a id="_idIndexMarker293"/> in an interface is to provide a new method<a id="_idIndexMarker294"/> to the classes (that implement this interface) without changing them. But the interface implementation is ignored as soon as a class implements the new method too.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Private methods</h2>
			<p>If there are several default methods<a id="_idIndexMarker295"/> in an interface, it is possible to create private methods<a id="_idIndexMarker296"/> accessible only by the default methods of the interface. They can be used to contain common functionality, instead of repeating it in every default method:</p>
			<pre class="source-code">interface SomeInterface {</pre>
			<pre class="source-code">    void method1();</pre>
			<pre class="source-code">    String method2(int i);</pre>
			<pre class="source-code">    default int method3(){</pre>
			<pre class="source-code">        return getNumber();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    default int method4(){</pre>
			<pre class="source-code">        return getNumber() + 22;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    private int getNumber(){</pre>
			<pre class="source-code">        return 42;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>This concept of private methods is not different from private methods in classes (see the <em class="italic">Packages, importing, and access</em> section). The private<a id="_idIndexMarker297"/> methods cannot be accessed<a id="_idIndexMarker298"/> from outside the interface.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Static fields and methods</h2>
			<p>Since Java 8, all the fields<a id="_idIndexMarker299"/> declared in an interface are implicitly public, static, and final<a id="_idIndexMarker300"/> constants. That is why an interface<a id="_idIndexMarker301"/> is a preferred location<a id="_idIndexMarker302"/> for the constants. You do not need to add <strong class="source-inline">public static final</strong> to their declarations.</p>
			<p>As for the static methods, they function in an interface in the same way as in a class:</p>
			<pre class="source-code">interface SomeInterface{</pre>
			<pre class="source-code">   static String someMethod() {</pre>
			<pre class="source-code">      return "abc";</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>Note that there is no need to mark the interface method as <strong class="source-inline">public</strong>. All non-private interface methods are public by default.</p>
			<p>We can call the preceding method by using just an interface name:</p>
			<pre class="source-code">System.out.println(SomeInetrface.someMethod()); //prints: abc</pre>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Interface versus abstract class</h2>
			<p>We have mentioned already that a class can be declared <strong class="source-inline">abstract</strong>. It may be a regular class that<a id="_idIndexMarker303"/> we do not want to be instantiated, or it may<a id="_idIndexMarker304"/> be a class that contains (or inherits) abstract methods. In the last case, we must declare such a class as <strong class="source-inline">abstract</strong> to avoid a compilation error.</p>
			<p>In many respects, an abstract class is very similar to an interface. It forces every <strong class="source-inline">child</strong> class that extends it to implement the abstract methods. Otherwise, the child cannot be instantiated and has to be declared abstract itself. </p>
			<p>However, a few principal differences between an interface and abstract class make each of them useful in different situations:</p>
			<ul>
				<li>An abstract<a id="_idIndexMarker305"/> class can have a constructor, while an interface<a id="_idIndexMarker306"/> cannot.</li>
				<li>An abstract class can have a state, while an interface cannot.</li>
				<li>The fields of an abstract class can be <strong class="source-inline">public</strong>, <strong class="source-inline">private</strong>, or <strong class="source-inline">protected</strong>, <strong class="source-inline">static</strong> or not, and <strong class="source-inline">final</strong> or not, while, in an interface, fields are always <strong class="source-inline">public</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">final</strong>.</li>
				<li>The methods in an abstract class can be <strong class="source-inline">public</strong>, <strong class="source-inline">private</strong>, or <strong class="source-inline">protected</strong>, while the interface methods can be <strong class="source-inline">public</strong> or <strong class="source-inline">private</strong> only.</li>
				<li>If the class you would like to amend extends another class already, you cannot use an abstract class, but you can implement an interface because a class can extend only one other class but can implement multiple interfaces.</li>
			</ul>
			<p>You will see an example of abstract usage in the <em class="italic">Polymorphism in action</em> section.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor064"/>Overloading, overriding, and hiding</h1>
			<p>We have already mentioned overriding in the <em class="italic">Inheritance</em> and <em class="italic">Abstraction/interface</em> sections. It is a replacement of a non-static method implemented<a id="_idIndexMarker307"/> in a parent class<a id="_idIndexMarker308"/> with the method of the same signatures in the <strong class="source-inline">child</strong> class. The default<a id="_idIndexMarker309"/> method of an interface also can be overridden in the interface that extends it. Hiding is similar to overriding but applies only to static methods and static, as well as properties of the instance.</p>
			<p>Overloading is creating several methods with the same name and different parameters (thus, different signatures) in the same class or interface. </p>
			<p>In this section, we will discuss all these concepts and demonstrate how they work for classes and interfaces.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Overloading</h2>
			<p>It is not possible to have<a id="_idIndexMarker310"/> two methods in the same interface or a class with the same signature. To have a different signature, the new method has to have either a new name or a different list of parameter types (and the sequence of the type does matter). Having two methods with the same name but a different list of parameter types constitutes overloading. Here are a few examples of a legitimate method of overloading in an interface:</p>
			<pre class="source-code">interface A {</pre>
			<pre class="source-code">    int m(String s);</pre>
			<pre class="source-code">    int m(String s, double d);</pre>
			<pre class="source-code">    default int m(String s, int i) { return 1; }</pre>
			<pre class="source-code">    static int m(String s, int i, double d) { return 1; }</pre>
			<pre class="source-code">}</pre>
			<p>Note that no two of the preceding methods have the same signature, including the default and static methods. Otherwise, a compiler’s error would be generated. Neither designation as default nor static plays any role in the overloading. A return type does not affect the overloading either. We use <strong class="source-inline">int</strong> as a return type everywhere just to make the examples less cluttered.</p>
			<p>Method overloading is done similarly in a class:</p>
			<pre class="source-code">    class C {</pre>
			<pre class="source-code">        int m(String s){ return 42; }</pre>
			<pre class="source-code">        int m(String s, double d){ return 42; }</pre>
			<pre class="source-code">        static int m(String s, double d, int i) { return 1; }</pre>
			<pre class="source-code">    }</pre>
			<p>And it does not matter where the methods with the same name are declared. The following method overloading is not different from the previous example, as follows:</p>
			<pre class="source-code">interface A {</pre>
			<pre class="source-code">    int m(String s);</pre>
			<pre class="source-code">    int m(String s, double d);</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">interface B extends A {</pre>
			<pre class="source-code">    default int m(String s, int i) { return 1; }</pre>
			<pre class="source-code">    static int m(String s, int i, double d) { return 1; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class C {</pre>
			<pre class="source-code">     int m(String s){ return 42; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class D extends C {</pre>
			<pre class="source-code">     int m(String s, double d){ return 42; }</pre>
			<pre class="source-code">     static int m(String s, double d, int i) { return 1; }</pre>
			<pre class="source-code">}</pre>
			<p>A private non-static method<a id="_idIndexMarker311"/> can be overloaded only by a non-static method of the same class.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Overloading happens when methods have the same name but a different list of parameter types and belong to the same interface (or class) or to different interfaces (or classes), one of which is an ancestor to another. A private method can be overloaded only by a method in the same class.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Overriding</h2>
			<p>In contrast to overloading, which happens with<a id="_idIndexMarker312"/> the static and non-static methods, method overriding happens only with non-static methods and only when they have <em class="italic">exactly the same signature</em> and <em class="italic">belong to different interfaces (or classes)</em>, one of which is an ancestor to another.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">The overriding method resides in the child interface (or class), while the overridden method has the same signature and belongs to one of the ancestor interfaces (or classes). A private method cannot be overridden.</p>
			<p>The following are examples<a id="_idIndexMarker313"/> of a method overriding an interface: </p>
			<pre class="source-code">interface A {</pre>
			<pre class="source-code">    default void method(){</pre>
			<pre class="source-code">        System.out.println("interface A");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">interface B extends A{</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    default void method(){</pre>
			<pre class="source-code">        System.out.println("interface B");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class C implements B { }</pre>
			<p>If we call the <strong class="source-inline">method()</strong> using the <strong class="source-inline">C</strong> class instance, the result will be as follows:</p>
			<pre class="source-code">C c = new C();</pre>
			<pre class="source-code">c.method();      //prints: interface B</pre>
			<p>Please note the usage of the <strong class="source-inline">@Override</strong> annotation. It tells the compiler that the programmer thinks that the annotated method overrides a method of one of the ancestor interfaces. This way, the compiler can make sure that the overriding does happen and generates an error if it doesn’t. For example, a programmer may misspell the name of the method, as follows:</p>
			<pre class="source-code">interface B extends A{</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    default void method(){</pre>
			<pre class="source-code">        System.out.println("interface B");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If that happens, the compiler<a id="_idIndexMarker314"/> generates an error because there is no <strong class="source-inline">metod()</strong> method to override. Without the <strong class="source-inline">@Overrride</strong> annotation, this mistake may go unnoticed by the programmer, and the result would be quite different:</p>
			<pre class="source-code">C c = new C();</pre>
			<pre class="source-code">c.method();      //prints: interface A</pre>
			<p>The same rules of overriding apply to the class instance methods. In the following example, the <strong class="source-inline">C2</strong> class overrides a method of the <strong class="source-inline">C1</strong> class:</p>
			<pre class="source-code">class C1{</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        System.out.println("class C1");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class C2 extends C1{</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        System.out.println("class C2");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The result is as follows:</p>
			<pre class="source-code">C2 c2 = new C2();</pre>
			<pre class="source-code">c2.method();      //prints: class C2</pre>
			<p>It does not matter how many ancestors are between the class or interface with the overridden method and the class<a id="_idIndexMarker315"/> or interface with the overriding method:</p>
			<pre class="source-code">class C1{</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        System.out.println("class C1");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class C3 extends C1{</pre>
			<pre class="source-code">    public void someOtherMethod(){</pre>
			<pre class="source-code">        System.out.println("class C3");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class C2 extends C3{</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public void method(){</pre>
			<pre class="source-code">        System.out.println("class C2");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The result of the preceding method’s overriding will still be the same.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Hiding</h2>
			<p><strong class="bold">Hiding</strong> is considered by many<a id="_idIndexMarker316"/> to be a complicated topic, but it should not be, and we will try to make it look simple.</p>
			<p>The name <em class="italic">hiding</em> came from the behavior of static properties and methods of classes and interfaces. Each static property or method exists as a single copy in the JVM’s memory because they are associated with the interface or class, not with an object. An interface or class exists as a single copy. That is why we cannot say that the child’s static property or method overrides the parent’s static property or method with the same name. All static properties<a id="_idIndexMarker317"/> and methods are loaded into the memory only once when the class or interface is loaded and stay there, not being copied anywhere. Let’s look at an example.</p>
			<p>Let’s create two interfaces that have a parent-child relationship and static fields and methods with the same name:</p>
			<pre class="source-code">interface A {</pre>
			<pre class="source-code">    String NAME = "interface A";</pre>
			<pre class="source-code">    static void method() {</pre>
			<pre class="source-code">        System.out.println("interface A");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">interface B extends A {</pre>
			<pre class="source-code">    String NAME = "interface B";</pre>
			<pre class="source-code">    static void method() {</pre>
			<pre class="source-code">        System.out.println("interface B");</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Please note the capital case for an identifier of an interface field. That’s the convention often used to denote a constant, whether it is declared in an interface or a class. Just to remind you, a constant in Java is a variable that, once initialized, cannot be re-assigned another value. An interface field is a constant by default because any field in an interface is <em class="italic">final</em> (see the <em class="italic">Final properties, methods, and classes</em> section).</p>
			<p>If we print <strong class="source-inline">NAME</strong> from the <strong class="source-inline">B</strong> interface and execute its <strong class="source-inline">method()</strong>, we get the following result:</p>
			<pre class="source-code">System.out.println(B.NAME); //prints: interface B</pre>
			<pre class="source-code">B.method();                 //prints: interface B</pre>
			<p>It looks very much like overriding, but, in fact, it is just that we call a particular property or a method associated <a id="_idIndexMarker318"/>with this particular interface.</p>
			<p>Similarly, consider the following classes:</p>
			<pre class="source-code">public class C {</pre>
			<pre class="source-code">    public static String NAME = "class C";</pre>
			<pre class="source-code">    public static void method(){</pre>
			<pre class="source-code">        System.out.println("class C"); </pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String name1 = "class C";</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">public class D extends C {</pre>
			<pre class="source-code">    public static String NAME = "class D";</pre>
			<pre class="source-code">    public static void method(){</pre>
			<pre class="source-code">        System.out.println("class D"); </pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String name1 = "class D";</pre>
			<pre class="source-code">}</pre>
			<p>If we try to access the static members of the <strong class="source-inline">D</strong> class using the class itself, we will get what we asked for:</p>
			<pre class="source-code">System.out.println(D.NAME);  //prints: class D</pre>
			<pre class="source-code">D.method();                  //prints: class D</pre>
			<p>The confusion appears only when a property or a static method is accessed using an object:</p>
			<pre class="source-code">C obj = new D();</pre>
			<pre class="source-code">System.out.println(obj.NAME);        //prints: class C</pre>
			<pre class="source-code">System.out.println(((D) obj).NAME);  //prints: class D</pre>
			<pre class="source-code">obj.method();                        //prints: class C</pre>
			<pre class="source-code">((D)obj).method();                   //prints: class D</pre>
			<pre class="source-code">System.out.println(obj.name1);       //prints: class C</pre>
			<pre class="source-code">System.out.println(((D) obj).name1); //prints: class D</pre>
			<p>The <strong class="source-inline">obj</strong> variable refers to the object of the <strong class="source-inline">D</strong> class, and the<a id="_idIndexMarker319"/> casting proves it, as you can see in the preceding example. But, even if we use an object, trying to access a static property or method brings<a id="_idIndexMarker320"/> us the members of the class that was used as the declared variable type. As for the instance property in the last two lines of the example, the properties in Java do not conform to polymorphic behavior, and we get the <strong class="source-inline">name1</strong> property of the parent <strong class="source-inline">C</strong> class, instead of the expected property of the child <strong class="source-inline">D</strong> class.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">To avoid confusion with static members of a class, always access them using the class, not an object. To avoid confusion with instance properties, always declare them private and access them via methods.</p>
			<p>To illustrate the last tip, consider the following classes:</p>
			<pre class="source-code">class X {</pre>
			<pre class="source-code">    private String name = "class X";</pre>
			<pre class="source-code">    public String getName() {</pre>
			<pre class="source-code">        return name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void setName(String name) {</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class Y extends X {</pre>
			<pre class="source-code">    private String name = "class Y";</pre>
			<pre class="source-code">    public String getName() {</pre>
			<pre class="source-code">        return name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public void setName(String name) {</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>If we run the same test for the instance<a id="_idIndexMarker321"/> properties as we did for the <strong class="source-inline">C</strong> and <strong class="source-inline">D</strong> classes, the result will be this:</p>
			<pre class="source-code">X x = new Y();</pre>
			<pre class="source-code">System.out.println(x.getName());      //prints: class Y</pre>
			<pre class="source-code">System.out.println(((Y)x).getName()); //prints: class Y</pre>
			<p>Now, we access instance properties using methods, which are subjects for an overriding effect and do not have unexpected results anymore.</p>
			<p>To conclude the discussion of hiding in Java, we would like to mention another type of hiding, namely when a local variable hides the instance or static property with the same name. Here is a class that does it:</p>
			<pre class="source-code">public class HidingProperty {</pre>
			<pre class="source-code">   private static String name1 = "static property";</pre>
			<pre class="source-code">   private String name2 = "instance property";</pre>
			<pre class="source-code">   public void method() {</pre>
			<pre class="source-code">      var name1 = "local variable";</pre>
			<pre class="source-code">      System.out.println(name1);     //prints: local variable</pre>
			<pre class="source-code">      var name2 = "local variable";  //prints: local variable</pre>
			<pre class="source-code">      System.out.println(name2);</pre>
			<pre class="source-code">      System.out.println(HidingProperty.name1); </pre>
			<pre class="source-code">                                     //prints: static property</pre>
			<pre class="source-code">      System.out.println(this.name2);</pre>
			<pre class="source-code">                                   //prints: instance property</pre>
			<pre class="source-code">   }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the <strong class="source-inline">name1</strong> local variable hides the static property with the same name, while the <strong class="source-inline">name2</strong> local variable hides the instance property. It is possible still to access the static property<a id="_idIndexMarker322"/> using the class name (see <strong class="source-inline">HidingProperty.name1</strong>). Please note that, despite being declared <strong class="source-inline">private</strong>, it is accessible from inside the class. </p>
			<p>The instance property can always be accessed<a id="_idIndexMarker323"/> by using the <strong class="source-inline">this</strong> keyword, which<a id="_idIndexMarker324"/> means the <strong class="bold">current object</strong>.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>The final variable, method, and classes</h1>
			<p>We have mentioned a <strong class="source-inline">final</strong> property several times in relation to the notion of a constant in Java, but<a id="_idIndexMarker325"/> that is only one case of using the <strong class="source-inline">final</strong> keyword. It can be applied<a id="_idIndexMarker326"/> to any variable in general. Also, a similar constraint can be applied<a id="_idIndexMarker327"/> to a method and even a class too, thus preventing the method from being overridden and the class from being extended.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>The final variable</h2>
			<p>The <strong class="source-inline">final</strong> keyword placed in front of a variable declaration<a id="_idIndexMarker328"/> makes this variable immutable after the initialization, such as the following:</p>
			<pre class="source-code">final String s = "abc";</pre>
			<p>The initialization can even be delayed:</p>
			<pre class="source-code">final String s;</pre>
			<pre class="source-code">s = "abc";</pre>
			<p>In the case of an <strong class="source-inline">object</strong> property, this delay can last only until the object is created. This means that the property can be initialized in the constructor, such as the following:</p>
			<pre class="source-code">class A {</pre>
			<pre class="source-code">    private final String s1 = "abc";</pre>
			<pre class="source-code">    private final String s2;</pre>
			<pre class="source-code">    private final String s3;   //error</pre>
			<pre class="source-code">    private final int x;       //error</pre>
			<pre class="source-code">    public A() {</pre>
			<pre class="source-code">        this.s1 = "xyz";      //error</pre>
			<pre class="source-code">        this.s2 = "xyz";     </pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Note that, even during the object construction, it is not possible to initialize the property twice – during declaration and in the constructor. It is also interesting to note that a final property has to be initialized explicitly. As you can see from the preceding example, the compiler does not allow the initialization of the final property to a default value.</p>
			<p>It is also possible to initialize a <strong class="source-inline">final</strong> property in an initialization block:</p>
			<pre class="source-code">class B {</pre>
			<pre class="source-code">    private final String s1 = "abc";</pre>
			<pre class="source-code">    private final String s2;</pre>
			<pre class="source-code">    {</pre>
			<pre class="source-code">        s1 = "xyz"; //error</pre>
			<pre class="source-code">        s2 = "abc";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In the case of a <strong class="source-inline">static</strong> property, it is not possible<a id="_idIndexMarker329"/> to initialize it in a constructor, so it has to be initialized either during its declaration or in a static initialization block:</p>
			<pre class="source-code">class C {</pre>
			<pre class="source-code">    private final static String s1 = "abc";</pre>
			<pre class="source-code">    private final static String s2;</pre>
			<pre class="source-code">    static {</pre>
			<pre class="source-code">        s1 = "xyz"; //error</pre>
			<pre class="source-code">        s2 = "abc";</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>In an interface, all fields are always final, even if they are not declared as such. Since neither a constructor nor an initialization block is not allowed in an interface, the only way to initialize an interface field is during declaration. Failing to do it results in a compilation error:</p>
			<pre class="source-code">interface I {</pre>
			<pre class="source-code">    String s1;  //error</pre>
			<pre class="source-code">    String s2 = "abc";</pre>
			<pre class="source-code">}</pre>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>Final method</h2>
			<p>A method declared <strong class="source-inline">final</strong> cannot be overridden in a <strong class="source-inline">child</strong> class or hidden in the case of a static<a id="_idIndexMarker330"/> method. For example, the <strong class="source-inline">java.lang.Object</strong> class, which is the ancestor of all classes in Java, has some of its methods declared <strong class="source-inline">final</strong>:</p>
			<pre class="source-code">public final Class getClass()x</pre>
			<pre class="source-code">public final void notify()</pre>
			<pre class="source-code">public final void notifyAll()</pre>
			<pre class="source-code">public final void wait() throws InterruptedException</pre>
			<pre class="source-code">public final void wait(long timeout) </pre>
			<pre class="source-code">                         throws InterruptedException</pre>
			<pre class="source-code">public final void wait(long timeout, int nanos)</pre>
			<pre class="source-code">                         throws InterruptedException</pre>
			<p>All the private methods and uninherited methods of a <strong class="source-inline">final</strong> class are effectively final because you cannot override them.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>Final class</h2>
			<p>A <strong class="source-inline">final</strong> class cannot be extended. It cannot have children, which makes all the methods<a id="_idIndexMarker331"/> of the class effectively <strong class="source-inline">final</strong> too. This feature is used for security or when a programmer would like to make sure the class functionality cannot be overridden, overloaded, or hidden because of some other design considerations.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/>The record class</h1>
			<p>The <strong class="source-inline">record</strong> class<a id="_idIndexMarker332"/> was added to the SDK in Java 16. It was a long-awaited Java feature. It allows you to avoid writing boilerplate code in a case when you need an immutable class (with getters only), which looks similar to the following <strong class="source-inline">Person</strong> class (see the <strong class="source-inline">Record</strong> class in the <strong class="source-inline">ch02_oop</strong> folder):</p>
			<pre class="source-code">final class Person {</pre>
			<pre class="source-code">    private int age;</pre>
			<pre class="source-code">    private String name;</pre>
			<pre class="source-code">    public Person(int age, String name) {</pre>
			<pre class="source-code">        this.age = age;</pre>
			<pre class="source-code">        this.name = name;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int age() { return age; }</pre>
			<pre class="source-code">    public String name() { return name; }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public boolean equals(Object o) {</pre>
			<pre class="source-code">        //implementation not shown for brevity</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public int hashCode() {</pre>
			<pre class="source-code">        //implementation not shown for brevity</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public String toString() {</pre>
			<pre class="source-code">        //implementation not shown for brevity</pre>
			<pre class="source-code">    }</pre>
			<p>Please note that the getters<a id="_idIndexMarker333"/> in the preceding above do not have the <strong class="source-inline">get</strong> prefix. It is done deliberately because, in the case of immutable class, there is no need to distinguish between getters and setters, as setters do not and should not exist if we want to have the class truly immutable. And that is the principal difference between such a class and JavaBeans, which are mutable and have both – setters and getters.</p>
			<p>The <strong class="source-inline">record</strong> class allows you to replace the preceding implementation with the following one line only:</p>
			<pre class="source-code">record Person(int age, String name){}</pre>
			<p>We can demonstrate<a id="_idIndexMarker334"/> it with the following code:</p>
			<pre class="source-code">record PersonR(int age, String name){} //We added suffix "R" </pre>
			<pre class="source-code">                 //to distinguish this class from class Person</pre>
			<pre class="source-code">Person person = new Person(25, "Bill");</pre>
			<pre class="source-code">System.out.println(person);  </pre>
			<pre class="source-code">                          //prints: Person{age=25, name='Bill'}</pre>
			<pre class="source-code">System.out.println(person.name());            //prints: Bill</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">Person person1 = new Person(25, "Bill");</pre>
			<pre class="source-code">System.out.println(person.equals(person1));   //prints: true</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">PersonR personR = new PersonR(25, "Bill");</pre>
			<pre class="source-code">System.out.println(personR);   </pre>
			<pre class="source-code">                         //prints: PersonR{age=25, name='Bill'}</pre>
			<pre class="source-code">System.out.println(personR.name());           //prints: Bill</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">PersonR personR1 = new PersonR(25, "Bill");</pre>
			<pre class="source-code">System.out.println(personR.equals(personR1)); //prints: true</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">System.out.println(personR.equals(person));   //prints: false</pre>
			<p>In addition to being <strong class="source-inline">final</strong> (not extendable) and immutable, <strong class="source-inline">record</strong> cannot extend another class because<a id="_idIndexMarker335"/> it already extends <strong class="source-inline">java.lang.Record</strong>, but it can implement another interface, as shown in the following example:</p>
			<pre class="source-code">interface Student{</pre>
			<pre class="source-code">    String getSchoolName();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">record StudentImpl(String name, String school) implements Student{</pre>
			<pre class="source-code">    @Override</pre>
			<pre class="source-code">    public String getSchoolName() { return school(); }</pre>
			<pre class="source-code">}</pre>
			<p>It is possible to add a <strong class="source-inline">static</strong> method to <strong class="source-inline">record</strong>, as shown in the following code snippet:</p>
			<pre class="source-code">record StudentImpl(String name, String school) implements Student{</pre>
			<pre class="source-code">    public static String getSchoolName(Student student) {</pre>
			<pre class="source-code">         return student.getSchoolName();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>A <strong class="source-inline">static</strong> method does not and cannot access instance properties and can utilize only the values passed into it as parameters.</p>
			<p><strong class="source-inline">record</strong> can have another constructor, which can be added, for example, as follows:</p>
			<pre class="source-code">record StudentImpl(String name, String school) implements Student{</pre>
			<pre class="source-code">    public StudentImpl(String name) {</pre>
			<pre class="source-code">        this(name, "Unknown");</pre>
			<pre class="source-code">    } </pre>
			<pre class="source-code">}</pre>
			<p>As you may have noticed, it is not possible to add another property or a setter to <strong class="source-inline">record</strong>, while all additional<a id="_idIndexMarker336"/> getters have to use only getters provided already by <strong class="source-inline">record</strong>. </p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/>Sealed classes and interfaces</h1>
			<p>A <strong class="source-inline">final</strong> class cannot be extended, while a non-public class or interface has limited access. Yet, there are times<a id="_idIndexMarker337"/> when a class or interface needs to be accessible from anywhere<a id="_idIndexMarker338"/> but be extendable only by a certain class or interface, or, in the case of an interface, be implemented only by certain classes. That was the motivation for <strong class="source-inline">sealed</strong> classes and interfaces being added to the SDK in Java 17.</p>
			<p>The difference between a <strong class="source-inline">sealed</strong> class or interface and a <strong class="source-inline">final</strong> one is that a <strong class="source-inline">sealed</strong> class or interface always has a <strong class="source-inline">permits</strong> keyword, followed by the list of the existing direct subtypes that are allowed to extend the <strong class="source-inline">sealed</strong> class or interface, or, in the case of the interface, implement it. Please note the word <em class="italic">existing</em>. The subtypes listed after the <strong class="source-inline">permits</strong> keyword must exist at compilation time in the same module as the sealed class or in the same package if in the default (unnamed) module.</p>
			<p>A subtype of a <strong class="source-inline">sealed</strong> class must be marked either <strong class="source-inline">sealed</strong>, <strong class="source-inline">final</strong>, or <strong class="source-inline">non-sealed</strong>. A subtype of a <strong class="source-inline">sealed</strong> interface must be marked either <strong class="source-inline">sealed</strong> or <strong class="source-inline">non-sealed</strong>, since an interface cannot be <strong class="source-inline">final</strong>. </p>
			<p>Let’s look at an example of a <strong class="source-inline">sealed</strong> interface first:</p>
			<pre class="source-code">sealed interface Engine permits EngineBrand {</pre>
			<pre class="source-code">    int getHorsePower();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">sealed interface EngineBrand extends Engine permits Vehicle {</pre>
			<pre class="source-code">    String getBrand();</pre>
			<pre class="source-code">} </pre>
			<pre class="source-code">non-sealed class Vehicle implements EngineBrand {</pre>
			<pre class="source-code">    private final String make, model, brand;</pre>
			<pre class="source-code">    private final int horsePower;</pre>
			<pre class="source-code">    public Vehicle(String make, String model, </pre>
			<pre class="source-code">                   String brand, int horsePower) {</pre>
			<pre class="source-code">        this.make = make;</pre>
			<pre class="source-code">        this.model = model;</pre>
			<pre class="source-code">        this.brand = brand;</pre>
			<pre class="source-code">        this.horsePower = horsePower;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String getMake() { return make; }</pre>
			<pre class="source-code">    public String getModel() { return model; }</pre>
			<pre class="source-code">    public String getBrand() { return brand; }</pre>
			<pre class="source-code">    public int getHorsePower() { return horsePower; }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, the <strong class="source-inline">EngineBrand</strong> interface<a id="_idIndexMarker339"/> extends the <strong class="source-inline">Engine</strong> interface and allows (permits) the <strong class="source-inline">Vehicle</strong> implementation. Alternatively, we can allow the <strong class="source-inline">Vehicle</strong> class<a id="_idIndexMarker340"/> to implement the <strong class="source-inline">Engine</strong> interface directly, as shown in the following example:</p>
			<pre class="source-code">sealed interface Engine permits EngineBrand, Vehicle {</pre>
			<pre class="source-code">    int getHorsePower();</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">sealed interface EngineBrand extends Engine permits Vehicle {</pre>
			<pre class="source-code">    String getBrand();</pre>
			<pre class="source-code">} </pre>
			<pre class="source-code">non-sealed class Vehicle implements Engine, EngineBrand {...}</pre>
			<p>Now, let’s look<a id="_idIndexMarker341"/> at an example<a id="_idIndexMarker342"/> of a <strong class="source-inline">sealed</strong> class:</p>
			<pre class="source-code">sealed class Vehicle permits Car, Truck {</pre>
			<pre class="source-code">    private final String make, model;</pre>
			<pre class="source-code">    private final int horsePower;</pre>
			<pre class="source-code">    public Vehicle(String make, String model, int horsePower) {</pre>
			<pre class="source-code">        this.make = make;</pre>
			<pre class="source-code">        this.model = model;</pre>
			<pre class="source-code">        this.horsePower = horsePower;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public String getMake() { return make; }</pre>
			<pre class="source-code">    public String getModel() { return model; }</pre>
			<pre class="source-code">    public int getHorsePower() { return horsePower; }</pre>
			<pre class="source-code">}</pre>
			<p>The following is an example of the <strong class="source-inline">Car</strong> and <strong class="source-inline">Truck</strong> permitted subtypes of the <strong class="source-inline">Vehicle</strong> <strong class="source-inline">sealed</strong> class:</p>
			<pre class="source-code">final class Car extends Vehicle {</pre>
			<pre class="source-code">    private final int passengerCount;</pre>
			<pre class="source-code">    public Car(String make, String model, int horsePower, </pre>
			<pre class="source-code">      int passengerCount) {</pre>
			<pre class="source-code">        super(make, model, horsePower);</pre>
			<pre class="source-code">        this.passengerCount = passengerCount;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getPassengerCount() { return passengerCount; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">non-sealed class Truck extends Vehicle {</pre>
			<pre class="source-code">    private final int payloadPounds;</pre>
			<pre class="source-code">    public Truck(String make, String model, int horsePower, </pre>
			<pre class="source-code">      int payloadPounds) {</pre>
			<pre class="source-code">        super(make, model, horsePower);</pre>
			<pre class="source-code">        this.payloadPounds = payloadPounds;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getPayloadPounds() { return payloadPounds; }</pre>
			<pre class="source-code">}</pre>
			<p>In support <strong class="source-inline">sealed</strong> classes, the Java Reflections<a id="_idIndexMarker343"/> API in Java 17 has two new<a id="_idIndexMarker344"/> methods, <strong class="source-inline">isSealed()</strong> and <strong class="source-inline">getPermittedSubclasses()</strong>. The following is an example of their usage:</p>
			<pre class="source-code">Vehicle vehicle = new Vehicle("Ford", "Taurus", 300);</pre>
			<pre class="source-code">System.out.println(vehicle.getClass().isSealed());  </pre>
			<pre class="source-code">                                                 //prints: true</pre>
			<pre class="source-code">System.out.println(Arrays.stream(vehicle.getClass()</pre>
			<pre class="source-code">                .getPermittedSubclasses())</pre>
			<pre class="source-code">                .map(Objects::toString).toList());</pre>
			<pre class="source-code">                             //prints list of permitted classes</pre>
			<pre class="source-code"> </pre>
			<pre class="source-code">Car car = new Car("Ford", "Taurus", 300, 4);</pre>
			<pre class="source-code">System.out.println(car.getClass().isSealed());  //prints: false</pre>
			<pre class="source-code">System.out.println(car.getClass().getPermittedSubclasses());</pre>
			<pre class="source-code">                                                 //prints: null</pre>
			<p>The <strong class="source-inline">sealed</strong> interface integrates well with <strong class="source-inline">record</strong> because <strong class="source-inline">record</strong> is <strong class="source-inline">final</strong> and can be listed<a id="_idIndexMarker345"/> as a permittable<a id="_idIndexMarker346"/> implementation.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Polymorphism in action</h1>
			<p>Polymorphism is the most powerful<a id="_idIndexMarker347"/> and useful feature of OOP. It uses all the other OOP concepts and features we have presented so far. It is the highest conceptual point on the way to mastering Java programming. After discussing it, the rest of the book will be mostly about Java language syntax and JVM functionality. </p>
			<p>As we stated in the <em class="italic">OOP concepts</em> section, polymorphism is the ability of an object to behave as an object of different classes or as an implementation of different interfaces. If you search the word <em class="italic">polymorphism</em> on the internet, you will find that it is <em class="italic">the condition of occurring in several different forms</em>. Metamorphosis is <em class="italic">a change of the form or nature of a thing or person into a completely different one, by natural or supernatural means</em>. So, <strong class="bold">Java polymorphism</strong> is the ability of an object<a id="_idIndexMarker348"/> to behave as if going through a metamorphosis and to exhibit completely different behaviors under different conditions.</p>
			<p>We will present this concept in a practical<a id="_idIndexMarker349"/> hands-on way, using an <strong class="bold">object factory</strong> – a specific programming<a id="_idIndexMarker350"/> implementation of a factory, which is a <em class="italic">method that returns objects of a varying prototype or class</em> (<a href="https://en.wikipedia.org/wiki/Factory_(object-oriented_programming">https://en.wikipedia.org/wiki/Factory_(object-oriented_programming</a>).</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>The object factory</h2>
			<p>The idea behind the object factory<a id="_idIndexMarker351"/> is to create a method that returns a new object<a id="_idIndexMarker352"/> of a certain type under certain conditions. For example, look at the <strong class="source-inline">CalcUsingAlg1</strong> and <strong class="source-inline">CalcUsingAlg2</strong> classes:</p>
			<pre class="source-code">interface CalcSomething{ double calculate(); }</pre>
			<pre class="source-code">class CalcUsingAlg1 implements CalcSomething{</pre>
			<pre class="source-code">    public double calculate(){ return 42.1; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class CalcUsingAlg2 implements CalcSomething{</pre>
			<pre class="source-code">    private int prop1;</pre>
			<pre class="source-code">    private double prop2;</pre>
			<pre class="source-code">    public CalcUsingAlg2(int prop1, double prop2) {</pre>
			<pre class="source-code">        this.prop1 = prop1;</pre>
			<pre class="source-code">        this.prop2 = prop2;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public double calculate(){ return prop1 * prop2; }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, they both implement the same interface, <strong class="source-inline">CalcSomething</strong>, but use different algorithms. Now, let’s say that we decided that the selection of the algorithm used will be done in a <strong class="source-inline">property</strong> file. Then, we can create the following object factory:</p>
			<pre class="source-code">class CalcFactory{</pre>
			<pre class="source-code">    public static CalcSomething getCalculator(){</pre>
			<pre class="source-code">        String alg = getAlgValueFromPropertyFile();</pre>
			<pre class="source-code">        switch(alg){</pre>
			<pre class="source-code">            case "1":</pre>
			<pre class="source-code">                return new CalcUsingAlg1();</pre>
			<pre class="source-code">            case "2":</pre>
			<pre class="source-code">                int p1 = getAlg2Prop1FromPropertyFile();</pre>
			<pre class="source-code">                double p2 = getAlg2Prop2FromPropertyFile();</pre>
			<pre class="source-code">                return new CalcUsingAlg2(p1, p2);</pre>
			<pre class="source-code">            default:</pre>
			<pre class="source-code">                System.out.println("Unknown value " + alg);</pre>
			<pre class="source-code">                return new CalcUsingAlg1();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The factory selects which algorithm<a id="_idIndexMarker353"/> to use based on the value returned by the <strong class="source-inline">getAlgValueFromPropertyFile()</strong> method. In the case of the second<a id="_idIndexMarker354"/> algorithm, it also uses the <strong class="source-inline">getAlg2Prop1FromPropertyFile()</strong> methods and <strong class="source-inline">getAlg2Prop2FromPropertyFile()</strong> to get the input parameters for the algorithm. But this complexity is hidden from the client:</p>
			<pre class="source-code">CalcSomething calc = CalcFactory.getCalculator();</pre>
			<pre class="source-code">double result = calc.calculate();</pre>
			<p>We can add new algorithm variations, and change the source for the algorithm parameters or the process of the algorithm selection, but the client will not need to change the code. And that is the power of polymorphism.</p>
			<p>Alternatively, we can use inheritance to implement polymorphic behavior. Consider the following classes:</p>
			<pre class="source-code">class CalcSomething{</pre>
			<pre class="source-code">    public double calculate(){ return 42.1; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class CalcUsingAlg2 extends CalcSomething{</pre>
			<pre class="source-code">    private int prop1;</pre>
			<pre class="source-code">    private double prop2;</pre>
			<pre class="source-code">    public CalcUsingAlg2(int prop1, double prop2) {</pre>
			<pre class="source-code">        this.prop1 = prop1;</pre>
			<pre class="source-code">        this.prop2 = prop2;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public double calculate(){ return prop1 * prop2; }</pre>
			<pre class="source-code">}</pre>
			<p>Then, our factory <a id="_idIndexMarker355"/>may look<a id="_idIndexMarker356"/> as follows:</p>
			<pre class="source-code">class CalcFactory{</pre>
			<pre class="source-code">    public static CalcSomething getCalculator(){</pre>
			<pre class="source-code">        String alg = getAlgValueFromPropertyFile();</pre>
			<pre class="source-code">        switch(alg){</pre>
			<pre class="source-code">            case "1":</pre>
			<pre class="source-code">                return new CalcSomething();</pre>
			<pre class="source-code">            case "2":</pre>
			<pre class="source-code">                int p1 = getAlg2Prop1FromPropertyFile();</pre>
			<pre class="source-code">                double p2 = getAlg2Prop2FromPropertyFile();</pre>
			<pre class="source-code">                return new CalcUsingAlg2(p1, p2);</pre>
			<pre class="source-code">            default:</pre>
			<pre class="source-code">                System.out.println("Unknown value " + alg);</pre>
			<pre class="source-code">                return new CalcSomething();</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>But the client code does not change:</p>
			<pre class="source-code">CalcSomething calc = CalcFactory.getCalculator();</pre>
			<pre class="source-code">double result = calc.calculate();</pre>
			<p>Given a choice, an experienced<a id="_idIndexMarker357"/> programmer uses a common interface for the<a id="_idIndexMarker358"/> implementation. It allows for a more flexible design, as a class in Java can implement multiple interfaces but can extend (inherit from) one class.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>The instanceof operator</h2>
			<p>Unfortunately, life is not always that easy, and once in a while, a programmer has to deal with code that<a id="_idIndexMarker359"/> is assembled from unrelated classes, even coming<a id="_idIndexMarker360"/> from different frameworks. In such a case, using polymorphism may be not an option. However, you can hide the complexity of an algorithm selection and even simulate polymorphic behavior using the <strong class="source-inline">instanceof</strong> operator, which returns <strong class="source-inline">true</strong> when an object is an instance of a certain class.</p>
			<p>Let’s assume we have two unrelated classes:</p>
			<pre class="source-code">class CalcUsingAlg1 {</pre>
			<pre class="source-code">    public double calculate(CalcInput1 input){</pre>
			<pre class="source-code">        return 42. * input.getProp1();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class CalcUsingAlg2{</pre>
			<pre class="source-code">    public double calculate(CalcInput2 input){</pre>
			<pre class="source-code">        return input.getProp2() * input.getProp1();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>Each of the classes expects as an input an object of a certain type:</p>
			<pre class="source-code">class CalcInput1{</pre>
			<pre class="source-code">    private int prop1;</pre>
			<pre class="source-code">    public CalcInput1(int prop1) { this.prop1 = prop1; }</pre>
			<pre class="source-code">    public int getProp1() { return prop1; }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">class CalcInput2{</pre>
			<pre class="source-code">    private int prop1;</pre>
			<pre class="source-code">    private double prop2;</pre>
			<pre class="source-code">    public CalcInput2(int prop1, double prop2) {</pre>
			<pre class="source-code">        this.prop1 = prop1;</pre>
			<pre class="source-code">        this.prop2 = prop2;</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">    public int getProp1() { return prop1; }</pre>
			<pre class="source-code">    public double getProp2() { return prop2; }</pre>
			<pre class="source-code">}</pre>
			<p>And let’s assume that the method<a id="_idIndexMarker361"/> we implement receives <a id="_idIndexMarker362"/>such an object:</p>
			<pre class="source-code">void calculate(Object input) {</pre>
			<pre class="source-code">    double result = Calculator.calculate(input);</pre>
			<pre class="source-code">    //other code follows</pre>
			<pre class="source-code">}</pre>
			<p>We still use polymorphism here because we describe our input as the <strong class="source-inline">Object</strong> type. We can do it because the <strong class="source-inline">Object</strong> class is the base class for all Java classes.</p>
			<p>Now, let’s look at how the <strong class="source-inline">Calculator</strong> class is implemented:</p>
			<pre class="source-code">class Calculator{</pre>
			<pre class="source-code">    public static double calculate(Object input){</pre>
			<pre class="source-code">        if(input instanceof CalcInput1 calcInput1){</pre>
			<pre class="source-code">            return new CalcUsingAlg1().calculate(calcInput1);</pre>
			<pre class="source-code">        } else if (input instanceof CalcInput2 calcInput2){</pre>
			<pre class="source-code">            return new CalcUsingAlg2().calculate(calcInput2);</pre>
			<pre class="source-code">        } else {</pre>
			<pre class="source-code">            throw new RuntimeException("Unknown input type " + </pre>
			<pre class="source-code">                          input.getClass().getCanonicalName());</pre>
			<pre class="source-code">        }</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>As you can see, it uses the <strong class="source-inline">instanceof</strong> operator for selecting the appropriate algorithm. By using the <strong class="source-inline">Object</strong> class as an input type, the <strong class="source-inline">Calculator</strong> class takes advantage of polymorphism<a id="_idIndexMarker363"/> too, but most of its implementation has nothing<a id="_idIndexMarker364"/> to do with it. Yet, from the outside, it looks polymorphic, and it is, but only to a degree.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Summary</h1>
			<p>This chapter introduced you to the concepts of OOP and how they are implemented in Java. It provided an explanation of each concept and demonstrated how to use it in specific code examples. The Java language constructs of <strong class="source-inline">class</strong> and <strong class="source-inline">interface</strong> were discussed in detail. You also learned what overloading, overriding, and hiding are and how to use the <strong class="source-inline">final</strong> keyword to protect methods from being overridden. </p>
			<p>In the <em class="italic">Polymorphism in action</em> section, you learned about the powerful Java feature of polymorphism. This section brought all the presented material together and showed how polymorphism stays at the center of OOP.</p>
			<p>In the next chapter, you will become familiar with the Java language syntax, including packages, importing, access modifiers, reserved and restricted keywords, and some aspects of Java reference types. You will also learn how to use the <strong class="source-inline">this</strong> and <strong class="source-inline">super</strong> keywords, what widening and narrowing conversions of primitive types are, boxing and unboxing, primitive and reference type assignment, and how the <strong class="source-inline">equals()</strong> method of a reference type works.</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/>Quiz</h1>
			<ol>
				<li>Select all the correct OOP concepts from the following list:<ol><li>Encapsulation</li><li>Isolation</li><li>Pollination</li><li>Inheritance</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>A Java object has status.</li><li>A Java object has behavior.</li><li>A Java object has state.</li><li>A Java object has methods.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>A Java object behavior can be inherited.</li><li>A Java object behavior can be overridden.</li><li>A Java object behavior can be overloaded.</li><li>A Java object behavior can be overwhelmed.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Java objects of different classes can have the same behavior.</li><li>Java objects of different classes share a parent object state.</li><li>Java objects of different classes have as a parent an object of the same class.</li><li>Java objects of different classes can share behavior.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>The method signature includes the return type.</li><li>The method signature is different if the return type is different.</li><li>The method signature changes if two parameters of the same type switch positions.</li><li>The method signature changes if two parameters of different types switch positions.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Encapsulation hides the class name.</li><li>Encapsulation hides behavior.</li><li>Encapsulation allows access to data only via methods.</li><li>Encapsulation does not allow direct access to the state.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>The class is declared in the <strong class="source-inline">.java</strong> file.</li><li>The class bytecode is stored in the <strong class="source-inline">.class</strong> file.</li><li>The parent class is stored in the <strong class="source-inline">.base</strong> file.</li><li>The <strong class="source-inline">child</strong> class is stored in the <strong class="source-inline">.sub</strong> file.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>A method defines an object state.</li><li>A method defines object behavior.</li><li>A method without parameters is marked as <strong class="source-inline">void</strong>.</li><li>A method can have many <strong class="source-inline">return</strong> statements.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li><strong class="source-inline">Varargs</strong> is declared as a <strong class="source-inline">var</strong> type.</li><li><strong class="source-inline">Varargs</strong> stands for <em class="italic">various arguments</em>.</li><li><strong class="source-inline">Varargs</strong> is a <strong class="source-inline">String</strong> array.</li><li><strong class="source-inline">Varargs</strong> can act as an array of the specified type.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>A constructor is a method that creates a state.</li><li>The primary responsibility of a constructor is to initialize a state.</li><li>JVM always provides a default constructor.</li><li>The parent class constructor can be called using the <strong class="source-inline">parent</strong> keyword.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>The <strong class="source-inline">new</strong> operator allocates memory to an object.</li><li>The <strong class="source-inline">new</strong> operator assigns default values to the object properties.</li><li>The <strong class="source-inline">new</strong> operator creates a parent object first.</li><li>The <strong class="source-inline">new</strong> operator creates a child object first.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>An <strong class="source-inline">Object</strong> class belongs to the <strong class="source-inline">java.base</strong> package.</li><li>An <strong class="source-inline">Object</strong> class belongs to the <strong class="source-inline">java.lang</strong> package.</li><li>An <strong class="source-inline">Object</strong> class belongs to a package of the Java Class Library.</li><li>An <strong class="source-inline">Object</strong> class is imported automatically.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>An instance method is invoked using an object.</li><li>A static method is invoked using a class.</li><li>An instance method is invoked using a class.</li><li>A static method is invoked using an object.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Methods in an interface are implicitly <strong class="source-inline">public</strong>, <strong class="source-inline">static</strong>, and <strong class="source-inline">final</strong>.</li><li>An interface can have methods that can be invoked without being implemented in a class.</li><li>An interface can have fields that can be used without any class.</li><li>An interface can be instantiated.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>The default method of an interface is always invoked by default.</li><li>The private method of an interface can be invoked only by the default method.</li><li>The interface static method can be invoked without being implemented in a class.</li><li>The default method can enhance a class that implements the interface.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>An <strong class="source-inline">Abstract</strong> class can have a default method.</li><li>An <strong class="source-inline">Abstract</strong> class can be declared without an <strong class="source-inline">abstract</strong> method.</li><li>Any class can be declared abstract.</li><li>An interface is an <strong class="source-inline">abstract</strong> class without a constructor.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Overloading can be done only in an interface.</li><li>Overloading can be done only when one class extends another.</li><li>Overloading can be done in any class.</li><li>The overloaded method must have the same signature.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Overriding can be done only in a <strong class="source-inline">child</strong> class.</li><li>Overriding can be done in an interface.</li><li>The overridden method must have the same name.</li><li>No method of an <strong class="source-inline">Object</strong> class can be overridden.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Any method can be hidden.</li><li>A variable can hide a property.</li><li>A static method can be hidden.</li><li>A public instance property can be hidden.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Any variable can be declared final.</li><li>A public method cannot be declared final.</li><li>A protected method can be declared final.</li><li>A class can be declared protected.</li></ol></li>
				<li>Select all the correct statements from the following list:<ol><li>Polymorphic behavior can be based on inheritance.</li><li>Polymorphic behavior can be based on overloading.</li><li>Polymorphic behavior can be based on overriding.</li><li>Polymorphic behavior can be based on an interface.</li></ol></li>
			</ol>
		</div>
	</body></html>