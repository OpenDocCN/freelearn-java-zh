- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDBC-based Authentication
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how we can extend Spring Security to utilize
    our `CalendarDao` interface and our existing domain model to authenticate users.
    In this chapter, we will see how we can use Spring Security’s built-in JDBC support.
    To keep things simple, this chapter’s sample code is based on our Spring Security
    setup from [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with
    Spring Security*. In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Security’s built-in JDBC-based authentication support
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Spring Security’s group-based authorization to make administering
    users easier
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use Spring Security’s UserDetailsManager interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Spring Security to utilize the existing CalendarUser schema to authenticate
    users
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how we can secure passwords using Spring Security’s new cryptography
    module
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Security’s default JDBC authentication
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application has not yet implemented security, or if your security infrastructure
    is using a database, Spring Security provides out-of-the-box support that can
    simplify the solving of your security needs. Spring Security provides a default
    schema for users, authorities, and groups. If that does not meet your needs, it
    allows for the querying and managing of users to be customized. In the next section,
    we are going to go through the basic steps for setting up JDBC authentication
    with Spring Security.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code in action link is here: [https://packt.link/of0XA](https://packt.link/of0XA).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required dependencies
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has already defined all the necessary dependencies required
    for this chapter. However, if you are using Spring Security’s JDBC support, you
    are likely going to want the following dependencies listed in your `build.gradle`
    file. It is important to highlight that the JDBC driver that you will use will
    depend on which database you are using. Consult your database vendor’s documentation
    for details on which driver is needed for your database.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all the Spring versions need to match, and all Spring Security
    versions need to match (this includes transitive dependency versions). If you
    are having difficulty getting this to work in your own application, you may want
    to define the dependency management section in `build.gradle` to enforce this,
    as shown in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started
    with Spring Security*. As previously mentioned, you will not need to worry about
    this when using the sample code, since we have already set up the necessary dependencies
    for you.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet defines the required dependencies needed for this chapter,
    including Spring Security and JDBC dependencies:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The main change here of the `build.gradle`, is to add the `spring-boot-starter-data-jdbc`
    dependency, to enable the Spring JDBC support.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Using the H2 database
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first portion of this exercise involves setting up an instance of the Java-based
    H2 which is an open-source, in-memory and embedded relational database written
    in Java. It is designed to be fast, lightweight, and easy to use. H2 database
    will be populated with the Spring Security default schema. We’ll configure H2
    to run in memory using Spring’s `EmbeddedDatabase` configuration feature a significantly
    simpler method of configuration than setting up the database by hand. You can
    find additional information on the H2 website at [http://www.h2database.com/](http://www.h2database.com/).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的第一部分涉及设置Java基础的H2实例，这是一个用Java编写的开源、内存和嵌入式关系型数据库。它设计得快速、轻量级且易于使用。H2数据库将填充Spring
    Security默认的模式。我们将使用Spring的`EmbeddedDatabase`配置功能配置H2在内存中运行，这是一种比手动设置数据库显著更简单的配置方法。你可以在H2网站上找到更多信息：[http://www.h2database.com/](http://www.h2database.com/)。
- en: Keep in mind that in our sample application, we’ll primarily use H2 due to its
    ease of setup. Spring Security will work with any database that supports ANSI
    SQL out of the box. We encourage you to tweak the configuration and use the database
    of your preference if you’re following along with the examples. As we didn’t want
    this portion of the book to focus on the complexities of database setup, we chose
    convenience over realism for the purpose of the exercises.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在我们的示例应用程序中，我们主要使用H2，因为它易于设置。Spring Security可以与任何支持ANSI SQL的数据库无缝工作。我们鼓励你在跟随示例时调整配置并使用你偏好的数据库。由于我们不想让这本书的这一部分专注于数据库设置的复杂性，我们选择了便利性而不是现实性来设计练习。
- en: In the following subsections, we will provide sample SQL scripts for our JBCP
    Calendar application. The scripts will be configured using H2 embedded database.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将提供我们的JBCP日历应用程序的示例SQL脚本。这些脚本将使用H2嵌入式数据库进行配置。
- en: Finally, we will enable the spring-security support, we will have to add a custom
    implementation of `UserDetailsManager`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将启用spring-security支持，我们需要添加一个自定义的`UserDetailsManager`实现。
- en: Provided JDBC scripts
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供的JDBC脚本
- en: We’ve supplied all the SQL files that are used for creating the schema and data
    in an H2 database for this chapter in the `src/main/resources/database/h2/` folder.
    Any files prefixed with `calendar` are custom SQL files for the JBCP calendar
    application. Hopefully, this will make running the samples a little easier. If
    you’re following along with your own database instance, you may have to adjust
    the schema definition syntax to fit your particular database. Additional database
    schemas can be found in the Spring Security reference. You can find a link to
    the Spring Security Reference in the book’s [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional* *Reference Material.*
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将用于创建H2数据库中模式和数据的所有SQL文件提供在了`src/main/resources/database/h2/`文件夹中。任何以`calendar`开头的前缀文件都是JBCP日历应用的定制SQL文件。希望这会使运行示例变得稍微容易一些。如果你正在跟随自己的数据库实例，你可能需要调整模式定义语法以适应你的特定数据库。额外的数据库模式可以在Spring
    Security参考文档中找到。你可以在书籍的[*附录*](B21757_20.xhtml#_idTextAnchor642)中找到Spring Security参考的链接，*附加*
    *参考资料*。
- en: Configuring the H2 embedded database
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置H2嵌入式数据库
- en: 'To configure the H2 embedded database, we need to create a `DataSource` and
    run SQL to create the Spring Security table structure. We will need to update
    the SQL that is loaded at startup to include Spring Security’s basic schema definition,
    Spring Security user definitions, and the authority mappings for users. You can
    find the `DataSource` definition and the relevant updates in the following code
    snippet:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置H2嵌入式数据库，我们需要创建一个`DataSource`并运行SQL来创建Spring Security表结构。我们需要更新启动时加载的SQL，包括Spring
    Security的基本模式定义、Spring Security用户定义和用户的权限映射。你可以在以下代码片段中找到`DataSource`定义和相关的更新：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember that the `EmbeddedDatabaseBuilder()` method creates this database only
    in memory, so you won’t see anything on the disk, and you won’t be able to use
    standard tools to query it. However, you can use the H2 console that is embedded
    in the application to interact with the database. See the instructions on the
    **Welcome** page of our application to learn how to use it.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`EmbeddedDatabaseBuilder()`方法仅在内存中创建此数据库，因此你不会在磁盘上看到任何东西，并且你无法使用标准工具来查询它。然而，你可以使用应用程序内嵌入的H2控制台与数据库交互。查看我们应用程序的**欢迎**页面上的说明，了解如何使用它。
- en: Configuring a JDBC UserDetailsManager implementation
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置JDBC UserDetailsManager实现
- en: 'We’ll modify the `SecurityConfig.java` file to declare that we’re using a JDBC
    `User` **DetailsManager** implementation, instead of the Spring Security in-memory
    `User` **DetailsService** implementation that we configured in[*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. This is done with a simple change to the
    `UserDetailsManager` declaration, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将修改 `SecurityConfig.java` 文件，声明我们使用的是 JDBC `User` **DetailsManager** 实现，而不是我们在[*第2章*](B21757_02.xhtml#_idTextAnchor043)中配置的
    Spring Security 内存 `User` **DetailsService** 实现，即 *Spring Security 入门*。这是通过简单更改
    `UserDetailsManager` 声明来实现的，如下所示：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We replace the previous `configure(AuthenticationManagerBuilder)` method, along
    with all of the child elements, with the `userDetailsService()` method, as shown
    in the preceding code snippet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 `userDetailsService()` 方法替换了之前的 `configure(AuthenticationManagerBuilder)`
    方法以及所有子元素，如前述代码片段所示。
- en: In this section, we have been able to configure H2 database with custom `UserDetailsManager`
    implementation, to enable Spring Security support.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经能够使用自定义 `UserDetailsManager` 实现配置 H2 数据库，以启用 Spring Security 支持。
- en: The default user schema of Spring Security
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Security 的默认用户模式
- en: 'Let’s take a look at each of the SQL files used to initialize the database.
    The first script we added contains the default Spring Security schema definition
    for users and their authorities. The following script has been adapted from Spring
    Security’s Reference, which is listed in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material* to have explicitly named constraints, to make
    troubleshooting easier:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下初始化数据库所使用的每个 SQL 文件。我们添加的第一个脚本包含了默认的 Spring Security 用户模式和权限定义。下面的脚本已经从
    Spring Security 的参考中改编，该参考列在[*附录*](B21757_20.xhtml#_idTextAnchor642)中，*附加参考资料*，以具有明确命名的约束，以便更容易进行故障排除：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Defining users
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户
- en: 'The next script is in charge of defining the users in our application. The
    included SQL statement creates the same users that we have used throughout the
    entire book so far. The file also adds an additional user, `disabled1@example.com`,
    who will not be able to log in since we indicate the user as disabled:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个脚本负责定义我们应用程序中的用户。包含的 SQL 语句创建了我们在整本书中一直使用的相同用户。该文件还添加了一个额外的用户 `disabled1@example.com`，由于我们指示该用户已被禁用，因此该用户将无法登录：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Defining user authorities
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义用户权限
- en: 'You may have noticed that there is no indication if a user is an administrator
    or a regular user. The next file specifies a direct mapping of the user to the
    corresponding authorities. If a user did not have an authority mapped to it, Spring
    Security would not allow that user to be logged in:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，没有指示说明一个用户是管理员还是普通用户。下一个文件指定了用户到相应权限的直接映射。如果一个用户没有映射到任何权限，Spring Security
    将不允许该用户登录：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After the SQL is added to the embedded database configuration, we should be
    able to start the application and log in. Try logging in with the new user using
    `disabled1@example.com` as the `username` and `disabled1` as the `password`. Notice
    that Spring Security does not allow the user to log in and provides the error
    message `Reason: User` `is disabled`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 SQL 添加到嵌入式数据库配置之后，我们应该能够启动应用程序并登录。尝试使用 `disabled1@example.com` 作为 `username`
    和 `disabled1` 作为 `password` 登录新用户。注意，Spring Security 不允许用户登录，并提供了错误信息 `原因：用户被禁用`。
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.01-calendar`.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码现在应该看起来像这样：`calendar04.01-calendar`。
- en: In this section, we have used the default Spring Security user schema and authorities.
    In the next section, we will explore how we can define **Group Based Access**
    **Control** (**GBAC**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们使用了默认的 Spring Security 用户模式和权限。在下一节中，我们将探讨如何定义 **基于组的访问控制**（**GBAC**）。
- en: Exploring UserDetailsManager interface
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 UserDetailsManager 接口
- en: We have already leveraged the `InMemoryUserDetailsManager` class in Spring Security
    in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*, to
    look up the current `CalendarUser` application in our `SpringSecurityUserContext`
    implementation of `UserContext`. This allowed us to determine which `CalendarUser`
    should be used when looking up the events for the `DefaultCalendarService.java`
    file to utilize `InMemoryUserDetailsManager`, to ensure that we created a new
    Spring Security user when we created `CalendarUser`. This chapter reuses exactly
    the same code. The only difference is that the `UserDetailsManager` implementation
    is backed by the `JdbcUserDetailsManager` class of Spring Security, which uses
    a database instead of an in-memory datastore.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: What other features does `UserDetailsManager` provide out of the box?
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these types of functions are relatively easy to write with additional
    JDBC statements, Spring Security actually provides out-of-the-box functionality
    to support many common **Create, Read, Update, and Delete** (**CRUD**) operations
    on users in JDBC databases. This can be convenient for simple systems, and a good
    base to build on for any custom requirements that a user may have:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
- en: '| `void` `createUser(UserDetails user)` | It creates a new user with the given
    `UserDetails` information, including any declared `GrantedAuthority` authorities.
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
- en: '| `void updateUser(final` `UserDetails user)` | It updates a user with the
    given `UserDetails` information. It updates `GrantedAuthority` and removes the
    user from the user cache. |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
- en: '| `void` `deleteUser(String username)` | It deletes the user with the given
    username and removes the user from the user cache. |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `userExists(String username)` | It indicates whether or not a user
    (active or inactive) exists with the given username. |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
- en: '| `void changePassword(String oldPassword,` `String` `newPassword)` | It changes
    the password of the currently logged-in user. The user must then supply the correct
    password in order for the operation to succeed. |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Custom database requirements settings
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: If `UserDetailsManager` does not provide all the methods that are necessary
    for your application, you can extend the interface to provide these custom requirements.
    For example, if you needed the ability to list all of the possible users in an
    administrative view, you could write your own interface with this method and provide
    an implementation that points to the same datastore as the `UserDetailsManager`
    implementation you are currently using.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Group-based access control
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `JdbcUserDetailsManager` class supports the ability to add a level of indirection
    between the users and the `GrantedAuthority` declarations by grouping `GrantedAuthority`
    into logical sets called groups.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Users are then assigned one or more groups, and their membership confers a
    set of the `Granted``Authority` declarations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Group-based access control sample](img/B21757_04_1.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Group-based access control sample
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, this indirection allows the assignment
    of the same set of roles to multiple users, by simply assigning any new users
    to existing groups. This is different behavior that we’ve seen so far, where previously
    we assigned `GrantedAuthority` directly to individual users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'This bundling of common sets of authorities can be helpful in the following
    scenarios:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: You need to segregate users into communities, with some overlapping roles between
    groups.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to globally change the authorization for a class of user. For example,
    if you have a supplier group, you might want to enable or disable their access
    to particular portions of the application.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a large number of users, and you don’t need user-level authority configuration.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless your application has a very small user base, there is a very high likelihood
    that you’ll be using group-based access control. While group-based access control
    is slightly more complex than other strategies, the flexibility and simplicity
    of managing a user’s access makes this complexity worthwhile. This indirect technique
    of aggregating user privileges by group is commonly referred to as GBAC.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: GBAC is an approach common to almost every secured operating system or software
    package on the market. **Microsoft Active Directory** (**AD**) is one of the most
    visible implementations of large-scale GBAC, due to its design of slotting AD
    users into groups and assigning privileges to those groups. Management of privileges
    in large AD-based organizations is made exponentially simpler through the use
    of GBAC.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Try to think of the security models of the software you use—how are the users,
    groups, and privileges managed? What are the pros and cons of the way the security
    model is written?
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a level of abstraction to the JBCP calendar application and apply
    the concept of group-based authorization to the site.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Configuring group-based access control
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll add two groups to the application: regular users, which we’ll call `Users`,
    and administrative users, which we’ll call `Administrators`. Our existing accounts
    will be associated with the appropriate groups through an additional SQL script.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JdbcUserDetailsManager to use groups
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Spring Security does not use GBAC. Therefore, we must instruct
    Spring Security to enable the use of groups. Modify the `SecurityConfig.java`
    file to use `GROUP_AUTHORITIES_BY_USERNAME_QUERY`, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Utilizing GBAC JDBC scripts
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to update the scripts that are being loaded at startup. We need
    to remove the `security-user-authorities.sql` mapping so that our users no longer
    obtain their authorities with direct mapping. We then need to add two additional
    SQL `scripts`. Update the `DataSource` bean configuration to load the SQL required
    for GBAC, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The group-based schema
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may be obvious, but the first SQL file we added contains updates to the
    schema to support group-based authorization. You can find the contents of the
    file in the following code snippet:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能很明显，但我们添加的第一个SQL文件包含了对模式的支持以支持基于组的授权的更新。您可以在以下代码片段中找到文件的内容：
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Group authority mappings
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组权限映射
- en: 'Now we need to map our existing users to groups, and the groups to authorities.
    This is done in the `security-groups-mappings.sql` file. Mapping based on groups
    can be convenient because often, organizations already have a logical group of
    users for various reasons. By utilizing the existing groupings of users, we can
    drastically simplify our configuration. This is how a layer of indirection helps
    us. We have included the group definitions, group to authority mappings, and a
    few users in the following group mapping:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将现有用户映射到组，将组映射到权限。这是在`security-groups-mappings.sql`文件中完成的。基于组的映射可以很方便，因为组织通常已经根据各种原因有一个逻辑用户组。通过利用现有的用户分组，我们可以极大地简化我们的配置。这就是间接层如何帮助我们。我们在以下组映射中包含了组定义、组到权限映射和一些用户：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Go ahead and start the application, and it will behave just as before; however,
    the additional layer of abstraction between the users and roles simplifies the
    managing of large groups of users.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 开始启动应用程序，它将表现得和以前一样；然而，用户和角色之间的额外抽象层简化了管理大量用户。
- en: Important note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Your code should now look like this: `calendar04.02-calendar`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码现在应该看起来像这样：`calendar04.02-calendar`。
- en: After exploring in this section how we can define GBAC, we will define in the
    following section a custom database queries to retrieve users and authorities.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何定义GBAC之后，将在下一节中定义一个自定义数据库查询来检索用户和权限。
- en: Support for a custom schema
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 支持自定义模式
- en: It’s common for new users of Spring Security to begin their experience by adapting
    the JDBC user, group, or role mapping to an existing schema. Even though a legacy
    database doesn’t conform to the expected Spring Security schema, we can still
    configure `JdbcDaoImpl` to map to it.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Spring Security的新用户来说，通常是通过将JDBC用户、组或角色映射到现有模式来开始他们的体验。即使遗留数据库不符合预期的Spring
    Security模式，我们仍然可以配置`JdbcDaoImpl`来映射到它。
- en: We will now update Spring Security’s JDBC support to use our existing `CalendarUser`
    database along with a new `calendar_authorities` table.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将更新Spring Security的JDBC支持，以使用我们现有的`CalendarUser`数据库以及一个新的`calendar_authorities`表。
- en: We can easily change the configuration of `JdbcUserDetailsManager` to utilize
    this schema and override Spring Security’s expected table definitions and columns,
    which we’re using for the JBCP calendar application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地更改`JdbcUserDetailsManager`的配置，以利用此模式并覆盖我们用于JBCP日历应用程序的Spring Security预期的表定义和列。
- en: In the following subsections, we will update the SQL user and authorities scripts
    to insert custom roles. At the end, we will configure `JdbcUserDetailsManager`
    to use this custom SQL queries.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下子节中，我们将更新SQL用户和权限脚本以插入自定义角色。最后，我们将配置`JdbcUserDetailsManager`以使用这些自定义SQL查询。
- en: Determining the correct JDBC SQL queries
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确定正确的JDBC SQL查询
- en: 'The `JdbcUserDetailsManager` class has three SQL queries that have a well-defined
    parameter and a set of returned columns. We must determine the SQL that we’ll
    assign to each of these queries, based on the intended functionality. Each SQL
    query used by `JdbcUserDetailsManager` takes the username presented at login as
    its one and only parameter:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`JdbcUserDetailsManager`类有三个具有明确定义参数和一组返回列的SQL查询。我们必须根据预期的功能确定我们将分配给这些查询的SQL。`JdbcUserDetailsManager`使用的每个SQL查询都以其在登录时提供的用户名作为其唯一参数：'
- en: '| **Namespace query** **attribute name** | **Description** | **Expected** **SQL
    columns** |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| **命名空间查询** **属性名** | **描述** | **预期** **SQL列** |'
- en: '| `users-by-username-query` | Returns one ormore usersmatching theusername;
    only thefirst user is used. | `Username (string)``Password (string)``Enabled (Boolean)`
    |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `users-by-username-query` | 返回一个或多个匹配用户名的用户；仅使用第一个用户。 | `Username (字符串)`
    `Password (字符串)` `Enabled (布尔值)` |'
- en: '| `authorities-by-username-query` | Returns one or more granted authorities
    directly provided to the user. Typically used when GBAC is disabled. | `Username
    (string)` `GrantedAuthority (string)` |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `authorities-by-username-query` | 返回直接提供给用户的授权权限。通常在GBAC禁用时使用。 | `Username
    (字符串)` `GrantedAuthority (字符串)` |'
- en: '| `group-authorities-by-username-query` | Returns grantedauthorities andgroup
    detailsprovided to theuser through groupmembership. Usedwhen GBAC is enabled.
    | `Group` `Primary Key``(``any)``Group` `Name (any)``GrantedAuthority (string)`
    |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – JDBC queries in spring-security
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that in some cases, the return columns are not used by the default
    `JdbcUserDetailsManager` implementation, but they must be returned anyway.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Updating the SQL scripts that are loaded
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to initialize the `DataSource` with our custom schema, rather than
    with Spring Security’s default schema. Update the `DataSourceConfig.java` file,
    as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice that we have removed all of the scripts that start with security and
    replaced them with `calendar-authorities.sql`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: The CalendarUser authority SQL
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can view the `CalendarUser` authority mappings in the following code snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Important note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we use the id as the foreign key, which is better than utilizing
    the username as a foreign key (as Spring Security does). By using the id as the
    foreign key, we can allow users to easily change their username.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Inserting custom authorities
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to update `DefaultCalendarService` to insert the authorities for the
    user using our custom schema when we add a new `CalendarUser` class. This is because
    while we reused the schema for the user definition, we did not define custom authorities
    in our existing application. Update `DefaultCalendarService`, as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Important note
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the `JdbcOperations` interface that is used for inserting
    our user. This is a convenient template provided by Spring that helps manage boilerplate
    code, such as connection and transaction handling. For more details, refer to
    the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference Material*
    of this book to find the Spring Reference.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JdbcUserDetailsManager to use custom SQL queries
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use custom SQL queries for our non-standard schema, we’ll simply
    update our `userDetailsService()` method to include new queries. This is quite
    similar to how we enabled support for GBAC, except instead of using the default
    SQL, we will use our modified SQL. Notice that we remove our old `setGroupAuthoritiesByUsernameQuery()`
    method call, since we will not be using it in this example, in order to keep things
    simple:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the only configuration required to use Spring Security to read settings
    from an existing, non-default schema! Start up the application and ensure that
    everything is working properly.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.03-calendar`.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the utilization of an existing schema commonly requires an
    extension of `JdbcUserDetailsManager` to support the changing of passwords, the
    renaming of user accounts, and other user-management functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `JdbcUserDetailsManager` to perform user-management tasks,
    then there are over 20 SQL queries utilized by the class that are accessible through
    the configuration. However, only the three covered are available through the namespace
    configuration. Please refer to the Javadoc or source code to review the defaults
    for the queries used by `JdbcUserDetailsManager`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用`JdbcUserDetailsManager`执行用户管理任务，那么该类使用了超过20个SQL查询，这些查询可以通过配置访问。然而，只有三个在命名空间配置中可用。请参阅Javadoc或源代码以查看`JdbcUserDetailsManager`使用的查询的默认值。
- en: Configuring secure passwords
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置安全密码
- en: You might recall from the security audit in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015),
    *Anatomy of an Unsafe Application*, that the security of passwords stored in cleartext
    was a top priority of the auditors. In fact, in any secured system, password security
    is a critical aspect of trust and authoritativeness of an authenticated principal.
    Designers of a fully secured system must ensure that passwords are stored in a
    way in which malicious users would have an impractically difficult time compromising
    them.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能还记得从[*第一章*](B21757_01.xhtml#_idTextAnchor015)《不安全应用程序解剖》中的安全审计，密码以明文形式存储的安全性是审计员的首要任务。事实上，在任何安全系统中，密码安全都是认证主体的信任和权威性的关键方面。完全安全系统的设计者必须确保密码以恶意用户难以攻破的方式存储。
- en: 'The following general rules should be applied to passwords stored in a database:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 应将该以下一般规则应用于数据库中存储的密码：
- en: Passwords must not be stored in cleartext (plaintext)
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密码不得以明文（plaintext）形式存储
- en: Passwords supplied by the user must be compared to the recorded passwords in
    the database
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户提供的密码必须与数据库中记录的密码进行比较
- en: A user’s password should not be supplied to the user upon demand (even if the
    user forgets it)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户密码不应在用户要求时提供（即使用户忘记了）
- en: For the purposes of most applications, the best fit for these requirements involves
    one-way encoding, known as the **hashing** of the passwords. Using a cryptographic
    hash provides properties such as security and uniqueness that are important to
    properly authenticate users, with the added bonus that once it is hashed, the
    password cannot be extracted from the value that is stored.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数应用程序而言，满足这些要求的最合适的方法涉及单向编码，即密码的**哈希**。使用加密哈希提供了诸如安全性和唯一性等属性，这对于正确验证用户非常重要，而且还有一个额外的优点，即一旦哈希，密码就不能从存储的值中提取出来。
- en: In most secure application designs, it is neither required nor desirable to
    ever retrieve the user’s actual password upon request, as providing the user’s
    password to them without the proper additional credentials could present a major
    security risk. Instead, most applications provide the user the ability to reset
    their password, either by presenting additional credentials (such as their social
    security number, date of birth, tax ID, or other personal information), or through
    an email-based system.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数安全的应用程序设计中，在请求时检索用户的实际密码既不是必需的，也不是所希望的，因为在不适当的额外凭证的情况下向用户提供密码可能会带来重大的安全风险。相反，大多数应用程序提供用户重置密码的能力，无论是通过提供额外的凭证（如他们的社会保险号码、出生日期、税务ID或其他个人信息），还是通过基于电子邮件的系统。
- en: Storing other types of sensitive information
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 存储其他类型的敏感信息
- en: Many of the guidelines listed that apply to passwords apply equally to other
    types of sensitive information, including social security numbers and credit card
    information (although, depending on the application, some of these may require
    the ability to decrypt). Storing this type of information to represent it in multiple
    ways, for example, a customer’s full 16-digit credit card number, would be stored
    in a highly encrypted form, but the last four digits might be stored in cleartext.
    For reference, think of any internet commerce site that displays `XXXX XXXX XXXX
    1234` to help you identify your stored credit cards.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列出的许多适用于密码的指南同样适用于其他类型的敏感信息，包括社会保险号码和信用卡信息（尽管，根据应用程序的不同，其中一些可能需要解密的能力）。存储此类信息以以多种方式表示，例如，客户的完整16位信用卡号可能会以高度加密的形式存储，但最后四位可能以明文形式存储。为了参考，想想任何显示`XXXX
    XXXX XXXX 1234`以帮助您识别存储的信用卡的互联网商业网站。
- en: You may already be thinking ahead and wondering, given our admittedly unrealistic
    approach of using SQL to populate our H2 database with users, how do we encode
    the passwords? H2, or most other databases for that matter, don’t offer encryption
    methods as built-in database functions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the bootstrap process (populating a system with initial users and
    data) is handled through a combination of SQL loads and Java code. Depending on
    the complexity of your application, this process can get very complicated.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: For the JBCP calendar application, we’ll retain the `dataSource()` bean declaration
    and `DataSource` is a name in code in the corresponding SQL, and then add some
    SQL that will modify the passwords to their hashed values.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: We have seen in this section the best practices for configuring secure password.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will deep dive into the different options to configure
    secured passwords using the `PasswordEncoder` interface.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the PasswordEncoder interface
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Password hashing in Spring Security is encapsulated and defined by implementations
    of the `o.s.s.authentication.encoding.PasswordEncoder` interface. The simple configuration
    of a password encoder is possible through the `createDelegatingPasswordEncoder()`
    method within the `PasswordEncoderFactories` element, as follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You’ll be happy to learn that Spring Security ships with a number of implementations
    of `passwordEncoder`, which are applicable for different needs and security requirements.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: The following table provides a list of the out-of-the-box implementation classes
    and their benefits.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: We can find the complete list of supported encoders in spring security in the
    `Password` **EncoderFactories** class. If one of these matches our requirement,
    we don’t need to rewrite it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all implementations reside in the `o.s.s.crypto` package:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '| **Encoder** | **Algorithm** | **Usage** |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
- en: '| `Pbkdf2PasswordEncoder` | PBKDF2 | Provides key strengthening with configurable
    iteration count, suitable for password hashing.Suitable for password storage.
    |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
- en: '| `SCryptPasswordEncoder` | Scrypt | Memory-hard key derivation function, making
    it resistant to brute-force attacks.Suitable for password storage. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
- en: '| `StandardPasswordEncoder` | SHA-256 | Uses a standard SHA-256 algorithm.
    Note that SHA-256 alone is not recommended for password hashing due to its speed.Suitable
    for legacy systems but not recommended for new applications. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
- en: '| `NoOpPasswordEncoder` | No operation | No hashing or encoding; passwords
    are stored as plain text.Not recommended for production. Useful for testing and
    development. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
- en: '| `LdapShaPasswordEncoder` | SHA-1 | Performs SHA-1 hashing with optional salt.
    Suitable for compatibility with LDAP directories.Suitable for integration with
    LDAP-based systems. |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
- en: '| `BCryptPasswordEncoder` | BCrypt | One-way hash function with adaptive hashing,
    suitable for password hashing.Recommended for password storage. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
- en: '| `MessageDigest PasswordEncoder` | Configurable(e.g., MD5,SHA-256,SHA-512)
    | Uses various message digest algorithms, but the choice of algorithm is crucial
    for security.Depends on the selected algorithm. Not recommended for new applications
    due to weaknesses in some algorithms. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – Main PasswordEncoder implementation
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: As with many other areas of Spring Security, it’s also possible to reference
    a bean definition by implementing `PasswordEncoder` to provide more precise configuration
    and
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: allowing `PasswordEncoder` to be wired into other beans through the dependency
    injection. For the JBCP calendar application, we’ll need to use this bean reference
    method in order to hash the passwords of the newly created users.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: The DelegatingPasswordEncoder implementation
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to Spring Security 5.0, the default `PasswordEncoder` was `NoOpPasswordEncoder`,
    which required plain-text passwords. Based on the Password History section, you
    might expect that the default `PasswordEncoder` would now be something like `BCryptPasswordEncoder`.
    However, this ignores three real world problems:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Many applications use old password encodings that cannot easily migrate.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best practice for password storage will change again.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a framework, Spring Security cannot make breaking changes frequently.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead, Spring Security introduces `DelegatingPasswordEncoder`, which solves
    all of the problems by:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that passwords are encoded by using the current password storage recommendations.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing for validating passwords in modern and legacy formats.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing for upgrading the encoding in the future.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can easily construct an instance of `DelegatingPasswordEncoder` by using
    `Password``EncoderFactories`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Let’s walk through the process of configuring basic password encoding for the
    JBCP calendar application.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Configuring password encoding
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring basic password encoding involves two steps: hashing the passwords
    we load into the database after the SQL script executes and ensuring that Spring
    Security is configured to work with `PasswordEncoder`.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the PasswordEncoder method
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll declare an instance of `PasswordEncoder` as a normal Spring bean,
    as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Making Spring Security aware of the PasswordEncoder method
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll need to configure Spring Security to have a reference to a Bean of type
    `PasswordEncoder`, so that it can encode and compare the presented password during
    user login.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: If you were to try the application at this point, you’d notice that what were
    previously valid login credentials would now be rejected. This is because the
    passwords stored in the database (loaded with the `calendar-users.sql` script)
    are not stored as a `hash` that matches the password encoder. We’ll need to update
    the stored passwords to be hashed values.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Hashing the stored passwords
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As illustrated in the following diagram, when a user submits a password, Spring
    Security hashes the submitted password and then compares that against the unhashed
    password in the database:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Hashing the stored passwords workflow](img/B21757_04_2.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Hashing the stored passwords workflow
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that users cannot log in to our application. To fix this, we will
    update the SQL that is loaded at startup time to update the passwords to be the
    hashed values. Update the `DataSourceConfig.java` file, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `calendar-sha256.sql` file simply updates the existing passwords to their
    expected hashed values, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'How did we know what value to update the password to? We have provided `o.s.s.authentication.encoding.Sha256PasswordEncoderMain`
    to demonstrate how to use the configured `PasswordEncoder` interface to hash the
    existing passwords. The relevant code is as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Hashing the passwords of new users
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we tried running the application and creating a new user, we would not be
    able to log in. This is because the newly-created user’s password would not be
    hashed. We need to update `DefaultCalendarService` to hash the password. Make
    the following updates to ensure that the newly-created users passwords are hashed:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Not quite secure
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go ahead and start the application. Try creating a new user with `user1` as
    the password. Log out of the application, then use the instructions on the `user1@example.com`
    are the same value? The fact that we have now figured out another user’s password
    is a little disturbing. We will solve this with a technique known as **salting**.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.04-calendar`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: 'Would you like some salt with that password? If the security auditor were to
    examine the encoded passwords in the database, he’d find something that would
    still make him concerned about the website’s security. Let’s examine the following
    stored username and password values for a few of our users:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Plaintext password** | **Hashed password** |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
- en: '| `admin1@example.com` | `admin1` | `{``SHA-256}25f43b1486ad95a1 398e3eeb3d83bc4010015fcc9``bedb35b432e00298d5021f7`
    |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
- en: '| `user1@example.com` | `user1` | `{``SHA-256}0a041b9462caa4a3 1bac3567e0b6e6fd9100787db``2ab433d96f6d178cabfce90`
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
- en: Table 4.4 – Hashed users passwords
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: This looks very secure—the encrypted passwords obviously bear no resemblance
    to the original passwords. What could the auditor be concerned about? What if
    we add a new user who happens to have the same password as our `user1@example.com`
    user?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Plaintext** **password** | **Hashed password** |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
- en: '| `hacker@example.com` | `user1` | `{``SHA-256}0a041b9462caa4 a31bac3567e0b6e6fd91007``87db2ab433d96f6d178cabfce90`
    |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
- en: Table 4.5 – Hacked hashed user password
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Now, note that the encrypted password of the `hacker@example.com` user is exactly
    the same as the real user! Thus, a hacker who had somehow gained the ability to
    read the encrypted passwords in the database could compare their known password’s
    encrypted representation with the unknown one for the user account, and see they
    are the same! If the hacker had access to an automated tool to perform this analysis,
    they could likely compromise the user’s account within a matter of hours.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: While it is difficult to guess a single password, hackers can calculate all
    the hashes ahead of time and store a mapping of the hash to the original password.
    Then, figuring out the original password is a matter of looking up the password
    by its hashed value in constant time. This is a hacking technique known as **rainbow
    tables**.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: One common and effective method of adding another layer of security to encrypted
    passwords is to incorporate a **salt**. A salt is a second plaintext component,
    which is concatenated with the plaintext password prior to performing the hash,
    in order to ensure that two factors must be used to generate (and thus compare)
    the hashed password values. Properly selected salts can guarantee that no two
    passwords will ever have the same hashed value, thus preventing the scenario that
    concerned our auditor, and avoiding many common types of brute force password
    cracking techniques.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice salts generally fall into one of the following three categories:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: They are algorithmically generated from some pieces of data associated with
    the user, for example, the timestamp that the user created
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are randomly generated and stored in some form
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are plaintext or two-way encrypted along with the user’s password record
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that because the `salt` value for a given user’s record in order to
    calculate the `hash` of the password, and to compare it with the stored `hash`
    of the user when performing authentication.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Using salt in Spring Security
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`spring-security-core` module and are available separately in `spring-security-crypto`.
    The `o.s.s.crypto.password.PasswordEncoder` interface. In fact, using this interface
    is the preferred method for encoding passwords, because it will salt passwords
    using a random `salt`. At the time of this writing, there are the following three
    implementations of `o.s.s.crypto.password.PasswordEncoder`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Description** |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.crypto.bcrypt.BCryptPasswordEncoder` | This class uses the `bcrypt`
    hashing function. It supports `salt` and the ability to slow down to perform over
    time as technology improves. This helps protect against brute- force search attacks.
    |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.crypto.password.NoOpPasswordEncoder` | This class does no encoding
    (it returns the password in its plaintext form). Provided for legacy and testing
    purposes only and is not considered secure. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.crypto.password.StandardPasswordEncoder` | This class uses `SHA-256`
    with multiple iterations and a random `salt` value. Provided for legacy and testing
    purposes only and is not considered secure. |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
- en: Table 4.6 – Common PasswordEncoder implementations
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: For those who are familiar with `Spring Security`, The Spring Security Crypto
    module provides support for symmetric encryption, key generation, and password
    encoding. The classes above are part of the core module and has no dependencies
    on any other Spring Security (or Spring) code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Spring Security configuration
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This can be done by updating the Spring Security configuration. Remove the
    old `ShaPasswordEncoder` encoder and add the new `StandardPasswordEncoder` encoder,
    as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Migrating existing passwords
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps and learn about migrating existing
    passwords:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to update our existing passwords to use the values produced by the
    new `PasswordEncoder` class. If you would like to generate your own passwords,
    you can use the following code snippet:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Remove the previously used `calendar-sha256.sql` file, and add the provided
    `saltedsha256.sql` file as follows:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Updating DefaultCalendarUserService
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `passwordEncoder()` method we defined previously is smart enough to handle
    the new password encoder interface. However, `DefaultCalendarUserService` needs
    to update to the new interface. Make the following updates to the `DefaultCalendarUserService`
    class:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With the preceding code implementation, we have been able to configure Salt
    SHA256 in Spring Security. The `DefaultCalendarService` uses this Salt `PasswordEncoder`
    to insert user’s password.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore another option to use `Salt` with `Bcrypt`
    algorithm.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Trying out salted passwords
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start up the application and try creating another user with the password `user1`.
    Use the H2 console to compare the new user’s password and observe that they are
    different.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.05-calendar`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security now generates a random `salt` and combines this with the password
    before hashing our password. It then adds the random `salt` to the beginning of
    the password in plaintext, so that passwords can be checked. The stored password
    can be summarized as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the pseudocode for hashing a newly created password.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'To authenticate a user, `salt` and `hash` can be extracted from the stored
    password, since both `salt` and `hash` are fixed lengths. Then, the extracted
    `hash` can be compared against a new `hash`, computed with extracted `salt` and
    the inputted password:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Salting the stored passwords workflow](img/B21757_04_3.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Salting the stored passwords workflow
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the pseudocode for validating a salted password:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`BCryptPasswordEncoder` is another salt implementation uses the widely supported
    `bcrypt` algorithm to hash the passwords. `Bcrypt` uses a random `16-byte salt`
    value and is a deliberately slow algorithm, to hinder password crackers. You can
    tune the amount of work it does by using the strength parameter, which takes a
    value from *4* to *31*. The higher the value, the more work has to be done to
    calculate the hash. The default value is `10`. You can change this value in your
    deployed system without affecting existing passwords, as the value is also stored
    in the encoded hash. The following example uses the `BCryptPasswordEncoder` with
    strength parameter value equal to `4`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In addition, we had to use add the provided `calendar-bcrypt.sql` file as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Start up the application and try logging to the application with username `user1@example.com`
    and password `user1`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.06-calendar`.'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Spring Security’s built-in *JDBC support*.
    Specifically, we have learned that Spring Security provides a default schema for
    new applications. We also explored how to implement *GBAC* and how it can make
    managing users easier.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to integrate Spring Security’s JDBC support with an existing
    database and also how to secure our passwords by hashing them and using a randomly
    generated *salt*.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the *Spring Data* project and how to configure
    Spring Security to use **object-relational mapping** (**ORM**) to connect to an
    RDBMS, as well as a document database.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
