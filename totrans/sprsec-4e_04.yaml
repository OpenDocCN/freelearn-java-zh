- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JDBC-based Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how we can extend Spring Security to utilize
    our `CalendarDao` interface and our existing domain model to authenticate users.
    In this chapter, we will see how we can use Spring Security’s built-in JDBC support.
    To keep things simple, this chapter’s sample code is based on our Spring Security
    setup from [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started with
    Spring Security*. In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Spring Security’s built-in JDBC-based authentication support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Spring Security’s group-based authorization to make administering
    users easier
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to use Spring Security’s UserDetailsManager interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Spring Security to utilize the existing CalendarUser schema to authenticate
    users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how we can secure passwords using Spring Security’s new cryptography
    module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Spring Security’s default JDBC authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application has not yet implemented security, or if your security infrastructure
    is using a database, Spring Security provides out-of-the-box support that can
    simplify the solving of your security needs. Spring Security provides a default
    schema for users, authorities, and groups. If that does not meet your needs, it
    allows for the querying and managing of users to be customized. In the next section,
    we are going to go through the basic steps for setting up JDBC authentication
    with Spring Security.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter''s code in action link is here: [https://packt.link/of0XA](https://packt.link/of0XA).'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the required dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application has already defined all the necessary dependencies required
    for this chapter. However, if you are using Spring Security’s JDBC support, you
    are likely going to want the following dependencies listed in your `build.gradle`
    file. It is important to highlight that the JDBC driver that you will use will
    depend on which database you are using. Consult your database vendor’s documentation
    for details on which driver is needed for your database.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all the Spring versions need to match, and all Spring Security
    versions need to match (this includes transitive dependency versions). If you
    are having difficulty getting this to work in your own application, you may want
    to define the dependency management section in `build.gradle` to enforce this,
    as shown in [*Chapter 2*](B21757_02.xhtml#_idTextAnchor043), *Getting Started
    with Spring Security*. As previously mentioned, you will not need to worry about
    this when using the sample code, since we have already set up the necessary dependencies
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet defines the required dependencies needed for this chapter,
    including Spring Security and JDBC dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The main change here of the `build.gradle`, is to add the `spring-boot-starter-data-jdbc`
    dependency, to enable the Spring JDBC support.
  prefs: []
  type: TYPE_NORMAL
- en: Using the H2 database
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first portion of this exercise involves setting up an instance of the Java-based
    H2 which is an open-source, in-memory and embedded relational database written
    in Java. It is designed to be fast, lightweight, and easy to use. H2 database
    will be populated with the Spring Security default schema. We’ll configure H2
    to run in memory using Spring’s `EmbeddedDatabase` configuration feature a significantly
    simpler method of configuration than setting up the database by hand. You can
    find additional information on the H2 website at [http://www.h2database.com/](http://www.h2database.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that in our sample application, we’ll primarily use H2 due to its
    ease of setup. Spring Security will work with any database that supports ANSI
    SQL out of the box. We encourage you to tweak the configuration and use the database
    of your preference if you’re following along with the examples. As we didn’t want
    this portion of the book to focus on the complexities of database setup, we chose
    convenience over realism for the purpose of the exercises.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will provide sample SQL scripts for our JBCP
    Calendar application. The scripts will be configured using H2 embedded database.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we will enable the spring-security support, we will have to add a custom
    implementation of `UserDetailsManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Provided JDBC scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve supplied all the SQL files that are used for creating the schema and data
    in an H2 database for this chapter in the `src/main/resources/database/h2/` folder.
    Any files prefixed with `calendar` are custom SQL files for the JBCP calendar
    application. Hopefully, this will make running the samples a little easier. If
    you’re following along with your own database instance, you may have to adjust
    the schema definition syntax to fit your particular database. Additional database
    schemas can be found in the Spring Security reference. You can find a link to
    the Spring Security Reference in the book’s [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional* *Reference Material.*
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the H2 embedded database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To configure the H2 embedded database, we need to create a `DataSource` and
    run SQL to create the Spring Security table structure. We will need to update
    the SQL that is loaded at startup to include Spring Security’s basic schema definition,
    Spring Security user definitions, and the authority mappings for users. You can
    find the `DataSource` definition and the relevant updates in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the `EmbeddedDatabaseBuilder()` method creates this database only
    in memory, so you won’t see anything on the disk, and you won’t be able to use
    standard tools to query it. However, you can use the H2 console that is embedded
    in the application to interact with the database. See the instructions on the
    **Welcome** page of our application to learn how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a JDBC UserDetailsManager implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll modify the `SecurityConfig.java` file to declare that we’re using a JDBC
    `User` **DetailsManager** implementation, instead of the Spring Security in-memory
    `User` **DetailsService** implementation that we configured in[*Chapter 2*](B21757_02.xhtml#_idTextAnchor043),
    *Getting Started with Spring Security*. This is done with a simple change to the
    `UserDetailsManager` declaration, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We replace the previous `configure(AuthenticationManagerBuilder)` method, along
    with all of the child elements, with the `userDetailsService()` method, as shown
    in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have been able to configure H2 database with custom `UserDetailsManager`
    implementation, to enable Spring Security support.
  prefs: []
  type: TYPE_NORMAL
- en: The default user schema of Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s take a look at each of the SQL files used to initialize the database.
    The first script we added contains the default Spring Security schema definition
    for users and their authorities. The following script has been adapted from Spring
    Security’s Reference, which is listed in the [*Appendix*](B21757_20.xhtml#_idTextAnchor642),
    *Additional Reference Material* to have explicitly named constraints, to make
    troubleshooting easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Defining users
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next script is in charge of defining the users in our application. The
    included SQL statement creates the same users that we have used throughout the
    entire book so far. The file also adds an additional user, `disabled1@example.com`,
    who will not be able to log in since we indicate the user as disabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Defining user authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that there is no indication if a user is an administrator
    or a regular user. The next file specifies a direct mapping of the user to the
    corresponding authorities. If a user did not have an authority mapped to it, Spring
    Security would not allow that user to be logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'After the SQL is added to the embedded database configuration, we should be
    able to start the application and log in. Try logging in with the new user using
    `disabled1@example.com` as the `username` and `disabled1` as the `password`. Notice
    that Spring Security does not allow the user to log in and provides the error
    message `Reason: User` `is disabled`.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.01-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have used the default Spring Security user schema and authorities.
    In the next section, we will explore how we can define **Group Based Access**
    **Control** (**GBAC**).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring UserDetailsManager interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already leveraged the `InMemoryUserDetailsManager` class in Spring Security
    in [*Chapter 3*](B21757_03.xhtml#_idTextAnchor068), *Custom Authentication*, to
    look up the current `CalendarUser` application in our `SpringSecurityUserContext`
    implementation of `UserContext`. This allowed us to determine which `CalendarUser`
    should be used when looking up the events for the `DefaultCalendarService.java`
    file to utilize `InMemoryUserDetailsManager`, to ensure that we created a new
    Spring Security user when we created `CalendarUser`. This chapter reuses exactly
    the same code. The only difference is that the `UserDetailsManager` implementation
    is backed by the `JdbcUserDetailsManager` class of Spring Security, which uses
    a database instead of an in-memory datastore.
  prefs: []
  type: TYPE_NORMAL
- en: What other features does `UserDetailsManager` provide out of the box?
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these types of functions are relatively easy to write with additional
    JDBC statements, Spring Security actually provides out-of-the-box functionality
    to support many common **Create, Read, Update, and Delete** (**CRUD**) operations
    on users in JDBC databases. This can be convenient for simple systems, and a good
    base to build on for any custom requirements that a user may have:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `createUser(UserDetails user)` | It creates a new user with the given
    `UserDetails` information, including any declared `GrantedAuthority` authorities.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `void updateUser(final` `UserDetails user)` | It updates a user with the
    given `UserDetails` information. It updates `GrantedAuthority` and removes the
    user from the user cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `void` `deleteUser(String username)` | It deletes the user with the given
    username and removes the user from the user cache. |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `userExists(String username)` | It indicates whether or not a user
    (active or inactive) exists with the given username. |'
  prefs: []
  type: TYPE_TB
- en: '| `void changePassword(String oldPassword,` `String` `newPassword)` | It changes
    the password of the currently logged-in user. The user must then supply the correct
    password in order for the operation to succeed. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Custom database requirements settings
  prefs: []
  type: TYPE_NORMAL
- en: If `UserDetailsManager` does not provide all the methods that are necessary
    for your application, you can extend the interface to provide these custom requirements.
    For example, if you needed the ability to list all of the possible users in an
    administrative view, you could write your own interface with this method and provide
    an implementation that points to the same datastore as the `UserDetailsManager`
    implementation you are currently using.
  prefs: []
  type: TYPE_NORMAL
- en: Group-based access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `JdbcUserDetailsManager` class supports the ability to add a level of indirection
    between the users and the `GrantedAuthority` declarations by grouping `GrantedAuthority`
    into logical sets called groups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users are then assigned one or more groups, and their membership confers a
    set of the `Granted``Authority` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Group-based access control sample](img/B21757_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Group-based access control sample
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding diagram, this indirection allows the assignment
    of the same set of roles to multiple users, by simply assigning any new users
    to existing groups. This is different behavior that we’ve seen so far, where previously
    we assigned `GrantedAuthority` directly to individual users.
  prefs: []
  type: TYPE_NORMAL
- en: 'This bundling of common sets of authorities can be helpful in the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: You need to segregate users into communities, with some overlapping roles between
    groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to globally change the authorization for a class of user. For example,
    if you have a supplier group, you might want to enable or disable their access
    to particular portions of the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have a large number of users, and you don’t need user-level authority configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unless your application has a very small user base, there is a very high likelihood
    that you’ll be using group-based access control. While group-based access control
    is slightly more complex than other strategies, the flexibility and simplicity
    of managing a user’s access makes this complexity worthwhile. This indirect technique
    of aggregating user privileges by group is commonly referred to as GBAC.
  prefs: []
  type: TYPE_NORMAL
- en: GBAC is an approach common to almost every secured operating system or software
    package on the market. **Microsoft Active Directory** (**AD**) is one of the most
    visible implementations of large-scale GBAC, due to its design of slotting AD
    users into groups and assigning privileges to those groups. Management of privileges
    in large AD-based organizations is made exponentially simpler through the use
    of GBAC.
  prefs: []
  type: TYPE_NORMAL
- en: Try to think of the security models of the software you use—how are the users,
    groups, and privileges managed? What are the pros and cons of the way the security
    model is written?
  prefs: []
  type: TYPE_NORMAL
- en: Let’s add a level of abstraction to the JBCP calendar application and apply
    the concept of group-based authorization to the site.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring group-based access control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll add two groups to the application: regular users, which we’ll call `Users`,
    and administrative users, which we’ll call `Administrators`. Our existing accounts
    will be associated with the appropriate groups through an additional SQL script.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JdbcUserDetailsManager to use groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, Spring Security does not use GBAC. Therefore, we must instruct
    Spring Security to enable the use of groups. Modify the `SecurityConfig.java`
    file to use `GROUP_AUTHORITIES_BY_USERNAME_QUERY`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Utilizing GBAC JDBC scripts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we need to update the scripts that are being loaded at startup. We need
    to remove the `security-user-authorities.sql` mapping so that our users no longer
    obtain their authorities with direct mapping. We then need to add two additional
    SQL `scripts`. Update the `DataSource` bean configuration to load the SQL required
    for GBAC, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The group-based schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It may be obvious, but the first SQL file we added contains updates to the
    schema to support group-based authorization. You can find the contents of the
    file in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Group authority mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to map our existing users to groups, and the groups to authorities.
    This is done in the `security-groups-mappings.sql` file. Mapping based on groups
    can be convenient because often, organizations already have a logical group of
    users for various reasons. By utilizing the existing groupings of users, we can
    drastically simplify our configuration. This is how a layer of indirection helps
    us. We have included the group definitions, group to authority mappings, and a
    few users in the following group mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Go ahead and start the application, and it will behave just as before; however,
    the additional layer of abstraction between the users and roles simplifies the
    managing of large groups of users.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.02-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: After exploring in this section how we can define GBAC, we will define in the
    following section a custom database queries to retrieve users and authorities.
  prefs: []
  type: TYPE_NORMAL
- en: Support for a custom schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s common for new users of Spring Security to begin their experience by adapting
    the JDBC user, group, or role mapping to an existing schema. Even though a legacy
    database doesn’t conform to the expected Spring Security schema, we can still
    configure `JdbcDaoImpl` to map to it.
  prefs: []
  type: TYPE_NORMAL
- en: We will now update Spring Security’s JDBC support to use our existing `CalendarUser`
    database along with a new `calendar_authorities` table.
  prefs: []
  type: TYPE_NORMAL
- en: We can easily change the configuration of `JdbcUserDetailsManager` to utilize
    this schema and override Spring Security’s expected table definitions and columns,
    which we’re using for the JBCP calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, we will update the SQL user and authorities scripts
    to insert custom roles. At the end, we will configure `JdbcUserDetailsManager`
    to use this custom SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the correct JDBC SQL queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `JdbcUserDetailsManager` class has three SQL queries that have a well-defined
    parameter and a set of returned columns. We must determine the SQL that we’ll
    assign to each of these queries, based on the intended functionality. Each SQL
    query used by `JdbcUserDetailsManager` takes the username presented at login as
    its one and only parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Namespace query** **attribute name** | **Description** | **Expected** **SQL
    columns** |'
  prefs: []
  type: TYPE_TB
- en: '| `users-by-username-query` | Returns one ormore usersmatching theusername;
    only thefirst user is used. | `Username (string)``Password (string)``Enabled (Boolean)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `authorities-by-username-query` | Returns one or more granted authorities
    directly provided to the user. Typically used when GBAC is disabled. | `Username
    (string)` `GrantedAuthority (string)` |'
  prefs: []
  type: TYPE_TB
- en: '| `group-authorities-by-username-query` | Returns grantedauthorities andgroup
    detailsprovided to theuser through groupmembership. Usedwhen GBAC is enabled.
    | `Group` `Primary Key``(``any)``Group` `Name (any)``GrantedAuthority (string)`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.2 – JDBC queries in spring-security
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that in some cases, the return columns are not used by the default
    `JdbcUserDetailsManager` implementation, but they must be returned anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the SQL scripts that are loaded
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to initialize the `DataSource` with our custom schema, rather than
    with Spring Security’s default schema. Update the `DataSourceConfig.java` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have removed all of the scripts that start with security and
    replaced them with `calendar-authorities.sql`.
  prefs: []
  type: TYPE_NORMAL
- en: The CalendarUser authority SQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can view the `CalendarUser` authority mappings in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we use the id as the foreign key, which is better than utilizing
    the username as a foreign key (as Spring Security does). By using the id as the
    foreign key, we can allow users to easily change their username.
  prefs: []
  type: TYPE_NORMAL
- en: Inserting custom authorities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to update `DefaultCalendarService` to insert the authorities for the
    user using our custom schema when we add a new `CalendarUser` class. This is because
    while we reused the schema for the user definition, we did not define custom authorities
    in our existing application. Update `DefaultCalendarService`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed the `JdbcOperations` interface that is used for inserting
    our user. This is a convenient template provided by Spring that helps manage boilerplate
    code, such as connection and transaction handling. For more details, refer to
    the [*Appendix*](B21757_20.xhtml#_idTextAnchor642), *Additional Reference Material*
    of this book to find the Spring Reference.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring JdbcUserDetailsManager to use custom SQL queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to use custom SQL queries for our non-standard schema, we’ll simply
    update our `userDetailsService()` method to include new queries. This is quite
    similar to how we enabled support for GBAC, except instead of using the default
    SQL, we will use our modified SQL. Notice that we remove our old `setGroupAuthoritiesByUsernameQuery()`
    method call, since we will not be using it in this example, in order to keep things
    simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This is the only configuration required to use Spring Security to read settings
    from an existing, non-default schema! Start up the application and ensure that
    everything is working properly.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.03-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the utilization of an existing schema commonly requires an
    extension of `JdbcUserDetailsManager` to support the changing of passwords, the
    renaming of user accounts, and other user-management functions.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using `JdbcUserDetailsManager` to perform user-management tasks,
    then there are over 20 SQL queries utilized by the class that are accessible through
    the configuration. However, only the three covered are available through the namespace
    configuration. Please refer to the Javadoc or source code to review the defaults
    for the queries used by `JdbcUserDetailsManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring secure passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might recall from the security audit in [*Chapter 1*](B21757_01.xhtml#_idTextAnchor015),
    *Anatomy of an Unsafe Application*, that the security of passwords stored in cleartext
    was a top priority of the auditors. In fact, in any secured system, password security
    is a critical aspect of trust and authoritativeness of an authenticated principal.
    Designers of a fully secured system must ensure that passwords are stored in a
    way in which malicious users would have an impractically difficult time compromising
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following general rules should be applied to passwords stored in a database:'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords must not be stored in cleartext (plaintext)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passwords supplied by the user must be compared to the recorded passwords in
    the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user’s password should not be supplied to the user upon demand (even if the
    user forgets it)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purposes of most applications, the best fit for these requirements involves
    one-way encoding, known as the **hashing** of the passwords. Using a cryptographic
    hash provides properties such as security and uniqueness that are important to
    properly authenticate users, with the added bonus that once it is hashed, the
    password cannot be extracted from the value that is stored.
  prefs: []
  type: TYPE_NORMAL
- en: In most secure application designs, it is neither required nor desirable to
    ever retrieve the user’s actual password upon request, as providing the user’s
    password to them without the proper additional credentials could present a major
    security risk. Instead, most applications provide the user the ability to reset
    their password, either by presenting additional credentials (such as their social
    security number, date of birth, tax ID, or other personal information), or through
    an email-based system.
  prefs: []
  type: TYPE_NORMAL
- en: Storing other types of sensitive information
  prefs: []
  type: TYPE_NORMAL
- en: Many of the guidelines listed that apply to passwords apply equally to other
    types of sensitive information, including social security numbers and credit card
    information (although, depending on the application, some of these may require
    the ability to decrypt). Storing this type of information to represent it in multiple
    ways, for example, a customer’s full 16-digit credit card number, would be stored
    in a highly encrypted form, but the last four digits might be stored in cleartext.
    For reference, think of any internet commerce site that displays `XXXX XXXX XXXX
    1234` to help you identify your stored credit cards.
  prefs: []
  type: TYPE_NORMAL
- en: You may already be thinking ahead and wondering, given our admittedly unrealistic
    approach of using SQL to populate our H2 database with users, how do we encode
    the passwords? H2, or most other databases for that matter, don’t offer encryption
    methods as built-in database functions.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the bootstrap process (populating a system with initial users and
    data) is handled through a combination of SQL loads and Java code. Depending on
    the complexity of your application, this process can get very complicated.
  prefs: []
  type: TYPE_NORMAL
- en: For the JBCP calendar application, we’ll retain the `dataSource()` bean declaration
    and `DataSource` is a name in code in the corresponding SQL, and then add some
    SQL that will modify the passwords to their hashed values.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen in this section the best practices for configuring secure password.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will deep dive into the different options to configure
    secured passwords using the `PasswordEncoder` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the PasswordEncoder interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Password hashing in Spring Security is encapsulated and defined by implementations
    of the `o.s.s.authentication.encoding.PasswordEncoder` interface. The simple configuration
    of a password encoder is possible through the `createDelegatingPasswordEncoder()`
    method within the `PasswordEncoderFactories` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You’ll be happy to learn that Spring Security ships with a number of implementations
    of `passwordEncoder`, which are applicable for different needs and security requirements.
  prefs: []
  type: TYPE_NORMAL
- en: The following table provides a list of the out-of-the-box implementation classes
    and their benefits.
  prefs: []
  type: TYPE_NORMAL
- en: We can find the complete list of supported encoders in spring security in the
    `Password` **EncoderFactories** class. If one of these matches our requirement,
    we don’t need to rewrite it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all implementations reside in the `o.s.s.crypto` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Encoder** | **Algorithm** | **Usage** |'
  prefs: []
  type: TYPE_TB
- en: '| `Pbkdf2PasswordEncoder` | PBKDF2 | Provides key strengthening with configurable
    iteration count, suitable for password hashing.Suitable for password storage.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SCryptPasswordEncoder` | Scrypt | Memory-hard key derivation function, making
    it resistant to brute-force attacks.Suitable for password storage. |'
  prefs: []
  type: TYPE_TB
- en: '| `StandardPasswordEncoder` | SHA-256 | Uses a standard SHA-256 algorithm.
    Note that SHA-256 alone is not recommended for password hashing due to its speed.Suitable
    for legacy systems but not recommended for new applications. |'
  prefs: []
  type: TYPE_TB
- en: '| `NoOpPasswordEncoder` | No operation | No hashing or encoding; passwords
    are stored as plain text.Not recommended for production. Useful for testing and
    development. |'
  prefs: []
  type: TYPE_TB
- en: '| `LdapShaPasswordEncoder` | SHA-1 | Performs SHA-1 hashing with optional salt.
    Suitable for compatibility with LDAP directories.Suitable for integration with
    LDAP-based systems. |'
  prefs: []
  type: TYPE_TB
- en: '| `BCryptPasswordEncoder` | BCrypt | One-way hash function with adaptive hashing,
    suitable for password hashing.Recommended for password storage. |'
  prefs: []
  type: TYPE_TB
- en: '| `MessageDigest PasswordEncoder` | Configurable(e.g., MD5,SHA-256,SHA-512)
    | Uses various message digest algorithms, but the choice of algorithm is crucial
    for security.Depends on the selected algorithm. Not recommended for new applications
    due to weaknesses in some algorithms. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.3 – Main PasswordEncoder implementation
  prefs: []
  type: TYPE_NORMAL
- en: As with many other areas of Spring Security, it’s also possible to reference
    a bean definition by implementing `PasswordEncoder` to provide more precise configuration
    and
  prefs: []
  type: TYPE_NORMAL
- en: allowing `PasswordEncoder` to be wired into other beans through the dependency
    injection. For the JBCP calendar application, we’ll need to use this bean reference
    method in order to hash the passwords of the newly created users.
  prefs: []
  type: TYPE_NORMAL
- en: The DelegatingPasswordEncoder implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to Spring Security 5.0, the default `PasswordEncoder` was `NoOpPasswordEncoder`,
    which required plain-text passwords. Based on the Password History section, you
    might expect that the default `PasswordEncoder` would now be something like `BCryptPasswordEncoder`.
    However, this ignores three real world problems:'
  prefs: []
  type: TYPE_NORMAL
- en: Many applications use old password encodings that cannot easily migrate.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best practice for password storage will change again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a framework, Spring Security cannot make breaking changes frequently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead, Spring Security introduces `DelegatingPasswordEncoder`, which solves
    all of the problems by:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that passwords are encoded by using the current password storage recommendations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing for validating passwords in modern and legacy formats.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowing for upgrading the encoding in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can easily construct an instance of `DelegatingPasswordEncoder` by using
    `Password``EncoderFactories`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through the process of configuring basic password encoding for the
    JBCP calendar application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring password encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring basic password encoding involves two steps: hashing the passwords
    we load into the database after the SQL script executes and ensuring that Spring
    Security is configured to work with `PasswordEncoder`.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the PasswordEncoder method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we’ll declare an instance of `PasswordEncoder` as a normal Spring bean,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Making Spring Security aware of the PasswordEncoder method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll need to configure Spring Security to have a reference to a Bean of type
    `PasswordEncoder`, so that it can encode and compare the presented password during
    user login.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to try the application at this point, you’d notice that what were
    previously valid login credentials would now be rejected. This is because the
    passwords stored in the database (loaded with the `calendar-users.sql` script)
    are not stored as a `hash` that matches the password encoder. We’ll need to update
    the stored passwords to be hashed values.
  prefs: []
  type: TYPE_NORMAL
- en: Hashing the stored passwords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As illustrated in the following diagram, when a user submits a password, Spring
    Security hashes the submitted password and then compares that against the unhashed
    password in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Hashing the stored passwords workflow](img/B21757_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Hashing the stored passwords workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that users cannot log in to our application. To fix this, we will
    update the SQL that is loaded at startup time to update the passwords to be the
    hashed values. Update the `DataSourceConfig.java` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calendar-sha256.sql` file simply updates the existing passwords to their
    expected hashed values, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'How did we know what value to update the password to? We have provided `o.s.s.authentication.encoding.Sha256PasswordEncoderMain`
    to demonstrate how to use the configured `PasswordEncoder` interface to hash the
    existing passwords. The relevant code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Hashing the passwords of new users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we tried running the application and creating a new user, we would not be
    able to log in. This is because the newly-created user’s password would not be
    hashed. We need to update `DefaultCalendarService` to hash the password. Make
    the following updates to ensure that the newly-created users passwords are hashed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Not quite secure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Go ahead and start the application. Try creating a new user with `user1` as
    the password. Log out of the application, then use the instructions on the `user1@example.com`
    are the same value? The fact that we have now figured out another user’s password
    is a little disturbing. We will solve this with a technique known as **salting**.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.04-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Would you like some salt with that password? If the security auditor were to
    examine the encoded passwords in the database, he’d find something that would
    still make him concerned about the website’s security. Let’s examine the following
    stored username and password values for a few of our users:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Plaintext password** | **Hashed password** |'
  prefs: []
  type: TYPE_TB
- en: '| `admin1@example.com` | `admin1` | `{``SHA-256}25f43b1486ad95a1 398e3eeb3d83bc4010015fcc9``bedb35b432e00298d5021f7`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `user1@example.com` | `user1` | `{``SHA-256}0a041b9462caa4a3 1bac3567e0b6e6fd9100787db``2ab433d96f6d178cabfce90`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.4 – Hashed users passwords
  prefs: []
  type: TYPE_NORMAL
- en: This looks very secure—the encrypted passwords obviously bear no resemblance
    to the original passwords. What could the auditor be concerned about? What if
    we add a new user who happens to have the same password as our `user1@example.com`
    user?
  prefs: []
  type: TYPE_NORMAL
- en: '| **Username** | **Plaintext** **password** | **Hashed password** |'
  prefs: []
  type: TYPE_TB
- en: '| `hacker@example.com` | `user1` | `{``SHA-256}0a041b9462caa4 a31bac3567e0b6e6fd91007``87db2ab433d96f6d178cabfce90`
    |'
  prefs: []
  type: TYPE_TB
- en: Table 4.5 – Hacked hashed user password
  prefs: []
  type: TYPE_NORMAL
- en: Now, note that the encrypted password of the `hacker@example.com` user is exactly
    the same as the real user! Thus, a hacker who had somehow gained the ability to
    read the encrypted passwords in the database could compare their known password’s
    encrypted representation with the unknown one for the user account, and see they
    are the same! If the hacker had access to an automated tool to perform this analysis,
    they could likely compromise the user’s account within a matter of hours.
  prefs: []
  type: TYPE_NORMAL
- en: While it is difficult to guess a single password, hackers can calculate all
    the hashes ahead of time and store a mapping of the hash to the original password.
    Then, figuring out the original password is a matter of looking up the password
    by its hashed value in constant time. This is a hacking technique known as **rainbow
    tables**.
  prefs: []
  type: TYPE_NORMAL
- en: One common and effective method of adding another layer of security to encrypted
    passwords is to incorporate a **salt**. A salt is a second plaintext component,
    which is concatenated with the plaintext password prior to performing the hash,
    in order to ensure that two factors must be used to generate (and thus compare)
    the hashed password values. Properly selected salts can guarantee that no two
    passwords will ever have the same hashed value, thus preventing the scenario that
    concerned our auditor, and avoiding many common types of brute force password
    cracking techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Best practice salts generally fall into one of the following three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: They are algorithmically generated from some pieces of data associated with
    the user, for example, the timestamp that the user created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are randomly generated and stored in some form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They are plaintext or two-way encrypted along with the user’s password record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that because the `salt` value for a given user’s record in order to
    calculate the `hash` of the password, and to compare it with the stored `hash`
    of the user when performing authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Using salt in Spring Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`spring-security-core` module and are available separately in `spring-security-crypto`.
    The `o.s.s.crypto.password.PasswordEncoder` interface. In fact, using this interface
    is the preferred method for encoding passwords, because it will salt passwords
    using a random `salt`. At the time of this writing, there are the following three
    implementations of `o.s.s.crypto.password.PasswordEncoder`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Class** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.crypto.bcrypt.BCryptPasswordEncoder` | This class uses the `bcrypt`
    hashing function. It supports `salt` and the ability to slow down to perform over
    time as technology improves. This helps protect against brute- force search attacks.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.crypto.password.NoOpPasswordEncoder` | This class does no encoding
    (it returns the password in its plaintext form). Provided for legacy and testing
    purposes only and is not considered secure. |'
  prefs: []
  type: TYPE_TB
- en: '| `o.s.s.crypto.password.StandardPasswordEncoder` | This class uses `SHA-256`
    with multiple iterations and a random `salt` value. Provided for legacy and testing
    purposes only and is not considered secure. |'
  prefs: []
  type: TYPE_TB
- en: Table 4.6 – Common PasswordEncoder implementations
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For those who are familiar with `Spring Security`, The Spring Security Crypto
    module provides support for symmetric encryption, key generation, and password
    encoding. The classes above are part of the core module and has no dependencies
    on any other Spring Security (or Spring) code.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Spring Security configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This can be done by updating the Spring Security configuration. Remove the
    old `ShaPasswordEncoder` encoder and add the new `StandardPasswordEncoder` encoder,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Migrating existing passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take a look at the following steps and learn about migrating existing
    passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to update our existing passwords to use the values produced by the
    new `PasswordEncoder` class. If you would like to generate your own passwords,
    you can use the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the previously used `calendar-sha256.sql` file, and add the provided
    `saltedsha256.sql` file as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Updating DefaultCalendarUserService
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `passwordEncoder()` method we defined previously is smart enough to handle
    the new password encoder interface. However, `DefaultCalendarUserService` needs
    to update to the new interface. Make the following updates to the `DefaultCalendarUserService`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code implementation, we have been able to configure Salt
    SHA256 in Spring Security. The `DefaultCalendarService` uses this Salt `PasswordEncoder`
    to insert user’s password.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore another option to use `Salt` with `Bcrypt`
    algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out salted passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Start up the application and try creating another user with the password `user1`.
    Use the H2 console to compare the new user’s password and observe that they are
    different.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.05-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Spring Security now generates a random `salt` and combines this with the password
    before hashing our password. It then adds the random `salt` to the beginning of
    the password in plaintext, so that passwords can be checked. The stored password
    can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is the pseudocode for hashing a newly created password.
  prefs: []
  type: TYPE_NORMAL
- en: 'To authenticate a user, `salt` and `hash` can be extracted from the stored
    password, since both `salt` and `hash` are fixed lengths. Then, the extracted
    `hash` can be compared against a new `hash`, computed with extracted `salt` and
    the inputted password:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Salting the stored passwords workflow](img/B21757_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Salting the stored passwords workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the pseudocode for validating a salted password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`BCryptPasswordEncoder` is another salt implementation uses the widely supported
    `bcrypt` algorithm to hash the passwords. `Bcrypt` uses a random `16-byte salt`
    value and is a deliberately slow algorithm, to hinder password crackers. You can
    tune the amount of work it does by using the strength parameter, which takes a
    value from *4* to *31*. The higher the value, the more work has to be done to
    calculate the hash. The default value is `10`. You can change this value in your
    deployed system without affecting existing passwords, as the value is also stored
    in the encoded hash. The following example uses the `BCryptPasswordEncoder` with
    strength parameter value equal to `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we had to use add the provided `calendar-bcrypt.sql` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Start up the application and try logging to the application with username `user1@example.com`
    and password `user1`.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Your code should now look like this: `calendar04.06-calendar`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Spring Security’s built-in *JDBC support*.
    Specifically, we have learned that Spring Security provides a default schema for
    new applications. We also explored how to implement *GBAC* and how it can make
    managing users easier.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to integrate Spring Security’s JDBC support with an existing
    database and also how to secure our passwords by hashing them and using a randomly
    generated *salt*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore the *Spring Data* project and how to configure
    Spring Security to use **object-relational mapping** (**ORM**) to connect to an
    RDBMS, as well as a document database.
  prefs: []
  type: TYPE_NORMAL
