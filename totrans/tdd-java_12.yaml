- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Test First, Test Later, Test Never
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试先行，测试后行，从不测试
- en: In this chapter, we are going to review some of the nuances of **Test-Driven
    Development** (**TDD**). We’ve already covered the broad techniques of writing
    unit tests as part of an overall test strategy. We can use the test pyramid and
    hexagonal architecture to guide the scope of our tests in terms of what specifically
    they need to cover.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将回顾**测试驱动开发**（**TDD**）的一些细微差别。我们已经涵盖了编写单元测试的整体测试策略中的广泛技术。我们可以使用测试金字塔和六边形架构来指导测试的范围，具体来说，它们需要覆盖什么。
- en: 'We have two more dimensions we need to decide on: when and where to start testing.
    The first question is one of timing. Should we always write our tests before the
    code? What difference would it make to write tests after the code? In fact, what
    about not testing at all – does that ever make sense? Where to start testing is
    another variable to decide. There are two schools of thought when it comes to
    TDD – testing from the inside out or the outside in. We will review what these
    terms mean and what impact each has on our work. Finally, we will consider how
    these approaches work with a hexagonal architecture to form a natural testing
    boundary.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要决定两个额外的维度：何时以及在哪里开始测试。第一个问题是关于时间的问题。我们应该总是在编写代码之前编写测试吗？在代码之后编写测试会有什么不同？实际上，完全不测试——这有没有意义？在哪里开始测试是另一个需要决定的变量。在TDD（测试驱动开发）方面，有两种不同的观点——从内部到外部或从外部到内部进行测试。我们将回顾这些术语的含义以及它们对我们工作的影响。最后，我们将考虑这些方法如何与六边形架构结合，形成一个自然的测试边界。
- en: 'In this chapter we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Adding tests first
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先添加测试
- en: We can always test it later, right?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不是总能稍后测试吗？
- en: Tests? They’re for people who can’t write code!
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试？那是给不会写代码的人准备的！
- en: Testing from the inside out
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从内部到外部进行测试
- en: Testing from the outside in
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从外部到内部进行测试
- en: Defining test boundaries with hexagonal architecture
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用六边形架构定义测试边界
- en: Adding tests first
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 先添加测试
- en: In this section, we will review the trade-offs of adding a test first before
    writing the production code to make it pass.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将回顾在编写生产代码之前先添加测试以使其通过时的权衡。
- en: Previous chapters have followed a test-first approach to writing code. We write
    a test before writing production code to make that test pass. This is a recommended
    approach, but it is important to understand some of the difficulties associated
    with it as well as considering its benefits.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章遵循了测试先行的编写代码方法。我们在编写生产代码之前编写测试以使其通过。这是一个推荐的方法，但了解与之相关的某些困难以及考虑其好处同样重要。
- en: Test-first is a design tool
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试先行是一种设计工具
- en: 'The most important benefit of writing tests first is that a test acts as a
    *design aid*. As we decide what to write in our test, we are designing the interface
    to our code. Each of the test stages helps us consider an aspect of software design,
    as illustrated by the following diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试先行的最重要的好处是测试可以作为*设计辅助工具*。当我们决定在测试中写什么时，我们正在设计代码的接口。以下图表展示了每个测试阶段如何帮助我们考虑软件设计的各个方面：
- en: '![Figure 12.1 – Test-first aids design](img/Figure_12.1_B18384.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 测试先行辅助设计](img/Figure_12.1_B18384.jpg)'
- en: Figure 12.1 – Test-first aids design
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 测试先行辅助设计
- en: 'The **Arrange** step helps us think about how the code under test relates to
    the bigger picture of the whole code base. This step helps us design how the code
    will fit into the whole code base. It gives us an opportunity to make the following
    design decisions:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**安排**步骤帮助我们思考待测试代码与整个代码库的更大图景之间的关系。这一步骤帮助我们设计代码将如何融入整个代码库。它给我们机会做出以下设计决策：'
- en: What configuration data will be needed?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要哪些配置数据？
- en: What connections to other objects or functions will be needed?
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要与其他对象或函数建立什么联系？
- en: What behavior should this code provide?
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这段代码应该提供什么行为？
- en: What extra inputs are needed to provide that behavior?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供该行为需要哪些额外的输入？
- en: 'Coding the Act step allows us to think about how easy our code will be to use.
    We reflect on what we would like the method signature of the code we are designing
    to be. Ideally, it should be simple and unambiguous. Some general recommendations
    are the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 编码行为步骤使我们能够思考我们的代码将有多容易使用。我们反思我们希望我们正在设计的代码的方法签名是什么。理想情况下，它应该是简单且明确的。以下是一些一般性建议：
- en: The method name should describe the outcome of calling the method.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法名应该描述调用该方法的结果。
- en: Pass in as few parameters as possible. Possibly group parameters into their
    own object.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能地传递尽可能少的参数。可能将参数分组到它们自己的对象中。
- en: Avoid Boolean flags that modify the behavior of the code. Use separate methods
    with appropriate names.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用布尔标志来修改代码的行为。使用具有适当名称的单独方法。
- en: Avoid requiring multiple method calls to do one thing. It is too easy to miss
    out on an important call in the sequence if we are unfamiliar with the code.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免要求多次方法调用来完成一项任务。如果我们不熟悉代码，很容易错过序列中的重要调用。
- en: Writing the Act step allows us to see what the call to our code will look like
    everywhere it is used for the first time. This provides the opportunity to simplify
    and clarify before our code gets widely used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 编写行为步骤允许我们看到我们的代码在首次使用时将如何调用。这为我们提供了在代码被广泛使用之前简化并澄清的机会。
- en: The code in our Assert step is the first consumer of the results of our code.
    We can judge from this step whether those results are easy to obtain. If we are
    unhappy with how the Assert code looks, this is a chance to review how our object
    provides its output.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们断言步骤中的代码是我们代码结果的第一消费者。我们可以从这个步骤判断这些结果是否容易获得。如果我们对断言代码的外观不满意，这是一个审查我们的对象如何提供输出的机会。
- en: Every test we write provides this opportunity for a design review. TDD is all
    about helping us uncover better designs, even more than it is about testing correctness.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写的每个测试都提供了这种设计审查的机会。TDD（测试驱动开发）的全部意义在于帮助我们发现更好的设计，甚至比测试正确性更重要。
- en: In other industries, such as designing cars, it is common to have dedicated
    design tools. **AutoCAD 3D Studio** is used to create 3D models for the chassis
    of a car on a computer. Before we manufacture the car, we can use the tool to
    pre-visualize the end result, rotating it through space and viewing it from several
    angles.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他行业，如汽车设计，拥有专门的设计工具是很常见的。**AutoCAD 3D Studio**用于在计算机上创建汽车底盘的3D模型。在我们制造汽车之前，我们可以使用这个工具来预览最终结果，通过旋转空间并从多个角度观看。
- en: Mainstream commercial software engineering lags far behind in terms of design
    tool support. We don’t have an equivalent to 3D Studio for designing code. The
    1980s to 2000s saw the rise of **Computer-Aided Software Engineering** (**CASE**)
    **tools** but these appear to have fallen into disuse. CASE tools purported to
    simplify software engineering by allowing their users to enter various graphical
    forms of software structures, then generate code that implemented those structures.
    Today, writing TDD tests prior to writing the production code seems to be the
    closest thing we have to computer-aided design for software at present.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在主流的商业软件开发中，设计工具的支持远远落后。我们没有用于设计代码的3D Studio的等价物。从20世纪80年代到2000年代，**计算机辅助软件工程**（**CASE**）**工具**的兴起，但这些似乎已经不再使用。CASE工具声称通过允许用户输入各种图形形式的软件结构，然后生成实现这些结构的代码来简化软件工程。今天，在编写生产代码之前编写TDD测试似乎是我们目前拥有的最接近软件计算机辅助设计的工具。
- en: Tests form executable specifications
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试形成可执行的规范
- en: Another advantage of test code is that it can form a highly accurate, repeatable
    form of documentation. Simplicity and clarity in the test code are required to
    achieve that. Instead of writing a test planning document, we write TDD tests
    as code, which can be run by a computer. This has the benefit of being more immediate
    for developers. These executable specifications are captured alongside the production
    code they test, stored in source control, and made continuously available to the
    whole team.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 测试代码的另一个优点是它可以形成一种高度准确、可重复的文档形式。为了实现这一点，测试代码需要简洁和清晰。我们不是编写测试计划文档，而是将TDD测试作为代码编写，这些代码可以被计算机运行。这为开发者提供了更直接的好处。这些可执行规范与它们测试的生产代码一起捕获，存储在源代码控制中，并持续提供给整个团队。
- en: Further documentation is useful. Documents such as **RAID logs** – documenting
    risks, actions, issues, and decisions – and **KDDs** – documenting key design
    decisions – are often required. These are non-executable documents. They serve
    the purpose of capturing who, when, and critically *why* an important decision
    was made. Information of this kind cannot be captured using test code, meaning
    that these kinds of documents have value.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步的文档很有用。例如，**RAID日志**——记录风险、行动、问题和决策——以及**KDDs**——记录关键设计决策——通常是必需的。这些是非可执行文档。它们的作用是捕捉谁、何时以及关键地*为什么*做出了重要决策。这类信息无法通过测试代码来捕捉，这意味着这类文档具有价值。
- en: Test-first provides meaningful code coverage metrics
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试驱动提供了有意义的代码覆盖率指标
- en: 'Writing a test before we write production code gives each test a specific purpose.
    The test exists to drive out a specific behavior in our code. Once we get this
    test to pass, we can run the test suite using a code coverage tool, which will
    output a report similar to the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写生产代码之前编写测试，为每个测试赋予一个特定的目的。测试的存在是为了驱除我们代码中的特定行为。一旦我们使这个测试通过，我们就可以使用代码覆盖率工具运行测试套件，这将输出一个类似于以下报告的报表：
- en: '![Figure 12.2 – Code coverage report](img/Figure_12.2_B18384.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 代码覆盖率报告](img/Figure_12.2_B18384.jpg)'
- en: Figure 12.2 – Code coverage report
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 代码覆盖率报告
- en: A **code coverage** tool instruments our production code as we run the tests.
    This instrumentation captures which lines of code were executed during running
    the tests. This report can suggest we have missing tests, by flagging up lines
    of code that were never executed during the test run.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率工具在我们运行测试时对我们的生产代码进行仪器化。这种仪器化捕获了在测试运行期间执行了哪些代码行。这份报告可以建议我们缺少测试，通过标记出在测试运行期间从未执行过的代码行。
- en: The code coverage report in the image shows we have executed 100% of the code
    in the domain model by our test run. Having 100% coverage is entirely down to
    us writing a TDD test before we write code to make it pass. We do not add untested
    code with a test-first TDD workflow.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图像中的代码覆盖率报告显示，我们的测试运行已经执行了领域模型中的100%的代码。拥有100%的覆盖率完全取决于我们在编写代码之前编写TDD测试来使其通过。我们不会在TDD测试优先的工作流程中添加未经测试的代码。
- en: Beware of making a code coverage metric a target
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谨防将代码覆盖率指标作为目标
- en: A high code coverage metric doesn’t always indicate high code quality. If we
    are writing tests for generated code or tests for code we’ve pulled from a library,
    that coverage does not tell us anything new. We may assume – generally – that
    our code generators and libraries have already been tested by their developers.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 高代码覆盖率指标并不总是意味着高代码质量。如果我们正在为生成的代码或从库中提取的代码编写测试，那么这种覆盖率并不能告诉我们任何新的信息。我们可能假设——通常——我们的代码生成器和库已经由它们的开发者进行了测试。
- en: 'However, a real problem with code coverage numbers happens when we mandate
    them as a metric. As soon as we impose a minimum coverage target on developers,
    then **Goodhart’s law** applies – *when a measure becomes a target, it ceases
    to be a good measure*. Humans will sometimes cheat the system to achieve a target
    when under pressure. When that happens, you see code such as this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，代码覆盖率数字的一个真正问题是当我们将其作为指标强制执行时。一旦我们向开发者强加一个最低覆盖率目标，那么**Goodhart定律**就适用了——*当一项指标成为目标时，它就不再是好的指标了*。在压力之下，人类有时会作弊以实现目标。当这种情况发生时，你会看到这样的代码：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice those comment symbols – `//` – just before `assertThat()`? That’s the
    hallmark of a test case that was failing and could not be made to pass by a certain
    deadline. By retaining the test, we keep our number of test cases up, and we keep
    our code coverage percentage up. A test such as this will execute lines of production
    code, but it will not *validate* that they work. The code coverage target will
    be hit – even though the code itself does not work.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意那些在`assertThat()`之前的注释符号——`//`？这是测试案例失败的标志，无法在某个截止日期前通过。通过保留测试，我们保持测试用例的数量，并保持代码覆盖率百分比。这样的测试将执行生产代码的行，但它不会*验证*它们是否工作。代码覆盖率目标将被达到——即使代码本身并不工作。
- en: Now, I know what you’re thinking – no developer would ever cheat the test code
    like this. It is, however, an example from a project I worked on for a major international
    client. The client had engaged both the company I work for and another development
    team to work on some microservices. Due to a time zone difference, the other team
    would check in their code changes while our team was asleep.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我知道你在想什么——没有开发者会像这样作弊测试代码。然而，这确实是我为一个主要国际客户工作的项目中的一个例子。客户聘请了我工作的公司和另一个开发团队来处理一些微服务。由于时区差异，另一个团队在我们团队睡觉时提交他们的代码更改。
- en: We came in one morning to see our test results dashboards lit up red. The overnight
    code change had caused large numbers of our tests to fail. We checked the pipelines
    of the other team and were astonished to see all their tests passing. This made
    no sense. Our tests clearly revealed a defect in that nightly code drop. We could
    even localize it from our test failures. This defect would have shown up in the
    unit tests around that code, but those unit tests were passing. The reason? Commented-out
    asserts.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在一个早上到达时看到我们的测试结果仪表板亮起了红色。夜间的代码更改导致我们的大量测试失败。我们检查了其他团队的代码管道，惊讶地看到他们的所有测试都通过了。这毫无道理。我们的测试清楚地揭示出那个夜间代码提交中的缺陷。我们甚至可以从我们的测试失败中定位到这个缺陷。这个缺陷本应该在围绕该代码的单元测试中显现出来，但那些单元测试是通过的。原因？注释掉的断言。
- en: The other team was under pressure to deliver. They obeyed their instructions
    to get that code change checked in on that day. Those changes, in fact, had broken
    their unit tests. When they could not fix them in the time available, they chose
    to cheat the system and defer the problem to another day. I’m not sure I blame
    them. Sometimes, 100% code coverage and all tests passing mean nothing at all.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个团队面临着交付的压力。他们遵守了当天将代码更改检查入库的指示。实际上，这些更改破坏了他们的单元测试。当他们没有足够的时间修复它们时，他们选择欺骗系统，将问题推迟到另一天。我不确定我是否应该责怪他们。有时候，100%的代码覆盖率和所有测试通过实际上什么也不意味着。
- en: Beware of writing all tests upfront
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 小心一开始就编写所有测试
- en: One of the strengths of TDD is that it allows for *emergent design*. We do a
    small piece of design work, captured in a test. We then do the next small piece
    of design, captured in a new test. We perform varying depths of refactoring as
    we go. In this way, we learn about what is and is not working in our approach.
    The tests provide fast feedback on our design.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: TDD（测试驱动开发）的一个优势是它允许*涌现式设计*。我们进行一小部分设计工作，体现在一个测试中。然后我们进行下一小部分设计，体现在一个新的测试中。我们在进行过程中执行不同程度的重构。这样，我们了解我们的方法中哪些是有效的，哪些是不有效的。测试为我们提供了关于设计的快速反馈。
- en: This can only happen if we write tests one at a time. A temptation for those
    familiar with waterfall project approaches can be to treat the test code as one
    giant requirements document, to be completed before development starts. While
    this seems more promising than simply writing a requirements document in a word
    processor, it also means that developers cannot learn from test feedback. There
    is no feedback cycle. This approach to testing should be avoided. Better results
    are obtained by taking an incremental approach. We write one test at a time, together
    with the production code to make that test pass.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况只会在我们一次写一个测试时发生。对于那些熟悉瀑布式项目方法的人来说，可能会倾向于将测试代码视为一个巨大的需求文档，在开发开始之前完成。虽然这比在文字处理器中简单地编写需求文档看起来更有希望，但它也意味着开发者无法从测试反馈中学习。没有反馈循环。这种测试方法应该避免。通过采取增量方法可以获得更好的结果。我们一次写一个测试，与生产代码一起编写，以确保测试通过。
- en: Writing tests first helps with continuous delivery
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写测试的第一步有助于持续交付
- en: Perhaps the biggest benefit of writing tests first lies in continuous delivery
    situations. Continuous delivery relies on a highly automated pipeline. Once a
    code change is pushed to source control, the build pipeline is started, all tests
    run, and finally, a deployment occurs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 写测试的第一大好处可能在于持续交付的情况。持续交付依赖于高度自动化的管道。一旦代码更改推送到源代码控制，就会启动构建管道，运行所有测试，最后进行部署。
- en: The only reason for code not to deploy in this system – assuming the code compiles
    – is if the tests fail. This implies that the automated tests we have in place
    are necessary and sufficient to create the level of confidence required.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个系统中，代码无法部署的唯一原因——假设代码可以编译——是测试失败。这表明我们现有的自动化测试是必要且充分的，以创建所需级别的信心。
- en: Writing tests first cannot guarantee this – we may still have missing tests
    – but out of all the ways of working with tests, it is perhaps the most likely
    to result in one meaningful test for each piece of application behavior that we
    care about.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 写测试的第一步不能保证这一点——我们可能仍然缺少测试——但与所有使用测试的方式相比，它可能是最有可能导致我们对每个关心的应用程序行为都有一个有意义的测试。
- en: This section has presented the case that writing tests first – before production
    code is written, to make them pass – helps create confidence in our code, as well
    as useful executable specifications. However, that’s not the only way to code.
    Indeed, a common approach we will see is to write a chunk of code first and then
    write tests shortly after.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提出了编写测试先于生产代码以使它们通过，从而有助于增强我们对代码的信心以及有用的可执行规范的观点。然而，这并非编写代码的唯一方式。实际上，我们将看到的一种常见方法是先编写一大块代码，然后不久后编写测试。
- en: The next section looks at the advantages and limitations of the test-later approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将探讨测试后方法的优缺点。
- en: We can always test it later, right?
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们总是可以稍后进行测试，对吧？
- en: An alternative approach to writing tests before code is to write code first,
    then write tests. This section compares and contrasts writing tests after the
    code with writing tests before the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写测试代码之前编写代码的另一种方法是先编写代码，然后编写测试。本节比较和对比了在代码之后编写测试与在代码之前编写测试。
- en: 'One approach to writing tests involves writing chunks of code and then retrofitting
    tests to those pieces of code. It’s an approach that is used in commercial programming,
    and the workflow can be illustrated as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编写测试的一种方法涉及编写代码块，然后为这些代码片段添加测试。这是一种在商业编程中使用的做法，其工作流程可以如下所示：
- en: '![Figure 12.3 – Test-after workflow](img/Figure_12.3_B18384.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 测试后工作流程](img/Figure_12.3_B18384.jpg)'
- en: Figure 12.3 – Test-after workflow
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 测试后工作流程
- en: 'Upon selecting a user story to develop, one or more pieces of production code
    are written. Tests follow! Academic research seems mixed, to say the least, on
    whether or not test-after differs from test-first. From one 2014 study by the
    ACM, an extract from the conclusion was this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择一个用户故事进行开发后，会编写一个或多个生产代码片段。然后是测试！至少可以说，学术界对于测试后是否与测试优先有所不同的研究似乎存在分歧。从2014年ACM的一项研究中提取的结论如下：
- en: “*…static code analysis results were found statistically significant in the
    favor of TDD. Moreover, the results of the survey revealed that the majority of
    developers in the experiment prefer TLD over TDD, given the lesser required level
    of learning curve.*”
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: “*…静态代码分析结果在TDD方面具有统计学上的显著性。此外，调查结果还显示，实验中的大多数开发者更喜欢TLD而不是TDD，因为TLD的学习曲线要求较低。*”
- en: '(Source: [https://dl.acm.org/doi/10.1145/2601248.2601267](https://dl.acm.org/doi/10.1145/2601248.2601267))'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: （来源：[https://dl.acm.org/doi/10.1145/2601248.2601267](https://dl.acm.org/doi/10.1145/2601248.2601267)）
- en: 'However, a commenter pointed out that in this research, the following applied:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一位评论者指出，在这项研究中，以下情况适用：
- en: “*…usable data was obtained from only 13 out of 31 developers. This meant the
    statistical analysis was undertaken using groups of seven (TDD) and six (TLD).
    There is no real surprise that the experiment was found to lack statistical power
    and that the findings were inconclusive.*”
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: “*…只有13位开发者中的13位提供了可用数据。这意味着统计分析是在使用7人组（TDD）和6人组（TLD）的群体中进行的。实验缺乏统计效力，结果并不确定的这一发现并不令人惊讶。*”
- en: Other research papers seem to show similar lackluster results. Practically then,
    what should we take away from this? Let’s consider some practical details of test-later
    development.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 其他研究论文似乎也显示出类似乏力的结果。那么在实践中，我们应该从中吸取什么教训呢？让我们考虑一些测试后开发的实际细节。
- en: Test-later is easier for a beginner to TDD
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试后方法对TDD初学者来说更容易
- en: One finding of the research was that beginners to TDD found test-later to be
    easier to get started with. This seems reasonable. Before we attempt TDD, we may
    consider coding and testing as different activities. We write code according to
    some set of heuristics, and then we figure out how to test that code. Adopting
    a test-later approach means that the coding phase is essentially unchanged by
    the demands of testing. We can continue coding as we always did. There is no impact
    from having to consider the impacts of testing on the design of that code. This
    seeming advantage is short-lived, as we discover the need to add access points
    for testing, but we can at least get started easily.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 研究的一个发现是，TDD初学者发现测试后方法更容易上手。这似乎是合理的。在我们尝试TDD之前，我们可能会将编码和测试视为不同的活动。我们根据某些启发式方法编写代码，然后找出如何测试这些代码。采用测试后方法意味着编码阶段基本上不受测试需求的影响。我们可以像以前一样继续编码。我们不需要考虑测试对代码设计的影响。这种看似的优势是短暂的，因为我们发现需要添加测试访问点，但我们至少可以轻松地开始。
- en: 'Adding tests later works reasonably well if we keep writing tests in lockstep
    with the production code: write a little code, and write a few tests for that
    code – but not having tests for every code path remains a risk.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们与生产代码同步编写测试，那么稍后添加测试可以合理地工作：编写一点代码，并为该代码编写一些测试——但不是为每个代码路径编写测试仍然是一个风险。
- en: Test-later makes it harder to test every code path
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试后使得测试每个代码路径变得更加困难
- en: A plausible argument against using a test-later approach is that it becomes
    harder to keep track of having all the tests we need. On the face of it, this
    claim cannot be completely true. We can always find some way to keep track of
    the tests we need. A test is a test, no matter when it is written.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 反对使用测试后方法的合理论点是，跟踪所有所需测试变得更加困难。表面上，这个说法可能并不完全正确。我们总能找到某种方法来跟踪所需的测试。无论何时编写，测试都是测试。
- en: 'The problem comes as the time between adding tests increases. We are adding
    more code, which means adding more execution paths throughout the code. For example,
    every `if` statement we write represents two execution paths. Ideally, every execution
    path through our code will have a test. Every untested execution path we add places
    us one test below this ideal number. This is illustrated directly in flowcharts:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于添加测试之间的时间增加。我们正在添加更多代码，这意味着在整个代码中添加更多执行路径。例如，我们编写的每个`if`语句代表两个执行路径。理想情况下，我们的代码中的每个执行路径都将有一个测试。我们添加的每个未测试的执行路径都使我们低于这个理想数量一个测试。这直接在流程图中展示：
- en: '![Figure 12.4 – Illustrating execution paths](img/Figure_12.4_B18384.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 展示执行路径](img/Figure_12.4_B18384.jpg)'
- en: Figure 12.4 – Illustrating execution paths
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 展示执行路径
- en: This flowchart depicts a process with nested decision points – the diamond shapes
    – which result in three possible execution paths, labeled **A**, **B**, and **C**.
    The technical measure of the number of execution paths is called **cyclomatic
    complexity**. The complexity score is the number calculated on how many linearly
    independent execution paths exist in a piece of code. The code in the flowchart
    has a cyclomatic complexity of three.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此流程图描述了一个具有嵌套决策点（菱形形状）的过程，这导致三个可能的执行路径，标记为**A**、**B**和**C**。执行路径数量的技术度量称为**圈复杂度**。复杂度得分是根据代码中存在的线性独立执行路径数量计算出的数值。流程图中的代码的圈复杂度为三。
- en: As we increase the cyclomatic complexity of our code, we increase our *cognitive
    load* with the need to remember all those tests that we need to write later. At
    some point, we might even find ourselves periodically stopping coding and writing
    down notes for what tests to add later. This sounds like a more arduous version
    of simply writing the tests as we go.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们代码的圈复杂度增加，我们需要记住所有那些需要稍后编写的测试，这增加了我们的*认知负荷*。在某个时候，我们甚至可能发现自己定期停止编码，并写下关于稍后要添加哪些测试的笔记。这听起来像是简单地边编写测试边进行的更艰难版本。
- en: The issue of keeping track of tests we are yet to write is avoided when using
    test-first development.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用测试优先开发时，避免跟踪尚未编写的测试的问题。
- en: Test-later makes it harder to influence the software design
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试后使得影响软件设计变得更加困难
- en: One of the benefits of test-first development is that the feedback loop is very
    short. We write one test and then complete a small amount of production code.
    We then refactor as required. This moves away from a waterfall-style pre-planned
    design to an emergent design. We change our design in response to learning more
    about the problem we are solving as we incrementally solve more of it.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 测试优先开发的一个好处是反馈循环非常短。我们编写一个测试，然后完成一小部分生产代码。然后根据需要重构。这从瀑布式预计划设计转变为涌现设计。我们根据对正在解决的问题的更多了解来改变我们的设计，因为我们逐步解决更多的问题。
- en: When writing tests after a chunk of code has already been written, it gets harder
    to incorporate feedback. We may find that the code we have created proves difficult
    to integrate into the rest of the code base. Perhaps this code is confusing to
    use due to having unclear interfaces. Given all the effort we have spent creating
    the messy code, it can be tempting to just live with the awkward design and its
    equally awkward test code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写了一块代码之后，再编写测试，就难以融入反馈。我们可能会发现我们创建的代码难以集成到其余代码库中。也许由于接口不明确，这段代码难以使用。鉴于我们为创建混乱的代码所付出的所有努力，我们可能会满足于这种尴尬的设计及其同样尴尬的测试代码。
- en: Test-later may never happen
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试后可能永远不会发生
- en: Development tends to be a busy activity, especially when deadlines are involved.
    Time pressures may mean that the time we hoped to get to write our tests simply
    never comes. It’s not uncommon for project managers to be more impressed with
    new features than with tests. This seems a false economy – as users only care
    about features that *work* – but it’s a pressure that developers sometimes face.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 开发通常是一项繁忙的活动，尤其是在涉及截止日期的情况下。时间压力可能意味着我们希望用来编写测试的时间根本就没有。项目经理对新的功能比对测试更感兴趣的情况并不少见。这似乎是一种错误的经济行为
    – 因为用户只关心那些*工作*的功能 – 但这是开发者有时面临的一种压力。
- en: This section has shown that writing tests shortly after writing code can work
    as well as writing tests first if care is exercised. It also seems preferable
    to some developers at the start of their TDD journey – but what about the ultimate
    extreme of *never* testing our code? Let’s quickly review the consequences of
    that approach.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节已表明，在编写代码后不久编写测试可以与先编写测试一样有效，只要我们小心行事。这也似乎是一些开发者TDD之旅开始时的首选 – 但如果我们达到从不测试代码的极端，又会怎样呢？让我们快速回顾一下这种方法的后果。
- en: Tests? They’re for people who can’t write code!
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试？那是给那些不会写代码的人准备的！
- en: This section discusses another obvious possibility when it comes to automated
    testing – simply not writing automated tests at all. Perhaps not even testing
    at all. Is this viable?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了自动化测试的另一个明显可能性 – 简单地不编写自动化测试，甚至可能完全不测试。这是可行的吗？
- en: Not testing at all is a choice we could make, and this might not be as silly
    as it sounds. If we define testing as *verifying some outcome is achieved in its
    target environment*, then things such as deep-space probes cannot truly be tested
    on Earth. At best, we are simulating the target environment during our testing.
    Giant-scale web applications can rarely be tested with realistic load profiles.
    Take any large web application, launch a hundred million users at it – all doing
    invalid things – and see how most applications hold up. It’s probably not as well
    as developer testing suggested.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 完全不测试是一个我们可以做出的选择，这可能不像听起来那么愚蠢。如果我们把测试定义为*验证在目标环境中实现了某些结果*，那么像深空探测器这样的东西在地球上是无法真正测试的。在测试过程中，我们最多只能模拟目标环境。大规模的Web应用程序很少能够用真实的负载配置文件进行测试。拿任何一个大型Web应用程序，向它投放一亿用户
    – 所有人都在做无效的事情 – 看看大多数应用程序的表现如何。这可能不如开发者测试所建议的好。
- en: 'There are areas of development where we might expect to see fewer automated
    tests:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些开发领域，我们可能会期望看到更少的自动化测试：
- en: '**Extract, Transform, and Load** (**ETL**) **scripts for** **data migrations**:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据迁移的ETL**（**提取、转换和加载**）**脚本**：'
- en: ETL scripts are often one-off affairs, written to solve a specific migration
    problem with some data. It’s not always worth writing automated tests for these,
    performing manual verification on a similar set of source data instead.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ETL脚本通常是单次事件，编写来解决一些特定数据迁移问题。为这些编写自动化测试并不总是值得，而是在类似的数据源集上执行手动验证。
- en: '**Front-end user** **interface work**:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端用户界面工作**：'
- en: Depending on the programming approach, it may be challenging to write unit tests
    for the frontend code. Whatever approach we take, assessing the visual look and
    feel cannot currently be automated. As a result, manual testing is often used
    against a candidate release of a user interface.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据编程方法的不同，编写前端代码的单元测试可能具有挑战性。无论我们采取什么方法，目前都无法自动化评估视觉外观和感觉。因此，通常会对用户界面的候选版本进行手动测试。
- en: '**Infrastructure-as-code scripts**:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施即代码脚本**：'
- en: Our applications need to be deployed somewhere for them to run. A recent approach
    to deployment is to use languages such as Terraform to configure servers using
    code. This is an area that’s not yet simple to automate tests for.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序需要部署到某个地方才能运行。最近的一种部署方法是使用像Terraform这样的语言通过代码来配置服务器。这是一个还不太容易自动化测试的领域。
- en: So what actually happens when we abandon test automation, possibly not even
    testing at all?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们放弃测试自动化，甚至可能完全不测试时，实际上会发生什么呢？
- en: What happens if we do not test during development?
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如果我们在开发过程中不进行测试会发生什么？
- en: 'We might think that not testing at all is an option, but in reality, testing
    will always happen at some point. We can illustrate this with a timeline of the
    possible points at which testing *can* occur:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会认为完全不测试是一个选择，但现实中，测试总会发生在某个时刻。我们可以用一个可能发生测试的时间线来展示这一点：
- en: '![Figure 12.5 – Testing timeline](img/Figure_12.5_B18384.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 测试时间线](img/Figure_12.5_B18384.jpg)'
- en: Figure 12.5 – Testing timeline
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 测试时间线
- en: Test-first approaches shift the testing to be as early as possible – an approach
    called **shift-left** – where defects can be corrected cheaply and easily. Thinking
    that we won’t test merely pushes testing all the way to the right – after users
    start using features live.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, *all code that users care about gets tested eventually*. Maybe developers
    don’t test it. Maybe testing will fall to another specialist testing team, who
    will write defect reports. Maybe defects will be found during the operation of
    the software. Most commonly of all, we end up outsourcing testing to the users
    themselves.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: 'Having users test our code for us is generally a bad idea. Users trust us to
    give them software that solves their problems. Whenever a defect in our code prevents
    that from happening, we lose that trust. A loss of trust damages the 3 Rs of a
    business: revenue, reputation, and retention. Users may well switch to another
    supplier, whose better-tested code actually solves the user’s problem.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: If there is any possibility at all to test our work before we ship it, we should
    take that opportunity. The sooner we build test-driven feedback loops into our
    work, the easier it will be to improve the quality of that work.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at *when* we test our software, let’s turn to *where* we test
    it. Given the overall design of a piece of software, where should we start testing?
    The next section reviews a test approach that starts from the inside of a design
    and works its way out.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Testing from the inside out
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to review our choice of starting point for our
    TDD activities. The first place to look at is inside our software system, starting
    with details.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: When starting to build software, we obviously need some place to start from.
    One place to start is with some of the details. Software is made up of small interconnecting
    components, each of which performs a portion of the whole task. Some components
    come from library code. Many components are custom-made to provide the functionality
    our application needs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: One place to start building, then, is on the *inside* of this software system.
    Starting with an overall user story, we can imagine a small component that is
    likely to be of use to us. We can begin our TDD efforts around this component
    and see where that leads us. This is a bottom-up approach to the design, composing
    the whole from smaller parts.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider a simplified version of our Wordz application structure, we
    can illustrate the inside-out approach as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Inside-out development](img/Figure_12.6_B18384.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Inside-out development
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The diagram shows the **Score** component highlighted, as that is where we will
    start development using an inside-out approach. The other software components
    are grayed-out. We are not designing those pieces yet. We would start with a test
    for some behavior we wanted the **Score** component to have. We would work our
    way outward from that starting point.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: This style of inside-out TDD is also known as **Classicist TDD** or **Chicago
    TDD**. It is the approach originally described by Kent Beck in his book *Test-Driven
    Development by Example*. The basic idea is to start anywhere to create any useful
    building block for our code. We then develop a progressively larger unit that
    incorporates the earlier building blocks.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The inside-out approach has a few advantages:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick start to development**: We test pure Java code first in this approach,
    using the familiar tools of JUnit and AssertJ. There is no setup for user interfaces,
    web service stubs, or databases. There is no setup of user interface testing tools.
    We just dive right in and code using Java.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Good for known designs**: As we gain experience, we recognize some problems
    as having known solutions. Perhaps we have written something similar before. Maybe
    we know a useful collection of design patterns that will work. In these cases,
    starting from the interior structure of our code makes sense.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Works well with hexagonal architecture**: Inside-out TDD starts work inside
    the inner hexagon, the domain model of our application. The adapter layer forms
    a natural boundary. An inside-out design is a good fit for this design approach.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Naturally, nothing is perfect and inside-out TDD is no exception. Some challenges
    include the following:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Possibility of waste**: We begin inside-out TDD with our best guess of some
    components that will be needed. Sometimes, it emerges later that either we don’t
    need these components, or we should refactor the features somewhere else. Our
    initial effort is in some sense wasted – although it will have helped us progress
    to this point.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risk of implementation lock-in**: Related to the previous point, sometimes
    we move on from an initial design having learned more about the problem we’re
    solving, but we don’t always recognize a sunk cost. There is always a temptation
    to keep using a component we wrote earlier even if it no longer fits as well,
    just because we invested that time and money into creating it.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside-out TDD is a useful approach and was first popularized by Kent Beck’s
    book. However, if we can start inside-out, what about turning that around? What
    if we started from the outside of the system and worked our way in? The next section
    reviews this alternative approach.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Testing from the outside in
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that inside-out TDD has some challenges as well as strengths, what difference
    does outside-in TDD make? This section reviews the alternative approach of starting
    from outside the system.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Outside-in TDD begins with the external users of the system. They may be human
    users or machines, consuming some API offered by our software. This approach to
    TDD begins by simulating some external input, such as the submission of a web
    form.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: The test will typically use some kind of test framework – such as Selenium or
    Cypress for web applications – that allows the test to call up a specific web
    view, and simulate typing text into fields, then clicking a submit button. We
    can then make this test pass in the normal way, only we will have written some
    code that directly deals with the input from a user this time. In our hexagonal
    architecture model, we will end up writing the user input adapter first.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'We can illustrate the outside-in approach as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – Outside-in view](img/Figure_12.7_B18384.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Outside-in view
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: We can see that a component called **Web API** is the focus of our attention
    here. We will write a test that sets up enough of our application to run a component
    that handles web requests. The test will form a web request, send it to our software,
    and then assert that the correct web response is sent. The test may also instrument
    the software itself to verify it takes the expected actions internally. We start
    testing from the outside, and as development progresses, we move inwards.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: This approach to TDD is described in the book, *Growing Object-Oriented Software,
    Guided by Tests*, by Steve Freeman and Nat Pryce. The technique is also known
    as the **London** or **Mockist** school of TDD. The reasons for that are the location
    where it was first popularized and its use of mock objects, respectively. To test
    drive the user input adapter as the first component we tackle, we need a test
    double in place of the rest of the software. Mocks and stubs are an inherent part
    of outside-in TDD.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'Outside-in TDD, predictably enough, has some strengths and weaknesses. Let’s
    take a look at the strengths first:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '**Less waste**: Outside-in TDD encourages a quite minimal approach to satisfying
    external behavior. The code produced tends to be highly customized to the application
    at hand. In contrast, inside-out TDD focuses on building a robust domain model,
    perhaps providing more functionality than will end up in use by users.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delivers user value quickly**: Because we start from a test that simulates
    a user request, the code we write will satisfy a user request. We can deliver
    value to users almost immediately.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Outside-in TDD also has some weaknesses, or at least limitations:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: '**Fewest abstractions**: On a related note, when writing the minimum code necessary
    to make a test pass, outside-in TDD may lead to application logic being present
    in the adapter layer. This can be refactored later but can lead to a less organized
    code base.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inverted test pyramid**: If all our TDD test efforts focus on the external
    responses, they are, in fact, end-to-end tests. This opposes the recommended pattern
    of the test pyramid, which prefers faster unit tests inside the code base. Having
    only slower, less repeatable end-to-end tests can slow development.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two traditional schools of TDD both offer certain advantages in terms of
    how they affect the software design we will produce. The next section looks at
    the impact of hexagonal architecture. By starting from the idea that we will use
    a hexagonal approach, we can combine the advantages of both schools of TDD. We
    end up defining a natural test boundary between the inside-out and outside-in
    approaches to TDD.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Defining test boundaries with hexagonal architecture
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The topic for this section is how using a hexagonal architecture impacts TDD.
    Knowing that we are using hexagonal architecture presents useful boundaries for
    the different kinds of tests in the test pyramid.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: In one sense, how we organize our code base does not affect our use of TDD.
    The internal structure of the code is simply an implementation detail, one of
    many possibilities that will make our tests pass. That being said, some ways of
    structuring our code are easier to work with than others. Using hexagonal architecture
    as a foundational structure does offer TDD some advantages. The reason why lies
    with the use of ports and adapters.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: We’ve learned from previous chapters that it is easier to write tests for code
    where we can control the environment in which the code runs. We’ve seen how the
    test pyramid gives a structure to the different kinds of tests we write. Using
    the ports and adapters approach provides clean boundaries for each kind of test
    in the code. Better yet, it provides us with an opportunity to bring even more
    tests to the unit test level.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review what kinds of tests best fit each layer of software written using
    hexagonal architecture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Inside-out works well with the domain model
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classic TDD uses an inside-out development approach, where we choose a certain
    software component to test-drive. This component may be a single function, a single
    class, or a small cluster of classes that collaborate with each other. We use
    TDD to test this component as a whole given the behaviors it offers to its consumers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'This kind of component resides in the domain model – the inner hexagon:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – Testing the domain logic](img/Figure_12.8_B18384.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Testing the domain logic
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: The key advantage is that these components are easy to write tests for and those
    tests run very quickly. Everything lives in computer memory and there are no external
    systems to contend with.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: A further advantage is that complex behaviors can be unit-tested here at a very
    fine granularity. An example would be testing all the state transitions within
    a finite state machine used to control a workflow.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage is that these fine-grained domain logic tests can get lost
    if a larger refactoring takes place. If the component under fine-grained tests
    gets removed during refactoring, its corresponding test will be lost – but the
    behavior will still exist somewhere else as a result of that refactoring. One
    thing refactoring tools cannot do is figure out what test code relates to the
    production code being refactored, and automatically refactor the test code to
    fit the new structure.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Outside-in works well with adapters
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mockist-style TDD approaches development from an outside-in perspective. This
    is a great match for our adapter layer in a hexagonal architecture. We can assume
    that the core application logic resides in the domain model and has been tested
    there with fast unit tests. This leaves adapters in the outer hexagon to be tested
    by integration tests.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: These integration tests only need to cover the behavior provided by the adapter.
    This should be very limited in scope. The adapter code maps from the formats used
    by the external system only to what is required by the domain model. It has no
    other function.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'This structure naturally follows the test pyramid guidelines. Fewer integration
    tests are required. Each integration test has only a small scope of behavior to
    test:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Testing adapters](img/Figure_12.9_B18384.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Testing adapters
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This style of testing verifies the adapter in isolation. It will require some
    end-to-end happy-path testing to show that the system as a whole has used the
    correct adapters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: User stories can be tested across the domain model
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One benefit of having a domain model containing all the application logic is
    that we can test the logic of complete user stories. We can replace the adapters
    with test doubles to simulate typical responses from the external systems. We
    can then use FIRST unit tests to exercise complete user stories:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Testing user stories](img/Figure_12.10_B18384.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Testing user stories
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The advantages are the speed and repeatability of FIRST unit tests. In other
    approaches to structuring our code, we might only be able to exercise a user story
    as an end-to-end test in a test environment, with all associated disadvantages.
    Having the ability to test user story logic at the unit level – across the whole
    domain model – gives us a high degree of confidence that our application will
    satisfy the users’ needs.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: To ensure this confidence, we need the integration tests of the adapter layer,
    plus some end-to-end tests across selected user stories, confirming the application
    is wired and configured correctly as a whole. These higher-level tests do not
    need to be as detailed as the user story tests performed around the domain model.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Having a good set of user story tests around the domain model also enables large-scale
    refactoring within the domain model. We can have the confidence to restructure
    the inner hexagon guided by these broadly scoped user story tests.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: This section has shown us how to relate the different kinds of tests in the
    test pyramid to the different layers in a hexagonal architecture.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has discussed the various stages at which we can write tests –
    before we write code, after we write code, or possibly even never. It has made
    a case for writing tests before code as providing the most value in terms of valid
    execution path coverage and developer ease. We went on to review how hexagonal
    architecture interacts with both TDD and the test pyramid, leading to an opportunity
    to bring user story testing into the realm of FIRST unit tests. This allows the
    fast and repeatable validation of the core logic driving our user stories.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter – and throughout the third part of the book – we will return
    to building our Wordz application. We will be making full use of all the techniques
    we’ve learned so far. We will begin inside-out with [*Chapter 13*](B18384_13.xhtml#_idTextAnchor275),
    *Driving the* *Domain Layer*.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is writing tests shortly after code just as good as writing test-first TDD?
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some research seems to suggest that, although it is very difficult to set up
    a controlled experiment with statistically significant results in this area. One
    factor we can consider concerns our own personal discipline. If we write tests
    later, are we sure we will cover everything necessary? I personally have concluded
    that I would not remember all I needed to cover and would need to make notes.
    Those notes are perhaps best captured in the form of test code, leading to a preference
    for test-first TDD.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: How does hexagonal architecture affect TDD?
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Hexagonal architecture provides a clean separation between a pure, inner core
    of domain logic and the outside world. This allows us to mix and match the two
    schools of TDD knowing that there is a firm boundary in the design up to which
    we can code. The inner domain model supports entire use cases being unit-tested,
    as well as any fine-grained unit tests for detailed behavior we feel are necessary.
    External adapters naturally suit integration tests, but these tests don’t have
    to cover much, as the logic relates to our domain lives in the inner domain model.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: What happens if we abandon testing completely?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We export the responsibility to the end user who will test it for us. We risk
    loss in revenue, reputation, and user retention. Sometimes, we cannot perfectly
    recreate the final environment in which the system will be used. In this case,
    making sure we have fully characterized and tested our system as closely as we
    can seems wise. We can at least minimize the known risks.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An explanation of the Cyclomatic Complexity metric: [https://en.wikipedia.org/wiki/Cyclomatic_complexity](https://en.wikipedia.org/wiki/Cyclomatic_complexity)'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous Delivery*, Jez Humble and Dave Farley, ISBN 978-0321601919'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Working Effectively with Legacy Code*, Michael Feathers, ISBN 978-0131177055'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test-Driven Development by Example*, Kent Beck, ISBN 978-0321146533'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Growing Object-Oriented Software, Guided by Tests*, Steve Freeman and Nat
    Pryce, ISBN 9780321503626'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://arxiv.org/pdf/1611.05994.pdf](https://arxiv.org/pdf/1611.05994.pdf)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Why Research on Test-Driven Development is Inconclusive?*, Ghafari, Gucci,
    Gross, and Felderer: [https://arxiv.org/pdf/2007.09863.pdf](https://arxiv.org/pdf/2007.09863.pdf)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Real-World TDD'
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Part 3* is where we apply all the techniques we have learned to complete our
    application. Wordz is a web service that plays a word guessing game. We build
    on the core domain logic we have already built, adding storage via a Postgres
    database accessed using SQL and providing web access by implementing an HTTP REST
    API.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We will use integration tests to test-drive our database and API implementations,
    making use of test frameworks that simplify these tasks. In the final chapter
    of the book, we will bring everything together to confidently run our test-driven
    Wordz application.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B18384_13.xhtml#_idTextAnchor275), *Driving the Domain Layer*'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B18384_14.xhtml#_idTextAnchor293), *Driving the Database Layer*'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B18384_15.xhtml#_idTextAnchor306), *Driving the Web Layer*'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
