- en: Chapter 4. Demystifying Build Scripts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 揭秘构建脚本
- en: In the first three chapters, we saw many interesting functionalities that Gradle
    can add to our builds merely by adding a few lines in the build file. However,
    this was just the tip of the iceberg. What we explored was mostly the tasks that
    were added by plugins shipped with Gradle. From our experiences, we know that
    project builds are never this simple. They will have customizations no matter
    how hard we try to avoid them. That's why the ability to add custom logic is extremely
    important for a build tool.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前三章中，我们看到了 Gradle 通过在构建文件中添加几行代码就能为我们的构建添加许多有趣的功能。然而，这只是冰山一角。我们所探索的多数是 Gradle
    随附的插件添加的任务。从我们的经验来看，我们知道项目构建永远不会这么简单。无论我们多么努力避免，它们都会有定制化。这就是为什么对于构建工具来说，添加自定义逻辑的能力极其重要。
- en: Also, the beauty of Gradle lies exactly there. It doesn't come into our way
    whenever we decide to either extend the existing functionality or deviate completely
    from the convention and want to do something unconventional. We are not required
    to write the XML soup or the bunch of Java code if we wish to add some logic to
    our build. We can create our own tasks or extend the existing tasks to do more.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Gradle 的美也恰恰在于此。当我们决定扩展现有功能或完全偏离传统，想要做一些非常规的事情时，Gradle 不会妨碍我们。如果我们想在构建中添加一些逻辑，我们不需要编写
    XML 汤或一大堆 Java 代码。我们可以创建自己的任务或扩展现有任务以做更多的事情。
- en: 'This flexibility comes with a very gentle learning curve in the form of learning
    Groovy DSL. In this chapter, we are going to understand the syntax of the Gradle
    build scripts and some of the key concepts of Gradle. We will cover the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这种灵活性伴随着学习 Groovy DSL 的非常温和的学习曲线。在本章中，我们将了解 Gradle 构建脚本的语法以及 Gradle 的一些关键概念。我们将涵盖以下主题：
- en: A Groovy primer that will help us understand the Gradle build script syntax
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一本 Groovy 入门指南，将帮助我们理解 Gradle 构建脚本的语法
- en: The two important objects available in our build, namely, the `project` object
    and the `task` object(s)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的构建中可用的两个重要对象，即 `project` 对象和 `task` 对象（们）
- en: Build phases and life cycle callbacks
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建阶段和生命周期回调
- en: Some details of the tasks (tasks execution and task dependencies)
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务的一些细节（任务执行和任务依赖）
- en: Groovy for Gradle build scripts
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Groovy 用于 Gradle 构建脚本
- en: To be proficient with Gradle and write effective build scripts, we need to understand
    some basics of Groovy, which is a fantastic dynamic language in itself. If we
    have any experience with dynamic languages such as Ruby or Python, in addition
    to Java, we will feel right at home with Groovy. If not, still knowing that most
    of the Java syntax is also the valid Groovy syntax should make us feel happy about
    Groovy, because we can start writing Groovy code and be productive from day one
    without having to learn anything.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要熟练使用 Gradle 并编写有效的构建脚本，我们需要了解一些 Groovy 的基础知识，Groovy 本身是一种出色的动态语言。如果我们对动态语言如
    Ruby 或 Python 有任何经验，再加上 Java，我们将对 Groovy 感到非常熟悉。如果没有，只要知道大多数 Java 语法也是有效的 Groovy
    语法，就足以让我们对 Groovy 感到高兴，因为我们可以从第一天开始编写 Groovy 代码并变得高效，而不需要学习任何新东西。
- en: To an unprepared eye, Gradle scripts may look a little difficult to comprehend
    at first. Gradle build scripts do not merely use the Groovy syntax, but also use
    a rich and expressive DSL that provides high-level abstractions to represent common
    build-related logics. Let's take a quick look at what makes Groovy a great choice
    for writing build files.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有准备的人来说，Gradle 脚本可能一开始看起来有点难以理解。Gradle 构建脚本不仅使用 Groovy 语法，还使用一个丰富且具有表达性的
    DSL，它提供了高级抽象来表示常见的构建相关逻辑。让我们快速看一下是什么让 Groovy 成为编写构建文件的一个很好的选择。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Using Groovy for writing build logics is not new. Gant and GMaven have already
    used Groovy to write the build logic in order to harness Groovy's syntactic terseness
    and expressiveness. GMavenPlus is a successor of GMaven. The tools they are built
    upon, namely Ant and Maven, limit both Gant and GMaven respectively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Groovy 编写构建逻辑并不新鲜。Gant 和 GMaven 已经使用 Groovy 来编写构建逻辑，以利用 Groovy 的简洁和表达性。GMavenPlus
    是 GMaven 的继任者。它们所基于的工具，即 Ant 和 Maven，分别限制了 Gant 和 GMaven。
- en: Instead of piggybacking on the existing tools to just add syntactic enhancements,
    Gradle is designed by leveraging the learning from the past tools.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与其依赖现有工具仅为了添加语法增强，Gradle 是通过利用从过去工具中学到的经验来设计的。
- en: Why Groovy?
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择 Groovy？
- en: Gradle's core is written mostly in Java (see the information below). Java is
    a great language, but it is not the best fit for writing scripts. Just imagine
    scripting in Java, we would perhaps be writing another project for defining the
    build of our main project because of the verbosity and ceremony of Java. XML,
    which was heavily used in the previous generation of build tools (Ant and Maven),
    is okay for the declarative part but is not great for writing logic.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 的核心主要用 Java 编写（见下文信息）。Java 是一种伟大的语言，但并不是编写脚本的最好选择。想象一下用 Java 编写脚本，我们可能需要为我们的主项目定义构建编写另一个项目，因为
    Java 的冗长和仪式感。在上一代构建工具（Ant 和 Maven）中广泛使用的 XML，对于声明性部分来说是可以的，但不是编写逻辑的最佳选择。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can view and download Gradle's source code from GitHub at [https://github.com/gradle/gradle](https://github.com/gradle/gradle).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从 GitHub 下载 Gradle 的源代码，网址为 [https://github.com/gradle/gradle](https://github.com/gradle/gradle)。
- en: Groovy is a dynamic avatar of Java. As mentioned earlier, most of the Java syntax
    is the valid Groovy syntax too. If we know Java, we can already write Groovy code.
    This is a big plus provided that the sheer number of people who can write Java
    today.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 是 Java 的动态化身。如前所述，大多数 Java 语法也是有效的 Groovy 语法。如果我们知道 Java，我们就可以编写 Groovy
    代码。考虑到现在能够编写 Java 的人数众多，这是一个很大的优势。
- en: Groovy's syntax is concise, expressive, and powerful. Groovy is a great mix
    of dynamic flavor, while still being able to use types. It is one of few languages
    that sport optional typing, that is, the flexibility to provide type information
    if we want to and leave type information aside when we don't want to. Groovy is
    an excellent language to build internal DSLs into because of the first class lambda
    support and metaprogramming capabilities. All of the above factors make it one
    of the most suitable candidates for writing build scripts.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 的语法简洁、表达性强且功能强大。Groovy 是动态风味和类型使用的完美结合。它是少数几种具有可选类型特性的语言之一，即如果我们想提供类型信息，就可以提供；如果我们不想提供，就可以不提供。由于
    Groovy 支持一等 lambda 和元编程功能，它是一种构建内部 DSL 的优秀语言。所有这些因素使它成为编写构建脚本的最佳候选人之一。
- en: Groovy primer
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Groovy 入门
- en: Although we can write Java style code in Groovy, if we invest some time in learning
    the dynamic nature of the language and some of the syntactical enhancements that
    Groovy offers, we will be able to write better Gradle build scripts and plugins.
    This is going to be fun if we don't already know Groovy.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在 Groovy 中编写 Java 风格的代码，但如果我们在学习语言动态特性和 Groovy 提供的一些语法增强上投入一些时间，我们将能够编写更好的
    Gradle 构建脚本和插件。如果我们还不了解 Groovy，这将是一件很有趣的事情。
- en: Let's learn just enough of Groovy so that we can understand the Gradle scripts
    properly. We will take a quick look at a few language features of Groovy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习足够的 Groovy，以便能够正确理解 Gradle 脚本。我们将快速浏览 Groovy 的几个语言特性。
- en: It is highly recommended to try and execute the code in the subsections that
    follow. Also, writing and trying out more code on our own to explore Groovy would
    help us strengthen our understanding of the language fundamentals. This guide
    is not exhaustive by any means and is included just to set the Groovy ball rolling.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议尝试执行以下子节中的代码。此外，自己编写和尝试更多代码以探索 Groovy 将有助于我们加强语言基础的理解。本指南绝非详尽无遗，只是为了让 Groovy
    的发展迈出第一步。
- en: Running Groovy code
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行 Groovy 代码
- en: 'The easiest and recommended way is to install the latest Groovy SDK locally.
    Groovy code snippets can be executed using any of the following options:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单且推荐的方式是在本地安装最新的 Groovy SDK。Groovy 代码片段可以使用以下任何一种选项执行：
- en: 'Save the snippets to the `.groovy` script and run from the command line using
    the following code:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码片段保存到 `.groovy` 脚本中，然后使用以下代码在命令行中运行：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can use the Groovy console GUI that comes packaged with the Groovy installation
    to edit and run the scripts
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用随 Groovy 安装包一起提供的 Groovy 控制台 GUI 来编辑和运行脚本。
- en: We can also use Groovy shell, which is an interactive shell for executing or
    evaluating Groovy statements and expressions
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以使用 Groovy shell，这是一个用于执行或评估 Groovy 语句和表达式的交互式 shell。
- en: 'If we don''t want to install Groovy locally, then:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望在本地上安装 Groovy，那么：
- en: We can run Groovy code online in a browser using Groovy console at [http://groovyconsole.appspot.com](http://groovyconsole.appspot.com)
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以使用 Groovy 控制台在浏览器中在线运行 Groovy 代码，网址为 [http://groovyconsole.appspot.com](http://groovyconsole.appspot.com)。
- en: We can also run Groovy code in the build script by creating tasks and putting
    code snippets in them (we can also put them outside any task and it will still
    run it in the configuration phase)
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还可以通过创建任务并将代码片段放入其中（我们也可以将它们放在任何任务之外，它仍然会在配置阶段运行它们）在构建脚本中运行 Groovy 代码。
- en: Variables
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'In a Groovy script, the `def` keyword can define a variable (depending on the
    context):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 脚本中，`def` 关键字可以定义一个变量（取决于上下文）：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: However, the type of `a` is decided at the runtime depending on what type of
    object it points to. Roughly speaking, a reference declared as `def` can refer
    to any `Object` or its subclasses.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`a` 的类型是在运行时根据它指向的对象类型来决定的。大致来说，声明为 `def` 的引用可以指向任何 `Object` 或其子类。
- en: 'Declaring a more specific type is equally valid and should be used whenever
    we want to have type safety:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一个更具体的类型同样有效，并且应该在我们想要有类型安全时使用：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can also use Java primitive data types, but keep in mind that they are not
    actually primitives in Groovy. They are still first-class objects and are actually
    Java wrapper classes for corresponding data type. Let''s confirm with an example,
    as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 Java 原始数据类型，但请注意，在 Groovy 中它们实际上不是原始类型。它们仍然是第一类对象，实际上是针对相应数据类型的 Java
    包装类。让我们通过以下示例来确认：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It prints the following output:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印以下输出：
- en: '[PRE4]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows that `c` is an object as we can call a method on it, and the type
    of `c` is `Integer`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明 `c` 是一个对象，因为我们可以在它上面调用方法，并且 `c` 的类型是 `Integer`。
- en: We recommend using specific types wherever possible as this adds to the readability
    and helps the Groovy compiler to detect errors early by catching invalid assignments.
    It also helps IDEs with code completion.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议尽可能使用特定类型，因为这增加了可读性，并帮助 Groovy 编译器通过捕获无效赋值来早期检测错误。这也帮助 IDE 进行代码补全。
- en: Strings
  id: totrans-45
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 字符串
- en: 'Unlike Java, the single quotes are (`''''`) string literals and not a `char`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Java 不同，单引号（`''`）是字符串字面量，而不是 `char`：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Of course, regular Java string literals (`""`) can also be used, but they are
    called GStrings in Groovy. They have an additional capability of string interpolation
    or inline expansion of variables or expressions:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，Java 的常规字符串字面量（`""`）也可以使用，但在 Groovy 中它们被称为 GStrings。它们具有字符串插值或变量或表达式的内联展开的附加功能：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This prints the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下输出：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Both `${var}` and `$var` are valid, but wrapping (`${}`) is more suitable and
    required for complex or longer expressions. For example:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '``${var}` 和 `$var` 都是有效的，但包装（`${}`）更适合，并且在复杂或较长的表达式中是必需的。例如：'
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It will print the following:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下内容：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'All of us would remember adding `+ "\\n"` at the end of every line in order
    to produce multiline strings in Java. Gone are those days, as Groovy supports
    multiline string literals. The multiline literal starts off with three single
    or double quotes (the same string versus the GString functionality) and ends with
    three single or double quotes:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所有人都记得在 Java 中，为了产生多行字符串，需要在每一行的末尾添加 `+ "\\n"`。那些日子已经过去了，因为 Groovy 支持多行字符串字面量。多行字面量以三个单引号或双引号开始（与
    GString 功能相同），并以三个单引号或双引号结束：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It will print the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The forward slash on line number 1 is optional and is used to exclude the first
    new line. If we do not put the forward slash, we would have an additional new
    line in the beginning of the output.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 第 1 行上的正斜杠是可选的，用于排除第一个新行。如果我们不放置正斜杠，输出开头将会有一个额外的空行。
- en: Also, look at the `stripMargin` and `stripIndent` methods for the special handling
    of leading whitespaces.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，查看 `stripMargin` 和 `stripIndent` 方法以了解对前导空白的特殊处理。
- en: 'If our literal contains a lot of escape characters (for example, regex), then
    we are better off using a "slashy" string literal, which starts and ends with
    a single forward slash (`/`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的字面量包含大量的转义字符（例如，正则表达式），那么我们最好使用“斜杠”字符串字面量，它以单个正斜杠（`/`）开始和结束：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It will prints the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下内容：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the above example, if we had to use a regular string, then we would have
    to escape the backslash before the character class `d`. It would have looked as
    follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，如果我们必须使用普通字符串，那么我们不得不在字符类 `d` 前面的反斜杠进行转义。它看起来如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Regular expressions
  id: totrans-68
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正则表达式
- en: 'Groovy supports a pattern operator (`~`), which when applied to a string, gives
    a pattern object:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 支持一个模式操作符（`~`），当应用于字符串时，会给出一个模式对象：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It prints the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印以下内容：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We can also use the find operator to directly match a string to a pattern:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用查找操作符直接将字符串与模式匹配：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'It will print the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下内容：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Closures
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 闭包
- en: '**Closure** in Groovy is a block of code that can be assigned to a reference
    or passed around just like any other variable. The concept is known as **lambda**
    in many other languages, including Java 8 or function pointers.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy中的**闭包**是一段代码块，它可以被赋值给引用或像任何其他变量一样传递。这个概念在许多其他语言中被称为**lambda**，包括Java
    8或函数指针。
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Lambdas have been supported since Java 8, but the syntax is a bit different
    than that of Groovy's closures. You don't need to be on Java 8 to use closure
    in Groovy.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda自Java 8以来一直被支持，但其语法与Groovy闭包的语法略有不同。你不需要使用Java 8就可以在Groovy中使用闭包。
- en: If we have no exposure to any of the above, then some detailed reading will
    be required to understand the concept well because it lays the foundation for
    many other advanced topics going forward. Closure is a huge topic in itself and
    an in-depth discussion is beyond the scope of this book.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有接触过上述任何一种，那么为了很好地理解这个概念，就需要进行一些详细的阅读，因为它为后续许多高级主题奠定了基础。闭包本身就是一个很大的主题，深入的讨论超出了本书的范围。
- en: 'Closure is almost like a regular method or function, but it can also be assigned
    to a variable. Also, as it can be assigned to a variable, it must be an object
    as well; hence, it will have methods on itself:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包几乎就像一个常规方法或函数，但它也可以被赋值给变量。由于它可以被赋值给变量，它也必须是一个对象；因此，它将有自己的方法：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the code block is being assigned to a variable called `cl1`. Now the
    code block can be executed using the call method in the future or the `cl1` variable
    can be passed around and executed later:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，代码块被赋值给一个名为`cl1`的变量。现在，代码块可以在未来的调用方法中执行，或者`cl1`变量可以在以后传递并执行：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'No wonder it prints the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，它打印了以下内容：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As closures are like methods, they can also accept parameters:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于闭包就像方法一样，它们也可以接受参数：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It prints the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印了以下内容：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Just like methods, they can also return values. The last expression of closure
    is automatically returned if no explicit `return` statement is declared.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像方法一样，它们也可以返回值。如果没有显式声明`return`语句，闭包的最后一个表达式将自动返回。
- en: 'Closures start shining when we have methods that accept closures. For example,
    the `times` method is available on integer, which takes in a closure and executes
    it as many number times as the value of the integer itself; with every call, it
    passes the current value as if we were looping up to the value from `0`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有接受闭包的方法时，闭包开始发光。例如，`times`方法在整数上可用，它接受一个闭包并执行它，次数与整数的值相同；每次调用时，它将当前值作为如果我们是从`0`循环到该值一样传递：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'It prints the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印了以下内容：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also inline the block and pass it directly to a method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将代码块内联并直接传递给方法：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It prints the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印了以下内容：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There is a special variable called `it`, which is available in the blocks scope
    if the closure doesn't define its parameter. In the preceding example, we accessed
    the number being passed to the block using `it` and multiplied it by itself to
    obtain its square.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个特殊的变量叫做`it`，如果闭包没有定义其参数，它将在代码块的作用域内可用。在上面的例子中，我们使用`it`访问传递给代码块的数量，并将其自身相乘以获得其平方。
- en: Closures are extremely useful in situations such as callback handling, whereas
    in Java 7 and lower, we would have to use anonymous interface implementation to
    achieve the same result.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包在诸如回调处理等情况下非常有用，而在Java 7及以下版本中，我们不得不使用匿名接口实现来达到相同的结果。
- en: Data structures
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据结构
- en: Groovy supports literal declaration of the often-used data structures, which
    makes the code a lot more terse without sacrificing readability.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy支持常用数据结构的字面量声明，这使得代码更加简洁，同时又不牺牲可读性。
- en: List
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 列表
- en: 'Groovy backs on the thoroughly tested Java Collection API and uses the same
    classes under the hood, but with some extra methods and syntactic sugar:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy依赖于经过充分测试的Java Collection API，并在底层使用相同的类，但增加了一些额外的方法和语法糖：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'It prints the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印了以下内容：
- en: '[PRE29]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Groovy, `[]` is actually a Java's `List` instance and not an array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在Groovy中，`[]` 实际上是Java的 `List` 实例，而不是数组。
- en: 'Let''s create another list with some initial content:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个带有一些初始内容的列表：
- en: '[PRE30]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Thanks to operator overloading, we can use many of the operators intuitively
    on the list. For example, using `anotherList[1]` will give us `b`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了运算符重载，我们可以在列表上直观地使用许多运算符。例如，使用`anotherList[1]`将给我们`b`。
- en: 'The following are some more examples of handy operators. This adds two lists
    and assigns the result to the list variable:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些更多有用的运算符的例子。这个例子将两个列表相加，并将结果赋值给列表变量：
- en: '[PRE31]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This appends `60` to the list:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将 `60` 添加到列表中：
- en: '[PRE32]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following two examples simply subtracts a list from another list:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 以下两个示例简单地从一个列表中减去另一个列表：
- en: '[PRE33]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Iterating over a list is equally simple and intuitive:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 遍历列表同样简单直观：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It will print the following
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 它将打印以下内容
- en: '[PRE35]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The closure passed to `each` is executed for each element of the list, with
    the element as a parameter to closure. So, the preceding code iterates over the
    list and prints the value of each element. Notice the usage of `it`, which is
    a handle to the current element of the list.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `each` 的闭包为列表中的每个元素执行，元素作为闭包的参数。因此，前面的代码遍历列表并打印每个元素的值。注意 `it` 的使用，它是列表当前元素的句柄。
- en: Set
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 集合
- en: 'Defining a set is similar to that of a list, but in addition, we have to use
    `as Set`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个集合与列表类似，但除此之外，我们必须使用 `as Set`：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This will print the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As the implementation class selected is `LinkedHashSet`, `aSet` will maintain
    the insertion order.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 由于选择的实现类是 `LinkedHashSet`，`aSet` 将保持插入顺序。
- en: 'Alternatively, declare the type of variable to get the correct implementation:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，声明变量的类型以获取正确的实现：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This prints the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Adding elements to a set is just like a list using an indirection operator.
    Other set interface methods are also available:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 向集合中添加元素就像使用间接操作符的列表一样。其他集合接口方法也是可用的：
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This prints the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印以下内容：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We don't see the entry `4` twice as the collection is a set implementation,
    which by definition eliminates duplicates.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于集合是集合实现，它按定义消除了重复，所以我们看不到条目 `4` 两次。
- en: Map
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 映射
- en: 'Map is one of the most important data structures for any dynamic language.
    Hence, it gets a deserved place in Groovy''s syntax. Map can be declared using
    the map literal `[:]`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 映射是任何动态语言最重要的数据结构之一。因此，它在 Groovy 的语法中得到了应有的位置。映射可以使用映射字面量 `[:]` 来声明：
- en: '[PRE42]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The implementation chosen by default is `java.util.LinkedHashMap`, which preserves
    the insertion order:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 默认选择的实现是 `java.util.LinkedHashMap`，它保留了插入顺序：
- en: '[PRE43]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Note that the keys are not string literals, but they get automatically converted
    to a string:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，键不是字符串字面量，但它们会自动转换为字符串：
- en: '[PRE44]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We can access the values by using both the subscript and dot operator, in addition
    to the plain old `get()` method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过索引操作符和点操作符以及普通的 `get()` 方法来访问值。
- en: 'We can put and update data in map using the subscript and dot operator and,
    of course, the good old `put()`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用索引操作符、点操作符以及当然的 `put()` 方法在映射中添加和更新数据：
- en: '[PRE45]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Methods
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'The following is more of a Java-like method, which is of course a valid Groovy
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 以下更像是 Java 类型的方法，当然这也是一个有效的 Groovy 方法：
- en: '[PRE46]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The preceding method can be succinctly rewritten as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法可以简洁地重写如下：
- en: '[PRE47]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Instead of specifying the return type, we just declared `def`, which effectively
    means the method can return any `Object` or subclass reference. Then, we omitted
    the type of the formal parameter, as declaring `def` is optional for formal parameters
    to a method. On line number 2, we omitted the `return` statement as the evaluation
    of the last expression is automatically returned by a method. We also omitted
    the semicolon as it's optional.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有指定返回类型，只是声明了 `def`，这意味着方法可以返回任何 `Object` 或子类引用。然后，我们省略了形式参数的类型，因为对于方法的形式参数来说，声明
    `def` 是可选的。在第 2 行，我们省略了 `return` 语句，因为方法的最后一个表达式的评估会自动返回。我们还省略了分号，因为它也是可选的。
- en: Both the examples are valid Groovy method declarations. However, readers are
    advised to choose types wisely as they provide type safety and act as a living
    documentation for methods. If we don't declare types of parameters, as in the
    preceding method, the sum (1,"2") will also become a valid method call, and worse,
    it returns an unexpected result without any exceptions.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '这两个示例都是有效的 Groovy 方法声明。然而，建议读者明智地选择类型，因为它们提供了类型安全，并作为方法的活文档。如果我们没有声明参数的类型，就像前面的方法一样，求和
    (1,"2") 也将成为一个有效的方法调用，而且更糟糕的是，它返回了没有异常的意外结果。 '
- en: Calling methods
  id: totrans-158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 调用方法
- en: A method call in Groovy can omit the parenthesis is many cases. Both of the
    following cases are valid method calls.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Groovy 中，在许多情况下可以省略方法调用中的括号。以下两种情况都是有效的方法调用。
- en: '[PRE48]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Default values of parameters
  id: totrans-161
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 参数的默认值
- en: 'Many a time, we want to make a parameter optional by providing a default value
    so that if the caller does not provide the value, the default value will be used.
    Take a look at the following example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多次，我们想要通过提供一个默认值来使参数可选，这样如果调用者没有提供值，则使用默认值。看看以下示例：
- en: '[PRE49]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'It prints the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印以下内容：
- en: '[PRE50]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: If we provide the value of the `by` parameter that will be used, the default
    value `2` will be assumed for the parameter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们提供了将要使用的 `by` 参数的值，则默认值 `2` 将被假定为该参数。
- en: Methods with map parameters/named parameters
  id: totrans-167
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有 map 参数/命名参数的方法
- en: 'Groovy does not support named parameters such as Python, but Map provides a
    very close approximation to the same functionality:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 不支持像 Python 那样的命名参数，但 Map 提供了对相同功能的非常接近的近似：
- en: '[PRE51]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the preceding code, we expect the map to contain keys `a` and `b`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们期望 map 包含键 `a` 和 `b`。
- en: Note
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On line number 2 and 3, notice the elvis operator `?:`, which returns the left
    hand side value, if value exists and is *truthy*; otherwise returns the right
    hand side (default) value. It is basically short hand for the following code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 2 行和第 3 行，注意 elvis 运算符 `?:`，如果存在值且是 *truthy*，则返回左侧值；否则返回右侧（默认）值。它基本上是以下代码的简写：
- en: '[PRE52]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, this method can be called as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个方法可以这样调用：
- en: '[PRE53]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can omit the square brackets (`[]`) because maps have special support in
    the method call:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以省略方括号 (`[]`)，因为 maps 在方法调用中有特殊支持：
- en: '[PRE54]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, it clearly looks like the named parameters. The order of parameters is
    not important and all the parameters need not be passed. Also, the parenthesis
    wrapping is optional, just like any method call:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，它看起来明显像是命名参数。参数的顺序并不重要，并且不需要传递所有参数。此外，括号包裹是可选的，就像任何方法调用一样：
- en: '[PRE55]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Methods with varags
  id: totrans-180
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有 varags 的方法
- en: 'Like in Java, varags are denoted by `...`, but providing the type is optional:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 Java 一样，varags 用 `...` 表示，但提供类型是可选的：
- en: '[PRE56]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the preceding examples, numbers are arrays, which have the `collect` method
    that accepts a closure and transforms each element of the collection in order
    to produce a new collection. In this case, we transform numbers in the collection
    of squares. Finally, we use the in-built sum method to sum all the squares.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，数字是数组，它具有接受闭包并按顺序转换集合中每个元素的 `collect` 方法，以产生一个新的集合。在这种情况下，我们转换集合中的平方数。最后，我们使用内置的
    sum 方法来求所有平方的和。
- en: Methods with closure params
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带闭包参数的方法
- en: 'Closures are important and, hence, Groovy has a special syntax for closures
    if the closure is the last parameter of a method signature:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包很重要，因此 Groovy 如果闭包是方法签名中的最后一个参数，则具有特殊的闭包语法：
- en: '[PRE57]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, this method can be called as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这个方法可以这样调用：
- en: '[PRE58]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Out of these, the third one is the special syntactical support in which the
    parenthesis just wraps the other parameters, while the closure is written outside
    the parenthesis, as if it were a method body.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些中，第三个是特殊的语法支持，其中括号仅包裹其他参数，而闭包则写在括号外，就像是一个方法体。
- en: Classes
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类
- en: Classes in Groovy are declared just like Java classes, but with a lot lesser
    ceremony. Classes are public by default. They can inherit from other classes using
    `extends` or implementing interfaces using `implmenets`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 中的类声明与 Java 类类似，但仪式较少。类默认是公共的。它们可以使用 `extends` 从其他类继承，或者使用 `implmenets`
    实现接口。
- en: 'The following is the definition of a very simple class, `Person`, having two
    properties, `name` and `age`:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个非常简单的类 `Person` 的定义，它有两个属性，`name` 和 `age`：
- en: '[PRE59]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Instead of using the `def` for properties, we can use more specific types.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更具体的类型来代替 `def` 用于属性。
- en: Constructors
  id: totrans-195
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'In addition to the default constructor, classes in Groovy get a special constructor,
    which takes the map of properties of the class. Here is how we use it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 除了默认构造函数之外，Groovy 中的类还有一个特殊的构造函数，它接受类的属性映射。以下是它的用法：
- en: '[PRE60]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In the preceding code, we have created the `person` object using the special
    constructor. The parameters are key-value pairs where the keys are the name of
    the properties in the class. The values provided for the keys will be set for
    the corresponding properties.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用特殊构造函数创建了 `person` 对象。参数是键值对，其中键是类中属性的名称。为键提供的值将设置对应的属性。
- en: Properties
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 属性
- en: Groovy has language-level support for properties. In the preceding class, `name`
    and `age`, unlike Java, are not just fields, but are also properties of the class
    with their getters and setters in place. Fields are private by default and their
    public accessors and mutators (getters and setters) are generated automatically.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Groovy 在语言级别上支持属性。在前面的类中，`name` 和 `age`，与 Java 不同，不仅仅是字段，而且还是具有其 getter 和 setter
    的类的属性。字段默认是私有的，它们的公共访问器和修改器（getter 和 setter）是自动生成的。
- en: 'We can call the `getAge()`/`setAge()` and `getName()`/`setName()` methods on
    the `person` object that we created above. However, there is an even more succinct
    way to do so. We can access properties just as if they were public fields, but
    behind the scenes, Groovy routes it through the getters and setters. Let''s try:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在上面创建的`person`对象上调用`getAge()`/`setAge()`和`getName()`/`setName()`方法。然而，有一个更简洁的方法可以做到这一点。我们可以像访问公共字段一样访问属性，但幕后Groovy会通过getter和setter进行路由。让我们试试：
- en: '[PRE61]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'It prints the following:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 它打印以下内容：
- en: '[PRE62]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding code, on line number 1, `person.age` is actually a call to
    `person.getAge()` and, hence, it returns the age of the person. Then, we updated
    the age using `person.age` with an assignment operator and value on the right-hand
    side. We did not update the field, but it internally passes through the setter
    `setAge()`. This is only possible because groovy offers syntactical support for
    properties.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，在第1行，`person.age`实际上是调用`person.getAge()`，因此它返回了人的年龄。然后，我们使用`person.age`和右侧的赋值运算符及值更新了年龄。我们没有更新字段，但它内部通过setter
    `setAge()`进行传递。这之所以可能，是因为Groovy提供了对属性的语法支持。
- en: 'We can provide our own getters and/or setter for the desired fields, which
    will take precedence over the generated one, but it is only necessary if we have
    some logic to write in those. For example, if we want to have one positive value
    of age to be set, then we can provide our own `setAge()` implementation, and this
    will be used whenever the property is updated:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为所需的字段提供自己的getter和/或setter，这将优先于生成的那个，但只有在我们需要在这些地方编写一些逻辑时才是必要的。例如，如果我们想设置一个年龄的正值，那么我们可以提供自己的`setAge()`实现，并且每次更新属性时都会使用它：
- en: '[PRE63]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The support for properties results in the significant reduction of the boilerplate
    code from class definitions and enhances readability.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 属性的支持导致类定义中的样板代码显著减少，并增强了可读性。
- en: Tip
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Properties are first-class citizens in Groovy. Going forward, whenever we refer
    to property, do not get confused between properties and fields.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 属性在Groovy中是一等公民。从现在开始，每次我们提到属性时，不要在属性和字段之间混淆。
- en: Instance methods
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 实例方法
- en: 'We can add an instance and static methods to classes just like we do in Java:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向类中添加实例方法和静态方法，就像我们在Java中做的那样：
- en: '[PRE64]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The methods section, as we discussed above, did not use classes, but applied
    as-is for the methods inside classes.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们上面所讨论的，方法部分没有使用类，而是直接应用于类内部的方法。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Scripts are classes**'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**脚本即类**'
- en: In fact, the methods that we discussed above were inside a class and they were
    not free-floating functions. As scripts get translated to classes transparently,
    it feels as if we were using functions.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们上面讨论的方法都在类内部，它们不是自由浮动的函数。由于脚本被透明地转换为类，所以我们感觉就像在使用函数。
- en: I am sure you have enjoyed Groovy so far. There is a lot more to cover in Groovy,
    but we have to switch back our focus to Gradle. However, I hope to have generated
    enough curiosity about Groovy so that you can appreciate it as a language and
    explore more of it on your own. There are a few good resources included in the
    references section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我相信到目前为止你已经享受了Groovy。Groovy还有很多内容可以介绍，但我们不得不将焦点转回到Gradle上。然而，我希望我已经激发了你足够的对Groovy的好奇心，这样你就可以欣赏它作为一种语言，并自己探索更多。参考资料部分包含了一些很好的资源。
- en: Another look at applying plugins
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 再次看看应用插件
- en: 'Now that we have learned about basic Groovy, let''s put it to use in the context
    of the Gradle build script. In earlier chapters, we have already seen the syntax
    of applying a plugin. It looked something as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了基本的Groovy，让我们将其应用于Gradle构建脚本的环境中。在早期章节中，我们已经看到了应用插件的语法。它看起来如下所示：
- en: '[PRE66]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If we look carefully, `apply` is a method call. We can wrap the parameters
    in the parenthesis:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察，`apply`是一个方法调用。我们可以将参数括在括号中：
- en: '[PRE67]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'A method that takes in a map can pass key values just like named arguments.
    However, for a more clear representation of Map, we can wrap the parameters in
    `[]`:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接收映射的方法可以像命名参数一样传递键值。然而，为了更清晰地表示映射，我们可以将参数用`[]`括起来：
- en: '[PRE68]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Finally, the `apply` method is implicitly applied on the `project` object (we
    will soon see this in the upcoming sections in this chapter). So, we can also
    call it on the `project` object''s reference:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`apply`方法在`project`对象上隐式应用（我们将在本章接下来的部分中看到这一点）。因此，我们也可以在`project`对象的引用上调用它：
- en: '[PRE69]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: So, from the preceding example, we can see that the statement that applies a
    plugin to project is merely a syntactic sugar to what is a method call on the
    `project` object. We are just writing Groovy code using Gradle API. Also, once
    we realize that, our perspective towards understanding the build script syntax
    changes for good.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，从前面的例子中，我们可以看到将插件应用于项目的声明仅仅是一个语法糖，它实际上是对 `project` 对象的方法调用。我们只是在使用 Gradle
    API 编写 Groovy 代码。一旦我们意识到这一点，我们对理解构建脚本语法的看法就会发生根本性的改变。
- en: Gradle – an object-oriented build tool
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle – 一个面向对象的构建工具
- en: 'If we were to think of a build system in an object-oriented way, the following
    classes will immediately come to our minds:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们以面向对象的方式思考构建系统，以下类会立刻浮现在我们的脑海中：
- en: A `project` that represents a system that is being built
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代表正在构建的系统的 `project`
- en: A `task` that encapsulates pieces of build logics that need to be performed
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个封装需要执行的部分构建逻辑的 `task`
- en: Well, we are lucky. As we might expect, Gradle creates objects of both `project`
    and `task` types. These objects are accessible in our build script for us to customize.
    Of course, the underlying implementation is non-trivial and the API is very sophisticated.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们很幸运。正如我们所预期的那样，Gradle 创建了 `project` 和 `task` 类型的对象。这些对象在我们的构建脚本中是可访问的，以便我们进行自定义。当然，其底层实现并不简单，API
    非常复杂。
- en: A `project` object is a central piece of API that is exposed to and configured
    via the build scripts. A `project` object is available in the script such that
    the methods without object reference are intelligently invoked on the `project`
    object. We have just seen an example of this in the last section. Most of the
    build script syntax can be understood by just reading the project API.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`project` 对象是暴露给构建脚本并配置的API的核心部分。在脚本中，`project` 对象是可用的，这样就可以在 `project` 对象上智能地调用没有对象引用的方法。我们已经在上一节中看到了一个例子。大多数构建脚本语法都可以通过阅读项目API来理解。'
- en: The `task` objects are created for each task declared directly in the build
    file and also for plugins. We have already created a very simple task in [Chapter
    1](part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0 "Chapter 1. Running
    Your First Gradle Task"), *Running Your First Gradle Task* and used tasks coming
    from plugins in [Chapter 2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 2. Building Java Projects"), *Building Java Projects*, and [Chapter 3](part0024_split_000.html#MSDG2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 3. Building a Web Application"), *Building a Web Application*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`task` 对象是为在构建文件中直接声明的每个任务以及插件而创建的。我们已经在 [第1章](part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0
    "第1章。运行您的第一个Gradle任务") 中创建了一个非常简单的任务，即 *运行您的第一个Gradle任务*，并在 [第2章](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0
    "第2章。构建Java项目") 和 [第3章](part0024_split_000.html#MSDG2-e78ecbb3ac0544f19c59f96d594821c0
    "第3章。构建Web应用程序") 中使用了来自插件的任务，即 *构建Java项目* 和 *构建Web应用程序*。'
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we have seen, some tasks are already available in our build without us having
    to add a single line to our build file (such as the `help` task and the `tasks`
    task, and so on). Even for these tasks, we would have task objects.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，一些任务在我们的构建文件中已经可用，我们无需在构建文件中添加任何一行代码（例如 `help` 任务和 `tasks` 任务等）。即使是这些任务，我们也会有任务对象。
- en: We will soon see how and when these objects are created.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到这些对象是如何以及何时被创建的。
- en: Build phases
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建阶段
- en: 'A Gradle build follows a very simple life cycle on every invocation. The build
    passes through three stages: initialization, configuration, and execution. When
    a `gradle` command is invoked, not all the code written in our build file executes
    sequentially from top to bottom. Only the blocks of code that are relevant to
    the current phase of the build are executed. Also, the build phase''s order determines
    when the block of code will execute. An example is the task configuration versus
    task execution. Understanding of these phases is important to correctly configure
    our build.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用时，Gradle 构建都会遵循一个非常简单的生命周期。构建过程会经过三个阶段：初始化、配置和执行。当调用 `gradle` 命令时，并非我们构建文件中编写的所有代码都会按顺序从上到下依次执行。只有与当前构建阶段相关的代码块会被执行。此外，构建阶段的顺序决定了代码块何时执行。例如，任务配置与任务执行。理解这些阶段对于正确配置我们的构建非常重要。
- en: Initialization
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: Gradle first figures out whether the current project has child projects or if
    it is the only project in the build. For multiprojects build, Gradle figures out
    which projects (or sub-module, as many prefer to call them) have to be included
    in the build. We will see multiproject builds in the next chapter. Gradle then
    creates a `Project` instance for the root project and for each of the child projects
    of a project. For single module projects that we have seen so far, there is not
    much to configure in this phase.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle首先确定当前项目是否有子项目，或者它是否是构建中的唯一项目。对于多项目构建，Gradle确定哪些项目（或子模块，许多人更喜欢这样称呼它们）需要包含在构建中。我们将在下一章中看到多项目构建。然后，Gradle为根项目和每个项目的子项目创建一个`Project`实例。对于到目前为止我们所看到的单模块项目，在这个阶段没有太多可以配置的。
- en: Configuration
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: In this phase, the build scripts of participating projects are evaluated against
    the corresponding project object that was created during the initialization phase.
    In the case of multimodule projects, evaluation happens in breadth-wise fashion,
    that is, all the sibling projects will be evaluated and configured before child
    projects. However, this behavior is configurable.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，参与项目的构建脚本将与初始化阶段创建的相应项目对象进行评估。在多模块项目中，评估是按广度进行的，也就是说，在评估和配置子项目之前，所有兄弟项目都将被评估和配置。然而，这种行为是可以配置的。
- en: 'Note that executing the scripts does not mean that the tasks are also executed.
    To quickly verify this, we can just put a `println` statement in the `build.gradle`
    file and also create a task that prints a message:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，执行脚本并不意味着任务也被执行。为了快速验证这一点，我们只需在`build.gradle`文件中添加一个`println`语句，并创建一个打印消息的任务：
- en: '[PRE70]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'If we execute the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行以下代码：
- en: '[PRE71]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We would see the following output:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到以下输出：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In fact, choose any in-built task as well, such as `help`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，选择任何内置任务也可以，例如`help`：
- en: '[PRE73]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We would still see our `build script is evaluated` message before any task is
    executed. Why is that?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何任务执行之前，我们仍然会看到我们的`build script is evaluated`消息。为什么是这样？
- en: When a script is evaluated, all the statements in the script are executed sequentially.
    That's why the `println` statement at the root level gets executed. A task action,
    if you notice, is actually a closure; hence, it is only attached to a task during
    the statement execution. However, the closure itself is not executed yet. The
    statements inside the action closure executes only if the task is executed, which
    happens only in the next phase.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个脚本被评估时，脚本中的所有语句都会按顺序执行。这就是为什么根级别的`println`语句会被执行。如果你注意到，任务动作实际上是一个闭包；因此，它仅在语句执行期间附加到任务上。然而，闭包本身尚未执行。动作闭包内的语句只有在任务执行时才会执行，这发生在下一个阶段。
- en: Tasks are only configured during this stage. No matter what tasks are going
    to be called, all tasks will be configured. Gradle prepares a **Directed Acyclic
    Graph** (**DAG**) representation of the tasks to determine the task dependency
    and execution order.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 任务仅在此时进行配置。无论将要调用哪些任务，所有任务都将被配置。Gradle为任务准备了一个**有向无环图**（**DAG**）表示，以确定任务的依赖关系和执行顺序。
- en: Execution
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行
- en: In this phase, Gradle figures out which tasks need to be run based on the parameters
    such as task names passed as command line arguments and the current directory.
    This is where tasks' actions will be performed. Hence, here, the action closures
    will actually execute if the task is to run.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，Gradle根据诸如通过命令行参数传递的任务名称和当前目录等参数确定需要运行的任务。这就是任务动作将被执行的地方。因此，在这里，如果任务要运行，动作闭包实际上会执行。
- en: Note
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'On subsequent invocations, Gradle intelligently determines which tasks need
    to actually run and which can be skipped. For example, for a compile task, there
    is no point in compiling again if there is no change in the source file after
    the last build. In such a case, the execution may be skipped. We can see such
    tasks in the output tagged as `UP-TO-DATE`:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在后续调用中，Gradle智能地确定哪些任务实际上需要运行，哪些可以跳过。例如，对于编译任务，如果源文件在最后一次构建后没有变化，再次编译就没有意义了。在这种情况下，执行可能会被跳过。我们可以在输出中看到这样的任务，标记为`UP-TO-DATE`：
- en: '[PRE74]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In the preceding output, as there was no change from the previous build, Gradle
    actually skipped every task. However, this will not happen for a custom task that
    we write, unless we tell Gradle the logic for figuring out whether the task needs
    execution or not.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，由于与前一次构建没有变化，Gradle实际上跳过了每个任务。然而，这不会发生在我们编写的自定义任务上，除非我们告诉Gradle确定任务是否需要执行的逻辑。
- en: Life cycle callbacks
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生命周期回调
- en: Gradle provides various hooks for executing code at various points during life
    cycle events. We can implement callback interfaces or provide callback closure
    to DSL in the build script. For example, we can listen for events such as the
    before and after project evaluation using the `beforeEvaluate` and `afterEvaluate`
    methods on `project`. We are not going to look at them individually, but the `Project`
    and `Gradle` (the interface name is not to be confused with the tool's name itself)
    APIs and the DSL documentation is the right place to check out the available callbacks,
    if we feel the need to implement life cycle callbacks.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle在生命周期事件的不同阶段提供了各种钩子来执行代码。我们可以在构建脚本中实现回调接口或提供回调闭包。例如，我们可以使用`project`上的`beforeEvaluate`和`afterEvaluate`方法来监听项目评估前后的事件。我们不会逐一查看它们，但`Project`和`Gradle`（接口名称不要与工具本身的名称混淆）API以及DSL文档是检查可用回调的正确地方，如果我们觉得需要实现生命周期回调的话。
- en: Gradle Project API
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gradle项目API
- en: As discussed earlier, Gradle creates a `project` object for each `build.gradle`
    for us during the initialization phase. This object is available in our build
    scripts using the `project` reference. Being a central piece of API, there are
    numerous methods and properties available on this object.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Gradle在初始化阶段为我们为每个`build.gradle`创建了一个`project`对象。这个对象可以通过`project`引用在我们的构建脚本中使用。作为一个API的核心部分，这个对象上有许多方法和属性。
- en: Project methods
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 项目方法
- en: We have been using the project API even without realizing that we are calling
    methods on the `project` object. Based on a few governing rules, all the top-level
    method calls in the build scripts are called on a project object if no explicit
    reference is provided.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至没有意识到，我们已经在调用`project`对象的`methods`了，尽管我们一直在使用项目API。根据一些管理规则，如果未提供明确的引用，构建脚本中的所有顶级方法调用都是在项目对象上进行的。
- en: 'Let''s rewrite the very simple build file from [Chapter 1](part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 1. Running Your First Gradle Task"), *Running Your First Gradle Task*
    to use the project reference for method calls:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重写[第1章](part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0 "第1章。运行您的第一个Gradle任务")中非常简单的构建文件，即*运行您的第一个Gradle任务*，以使用项目引用进行方法调用：
- en: '[PRE75]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'As we saw earlier in this chapter, `apply` is the method on the `project`.
    The so-called `dependencies` block is actually a method named `dependencies()`
    on `project` that accepts a closure. It is true for the `repositories` section
    as well. We can add parenthesis around the closure block to make it look like
    a plain old method call:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，`apply`是`project`上的一个方法。所谓的`dependencies`块实际上是在`project`上接受闭包的`dependencies()`方法。对于`repositories`部分也是如此。我们可以将闭包块用括号括起来，使其看起来像是一个普通的方法调用：
- en: '[PRE76]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: There are many more interesting methods on this object, which we will see in
    the upcoming sections and chapters, again, with or without explicit reference
    to the `project` object.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个对象上还有许多其他有趣的方法，我们将在接下来的章节中看到，这些方法要么有，要么没有对`project`对象的明确引用。
- en: Project properties
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目属性
- en: There are several properties available on the `project` object. Some properties
    are read-only properties, such as `name`, `path`, `parent`, and so on, while others
    are both readable and writable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`project`对象上有几个属性可用。一些属性是只读属性，如`name`、`path`、`parent`等，而其他属性则是可读可写的。
- en: For example, we can set `project.description` to provide a description of our
    project. We can use the `project.version` property to set the version of the project.
    This version will be used by other tasks such as `Jar` to include a version number
    in the produced artifact.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以设置`project.description`来提供项目的描述。我们可以使用`project.version`属性来设置项目的版本。这个版本将被其他任务，如`Jar`使用，以在生成的工件中包含版本号。
- en: Note
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We cannot change the `project.name` from the `build.gradle` file, but we can
    use `settings.gradle` in the same project to set the project name. We will see
    this file in more detail when we learn about multi-project builds.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能从`build.gradle`文件中更改`project.name`，但我们可以使用同一项目中的`settings.gradle`来设置项目名称。当我们学习多项目构建时，我们将更详细地了解这个文件。
- en: Apart from directly accessing a property by its name, we can access properties
    using the following methods on the `project` object.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 除了直接通过名称访问属性外，我们还可以使用以下在`project`对象上的方法来访问属性。
- en: 'To check whether a property exists, use the following method:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查属性是否存在，请使用以下方法：
- en: '[PRE77]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'To get the value of a property for a given property name, use the following
    method:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取给定属性名的属性值，请使用以下方法：
- en: '[PRE78]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To set the value of a property for a given property name, use the following
    method:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置给定属性名的属性值，请使用以下方法：
- en: '[PRE79]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'For example, let''s create a `build.gradle` file with the following content:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们创建一个包含以下内容的`build.gradle`文件：
- en: '[PRE80]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Execute the following task:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下任务：
- en: '[PRE81]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: As seen earlier, in Groovy, we can use the `property = value` syntax to call
    a setter. We are setting the `description` and `version` properties on the `project`
    object. Then, we add a task with the task action that prints the version using
    the `project` reference and `description` using the `property()` method on the
    `project` object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在Groovy中，我们可以使用`property = value`语法来调用setter。我们在`project`对象上设置了`description`和`version`属性。然后，我们添加了一个任务，该任务使用`project`引用和`description`使用`project`对象上的`property()`方法来打印版本。
- en: The properties that we have seen above must exist on the project, otherwise
    build fails with a `Could not find property …` message.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上面看到的属性必须在项目上存在，否则构建将失败，并显示`Could not find property …`消息。
- en: Extra properties on a project
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 项目上的额外属性
- en: 'Gradle makes it very easy to store user-defined properties on a project, while
    still being able to enjoy the niceties of project properties'' syntax. All we
    have to do is to use the `ext` namespace to assign a value to a custom property.
    Then, this property can be accessed on a project just like regular project properties.
    Here is an example:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle使得在项目上存储用户定义的属性变得非常容易，同时仍然能够享受项目属性语法的便利。我们只需要使用`ext`命名空间将值分配给自定义属性。然后，这个属性可以在项目上像常规项目属性一样访问。以下是一个示例：
- en: '[PRE82]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Execute the following task:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下任务：
- en: '[PRE83]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In the preceding example, we declared a custom property called `abc` and assigned
    it the value `123`. We did not use the `project` reference as it is implicitly
    available at the script root level. In the task action, we printed it first using
    a project reference directly, just as if it were a property on `Project`. Then,
    we accessed using the `property()` method and also using the `project.ext` reference.
    Note that inside tasks' action closure, we should use the `project` reference
    to avoid any ambiguity.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们声明了一个名为`abc`的自定义属性，并将其赋值为`123`。我们没有使用`project`引用，因为它在脚本根级别上是隐式可用的。在任务操作中，我们首先使用项目引用直接打印它，就像它是在`Project`上的一个属性一样。然后，我们使用`property()`方法和`project.ext`引用来访问它。请注意，在任务的动作闭包内部，我们应该使用`project`引用以避免任何歧义。
- en: Extra properties will be accessible in the sub-projects (modules). Extra properties
    can be set on other objects as well.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的属性将在子项目（模块）中可用。也可以在其他对象上设置额外的属性。
- en: Note
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We could have just used the local variable by declaring it with `def`. However,
    such variables are not accessible outside the lexical scope. Also, they are not
    queriable.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以使用局部变量，通过使用`def`声明它。然而，这样的变量在词法作用域之外不可访问。此外，它们也不可查询。
- en: Although we have looked at a few methods and properties, it's impractical to
    cover all of those here; hence, it is worth spending some time reading the API
    and the DSL documentation of the `project` interface.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经查看了一些方法和属性，但在这里涵盖所有这些是不切实际的；因此，花些时间阅读`project`接口的API和DSL文档是值得的。
- en: Tasks
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务
- en: As we have seen so far, a `task` is a named action that performs some build
    logic. It's a unit of build work. For example, `clean`, `compile`, `dist`, and
    so on, are typical build tasks that easily come to our mind if we have to write
    tasks for our project. Tasks are more or less analogous to Ant's targets.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`task`是一个执行某些构建逻辑的命名操作。它是一个构建工作的单元。例如，`clean`、`compile`、`dist`等，如果我们必须为我们自己的项目编写任务，这些是典型的构建任务，很容易浮现在我们的脑海中。任务在某种程度上类似于Ant的目标。
- en: 'The simplest way to create a task is as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 创建任务的简单方法如下：
- en: '[PRE84]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Before we go any further with tasks, let's take a moment to ponder about task
    creation.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进一步讨论任务之前，让我们花点时间思考一下任务创建。
- en: We used the `taskName` task form of a statement.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了语句的`taskName`任务形式。
- en: If we rewrite it as a `task (taskName)`, it will immediately look like the method
    call.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将其重写为`task (taskName)`，它将立即看起来像方法调用。
- en: The preceding method, as we might have already guessed by now, is available
    on the project object.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能已经猜到的，前面的方法在项目对象上是可用的。
- en: 'So, we could write one of the following as well:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们也可以写出以下内容之一：
- en: '`project.task "myTask"`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project.task "myTask"`'
- en: '`project.task("myTask")`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`project.task("myTask")`'
- en: Notice that in the later examples we had to pass the task name as a string.
    The `task taskName` is a special form where we can use `taskName` as a literal
    instead of string. This is done by Groovy AST transformation magic.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在后面的示例中，我们必须传递任务名称作为字符串。`task taskName` 是一种特殊形式，我们可以使用 `taskName` 作为字面量而不是字符串。这是通过
    Groovy AST 转换魔法实现的。
- en: 'The project has several flavors of a task method to create a task object:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 项目有几种创建任务对象的 `task` 方法：
- en: '[PRE85]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: However, in essence, we may pass some key values as named parameters while creating
    a task and a configuration closure to configure the task.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本质上，我们可以在创建任务时传递一些键值作为命名参数，并传递一个配置闭包来配置任务。
- en: We are essentially creating an object of the type `Task` (the exact class name
    is not important right now). We can query the properties and call methods on this
    object. Gradle nicely makes this `task` object available for use. Behind the nice
    DSL, we are actually writing a script that creates the build logic in a nice object-oriented
    way.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上创建了一个 `Task` 类型（确切类名现在并不重要）的对象。我们可以查询属性并在此对象上调用方法。Gradle 优雅地使这个 `task`
    对象可用于使用。在优雅的 DSL 之下，我们实际上正在编写一个脚本，以优雅的面向对象方式创建构建逻辑。
- en: Attaching actions to a task
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将操作附加到任务
- en: A `Task` object, such as the one created above, does not do much. In fact, there
    is no action attached to it. We need to attach actions to a `Task` object for
    Gradle to perform those actions when a task is run.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Task` 对象，例如上面创建的，实际上并没有做什么。事实上，它没有附加任何操作。我们需要将操作附加到 `Task` 对象上，以便 Gradle
    在运行任务时执行这些操作。
- en: 'A `Task` object has a method called `doLast`, which accepts a closure. Gradle
    ensures that all the closures passed to this methods are executed in the order
    they were passed:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `Task` 对象有一个名为 `doLast` 的方法，它接受一个闭包。Gradle 确保传递给此方法的闭包按它们传递的顺序执行：
- en: '[PRE86]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'What we can do now is call `doLast` once more:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以再次调用 `doLast`：
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Also, in an alternate syntax:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在另一种语法中：
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'There are multiple ways to add a `doLast` logic to a task, but the most idiomatic,
    and perhaps a terse way is as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以向任务添加 `doLast` 逻辑，但最符合习惯用法，也许是最简洁的方法如下：
- en: '[PRE89]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Just like the `Project` object, we have the `Task` object on which methods and
    properties are accessible. However, unlike the `Project` object, it is not implicitly
    available at the top level in the script, but only inside the task’s configuration
    scope. Also, intuitively, we can say that there will be multiple `Task` objects
    per `build.gradle`. We will see the various ways to access the `Task` object later.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `Project` 对象一样，我们有一个 `Task` 对象，其中方法和属性是可访问的。然而，与 `Project` 对象不同，它不是在脚本的顶层隐式可用，而仅在任务的配置范围内。直观地说，我们可以认为每个
    `build.gradle` 将会有多个 `Task` 对象。我们将在稍后看到访问 `Task` 对象的各种方法。
- en: Task flow control
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务流程控制
- en: Tasks within a project may have a dependency on each other. In this section,
    we will see different kinds of relationships that may exist within tasks of a
    project.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 项目内的任务可能相互依赖。在本节中，我们将看到项目任务中可能存在不同类型的关系。
- en: dependsOn
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: dependsOn
- en: 'There are tasks whose execution is dependent on the other task''s successful
    completion. For example, for creating a distributable JAR file, the code should
    have been compiled first and the "class" files should already exist. In such a
    case, we don''t want the user to explicitly specify all the tasks and their order
    from the command line, as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些任务的执行依赖于其他任务的成功完成。例如，为了创建可分发的 JAR 文件，代码应该首先被编译，并且 "class" 文件应该已经存在。在这种情况下，我们不希望用户明确指定所有任务及其顺序，如下所示：
- en: '[PRE90]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'This is error-prone. We may forget to include one task, or the ordering may
    become complicated if there are multiple tasks that are dependent on the successful
    completion of the previous tasks. It is desirable to be able to specify if a:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会导致错误。我们可能会忘记包含一个任务，或者如果有多个任务依赖于前一个任务的完成，顺序可能会变得复杂。我们希望能够指定是否：
- en: '[PRE91]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: finalizedBy
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: finalizedBy
- en: 'We can also declare that, if a task is called, it should be followed by another
    task, even if another task is not explicitly called. This is in contrast to `dependsOn`,
    where another task is executed before the called task. In the case of `finalizedBy`,
    another task is executed after the execution of the called task:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明，如果调用一个任务，它应该跟随另一个任务，即使没有明确调用另一个任务。这与 `dependsOn` 相反，其中另一个任务在调用任务之前执行。在
    `finalizedBy` 的情况下，另一个任务在调用任务的执行之后执行：
- en: '[PRE92]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: onlyIf
  id: totrans-339
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: onlyIf
- en: 'We can specify a condition and if it is satisfied, the task will be executed:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以指定一个条件，如果满足该条件，则任务将被执行：
- en: '[PRE93]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: mustRunAfter and shouldRunAfter
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: mustRunAfter和shouldRunAfter
- en: 'There are times when we just want to order tasks in a particular fashion if
    this relationship is not exactly the same as `dependsOn`. For example, if we execute
    the following command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，如果我们想要以特定的顺序排列任务，而这种关系并不完全等同于`dependsOn`。例如，如果我们执行以下命令：
- en: '[PRE94]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Then, unrelated tasks will be executed in the order they were specified on the
    command line, which in this case doesn't make sense.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，无关的任务将按照在命令行上指定的顺序执行，在这种情况下这没有意义。
- en: 'In such a case, we may add the following line of code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可能需要添加以下代码行：
- en: '[PRE95]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: This tells Gradle that, if both the tasks are there in the task graph, then
    the `build` must run after the `clean` is run. Here, build does not depend on
    clean.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Gradle，如果任务图中有这两个任务，那么`build`必须在`clean`运行之后运行。在这里，`build`不依赖于`clean`。
- en: 'The difference between `shouldRunAfter` and `mustRunAfter` is that the former
    is more suggestive to Gradle, but doesn''t enforce Gradle to follow the ordering
    all the time. In the following two cases, `shouldRunAfter` may not be honored
    by Gradle:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '`shouldRunAfter`和`mustRunAfter`之间的区别在于前者对Gradle更具暗示性，但并不强制Gradle始终遵循这种顺序。在以下两种情况下，Gradle可能不会遵守`shouldRunAfter`：'
- en: In the case when it introduces cyclic ordering.
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它引入循环排序时的情况。
- en: In the case of parallel execution, when only the `shouldRunAfter` task has not
    yet successfully completed and other dependencies are satisfied, then `shouldRunAfter`
    will be ignored.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行执行的情况下，当只有`shouldRunAfter`任务尚未成功完成且其他依赖项已满足时，则`shouldRunAfter`将被忽略。
- en: Creating tasks dynamically
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态创建任务
- en: One of the beauties of Gradle is that we can create tasks dynamically as well.
    What this means is that the name and the logic of task is not completely known
    while writing the build, but depending on some variable parameter, the tasks will
    be automatically added to our Gradle project.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的一个优点是我们可以动态创建任务。这意味着在编写构建时，任务的名称和逻辑并不完全已知，但根据某些变量参数，任务将自动添加到我们的Gradle项目中。
- en: 'Let''s try to understand with an example:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个示例来尝试理解：
- en: '[PRE96]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In the preceding contrived examples, we are creating and adding ten tasks dynamically
    to our build. Although all of them just print the task number, the ability to
    dynamically create and add tasks to our project is extremely powerful.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的虚构示例中，我们正在动态创建并添加十个任务到我们的构建中。尽管它们只是打印任务编号，但能够动态创建和添加任务到我们的项目中是非常强大的。
- en: Setting default tasks
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置默认任务
- en: 'So far, we have always been calling the `gradle` command line interface with
    the task name(s). This is kind of repetitive in nature, especially during development,
    and a tool such as Gradle gets us covered:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用带有任务名称（s）的`gradle`命令行界面。这在本质上有点重复，尤其是在开发期间，Gradle这样的工具为我们提供了覆盖：
- en: '[PRE97]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: It is wise to set default tasks so that if we don't specify any task name, the
    set tasks are executed by default.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 设置默认任务是个明智的选择，这样如果我们没有指定任何任务名称，默认的任务就会被执行。
- en: In the preceding example, running `gradle` from the command line without any
    arguments runs the default tasks one after another in the sequence specified in
    the `defaultTasks`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，不带任何参数从命令行运行`gradle`会依次运行`defaultTasks`中指定的默认任务。
- en: Task types
  id: totrans-362
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任务类型
- en: The tasks that we have seen so far were ad-hoc in nature. We had to write the
    code for the task action that needs to be performed whenever the task executes.
    However, no matter which project we are building, there are many tasks for which
    the logic of task action need not change if we have the capability to make some
    configuration changes to the existing logic. For example, when you copy files,
    only the source, target, and inclusion/exclusion patterns change, but the actual
    logic of how to copy files from one location to another honoring the inclusion/exclusion
    patterns stays the same. So, if there are two copy-like tasks required in a project,
    let's say `copyDocumentation` and `deployWar`, would we really want to write an
    entire logic to copy the selected files twice?
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到的任务都是临时的。我们必须编写任务动作的代码，每当任务执行时都需要执行。然而，无论我们构建哪个项目，总有许多任务的动作逻辑不需要改变，如果我们有能力对现有逻辑进行一些配置更改。例如，当你复制文件时，只有源、目标和包含/排除模式会改变，但如何从一处复制文件到另一处并遵守包含/排除模式的实际逻辑保持不变。所以，如果一个项目中需要两个类似复制任务的，比如说`copyDocumentation`和`deployWar`，我们真的需要编写整个逻辑来复制选定的文件两次吗？
- en: This would be okay for very small builds (such as the examples in our chapter),
    but the approach does not scale well. If we keep on writing task actions to perform
    these mundane operations, then our build scripts will quickly bloat into an unmanageable
    state.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常小的构建（例如我们章节中的示例），这可能是可行的，但这种方法扩展性不好。如果我们继续编写任务操作来执行这些日常操作，那么我们的构建脚本将很快膨胀到一个难以管理的状态。
- en: Custom task type is Gradle's solution to abstract out reusable build logic into
    custom task classes, which expose the input/output configuration variables on
    the task object. This helps us tune a typed task to suit our specific needs. This
    helps us keep the common build logic reusable and testable.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义任务类型是 Gradle 将可重用的构建逻辑抽象到自定义任务类中的解决方案，这些类在任务对象上公开输入/输出配置变量。这有助于我们调整类型化任务以满足我们的特定需求。这有助于我们保持常见的构建逻辑可重用和可测试。
- en: Another problem with ad-hoc task action is that it's imperative in nature. For
    the sake of flexibility of the tool, Gradle allows us to imperatively script custom
    logic in build scripts. However, excessive usage of imperative code in our build
    scripts makes the build script unmaintainable. Gradle should be used in a declarative
    manner as much as possible. An imperative logic should be encapsulated within
    a custom task class while exposing the task configuration for the user to configure.
    In Gradle's terminology, custom task classes are called **enhanced tasks**.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个与临时代码任务操作相关的问题是它本质上是命令式的。为了工具的灵活性，Gradle 允许我们在构建脚本中以命令式方式编写自定义逻辑。然而，在构建脚本中过度使用命令式代码会使构建脚本难以维护。Gradle
    应尽可能以声明式方式使用。命令式逻辑应封装在自定义任务类中，同时向用户公开任务配置以便配置。在 Gradle 的术语中，自定义任务类被称为 **增强任务**。
- en: Custom task types act as a template with some sensible defaults for a common
    build logic. We still need to declare a task in our build, but we just tell Gradle
    the type of this task and configure the settings of this task type, instead of
    writing the entire task action block again. Gradle already ships with many custom
    task types; for example, `Copy`, `Exec`, `Delete`, `Jar`, `Sync`, `Test`, `JavaCompile`,
    `Zip`, and so on. We can easily write our own enhanced tasks as well. We will
    very briefly see both the scenarios.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义任务类型充当一个模板，为常见的构建逻辑提供一些合理的默认值。我们仍然需要在构建中声明一个任务，但我们只需告诉 Gradle 这个任务类型以及配置这个任务类型的设置，而不是再次编写整个任务操作块。Gradle
    已经提供了许多自定义任务类型；例如，`Copy`、`Exec`、`Delete`、`Jar`、`Sync`、`Test`、`JavaCompile`、`Zip`
    等等。我们也可以轻松编写我们自己的增强任务。我们将简要地查看这两种场景。
- en: Using task types
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任务类型
- en: 'We can configure a task that is of type `Copy` using the following syntax:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下语法配置类型为 `Copy` 的任务：
- en: '[PRE98]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In the preceding example, the first important difference is that we are passing
    a key `type` with the value as the custom task's class name, which is `Copy` in
    this case. Also, notice that there is no `doLast` or indirection (`<<`) operator.
    The closure that we are passing to this task actually gets executed in the configuration
    phase of build. The method calls inside the closure are delegated to the implicitly
    available `task` object, which is being configured. We have not written any logic
    here, but have just provided the configuration to a task whose type is `Copy`.
    It is always worth taking a look at the available custom tasks before we go ahead
    with writing ad-hoc task actions.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，第一个重要的区别是我们传递了一个带有自定义任务类名（在这种情况下为 `Copy`）作为值的 `type` 键。此外，请注意没有 `doLast`
    或间接（`<<`）操作符。我们传递给这个任务的闭包实际上在构建配置阶段执行。闭包内的方法调用被委派给隐式可用的 `task` 对象，该对象正在被配置。我们没有在这里编写任何逻辑，只是为类型为
    `Copy` 的任务提供了配置。在继续编写临时代码任务操作之前，查看可用的自定义任务总是值得的。
- en: Creating task types
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建任务类型
- en: If we look back now, the code we have been writing for our task actions for
    our sample tasks was mostly a `println` statement that would print the given message
    on `System.out`. Now, just imagine that we found `System.out` doesn't fit our
    bill, and we should rather use text files to print the message from the tasks.
    We would need to go through all the tasks and change the implementation to write
    to a file instead of `println`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在回顾一下，我们为示例任务编写的任务操作代码主要是打印给定消息到 `System.out` 的 `println` 语句。现在，想象一下，如果我们发现
    `System.out` 不符合我们的要求，我们更应该使用文本文件从任务中打印消息。我们需要遍历所有任务并更改实现以将消息写入文件而不是 `println`。
- en: 'There is a better way to handle such changing requirement. We can leverage
    the capability of the task type here by providing our own task type. Let''s put
    the following code in our `build.gradle`:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 处理此类变化需求有更好的方法。我们可以通过提供自己的任务类型来利用任务类型的功能。让我们在`build.gradle`中放入以下代码：
- en: '[PRE99]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'In the preceding code sample:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码示例中：
- en: We first created a class (which will be our task type) that extends `DefaultTask`,
    which is already defined in Gradle.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们首先创建了一个类（它将成为我们的任务类型），该类扩展了`DefaultTask`，这是在Gradle中已经定义好的。
- en: Next, we declared a configurable input to our task using `@Input` on the property
    named `message`. The consumer of our task can configure this property.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`@Input`在名为`message`的属性上声明了一个可配置的任务输入。我们的任务消费者可以配置这个属性。
- en: Then, we used the `@TaskAction` annotation on the `print` method. This method
    is executed when our task is called. It just uses `println` to print the `message`.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们在`print`方法上使用了`@TaskAction`注解。当我们的任务被调用时，这个方法会被执行。它只是使用`println`来打印`message`。
- en: Then, we declared the three tasks; all using different ways to configure our
    task. Notice the absence of any task action.
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们声明了三个任务；所有任务都使用不同的方式来配置我们的任务。注意没有任务动作。
- en: Finally, we applied task flow control techniques to declare task dependencies.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们应用了任务流程控制技术来声明任务依赖关系。
- en: 'If we run the `thanks` task now, we can see the expected output, as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行`thanks`任务，我们可以看到预期的输出，如下所示：
- en: '[PRE100]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'A few points to note here are as follows:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里需要注意的几点如下：
- en: If we want to change the implementation of our printing logic, there is only
    one place where we need to do the change, the `print` method of our custom task
    class.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想要更改打印逻辑的实现，我们只需要在一个地方进行更改，那就是我们自定义任务类的`print`方法。
- en: The tasks using task types are used and they work just like any other tasks.
    They can also have task actions closure using `doLast {}`, `<< {}`, but it is
    usually not required.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务类型的任务被使用，并且它们的工作方式与任何其他任务一样。它们也可以使用`doLast {}`、`<< {}`来执行任务动作闭包，但通常不是必需的。
- en: References
  id: totrans-387
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参考文献
- en: The next sections mention some of the useful references for Groovy.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 下几节提到了一些Groovy的有用参考资料。
- en: Groovy
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Groovy
- en: 'There is a plethora of online reference material available for Groovy. We could
    start at:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Groovy，有大量的在线参考资料可用。我们可以从这里开始：
- en: For further reading, refer to Groovy's online documentation at [http://www.groovy-lang.org/documentation.html](http://www.groovy-lang.org/documentation.html)
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于进一步阅读，请参考Groovy的在线文档[http://www.groovy-lang.org/documentation.html](http://www.groovy-lang.org/documentation.html)
- en: More references of Groovy resources are available at [https://github.com/kdabir/awesome-groovy](https://github.com/kdabir/awesome-groovy)
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多Groovy资源的参考信息可在[https://github.com/kdabir/awesome-groovy](https://github.com/kdabir/awesome-groovy)找到。
- en: 'Here is a list of books on Groovy:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一份关于Groovy的书籍列表：
- en: The *Groovy in Action* book is available at [https://www.manning.com/books/groovy-in-action-second-edition](https://www.manning.com/books/groovy-in-action-second-edition).
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Groovy in Action》一书可在[https://www.manning.com/books/groovy-in-action-second-edition](https://www.manning.com/books/groovy-in-action-second-edition)找到。
- en: The *Groovy Cookbook* is available at [https://www.packtpub.com/application-development/groovy-2-cookbook](https://www.packtpub.com/application-development/groovy-2-cookbook).
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Groovy Cookbook》一书可在[https://www.packtpub.com/application-development/groovy-2-cookbook](https://www.packtpub.com/application-development/groovy-2-cookbook)找到。
- en: The *Programming Groovy 2* book is available at [https://pragprog.com/book/vslg2/programming-groovy-2](https://pragprog.com/book/vslg2/programming-groovy-2).
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Programming Groovy 2》一书可在[https://pragprog.com/book/vslg2/programming-groovy-2](https://pragprog.com/book/vslg2/programming-groovy-2)找到。
- en: Gradle API and DSL used in this chapter
  id: totrans-397
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 本章中使用的Gradle API和DSL
- en: Gradle's official API and DSL documentation is a good place to explore and learn
    more about various classes discussed in this chapter. These APIs and DSLs are
    very rich and deserve our reading time.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle的官方API和DSL文档是探索和学习本章中讨论的各种类的好地方。这些API和DSL非常丰富，值得我们花时间阅读。
- en: '`Project`:'
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Project`：'
- en: 'The API documentation: [http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html](http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html)'
  id: totrans-400
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API文档：[http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html](http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html)
- en: 'The DSL documentation: [http://gradle.org/docs/current/dsl/org.gradle.api.Project.html](http://gradle.org/docs/current/dsl/org.gradle.api.Project.html)'
  id: totrans-401
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSL文档：[http://gradle.org/docs/current/dsl/org.gradle.api.Project.html](http://gradle.org/docs/current/dsl/org.gradle.api.Project.html)
- en: '`Gradle` (the interface):'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gradle`（接口）：'
- en: 'The API documentation: [http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html](http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html)'
  id: totrans-403
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 文档：[http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html](http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html)
- en: 'The DSL documentation: [http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html](http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html)'
  id: totrans-404
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSL 文档：[http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html](http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html)
- en: '`Task`:'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`任务`：'
- en: 'The API documentation: [http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html](http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html)'
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 文档：[http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html](http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html)
- en: 'The DSL documentation: [http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html](http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html)'
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSL 文档：[http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html](http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html)
- en: Summary
  id: totrans-408
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started this chapter with a quick feature overview of Groovy language, covering
    some of the topics that would be helpful for us to understand Gradle's syntax
    and write better build scripts. Then, we looked at the API that Gradle exposes
    to our build scripts and how to consume the API via the DSL. We also covered the
    Gradle build phases. Then, we looked at the way in which tasks can be created,
    configured, have dependencies between, and run by default.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本章从 Groovy 语言的快速功能概述开始，涵盖了一些有助于我们理解 Gradle 语法和编写更好的构建脚本的议题。然后，我们研究了 Gradle
    向我们的构建脚本公开的 API 以及如何通过 DSL 消费 API。我们还涵盖了 Gradle 构建阶段。然后，我们探讨了任务可以被创建、配置、相互依赖以及默认运行的方式。
- en: After reading this chapter, we should be able to comprehend the Gradle DSL,
    rather than just trying to remember the syntax. We are now in a position to read
    and understand any given Gradle build file, and we should now be able to write
    custom tasks with ease.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读完本章后，我们应该能够理解 Gradle DSL，而不仅仅是试图记住语法。我们现在能够阅读并理解任何给定的 Gradle 构建文件，并且现在能够轻松地编写自定义任务。
- en: This chapter might feel a little long and complex. We should take some time
    out to practise and reread the sections that are not clear and also look up the
    online references given throughout the chapter. The chapters ahead will be smooth
    sailing.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 本章可能感觉有点长且复杂。我们应该抽出一些时间来练习和重新阅读那些不清楚的部分，并且查阅本章中给出的在线参考资料。接下来的章节将会更加顺畅。
