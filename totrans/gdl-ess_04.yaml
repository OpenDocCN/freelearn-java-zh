- en: Chapter 4. Demystifying Build Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the first three chapters, we saw many interesting functionalities that Gradle
    can add to our builds merely by adding a few lines in the build file. However,
    this was just the tip of the iceberg. What we explored was mostly the tasks that
    were added by plugins shipped with Gradle. From our experiences, we know that
    project builds are never this simple. They will have customizations no matter
    how hard we try to avoid them. That's why the ability to add custom logic is extremely
    important for a build tool.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the beauty of Gradle lies exactly there. It doesn't come into our way
    whenever we decide to either extend the existing functionality or deviate completely
    from the convention and want to do something unconventional. We are not required
    to write the XML soup or the bunch of Java code if we wish to add some logic to
    our build. We can create our own tasks or extend the existing tasks to do more.
  prefs: []
  type: TYPE_NORMAL
- en: 'This flexibility comes with a very gentle learning curve in the form of learning
    Groovy DSL. In this chapter, we are going to understand the syntax of the Gradle
    build scripts and some of the key concepts of Gradle. We will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A Groovy primer that will help us understand the Gradle build script syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two important objects available in our build, namely, the `project` object
    and the `task` object(s)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build phases and life cycle callbacks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some details of the tasks (tasks execution and task dependencies)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groovy for Gradle build scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To be proficient with Gradle and write effective build scripts, we need to understand
    some basics of Groovy, which is a fantastic dynamic language in itself. If we
    have any experience with dynamic languages such as Ruby or Python, in addition
    to Java, we will feel right at home with Groovy. If not, still knowing that most
    of the Java syntax is also the valid Groovy syntax should make us feel happy about
    Groovy, because we can start writing Groovy code and be productive from day one
    without having to learn anything.
  prefs: []
  type: TYPE_NORMAL
- en: To an unprepared eye, Gradle scripts may look a little difficult to comprehend
    at first. Gradle build scripts do not merely use the Groovy syntax, but also use
    a rich and expressive DSL that provides high-level abstractions to represent common
    build-related logics. Let's take a quick look at what makes Groovy a great choice
    for writing build files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using Groovy for writing build logics is not new. Gant and GMaven have already
    used Groovy to write the build logic in order to harness Groovy's syntactic terseness
    and expressiveness. GMavenPlus is a successor of GMaven. The tools they are built
    upon, namely Ant and Maven, limit both Gant and GMaven respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of piggybacking on the existing tools to just add syntactic enhancements,
    Gradle is designed by leveraging the learning from the past tools.
  prefs: []
  type: TYPE_NORMAL
- en: Why Groovy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle's core is written mostly in Java (see the information below). Java is
    a great language, but it is not the best fit for writing scripts. Just imagine
    scripting in Java, we would perhaps be writing another project for defining the
    build of our main project because of the verbosity and ceremony of Java. XML,
    which was heavily used in the previous generation of build tools (Ant and Maven),
    is okay for the declarative part but is not great for writing logic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can view and download Gradle's source code from GitHub at [https://github.com/gradle/gradle](https://github.com/gradle/gradle).
  prefs: []
  type: TYPE_NORMAL
- en: Groovy is a dynamic avatar of Java. As mentioned earlier, most of the Java syntax
    is the valid Groovy syntax too. If we know Java, we can already write Groovy code.
    This is a big plus provided that the sheer number of people who can write Java
    today.
  prefs: []
  type: TYPE_NORMAL
- en: Groovy's syntax is concise, expressive, and powerful. Groovy is a great mix
    of dynamic flavor, while still being able to use types. It is one of few languages
    that sport optional typing, that is, the flexibility to provide type information
    if we want to and leave type information aside when we don't want to. Groovy is
    an excellent language to build internal DSLs into because of the first class lambda
    support and metaprogramming capabilities. All of the above factors make it one
    of the most suitable candidates for writing build scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Groovy primer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although we can write Java style code in Groovy, if we invest some time in learning
    the dynamic nature of the language and some of the syntactical enhancements that
    Groovy offers, we will be able to write better Gradle build scripts and plugins.
    This is going to be fun if we don't already know Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn just enough of Groovy so that we can understand the Gradle scripts
    properly. We will take a quick look at a few language features of Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: It is highly recommended to try and execute the code in the subsections that
    follow. Also, writing and trying out more code on our own to explore Groovy would
    help us strengthen our understanding of the language fundamentals. This guide
    is not exhaustive by any means and is included just to set the Groovy ball rolling.
  prefs: []
  type: TYPE_NORMAL
- en: Running Groovy code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest and recommended way is to install the latest Groovy SDK locally.
    Groovy code snippets can be executed using any of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the snippets to the `.groovy` script and run from the command line using
    the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can use the Groovy console GUI that comes packaged with the Groovy installation
    to edit and run the scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also use Groovy shell, which is an interactive shell for executing or
    evaluating Groovy statements and expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we don''t want to install Groovy locally, then:'
  prefs: []
  type: TYPE_NORMAL
- en: We can run Groovy code online in a browser using Groovy console at [http://groovyconsole.appspot.com](http://groovyconsole.appspot.com)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also run Groovy code in the build script by creating tasks and putting
    code snippets in them (we can also put them outside any task and it will still
    run it in the configuration phase)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a Groovy script, the `def` keyword can define a variable (depending on the
    context):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: However, the type of `a` is decided at the runtime depending on what type of
    object it points to. Roughly speaking, a reference declared as `def` can refer
    to any `Object` or its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a more specific type is equally valid and should be used whenever
    we want to have type safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use Java primitive data types, but keep in mind that they are not
    actually primitives in Groovy. They are still first-class objects and are actually
    Java wrapper classes for corresponding data type. Let''s confirm with an example,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This shows that `c` is an object as we can call a method on it, and the type
    of `c` is `Integer`.
  prefs: []
  type: TYPE_NORMAL
- en: We recommend using specific types wherever possible as this adds to the readability
    and helps the Groovy compiler to detect errors early by catching invalid assignments.
    It also helps IDEs with code completion.
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Unlike Java, the single quotes are (`''''`) string literals and not a `char`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, regular Java string literals (`""`) can also be used, but they are
    called GStrings in Groovy. They have an additional capability of string interpolation
    or inline expansion of variables or expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `${var}` and `$var` are valid, but wrapping (`${}`) is more suitable and
    required for complex or longer expressions. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All of us would remember adding `+ "\\n"` at the end of every line in order
    to produce multiline strings in Java. Gone are those days, as Groovy supports
    multiline string literals. The multiline literal starts off with three single
    or double quotes (the same string versus the GString functionality) and ends with
    three single or double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The forward slash on line number 1 is optional and is used to exclude the first
    new line. If we do not put the forward slash, we would have an additional new
    line in the beginning of the output.
  prefs: []
  type: TYPE_NORMAL
- en: Also, look at the `stripMargin` and `stripIndent` methods for the special handling
    of leading whitespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our literal contains a lot of escape characters (for example, regex), then
    we are better off using a "slashy" string literal, which starts and ends with
    a single forward slash (`/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It will prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, if we had to use a regular string, then we would have
    to escape the backslash before the character class `d`. It would have looked as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Groovy supports a pattern operator (`~`), which when applied to a string, gives
    a pattern object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the find operator to directly match a string to a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'It will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Closures
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Closure** in Groovy is a block of code that can be assigned to a reference
    or passed around just like any other variable. The concept is known as **lambda**
    in many other languages, including Java 8 or function pointers.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Lambdas have been supported since Java 8, but the syntax is a bit different
    than that of Groovy's closures. You don't need to be on Java 8 to use closure
    in Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: If we have no exposure to any of the above, then some detailed reading will
    be required to understand the concept well because it lays the foundation for
    many other advanced topics going forward. Closure is a huge topic in itself and
    an in-depth discussion is beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closure is almost like a regular method or function, but it can also be assigned
    to a variable. Also, as it can be assigned to a variable, it must be an object
    as well; hence, it will have methods on itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the code block is being assigned to a variable called `cl1`. Now the
    code block can be executed using the call method in the future or the `cl1` variable
    can be passed around and executed later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'No wonder it prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'As closures are like methods, they can also accept parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Just like methods, they can also return values. The last expression of closure
    is automatically returned if no explicit `return` statement is declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closures start shining when we have methods that accept closures. For example,
    the `times` method is available on integer, which takes in a closure and executes
    it as many number times as the value of the integer itself; with every call, it
    passes the current value as if we were looping up to the value from `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also inline the block and pass it directly to a method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There is a special variable called `it`, which is available in the blocks scope
    if the closure doesn't define its parameter. In the preceding example, we accessed
    the number being passed to the block using `it` and multiplied it by itself to
    obtain its square.
  prefs: []
  type: TYPE_NORMAL
- en: Closures are extremely useful in situations such as callback handling, whereas
    in Java 7 and lower, we would have to use anonymous interface implementation to
    achieve the same result.
  prefs: []
  type: TYPE_NORMAL
- en: Data structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Groovy supports literal declaration of the often-used data structures, which
    makes the code a lot more terse without sacrificing readability.
  prefs: []
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Groovy backs on the thoroughly tested Java Collection API and uses the same
    classes under the hood, but with some extra methods and syntactic sugar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Groovy, `[]` is actually a Java's `List` instance and not an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another list with some initial content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to operator overloading, we can use many of the operators intuitively
    on the list. For example, using `anotherList[1]` will give us `b`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some more examples of handy operators. This adds two lists
    and assigns the result to the list variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This appends `60` to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two examples simply subtracts a list from another list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Iterating over a list is equally simple and intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It will print the following
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The closure passed to `each` is executed for each element of the list, with
    the element as a parameter to closure. So, the preceding code iterates over the
    list and prints the value of each element. Notice the usage of `it`, which is
    a handle to the current element of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Defining a set is similar to that of a list, but in addition, we have to use
    `as Set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As the implementation class selected is `LinkedHashSet`, `aSet` will maintain
    the insertion order.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, declare the type of variable to get the correct implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding elements to a set is just like a list using an indirection operator.
    Other set interface methods are also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We don't see the entry `4` twice as the collection is a set implementation,
    which by definition eliminates duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Map
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Map is one of the most important data structures for any dynamic language.
    Hence, it gets a deserved place in Groovy''s syntax. Map can be declared using
    the map literal `[:]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation chosen by default is `java.util.LinkedHashMap`, which preserves
    the insertion order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the keys are not string literals, but they get automatically converted
    to a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We can access the values by using both the subscript and dot operator, in addition
    to the plain old `get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can put and update data in map using the subscript and dot operator and,
    of course, the good old `put()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following is more of a Java-like method, which is of course a valid Groovy
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method can be succinctly rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Instead of specifying the return type, we just declared `def`, which effectively
    means the method can return any `Object` or subclass reference. Then, we omitted
    the type of the formal parameter, as declaring `def` is optional for formal parameters
    to a method. On line number 2, we omitted the `return` statement as the evaluation
    of the last expression is automatically returned by a method. We also omitted
    the semicolon as it's optional.
  prefs: []
  type: TYPE_NORMAL
- en: Both the examples are valid Groovy method declarations. However, readers are
    advised to choose types wisely as they provide type safety and act as a living
    documentation for methods. If we don't declare types of parameters, as in the
    preceding method, the sum (1,"2") will also become a valid method call, and worse,
    it returns an unexpected result without any exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A method call in Groovy can omit the parenthesis is many cases. Both of the
    following cases are valid method calls.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Default values of parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Many a time, we want to make a parameter optional by providing a default value
    so that if the caller does not provide the value, the default value will be used.
    Take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: If we provide the value of the `by` parameter that will be used, the default
    value `2` will be assumed for the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Methods with map parameters/named parameters
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Groovy does not support named parameters such as Python, but Map provides a
    very close approximation to the same functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we expect the map to contain keys `a` and `b`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On line number 2 and 3, notice the elvis operator `?:`, which returns the left
    hand side value, if value exists and is *truthy*; otherwise returns the right
    hand side (default) value. It is basically short hand for the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this method can be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'We can omit the square brackets (`[]`) because maps have special support in
    the method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it clearly looks like the named parameters. The order of parameters is
    not important and all the parameters need not be passed. Also, the parenthesis
    wrapping is optional, just like any method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Methods with varags
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Like in Java, varags are denoted by `...`, but providing the type is optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, numbers are arrays, which have the `collect` method
    that accepts a closure and transforms each element of the collection in order
    to produce a new collection. In this case, we transform numbers in the collection
    of squares. Finally, we use the in-built sum method to sum all the squares.
  prefs: []
  type: TYPE_NORMAL
- en: Methods with closure params
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Closures are important and, hence, Groovy has a special syntax for closures
    if the closure is the last parameter of a method signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, this method can be called as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Out of these, the third one is the special syntactical support in which the
    parenthesis just wraps the other parameters, while the closure is written outside
    the parenthesis, as if it were a method body.
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Classes in Groovy are declared just like Java classes, but with a lot lesser
    ceremony. Classes are public by default. They can inherit from other classes using
    `extends` or implementing interfaces using `implmenets`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the definition of a very simple class, `Person`, having two
    properties, `name` and `age`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using the `def` for properties, we can use more specific types.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In addition to the default constructor, classes in Groovy get a special constructor,
    which takes the map of properties of the class. Here is how we use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have created the `person` object using the special
    constructor. The parameters are key-value pairs where the keys are the name of
    the properties in the class. The values provided for the keys will be set for
    the corresponding properties.
  prefs: []
  type: TYPE_NORMAL
- en: Properties
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Groovy has language-level support for properties. In the preceding class, `name`
    and `age`, unlike Java, are not just fields, but are also properties of the class
    with their getters and setters in place. Fields are private by default and their
    public accessors and mutators (getters and setters) are generated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can call the `getAge()`/`setAge()` and `getName()`/`setName()` methods on
    the `person` object that we created above. However, there is an even more succinct
    way to do so. We can access properties just as if they were public fields, but
    behind the scenes, Groovy routes it through the getters and setters. Let''s try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'It prints the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, on line number 1, `person.age` is actually a call to
    `person.getAge()` and, hence, it returns the age of the person. Then, we updated
    the age using `person.age` with an assignment operator and value on the right-hand
    side. We did not update the field, but it internally passes through the setter
    `setAge()`. This is only possible because groovy offers syntactical support for
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can provide our own getters and/or setter for the desired fields, which
    will take precedence over the generated one, but it is only necessary if we have
    some logic to write in those. For example, if we want to have one positive value
    of age to be set, then we can provide our own `setAge()` implementation, and this
    will be used whenever the property is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The support for properties results in the significant reduction of the boilerplate
    code from class definitions and enhances readability.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Properties are first-class citizens in Groovy. Going forward, whenever we refer
    to property, do not get confused between properties and fields.
  prefs: []
  type: TYPE_NORMAL
- en: Instance methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can add an instance and static methods to classes just like we do in Java:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The methods section, as we discussed above, did not use classes, but applied
    as-is for the methods inside classes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Scripts are classes**'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the methods that we discussed above were inside a class and they were
    not free-floating functions. As scripts get translated to classes transparently,
    it feels as if we were using functions.
  prefs: []
  type: TYPE_NORMAL
- en: I am sure you have enjoyed Groovy so far. There is a lot more to cover in Groovy,
    but we have to switch back our focus to Gradle. However, I hope to have generated
    enough curiosity about Groovy so that you can appreciate it as a language and
    explore more of it on your own. There are a few good resources included in the
    references section.
  prefs: []
  type: TYPE_NORMAL
- en: Another look at applying plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have learned about basic Groovy, let''s put it to use in the context
    of the Gradle build script. In earlier chapters, we have already seen the syntax
    of applying a plugin. It looked something as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look carefully, `apply` is a method call. We can wrap the parameters
    in the parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A method that takes in a map can pass key values just like named arguments.
    However, for a more clear representation of Map, we can wrap the parameters in
    `[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `apply` method is implicitly applied on the `project` object (we
    will soon see this in the upcoming sections in this chapter). So, we can also
    call it on the `project` object''s reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: So, from the preceding example, we can see that the statement that applies a
    plugin to project is merely a syntactic sugar to what is a method call on the
    `project` object. We are just writing Groovy code using Gradle API. Also, once
    we realize that, our perspective towards understanding the build script syntax
    changes for good.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle – an object-oriented build tool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we were to think of a build system in an object-oriented way, the following
    classes will immediately come to our minds:'
  prefs: []
  type: TYPE_NORMAL
- en: A `project` that represents a system that is being built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `task` that encapsulates pieces of build logics that need to be performed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, we are lucky. As we might expect, Gradle creates objects of both `project`
    and `task` types. These objects are accessible in our build script for us to customize.
    Of course, the underlying implementation is non-trivial and the API is very sophisticated.
  prefs: []
  type: TYPE_NORMAL
- en: A `project` object is a central piece of API that is exposed to and configured
    via the build scripts. A `project` object is available in the script such that
    the methods without object reference are intelligently invoked on the `project`
    object. We have just seen an example of this in the last section. Most of the
    build script syntax can be understood by just reading the project API.
  prefs: []
  type: TYPE_NORMAL
- en: The `task` objects are created for each task declared directly in the build
    file and also for plugins. We have already created a very simple task in [Chapter
    1](part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0 "Chapter 1. Running
    Your First Gradle Task"), *Running Your First Gradle Task* and used tasks coming
    from plugins in [Chapter 2](part0019_split_000.html#I3QM2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 2. Building Java Projects"), *Building Java Projects*, and [Chapter 3](part0024_split_000.html#MSDG2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 3. Building a Web Application"), *Building a Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we have seen, some tasks are already available in our build without us having
    to add a single line to our build file (such as the `help` task and the `tasks`
    task, and so on). Even for these tasks, we would have task objects.
  prefs: []
  type: TYPE_NORMAL
- en: We will soon see how and when these objects are created.
  prefs: []
  type: TYPE_NORMAL
- en: Build phases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Gradle build follows a very simple life cycle on every invocation. The build
    passes through three stages: initialization, configuration, and execution. When
    a `gradle` command is invoked, not all the code written in our build file executes
    sequentially from top to bottom. Only the blocks of code that are relevant to
    the current phase of the build are executed. Also, the build phase''s order determines
    when the block of code will execute. An example is the task configuration versus
    task execution. Understanding of these phases is important to correctly configure
    our build.'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle first figures out whether the current project has child projects or if
    it is the only project in the build. For multiprojects build, Gradle figures out
    which projects (or sub-module, as many prefer to call them) have to be included
    in the build. We will see multiproject builds in the next chapter. Gradle then
    creates a `Project` instance for the root project and for each of the child projects
    of a project. For single module projects that we have seen so far, there is not
    much to configure in this phase.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this phase, the build scripts of participating projects are evaluated against
    the corresponding project object that was created during the initialization phase.
    In the case of multimodule projects, evaluation happens in breadth-wise fashion,
    that is, all the sibling projects will be evaluated and configured before child
    projects. However, this behavior is configurable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that executing the scripts does not mean that the tasks are also executed.
    To quickly verify this, we can just put a `println` statement in the `build.gradle`
    file and also create a task that prints a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We would see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In fact, choose any in-built task as well, such as `help`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We would still see our `build script is evaluated` message before any task is
    executed. Why is that?
  prefs: []
  type: TYPE_NORMAL
- en: When a script is evaluated, all the statements in the script are executed sequentially.
    That's why the `println` statement at the root level gets executed. A task action,
    if you notice, is actually a closure; hence, it is only attached to a task during
    the statement execution. However, the closure itself is not executed yet. The
    statements inside the action closure executes only if the task is executed, which
    happens only in the next phase.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks are only configured during this stage. No matter what tasks are going
    to be called, all tasks will be configured. Gradle prepares a **Directed Acyclic
    Graph** (**DAG**) representation of the tasks to determine the task dependency
    and execution order.
  prefs: []
  type: TYPE_NORMAL
- en: Execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this phase, Gradle figures out which tasks need to be run based on the parameters
    such as task names passed as command line arguments and the current directory.
    This is where tasks' actions will be performed. Hence, here, the action closures
    will actually execute if the task is to run.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On subsequent invocations, Gradle intelligently determines which tasks need
    to actually run and which can be skipped. For example, for a compile task, there
    is no point in compiling again if there is no change in the source file after
    the last build. In such a case, the execution may be skipped. We can see such
    tasks in the output tagged as `UP-TO-DATE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding output, as there was no change from the previous build, Gradle
    actually skipped every task. However, this will not happen for a custom task that
    we write, unless we tell Gradle the logic for figuring out whether the task needs
    execution or not.
  prefs: []
  type: TYPE_NORMAL
- en: Life cycle callbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle provides various hooks for executing code at various points during life
    cycle events. We can implement callback interfaces or provide callback closure
    to DSL in the build script. For example, we can listen for events such as the
    before and after project evaluation using the `beforeEvaluate` and `afterEvaluate`
    methods on `project`. We are not going to look at them individually, but the `Project`
    and `Gradle` (the interface name is not to be confused with the tool's name itself)
    APIs and the DSL documentation is the right place to check out the available callbacks,
    if we feel the need to implement life cycle callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Gradle Project API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed earlier, Gradle creates a `project` object for each `build.gradle`
    for us during the initialization phase. This object is available in our build
    scripts using the `project` reference. Being a central piece of API, there are
    numerous methods and properties available on this object.
  prefs: []
  type: TYPE_NORMAL
- en: Project methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have been using the project API even without realizing that we are calling
    methods on the `project` object. Based on a few governing rules, all the top-level
    method calls in the build scripts are called on a project object if no explicit
    reference is provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the very simple build file from [Chapter 1](part0015_split_000.html#E9OE2-e78ecbb3ac0544f19c59f96d594821c0
    "Chapter 1. Running Your First Gradle Task"), *Running Your First Gradle Task*
    to use the project reference for method calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'As we saw earlier in this chapter, `apply` is the method on the `project`.
    The so-called `dependencies` block is actually a method named `dependencies()`
    on `project` that accepts a closure. It is true for the `repositories` section
    as well. We can add parenthesis around the closure block to make it look like
    a plain old method call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: There are many more interesting methods on this object, which we will see in
    the upcoming sections and chapters, again, with or without explicit reference
    to the `project` object.
  prefs: []
  type: TYPE_NORMAL
- en: Project properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several properties available on the `project` object. Some properties
    are read-only properties, such as `name`, `path`, `parent`, and so on, while others
    are both readable and writable.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can set `project.description` to provide a description of our
    project. We can use the `project.version` property to set the version of the project.
    This version will be used by other tasks such as `Jar` to include a version number
    in the produced artifact.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We cannot change the `project.name` from the `build.gradle` file, but we can
    use `settings.gradle` in the same project to set the project name. We will see
    this file in more detail when we learn about multi-project builds.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from directly accessing a property by its name, we can access properties
    using the following methods on the `project` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check whether a property exists, use the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the value of a property for a given property name, use the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'To set the value of a property for a given property name, use the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s create a `build.gradle` file with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: As seen earlier, in Groovy, we can use the `property = value` syntax to call
    a setter. We are setting the `description` and `version` properties on the `project`
    object. Then, we add a task with the task action that prints the version using
    the `project` reference and `description` using the `property()` method on the
    `project` object.
  prefs: []
  type: TYPE_NORMAL
- en: The properties that we have seen above must exist on the project, otherwise
    build fails with a `Could not find property …` message.
  prefs: []
  type: TYPE_NORMAL
- en: Extra properties on a project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Gradle makes it very easy to store user-defined properties on a project, while
    still being able to enjoy the niceties of project properties'' syntax. All we
    have to do is to use the `ext` namespace to assign a value to a custom property.
    Then, this property can be accessed on a project just like regular project properties.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we declared a custom property called `abc` and assigned
    it the value `123`. We did not use the `project` reference as it is implicitly
    available at the script root level. In the task action, we printed it first using
    a project reference directly, just as if it were a property on `Project`. Then,
    we accessed using the `property()` method and also using the `project.ext` reference.
    Note that inside tasks' action closure, we should use the `project` reference
    to avoid any ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: Extra properties will be accessible in the sub-projects (modules). Extra properties
    can be set on other objects as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have just used the local variable by declaring it with `def`. However,
    such variables are not accessible outside the lexical scope. Also, they are not
    queriable.
  prefs: []
  type: TYPE_NORMAL
- en: Although we have looked at a few methods and properties, it's impractical to
    cover all of those here; hence, it is worth spending some time reading the API
    and the DSL documentation of the `project` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen so far, a `task` is a named action that performs some build
    logic. It's a unit of build work. For example, `clean`, `compile`, `dist`, and
    so on, are typical build tasks that easily come to our mind if we have to write
    tasks for our project. Tasks are more or less analogous to Ant's targets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way to create a task is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Before we go any further with tasks, let's take a moment to ponder about task
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: We used the `taskName` task form of a statement.
  prefs: []
  type: TYPE_NORMAL
- en: If we rewrite it as a `task (taskName)`, it will immediately look like the method
    call.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding method, as we might have already guessed by now, is available
    on the project object.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we could write one of the following as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '`project.task "myTask"`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`project.task("myTask")`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Notice that in the later examples we had to pass the task name as a string.
    The `task taskName` is a special form where we can use `taskName` as a literal
    instead of string. This is done by Groovy AST transformation magic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The project has several flavors of a task method to create a task object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: However, in essence, we may pass some key values as named parameters while creating
    a task and a configuration closure to configure the task.
  prefs: []
  type: TYPE_NORMAL
- en: We are essentially creating an object of the type `Task` (the exact class name
    is not important right now). We can query the properties and call methods on this
    object. Gradle nicely makes this `task` object available for use. Behind the nice
    DSL, we are actually writing a script that creates the build logic in a nice object-oriented
    way.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching actions to a task
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `Task` object, such as the one created above, does not do much. In fact, there
    is no action attached to it. We need to attach actions to a `Task` object for
    Gradle to perform those actions when a task is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `Task` object has a method called `doLast`, which accepts a closure. Gradle
    ensures that all the closures passed to this methods are executed in the order
    they were passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'What we can do now is call `doLast` once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, in an alternate syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'There are multiple ways to add a `doLast` logic to a task, but the most idiomatic,
    and perhaps a terse way is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Just like the `Project` object, we have the `Task` object on which methods and
    properties are accessible. However, unlike the `Project` object, it is not implicitly
    available at the top level in the script, but only inside the task’s configuration
    scope. Also, intuitively, we can say that there will be multiple `Task` objects
    per `build.gradle`. We will see the various ways to access the `Task` object later.
  prefs: []
  type: TYPE_NORMAL
- en: Task flow control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tasks within a project may have a dependency on each other. In this section,
    we will see different kinds of relationships that may exist within tasks of a
    project.
  prefs: []
  type: TYPE_NORMAL
- en: dependsOn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are tasks whose execution is dependent on the other task''s successful
    completion. For example, for creating a distributable JAR file, the code should
    have been compiled first and the "class" files should already exist. In such a
    case, we don''t want the user to explicitly specify all the tasks and their order
    from the command line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'This is error-prone. We may forget to include one task, or the ordering may
    become complicated if there are multiple tasks that are dependent on the successful
    completion of the previous tasks. It is desirable to be able to specify if a:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: finalizedBy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also declare that, if a task is called, it should be followed by another
    task, even if another task is not explicitly called. This is in contrast to `dependsOn`,
    where another task is executed before the called task. In the case of `finalizedBy`,
    another task is executed after the execution of the called task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: onlyIf
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can specify a condition and if it is satisfied, the task will be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: mustRunAfter and shouldRunAfter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are times when we just want to order tasks in a particular fashion if
    this relationship is not exactly the same as `dependsOn`. For example, if we execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Then, unrelated tasks will be executed in the order they were specified on the
    command line, which in this case doesn't make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a case, we may add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: This tells Gradle that, if both the tasks are there in the task graph, then
    the `build` must run after the `clean` is run. Here, build does not depend on
    clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between `shouldRunAfter` and `mustRunAfter` is that the former
    is more suggestive to Gradle, but doesn''t enforce Gradle to follow the ordering
    all the time. In the following two cases, `shouldRunAfter` may not be honored
    by Gradle:'
  prefs: []
  type: TYPE_NORMAL
- en: In the case when it introduces cyclic ordering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of parallel execution, when only the `shouldRunAfter` task has not
    yet successfully completed and other dependencies are satisfied, then `shouldRunAfter`
    will be ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating tasks dynamically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the beauties of Gradle is that we can create tasks dynamically as well.
    What this means is that the name and the logic of task is not completely known
    while writing the build, but depending on some variable parameter, the tasks will
    be automatically added to our Gradle project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to understand with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding contrived examples, we are creating and adding ten tasks dynamically
    to our build. Although all of them just print the task number, the ability to
    dynamically create and add tasks to our project is extremely powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Setting default tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have always been calling the `gradle` command line interface with
    the task name(s). This is kind of repetitive in nature, especially during development,
    and a tool such as Gradle gets us covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: It is wise to set default tasks so that if we don't specify any task name, the
    set tasks are executed by default.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, running `gradle` from the command line without any
    arguments runs the default tasks one after another in the sequence specified in
    the `defaultTasks`.
  prefs: []
  type: TYPE_NORMAL
- en: Task types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tasks that we have seen so far were ad-hoc in nature. We had to write the
    code for the task action that needs to be performed whenever the task executes.
    However, no matter which project we are building, there are many tasks for which
    the logic of task action need not change if we have the capability to make some
    configuration changes to the existing logic. For example, when you copy files,
    only the source, target, and inclusion/exclusion patterns change, but the actual
    logic of how to copy files from one location to another honoring the inclusion/exclusion
    patterns stays the same. So, if there are two copy-like tasks required in a project,
    let's say `copyDocumentation` and `deployWar`, would we really want to write an
    entire logic to copy the selected files twice?
  prefs: []
  type: TYPE_NORMAL
- en: This would be okay for very small builds (such as the examples in our chapter),
    but the approach does not scale well. If we keep on writing task actions to perform
    these mundane operations, then our build scripts will quickly bloat into an unmanageable
    state.
  prefs: []
  type: TYPE_NORMAL
- en: Custom task type is Gradle's solution to abstract out reusable build logic into
    custom task classes, which expose the input/output configuration variables on
    the task object. This helps us tune a typed task to suit our specific needs. This
    helps us keep the common build logic reusable and testable.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem with ad-hoc task action is that it's imperative in nature. For
    the sake of flexibility of the tool, Gradle allows us to imperatively script custom
    logic in build scripts. However, excessive usage of imperative code in our build
    scripts makes the build script unmaintainable. Gradle should be used in a declarative
    manner as much as possible. An imperative logic should be encapsulated within
    a custom task class while exposing the task configuration for the user to configure.
    In Gradle's terminology, custom task classes are called **enhanced tasks**.
  prefs: []
  type: TYPE_NORMAL
- en: Custom task types act as a template with some sensible defaults for a common
    build logic. We still need to declare a task in our build, but we just tell Gradle
    the type of this task and configure the settings of this task type, instead of
    writing the entire task action block again. Gradle already ships with many custom
    task types; for example, `Copy`, `Exec`, `Delete`, `Jar`, `Sync`, `Test`, `JavaCompile`,
    `Zip`, and so on. We can easily write our own enhanced tasks as well. We will
    very briefly see both the scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Using task types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can configure a task that is of type `Copy` using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the first important difference is that we are passing
    a key `type` with the value as the custom task's class name, which is `Copy` in
    this case. Also, notice that there is no `doLast` or indirection (`<<`) operator.
    The closure that we are passing to this task actually gets executed in the configuration
    phase of build. The method calls inside the closure are delegated to the implicitly
    available `task` object, which is being configured. We have not written any logic
    here, but have just provided the configuration to a task whose type is `Copy`.
    It is always worth taking a look at the available custom tasks before we go ahead
    with writing ad-hoc task actions.
  prefs: []
  type: TYPE_NORMAL
- en: Creating task types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we look back now, the code we have been writing for our task actions for
    our sample tasks was mostly a `println` statement that would print the given message
    on `System.out`. Now, just imagine that we found `System.out` doesn't fit our
    bill, and we should rather use text files to print the message from the tasks.
    We would need to go through all the tasks and change the implementation to write
    to a file instead of `println`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a better way to handle such changing requirement. We can leverage
    the capability of the task type here by providing our own task type. Let''s put
    the following code in our `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: We first created a class (which will be our task type) that extends `DefaultTask`,
    which is already defined in Gradle.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we declared a configurable input to our task using `@Input` on the property
    named `message`. The consumer of our task can configure this property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we used the `@TaskAction` annotation on the `print` method. This method
    is executed when our task is called. It just uses `println` to print the `message`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we declared the three tasks; all using different ways to configure our
    task. Notice the absence of any task action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we applied task flow control techniques to declare task dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we run the `thanks` task now, we can see the expected output, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'A few points to note here are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to change the implementation of our printing logic, there is only
    one place where we need to do the change, the `print` method of our custom task
    class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tasks using task types are used and they work just like any other tasks.
    They can also have task actions closure using `doLast {}`, `<< {}`, but it is
    usually not required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next sections mention some of the useful references for Groovy.
  prefs: []
  type: TYPE_NORMAL
- en: Groovy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a plethora of online reference material available for Groovy. We could
    start at:'
  prefs: []
  type: TYPE_NORMAL
- en: For further reading, refer to Groovy's online documentation at [http://www.groovy-lang.org/documentation.html](http://www.groovy-lang.org/documentation.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More references of Groovy resources are available at [https://github.com/kdabir/awesome-groovy](https://github.com/kdabir/awesome-groovy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a list of books on Groovy:'
  prefs: []
  type: TYPE_NORMAL
- en: The *Groovy in Action* book is available at [https://www.manning.com/books/groovy-in-action-second-edition](https://www.manning.com/books/groovy-in-action-second-edition).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Groovy Cookbook* is available at [https://www.packtpub.com/application-development/groovy-2-cookbook](https://www.packtpub.com/application-development/groovy-2-cookbook).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Programming Groovy 2* book is available at [https://pragprog.com/book/vslg2/programming-groovy-2](https://pragprog.com/book/vslg2/programming-groovy-2).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gradle API and DSL used in this chapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradle's official API and DSL documentation is a good place to explore and learn
    more about various classes discussed in this chapter. These APIs and DSLs are
    very rich and deserve our reading time.
  prefs: []
  type: TYPE_NORMAL
- en: '`Project`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The API documentation: [http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html](http://gradle.org/docs/current/javadoc/org/gradle/api/Project.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The DSL documentation: [http://gradle.org/docs/current/dsl/org.gradle.api.Project.html](http://gradle.org/docs/current/dsl/org.gradle.api.Project.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Gradle` (the interface):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The API documentation: [http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html](http://gradle.org/docs/current/javadoc/org/gradle/api/invocation/Gradle.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The DSL documentation: [http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html](http://gradle.org/docs/current/dsl/org.gradle.api.invocation.Gradle.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The API documentation: [http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html](http://www.gradle.org/docs/current/javadoc/org/gradle/api/Task.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The DSL documentation: [http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html](http://www.gradle.org/docs/current/dsl/org.gradle.api.Task.html)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter with a quick feature overview of Groovy language, covering
    some of the topics that would be helpful for us to understand Gradle's syntax
    and write better build scripts. Then, we looked at the API that Gradle exposes
    to our build scripts and how to consume the API via the DSL. We also covered the
    Gradle build phases. Then, we looked at the way in which tasks can be created,
    configured, have dependencies between, and run by default.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this chapter, we should be able to comprehend the Gradle DSL,
    rather than just trying to remember the syntax. We are now in a position to read
    and understand any given Gradle build file, and we should now be able to write
    custom tasks with ease.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter might feel a little long and complex. We should take some time
    out to practise and reread the sections that are not clear and also look up the
    online references given throughout the chapter. The chapters ahead will be smooth
    sailing.
  prefs: []
  type: TYPE_NORMAL
