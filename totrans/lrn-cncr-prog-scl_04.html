<html><head></head><body><div id="book-columns"><div id="book-inner"><div class="chapter" title="Chapter 4.  Asynchronous Programming with Futures and Promises"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/><span class="koboSpan" id="kobo.1.1">Chapter 4.    Asynchronous Programming with Futures and Promises   </span></h1></div></div></div><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"><span class="koboSpan" id="kobo.2.1"> </span></td><td valign="top"><p><span class="emphasis"><em><span class="koboSpan" id="kobo.3.1">Programming in a functional style makes the state presented to your code explicit, which makes it much easier to reason about, and, in a completely pure system, makes thread race conditions impossible.</span></em></span></p></td><td valign="top"><span class="koboSpan" id="kobo.4.1"> </span></td></tr><tr><td valign="top"><span class="koboSpan" id="kobo.5.1"> </span></td><td colspan="2" align="right" valign="top" style="text-align: center"><span class="koboSpan" id="kobo.6.1">--</span><span class="attribution"><span class="emphasis"><em><span class="koboSpan" id="kobo.7.1">John Carmack</span></em></span></span></td></tr></table></div><p><span class="koboSpan" id="kobo.8.1">In the examples of the previous chapters, we often dealt with blocking computations. </span><span class="koboSpan" id="kobo.8.2">We have seen that blocking synchronization can have negative effects: it can cause deadlocks, starve thread pools, or break lazy value initialization. </span><span class="koboSpan" id="kobo.8.3">While, in some cases, blocking is the right tool for the job, in many cases we can avoid it. </span><span class="koboSpan" id="kobo.8.4">Asynchronous programming refers to the programming style in which executions occur independently of the main program flow. </span><span class="koboSpan" id="kobo.8.5">Asynchronous programming helps you to eliminate blocking instead of suspending the thread whenever a resource is not available; a separate computation is scheduled to proceed once the resource becomes available.</span></p><p><span class="koboSpan" id="kobo.9.1">In a way, many of the concurrency patterns seen so far support asynchronous programming; thread creation and scheduling execution context tasks can be used to start executing a computation concurrent to the main program flow. </span><span class="koboSpan" id="kobo.9.2">Still, using these facilities directly when avoiding blocking or composing asynchronous computations is not straightforward. </span><span class="koboSpan" id="kobo.9.3">In this chapter, we will focus on two abstractions in Scala that are specifically tailored for this task: futures and promises.</span></p><p><span class="koboSpan" id="kobo.10.1">More specifically, we will study the following topics:</span></p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.11.1">Starting asynchronous computations, and using </span><code class="literal"><span class="koboSpan" id="kobo.12.1">Future</span></code><span class="koboSpan" id="kobo.13.1"> objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.14.1">Installing callbacks that handle the results of asynchronous computations</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.15.1">Exception semantics of </span><code class="literal"><span class="koboSpan" id="kobo.16.1">Future</span></code><span class="koboSpan" id="kobo.17.1"> objects, and using the type </span><code class="literal"><span class="koboSpan" id="kobo.18.1">Try</span></code><span class="koboSpan" id="kobo.19.1"> </span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.20.1">Functional composition of </span><code class="literal"><span class="koboSpan" id="kobo.21.1">Future</span></code><span class="koboSpan" id="kobo.22.1"> objects</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.23.1">Using </span><code class="literal"><span class="koboSpan" id="kobo.24.1">Promise</span></code><span class="koboSpan" id="kobo.25.1"> objects to interface with callback-based APIs, implement future combinators, and support cancellation</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.26.1">Blocking threads inside asynchronous computations</span></li><li class="listitem" style="list-style-type: disc"><span class="koboSpan" id="kobo.27.1">Using the Scala </span><code class="literal"><span class="koboSpan" id="kobo.28.1">Async</span></code><span class="koboSpan" id="kobo.29.1"> library</span></li></ul></div><p><span class="koboSpan" id="kobo.30.1">In the next section, we will start by introducing the try </span><code class="literal"><span class="koboSpan" id="kobo.31.1">Future</span></code><span class="koboSpan" id="kobo.32.1"> , and show why it is useful.</span></p><div class="section" title="Futures"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/><span class="koboSpan" id="kobo.33.1">Futures</span></h1></div></div></div><p><span class="koboSpan" id="kobo.34.1">In earlier chapters, we learned that parallel executions in a concurrent program proceed on entities called </span><span class="strong"><strong><span class="koboSpan" id="kobo.35.1">threads</span></strong></span><span class="koboSpan" id="kobo.36.1">. </span><span class="koboSpan" id="kobo.36.2">At any point, the execution of a thread can be temporarily suspended, until a specific condition is fulfilled. </span><span class="koboSpan" id="kobo.36.3">When this happens, we say that the thread is blocked. </span><span class="koboSpan" id="kobo.36.4">Why do we block threads in the first place in concurrent programming? </span><span class="koboSpan" id="kobo.36.5">One of the reasons is that we have a finite amount of resources; multiple computations that share these resources sometimes need to wait. </span><span class="koboSpan" id="kobo.36.6">In other situations, a computation needs specific data to proceed, and if that data is not yet available, threads responsible for producing the data could be slow or the source of the data could be external to the program. </span><span class="koboSpan" id="kobo.36.7">A classic example is waiting for the data to arrive over the network. </span><span class="koboSpan" id="kobo.36.8">Let's assume that we have a </span><code class="literal"><span class="koboSpan" id="kobo.37.1">getWebpage</span></code><span class="koboSpan" id="kobo.38.1"> method, that given a </span><code class="literal"><span class="koboSpan" id="kobo.39.1">url</span></code><span class="koboSpan" id="kobo.40.1"> string with the location of the webpage, returns that webpage's contents:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.41.1">def getWebpage(url: String): String 
</span></pre><p><span class="koboSpan" id="kobo.42.1">The return type of the </span><code class="literal"><span class="koboSpan" id="kobo.43.1">getWebpage</span></code><span class="koboSpan" id="kobo.44.1"> method is </span><code class="literal"><span class="koboSpan" id="kobo.45.1">String</span></code><span class="koboSpan" id="kobo.46.1">; the method must return a string with the webpage's contents. </span><span class="koboSpan" id="kobo.46.2">Upon sending an HTTP request, though, the webpage's contents are not available immediately. </span><span class="koboSpan" id="kobo.46.3">It takes some time for the request to travel over the network to the server and back before the program can access the document. </span><span class="koboSpan" id="kobo.46.4">The only way for the method to return the contents of the webpage as a string value is to wait for the HTTP response to arrive. </span><span class="koboSpan" id="kobo.46.5">However, this can take a relatively long time from the program's point of view; even with a high-speed Internet connection, the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">getWebpage</span></code><span class="koboSpan" id="kobo.48.1"> method needs to wait. </span><span class="koboSpan" id="kobo.48.2">Since the thread that called the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">getWebpage</span></code><span class="koboSpan" id="kobo.50.1"> method cannot proceed without the contents of the webpage, it needs to pause its execution; therefore, the only way to correctly implement the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">getWebpage</span></code><span class="koboSpan" id="kobo.52.1"> method is to block.</span></p><p><span class="koboSpan" id="kobo.53.1">We already know that blocking can have negative side-effects, so can we change the return value of the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">getWebpage</span></code><span class="koboSpan" id="kobo.55.1"> method to some special value that can be returned immediately? </span><span class="koboSpan" id="kobo.55.2">The answer is yes. </span><span class="koboSpan" id="kobo.55.3">In Scala, this special value is called a </span><span class="strong"><strong><span class="koboSpan" id="kobo.56.1">future</span></strong></span><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">A future is a placeholder, that is, a memory location for the value. </span><span class="koboSpan" id="kobo.57.3">This placeholder does not need to contain a value when the future is created; the value can be placed into the future eventually by the </span><code class="literal"><span class="koboSpan" id="kobo.58.1">getWebpage</span></code><span class="koboSpan" id="kobo.59.1"> method. </span><span class="koboSpan" id="kobo.59.2">We can change the signature of the </span><code class="literal"><span class="koboSpan" id="kobo.60.1">getWebpage</span></code><span class="koboSpan" id="kobo.61.1"> method to return a future as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.62.1">def getWebpage(url: String): Future[String] 
</span></pre><p><span class="koboSpan" id="kobo.63.1">Here, the </span><code class="literal"><span class="koboSpan" id="kobo.64.1">Future[String]</span></code><span class="koboSpan" id="kobo.65.1"> type means that the future object can eventually contain a </span><code class="literal"><span class="koboSpan" id="kobo.66.1">String</span></code><span class="koboSpan" id="kobo.67.1"> value. </span><span class="koboSpan" id="kobo.67.2">We can now implement the </span><code class="literal"><span class="koboSpan" id="kobo.68.1">getWebpage</span></code><span class="koboSpan" id="kobo.69.1"> method without blocking-we can start the HTTP request asynchronously and place the webpage's contents into the future when they become available. </span><span class="koboSpan" id="kobo.69.2">When this happens, we say that the </span><code class="literal"><span class="koboSpan" id="kobo.70.1">getWebpage</span></code><span class="koboSpan" id="kobo.71.1"> method completes the future. </span><span class="koboSpan" id="kobo.71.2">Importantly, after the future is completed with some value, that value can no longer change.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/><span class="koboSpan" id="kobo.72.1">Note</span></h3><p><span class="koboSpan" id="kobo.73.1">The </span><code class="literal"><span class="koboSpan" id="kobo.74.1">Future[T]</span></code><span class="koboSpan" id="kobo.75.1"> type encodes latency in the program; use it to encode values that will become available later during execution.</span></p></div></div><p><span class="koboSpan" id="kobo.76.1">This removes blocking from the </span><code class="literal"><span class="koboSpan" id="kobo.77.1">getWebpage</span></code><span class="koboSpan" id="kobo.78.1"> method, but it is not clear how the calling thread can extract the content of the future. </span><span class="koboSpan" id="kobo.78.2">Polling is one non-blocking way of extracting the content. </span><span class="koboSpan" id="kobo.78.3">In the polling approach, the calling thread calls a special method to block until the value becomes available. </span><span class="koboSpan" id="kobo.78.4">While this approach does not eliminate blocking, it transfers the responsibility of blocking from the </span><code class="literal"><span class="koboSpan" id="kobo.79.1">getWebpage</span></code><span class="koboSpan" id="kobo.80.1"> method to the caller thread. </span><span class="koboSpan" id="kobo.80.2">Java defines its own </span><code class="literal"><span class="koboSpan" id="kobo.81.1">Future</span></code><span class="koboSpan" id="kobo.82.1"> type to encode values that will become available later. </span><span class="koboSpan" id="kobo.82.2">However, as a Scala developer, you should use Scala's futures instead; they allow additional ways of handling future values and avoid blocking, as we will soon see.</span></p><p><span class="koboSpan" id="kobo.83.1">When programming with futures in Scala, we need to distinguish between </span><span class="strong"><strong><span class="koboSpan" id="kobo.84.1">future values</span></strong></span><span class="koboSpan" id="kobo.85.1"> and </span><span class="strong"><strong><span class="koboSpan" id="kobo.86.1">future computations</span></strong></span><span class="koboSpan" id="kobo.87.1">. </span><span class="koboSpan" id="kobo.87.2">A future value of the type </span><code class="literal"><span class="koboSpan" id="kobo.88.1">Future[T]</span></code><span class="koboSpan" id="kobo.89.1">  denotes some value of type </span><code class="literal"><span class="koboSpan" id="kobo.90.1">T</span></code><span class="koboSpan" id="kobo.91.1">  in the program that might not be currently available, but could become available later. </span><span class="koboSpan" id="kobo.91.2">Usually, when we say a future, we really mean a future value. </span><span class="koboSpan" id="kobo.91.3">In the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">scala.concurrent</span></code><span class="koboSpan" id="kobo.93.1"> package, futures are represented with the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">Future[T]</span></code><span class="koboSpan" id="kobo.95.1"> trait:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.96.1">trait Future[T] 
</span></pre><p><span class="koboSpan" id="kobo.97.1">By contrast, a future computation is an asynchronous computation that produces a future value. </span><span class="koboSpan" id="kobo.97.2">A future computation can be started by calling the </span><code class="literal"><span class="koboSpan" id="kobo.98.1">apply</span></code><span class="koboSpan" id="kobo.99.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.100.1">Future</span></code><span class="koboSpan" id="kobo.101.1"> companion object. </span><span class="koboSpan" id="kobo.101.2">This method has the following signature in the </span><code class="literal"><span class="koboSpan" id="kobo.102.1">scala.concurrent</span></code><span class="koboSpan" id="kobo.103.1"> package:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.104.1">def apply[T](b: =&gt;T)(implicit e: ExecutionContext): Future[T] 
</span></pre><p><span class="koboSpan" id="kobo.105.1">This method takes a by-name parameter of the type </span><code class="literal"><span class="koboSpan" id="kobo.106.1">T</span></code><span class="koboSpan" id="kobo.107.1"> . </span><span class="koboSpan" id="kobo.107.2">This is the body of the asynchronous computation that results in some value of type </span><code class="literal"><span class="koboSpan" id="kobo.108.1">T</span></code><span class="koboSpan" id="kobo.109.1">. </span><span class="koboSpan" id="kobo.109.2">It also takes an implicit </span><code class="literal"><span class="koboSpan" id="kobo.110.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.111.1"> parameter, which abstracts over where and when the thread gets executed, as we learned in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.112.1">Chapter 3</span></a><span class="koboSpan" id="kobo.113.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.114.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">Recall that Scala's implicit parameters can either be specified when calling a method, in the same way as normal parameters, or they can be left out-in this case, the Scala compiler searches for a value of the </span><code class="literal"><span class="koboSpan" id="kobo.116.1">ExecutionContext</span></code><span class="koboSpan" id="kobo.117.1"> type in the surrounding scope. </span><span class="koboSpan" id="kobo.117.2">Most </span><code class="literal"><span class="koboSpan" id="kobo.118.1">Future</span></code><span class="koboSpan" id="kobo.119.1"> methods take an implicit execution context. </span><span class="koboSpan" id="kobo.119.2">Finally, the </span><code class="literal"><span class="koboSpan" id="kobo.120.1">Future.apply</span></code><span class="koboSpan" id="kobo.121.1"> method returns a future of the type </span><code class="literal"><span class="koboSpan" id="kobo.122.1">T</span></code><span class="koboSpan" id="kobo.123.1">. </span><span class="koboSpan" id="kobo.123.2">This future is completed with the value resulting from the asynchronous computation, </span><code class="literal"><span class="koboSpan" id="kobo.124.1">b</span></code><span class="koboSpan" id="kobo.125.1">.</span></p><div class="section" title="Starting future computations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec31"/><span class="koboSpan" id="kobo.126.1">Starting future computations</span></h2></div></div></div><p><span class="koboSpan" id="kobo.127.1">Let's see how to start a future computation in an example. </span><span class="koboSpan" id="kobo.127.2">We first import the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.128.1">scala.concurrent</span></code><span class="koboSpan" id="kobo.129.1"> package. </span><span class="koboSpan" id="kobo.129.2">We then import the </span><code class="literal"><span class="koboSpan" id="kobo.130.1">global</span></code><span class="koboSpan" id="kobo.131.1"> execution context from the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">Implicits</span></code><span class="koboSpan" id="kobo.133.1"> object. </span><span class="koboSpan" id="kobo.133.2">This makes sure that future computations execute on </span><code class="literal"><span class="koboSpan" id="kobo.134.1">global</span></code><span class="koboSpan" id="kobo.135.1">, the default execution context you can use in most cases:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.136.1">import scala.concurrent._ 
import ExecutionContext.Implicits.global 
object FuturesCreate extends App { 
  Future { log("the future is here") } 
  log("the future is coming") 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.137.1">The order in which the </span><code class="literal"><span class="koboSpan" id="kobo.138.1">log</span></code><span class="koboSpan" id="kobo.139.1"> method calls (in the future computation and the main thread) execute is nondeterministic. </span><span class="koboSpan" id="kobo.139.2">The </span><code class="literal"><span class="koboSpan" id="kobo.140.1">Future</span></code><span class="koboSpan" id="kobo.141.1"> singleton object followed by a block is syntactic sugar for calling the </span><code class="literal"><span class="koboSpan" id="kobo.142.1">Future.apply</span></code><span class="koboSpan" id="kobo.143.1"> method. </span><span class="koboSpan" id="kobo.143.2">The </span><code class="literal"><span class="koboSpan" id="kobo.144.1">Future.apply</span></code><span class="koboSpan" id="kobo.145.1"> method acts similarly to the </span><code class="literal"><span class="koboSpan" id="kobo.146.1">execute</span></code><span class="koboSpan" id="kobo.147.1"> statement from </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.148.1">Chapter 3</span></a><span class="koboSpan" id="kobo.149.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.150.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.151.1">. </span><span class="koboSpan" id="kobo.151.2">The difference is that the </span><code class="literal"><span class="koboSpan" id="kobo.152.1">Future.apply</span></code><span class="koboSpan" id="kobo.153.1"> method returns a future value. </span><span class="koboSpan" id="kobo.153.2">We can poll this future value until it is completed. </span><span class="koboSpan" id="kobo.153.3">In the following example, we can use the </span><code class="literal"><span class="koboSpan" id="kobo.154.1">scala.io.Source</span></code><span class="koboSpan" id="kobo.155.1"> object to read the contents of our </span><code class="literal"><span class="koboSpan" id="kobo.156.1">build.sbt</span></code><span class="koboSpan" id="kobo.157.1"> file in a future computation. </span><span class="koboSpan" id="kobo.157.2">The main thread calls the </span><code class="literal"><span class="koboSpan" id="kobo.158.1">isCompleted</span></code><span class="koboSpan" id="kobo.159.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.160.1">buildFile</span></code><span class="koboSpan" id="kobo.161.1"> future value, returned from the future computation. </span><span class="koboSpan" id="kobo.161.2">Chances are that the build file was not read so rapid, so </span><code class="literal"><span class="koboSpan" id="kobo.162.1">isCompleted</span></code><span class="koboSpan" id="kobo.163.1"> returns </span><code class="literal"><span class="koboSpan" id="kobo.164.1">false</span></code><span class="koboSpan" id="kobo.165.1">. </span><span class="koboSpan" id="kobo.165.2">After 250 milliseconds, the main thread calls </span><code class="literal"><span class="koboSpan" id="kobo.166.1">isCompleted</span></code><span class="koboSpan" id="kobo.167.1"> again, and this time </span><code class="literal"><span class="koboSpan" id="kobo.168.1">isCompleted</span></code><span class="koboSpan" id="kobo.169.1"> returns </span><code class="literal"><span class="koboSpan" id="kobo.170.1">true</span></code><span class="koboSpan" id="kobo.171.1">. </span><span class="koboSpan" id="kobo.171.2">Finally, the main thread calls the </span><code class="literal"><span class="koboSpan" id="kobo.172.1">value</span></code><span class="koboSpan" id="kobo.173.1"> method, which returns the contents of the build file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.174.1">import scala.io.Source 
object FuturesDataType extends App { 
  val buildFile: Future[String] = Future { 
    val f = Source.fromFile("build.sbt") 
    try f.getLines.mkString("\n") finally f.close() 
  } 
  log(s"started reading the build file asynchronously") 
  log(s"status: ${buildFile.isCompleted}") 
  Thread.sleep(250) 
  log(s"status: ${buildFile.isCompleted}") 
  log(s"value: ${buildFile.value}") 
} 
</span></pre><p><span class="koboSpan" id="kobo.175.1">In this example, we used polling to obtain the value of the future. </span><span class="koboSpan" id="kobo.175.2">The </span><code class="literal"><span class="koboSpan" id="kobo.176.1">Future</span></code><span class="koboSpan" id="kobo.177.1"> singleton object's polling methods are non-blocking, but they are also nondeterministic; </span><code class="literal"><span class="koboSpan" id="kobo.178.1">isCompleted</span></code><span class="koboSpan" id="kobo.179.1"> will repeatedly return </span><code class="literal"><span class="koboSpan" id="kobo.180.1">false</span></code><span class="koboSpan" id="kobo.181.1"> until the future is completed. </span><span class="koboSpan" id="kobo.181.2">Importantly, completion of the future is in a happens-before relationship with the polling calls. </span><span class="koboSpan" id="kobo.181.3">If the future completes before the invocation of the polling method, then its effects are visible to the thread after polling completes.</span></p><p><span class="koboSpan" id="kobo.182.1">Shown graphically, polling looks like the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.183.1"><img src="graphics/image_04_001.jpg" alt="Starting future computations"/></span></div><p><span class="koboSpan" id="kobo.184.1">Polling diagram</span></p><p><span class="koboSpan" id="kobo.185.1">Polling is like calling your potential employer every five minutes to ask if you're hired. </span><span class="koboSpan" id="kobo.185.2">What you really want to do is hand in a job application and then apply for other jobs, instead of busy-waiting for the employer's response. </span><span class="koboSpan" id="kobo.185.3">Once your employer decides to hire you, they will give you a call on the phone number you left them. </span><span class="koboSpan" id="kobo.185.4">We want futures to do the same; when they are completed, they should call a specific function we left for them. </span><span class="koboSpan" id="kobo.185.5">This is the topic of the next section.</span></p></div><div class="section" title="Future callbacks"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec32"/><span class="koboSpan" id="kobo.186.1">Future callbacks</span></h2></div></div></div><p><span class="koboSpan" id="kobo.187.1">A callback is a function that is called once its arguments become available. </span><span class="koboSpan" id="kobo.187.2">When a Scala future takes a callback, it eventually calls that callback. </span><span class="koboSpan" id="kobo.187.3">However, the future does not call the callback before this future is completed with some value.</span></p><p><span class="koboSpan" id="kobo.188.1">Let's assume that we need to look up details of the URL specification from the W3 consortium. </span><span class="koboSpan" id="kobo.188.2">We are interested in all the occurrences of the </span><code class="literal"><span class="koboSpan" id="kobo.189.1">telnet</span></code><span class="koboSpan" id="kobo.190.1"> keyword. </span><span class="koboSpan" id="kobo.190.2">The URL specification is available as a text document at </span><a class="ulink" href="https://www.w3.org/"><span class="koboSpan" id="kobo.191.1">https://www.w3.org/</span></a><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">We can use the </span><code class="literal"><span class="koboSpan" id="kobo.193.1">scala.io.Source</span></code><span class="koboSpan" id="kobo.194.1"> object to fetch the contents of the specification, and use futures in the </span><code class="literal"><span class="koboSpan" id="kobo.195.1">getUrlSpec</span></code><span class="koboSpan" id="kobo.196.1"> method to asynchronously execute the HTTP request. </span><span class="koboSpan" id="kobo.196.2">The </span><code class="literal"><span class="koboSpan" id="kobo.197.1">getUrlSpec</span></code><span class="koboSpan" id="kobo.198.1"> method first calls the </span><code class="literal"><span class="koboSpan" id="kobo.199.1">fromURL</span></code><span class="koboSpan" id="kobo.200.1"> method to obtain a </span><code class="literal"><span class="koboSpan" id="kobo.201.1">Source</span></code><span class="koboSpan" id="kobo.202.1"> object with the text document. </span><span class="koboSpan" id="kobo.202.2">It then calls </span><code class="literal"><span class="koboSpan" id="kobo.203.1">getLines</span></code><span class="koboSpan" id="kobo.204.1"> to get a list of separate lines in the document:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.205.1">object FuturesCallbacks extends App { 
  def getUrlSpec(): Future[List[String]] = Future { 
    val url = "http://www.w3.org/Addressing/URL/url-spec.txt" 
    val f = Source.fromURL(url) 
    try f.getLines.toList finally f.close() 
  } 
  val urlSpec: Future[List[String]] = getUrlSpec() 
</span></pre><p><span class="koboSpan" id="kobo.206.1">To find the lines in the </span><code class="literal"><span class="koboSpan" id="kobo.207.1">urlSpec</span></code><span class="koboSpan" id="kobo.208.1"> future that contains the </span><code class="literal"><span class="koboSpan" id="kobo.209.1">telnet</span></code><span class="koboSpan" id="kobo.210.1"> keyword, we use the </span><code class="literal"><span class="koboSpan" id="kobo.211.1">find</span></code><span class="koboSpan" id="kobo.212.1"> method which takes a list of lines and a keyword and returns a string containing the matches:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.213.1">  def find(lines: List[String], keyword: String): String = lines.zipWithIndex collect { 
      case (line, n) if line.contains(keyword) =&gt; (n, line) 
    } mkString("\n") 
</span></pre><p><span class="koboSpan" id="kobo.214.1">The </span><code class="literal"><span class="koboSpan" id="kobo.215.1">find</span></code><span class="koboSpan" id="kobo.216.1"> method takes a </span><code class="literal"><span class="koboSpan" id="kobo.217.1">List[String]</span></code><span class="koboSpan" id="kobo.218.1"> parameter, but </span><code class="literal"><span class="koboSpan" id="kobo.219.1">urlSpec</span></code><span class="koboSpan" id="kobo.220.1"> is of the </span><code class="literal"><span class="koboSpan" id="kobo.221.1">Future[List[String]]</span></code><span class="koboSpan" id="kobo.222.1"> type. </span><span class="koboSpan" id="kobo.222.2">We cannot pass the </span><code class="literal"><span class="koboSpan" id="kobo.223.1">urlSpec</span></code><span class="koboSpan" id="kobo.224.1"> future directly to the </span><code class="literal"><span class="koboSpan" id="kobo.225.1">find</span></code><span class="koboSpan" id="kobo.226.1"> method; and for a good reason, the value might not be available at the time when we call the </span><code class="literal"><span class="koboSpan" id="kobo.227.1">find</span></code><span class="koboSpan" id="kobo.228.1"> method.</span></p><p><span class="koboSpan" id="kobo.229.1">Instead, we install a callback to the future using the </span><code class="literal"><span class="koboSpan" id="kobo.230.1">foreach</span></code><span class="koboSpan" id="kobo.231.1"> method. </span><span class="koboSpan" id="kobo.231.2">Note that the equivalent of the </span><code class="literal"><span class="koboSpan" id="kobo.232.1">foreach</span></code><span class="koboSpan" id="kobo.233.1"> method is the </span><code class="literal"><span class="koboSpan" id="kobo.234.1">onSuccess</span></code><span class="koboSpan" id="kobo.235.1"> method, but it might be deprecated after Scala 2.11. </span><span class="koboSpan" id="kobo.235.2">This method takes a partial function that, given a value of the future, performs some action, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.236.1">  urlSpec foreach { 
    case lines =&gt; log(find(lines, "telnet")) 
  } 
  log("callback registered, continuing with other work") 
  Thread.sleep(2000) 
</span></pre><p><span class="koboSpan" id="kobo.237.1">Importantly, installing a callback is a non-blocking operation. </span><span class="koboSpan" id="kobo.237.2">The </span><code class="literal"><span class="koboSpan" id="kobo.238.1">log</span></code><span class="koboSpan" id="kobo.239.1"> statement in the main thread immediately executes after the callback is registered, but the </span><code class="literal"><span class="koboSpan" id="kobo.240.1">log</span></code><span class="koboSpan" id="kobo.241.1"> statement in the callback can be called much later. </span><span class="koboSpan" id="kobo.241.2">This is illustrated in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.242.1"><img src="graphics/image_04_002.jpg" alt="Future callbacks"/></span></div><p><span class="koboSpan" id="kobo.243.1">Callback diagram</span></p><p><span class="koboSpan" id="kobo.244.1">Note that the callback is not necessarily invoked immediately after the future is completed. </span><span class="koboSpan" id="kobo.244.2">Most execution contexts schedule a task to asynchronously process the callbacks. </span><span class="koboSpan" id="kobo.244.3">The same is true if the future is already completed when we try to install a callback.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/><span class="koboSpan" id="kobo.245.1">Note</span></h3><p><span class="koboSpan" id="kobo.246.1">After the future is completed, the callback is called </span><span class="emphasis"><em><span class="koboSpan" id="kobo.247.1">eventually</span></em></span><span class="koboSpan" id="kobo.248.1"> and independently from other callbacks on the same future. </span><span class="koboSpan" id="kobo.248.2">The specified execution context decides when and on which thread the callback gets executed.</span></p><p><span class="koboSpan" id="kobo.249.1">There is a happens-before relationship between completing the future and starting the callback.</span></p></div></div><p><span class="koboSpan" id="kobo.250.1">We are not limited to installing a single callback to the future. </span><span class="koboSpan" id="kobo.250.2">If we additionally want to find all the occurrences of the </span><code class="literal"><span class="koboSpan" id="kobo.251.1">password</span></code><span class="koboSpan" id="kobo.252.1"> keyword, we can install another callback:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.253.1">  urlSpec foreach { 
    case lines =&gt; log(find(lines, "password")) 
  } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.254.1">As an experienced Scala programmer, you might have heard about referential transparency. </span><span class="koboSpan" id="kobo.254.2">Roughly speaking, a function is referentially transparent if it does not execute any side effects such as variable assignment, modifying mutable collections, or writing to the standard output. </span><span class="koboSpan" id="kobo.254.3">Callbacks on futures have one very useful property. </span><span class="koboSpan" id="kobo.254.4">Programs using only the </span><code class="literal"><span class="koboSpan" id="kobo.255.1">Future.apply</span></code><span class="koboSpan" id="kobo.256.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.257.1">foreach</span></code><span class="koboSpan" id="kobo.258.1"> calls with referentially transparent callbacks are deterministic. </span><span class="koboSpan" id="kobo.258.2">For the same inputs, such programs will always compute the same results.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/><span class="koboSpan" id="kobo.259.1">Note</span></h3><p><span class="koboSpan" id="kobo.260.1">Programs composed from referentially transparent future computations and callbacks are deterministic.</span></p></div></div><p><span class="koboSpan" id="kobo.261.1">In the examples so far, we assumed that an asynchronous computation yielding a future always succeeds. </span><span class="koboSpan" id="kobo.261.2">However, computations occasionally fail and throw exceptions. </span><span class="koboSpan" id="kobo.261.3">We will study how to handle failures in asynchronous computations next.</span></p></div><div class="section" title="Futures and exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec33"/><span class="koboSpan" id="kobo.262.1">Futures and exceptions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.263.1">If a future computation throws an exception, then its corresponding future object cannot be completed with a value. </span><span class="koboSpan" id="kobo.263.2">Ideally, we would like to be notified when this happens. </span><span class="koboSpan" id="kobo.263.3">If you apply for a job and the employer decides to hire someone else, you would still like to receive a phone call. </span><span class="koboSpan" id="kobo.263.4">Otherwise, you might spend days sitting idly in front of your phone, waiting for the call from the recruiter.</span></p><p><span class="koboSpan" id="kobo.264.1">When a Scala future is completed, it can either be completed </span><span class="emphasis"><em><span class="koboSpan" id="kobo.265.1">successfully</span></em></span><span class="koboSpan" id="kobo.266.1"> or with a failure. </span><span class="koboSpan" id="kobo.266.2">When a future is completed with a failure, we also say that a future has </span><span class="emphasis"><em><span class="koboSpan" id="kobo.267.1">failed</span></em></span><span class="koboSpan" id="kobo.268.1">. </span><span class="koboSpan" id="kobo.268.2">To summarize all the different states of a future, we show the following state diagram. </span><span class="koboSpan" id="kobo.268.3">A future is created without any associated callbacks. </span><span class="koboSpan" id="kobo.268.4">Then, any number of callbacks </span><code class="literal"><span class="koboSpan" id="kobo.269.1">f1</span></code><span class="koboSpan" id="kobo.270.1">, </span><code class="literal"><span class="koboSpan" id="kobo.271.1">f2</span></code><span class="koboSpan" id="kobo.272.1">, ..., </span><code class="literal"><span class="koboSpan" id="kobo.273.1">fn</span></code><span class="koboSpan" id="kobo.274.1"> can be assigned to it. </span><span class="koboSpan" id="kobo.274.2">When the future is completed, it has either completed successfully or has failed. </span><span class="koboSpan" id="kobo.274.3">After that, the future's state no longer changes, and registering a callback immediately schedules it for execution.</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.275.1"><img src="graphics/image_04_003.jpg" alt="Futures and exceptions"/></span></div><p><span class="koboSpan" id="kobo.276.1">We now take a closer look at handling the failure case. </span><span class="koboSpan" id="kobo.276.2">The </span><code class="literal"><span class="koboSpan" id="kobo.277.1">foreach</span></code><span class="koboSpan" id="kobo.278.1"> method only accepts callbacks that handle values from a successfully completed future, so we need another method to install failure callbacks. </span><span class="koboSpan" id="kobo.278.2">This method is called </span><code class="literal"><span class="koboSpan" id="kobo.279.1">failed</span></code><span class="koboSpan" id="kobo.280.1">. </span><span class="koboSpan" id="kobo.280.2">It returns a </span><code class="literal"><span class="koboSpan" id="kobo.281.1">Future[Throwable]</span></code><span class="koboSpan" id="kobo.282.1"> object that contains the exception that the current object has failed with, and can be used with the </span><code class="literal"><span class="koboSpan" id="kobo.283.1">foreach</span></code><span class="koboSpan" id="kobo.284.1"> statement to access the exception:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.285.1">object FuturesFailure extends App { 
  val urlSpec: Future[String] = Future { 
    val invalidUrl = "http://www.w3.org/non-existent-url-spec.txt" 
    Source.fromURL(invalidUrl).mkString 
  } 
  urlSpec.failed foreach { 
    case t =&gt; log(s"exception occurred - $t") 
  } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.286.1">In this example, our asynchronous computation sends an HTTP request to an invalid URL. </span><span class="koboSpan" id="kobo.286.2">As a result, the </span><code class="literal"><span class="koboSpan" id="kobo.287.1">fromURL</span></code><span class="koboSpan" id="kobo.288.1"> method throws an exception, and the </span><code class="literal"><span class="koboSpan" id="kobo.289.1">urlSpec</span></code><span class="koboSpan" id="kobo.290.1"> future fails. </span><span class="koboSpan" id="kobo.290.2">The program then prints the exception name and message with the </span><code class="literal"><span class="koboSpan" id="kobo.291.1">log</span></code><span class="koboSpan" id="kobo.292.1"> statement.</span></p></div><div class="section" title="Using the Try type"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec34"/><span class="koboSpan" id="kobo.293.1">Using the Try type</span></h2></div></div></div><p><span class="koboSpan" id="kobo.294.1">For conciseness, sometimes we want to subscribe to both successes and failures in the same callback. </span><span class="koboSpan" id="kobo.294.2">To do this, we need to use the type </span><code class="literal"><span class="koboSpan" id="kobo.295.1">Try[T]</span></code><span class="koboSpan" id="kobo.296.1">. </span><span class="koboSpan" id="kobo.296.2">The type </span><code class="literal"><span class="koboSpan" id="kobo.297.1">Try[T]</span></code><span class="koboSpan" id="kobo.298.1"> is very similar to the type </span><code class="literal"><span class="koboSpan" id="kobo.299.1">Option[T]</span></code><span class="koboSpan" id="kobo.300.1"> . </span><span class="koboSpan" id="kobo.300.2">Recall from your experience with sequential Scala programming that the type </span><code class="literal"><span class="koboSpan" id="kobo.301.1">Option[T]</span></code><span class="koboSpan" id="kobo.302.1">  is used to encode a value of the type </span><code class="literal"><span class="koboSpan" id="kobo.303.1">T</span></code><span class="koboSpan" id="kobo.304.1"> or its absence. </span><span class="koboSpan" id="kobo.304.2">A value of </span><code class="literal"><span class="koboSpan" id="kobo.305.1">Option[T]</span></code><span class="koboSpan" id="kobo.306.1"> type can either be an object of a type </span><code class="literal"><span class="koboSpan" id="kobo.307.1">Some[T]</span></code><span class="koboSpan" id="kobo.308.1"> , which holds some value, or </span><code class="literal"><span class="koboSpan" id="kobo.309.1">None</span></code><span class="koboSpan" id="kobo.310.1">, which does not hold anything. </span><span class="koboSpan" id="kobo.310.2">We use pattern matching to determine whether an </span><code class="literal"><span class="koboSpan" id="kobo.311.1">Option[T]</span></code><span class="koboSpan" id="kobo.312.1"> type is </span><code class="literal"><span class="koboSpan" id="kobo.313.1">Some[T]</span></code><span class="koboSpan" id="kobo.314.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.315.1">None</span></code><span class="koboSpan" id="kobo.316.1">. </span><span class="koboSpan" id="kobo.316.2">Optional types are an alternative to using </span><code class="literal"><span class="koboSpan" id="kobo.317.1">null</span></code><span class="koboSpan" id="kobo.318.1"> values, which is what one typically does in Java. </span><span class="koboSpan" id="kobo.318.2">However, the </span><code class="literal"><span class="koboSpan" id="kobo.319.1">Option[T]</span></code><span class="koboSpan" id="kobo.320.1"> type does not allow encoding failures in its </span><code class="literal"><span class="koboSpan" id="kobo.321.1">None</span></code><span class="koboSpan" id="kobo.322.1"> subtype. </span><span class="koboSpan" id="kobo.322.2">The </span><code class="literal"><span class="koboSpan" id="kobo.323.1">None</span></code><span class="koboSpan" id="kobo.324.1"> subtype tells us nothing about the exception in the computation. </span><span class="koboSpan" id="kobo.324.2">For this, we use the </span><code class="literal"><span class="koboSpan" id="kobo.325.1">Try[T]</span></code><span class="koboSpan" id="kobo.326.1"> type.</span></p><p><span class="koboSpan" id="kobo.327.1">The type </span><code class="literal"><span class="koboSpan" id="kobo.328.1">Try[T]</span></code><span class="koboSpan" id="kobo.329.1"> has two implementations--the type </span><code class="literal"><span class="koboSpan" id="kobo.330.1">Success[T]</span></code><span class="koboSpan" id="kobo.331.1">, which encodes the results of the successful computations, and the </span><code class="literal"><span class="koboSpan" id="kobo.332.1">Failure[T]</span></code><span class="koboSpan" id="kobo.333.1"> type, which encodes the </span><code class="literal"><span class="koboSpan" id="kobo.334.1">Throwable</span></code><span class="koboSpan" id="kobo.335.1"> objects that failed the computation. </span><span class="koboSpan" id="kobo.335.2">We use pattern matching to determine which of the two a </span><code class="literal"><span class="koboSpan" id="kobo.336.1">Try[T]</span></code><span class="koboSpan" id="kobo.337.1"> object is:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.338.1">def handleMessage(t: Try[String]) = t match { 
  case Success(msg) =&gt; log(msg) 
  case Failure(error) =&gt; log(s"unexpected failure - $error") 
} 
</span></pre><p><span class="koboSpan" id="kobo.339.1">The </span><code class="literal"><span class="koboSpan" id="kobo.340.1">Try[T]</span></code><span class="koboSpan" id="kobo.341.1"> objects are immutable objects used synchronously; unlike futures, they contain a value or an exception from the moment they are created. </span><span class="koboSpan" id="kobo.341.2">They are more akin to collections than to futures. </span><span class="koboSpan" id="kobo.341.3">We can even compose </span><code class="literal"><span class="koboSpan" id="kobo.342.1">Try[T]</span></code><span class="koboSpan" id="kobo.343.1"> values in for-comprehensions. </span><span class="koboSpan" id="kobo.343.2">In the following code snippet, we will compose the name of the current thread with some custom text:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.344.1">import scala.util.{Try, Success, Failure} 
object FuturesTry extends App { 
  val threadName: Try[String] = Try(Thread.currentThread.getName) 
  val someText: Try[String] = Try("Try objects are synchronous") 
  val message: Try[String] = for { 
    tn &lt;- threadName 
    st &lt;- someText 
  } yield s"Message $st was created on t = $tn" 
  handleMessage(message) 
} 
</span></pre><p><span class="koboSpan" id="kobo.345.1">We will first create two </span><code class="literal"><span class="koboSpan" id="kobo.346.1">Try[String]</span></code><span class="koboSpan" id="kobo.347.1"> values, </span><code class="literal"><span class="koboSpan" id="kobo.348.1">threadName</span></code><span class="koboSpan" id="kobo.349.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.350.1">someText</span></code><span class="koboSpan" id="kobo.351.1">, using the </span><code class="literal"><span class="koboSpan" id="kobo.352.1">Try.apply</span></code><span class="koboSpan" id="kobo.353.1"> factory method. </span><span class="koboSpan" id="kobo.353.2">The </span><code class="literal"><span class="koboSpan" id="kobo.354.1">for</span></code><span class="koboSpan" id="kobo.355.1"> comprehension extracts the thread name, </span><code class="literal"><span class="koboSpan" id="kobo.356.1">tn</span></code><span class="koboSpan" id="kobo.357.1">, from the </span><code class="literal"><span class="koboSpan" id="kobo.358.1">threadName</span></code><span class="koboSpan" id="kobo.359.1"> value, and then the </span><code class="literal"><span class="koboSpan" id="kobo.360.1">st</span></code><span class="koboSpan" id="kobo.361.1"> text from the </span><code class="literal"><span class="koboSpan" id="kobo.362.1">someText</span></code><span class="koboSpan" id="kobo.363.1"> value. </span><span class="koboSpan" id="kobo.363.2">These values are then used to yield another string. </span><span class="koboSpan" id="kobo.363.3">If any of the </span><code class="literal"><span class="koboSpan" id="kobo.364.1">Try</span></code><span class="koboSpan" id="kobo.365.1"> values in the </span><code class="literal"><span class="koboSpan" id="kobo.366.1">for</span></code><span class="koboSpan" id="kobo.367.1"> comprehension fail, then the resulting </span><code class="literal"><span class="koboSpan" id="kobo.368.1">Try</span></code><span class="koboSpan" id="kobo.369.1"> value fails with the </span><code class="literal"><span class="koboSpan" id="kobo.370.1">Throwable</span></code><span class="koboSpan" id="kobo.371.1"> object from the first failed </span><code class="literal"><span class="koboSpan" id="kobo.372.1">Try</span></code><span class="koboSpan" id="kobo.373.1"> value. </span><span class="koboSpan" id="kobo.373.2">However, if all the </span><code class="literal"><span class="koboSpan" id="kobo.374.1">Try</span></code><span class="koboSpan" id="kobo.375.1"> values are </span><code class="literal"><span class="koboSpan" id="kobo.376.1">Success</span></code><span class="koboSpan" id="kobo.377.1">, then the resulting </span><code class="literal"><span class="koboSpan" id="kobo.378.1">Try</span></code><span class="koboSpan" id="kobo.379.1"> value is </span><code class="literal"><span class="koboSpan" id="kobo.380.1">Success</span></code><span class="koboSpan" id="kobo.381.1"> with the value of the expression after the </span><code class="literal"><span class="koboSpan" id="kobo.382.1">yield</span></code><span class="koboSpan" id="kobo.383.1"> keyword. </span><span class="koboSpan" id="kobo.383.2">If this expression throws an exception, the resulting </span><code class="literal"><span class="koboSpan" id="kobo.384.1">Try</span></code><span class="koboSpan" id="kobo.385.1"> value fails with that exception.</span></p><p><span class="koboSpan" id="kobo.386.1">Note that the preceding example always prints the name of the main thread. </span><span class="koboSpan" id="kobo.386.2">Creating </span><code class="literal"><span class="koboSpan" id="kobo.387.1">Try</span></code><span class="koboSpan" id="kobo.388.1"> objects and using them in </span><code class="literal"><span class="koboSpan" id="kobo.389.1">for</span></code><span class="koboSpan" id="kobo.390.1"> comprehensions always occurs on the caller thread.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/><span class="koboSpan" id="kobo.391.1">Note</span></h3><p><span class="koboSpan" id="kobo.392.1">Unlike </span><code class="literal"><span class="koboSpan" id="kobo.393.1">Future[T]</span></code><span class="koboSpan" id="kobo.394.1"> values, </span><code class="literal"><span class="koboSpan" id="kobo.395.1">Try[T]</span></code><span class="koboSpan" id="kobo.396.1"> values are manipulated synchronously.</span></p></div></div><p><span class="koboSpan" id="kobo.397.1">In most cases, we use the </span><code class="literal"><span class="koboSpan" id="kobo.398.1">Try</span></code><span class="koboSpan" id="kobo.399.1"> values in pattern matching. </span><span class="koboSpan" id="kobo.399.2">When calling the </span><code class="literal"><span class="koboSpan" id="kobo.400.1">onComplete</span></code><span class="koboSpan" id="kobo.401.1"> callback, we will provide a partial function that matches the </span><code class="literal"><span class="koboSpan" id="kobo.402.1">Success</span></code><span class="koboSpan" id="kobo.403.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.404.1">Failure</span></code><span class="koboSpan" id="kobo.405.1"> values. </span><span class="koboSpan" id="kobo.405.2">Our example for fetching the URL specification is as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.406.1">urlSpec onComplete { 
  case Success(txt) =&gt; log(find(txt)) 
  case Failure(err) =&gt; log(s"exception occurred - $err") 
} 
</span></pre></div><div class="section" title="Fatal exceptions"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec35"/><span class="koboSpan" id="kobo.407.1">Fatal exceptions</span></h2></div></div></div><p><span class="koboSpan" id="kobo.408.1">We have seen futures storing exceptions that caused them to fail. </span><span class="koboSpan" id="kobo.408.2">However, there are some </span><code class="literal"><span class="koboSpan" id="kobo.409.1">Throwable</span></code><span class="koboSpan" id="kobo.410.1"> objects that a future computation does not catch. </span><span class="koboSpan" id="kobo.410.2">In the following short program, the callback on the </span><code class="literal"><span class="koboSpan" id="kobo.411.1">f</span></code><span class="koboSpan" id="kobo.412.1"> future is never invoked. </span><span class="koboSpan" id="kobo.412.2">Instead, the stack trace of </span><code class="literal"><span class="koboSpan" id="kobo.413.1">InterruptedException</span></code><span class="koboSpan" id="kobo.414.1"> exception is printed on the standard error output:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.415.1">object FuturesNonFatal extends App { 
  val f = Future { throw new InterruptedException } 
  val g = Future { throw new IllegalArgumentException } 
  f.failed foreach { case t =&gt; log(s"error - $t") } 
  g.failed foreach { case t =&gt; log(s"error - $t") } 
} 
</span></pre><p><span class="koboSpan" id="kobo.416.1">The </span><code class="literal"><span class="koboSpan" id="kobo.417.1">InterruptedException</span></code><span class="koboSpan" id="kobo.418.1"> exception and some severe program errors such as </span><code class="literal"><span class="koboSpan" id="kobo.419.1">LinkageError</span></code><span class="koboSpan" id="kobo.420.1">, </span><code class="literal"><span class="koboSpan" id="kobo.421.1">VirtualMachineError</span></code><span class="koboSpan" id="kobo.422.1">, </span><code class="literal"><span class="koboSpan" id="kobo.423.1">ThreadDeath</span></code><span class="koboSpan" id="kobo.424.1">, and Scala's </span><code class="literal"><span class="koboSpan" id="kobo.425.1">ControlThrowable</span></code><span class="koboSpan" id="kobo.426.1"> error are forwarded to the execution context's </span><code class="literal"><span class="koboSpan" id="kobo.427.1">reportFailure</span></code><span class="koboSpan" id="kobo.428.1"> method introduced in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.429.1">Chapter 3</span></a><span class="koboSpan" id="kobo.430.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.431.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.432.1">. </span><span class="koboSpan" id="kobo.432.2">These types of </span><code class="literal"><span class="koboSpan" id="kobo.433.1">Throwable</span></code><span class="koboSpan" id="kobo.434.1"> object are called </span><span class="strong"><strong><span class="koboSpan" id="kobo.435.1">fatal errors</span></strong></span><span class="koboSpan" id="kobo.436.1">. </span><span class="koboSpan" id="kobo.436.2">To find out if a </span><code class="literal"><span class="koboSpan" id="kobo.437.1">Throwable</span></code><span class="koboSpan" id="kobo.438.1"> object will be stored in a </span><code class="literal"><span class="koboSpan" id="kobo.439.1">Future</span></code><span class="koboSpan" id="kobo.440.1"> instance, you can pattern match the </span><code class="literal"><span class="koboSpan" id="kobo.441.1">Throwable</span></code><span class="koboSpan" id="kobo.442.1"> object with the </span><code class="literal"><span class="koboSpan" id="kobo.443.1">NonFatal</span></code><span class="koboSpan" id="kobo.444.1"> extractor:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.445.1">f.failed foreach { 
  case NonFatal(t) =&gt; log(s"$t is non-fatal!") 
} 
</span></pre><p><span class="koboSpan" id="kobo.446.1">Note that you never need to manually match in order to see whether errors in your futures are nonfatal. </span><span class="koboSpan" id="kobo.446.2">Fatal errors are automatically forwarded to the execution context.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/><span class="koboSpan" id="kobo.447.1">Note</span></h3><p><span class="koboSpan" id="kobo.448.1">Future computations do not catch fatal errors. </span><span class="koboSpan" id="kobo.448.2">Use the </span><code class="literal"><span class="koboSpan" id="kobo.449.1">NonFatal</span></code><span class="koboSpan" id="kobo.450.1"> extractor to pattern match against nonfatal errors.</span></p></div></div></div><div class="section" title="Functional composition on futures"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec36"/><span class="koboSpan" id="kobo.451.1">Functional composition on futures</span></h2></div></div></div><p><span class="koboSpan" id="kobo.452.1">Callbacks are useful, but they can make reasoning about control flow difficult when programs become larger. </span><span class="koboSpan" id="kobo.452.2">They also disallow certain patterns in asynchronous programming in particular, it is cumbersome to use a callback to subscribe to multiple futures at once. </span><span class="koboSpan" id="kobo.452.3">Luckily, Scala futures have an answer to these problems called </span><span class="strong"><strong><span class="koboSpan" id="kobo.453.1">functional composition</span></strong></span><span class="koboSpan" id="kobo.454.1">. </span><span class="koboSpan" id="kobo.454.2">Functional composition on futures allows using futures inside </span><code class="literal"><span class="koboSpan" id="kobo.455.1">for</span></code><span class="koboSpan" id="kobo.456.1"> comprehensions, and is often more intuitive to use than callbacks.</span></p><p><span class="koboSpan" id="kobo.457.1">Introducing futures transfers the responsibility for blocking from the API to the caller. </span><span class="koboSpan" id="kobo.457.2">The </span><code class="literal"><span class="koboSpan" id="kobo.458.1">foreach</span></code><span class="koboSpan" id="kobo.459.1"> method helps you to avoid blocking altogether. </span><span class="koboSpan" id="kobo.459.2">It also eliminates non-determinism inherent to polling methods such as </span><code class="literal"><span class="koboSpan" id="kobo.460.1">isCompleted</span></code><span class="koboSpan" id="kobo.461.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.462.1">value</span></code><span class="koboSpan" id="kobo.463.1">. </span><span class="koboSpan" id="kobo.463.2">Still, there are some situations when the </span><code class="literal"><span class="koboSpan" id="kobo.464.1">foreach</span></code><span class="koboSpan" id="kobo.465.1"> statement is not the best solution.</span></p><p><span class="koboSpan" id="kobo.466.1">Let's say that we want to implement some of the functionality from the Git version control system; we want to use the </span><code class="literal"><span class="koboSpan" id="kobo.467.1">.gitignore</span></code><span class="koboSpan" id="kobo.468.1"> file to find files in our project tree that should not be versioned. </span><span class="koboSpan" id="kobo.468.2">We simplify our task by assuming that the </span><code class="literal"><span class="koboSpan" id="kobo.469.1">.gitignore</span></code><span class="koboSpan" id="kobo.470.1"> file only contains a list of prefixes for blacklisted file paths, and no regular expressions.</span></p><p><span class="koboSpan" id="kobo.471.1">We perform two asynchronous actions. </span><span class="koboSpan" id="kobo.471.2">First, we fetch the contents of our </span><code class="literal"><span class="koboSpan" id="kobo.472.1">.gitignore</span></code><span class="koboSpan" id="kobo.473.1"> file in a future computation. </span><span class="koboSpan" id="kobo.473.2">Then, using its contents, we will asynchronously scan all the files in our project directory and match them. </span><span class="koboSpan" id="kobo.473.3">We will start by importing the packages necessary for file handling. </span><span class="koboSpan" id="kobo.473.4">In addition to the </span><code class="literal"><span class="koboSpan" id="kobo.474.1">scala.io.Source</span></code><span class="koboSpan" id="kobo.475.1"> object, we use the </span><code class="literal"><span class="koboSpan" id="kobo.476.1">java.io</span></code><span class="koboSpan" id="kobo.477.1"> package and the </span><code class="literal"><span class="koboSpan" id="kobo.478.1">apache.commons.io.FileUtils</span></code><span class="koboSpan" id="kobo.479.1"> class, and import them as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.480.1">import java.io._ 
import org.apache.commons.io.FileUtils._ 
import scala.collection.convert.decorateAsScala._ 
</span></pre><p><span class="koboSpan" id="kobo.481.1">If you haven't already added the dependency on Commons IO to your </span><code class="literal"><span class="koboSpan" id="kobo.482.1">build.sbt</span></code><span class="koboSpan" id="kobo.483.1"> file in the previous chapters, now is a good time to introduce the following line:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.484.1">libraryDependencies += "commons-io" % "commons-io" % "2.4" 
</span></pre><p><span class="koboSpan" id="kobo.485.1">We will first create a future using the </span><code class="literal"><span class="koboSpan" id="kobo.486.1">blacklistFile</span></code><span class="koboSpan" id="kobo.487.1"> method, which reads the contents of the </span><code class="literal"><span class="koboSpan" id="kobo.488.1">.gitignore</span></code><span class="koboSpan" id="kobo.489.1"> file. </span><span class="koboSpan" id="kobo.489.2">Given the pace at which technology is evolving these days, we never know when a different version control system will become more popular; so we add the </span><code class="literal"><span class="koboSpan" id="kobo.490.1">name</span></code><span class="koboSpan" id="kobo.491.1"> parameter for the name of the blacklist file. </span><span class="koboSpan" id="kobo.491.2">We filter out the empty lines and all the comment lines starting with a </span><code class="literal"><span class="koboSpan" id="kobo.492.1">#</span></code><span class="koboSpan" id="kobo.493.1"> sign. </span><span class="koboSpan" id="kobo.493.2">We then convert them to a list, as shown in the following code snippet:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.494.1">object FuturesClumsyCallback extends App { 
  def blacklistFile(name: String): Future[List[String]] = Future { 
    val lines = Source.fromFile(name).getLines 
    lines.filter(x =&gt; !x.startsWith("#") &amp;&amp; !x.isEmpty).toList 
  } 
</span></pre><p><span class="koboSpan" id="kobo.495.1">In our case, the future returned by the </span><code class="literal"><span class="koboSpan" id="kobo.496.1">blacklistFile</span></code><span class="koboSpan" id="kobo.497.1"> method eventually contains a list with a single string, the </span><code class="literal"><span class="koboSpan" id="kobo.498.1">target</span></code><span class="koboSpan" id="kobo.499.1"> directory is where SBT stores files created by the Scala compiler. </span><span class="koboSpan" id="kobo.499.2">Then, we implement another method named </span><code class="literal"><span class="koboSpan" id="kobo.500.1">findFiles</span></code><span class="koboSpan" id="kobo.501.1"> that, given a list of patterns, finds all the files in the current directory containing these patterns. </span><span class="koboSpan" id="kobo.501.2">The </span><code class="literal"><span class="koboSpan" id="kobo.502.1">iterateFiles</span></code><span class="koboSpan" id="kobo.503.1"> method from the Commons IO library returns a Java iterator over the project files, so we can convert it to a Scala iterator by calling </span><code class="literal"><span class="koboSpan" id="kobo.504.1">asScala</span></code><span class="koboSpan" id="kobo.505.1">. </span><span class="koboSpan" id="kobo.505.2">We then yield all the matching file paths:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.506.1">  def findFiles(patterns: List[String]): List[String] = { 
    val root = new File(".") 
    for { 
      f &lt;- iterateFiles(root, null, true).asScala.toList 
      pat &lt;- patterns 
      abspat = root.getCanonicalPath + File.separator + pat 
      if f.getCanonicalPath.contains(abspat) 
    } yield f.getCanonicalPath 
  } 
</span></pre><p><span class="koboSpan" id="kobo.507.1">If we now want to list blacklisted files, we first need to call </span><code class="literal"><span class="koboSpan" id="kobo.508.1">foreach</span></code><span class="koboSpan" id="kobo.509.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.510.1">blacklistFile</span></code><span class="koboSpan" id="kobo.511.1"> future, and call </span><code class="literal"><span class="koboSpan" id="kobo.512.1">findPatterns</span></code><span class="koboSpan" id="kobo.513.1"> from inside the callback, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.514.1">  blacklistFile(".gitignore") foreach { 
    case lines =&gt; 
      val files = findFiles(lines) 
      log(s"matches: ${files.mkString("\n")}") 
  } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.515.1">Assume your fellow developer now asks you to implement another </span><code class="literal"><span class="koboSpan" id="kobo.516.1">blacklisted</span></code><span class="koboSpan" id="kobo.517.1"> method that takes the name of the blacklist file and returns a future with a list of blacklisted files. </span><span class="koboSpan" id="kobo.517.2">This allows us to specify the callback independently in the program; instead of printing the files to the standard output, another part of the program can, for example, create a safety backup of the blacklisted files using the following method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.518.1">def blacklisted(name: String): Future[List[String]] 
</span></pre><p><span class="koboSpan" id="kobo.519.1">Being an experienced object-oriented developer, you'd like to reuse the </span><code class="literal"><span class="koboSpan" id="kobo.520.1">blacklistFile</span></code><span class="koboSpan" id="kobo.521.1"> future and the </span><code class="literal"><span class="koboSpan" id="kobo.522.1">findFiles</span></code><span class="koboSpan" id="kobo.523.1"> method. </span><span class="koboSpan" id="kobo.523.2">After all, the functionality is already there. </span><span class="koboSpan" id="kobo.523.3">We challenge you to reuse the existing methods to implement the new </span><code class="literal"><span class="koboSpan" id="kobo.524.1">blacklisted</span></code><span class="koboSpan" id="kobo.525.1"> method. </span><span class="koboSpan" id="kobo.525.2">Try to use the </span><code class="literal"><span class="koboSpan" id="kobo.526.1">foreach</span></code><span class="koboSpan" id="kobo.527.1"> statement. </span><span class="koboSpan" id="kobo.527.2">You will find this task extremely difficult.</span></p><p><span class="koboSpan" id="kobo.528.1">So far, we haven't seen methods that produce new futures using the values in existing futures. </span><span class="koboSpan" id="kobo.528.2">The </span><code class="literal"><span class="koboSpan" id="kobo.529.1">Future</span></code><span class="koboSpan" id="kobo.530.1"> trait has a </span><code class="literal"><span class="koboSpan" id="kobo.531.1">map</span></code><span class="koboSpan" id="kobo.532.1"> method that maps the value in one future to a value in another future:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.533.1">def map[S](f: T =&gt; S)(implicit e: ExecutionContext): Future[S] 
</span></pre><p><span class="koboSpan" id="kobo.534.1">This method is non blocking--it returns the </span><code class="literal"><span class="koboSpan" id="kobo.535.1">Future[S]</span></code><span class="koboSpan" id="kobo.536.1"> object immediately. </span><span class="koboSpan" id="kobo.536.2">After the original future completes with some value </span><code class="literal"><span class="koboSpan" id="kobo.537.1">x</span></code><span class="koboSpan" id="kobo.538.1">, the returned </span><code class="literal"><span class="koboSpan" id="kobo.539.1">Future[S]</span></code><span class="koboSpan" id="kobo.540.1"> object is eventually completed with </span><code class="literal"><span class="koboSpan" id="kobo.541.1">f(x)</span></code><span class="koboSpan" id="kobo.542.1">. </span><span class="koboSpan" id="kobo.542.2">With the </span><code class="literal"><span class="koboSpan" id="kobo.543.1">map</span></code><span class="koboSpan" id="kobo.544.1"> method, our task is trivial: we transform the patterns into a list of matching files by calling the </span><code class="literal"><span class="koboSpan" id="kobo.545.1">findFiles</span></code><span class="koboSpan" id="kobo.546.1"> method:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.547.1">def blacklisted(name: String): Future[List[String]] = 
  blacklistFile(name).map(patterns =&gt; findFiles(patterns)) 
</span></pre><p><span class="koboSpan" id="kobo.548.1">As a Scala developer, you know that a </span><code class="literal"><span class="koboSpan" id="kobo.549.1">map</span></code><span class="koboSpan" id="kobo.550.1"> operation on a collection transforms many elements into a new collection. </span><span class="koboSpan" id="kobo.550.2">To more easily comprehend operations such as the </span><code class="literal"><span class="koboSpan" id="kobo.551.1">map</span></code><span class="koboSpan" id="kobo.552.1"> operation on futures, you can consider a future as a specific form of collection that contains at most one element.</span></p><p><span class="strong"><strong><span class="koboSpan" id="kobo.553.1">Functional composition</span></strong></span><span class="koboSpan" id="kobo.554.1"> is a programming pattern in which simpler values are composed into more complex ones by means of higher-order functions called </span><span class="strong"><strong><span class="koboSpan" id="kobo.555.1">combinators</span></strong></span><span class="koboSpan" id="kobo.556.1">. </span><span class="koboSpan" id="kobo.556.2">Functional composition on Scala collections should be familiar to you from sequential Scala programming. </span><span class="koboSpan" id="kobo.556.3">For example, the </span><code class="literal"><span class="koboSpan" id="kobo.557.1">map</span></code><span class="koboSpan" id="kobo.558.1"> method on a collection produces a new collection containing elements from the original collection, mapped with a specified function.</span></p><p><span class="koboSpan" id="kobo.559.1">Functional composition on futures is similar; we can produce new futures by transforming or merging existing futures, as in the preceding example. </span><span class="koboSpan" id="kobo.559.2">Callbacks are useful, but they do not directly allow functional composition in the way combinators such as </span><code class="literal"><span class="koboSpan" id="kobo.560.1">map</span></code><span class="koboSpan" id="kobo.561.1"> do. </span><span class="koboSpan" id="kobo.561.2">Just as with callbacks, a function passed to a combinator is never invoked before the corresponding future completes.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/><span class="koboSpan" id="kobo.562.1">Note</span></h3><p><span class="koboSpan" id="kobo.563.1">There is a happens-before relationship between completing the future and invoking the function in any of its combinators.</span></p></div></div><p><span class="koboSpan" id="kobo.564.1">Choosing between alternative ways to handle futures can be confusing. </span><span class="koboSpan" id="kobo.564.2">When should we use functional composition in place of callbacks? </span><span class="koboSpan" id="kobo.564.3">A good rule of thumb is to use callbacks for side-effecting actions that depend on a single future. </span><span class="koboSpan" id="kobo.564.4">In all other situations, we can use functional composition.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip40"/><span class="koboSpan" id="kobo.565.1">Tip</span></h3><p><span class="koboSpan" id="kobo.566.1">When an action in the program depends on the value of a single future, use callbacks on futures. </span><span class="koboSpan" id="kobo.566.2">When subsequent actions in the program depend on values of multiple futures or produce new futures, use functional composition on futures.</span></p></div></div><p><span class="koboSpan" id="kobo.567.1">Let us consider several crucial combinators for functional composition. </span><span class="koboSpan" id="kobo.567.2">The </span><code class="literal"><span class="koboSpan" id="kobo.568.1">map</span></code><span class="koboSpan" id="kobo.569.1"> method on a </span><code class="literal"><span class="koboSpan" id="kobo.570.1">Future[T]</span></code><span class="koboSpan" id="kobo.571.1"> takes an </span><code class="literal"><span class="koboSpan" id="kobo.572.1">f</span></code><span class="koboSpan" id="kobo.573.1"> function and returns a new </span><code class="literal"><span class="koboSpan" id="kobo.574.1">Future[S]</span></code><span class="koboSpan" id="kobo.575.1"> future. </span><span class="koboSpan" id="kobo.575.2">After the </span><code class="literal"><span class="koboSpan" id="kobo.576.1">Future[T]</span></code><span class="koboSpan" id="kobo.577.1"> is completed, the </span><code class="literal"><span class="koboSpan" id="kobo.578.1">Future[S]</span></code><span class="koboSpan" id="kobo.579.1"> is completed by applying </span><code class="literal"><span class="koboSpan" id="kobo.580.1">f</span></code><span class="koboSpan" id="kobo.581.1"> to the value in </span><code class="literal"><span class="koboSpan" id="kobo.582.1">Future[T]</span></code><span class="koboSpan" id="kobo.583.1">. </span><span class="koboSpan" id="kobo.583.2">If </span><code class="literal"><span class="koboSpan" id="kobo.584.1">Future[T]</span></code><span class="koboSpan" id="kobo.585.1"> fails with an exception </span><code class="literal"><span class="koboSpan" id="kobo.586.1">e</span></code><span class="koboSpan" id="kobo.587.1">, or the mapping function </span><code class="literal"><span class="koboSpan" id="kobo.588.1">f</span></code><span class="koboSpan" id="kobo.589.1"> throws an exception </span><code class="literal"><span class="koboSpan" id="kobo.590.1">e</span></code><span class="koboSpan" id="kobo.591.1">, then </span><code class="literal"><span class="koboSpan" id="kobo.592.1">Future[S]</span></code><span class="koboSpan" id="kobo.593.1"> also fails with that exception </span><code class="literal"><span class="koboSpan" id="kobo.594.1">e</span></code><span class="koboSpan" id="kobo.595.1">.</span></p><p><span class="koboSpan" id="kobo.596.1">Recall that Scala allows using for-comprehensions on objects that have a </span><code class="literal"><span class="koboSpan" id="kobo.597.1">map</span></code><span class="koboSpan" id="kobo.598.1"> method, so we can use futures in for-comprehensions. </span><span class="koboSpan" id="kobo.598.2">Let's assume that we want to get the future with the longest line from our </span><code class="literal"><span class="koboSpan" id="kobo.599.1">build.sbt</span></code><span class="koboSpan" id="kobo.600.1"> file. </span><span class="koboSpan" id="kobo.600.2">The computation proceeds in two steps. </span><span class="koboSpan" id="kobo.600.3">First, we read in the lines from the disk, and then we call the </span><code class="literal"><span class="koboSpan" id="kobo.601.1">maxBy</span></code><span class="koboSpan" id="kobo.602.1"> method to get the longest line:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.603.1">val buildFile = Future {  
  Source.fromFile("build.sbt").getLines  
} 
 
val longest = for (ls &lt;- buildFile) yield ls.maxBy(_.length) 
longest foreach { 
  case line =&gt; log(s"longest line: $line") 
} 
</span></pre><p><span class="koboSpan" id="kobo.604.1">The </span><code class="literal"><span class="koboSpan" id="kobo.605.1">longest</span></code><span class="koboSpan" id="kobo.606.1"> declaration is desugared by the Scala compiler into the following line:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.607.1">val longest = buildFile.map(ls =&gt; ls.maxBy(_.length)) 
</span></pre><p><span class="koboSpan" id="kobo.608.1">The real advantage of </span><code class="literal"><span class="koboSpan" id="kobo.609.1">for</span></code><span class="koboSpan" id="kobo.610.1"> comprehensions becomes apparent when we use the </span><code class="literal"><span class="koboSpan" id="kobo.611.1">flatMap</span></code><span class="koboSpan" id="kobo.612.1"> combinator, which has the following signature:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.613.1">def flatMap[S](f: T =&gt; Future[S])(implicit e: ExecutionContext): 
  Future[S] 
</span></pre><p><span class="koboSpan" id="kobo.614.1">The </span><code class="literal"><span class="koboSpan" id="kobo.615.1">flatMap</span></code><span class="koboSpan" id="kobo.616.1"> combinator uses the current future with the </span><code class="literal"><span class="koboSpan" id="kobo.617.1">Future[T]</span></code><span class="koboSpan" id="kobo.618.1"> type to produce another future with the type </span><code class="literal"><span class="koboSpan" id="kobo.619.1">Future[S]</span></code><span class="koboSpan" id="kobo.620.1"> . </span><span class="koboSpan" id="kobo.620.2">The resulting </span><code class="literal"><span class="koboSpan" id="kobo.621.1">Future[S]</span></code><span class="koboSpan" id="kobo.622.1"> is completed by taking the value </span><code class="literal"><span class="koboSpan" id="kobo.623.1">x</span></code><span class="koboSpan" id="kobo.624.1"> of the type </span><code class="literal"><span class="koboSpan" id="kobo.625.1">T</span></code><span class="koboSpan" id="kobo.626.1"> from the current future, and mapping that value to another future </span><code class="literal"><span class="koboSpan" id="kobo.627.1">f(x)</span></code><span class="koboSpan" id="kobo.628.1">. </span><span class="koboSpan" id="kobo.628.2">While the future resulting from a </span><code class="literal"><span class="koboSpan" id="kobo.629.1">map</span></code><span class="koboSpan" id="kobo.630.1"> method completes when the mapping function </span><code class="literal"><span class="koboSpan" id="kobo.631.1">f</span></code><span class="koboSpan" id="kobo.632.1"> completes, the future resulting from a </span><code class="literal"><span class="koboSpan" id="kobo.633.1">flatMap</span></code><span class="koboSpan" id="kobo.634.1"> method completes when both </span><code class="literal"><span class="koboSpan" id="kobo.635.1">f</span></code><span class="koboSpan" id="kobo.636.1"> and the future returned by </span><code class="literal"><span class="koboSpan" id="kobo.637.1">f</span></code><span class="koboSpan" id="kobo.638.1"> complete.</span></p><p><span class="koboSpan" id="kobo.639.1">To understand how this combinator is useful, let's consider the following example. </span><span class="koboSpan" id="kobo.639.2">Assume that your job application went well and you got that new job you were hoping for. </span><span class="koboSpan" id="kobo.639.3">On the first day of work, you receive a chain e-mail from your secretary. </span><span class="koboSpan" id="kobo.639.4">The chain e-mail claims that you should never open URLs starting with </span><code class="literal"><span class="koboSpan" id="kobo.640.1">ftp://</span></code><span class="koboSpan" id="kobo.641.1">, because all of them contain viruses. </span><span class="koboSpan" id="kobo.641.2">As a skillful techie with a lot of experience, you quickly recognize the chain letter for what it is--a scam. </span><span class="koboSpan" id="kobo.641.3">You, therefore, decide to enlighten your secretary by sending her instructions on how to communicate using e-mails, and an explanation of what FTP links are. </span><span class="koboSpan" id="kobo.641.4">You write a short program that replies asynchronously. </span><span class="koboSpan" id="kobo.641.5">You've got better things to do than to spend your day writing e-mails:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.642.1">val netiquetteUrl = "http://www.ietf.org/rfc/rfc1855.txt" 
val netiquette = Future { Source.fromURL(netiquetteUrl).mkString } 
val urlSpecUrl = "http://www.w3.org/Addressing/URL/url-spec.txt" 
val urlSpec = Future { Source.fromURL(urlSpecUrl).mkString } 
val answer = netiquette.flatMap { nettext =&gt; 
  urlSpec.map { urltext =&gt; 
    "Check this out: " + nettext + ". </span><span class="koboSpan" id="kobo.642.2">And check out: " + urltext 
  } 
} 
answer foreach { case contents =&gt; log(contents) } 
</span></pre><p><span class="koboSpan" id="kobo.643.1">This program asynchronously fetches the good old </span><span class="strong"><strong><span class="koboSpan" id="kobo.644.1">RFC 1855</span></strong></span><span class="koboSpan" id="kobo.645.1">--the guidelines for e-mail communication or netiquette. </span><span class="koboSpan" id="kobo.645.2">It then asynchronously fetches the URL specification with information on the </span><code class="literal"><span class="koboSpan" id="kobo.646.1">ftp</span></code><span class="koboSpan" id="kobo.647.1"> schema. </span><span class="koboSpan" id="kobo.647.2">The program attempts to concatenate the two texts. </span><span class="koboSpan" id="kobo.647.3">It calls </span><code class="literal"><span class="koboSpan" id="kobo.648.1">flatMap</span></code><span class="koboSpan" id="kobo.649.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.650.1">netiquette</span></code><span class="koboSpan" id="kobo.651.1"> future. </span><span class="koboSpan" id="kobo.651.2">Based on the </span><code class="literal"><span class="koboSpan" id="kobo.652.1">nettext</span></code><span class="koboSpan" id="kobo.653.1"> value in the </span><code class="literal"><span class="koboSpan" id="kobo.654.1">netiquette</span></code><span class="koboSpan" id="kobo.655.1"> future, the </span><code class="literal"><span class="koboSpan" id="kobo.656.1">flatMap</span></code><span class="koboSpan" id="kobo.657.1"> future needs to return another future. </span><span class="koboSpan" id="kobo.657.2">It could return the </span><code class="literal"><span class="koboSpan" id="kobo.658.1">urlSpec</span></code><span class="koboSpan" id="kobo.659.1"> future directly, but the resulting future, </span><code class="literal"><span class="koboSpan" id="kobo.660.1">answer</span></code><span class="koboSpan" id="kobo.661.1">, would then be completed with just the URL specification. </span><span class="koboSpan" id="kobo.661.2">Instead, we can call the </span><code class="literal"><span class="koboSpan" id="kobo.662.1">map</span></code><span class="koboSpan" id="kobo.663.1"> combinator on the </span><code class="literal"><span class="koboSpan" id="kobo.664.1">urlSpec</span></code><span class="koboSpan" id="kobo.665.1"> future; we map its value, </span><code class="literal"><span class="koboSpan" id="kobo.666.1">urltext</span></code><span class="koboSpan" id="kobo.667.1">, into the concatenation of the </span><code class="literal"><span class="koboSpan" id="kobo.668.1">nettext</span></code><span class="koboSpan" id="kobo.669.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.670.1">urltext</span></code><span class="koboSpan" id="kobo.671.1"> values. </span><span class="koboSpan" id="kobo.671.2">This results in another intermediate future holding the concatenation; once this future is completed, the </span><code class="literal"><span class="koboSpan" id="kobo.672.1">answer</span></code><span class="koboSpan" id="kobo.673.1"> future is completed as well. </span><span class="koboSpan" id="kobo.673.2">Graphically, this looks as follows:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.674.1"><img src="graphics/image_04_004.jpg" alt="Functional composition on futures"/></span></div><p><span class="koboSpan" id="kobo.675.1">If you look at this execution diagram from a distance, you will notice that there is an inherent ordering between asynchronous computations. </span><span class="koboSpan" id="kobo.675.2">We can capture these relationships in a graph, as shown in the following figure:</span></p><div class="mediaobject"><span class="koboSpan" id="kobo.676.1"><img src="graphics/image_04_005.jpg" alt="Functional composition on futures"/></span></div><p><span class="koboSpan" id="kobo.677.1">This graph is called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.678.1">dataflow graph</span></strong></span><span class="koboSpan" id="kobo.679.1">, because it describes how the data flows from one future to another. </span><span class="koboSpan" id="kobo.679.2">Futures are represented with vertices and asynchronous computations are directed edges between them. </span><span class="koboSpan" id="kobo.679.3">An edge points from one vertex to another if the value of future in the first vertex is used to compute the value of future in the second vertex. </span><span class="koboSpan" id="kobo.679.4">In this graph, futures produced by </span><code class="literal"><span class="koboSpan" id="kobo.680.1">Future.apply</span></code><span class="koboSpan" id="kobo.681.1"> are source vertices-they have only outward edges. </span><span class="koboSpan" id="kobo.681.2">Various future combinators such as </span><code class="literal"><span class="koboSpan" id="kobo.682.1">map</span></code><span class="koboSpan" id="kobo.683.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.684.1">flatMap</span></code><span class="koboSpan" id="kobo.685.1"> connect different vertices. </span><span class="koboSpan" id="kobo.685.2">Callback functions such as </span><code class="literal"><span class="koboSpan" id="kobo.686.1">foreach</span></code><span class="koboSpan" id="kobo.687.1"> lead to sink vertices-they have no outward edges. </span><span class="koboSpan" id="kobo.687.2">Some combinators, such as </span><code class="literal"><span class="koboSpan" id="kobo.688.1">flatMap</span></code><span class="koboSpan" id="kobo.689.1">, can use values from multiple vertices.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip41"/><span class="koboSpan" id="kobo.690.1">Tip</span></h3><p><span class="koboSpan" id="kobo.691.1">The </span><code class="literal"><span class="koboSpan" id="kobo.692.1">flatMap</span></code><span class="koboSpan" id="kobo.693.1"> combinator combines two futures into one: the one on which the </span><code class="literal"><span class="koboSpan" id="kobo.694.1">flatMap</span></code><span class="koboSpan" id="kobo.695.1"> combinator is invoked and the one that is returned by the argument function.</span></p></div></div><p><span class="koboSpan" id="kobo.696.1">There are two issues with our e-mail example. </span><span class="koboSpan" id="kobo.696.2">First, we should be nicer to our new secretary; she's not a techie like we are. </span><span class="koboSpan" id="kobo.696.3">Second, using </span><code class="literal"><span class="koboSpan" id="kobo.697.1">flatMap</span></code><span class="koboSpan" id="kobo.698.1"> directly makes the program hard to understand. </span><span class="koboSpan" id="kobo.698.2">There are not many developers in the Scala community that use </span><code class="literal"><span class="koboSpan" id="kobo.699.1">flatMap</span></code><span class="koboSpan" id="kobo.700.1"> like this. </span><span class="koboSpan" id="kobo.700.2">Instead, </span><code class="literal"><span class="koboSpan" id="kobo.701.1">flatMap</span></code><span class="koboSpan" id="kobo.702.1"> should be used implicitly in </span><code class="literal"><span class="koboSpan" id="kobo.703.1">for</span></code><span class="koboSpan" id="kobo.704.1"> comprehensions:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.705.1">val answer = for { 
  nettext &lt;- netiquette 
  urltext &lt;- urlSpec 
} yield { 
  "First, read this: " + nettext + ". </span><span class="koboSpan" id="kobo.705.2">Now, try this: " + urltext 
} 
</span></pre><p><span class="koboSpan" id="kobo.706.1">After desugaring, this </span><code class="literal"><span class="koboSpan" id="kobo.707.1">for</span></code><span class="koboSpan" id="kobo.708.1"> comprehension is identical to what we had before. </span><span class="koboSpan" id="kobo.708.2">This is much simpler; the program now almost reads itself. </span><span class="koboSpan" id="kobo.708.3">For the </span><code class="literal"><span class="koboSpan" id="kobo.709.1">nettext</span></code><span class="koboSpan" id="kobo.710.1"> value of the </span><code class="literal"><span class="koboSpan" id="kobo.711.1">netiquette</span></code><span class="koboSpan" id="kobo.712.1"> future and the </span><code class="literal"><span class="koboSpan" id="kobo.713.1">urltext</span></code><span class="koboSpan" id="kobo.714.1"> value of the </span><code class="literal"><span class="koboSpan" id="kobo.715.1">urlSpec</span></code><span class="koboSpan" id="kobo.716.1"> future, the </span><code class="literal"><span class="koboSpan" id="kobo.717.1">answer</span></code><span class="koboSpan" id="kobo.718.1"> future is a new future with the concatenation of </span><code class="literal"><span class="koboSpan" id="kobo.719.1">nettext</span></code><span class="koboSpan" id="kobo.720.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.721.1">urltext</span></code><span class="koboSpan" id="kobo.722.1">.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip42"/><span class="koboSpan" id="kobo.723.1">Tip</span></h3><p><span class="koboSpan" id="kobo.724.1">You should prefer for-comprehensions to using </span><code class="literal"><span class="koboSpan" id="kobo.725.1">flatMap</span></code><span class="koboSpan" id="kobo.726.1"> directly to make programs more concise and understandable.</span></p></div></div><p><span class="koboSpan" id="kobo.727.1">Note that the following for-comprehension looks very similar to what we had before, but it is not equivalent:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.728.1">val answer = for { 
  nettext &lt;- Future { Source.fromURL(netiquetteUrl).mkString } 
  urltext &lt;- Future { Source.fromURL(urlSpecUrl).mkString } 
} yield { 
  "First, read this: " + nettext + ". </span><span class="koboSpan" id="kobo.728.2">Now, try this: " + urltext 
} 
</span></pre><p><span class="koboSpan" id="kobo.729.1">In the preceding code, the </span><code class="literal"><span class="koboSpan" id="kobo.730.1">nettext</span></code><span class="koboSpan" id="kobo.731.1"> value is extracted from the first future. </span><span class="koboSpan" id="kobo.731.2">Only after the first future is completed, the second future computation start. </span><span class="koboSpan" id="kobo.731.3">This is useful when the second asynchronous computation uses </span><code class="literal"><span class="koboSpan" id="kobo.732.1">nettext</span></code><span class="koboSpan" id="kobo.733.1">, but in our case fetching the </span><code class="literal"><span class="koboSpan" id="kobo.734.1">netiquette</span></code><span class="koboSpan" id="kobo.735.1"> document and the URL specification can proceed concurrently.</span></p><p><span class="koboSpan" id="kobo.736.1">So far, we have only considered future combinators that work with successful futures. </span><span class="koboSpan" id="kobo.736.2">When any of the input futures fail or the computation in the combinator throws an exception, the resulting future fails with the same exception. </span><span class="koboSpan" id="kobo.736.3">In some situations, we want to handle the exception in the future in the same way as we handle exceptions with a </span><code class="literal"><span class="koboSpan" id="kobo.737.1">try-catch</span></code><span class="koboSpan" id="kobo.738.1"> block in sequential programming. </span><span class="koboSpan" id="kobo.738.2">A combinator that is helpful in these situations is called </span><code class="literal"><span class="koboSpan" id="kobo.739.1">recover</span></code><span class="koboSpan" id="kobo.740.1">. </span><span class="koboSpan" id="kobo.740.2">Its simplified signature is as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.741.1">def recover(pf: PartialFunction[Throwable, T]) 
  (implicit e: ExecutionContext): Future[T] 
</span></pre><p><span class="koboSpan" id="kobo.742.1">When this combinator is called on a future, which is successfully completed with some value </span><code class="literal"><span class="koboSpan" id="kobo.743.1">x</span></code><span class="koboSpan" id="kobo.744.1"> of the type </span><code class="literal"><span class="koboSpan" id="kobo.745.1">T</span></code><span class="koboSpan" id="kobo.746.1">, the resulting future is completed with the same value </span><code class="literal"><span class="koboSpan" id="kobo.747.1">x</span></code><span class="koboSpan" id="kobo.748.1">. </span><span class="koboSpan" id="kobo.748.2">On the other hand, if a future fails, then the </span><code class="literal"><span class="koboSpan" id="kobo.749.1">pf</span></code><span class="koboSpan" id="kobo.750.1"> partial function is applied to the </span><code class="literal"><span class="koboSpan" id="kobo.751.1">Throwable</span></code><span class="koboSpan" id="kobo.752.1"> object that failed it. </span><span class="koboSpan" id="kobo.752.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.753.1">pf</span></code><span class="koboSpan" id="kobo.754.1"> partial function is not defined for the </span><code class="literal"><span class="koboSpan" id="kobo.755.1">Throwable</span></code><span class="koboSpan" id="kobo.756.1"> object, then the resulting future is failed with the same </span><code class="literal"><span class="koboSpan" id="kobo.757.1">Throwable</span></code><span class="koboSpan" id="kobo.758.1"> object. </span><span class="koboSpan" id="kobo.758.2">Otherwise, the resulting future is completed with the result of applying </span><code class="literal"><span class="koboSpan" id="kobo.759.1">pf</span></code><span class="koboSpan" id="kobo.760.1"> to the </span><code class="literal"><span class="koboSpan" id="kobo.761.1">Throwable</span></code><span class="koboSpan" id="kobo.762.1"> object. </span><span class="koboSpan" id="kobo.762.2">If the </span><code class="literal"><span class="koboSpan" id="kobo.763.1">pf</span></code><span class="koboSpan" id="kobo.764.1"> partial function itself throws an exception, the resulting future is completed with that exception.</span></p><p><span class="koboSpan" id="kobo.765.1">Let's assume you're worried about misspelling the URL for the </span><code class="literal"><span class="koboSpan" id="kobo.766.1">netiquette</span></code><span class="koboSpan" id="kobo.767.1"> document. </span><span class="koboSpan" id="kobo.767.2">You can use the </span><code class="literal"><span class="koboSpan" id="kobo.768.1">recover</span></code><span class="koboSpan" id="kobo.769.1"> combinator on the </span><code class="literal"><span class="koboSpan" id="kobo.770.1">netiquette</span></code><span class="koboSpan" id="kobo.771.1"> future to provide a reasonable default message if anything fails, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.772.1">val netiquetteUrl = "http://www.ietf.org/rfc/rfc1855.doc" 
val netiquette = Future { Source.fromURL(netiquetteUrl).mkString } 
val answer = netiquette recover { 
  case e: java.io.FileNotFoundException =&gt; 
    "Dear secretary, thank you for your e-mail." </span><span class="koboSpan" id="kobo.772.2">+ 
    "You might be interested to know that ftp links " + 
    "can also point to regular files we keep on our servers." 
</span><span class="koboSpan" id="kobo.772.3">} 
answer foreach { case contents =&gt; log(contents) } 
Thread.sleep(2000) 
</span></pre><p><span class="koboSpan" id="kobo.773.1">Futures come with other combinators such as </span><code class="literal"><span class="koboSpan" id="kobo.774.1">filter</span></code><span class="koboSpan" id="kobo.775.1">, </span><code class="literal"><span class="koboSpan" id="kobo.776.1">fallbackTo</span></code><span class="koboSpan" id="kobo.777.1">, or </span><code class="literal"><span class="koboSpan" id="kobo.778.1">zip</span></code><span class="koboSpan" id="kobo.779.1">, but we will not cover all of them here; an understanding of the basic combinators should be sufficient. </span><span class="koboSpan" id="kobo.779.2">You might wish to study the remaining combinators in the API documentation.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Promises"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/><span class="koboSpan" id="kobo.1.1">Promises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.3.1">Chapter 2</span></a><span class="koboSpan" id="kobo.4.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.5.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.6.1">, we implemented an </span><code class="literal"><span class="koboSpan" id="kobo.7.1">asynchronous</span></code><span class="koboSpan" id="kobo.8.1"> method that used a worker thread and a task queue to receive and execute asynchronous computations. </span><span class="koboSpan" id="kobo.8.2">That example should have left you with a basic intuition about how the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">execute</span></code><span class="koboSpan" id="kobo.10.1"> method is implemented in execution contexts. </span><span class="koboSpan" id="kobo.10.2">You might be wondering how the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">Future.apply</span></code><span class="koboSpan" id="kobo.12.1"> method can return and complete a </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Future</span></code><span class="koboSpan" id="kobo.14.1"> object. </span><span class="koboSpan" id="kobo.14.2">We will study promises in this section to answer this question. </span><span class="strong"><strong><span class="koboSpan" id="kobo.15.1">Promises</span></strong></span><span class="koboSpan" id="kobo.16.1"> are objects that can be assigned a value or an exception only once. </span><span class="koboSpan" id="kobo.16.2">This is why promises are sometimes also called single-assignment variables. </span><span class="koboSpan" id="kobo.16.3">A promise is represented with the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Promise[T]</span></code><span class="koboSpan" id="kobo.18.1"> type in Scala. </span><span class="koboSpan" id="kobo.18.2">To create a promise instance, we use the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">Promise.apply</span></code><span class="koboSpan" id="kobo.20.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">Promise</span></code><span class="koboSpan" id="kobo.22.1"> companion object:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.23.1">def apply[T](): Promise[T] 
</span></pre><p><span class="koboSpan" id="kobo.24.1">This method returns a new promise instance. </span><span class="koboSpan" id="kobo.24.2">Like the </span><code class="literal"><span class="koboSpan" id="kobo.25.1">Future.apply</span></code><span class="koboSpan" id="kobo.26.1"> method, the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">Promise.apply</span></code><span class="koboSpan" id="kobo.28.1"> method returns immediately; it is non-blocking. </span><span class="koboSpan" id="kobo.28.2">However, the </span><code class="literal"><span class="koboSpan" id="kobo.29.1">Promise.apply</span></code><span class="koboSpan" id="kobo.30.1"> method does not start an asynchronous computation; it just creates a fresh promise object. </span><span class="koboSpan" id="kobo.30.2">When the promise object is created, it does not contain a value or an exception. </span><span class="koboSpan" id="kobo.30.3">To assign a value or an exception to a promise, we use the </span><code class="literal"><span class="koboSpan" id="kobo.31.1">success</span></code><span class="koboSpan" id="kobo.32.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.33.1">failure</span></code><span class="koboSpan" id="kobo.34.1"> method, respectively.</span></p><p><span class="koboSpan" id="kobo.35.1">Perhaps you have noticed that promises are very similar to futures. </span><span class="koboSpan" id="kobo.35.2">Both futures and promises are initially empty and can be completed with either a value or an exception. </span><span class="koboSpan" id="kobo.35.3">This is intentional; every promise object corresponds to exactly one future object. </span><span class="koboSpan" id="kobo.35.4">To obtain the future associated with a promise, we can call the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">future</span></code><span class="koboSpan" id="kobo.37.1"> method on the promise. </span><span class="koboSpan" id="kobo.37.2">Calling this method multiple times always returns the same future object.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/><span class="koboSpan" id="kobo.38.1">Note</span></h3><p><span class="koboSpan" id="kobo.39.1">A promise and a future represent two aspects of a single--assignment variable--the promise allows you to assign a value to the future object, whereas the future allows you to read that value.</span></p></div></div><p><span class="koboSpan" id="kobo.40.1">In the following code snippet, we create two promises, </span><code class="literal"><span class="koboSpan" id="kobo.41.1">p</span></code><span class="koboSpan" id="kobo.42.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.43.1">q</span></code><span class="koboSpan" id="kobo.44.1">, that can hold string values. </span><span class="koboSpan" id="kobo.44.2">We then install a </span><code class="literal"><span class="koboSpan" id="kobo.45.1">foreach</span></code><span class="koboSpan" id="kobo.46.1"> callback on the future associated with the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">p</span></code><span class="koboSpan" id="kobo.48.1"> promise and wait for one second. </span><span class="koboSpan" id="kobo.48.2">The callback is not invoked until the </span><code class="literal"><span class="koboSpan" id="kobo.49.1">p</span></code><span class="koboSpan" id="kobo.50.1"> promise is completed by calling the </span><code class="literal"><span class="koboSpan" id="kobo.51.1">success</span></code><span class="koboSpan" id="kobo.52.1"> method. </span><span class="koboSpan" id="kobo.52.2">We then fail the </span><code class="literal"><span class="koboSpan" id="kobo.53.1">q</span></code><span class="koboSpan" id="kobo.54.1"> promise in the same way and install a </span><code class="literal"><span class="koboSpan" id="kobo.55.1">failed.foreach</span></code><span class="koboSpan" id="kobo.56.1"> callback:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.57.1">object PromisesCreate extends App { 
  val p = Promise[String] 
  val q = Promise[String] 
  p.future foreach { case x =&gt; log(s"p succeeded with '$x'") } 
  Thread.sleep(1000) 
  p success "assigned" 
  q failure new Exception("not kept") 
  q.future.failed foreach { case t =&gt; log(s"q failed with $t") } 
  Thread.sleep(1000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.58.1">Alternatively, we can use the </span><code class="literal"><span class="koboSpan" id="kobo.59.1">complete</span></code><span class="koboSpan" id="kobo.60.1"> method and specify a </span><code class="literal"><span class="koboSpan" id="kobo.61.1">Try[T]</span></code><span class="koboSpan" id="kobo.62.1"> object to complete the promise. </span><span class="koboSpan" id="kobo.62.2">Depending on whether the </span><code class="literal"><span class="koboSpan" id="kobo.63.1">Try[T]</span></code><span class="koboSpan" id="kobo.64.1"> object is a success or a failure, the promise is successfully completed or failed. </span><span class="koboSpan" id="kobo.64.2">Importantly, after a promise is either successfully completed or failed, it cannot be assigned an exception or a value again in any way. </span><span class="koboSpan" id="kobo.64.3">Trying to do so results in an exception. </span><span class="koboSpan" id="kobo.64.4">Note that this is true even when there are multiple threads simultaneously calling </span><code class="literal"><span class="koboSpan" id="kobo.65.1">success</span></code><span class="koboSpan" id="kobo.66.1"> or </span><code class="literal"><span class="koboSpan" id="kobo.67.1">complete</span></code><span class="koboSpan" id="kobo.68.1">. </span><span class="koboSpan" id="kobo.68.2">Only one thread completes the promise, and the rest throw an exception.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/><span class="koboSpan" id="kobo.69.1">Note</span></h3><p><span class="koboSpan" id="kobo.70.1">Assigning a value or an exception to an already completed promise is not allowed and throws an exception.</span></p></div></div><p><span class="koboSpan" id="kobo.71.1">We can also use the </span><code class="literal"><span class="koboSpan" id="kobo.72.1">trySuccess</span></code><span class="koboSpan" id="kobo.73.1">, </span><code class="literal"><span class="koboSpan" id="kobo.74.1">tryFailure</span></code><span class="koboSpan" id="kobo.75.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.76.1">tryComplete</span></code><span class="koboSpan" id="kobo.77.1"> methods that correspond to </span><code class="literal"><span class="koboSpan" id="kobo.78.1">success</span></code><span class="koboSpan" id="kobo.79.1">, </span><code class="literal"><span class="koboSpan" id="kobo.80.1">failure</span></code><span class="koboSpan" id="kobo.81.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.82.1">complete</span></code><span class="koboSpan" id="kobo.83.1">, respectively, but return a Boolean value to indicate whether the assignment was successful. </span><span class="koboSpan" id="kobo.83.2">Recall that using </span><code class="literal"><span class="koboSpan" id="kobo.84.1">Future.apply</span></code><span class="koboSpan" id="kobo.85.1"> and callback methods with referentially transparent functions results in deterministic concurrent programs. </span><span class="koboSpan" id="kobo.85.2">As long as we do not use the </span><code class="literal"><span class="koboSpan" id="kobo.86.1">trySuccess</span></code><span class="koboSpan" id="kobo.87.1">, </span><code class="literal"><span class="koboSpan" id="kobo.88.1">tryFailure</span></code><span class="koboSpan" id="kobo.89.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.90.1">tryComplete</span></code><span class="koboSpan" id="kobo.91.1"> methods, and none of the </span><code class="literal"><span class="koboSpan" id="kobo.92.1">success</span></code><span class="koboSpan" id="kobo.93.1">, </span><code class="literal"><span class="koboSpan" id="kobo.94.1">failure</span></code><span class="koboSpan" id="kobo.95.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.96.1">complete</span></code><span class="koboSpan" id="kobo.97.1"> methods ever throw an exception, we can use promises and retain determinism in our programs.</span></p><p><span class="koboSpan" id="kobo.98.1">We now have everything we need to implement our custom </span><code class="literal"><span class="koboSpan" id="kobo.99.1">Future.apply</span></code><span class="koboSpan" id="kobo.100.1"> method. </span><span class="koboSpan" id="kobo.100.2">We call it </span><code class="literal"><span class="koboSpan" id="kobo.101.1">myFuture</span></code><span class="koboSpan" id="kobo.102.1"> in the following example. </span><span class="koboSpan" id="kobo.102.2">The </span><code class="literal"><span class="koboSpan" id="kobo.103.1">myFuture</span></code><span class="koboSpan" id="kobo.104.1"> method takes a </span><code class="literal"><span class="koboSpan" id="kobo.105.1">b</span></code><span class="koboSpan" id="kobo.106.1"> by-name parameter that is the asynchronous computation. </span><span class="koboSpan" id="kobo.106.2">First, it creates a </span><code class="literal"><span class="koboSpan" id="kobo.107.1">p</span></code><span class="koboSpan" id="kobo.108.1"> promise. </span><span class="koboSpan" id="kobo.108.2">Then, it starts an asynchronous computation on the </span><code class="literal"><span class="koboSpan" id="kobo.109.1">global</span></code><span class="koboSpan" id="kobo.110.1"> execution context. </span><span class="koboSpan" id="kobo.110.2">This computation tries to evaluate </span><code class="literal"><span class="koboSpan" id="kobo.111.1">b</span></code><span class="koboSpan" id="kobo.112.1"> and complete the promise. </span><span class="koboSpan" id="kobo.112.2">However, if the </span><code class="literal"><span class="koboSpan" id="kobo.113.1">b</span></code><span class="koboSpan" id="kobo.114.1"> body throws a nonfatal exception, the asynchronous computation fails the promise with that exception. </span><span class="koboSpan" id="kobo.114.2">In the meanwhile, the </span><code class="literal"><span class="koboSpan" id="kobo.115.1">myFuture</span></code><span class="koboSpan" id="kobo.116.1"> method returns the future immediately after starting the asynchronous computation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.117.1">import scala.util.control.NonFatal 
object PromisesCustomAsync extends App { 
  def myFuture[T](b: =&gt;T): Future[T] = { 
    val p = Promise[T] 
    global.execute(new Runnable { 
      def run() = try { 
        p.success(b) 
      } catch { 
        case NonFatal(e) =&gt; p.failure(e) 
      } 
    }) 
    p.future 
  } 
  val f = myFuture { "naa" + "na" * 8 + " Katamari Damacy!" </span><span class="koboSpan" id="kobo.117.2">} 
  f foreach { case text =&gt; log(text) } 
} 
</span></pre><p><span class="koboSpan" id="kobo.118.1">This is a common pattern when producing futures. </span><span class="koboSpan" id="kobo.118.2">We create a promise, let some other computation complete that promise, and return the corresponding future. </span><span class="koboSpan" id="kobo.118.3">However, promises were not invented just for our custom future computation method, </span><code class="literal"><span class="koboSpan" id="kobo.119.1">myFuture</span></code><span class="koboSpan" id="kobo.120.1">. </span><span class="koboSpan" id="kobo.120.2">In the following sections, we will study use cases in which promises are useful.</span></p><div class="section" title="Converting callback-based APIs"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec37"/><span class="koboSpan" id="kobo.121.1">Converting callback-based APIs</span></h2></div></div></div><p><span class="koboSpan" id="kobo.122.1">Scala futures are great. </span><span class="koboSpan" id="kobo.122.2">We already saw how they can be used to avoid blocking. </span><span class="koboSpan" id="kobo.122.3">We have learned that callbacks help us to avoid polling and busy-waiting. </span><span class="koboSpan" id="kobo.122.4">We witnessed that futures compose well with functional combinators and </span><code class="literal"><span class="koboSpan" id="kobo.123.1">for</span></code><span class="koboSpan" id="kobo.124.1"> comprehensions. </span><span class="koboSpan" id="kobo.124.2">In some cases, futures and promises even guarantee deterministic programs. </span><span class="koboSpan" id="kobo.124.3">But, we have to face the truth-not all legacy APIs were created using Scala futures. </span><span class="koboSpan" id="kobo.124.4">Although futures are now the right way to do asynchronous computing, various third-party libraries have different approaches to encoding latency.</span></p><p><span class="koboSpan" id="kobo.125.1">Legacy frameworks deal with latency in the program with raw callbacks. </span><span class="koboSpan" id="kobo.125.2">Methods that take an unbounded amount of time to complete do not return the result; instead, they take a callback argument, which is invoked with the result later. </span><span class="koboSpan" id="kobo.125.3">JavaScript libraries and frameworks are a good example for this--there is a single thread executing a JavaScript program and it is unacceptable to block that thread every time we call a blocking method.</span></p><p><span class="koboSpan" id="kobo.126.1">Such legacy systems have issues in large-scale development. </span><span class="koboSpan" id="kobo.126.2">First, they do not nicely compose, as we already saw. </span><span class="koboSpan" id="kobo.126.3">Second, they are hard to understand and reason about; a bunch of unstructured callbacks feels almost like spaghetti code. </span><span class="koboSpan" id="kobo.126.4">The control flow of the program is not apparent from the code, but is dictated by the internals of the library. </span><span class="koboSpan" id="kobo.126.5">This is called </span><span class="strong"><strong><span class="koboSpan" id="kobo.127.1">inversion of control</span></strong></span><span class="koboSpan" id="kobo.128.1">. </span><span class="koboSpan" id="kobo.128.2">We would like to somehow create a bridge between legacy callback-based APIs and futures, and avoid this inversion of control. </span><span class="koboSpan" id="kobo.128.3">This is where promises come in handy.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip45"/><span class="koboSpan" id="kobo.129.1">Tip</span></h3><p><span class="koboSpan" id="kobo.130.1">Use promises to bridge the gap between callback-based APIs and futures.</span></p></div></div><p><span class="koboSpan" id="kobo.131.1">Let's consider the </span><code class="literal"><span class="koboSpan" id="kobo.132.1">org.apache.commons.io.monitor</span></code><span class="koboSpan" id="kobo.133.1"> package from the </span><span class="strong"><strong><span class="koboSpan" id="kobo.134.1">Commons IO</span></strong></span><span class="koboSpan" id="kobo.135.1"> library. </span><span class="koboSpan" id="kobo.135.2">This package allows subscribing to filesystem events such as file and directory creation and deletion. </span><span class="koboSpan" id="kobo.135.3">Having become well versed in the use of futures, we do not want to deal with this API directly anymore. </span><span class="koboSpan" id="kobo.135.4">We, therefore, implement a </span><code class="literal"><span class="koboSpan" id="kobo.136.1">fileCreated</span></code><span class="koboSpan" id="kobo.137.1"> method that takes a directory name and returns a future with the name of the first file in that freshly created directory:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.138.1">import org.apache.commons.io.monitor._ 
</span></pre><p><span class="koboSpan" id="kobo.139.1">To subscribe to a filesystem event using this package, we first need to instantiate a </span><code class="literal"><span class="koboSpan" id="kobo.140.1">FileAlterationMonitor</span></code><span class="koboSpan" id="kobo.141.1"> object. </span><span class="koboSpan" id="kobo.141.2">This object periodically scans the filesystem for changes. </span><span class="koboSpan" id="kobo.141.3">After that, we need to create a </span><code class="literal"><span class="koboSpan" id="kobo.142.1">FileAlterationObserver</span></code><span class="koboSpan" id="kobo.143.1"> object, which observes a specific directory for changes. </span><span class="koboSpan" id="kobo.143.2">Finally, we create a </span><code class="literal"><span class="koboSpan" id="kobo.144.1">FileAlterationListenerAdaptor</span></code><span class="koboSpan" id="kobo.145.1"> object, which represents the callback. </span><span class="koboSpan" id="kobo.145.2">Its </span><code class="literal"><span class="koboSpan" id="kobo.146.1">onFileCreate</span></code><span class="koboSpan" id="kobo.147.1"> method is called when a file is created in the filesystem; we use it to complete the promise with the name of the file that was changed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.148.1">def fileCreated(directory: String): Future[String] = { 
  val p = Promise[String] 
  val fileMonitor = new FileAlterationMonitor(1000) 
  val observer = new FileAlterationObserver(directory) 
  val listener = new FileAlterationListenerAdaptor { 
    override def onFileCreate(file: File): Unit = 
      try p.trySuccess(file.getName) finally fileMonitor.stop() 
  } 
  observer.addListener(listener) 
  fileMonitor.addObserver(observer) 
  fileMonitor.start() 
  p.future 
} 
</span></pre><p><span class="koboSpan" id="kobo.149.1">Notice that the structure of this method is the same as the structure of the </span><code class="literal"><span class="koboSpan" id="kobo.150.1">myFuture</span></code><span class="koboSpan" id="kobo.151.1"> method. </span><span class="koboSpan" id="kobo.151.2">We first create a promise and defer the completion of the promise to some other computation. </span><span class="koboSpan" id="kobo.151.3">Then, we return the future associated with the promise. </span><span class="koboSpan" id="kobo.151.4">This recurring pattern is called the future-callback bridge.</span></p><p><span class="koboSpan" id="kobo.152.1">We can now use the future to subscribe to the first file change in the filesystem. </span><span class="koboSpan" id="kobo.152.2">We add a </span><code class="literal"><span class="koboSpan" id="kobo.153.1">foreach</span></code><span class="koboSpan" id="kobo.154.1"> call to the future returned by the </span><code class="literal"><span class="koboSpan" id="kobo.155.1">fileCreated</span></code><span class="koboSpan" id="kobo.156.1"> method, create a new file in the editor, and witness how the program detects a new file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.157.1">fileCreated(".") foreach { 
  case filename =&gt; log(s"Detected new file '$filename'") 
} 
</span></pre><p><span class="koboSpan" id="kobo.158.1">A useful utility that is not available on futures is the </span><code class="literal"><span class="koboSpan" id="kobo.159.1">timeout</span></code><span class="koboSpan" id="kobo.160.1"> method. </span><span class="koboSpan" id="kobo.160.2">We want to call a </span><code class="literal"><span class="koboSpan" id="kobo.161.1">timeout</span></code><span class="koboSpan" id="kobo.162.1"> method that takes some number of </span><code class="literal"><span class="koboSpan" id="kobo.163.1">t</span></code><span class="koboSpan" id="kobo.164.1"> milliseconds and returns a future that is completed after at least </span><code class="literal"><span class="koboSpan" id="kobo.165.1">t</span></code><span class="koboSpan" id="kobo.166.1"> milliseconds. </span><span class="koboSpan" id="kobo.166.2">We apply the callback-future bridge to the </span><code class="literal"><span class="koboSpan" id="kobo.167.1">Timer</span></code><span class="koboSpan" id="kobo.168.1"> class from the </span><code class="literal"><span class="koboSpan" id="kobo.169.1">java.util</span></code><span class="koboSpan" id="kobo.170.1"> package. </span><span class="koboSpan" id="kobo.170.2">We use a single timer object for all the </span><code class="literal"><span class="koboSpan" id="kobo.171.1">timeout</span></code><span class="koboSpan" id="kobo.172.1"> calls:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.173.1">import java.util._ 
private val timer = new Timer(true) 
</span></pre><p><span class="koboSpan" id="kobo.174.1">Again, we first create a promise </span><code class="literal"><span class="koboSpan" id="kobo.175.1">p</span></code><span class="koboSpan" id="kobo.176.1">. </span><span class="koboSpan" id="kobo.176.2">This promise holds no useful information other than the fact that it is completed, so we give it the type </span><code class="literal"><span class="koboSpan" id="kobo.177.1">Promise[Unit]</span></code><span class="koboSpan" id="kobo.178.1"> . </span><span class="koboSpan" id="kobo.178.2">We then call the </span><code class="literal"><span class="koboSpan" id="kobo.179.1">Timer</span></code><span class="koboSpan" id="kobo.180.1"> class's </span><code class="literal"><span class="koboSpan" id="kobo.181.1">schedule</span></code><span class="koboSpan" id="kobo.182.1"> method with a </span><code class="literal"><span class="koboSpan" id="kobo.183.1">TimerTask</span></code><span class="koboSpan" id="kobo.184.1"> object that completes the </span><code class="literal"><span class="koboSpan" id="kobo.185.1">p</span></code><span class="koboSpan" id="kobo.186.1"> promise after </span><code class="literal"><span class="koboSpan" id="kobo.187.1">t</span></code><span class="koboSpan" id="kobo.188.1"> milliseconds:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.189.1">def timeout(t: Long): Future[Unit] = { 
  val p = Promise[Unit] 
  timer.schedule(new TimerTask { 
    def run() = { 
      p success () 
      timer.cancel() 
    } 
  }, t) 
  p.future 
} 
timeout(1000) foreach { case _ =&gt; log("Timed out!") } 
Thread.sleep(2000) 
</span></pre><p><span class="koboSpan" id="kobo.190.1">The future returned by the </span><code class="literal"><span class="koboSpan" id="kobo.191.1">timeout</span></code><span class="koboSpan" id="kobo.192.1"> method can be used to install a callback, or it can be combined with other futures using combinators. </span><span class="koboSpan" id="kobo.192.2">In the next section, we will introduce new combinators for this purpose.</span></p></div><div class="section" title="Extending the future API"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/><span class="koboSpan" id="kobo.193.1">Extending the future API</span></h2></div></div></div><p><span class="koboSpan" id="kobo.194.1">Usually, the existing future combinators are sufficient for most tasks, but occasionally we want to define new ones. </span><span class="koboSpan" id="kobo.194.2">This is another use case for promises. </span><span class="koboSpan" id="kobo.194.3">Assume that we want to add a combinator to futures, as follows:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.195.1">def or(that: Future[T]): Future[T] 
</span></pre><p><span class="koboSpan" id="kobo.196.1">This method returns a new future of the same type that is assigned the value of the </span><code class="literal"><span class="koboSpan" id="kobo.197.1">this</span></code><span class="koboSpan" id="kobo.198.1"> future or the </span><code class="literal"><span class="koboSpan" id="kobo.199.1">that</span></code><span class="koboSpan" id="kobo.200.1"> future, whichever is completed first. </span><span class="koboSpan" id="kobo.200.2">We cannot add this method directly to the </span><code class="literal"><span class="koboSpan" id="kobo.201.1">Future</span></code><span class="koboSpan" id="kobo.202.1"> trait because futures are defined in the Scala standard library, but we can create an implicit conversion that adds this method. </span><span class="koboSpan" id="kobo.202.2">Recall that, if you call a nonexistent </span><code class="literal"><span class="koboSpan" id="kobo.203.1">xyz</span></code><span class="koboSpan" id="kobo.204.1"> method on an object of some type </span><code class="literal"><span class="koboSpan" id="kobo.205.1">A</span></code><span class="koboSpan" id="kobo.206.1">, the Scala compiler will search for all implicit conversions from type </span><code class="literal"><span class="koboSpan" id="kobo.207.1">A</span></code><span class="koboSpan" id="kobo.208.1">  to some other type that has the </span><code class="literal"><span class="koboSpan" id="kobo.209.1">xyz</span></code><span class="koboSpan" id="kobo.210.1"> method. </span><span class="koboSpan" id="kobo.210.2">One way to define such an implicit conversion is to use Scala's implicit classes:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.211.1">implicit class FutureOps[T](val self: Future[T]) { 
  def or(that: Future[T]): Future[T] = { 
    val p = Promise[T] 
    self onComplete { case x =&gt; p tryComplete x } 
    that onComplete { case y =&gt; p tryComplete y } 
    p.future 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.212.1">The implicit </span><code class="literal"><span class="koboSpan" id="kobo.213.1">FutureOps</span></code><span class="koboSpan" id="kobo.214.1"> class converts a future of type </span><code class="literal"><span class="koboSpan" id="kobo.215.1">Future[T]</span></code><span class="koboSpan" id="kobo.216.1">  to an object with an additional </span><code class="literal"><span class="koboSpan" id="kobo.217.1">or</span></code><span class="koboSpan" id="kobo.218.1"> method. </span><span class="koboSpan" id="kobo.218.2">Inside the </span><code class="literal"><span class="koboSpan" id="kobo.219.1">FutureOps</span></code><span class="koboSpan" id="kobo.220.1"> object, we refer to the original future with the name </span><code class="literal"><span class="koboSpan" id="kobo.221.1">self</span></code><span class="koboSpan" id="kobo.222.1">; we cannot use </span><code class="literal"><span class="koboSpan" id="kobo.223.1">this</span></code><span class="koboSpan" id="kobo.224.1"> word, because </span><code class="literal"><span class="koboSpan" id="kobo.225.1">this</span></code><span class="koboSpan" id="kobo.226.1"> is a reserved keyword that refers to the </span><code class="literal"><span class="koboSpan" id="kobo.227.1">FutureOps</span></code><span class="koboSpan" id="kobo.228.1"> object. </span><span class="koboSpan" id="kobo.228.2">The </span><code class="literal"><span class="koboSpan" id="kobo.229.1">or</span></code><span class="koboSpan" id="kobo.230.1"> method installs callbacks on </span><code class="literal"><span class="koboSpan" id="kobo.231.1">self</span></code><span class="koboSpan" id="kobo.232.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.233.1">that</span></code><span class="koboSpan" id="kobo.234.1"> future. </span><span class="koboSpan" id="kobo.234.2">Each of these callbacks calls the </span><code class="literal"><span class="koboSpan" id="kobo.235.1">tryComplete</span></code><span class="koboSpan" id="kobo.236.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.237.1">p</span></code><span class="koboSpan" id="kobo.238.1"> promise; the callback that executes first successfully completes the promise. </span><span class="koboSpan" id="kobo.238.2">The </span><code class="literal"><span class="koboSpan" id="kobo.239.1">tryComplete</span></code><span class="koboSpan" id="kobo.240.1"> method in the other callback returns </span><code class="literal"><span class="koboSpan" id="kobo.241.1">false</span></code><span class="koboSpan" id="kobo.242.1"> and does not change the state of the promise.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip46"/><span class="koboSpan" id="kobo.243.1">Tip</span></h3><p><span class="koboSpan" id="kobo.244.1">Use promises to extend futures with additional functional combinators.</span></p></div></div><p><span class="koboSpan" id="kobo.245.1">Note that we used the </span><code class="literal"><span class="koboSpan" id="kobo.246.1">tryComplete</span></code><span class="koboSpan" id="kobo.247.1"> method in this example, and the </span><code class="literal"><span class="koboSpan" id="kobo.248.1">or</span></code><span class="koboSpan" id="kobo.249.1"> combinator is nondeterministic as a result. </span><span class="koboSpan" id="kobo.249.2">The resulting future is completed with the value of one of the input futures depending on the execution schedule. </span><span class="koboSpan" id="kobo.249.3">In this particular case, this is exactly what we want.</span></p></div><div class="section" title="Cancellation of asynchronous computations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/><span class="koboSpan" id="kobo.250.1">Cancellation of asynchronous computations</span></h2></div></div></div><p><span class="koboSpan" id="kobo.251.1">In some cases, we want to cancel a future computation. </span><span class="koboSpan" id="kobo.251.2">This might be because a future computation takes more than the allotted amount of time, or because the user clicks on the </span><span class="strong"><strong><span class="koboSpan" id="kobo.252.1">Cancel</span></strong></span><span class="koboSpan" id="kobo.253.1"> button in the UI. </span><span class="koboSpan" id="kobo.253.2">In either case, we need to provide some alternative value for the canceled future.</span></p><p><span class="koboSpan" id="kobo.254.1">Futures come without built-in support for cancellation. </span><span class="koboSpan" id="kobo.254.2">Once a future computation starts, it is not possible to cancel it directly. </span><span class="koboSpan" id="kobo.254.3">Recall from </span><a class="link" href="ch02.html" title="Chapter 2. Concurrency on the JVM and the Java Memory Model"><span class="koboSpan" id="kobo.255.1">Chapter 2</span></a><span class="koboSpan" id="kobo.256.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.257.1">Concurrency on the JVM and the Java Memory Model</span></em></span><span class="koboSpan" id="kobo.258.1">, that violently stopping concurrent computations can be harmful, and this is why the </span><code class="literal"><span class="koboSpan" id="kobo.259.1">Thread</span></code><span class="koboSpan" id="kobo.260.1"> methods such as </span><code class="literal"><span class="koboSpan" id="kobo.261.1">stop</span></code><span class="koboSpan" id="kobo.262.1"> were deprecated in the early JDK releases.</span></p><p><span class="koboSpan" id="kobo.263.1">One approach to cancel a future is to compose it with another future called the </span><span class="strong"><strong><span class="koboSpan" id="kobo.264.1">cancellation future</span></strong></span><span class="koboSpan" id="kobo.265.1">. </span><span class="koboSpan" id="kobo.265.2">The </span><code class="literal"><span class="koboSpan" id="kobo.266.1">cancellation</span></code><span class="koboSpan" id="kobo.267.1"> future provides a default value when a future is canceled. </span><span class="koboSpan" id="kobo.267.2">We can use the </span><code class="literal"><span class="koboSpan" id="kobo.268.1">or</span></code><span class="koboSpan" id="kobo.269.1"> combinator, discussed in the previous section, along with the </span><code class="literal"><span class="koboSpan" id="kobo.270.1">timeout</span></code><span class="koboSpan" id="kobo.271.1"> method, to compose a future with its </span><code class="literal"><span class="koboSpan" id="kobo.272.1">cancellation</span></code><span class="koboSpan" id="kobo.273.1"> future:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.274.1">val f = timeout(1000).map(_ =&gt; "timeout!") or Future { 
  Thread.sleep(999) 
  "work completed!" 
</span><span class="koboSpan" id="kobo.274.2">} 
</span></pre><p><span class="koboSpan" id="kobo.275.1">The nondeterminism of the </span><code class="literal"><span class="koboSpan" id="kobo.276.1">or</span></code><span class="koboSpan" id="kobo.277.1"> combinator is apparent when running this program. </span><span class="koboSpan" id="kobo.277.2">The </span><code class="literal"><span class="koboSpan" id="kobo.278.1">timeout</span></code><span class="koboSpan" id="kobo.279.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.280.1">sleep</span></code><span class="koboSpan" id="kobo.281.1"> statements are precisely tuned to occur approximately at the same time. </span><span class="koboSpan" id="kobo.281.2">Another thing worth noting is that the computation started by the </span><code class="literal"><span class="koboSpan" id="kobo.282.1">Future.apply</span></code><span class="koboSpan" id="kobo.283.1"> method does not actually stop if a timeout occurs. </span><span class="koboSpan" id="kobo.283.2">The </span><code class="literal"><span class="koboSpan" id="kobo.284.1">f</span></code><span class="koboSpan" id="kobo.285.1"> future is completed with the value </span><code class="literal"><span class="koboSpan" id="kobo.286.1">"timeout!"</span></code><span class="koboSpan" id="kobo.287.1">, but the future computation proceeds concurrently. </span><span class="koboSpan" id="kobo.287.2">Eventually, it fails to set the value of the promise when calling </span><code class="literal"><span class="koboSpan" id="kobo.288.1">tryComplete</span></code><span class="koboSpan" id="kobo.289.1"> in the </span><code class="literal"><span class="koboSpan" id="kobo.290.1">or</span></code><span class="koboSpan" id="kobo.291.1"> combinator. </span><span class="koboSpan" id="kobo.291.2">In many cases, this is not a problem. </span><span class="koboSpan" id="kobo.291.3">An HTTP request that needs to complete a future does not occupy any computational resources, and will eventually timeout anyway. </span><span class="koboSpan" id="kobo.291.4">A keyboard event that completes a future only consumes a small amount of CPU time when it triggers. </span><span class="koboSpan" id="kobo.291.5">Callback-based futures can usually be canceled, as in the preceding example. </span><span class="koboSpan" id="kobo.291.6">On the other hand, a future that performs an asynchronous computation can use a lot of CPU power or other resources. </span><span class="koboSpan" id="kobo.291.7">We might want to ensure that actions such as scanning the filesystem or downloading a huge file really terminate.</span></p><p><span class="koboSpan" id="kobo.292.1">A future computation cannot be forcefully stopped. </span><span class="koboSpan" id="kobo.292.2">Instead, there should exist some form of cooperation between the future computation and the client of the future. </span><span class="koboSpan" id="kobo.292.3">In the examples seen so far, asynchronous computations always use futures to communicate a value to the client. </span><span class="koboSpan" id="kobo.292.4">In this case, the client also communicates in the opposite direction to let the asynchronous computation know that it should stop. </span><span class="koboSpan" id="kobo.292.5">Naturally, we use futures and promises to accomplish this two-way communication.</span></p><p><span class="koboSpan" id="kobo.293.1">First, we define a type </span><code class="literal"><span class="koboSpan" id="kobo.294.1">Cancellable[T]</span></code><span class="koboSpan" id="kobo.295.1">  as a pair of </span><code class="literal"><span class="koboSpan" id="kobo.296.1">Promise[Unit]</span></code><span class="koboSpan" id="kobo.297.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.298.1">Future[T]</span></code><span class="koboSpan" id="kobo.299.1"> objects. </span><span class="koboSpan" id="kobo.299.2">The client will use the </span><code class="literal"><span class="koboSpan" id="kobo.300.1">Promise[Unit]</span></code><span class="koboSpan" id="kobo.301.1"> part to request a cancellation, and the </span><code class="literal"><span class="koboSpan" id="kobo.302.1">Future[T]</span></code><span class="koboSpan" id="kobo.303.1"> part to subscribe to the result of the computation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.304.1">object PromisesCancellation extends App { 
  type Cancellable[T] = (Promise[Unit], Future[T]) 
</span></pre><p><span class="koboSpan" id="kobo.305.1">The </span><code class="literal"><span class="koboSpan" id="kobo.306.1">cancellable</span></code><span class="koboSpan" id="kobo.307.1"> method takes the </span><code class="literal"><span class="koboSpan" id="kobo.308.1">b</span></code><span class="koboSpan" id="kobo.309.1"> body of the asynchronous computation. </span><span class="koboSpan" id="kobo.309.2">This time, the </span><code class="literal"><span class="koboSpan" id="kobo.310.1">b</span></code><span class="koboSpan" id="kobo.311.1"> body takes a single parameter, </span><code class="literal"><span class="koboSpan" id="kobo.312.1">Future[Unit]</span></code><span class="koboSpan" id="kobo.313.1">, to check if the cancellation was requested. </span><span class="koboSpan" id="kobo.313.2">The </span><code class="literal"><span class="koboSpan" id="kobo.314.1">cancellable</span></code><span class="koboSpan" id="kobo.315.1"> method creates a </span><code class="literal"><span class="koboSpan" id="kobo.316.1">cancel</span></code><span class="koboSpan" id="kobo.317.1"> promise of the type </span><code class="literal"><span class="koboSpan" id="kobo.318.1">Promise[Unit]</span></code><span class="koboSpan" id="kobo.319.1">  and forwards its corresponding future to the asynchronous computation. </span><span class="koboSpan" id="kobo.319.2">We call this promise the </span><span class="strong"><strong><span class="koboSpan" id="kobo.320.1">cancellation promise</span></strong></span><span class="koboSpan" id="kobo.321.1">. </span><span class="koboSpan" id="kobo.321.2">The </span><code class="literal"><span class="koboSpan" id="kobo.322.1">cancel</span></code><span class="koboSpan" id="kobo.323.1"> promise will be used to signal that the asynchronous computation </span><code class="literal"><span class="koboSpan" id="kobo.324.1">b</span></code><span class="koboSpan" id="kobo.325.1"> should end. </span><span class="koboSpan" id="kobo.325.2">After the asynchronous computation </span><code class="literal"><span class="koboSpan" id="kobo.326.1">b</span></code><span class="koboSpan" id="kobo.327.1"> returns some value </span><code class="literal"><span class="koboSpan" id="kobo.328.1">r</span></code><span class="koboSpan" id="kobo.329.1">, the </span><code class="literal"><span class="koboSpan" id="kobo.330.1">cancel</span></code><span class="koboSpan" id="kobo.331.1"> promise needs to fail. </span><span class="koboSpan" id="kobo.331.2">This ensures that, if the type </span><code class="literal"><span class="koboSpan" id="kobo.332.1">Future[T]</span></code><span class="koboSpan" id="kobo.333.1">  is completed, then the client cannot successfully cancel the computation using the </span><code class="literal"><span class="koboSpan" id="kobo.334.1">cancel</span></code><span class="koboSpan" id="kobo.335.1"> promise:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.336.1">  def cancellable[T](b: Future[Unit] =&gt; T): Cancellable[T] = { 
    val cancel = Promise[Unit] 
    val f = Future { 
      val r = b(cancel.future) 
      if (!cancel.tryFailure(new Exception)) 
        throw new CancellationException 
      r 
    } 
    (cancel, f) 
  } 
</span></pre><p><span class="koboSpan" id="kobo.337.1">If calling </span><code class="literal"><span class="koboSpan" id="kobo.338.1">tryFailure</span></code><span class="koboSpan" id="kobo.339.1"> on the </span><code class="literal"><span class="koboSpan" id="kobo.340.1">cancel</span></code><span class="koboSpan" id="kobo.341.1"> promise returns </span><code class="literal"><span class="koboSpan" id="kobo.342.1">false</span></code><span class="koboSpan" id="kobo.343.1">, then the client must have already completed the </span><code class="literal"><span class="koboSpan" id="kobo.344.1">cancel</span></code><span class="koboSpan" id="kobo.345.1"> promise. </span><span class="koboSpan" id="kobo.345.2">In this case, we cannot fail the client's attempt to cancel the computation, so we throw a </span><code class="literal"><span class="koboSpan" id="kobo.346.1">CancellationException</span></code><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">Note that we cannot omit this check, as it exists to avoid the race in which the client successfully requests the cancellation, and the future computation simultaneously completes the future.</span></p><p><span class="koboSpan" id="kobo.348.1">The asynchronous computation must occasionally check if the future was canceled using the </span><code class="literal"><span class="koboSpan" id="kobo.349.1">isCompleted</span></code><span class="koboSpan" id="kobo.350.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.351.1">cancel</span></code><span class="koboSpan" id="kobo.352.1"> future. </span><span class="koboSpan" id="kobo.352.2">If it detects that it was canceled, it must cease execution by throwing a </span><code class="literal"><span class="koboSpan" id="kobo.353.1">CancellationException</span></code><span class="koboSpan" id="kobo.354.1"> value:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.355.1">  val (cancel, value) = cancellable { cancel =&gt; 
    var i = 0 
    while (i &lt; 5) { 
      if (cancel.isCompleted) throw new CancellationException 
      Thread.sleep(500) 
      log(s"$i: working") 
      i += 1 
    } 
    "resulting value" 
  } 
</span></pre><p><span class="koboSpan" id="kobo.356.1">After the </span><code class="literal"><span class="koboSpan" id="kobo.357.1">cancellable</span></code><span class="koboSpan" id="kobo.358.1"> computation starts, the main thread waits for 1,500 milliseconds and then calls </span><code class="literal"><span class="koboSpan" id="kobo.359.1">trySuccess</span></code><span class="koboSpan" id="kobo.360.1"> to complete the cancellation promise. </span><span class="koboSpan" id="kobo.360.2">By this time, the cancellation promise could have already failed; in this case, calling </span><code class="literal"><span class="koboSpan" id="kobo.361.1">success</span></code><span class="koboSpan" id="kobo.362.1"> instead of the </span><code class="literal"><span class="koboSpan" id="kobo.363.1">trySuccess</span></code><span class="koboSpan" id="kobo.364.1"> method would result in an exception:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.365.1">  Thread.sleep(1500) 
  cancel trySuccess () 
  log("computation cancelled!") 
  Thread.sleep(2000) 
} 
</span></pre><p><span class="koboSpan" id="kobo.366.1">We expect to see the final </span><code class="literal"><span class="koboSpan" id="kobo.367.1">working</span></code><span class="koboSpan" id="kobo.368.1"> message printed after the </span><code class="literal"><span class="koboSpan" id="kobo.369.1">"computation cancelled!"</span></code><span class="koboSpan" id="kobo.370.1"> message from the main thread. </span><span class="koboSpan" id="kobo.370.2">This is because the asynchronous computation uses polling and does not immediately detect that it was cancelled.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip47"/><span class="koboSpan" id="kobo.371.1">Tip</span></h3><p><span class="koboSpan" id="kobo.372.1">Use promises to implement cancellation or any other form of two-way communication between the client and the asynchronous computation.</span></p></div></div><p><span class="koboSpan" id="kobo.373.1">Note that calling the </span><code class="literal"><span class="koboSpan" id="kobo.374.1">trySuccess</span></code><span class="koboSpan" id="kobo.375.1"> method on the </span><code class="literal"><span class="koboSpan" id="kobo.376.1">cancel</span></code><span class="koboSpan" id="kobo.377.1"> promise does not guarantee that the computation will really be canceled. </span><span class="koboSpan" id="kobo.377.2">It is entirely possible that the asynchronous computation fails the </span><code class="literal"><span class="koboSpan" id="kobo.378.1">cancel</span></code><span class="koboSpan" id="kobo.379.1"> promise before the client has a chance to cancel it. </span><span class="koboSpan" id="kobo.379.2">Thus, the client, such as the main thread in our example, should in general use the return value from the </span><code class="literal"><span class="koboSpan" id="kobo.380.1">trySuccess</span></code><span class="koboSpan" id="kobo.381.1"> method to check if the cancellation succeeded.</span></p></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Futures and blocking"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/><span class="koboSpan" id="kobo.1.1">Futures and blocking</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Examples in this book should have shed the light into why blocking is sometimes considered an anti-pattern. </span><span class="koboSpan" id="kobo.2.2">Futures and asynchronous computations mainly exist to avoid blocking, but in some cases, we cannot live without it. </span><span class="koboSpan" id="kobo.2.3">It is, therefore, valid to ask how blocking interacts with futures.</span></p><p><span class="koboSpan" id="kobo.3.1">There are two ways to block with futures. </span><span class="koboSpan" id="kobo.3.2">The first is waiting until a future is completed. </span><span class="koboSpan" id="kobo.3.3">The second is blocking from within an asynchronous computation. </span><span class="koboSpan" id="kobo.3.4">We will study both the topics in this section.</span></p><div class="section" title="Awaiting futures"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/><span class="koboSpan" id="kobo.4.1">Awaiting futures</span></h2></div></div></div><p><span class="koboSpan" id="kobo.5.1">In rare situations, we cannot use callbacks or future combinators to avoid blocking. </span><span class="koboSpan" id="kobo.5.2">For example, the main thread that starts multiple asynchronous computations has to wait for these computations to finish. </span><span class="koboSpan" id="kobo.5.3">If an execution context uses daemon threads, as is the case with the </span><code class="literal"><span class="koboSpan" id="kobo.6.1">global</span></code><span class="koboSpan" id="kobo.7.1"> execution context, the main thread needs to block to prevent the JVM process from terminating.</span></p><p><span class="koboSpan" id="kobo.8.1">In these exceptional circumstances, we use the </span><code class="literal"><span class="koboSpan" id="kobo.9.1">ready</span></code><span class="koboSpan" id="kobo.10.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.11.1">result</span></code><span class="koboSpan" id="kobo.12.1"> methods on the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Await</span></code><span class="koboSpan" id="kobo.14.1"> object from the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">scala.concurrent</span></code><span class="koboSpan" id="kobo.16.1"> package. </span><span class="koboSpan" id="kobo.16.2">The </span><code class="literal"><span class="koboSpan" id="kobo.17.1">ready</span></code><span class="koboSpan" id="kobo.18.1"> method blocks the caller thread until the specified future is completed. </span><span class="koboSpan" id="kobo.18.2">The </span><code class="literal"><span class="koboSpan" id="kobo.19.1">result</span></code><span class="koboSpan" id="kobo.20.1"> method also blocks the caller thread, but returns the value of the future if it was completed successfully, or throws the exception in the future if the future was failed.</span></p><p><span class="koboSpan" id="kobo.21.1">Both the methods require specifying a timeout parameter-the longest duration that the caller should wait for the completion of the future before a </span><code class="literal"><span class="koboSpan" id="kobo.22.1">TimeoutException</span></code><span class="koboSpan" id="kobo.23.1"> is thrown. </span><span class="koboSpan" id="kobo.23.2">To specify a timeout, we import the </span><code class="literal"><span class="koboSpan" id="kobo.24.1">scala.concurrent.duration</span></code><span class="koboSpan" id="kobo.25.1"> package. </span><span class="koboSpan" id="kobo.25.2">This allows us to write expressions such as </span><code class="literal"><span class="koboSpan" id="kobo.26.1">10.seconds</span></code><span class="koboSpan" id="kobo.27.1">:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.28.1">import scala.concurrent.duration._ 
object BlockingAwait extends App { 
  val urlSpecSizeFuture = Future { 
    val specUrl = "http://www.w3.org/Addressing/URL/url-spec.txt" 
    Source.fromURL(specUrl).size 
  } 
  val urlSpecSize = Await.result(urlSpecSizeFuture, 10.seconds) 
  log(s"url spec contains $urlSpecSize characters") 
} 
</span></pre><p><span class="koboSpan" id="kobo.29.1">In this example, the main thread starts a computation that retrieves the URL specification and then awaits. </span><span class="koboSpan" id="kobo.29.2">By this time, the World Wide Web Consortium is worried that a DOS attack is under way, so this is the last time we download the URL specification.</span></p></div><div class="section" title="Blocking in asynchronous computations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/><span class="koboSpan" id="kobo.30.1">Blocking in asynchronous computations</span></h2></div></div></div><p><span class="koboSpan" id="kobo.31.1">Waiting for the completion of a future is not the only way to block. </span><span class="koboSpan" id="kobo.31.2">Some legacy APIs do not use callbacks to asynchronously return results. </span><span class="koboSpan" id="kobo.31.3">Instead, such APIs expose the blocking methods. </span><span class="koboSpan" id="kobo.31.4">After we call a blocking method, we lose control over the thread; it is up to the blocking method to unblock the thread and return the control back.</span></p><p><span class="koboSpan" id="kobo.32.1">Execution contexts are often implemented using thread pools. </span><span class="koboSpan" id="kobo.32.2">As we saw in </span><a class="link" href="ch03.html" title="Chapter 3. Traditional Building Blocks of Concurrency"><span class="koboSpan" id="kobo.33.1">Chapter 3</span></a><span class="koboSpan" id="kobo.34.1">, </span><span class="emphasis"><em><span class="koboSpan" id="kobo.35.1">Traditional Building Blocks of Concurrency</span></em></span><span class="koboSpan" id="kobo.36.1">, blocking worker threads can lead to thread starvation. </span><span class="koboSpan" id="kobo.36.2">Thus, by starting future computations that block, it is possible to reduce parallelism and even cause deadlocks. </span><span class="koboSpan" id="kobo.36.3">This is illustrated in the following example, in which 16 separate future computations call the </span><code class="literal"><span class="koboSpan" id="kobo.37.1">sleep</span></code><span class="koboSpan" id="kobo.38.1"> method, and the main thread waits until they complete for an unbounded amount of time:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.39.1">val startTime = System.nanoTime 
val futures = for (_ &lt;- 0 until 16) yield Future { 
  Thread.sleep(1000) 
} 
for (f &lt;- futures) Await.ready(f, Duration.Inf) 
val endTime = System.nanoTime 
log(s"Total time = ${(endTime - startTime) / 1000000} ms") 
log(s"Total CPUs = ${Runtime.getRuntime.availableProcessors}") 
</span></pre><p><span class="koboSpan" id="kobo.40.1">Assume that you have eight cores in your processor. </span><span class="koboSpan" id="kobo.40.2">This program does not end in one second. </span><span class="koboSpan" id="kobo.40.3">Instead, the first batch of eight futures started by the </span><code class="literal"><span class="koboSpan" id="kobo.41.1">Future.apply</span></code><span class="koboSpan" id="kobo.42.1"> method will block all the worker threads for one second, and then another batch of eight futures will block for another second. </span><span class="koboSpan" id="kobo.42.2">As a result, none of our eight processor cores can do any useful work for one second.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip48"/><span class="koboSpan" id="kobo.43.1">Tip</span></h3><p><span class="koboSpan" id="kobo.44.1">Avoid blocking in asynchronous computations, as it can cause thread starvation.</span></p></div></div><p><span class="koboSpan" id="kobo.45.1">If you absolutely must block, then the part of the code that blocks should be enclosed within the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">blocking</span></code><span class="koboSpan" id="kobo.47.1"> call. </span><span class="koboSpan" id="kobo.47.2">This signals to the execution context that the worker thread is blocked and allows it to temporarily spawn additional worker threads if necessary:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.48.1">  val futures = for (_ &lt;- 0 until 16) yield Future { 
    blocking { 
      Thread.sleep(1000) 
    } 
  } 
</span></pre><p><span class="koboSpan" id="kobo.49.1">With the </span><code class="literal"><span class="koboSpan" id="kobo.50.1">blocking</span></code><span class="koboSpan" id="kobo.51.1"> call around the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">sleep</span></code><span class="koboSpan" id="kobo.53.1"> call, the </span><code class="literal"><span class="koboSpan" id="kobo.54.1">global</span></code><span class="koboSpan" id="kobo.55.1"> execution context spawns additional threads when it detects that there is more work than the worker threads. </span><span class="koboSpan" id="kobo.55.2">All 16 future computations can execute concurrently, and the program terminates after one second.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note49"/><span class="koboSpan" id="kobo.56.1">Note</span></h3><p><span class="koboSpan" id="kobo.57.1">The </span><code class="literal"><span class="koboSpan" id="kobo.58.1">Await.ready</span></code><span class="koboSpan" id="kobo.59.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.60.1">Await.result</span></code><span class="koboSpan" id="kobo.61.1"> statements block the caller thread until the future is completed, and are in most cases used outside the asynchronous computations. </span><span class="koboSpan" id="kobo.61.2">They are blocking operations. </span><span class="koboSpan" id="kobo.61.3">The </span><code class="literal"><span class="koboSpan" id="kobo.62.1">blocking</span></code><span class="koboSpan" id="kobo.63.1"> statement is used inside asynchronous code to designate that the enclosed block of code contains a blocking call. </span><span class="koboSpan" id="kobo.63.2">It is not a blocking operation by itself.</span></p></div></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="The Scala Async library"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec29"/><span class="koboSpan" id="kobo.1.1">The Scala Async library</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">In the final section of this chapter, we turn to the Scala </span><span class="strong"><strong><span class="koboSpan" id="kobo.3.1">Async</span></strong></span><span class="koboSpan" id="kobo.4.1"> library. </span><span class="koboSpan" id="kobo.4.2">You should understand that the Scala Async library does not add anything conceptually new to futures and promises. </span><span class="koboSpan" id="kobo.4.3">If you got this far in this chapter, you already know everything that you need to know about asynchronous programming, callbacks, future composition, promises, and blocking. </span><span class="koboSpan" id="kobo.4.4">You can start building asynchronous applications right away.</span></p><p><span class="koboSpan" id="kobo.5.1">Having said that, the Scala Async library is a convenient library for futures and promises that allow expressing chains of asynchronous computations more conveniently. </span><span class="koboSpan" id="kobo.5.2">Every program that you express using the Scala Async library can also be expressed using futures and promises. </span><span class="koboSpan" id="kobo.5.3">Often, the Scala Async library allows writing shorter, more concise, and understandable programs.</span></p><p><span class="koboSpan" id="kobo.6.1">The Scala Async library introduces two new method calls--the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">async</span></code><span class="koboSpan" id="kobo.8.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.9.1">await</span></code><span class="koboSpan" id="kobo.10.1"> methods. </span><span class="koboSpan" id="kobo.10.2">The </span><code class="literal"><span class="koboSpan" id="kobo.11.1">async</span></code><span class="koboSpan" id="kobo.12.1"> method is conceptually equivalent to the </span><code class="literal"><span class="koboSpan" id="kobo.13.1">Future.apply</span></code><span class="koboSpan" id="kobo.14.1"> method; it starts an asynchronous computation and returns a future object. </span><span class="koboSpan" id="kobo.14.2">The </span><code class="literal"><span class="koboSpan" id="kobo.15.1">await</span></code><span class="koboSpan" id="kobo.16.1"> method should not be confused with the </span><code class="literal"><span class="koboSpan" id="kobo.17.1">Await</span></code><span class="koboSpan" id="kobo.18.1"> object used to block on futures. </span><span class="koboSpan" id="kobo.18.2">The </span><code class="literal"><span class="koboSpan" id="kobo.19.1">await</span></code><span class="koboSpan" id="kobo.20.1"> method takes a future and returns that future's value. </span><span class="koboSpan" id="kobo.20.2">However, unlike the methods on the </span><code class="literal"><span class="koboSpan" id="kobo.21.1">Await</span></code><span class="koboSpan" id="kobo.22.1"> object, the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">await</span></code><span class="koboSpan" id="kobo.24.1"> method does not block the underlying thread; we will soon see how this is possible.</span></p><p><span class="koboSpan" id="kobo.25.1">The Scala Async library is currently not part of the Scala standard library. </span><span class="koboSpan" id="kobo.25.2">To use it, we need to add the following line to our build definition file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.26.1">libraryDependencies += 
  "org.scala-lang.modules" %% "scala-async" % "0.9.1" 
</span></pre><p><span class="koboSpan" id="kobo.27.1">As a simple example, consider the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">delay</span></code><span class="koboSpan" id="kobo.29.1"> method, which returns a future that is completed after </span><code class="literal"><span class="koboSpan" id="kobo.30.1">n</span></code><span class="koboSpan" id="kobo.31.1"> seconds. </span><span class="koboSpan" id="kobo.31.2">We use the </span><code class="literal"><span class="koboSpan" id="kobo.32.1">async</span></code><span class="koboSpan" id="kobo.33.1"> method to start an asynchronous computation that calls the </span><code class="literal"><span class="koboSpan" id="kobo.34.1">sleep</span></code><span class="koboSpan" id="kobo.35.1"> method. </span><span class="koboSpan" id="kobo.35.2">When the </span><code class="literal"><span class="koboSpan" id="kobo.36.1">sleep</span></code><span class="koboSpan" id="kobo.37.1"> call returns, the future is completed:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.38.1">def delay(n: Int): Future[Unit] = async { 
  blocking { Thread.sleep(n * 1000) } 
} 
</span></pre><p><span class="koboSpan" id="kobo.39.1">The </span><code class="literal"><span class="koboSpan" id="kobo.40.1">await</span></code><span class="koboSpan" id="kobo.41.1"> method must be statically enclosed within an </span><code class="literal"><span class="koboSpan" id="kobo.42.1">async</span></code><span class="koboSpan" id="kobo.43.1"> block in the same method; it is a compile-time error to invoke </span><code class="literal"><span class="koboSpan" id="kobo.44.1">await</span></code><span class="koboSpan" id="kobo.45.1"> outside of the </span><code class="literal"><span class="koboSpan" id="kobo.46.1">async</span></code><span class="koboSpan" id="kobo.47.1"> block. </span><span class="koboSpan" id="kobo.47.2">Whenever the execution inside the </span><code class="literal"><span class="koboSpan" id="kobo.48.1">async</span></code><span class="koboSpan" id="kobo.49.1"> block reaches an </span><code class="literal"><span class="koboSpan" id="kobo.50.1">await</span></code><span class="koboSpan" id="kobo.51.1"> statement, it stops until the value from the future in the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">await</span></code><span class="koboSpan" id="kobo.53.1"> statement becomes available. </span><span class="koboSpan" id="kobo.53.2">Consider the following example:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">async { 
  log("T-minus 1 second") 
  await { delay(1) } 
  log("done!") 
} 
</span></pre><p><span class="koboSpan" id="kobo.55.1">Here, the asynchronous computation in the </span><code class="literal"><span class="koboSpan" id="kobo.56.1">async</span></code><span class="koboSpan" id="kobo.57.1"> block prints </span><code class="literal"><span class="koboSpan" id="kobo.58.1">"T-minus 1 second"</span></code><span class="koboSpan" id="kobo.59.1">. </span><span class="koboSpan" id="kobo.59.2">It then calls </span><code class="literal"><span class="koboSpan" id="kobo.60.1">delay</span></code><span class="koboSpan" id="kobo.61.1"> to obtain a future that is completed after one second. </span><span class="koboSpan" id="kobo.61.2">The </span><code class="literal"><span class="koboSpan" id="kobo.62.1">await</span></code><span class="koboSpan" id="kobo.63.1"> call designates that the computation can proceed only after the future returned by </span><code class="literal"><span class="koboSpan" id="kobo.64.1">delay</span></code><span class="koboSpan" id="kobo.65.1"> completes. </span><span class="koboSpan" id="kobo.65.2">After that happens, the </span><code class="literal"><span class="koboSpan" id="kobo.66.1">async</span></code><span class="koboSpan" id="kobo.67.1"> block prints the text </span><code class="literal"><span class="koboSpan" id="kobo.68.1">done</span></code><span class="koboSpan" id="kobo.69.1">.</span></p><p><span class="koboSpan" id="kobo.70.1">The natural question is: How can the Scala Async library execute the preceding example without blocking? </span><span class="koboSpan" id="kobo.70.2">The answer is that the Scala Async library uses Scala Macros to transform the code inside the </span><code class="literal"><span class="koboSpan" id="kobo.71.1">async</span></code><span class="koboSpan" id="kobo.72.1"> statement. </span><span class="koboSpan" id="kobo.72.2">The code is transformed in such a way that the code after every </span><code class="literal"><span class="koboSpan" id="kobo.73.1">await</span></code><span class="koboSpan" id="kobo.74.1"> statement becomes a callback registered to the future inside </span><code class="literal"><span class="koboSpan" id="kobo.75.1">await</span></code><span class="koboSpan" id="kobo.76.1">. </span><span class="koboSpan" id="kobo.76.2">Immensely simplifying how this transformation works under the hood, the preceding code is equivalent to the following computation:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.77.1">Future { 
  log("T-minus 1 second") 
  delay(1) foreach { 
    case x =&gt; log("done!") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.78.1">As you can see, the equivalent code produced by the Scala Async library is completely non-blocking. </span><span class="koboSpan" id="kobo.78.2">The advantage of the </span><code class="literal"><span class="koboSpan" id="kobo.79.1">async</span></code><span class="koboSpan" id="kobo.80.1">/</span><code class="literal"><span class="koboSpan" id="kobo.81.1">await</span></code><span class="koboSpan" id="kobo.82.1"> style code is that it is much more understandable. </span><span class="koboSpan" id="kobo.82.2">For example, it allows defining a custom </span><code class="literal"><span class="koboSpan" id="kobo.83.1">countdown</span></code><span class="koboSpan" id="kobo.84.1"> method that takes a number of seconds and an </span><code class="literal"><span class="koboSpan" id="kobo.85.1">n</span></code><span class="koboSpan" id="kobo.86.1"> and a </span><code class="literal"><span class="koboSpan" id="kobo.87.1">f</span></code><span class="koboSpan" id="kobo.88.1"> function to execute every second. </span><span class="koboSpan" id="kobo.88.2">We use a </span><code class="literal"><span class="koboSpan" id="kobo.89.1">while</span></code><span class="koboSpan" id="kobo.90.1"> loop for the </span><code class="literal"><span class="koboSpan" id="kobo.91.1">countdown</span></code><span class="koboSpan" id="kobo.92.1"> method inside the </span><code class="literal"><span class="koboSpan" id="kobo.93.1">async</span></code><span class="koboSpan" id="kobo.94.1"> block: each time an </span><code class="literal"><span class="koboSpan" id="kobo.95.1">await</span></code><span class="koboSpan" id="kobo.96.1"> instance is invoked, the execution is postponed for one second. </span><span class="koboSpan" id="kobo.96.2">The implementation using the Scala Async library feels like regular procedural code, but it does not incur the cost of blocking:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.97.1">def countdown(n: Int)(f: Int =&gt; Unit): Future[Unit] = async { 
  var i = n 
  while (i &gt; 0) { 
    f(i) 
    await { delay(1) } 
    i -= 1 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.98.1">The </span><code class="literal"><span class="koboSpan" id="kobo.99.1">countdown</span></code><span class="koboSpan" id="kobo.100.1"> method can be used from the main thread to print to the standard output every second. </span><span class="koboSpan" id="kobo.100.2">Since the </span><code class="literal"><span class="koboSpan" id="kobo.101.1">countdown</span></code><span class="koboSpan" id="kobo.102.1"> method returns a future, we can additionally install a </span><code class="literal"><span class="koboSpan" id="kobo.103.1">foreach</span></code><span class="koboSpan" id="kobo.104.1"> callback to execute after the </span><code class="literal"><span class="koboSpan" id="kobo.105.1">countdown</span></code><span class="koboSpan" id="kobo.106.1"> method is over:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.107.1">countdown(10) { n =&gt; log(s"T-minus $n seconds") } foreach { 
  case _ =&gt; log(s"This program is over!") 
} 
</span></pre><p><span class="koboSpan" id="kobo.108.1">Having seen how expressive the Async library is in practice, the question is: When to use it in place of callbacks, future combinators, and for-comprehensions? </span><span class="koboSpan" id="kobo.108.2">In most cases, whenever you can express a chain of asynchronous computations inside a single method, you are free to use Async. </span><span class="koboSpan" id="kobo.108.3">You should use your best judgment when applying it; always choose the programming style that results in concise, more understandable, and more maintainable programs.</span></p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip50"/><span class="koboSpan" id="kobo.109.1">Tip</span></h3><p><span class="koboSpan" id="kobo.110.1">Use the Scala Async library when a chain of asynchronous computations can be expressed more intuitively as procedural code using the </span><code class="literal"><span class="koboSpan" id="kobo.111.1">async</span></code><span class="koboSpan" id="kobo.112.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.113.1">await</span></code><span class="koboSpan" id="kobo.114.1"> statements.</span></p></div></div></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Alternative future frameworks"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec30"/><span class="koboSpan" id="kobo.1.1">Alternative future frameworks</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">Scala futures and promises API resulted from an attempt to consolidate several different APIs for asynchronous programming, among them, legacy Scala futures, Akka futures, Scalaz futures, and Twitter's Finagle futures. </span><span class="koboSpan" id="kobo.2.2">Legacy Scala futures and Akka futures have already converged to the futures and promises APIs that you've learned about so far in this chapter. </span><span class="koboSpan" id="kobo.2.3">Finagle's </span><code class="literal"><span class="koboSpan" id="kobo.3.1">com.twitter.util.Future</span></code><span class="koboSpan" id="kobo.4.1"> type is planned to eventually implement the same interface as </span><code class="literal"><span class="koboSpan" id="kobo.5.1">scala.concurrent.Future</span></code><span class="koboSpan" id="kobo.6.1">, while the Scalaz </span><code class="literal"><span class="koboSpan" id="kobo.7.1">scalaz.concurrent.Future</span></code><span class="koboSpan" id="kobo.8.1"> type implements a slightly different interface. </span><span class="koboSpan" id="kobo.8.2">In this section, we give a brief description of Scalaz futures.</span></p><p><span class="koboSpan" id="kobo.9.1">To use Scalaz, we add the following dependency to the </span><code class="literal"><span class="koboSpan" id="kobo.10.1">build.sbt</span></code><span class="koboSpan" id="kobo.11.1"> file:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.12.1">libraryDependencies += 
  "org.scalaz" %% "scalaz-concurrent" % "7.0.6" 
</span></pre><p><span class="koboSpan" id="kobo.13.1">We now encode an asynchronous tombola program using Scalaz. </span><span class="koboSpan" id="kobo.13.2">The </span><code class="literal"><span class="koboSpan" id="kobo.14.1">Future</span></code><span class="koboSpan" id="kobo.15.1"> type in Scalaz does not have the </span><code class="literal"><span class="koboSpan" id="kobo.16.1">foreach</span></code><span class="koboSpan" id="kobo.17.1"> method. </span><span class="koboSpan" id="kobo.17.2">Instead, we use its </span><code class="literal"><span class="koboSpan" id="kobo.18.1">runAsync</span></code><span class="koboSpan" id="kobo.19.1"> method, which asynchronously runs the future computation to obtain its value, and then calls the specified callback:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.20.1">import scalaz.concurrent._ 
object Scalaz extends App { 
  val tombola = Future { 
    scala.util.Random.shuffle((0 until 10000).toVector) 
  } 
  tombola.runAsync { numbers =&gt; 
    log(s"And the winner is: ${numbers.head}") 
  } 
  tombola.runAsync { numbers =&gt; 
    log(s"... </span><span class="koboSpan" id="kobo.20.2">ahem, winner is: ${numbers.head}") 
  } 
} 
</span></pre><p><span class="koboSpan" id="kobo.21.1">Unless you are terribly lucky and draw the same permutation twice, running this program reveals that the two </span><code class="literal"><span class="koboSpan" id="kobo.22.1">runAsync</span></code><span class="koboSpan" id="kobo.23.1"> calls print different numbers. </span><span class="koboSpan" id="kobo.23.2">Each </span><code class="literal"><span class="koboSpan" id="kobo.24.1">runAsync</span></code><span class="koboSpan" id="kobo.25.1"> call separately computes the permutation of the random numbers. </span><span class="koboSpan" id="kobo.25.2">This is not surprising, as Scalaz futures have the pull semantics, in which the value is computed each time some callback requests it, in contrast to the push semantics of Finagle and Scala futures, in which the callback is stored, and applied if and when the asynchronously computed value becomes available.</span></p><p><span class="koboSpan" id="kobo.26.1">To achieve the same semantics as we would have with Scala futures, we need to use the </span><code class="literal"><span class="koboSpan" id="kobo.27.1">start</span></code><span class="koboSpan" id="kobo.28.1"> combinator that runs the asynchronous computation once, and caches its result:</span></p><pre class="programlisting"><span class="koboSpan" id="kobo.29.1">val tombola = Future { 
  scala.util.Random.shuffle((0 until 10000).toVector) 
} start 
</span></pre><p><span class="koboSpan" id="kobo.30.1">With this change, the two </span><code class="literal"><span class="koboSpan" id="kobo.31.1">runAsync</span></code><span class="koboSpan" id="kobo.32.1"> calls use the same permutation of random numbers </span><code class="literal"><span class="koboSpan" id="kobo.33.1">tombola</span></code><span class="koboSpan" id="kobo.34.1">, and print the same values.</span></p><p><span class="koboSpan" id="kobo.35.1">We will not delve further into the internals of alternate frameworks. </span><span class="koboSpan" id="kobo.35.2">The fundamentals of futures and promises that you learned about in this chapter should be sufficient to easily familiarize yourself with other asynchronous programming libraries, should the need arise.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec31"/><span class="koboSpan" id="kobo.1.1">Summary</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">This chapter presented some powerful abstractions for asynchronous programming. </span><span class="koboSpan" id="kobo.2.2">We have seen how to encode latency with the </span><code class="literal"><span class="koboSpan" id="kobo.3.1">Future</span></code><span class="koboSpan" id="kobo.4.1"> type, how to avoid blocking with callbacks on futures, and how to compose values from multiple futures. </span><span class="koboSpan" id="kobo.4.2">We have learned that futures and promises are closely tied together and that promises allow interfacing with legacy callback-based systems. </span><span class="koboSpan" id="kobo.4.3">In cases where blocking was unavoidable, we learned how to use the </span><code class="literal"><span class="koboSpan" id="kobo.5.1">Await</span></code><span class="koboSpan" id="kobo.6.1"> object and the </span><code class="literal"><span class="koboSpan" id="kobo.7.1">blocking</span></code><span class="koboSpan" id="kobo.8.1"> statement. </span><span class="koboSpan" id="kobo.8.2">Finally, we learned that the Scala Async library is a powerful alternative for expressing future computations more concisely.</span></p><p><span class="koboSpan" id="kobo.9.1">Futures and promises only allow dealing with a single value at a time. </span><span class="koboSpan" id="kobo.9.2">What if an asynchronous computation produces more than a single value before completing? </span><span class="koboSpan" id="kobo.9.3">Similarly, how do we efficiently execute thousands of asynchronous operations on different elements of large datasets? </span><span class="koboSpan" id="kobo.9.4">Should we use futures in such cases? </span><span class="koboSpan" id="kobo.9.5">In the next chapter, we will explore Scala's support for data-parallelism, a form of concurrency where similar asynchronous computations execute in parallel on different collection elements. </span><span class="koboSpan" id="kobo.9.6">We will see that using data-parallel collections is preferable to using futures when collections are large, as it results in a better performance.</span></p></div></div></div>
<div id="book-columns"><div id="book-inner"><div class="section" title="Exercises"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec32"/><span class="koboSpan" id="kobo.1.1">Exercises</span></h1></div></div></div><p><span class="koboSpan" id="kobo.2.1">The following exercises summarize what we have learned about futures and promises in this chapter, and require implementing custom future factory methods and combinators. </span><span class="koboSpan" id="kobo.2.2">Several exercises also deal with several deterministic programming abstractions that were not covered in this chapter, such as single-assignment variables and maps:</span></p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="koboSpan" id="kobo.3.1">Implement a command-line program that asks the user to input a URL of some website, and displays the HTML of that website. </span><span class="koboSpan" id="kobo.3.2">Between the time that the user hits </span><span class="strong"><strong><span class="koboSpan" id="kobo.4.1">ENTER</span></strong></span><span class="koboSpan" id="kobo.5.1"> and the time that the HTML is retrieved, the program should repetitively print a </span><code class="literal"><span class="koboSpan" id="kobo.6.1">.</span></code><span class="koboSpan" id="kobo.7.1"> to the standard output every 50 milliseconds, with a 2 second timeout. </span><span class="koboSpan" id="kobo.7.2">Use only futures and promises, and avoid synchronization primitives from the previous chapters. </span><span class="koboSpan" id="kobo.7.3">You may reuse the </span><code class="literal"><span class="koboSpan" id="kobo.8.1">timeout</span></code><span class="koboSpan" id="kobo.9.1"> method defined in this chapter.</span></li><li class="listitem"><span class="koboSpan" id="kobo.10.1">Implement an abstraction called a single-assignment variable, represented by the </span><code class="literal"><span class="koboSpan" id="kobo.11.1">IVar</span></code><span class="koboSpan" id="kobo.12.1"> class:</span><pre class="programlisting"><span class="koboSpan" id="kobo.13.1">            class IVar[T] { 
              def apply(): T = ??? 
              </span><span class="koboSpan" id="kobo.13.2">def :=(x: T): Unit = ??? 
            </span><span class="koboSpan" id="kobo.13.3">} 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.14.1">When created, the </span><code class="literal"><span class="koboSpan" id="kobo.15.1">IVar</span></code><span class="koboSpan" id="kobo.16.1"> class does not contain a value, and calling </span><code class="literal"><span class="koboSpan" id="kobo.17.1">apply</span></code><span class="koboSpan" id="kobo.18.1"> results in an exception. </span><span class="koboSpan" id="kobo.18.2">After a value is assigned using the </span><code class="literal"><span class="koboSpan" id="kobo.19.1">:=</span></code><span class="koboSpan" id="kobo.20.1"> method, subsequent calls to </span><code class="literal"><span class="koboSpan" id="kobo.21.1">:=</span></code><span class="koboSpan" id="kobo.22.1"> throw an exception, and the </span><code class="literal"><span class="koboSpan" id="kobo.23.1">apply</span></code><span class="koboSpan" id="kobo.24.1"> method returns the previously assigned value. </span><span class="koboSpan" id="kobo.24.2">Use only futures and promises, and avoid the synchronization primitives from the previous chapters.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.25.1">Extend the </span><code class="literal"><span class="koboSpan" id="kobo.26.1">Future[T]</span></code><span class="koboSpan" id="kobo.27.1"> type with the </span><code class="literal"><span class="koboSpan" id="kobo.28.1">exists</span></code><span class="koboSpan" id="kobo.29.1"> method, which takes a predicate and returns a </span><code class="literal"><span class="koboSpan" id="kobo.30.1">Future[Boolean]</span></code><span class="koboSpan" id="kobo.31.1"> object:</span><pre class="programlisting"><span class="koboSpan" id="kobo.32.1">            def exists(p: T =&gt; Boolean): Future[Boolean] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.33.1">The resulting future is completed with </span><code class="literal"><span class="koboSpan" id="kobo.34.1">true</span></code><span class="koboSpan" id="kobo.35.1"> if and only if the original future is completed and the predicate returns </span><code class="literal"><span class="koboSpan" id="kobo.36.1">true</span></code><span class="koboSpan" id="kobo.37.1">, and </span><code class="literal"><span class="koboSpan" id="kobo.38.1">false</span></code><span class="koboSpan" id="kobo.39.1"> otherwise. </span><span class="koboSpan" id="kobo.39.2">You can use future combinators, but you are not allowed to create any </span><code class="literal"><span class="koboSpan" id="kobo.40.1">Promise</span></code><span class="koboSpan" id="kobo.41.1"> objects in the implementation.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.42.1">Repeat the previous exercise, but use </span><code class="literal"><span class="koboSpan" id="kobo.43.1">Promise</span></code><span class="koboSpan" id="kobo.44.1"> objects instead of future combinators.</span></li><li class="listitem"><span class="koboSpan" id="kobo.45.1">Repeat the previous exercise, but use the Scala Async framework.</span></li><li class="listitem"><span class="koboSpan" id="kobo.46.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.47.1">spawn</span></code><span class="koboSpan" id="kobo.48.1"> method, which takes a command-line string, asynchronously executes it as a child process, and returns a future with the exit code of the child process:</span><pre class="programlisting"><span class="koboSpan" id="kobo.49.1">            def spawn(command: String): Future[Int] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.50.1">Make sure that your implementation does not cause thread starvation.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.51.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.52.1">IMap</span></code><span class="koboSpan" id="kobo.53.1"> class, which represents a single-assignment map:</span><pre class="programlisting"><span class="koboSpan" id="kobo.54.1">            class IMap[K, V] { 
              def update(k: K, v: V): Unit 
              def apply(k: K): Future[V] 
            } 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.55.1">Pairs of keys and values can be added to the </span><code class="literal"><span class="koboSpan" id="kobo.56.1">IMap</span></code><span class="koboSpan" id="kobo.57.1"> object, but they can never be removed or modified. </span><span class="koboSpan" id="kobo.57.2">A specific key can be assigned only once, and subsequent calls to </span><code class="literal"><span class="koboSpan" id="kobo.58.1">update</span></code><span class="koboSpan" id="kobo.59.1"> with that key result in an exception. </span><span class="koboSpan" id="kobo.59.2">Calling </span><code class="literal"><span class="koboSpan" id="kobo.60.1">apply</span></code><span class="koboSpan" id="kobo.61.1"> with a specific key returns a future, which is completed after that key is inserted into the map. </span><span class="koboSpan" id="kobo.61.2">In addition to futures and promises, you may use the </span><code class="literal"><span class="koboSpan" id="kobo.62.1">scala.collection.concurrent.Map</span></code><span class="koboSpan" id="kobo.63.1"> class.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.64.1">Extend the type </span><code class="literal"><span class="koboSpan" id="kobo.65.1">Promise[T]</span></code><span class="koboSpan" id="kobo.66.1">  with the </span><code class="literal"><span class="koboSpan" id="kobo.67.1">compose</span></code><span class="koboSpan" id="kobo.68.1"> method, which takes a function of the type </span><code class="literal"><span class="koboSpan" id="kobo.69.1">S =&gt; T</span></code><span class="koboSpan" id="kobo.70.1"> , and returns a </span><code class="literal"><span class="koboSpan" id="kobo.71.1">Promise[S]</span></code><span class="koboSpan" id="kobo.72.1"> object:</span><pre class="programlisting"><span class="koboSpan" id="kobo.73.1">            def compose[S](f: S =&gt; T): Promise[S] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.74.1">Whenever the resulting promise is completed with some value </span><code class="literal"><span class="koboSpan" id="kobo.75.1">x</span></code><span class="koboSpan" id="kobo.76.1"> of the type </span><code class="literal"><span class="koboSpan" id="kobo.77.1">S</span></code><span class="koboSpan" id="kobo.78.1"> (or failed), the original promise must be completed with the value </span><code class="literal"><span class="koboSpan" id="kobo.79.1">f(x)</span></code><span class="koboSpan" id="kobo.80.1"> asynchronously (or failed), unless the original promise is already completed.</span></p></li><li class="listitem"><span class="koboSpan" id="kobo.81.1">Implement the </span><code class="literal"><span class="koboSpan" id="kobo.82.1">scatterGather</span></code><span class="koboSpan" id="kobo.83.1"> method, which given a sequence of tasks, runs those tasks as parallel asynchronous computations, then combines the results, and returns a future that contains the sequence of results from different tasks. </span><span class="koboSpan" id="kobo.83.2">The </span><code class="literal"><span class="koboSpan" id="kobo.84.1">scatterGather</span></code><span class="koboSpan" id="kobo.85.1"> method has the following interface:</span><pre class="programlisting"><span class="koboSpan" id="kobo.86.1">            def scatterGather[T](tasks: Seq[() =&gt; T]): Future[Seq[T]] 
</span></pre></li><li class="listitem"><span class="koboSpan" id="kobo.87.1">Implement another version of the </span><code class="literal"><span class="koboSpan" id="kobo.88.1">timeout</span></code><span class="koboSpan" id="kobo.89.1"> method shown in this chapter, but without using the </span><code class="literal"><span class="koboSpan" id="kobo.90.1">blocking</span></code><span class="koboSpan" id="kobo.91.1"> construct or </span><code class="literal"><span class="koboSpan" id="kobo.92.1">Thread.sleep</span></code><span class="koboSpan" id="kobo.93.1">. </span><span class="koboSpan" id="kobo.93.2">Instead use the </span><code class="literal"><span class="koboSpan" id="kobo.94.1">java.util.Timer</span></code><span class="koboSpan" id="kobo.95.1"> class from the JDK. </span><span class="koboSpan" id="kobo.95.2">What are the advantages of this new implementation?</span></li><li class="listitem"><span class="koboSpan" id="kobo.96.1">A directed graph is a data structure composed from a finite set of nodes, where each node has a finite number of directed edges that connect it with other nodes in the graph. </span><span class="koboSpan" id="kobo.96.2">A directed acyclic graph, or shorter, DAG, is a directed graph data structure in which, starting from any node N and following any path along the directed edges, we cannot arrive back at N. </span><span class="koboSpan" id="kobo.96.3">In other words, directed edges of a DAG never form a cycle.</span><p><span class="koboSpan" id="kobo.97.1">One way to represent the nodes of the DAG data structure is as follows:</span></p><p>
</p><pre class="programlisting"><span class="koboSpan" id="kobo.98.1">            class DAG[T](val value: T) { 
              val edges = scala.collection.mutable.Set[DAG[T]] 
            } 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.99.1">Here is an example of a DAG declaration:</span></p><p>
</p><pre class="programlisting"><span class="koboSpan" id="kobo.100.1">            val a = new DAG("a") 
            val b = new DAG("b") 
            val c = new DAG("c") 
            val d = new DAG("d") 
            val e = new DAG("e") 
            a.edges += b 
            b.edges += c 
            b.edges += d 
            c.edges += e 
            d.edges += e 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.101.1">The preceding DAG declaration is shown graphically in the following figure:</span></p><p>
</p><div class="mediaobject"><span class="koboSpan" id="kobo.102.1"><img src="graphics/image_04_006.jpg" alt="Exercises"/></span></div><p>
</p><p><span class="koboSpan" id="kobo.103.1">DAGs are often used to declare dependencies between different items, for example, build tasks in a project build tool or an IDE. </span><span class="koboSpan" id="kobo.103.2">Your task is to implement the </span><code class="literal"><span class="koboSpan" id="kobo.104.1">fold</span></code><span class="koboSpan" id="kobo.105.1"> method that takes a DAG node and a function that maps each item and its inputs into some value, and then returns the future with the resulting value of the input node:</span></p><p>
</p><pre class="programlisting"><span class="koboSpan" id="kobo.106.1">            def fold[T, S](g: DAG[T], f: (T, Seq[S]) =&gt; S): Future[S] 
</span></pre><p>
</p><p><span class="koboSpan" id="kobo.107.1">The </span><code class="literal"><span class="koboSpan" id="kobo.108.1">fold</span></code><span class="koboSpan" id="kobo.109.1"> method runs an asynchronous task for each item in the DAG to map the item and its inputs to a new value. </span><span class="koboSpan" id="kobo.109.2">Dependencies between DAG items must be respected: an item can only run after all of its dependencies have been computed. </span><span class="koboSpan" id="kobo.109.3">For example, in the previous figure, task </span><code class="literal"><span class="koboSpan" id="kobo.110.1">b</span></code><span class="koboSpan" id="kobo.111.1"> can only run after both </span><code class="literal"><span class="koboSpan" id="kobo.112.1">c</span></code><span class="koboSpan" id="kobo.113.1"> and </span><code class="literal"><span class="koboSpan" id="kobo.114.1">d</span></code><span class="koboSpan" id="kobo.115.1"> have produced a result.</span></p></li></ol></div></div></div></div></body></html>