<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;4.&#xA0;Progressive Mockito"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04" class="calibre1"/>Chapter 4. Progressive Mockito</h1></div></div></div><p class="calibre9">This chapter distills the Mockito framework to its main core and provides technical examples. No previous knowledge of mocking is necessary.</p><p class="calibre9">The following topics are covered in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Overview of Mockito</li><li class="listitem">Exploring Mockito APIs</li><li class="listitem">Advanced Mockito examples</li><li class="listitem">Behavior-driven development (BDD) with Mockito</li></ul></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Progressive Mockito">
<div class="book" title="Working with Mockito"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch04lvl1sec22" class="calibre1"/>Working with Mockito</h1></div></div></div><p class="calibre9">Mockito is an open<a id="id327" class="calibre1"/> source mock unit testing framework for Java. In the previous chapter, we read about test doubles and mock objects. Mockito allows mock object creation, verification, and stubbing.</p><p class="calibre9">To find out more about Mockito, visit <a id="id328" class="calibre1"/>the following link:</p><p class="calibre9">
<a class="calibre1" href="http://code.google.com/p/mockito/">http://code.google.com/p/mockito/</a>
</p></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Progressive Mockito">
<div class="book" title="Working with Mockito">
<div class="book" title="Why should you use Mockito?"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec28" class="calibre1"/>Why should you use Mockito?</h2></div></div></div><p class="calibre9">Automated tests are safety nets. They run and notify the user if the system is broken so that the offending code can be fixed very quickly.</p><p class="calibre9">If a test suite runs for an hour, the purpose of quick feedback is compromised. Unit tests should act as a safety net and provide quick feedback; this is the main principle of TDD.</p><p class="calibre9">I worked with an environment<a id="id329" class="calibre1"/> where when a piece of code is checked-in, the automated tests would run and would take hours to complete. So, a developer had to wait for an hour to check-in the new code unless the previous build/test run was complete. A developer can check-in the code in the middle of a build, but the best practice is to monitor the status before signing off; otherwise, the new code can break the next build and cause problem for the other developers. So, the developer has to wait for an additional hour to monitor the next build. This kind of slow build environment blocks the progress of development.</p><p class="calibre9">A test may take time to execute<a id="id330" class="calibre1"/> due to the following reasons:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Sometimes a test acquires a connection from the database that fetches/updates data</li><li class="listitem">It connects to the Internet and downloads files</li><li class="listitem">It interacts with an SMTP server to send e-mails</li><li class="listitem">It performs I/O operations</li></ul></div><p class="calibre9">Now the question is do we really need to acquire a database connection or download files to unit test code?</p><p class="calibre9">The answer is yes. If it doesn't connect to a database or download the latest stock price, few parts of the system remain untested. So, DB interaction or network connection is mandatory for a few parts of the system, and these are integration tests. To unit test these parts, the external dependencies need to be mocked out.</p><p class="calibre9">Mockito plays a key role in mocking out external dependencies. It mocks out the database connection or any external I/O behavior so that the actual logic can be unit tested.</p><p class="calibre9">Unit tests should adhere to a number of principles for flexibility and maintainability. The next section will elucidate the principles that we will follow throughout this journey.</p></div></div></div>

<div class="book" title="Chapter&#xA0;4.&#xA0;Progressive Mockito">
<div class="book" title="Working with Mockito">
<div class="book" title="Qualities of unit testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec29" class="calibre1"/>Qualities of unit testing</h2></div></div></div><p class="calibre9">Unit tests should adhere to<a id="id331" class="calibre1"/> the following principles:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre10">Order independent and isolated</strong></span>: The <code class="literal">ATest.java</code> test class<a id="id332" class="calibre1"/> should not be dependent on the output of the <code class="literal">BTest.java</code> test class, or a <code class="literal">when_an_user_is_deleted_the_associated_id_gets_deleted()</code> test should not depend on the execution of another <code class="literal">when_a_new_user_is_created_an_id_is_returned()</code> test. The tests shouldn't fail if <code class="literal">BTest.java</code> is executed after <code class="literal">ATest.java</code>, or the <code class="literal">when_a_new_user_is_created_an_id_is_returned()</code>test is executed after <code class="literal">when_an_user_is_deleted_the_associated_id_gets_deleted()</code>.</li><li class="listitem"><span class="strong"><strong class="calibre10">Trouble-free setup and run</strong></span>: Unit tests should<a id="id333" class="calibre1"/> not require a DB connection or an Internet connection or a clean-up temp directory.</li><li class="listitem"><span class="strong"><strong class="calibre10">Effortless execution</strong></span>: Unit tests should run fine on<a id="id334" class="calibre1"/> all computers, not just on a specific computer.</li><li class="listitem"><span class="strong"><strong class="calibre10">Formula 1 execution</strong></span>: A test should not take<a id="id335" class="calibre1"/> more than a second to finish the execution.</li></ul></div><p class="calibre9">Mockito provides APIs to mock out the external dependencies and achieve the qualities mentioned here.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Drinking Mockito"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec23" class="calibre1"/>Drinking Mockito</h1></div></div></div><p class="calibre9">Download the latest Mockito binary from the following link and add it to the project dependency:</p><p class="calibre9">
<a class="calibre1" href="http://code.google.com/p/mockito/downloads/list">http://code.google.com/p/mockito/downloads/list</a></p><p class="calibre9">As of February 2014, the latest Mockito version is 1.9.5.</p></div>

<div class="book" title="Drinking Mockito">
<div class="book" title="Configuring Mockito"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch04lvl2sec30" class="calibre1"/>Configuring Mockito</h2></div></div></div><p class="calibre9">To add Mockito JAR files to<a id="id336" class="calibre1"/> the project dependency, perform the following steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Extract the JAR files into a folder.</li><li class="listitem" value="2">Launch Eclipse.</li><li class="listitem" value="3">Create an Eclipse project named <code class="literal">Chapter04</code>.</li><li class="listitem" value="4">Go to the <span class="strong"><strong class="calibre10">Libraries</strong></span> tab in the project build path.</li><li class="listitem" value="5">Click on the <span class="strong"><strong class="calibre10">Add External JARs...</strong></span> button and browse to the <span class="strong"><strong class="calibre10">Mockito JAR</strong></span> folder.</li><li class="listitem" value="6">Select all JAR files and click on <span class="strong"><strong class="calibre10">OK</strong></span>.</li></ol><div class="calibre17"/></div><p class="calibre9">We worked with Gradle and Maven and built a project with the JUnit dependency. In this section, we will add Mockito dependencies to our existing projects.</p><p class="calibre9">The following code snippet will add a Mockito dependency to a Maven project and download the JAR file from the central Maven repository (<a class="calibre1" href="http://mvnrepository.com/artifact/org.mockito/mockito-core">http://mvnrepository.com/artifact/org.mockito/mockito-core</a>):</p><div class="informalexample"><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;org.mockito&lt;/groupId&gt;
  &lt;artifactId&gt;mockito-core&lt;/artifactId&gt;
  &lt;version&gt;1.9.5&lt;/version&gt;
  &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p class="calibre9">The following Gradle script snippet will add a Mockito dependency to a Gradle project:</p><div class="informalexample"><pre class="programlisting">  testCompile 'org.mockito:mockito-core:1.9.5'</pre></div></div></div>

<div class="book" title="Drinking Mockito">
<div class="book" title="Mocking in action"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch04lvl2sec31" class="calibre1"/>Mocking in action</h2></div></div></div><p class="calibre9">This section demonstrates the mock objects with a stock quote example. In the real world, people invest money on the stock market—they buy and sell stocks. A stock symbol is an abbreviation used to uniquely identify shares of a particular stock on a particular market, such as stocks of Facebook are registered on NASDAQ as FB and stocks of Apple as AAPL.</p><p class="calibre9">We will build a stock broker<a id="id337" class="calibre1"/> simulation program. The program will watch the market statistics, and depending on the current market data, you can perform any of the following actions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Buy stocks</li><li class="listitem">Sell stocks</li><li class="listitem">Hold stocks</li></ul></div><p class="calibre9">The domain classes that will be used in the program are <code class="literal">Stock</code>, <code class="literal">MarketWatcher</code>, <code class="literal">Portfolio</code>, and <code class="literal">StockBroker</code>.</p><p class="calibre9">
<code class="literal">Stock</code> represents a real-world stock. It has a symbol, company name, and price.</p><p class="calibre9">
<code class="literal">MarketWatcher</code> looks up the stock market and returns the quote for the stock. A real implementation of a market watcher can be implemented from <a class="calibre1" href="http://www.wikijava.org/wiki/Downloading_stock_market_quotes_from_Yahoo!_finance">http://www.wikijava.org/wiki/Downloading_stock_market_quotes_from_Yahoo!_finance</a>. Note that the real implementation will connect to the Internet and download the stock quote from a provider.</p><p class="calibre9">
<code class="literal">Portfolio</code> represents a user's stock data such as the number of stocks and price details. <code class="literal">Portfolio</code> exposes APIs for getting the average stock price and buying and selling stocks. Suppose on day one someone buys a share at a price of $10.00, and on day two, the customer buys the same share at a price of $8.00. So, on day two the person has two shares and the average price of the share is $9.00.</p><p class="calibre9">The following screenshot represents the Eclipse project structure. You can download the project from the Packt Publishing website and work with the files:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Mocking in action" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">The following code snippet<a id="id338" class="calibre1"/> represents the <code class="literal">StockBroker</code> class. <code class="literal">StockBroker</code> collaborates with the <code class="literal">MarketWatcher</code> and <code class="literal">Portfolio</code> classes. The <code class="literal">perform()</code> method of <code class="literal">StockBroker</code> accepts a <code class="literal">portfolio</code> and a <code class="literal">Stock</code> object:</p><div class="informalexample"><pre class="programlisting">public class StockBroker {
  private final static BigDecimal LIMIT = new BigDecimal("0.10");

  private final MarketWatcher market;

  public StockBroker(MarketWatcher market) {
    this.market = market;
  }
  
  public void perform(Portfolio portfolio,Stock stock) {
    Stock liveStock = market.getQuote(stock.getSymbol());
    BigDecimal avgPrice = portfolio.getAvgPrice(stock);
    BigDecimal priceGained = liveStock.getPrice().subtract(avgPrice);
    BigDecimal percentGain = priceGained.divide(avgPrice);
    if(percentGain.compareTo(LIMIT) &gt; 0) {
      portfolio.sell(stock, 10);
    }else if(percentGain.compareTo(LIMIT) &lt; 0){
      portfolio.buy(stock);
    }
  }
}</pre></div><p class="calibre9">Look at the <code class="literal">perform</code> method. It takes a <code class="literal">portfolio</code> object and a <code class="literal">stock</code> object, calls the <code class="literal">getQuote</code> method of <code class="literal">MarketWatcher</code>, and passes a <code class="literal">stock</code> symbol. Then, it gets the average stock price from <code class="literal">portfolio</code> and compares the current market price with the average stock price. If the current stock price is 10 percent greater than the average price, then the <code class="literal">StockBroker</code> program sells 10 stocks from <code class="literal">Portfolio</code>; however, if the current stock price goes down by 10 percent, then the program buys shares from the market to average out the loss.</p><p class="calibre9">Why do we sell 10 stocks? This is just<a id="id339" class="calibre1"/> an example and 10 is just a number; this could be anything you want.</p><p class="calibre9">
<code class="literal">StockBroker</code> depends on <code class="literal">Portfolio</code> and <code class="literal">MarketWatcher</code>; a real implementation of <code class="literal">Portfolio</code> should interact with a database, and <code class="literal">MarketWatcher</code> needs to connect to the Internet. So, if we write a unit test for the broker, we need to execute the test with a database and an Internet connection. A database connection will take time and Internet connectivity depends on the Internet provider. So, the test execution will depend on external entities and will take a while to finish. This will violate the quick test execution principle. Also, the database state might not be the same across all test runs. This is also applicable for the Internet connection service. Each time the database might return different values, and therefore asserting a specific value in your unit test is very difficult.</p><p class="calibre9">We'll use Mockito to mock the external dependencies and execute the test in isolation. So, the test will no longer be dependent on real external service, and therefore it will be executed quickly.</p><div class="book" title="Mocking objects"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec31" class="calibre1"/>Mocking objects</h3></div></div></div><p class="calibre9">A mock can be created <a id="id340" class="calibre1"/>with the help of a static <code class="literal">mock()</code> method as<a id="id341" class="calibre1"/> follows:</p><div class="informalexample"><pre class="programlisting">import org.mockito.Mockito;

public class StockBrokerTest {
  MarketWatcher marketWatcher = Mockito.mock(MarketWatcher.class);
  Portfolio portfolio = Mockito.mock(Portfolio.class);

}</pre></div><p class="calibre9">Otherwise, you can use Java's static import feature and static import the <code class="literal">mock</code> method of the <code class="literal">org.mockito.Mockito</code> class as follows:</p><div class="informalexample"><pre class="programlisting">import static org.mockito.Mockito.mock;

public class StockBrokerTest {
  MarketWatcher marketWatcher = mock(MarketWatcher.class);
  Portfolio portfolio = mock(Portfolio.class);
}</pre></div><p class="calibre9">There's another alternative; you can<a id="id342" class="calibre1"/> use the <code class="literal">@Mock</code> annotation<a id="id343" class="calibre1"/> as follows:</p><div class="informalexample"><pre class="programlisting">import org.mockito.Mock;

public class StockBrokerTest {
  @Mock 
  MarketWatcher marketWatcher;
  @Mock 
  Portfolio portfolio;
}</pre></div><p class="calibre9">However, to work with the <code class="literal">@Mock</code> annotation, you are required to call <code class="literal">MockitoAnnotations.initMocks( this )</code> before using the mocks, or use <code class="literal">MockitoJUnitRunner</code> as a JUnit runner.</p><p class="calibre9">The following code snippet uses <code class="literal">MockitoAnnotations</code> to create <code class="literal">mocks</code>:</p><div class="informalexample"><pre class="programlisting">import static org.junit.Assert.assertEquals;
import org.mockito.MockitoAnnotations;

public class StockBrokerTest {

  @Mock 
  MarketWatcher marketWatcher;

  @Mock 
  Portfolio portfolio;
  
  @Before 
  public void setUp() {
    MockitoAnnotations.initMocks(this);
  }
  

  @Test 
  public void sanity() throws Exception {
    assertNotNull(marketWatcher);
    assertNotNull(portfolio);
  }
}</pre></div><p class="calibre9">The following code snippet uses the <code class="literal">MockitoJUnitRunner</code> JUnit runner:</p><div class="informalexample"><pre class="programlisting">import org.mockito.runners.MockitoJUnitRunner;

@RunWith(MockitoJUnitRunner.class)
public class StockBrokerTest {

  @Mock
    MarketWatcher marketWatcher;
  @Mock 
    Portfolio portfolio;
  
  @Test 
    public void sanity() throws Exception {
      assertNotNull(marketWatcher);
      assertNotNull(portfolio);
  }
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre9">Before we deep dive into the Mockito world, there are a few things to remember. Mockito cannot mock or spy the following functions: final classes, final methods, enums, static methods, private methods, the <code class="literal">hashCode()</code> and <code class="literal">equals()</code> methods, anonymous classes, and primitive types.</p><p class="calibre9">PowerMock<a id="id344" class="calibre1"/> (an extension of EasyMock) and <a id="id345" class="calibre1"/>PowerMockito (an extension of the Mockito framework) allows you to mock static and private methods; even PowerMockito allows<a id="id346" class="calibre1"/> you to set expectations on new invocations for private member classes, inner classes, and local or anonymous classes. However, as per the design, you should not opt for mocking private/static properties—it violates the encapsulation. Instead, you should refactor the offending code to make it testable. <a class="calibre1" title="Chapter 9. Solving Test Puzzles" href="part0052_split_000.html#page">Chapter 9</a>, <span class="strong"><em class="calibre11">Solving Test Puzzles</em></span>, explains the design for the testability concept.</p></div><p class="calibre9">Change the <code class="literal">Portfolio</code> class, create the <code class="literal">final</code> class, and rerun the test; the test will fail as the <code class="literal">Portfolio</code> class is final, and Mockito cannot mock a <code class="literal">final</code> class.</p><p class="calibre9">The following screenshot shows the JUnit output:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Mocking objects" class="calibre12"/></div><p class="calibre13"> </p></div><div class="book" title="Stubbing methods"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec32" class="calibre1"/>Stubbing methods</h3></div></div></div><p class="calibre9">We read about stubs in <a class="calibre1" title="Chapter 3. Test Doubles" href="part0021_split_000.html#page">Chapter 3</a>, <span class="strong"><em class="calibre11">Test Doubles</em></span>. The stubbing process defines the behavior of a mock method such as the value to be returned or the exception to be thrown when the method is invoked.</p><p class="calibre9">The Mockito framework supports<a id="id347" class="calibre1"/> stubbing and allows us to return a given value when a specific method is called. This can be done using <code class="literal">Mockito.when()</code> along with <code class="literal">thenReturn ()</code>.</p><p class="calibre9">The following is the syntax of importing <code class="literal">when</code>:</p><div class="informalexample"><pre class="programlisting">import static org.mockito.Mockito.when;</pre></div><p class="calibre9">The following code snippet stubs the <code class="literal">getQuote(String symbol)</code> method of <code class="literal">MarcketWatcher</code> and returns a specific <code class="literal">Stock</code> object:</p><div class="informalexample"><pre class="programlisting">import static org.mockito.Matchers.anyString;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class StockBrokerTest {

  @Mock MarketWatcher marketWatcher;
  @Mock Portfolio portfolio;

  @Test
  public void marketWatcher_Returns_current_stock_status() {
    Stock uvsityCorp = new Stock("UV", "Uvsity Corporation", new BigDecimal("100.00"));
    
<span class="strong"><strong class="calibre10">    when</strong></span>(marketWatcher.getQuote(<span class="strong"><strong class="calibre10">anyString</strong></span>())).
<span class="strong"><strong class="calibre10">      thenReturn</strong></span>(uvsityCorp);

    assertNotNull(marketWatcher.getQuote("UV"));
  }
}</pre></div><p class="calibre9">A <code class="literal">uvsityCorp</code> stock object is created with a stock price of $100.00 and the <code class="literal">getQuote</code> method is stubbed to return <code class="literal">uvsityCorp</code> whenever the <code class="literal">getQuote</code> method is called. Note that <code class="literal">anyString()</code> is passed to the <code class="literal">getQuote</code> method, which means whenever the <code class="literal">getQuote</code> method will be called with<a id="id348" class="calibre1"/> any <code class="literal">String</code> value, the <code class="literal">uvsityCorp</code> object will be returned.</p><p class="calibre9">The <code class="literal">when()</code> method represents the trigger, that is, when to stub.</p><p class="calibre9">The following methods are used to represent what to do when the trigger is triggered:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">thenReturn(</code>x<code class="literal">)</code>: This returns<a id="id349" class="calibre1"/> the <code class="literal">x</code> value.</li><li class="listitem"><code class="literal">thenThrow(x)</code>: This throws an<a id="id350" class="calibre1"/> <code class="literal">x</code> exception.</li><li class="listitem"><code class="literal">thenAnswer(Answer answer)</code>: Unlike returning<a id="id351" class="calibre1"/> a hardcoded value, a dynamic user-defined logic is executed. It's more like for fake test doubles, <code class="literal">Answer</code> is an interface.</li><li class="listitem"><code class="literal">thenCallRealMethod()</code>: This method calls<a id="id352" class="calibre1"/> the real method on the mock object.</li></ul></div><p class="calibre9">The following code snippet stubs the external dependencies and creates a test for the <code class="literal">StockBroker</code> class:</p><div class="informalexample"><pre class="programlisting">import com.packt.trading.dto.Stock;
import static org.junit.Assert.assertNotNull;
import static org.mockito.Matchers.anyString;
import static org.mockito.Matchers.isA;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

@RunWith(MockitoJUnitRunner.class)
public class StockBrokerTest {
  @Mock   MarketWatcher marketWatcher;
  @Mock   Portfolio portfolio;
  StockBroker broker;

  @Before public void setUp() {
    broker = new StockBroker(marketWatcher);
  }

  @Test
  public void when_ten_percent_gain_then_the_stock_is_sold() {
    //Portfolio's getAvgPrice is stubbed to return $10.00
    when(portfolio.getAvgPrice(isA(Stock.class))).
      thenReturn(new BigDecimal("10.00"));
    //A stock object is created with current price $11.20
    Stock aCorp = new Stock("A", "A Corp", new BigDecimal("11.20"));
    //getQuote method is stubbed to return the stock
    when(marketWatcher.getQuote(anyString())).thenReturn(aCorp);
    //perform method is called, as the stock price increases 
    // by 12% the broker should sell the stocks
    broker.perform(portfolio, aCorp);

  //verifying that the broker sold the stocks
  verify(portfolio).sell(aCorp,10);
 }  
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre9">The test method name is <code class="literal">when_ten_percent_gain_then_the_stock_is_sold</code>; a test name should explain the intention of the test. We use <a id="id353" class="calibre1"/>underscores to make the test name readable. We will use the <code class="literal">when_&lt;&lt;</code>something happens<code class="literal">&gt;&gt;_then_&lt;&lt;</code>the action is taken<code class="literal">&gt;&gt;</code> convention for the tests.</p></div><p class="calibre9">In the preceding test example, the <code class="literal">getAvgPrice()</code> method of <code class="literal">portfolio</code> is stubbed to return $10.00, then the <code class="literal">getQuote</code> method is stubbed to return a hardcoded <code class="literal">stock</code> object with a current stock price of $11.20. The <code class="literal">broker</code> logic should sell the stock as the stock price goes up by 12 percent.</p><p class="calibre9">The <code class="literal">portfolio</code> object is a mock <a id="id354" class="calibre1"/>object. So, unless we stub a method, by default, all the methods of portfolio are autostubbed to return a default value, and for the <code class="literal">void</code> methods, no action is performed. The <code class="literal">sell</code> method is a <code class="literal">void</code> method; so, instead of connecting to a database to update the stock count, the autostub will do nothing.</p><p class="calibre9">However, how will we test whether the <code class="literal">sell</code> method was invoked? We use <code class="literal">Mockito.verify</code>.</p><p class="calibre9">The <code class="literal">verify()</code> method<a id="id355" class="calibre1"/> is a static method, which is used to verify the method invocation. If the method is not invoked, or the argument doesn't match, then the verify method will raise an error to indicate that the code logic has issues.</p></div><div class="book" title="Verifying the method invocation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec33" class="calibre1"/>Verifying the method invocation</h3></div></div></div><p class="calibre9">To verify a redundant method invocation, or to verify whether a stubbed method was not called but was important<a id="id356" class="calibre1"/> from the test perspective, we should manually verify the invocation; for this, we need to use the static <code class="literal">verify</code> method.</p><div class="book" title="Why do we use verify?"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec09" class="calibre1"/>Why do we use verify?</h4></div></div></div><p class="calibre9">Mock objects are used to stub external<a id="id357" class="calibre1"/> dependencies. We set an expectation, and a mock object returns an expected value. In some conditions, a behavior or method of a mock object should not be invoked, or sometimes, we may need to call the method N (a number) times. The <code class="literal">verify</code> method verifies the invocation of mock objects.</p><p class="calibre9">Mockito does not automatically verify all stubbed calls.</p><p class="calibre9">If a stubbed behavior should not be called but the method is called due to a bug in the code, <code class="literal">verify</code> flags the error though we have to verify that manually. The <code class="literal">void</code> methods don't return values, so you cannot assert the returned values. Hence, <code class="literal">verify</code> is very handy to test the <code class="literal">void</code> methods.</p></div><div class="book" title="Verifying in depth"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec10" class="calibre1"/>Verifying in depth</h4></div></div></div><p class="calibre9">The <code class="literal">verify()</code> method has<a id="id358" class="calibre1"/> an overloaded version that takes <code class="literal">Times</code> as an argument. <code class="literal">Times</code> is a Mockito framework class of the <code class="literal">org.mockito.internal.verification</code> package, and it takes <code class="literal">wantedNumberOfInvocations</code> as an integer argument.</p><p class="calibre9">If <code class="literal">0</code> is passed to <code class="literal">Times</code>, it infers that the<a id="id359" class="calibre1"/> method will not be invoked in the testing path. We can pass <code class="literal">0</code> to <code class="literal">Times(0)</code> to make sure that the <code class="literal">sell</code> or <code class="literal">buy</code> methods are not invoked. If a negative number is passed to the <code class="literal">Times</code> constructor, Mockito throws <code class="literal">MockitoException - org.mockito.exceptions.base.MockitoException</code>, and this shows the <span class="strong"><strong class="calibre10">Negative value is not allowed here</strong></span> error.</p><p class="calibre9">The following methods are used in <a id="id360" class="calibre1"/>conjunction with <code class="literal">verify</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">times(int wantedNumberOfInvocations)</code>: This method<a id="id361" class="calibre1"/> is invoked exactly <span class="strong"><em class="calibre11">n</em></span> times; if the method is not invoked <code class="literal">wantedNumberOfInvocations</code> times, then the test fails.</li><li class="listitem"><code class="literal">never()</code>: This method signifies that the stubbed method is never called or you can use <code class="literal">times(0)</code> to represent<a id="id362" class="calibre1"/> the same scenario. If the stubbed method is invoked at least once, then the test fails.</li><li class="listitem"><code class="literal">atLeastOnce()</code>: This method is invoked <a id="id363" class="calibre1"/>at least once, and it works fine if it is invoked multiple times. However, the operation fails if the method is not invoked.</li><li class="listitem"><code class="literal">atLeast(int minNumberOfInvocations)</code>: This method<a id="id364" class="calibre1"/> is called at least <span class="strong"><em class="calibre11">n</em></span> times, and it works fine if the method is invoked more than the <code class="literal">minNumberOfInvocations</code> times. However, the operation fails if the method is not called <code class="literal">minNumberOfInvocations</code> times.</li><li class="listitem"><code class="literal">atMost(int maxNumberOfInvocations)</code>: This method is called at the most <code class="literal">n</code> times. However, the <a id="id365" class="calibre1"/>operation fails if the <a id="id366" class="calibre1"/>method is called more than <code class="literal">minNumberOfInvocations</code> times.</li><li class="listitem"><code class="literal">only()</code>: The <code class="literal">only</code> method called on<a id="id367" class="calibre1"/> a mock fails if any other method is called on the mock object. In our example, if we use <code class="literal">verify(portfolio, only()).sell(aCorp,10);</code>, the test will fail with the following output:<div class="mediaobject"><img src="../images/00052.jpeg" alt="Verifying in depth" class="calibre12"/></div><p class="calibre16"> </p><p class="calibre15">The test fails in line 15 as <code class="literal">portfolio.getAvgPrice(stock)</code> is called.</p></li><li class="listitem"><code class="literal">timeout(int millis)</code>: This method is interacted in a specified time range.</li></ul></div></div><div class="book" title="Verifying zero and no more interactions"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec11" class="calibre1"/>Verifying zero and no more interactions</h4></div></div></div><p class="calibre9">The <code class="literal">verifyZeroInteractions(Object... mocks)</code> method verifies <a id="id368" class="calibre1"/>whether no interactions happened on the given<a id="id369" class="calibre1"/> mocks.</p><p class="calibre9">The following test code directly calls <code class="literal">verifyZeroInteractions</code> and passes the two mock objects. Since no methods are invoked on the mock objects, the test passes:</p><div class="informalexample"><pre class="programlisting">  @Test  public void verify_zero_interaction() {
    verifyZeroInteractions(marketWatcher,portfolio);
  }</pre></div><p class="calibre9">The <code class="literal">verifyNoMoreInteractions(Object... mocks)</code> method checks whether any of the given mocks has any<a id="id370" class="calibre1"/> unverified interaction. We can use this method after verifying a mock method to make sure that <a id="id371" class="calibre1"/>nothing else was invoked on the mock.</p><p class="calibre9">The following test code demonstrates <code class="literal">verifyNoMoreInteractions</code>:</p><div class="informalexample"><pre class="programlisting">  @Test  public void verify_no_more_interaction() {
    Stock noStock = null;
    portfolio.getAvgPrice(noStock);
    portfolio.sell(null, 0);
    verify(portfolio).getAvgPrice(eq(noStock));
    //this will fail as the sell method was invoked
    verifyNoMoreInteractions(portfolio);
  }</pre></div><p class="calibre9">The following is the JUnit output:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="Verifying zero and no more interactions" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">The following are the rationales and examples of argument matchers.</p></div></div><div class="book" title="Using argument matcher"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec34" class="calibre1"/>Using argument matcher</h3></div></div></div><p class="calibre9">
<code class="literal">ArgumentMatcher</code> is a Hamcrest matcher with a predefined <code class="literal">describeTo()</code> method. <code class="literal">ArgumentMatcher</code> extends the <code class="literal">org.hamcrest.BaseMatcher</code> package. It verifies the indirect inputs into a mocked dependency.</p><p class="calibre9">The <code class="literal">Matchers.argThat(Matcher)</code> method is <a id="id372" class="calibre1"/>used in conjunction with the <code class="literal">verify</code> method to verify whether a method is invoked with a specific argument value.</p><p class="calibre9">
<code class="literal">ArgumentMatcher</code> plays a key role in mocking. The following section describes the context of <code class="literal">ArgumentMatcher</code>.</p><p class="calibre9">Mock objects return expected values, but when they need to return different values for different arguments, argument <a id="id373" class="calibre1"/>matcher comes into play. Suppose we have a method that takes a player name as input and returns the total number of runs (a run is a point scored in a cricket match) scored as output. We want to stub it and return <code class="literal">100</code> for <code class="literal">Sachin</code> and <code class="literal">10</code> for <code class="literal">xyz</code>. We have to use argument matcher to stub this.</p><p class="calibre9">Mockito returns expected values when a method is stubbed. If the method takes arguments, the argument must match during the execution; for example, the <code class="literal">getValue(int someValue)</code> method is stubbed in the following way:</p><div class="informalexample"><pre class="programlisting">when(mockObject.getValue(1)).thenReturn(expected value);</pre></div><p class="calibre9">Here, the <code class="literal">getValue</code> method is called with <code class="literal">mockObject.getValue(100)</code>. Then, the parameter doesn't match (it is expected that the method will be called with 1, but at runtime, it encounters 100), so the mock object fails to return the expected value. It will return the default value of the return type—if the return type is Boolean, it'll return false; if the return type is object, then null, and so on.</p><p class="calibre9">Mockito verifies argument values in natural Java style by using an <code class="literal">equals()</code> method. Sometimes, we use argument matchers when extra flexibility is required.</p><p class="calibre9">Mockito provides built-in matchers such as <code class="literal">anyInt()</code>, <code class="literal">anyDouble()</code>, <code class="literal">anyString()</code>, <code class="literal">anyList()</code>, and <code class="literal">anyCollection()</code>.</p><p class="calibre9">More built-in matchers and examples of custom argument matchers or Hamcrest matchers can be found at the following link:</p><p class="calibre9">
<a class="calibre1" href="http://docs.mockito.googlecode.com/hg/latest/org/mockito/Matchers.html">http://docs.mockito.googlecode.com/hg/latest/org/mockito/Matchers.html</a>
</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre9">Examples of other matchers are <code class="literal">isA(java.lang.Class&lt;T&gt; clazz)</code>, <code class="literal">any(java.lang.Class&lt;T&gt; clazz)</code>, and <code class="literal">eq(T) or eq(primitive value)</code>.</p></div><p class="calibre9">The <code class="literal">isA</code> argument checks whether the passed object is an instance of the class type passed in the <code class="literal">isA</code> argument. The <code class="literal">any(T)</code> argument also works in the same way.</p><div class="book" title="Why do we need wildcard matchers?"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec12" class="calibre1"/>Why do we need wildcard matchers?</h4></div></div></div><p class="calibre9">Wildcard <a id="id374" class="calibre1"/>matchers are used to verify the indirect inputs to the mocked dependencies. The following example describes the context.</p><p class="calibre9">In the following code <a id="id375" class="calibre1"/>snippet, an object is passed to a method and then a <code class="literal">request</code> object is created and passed to <code class="literal">service</code>. Now, from a test, if we call the <code class="literal">someMethod</code> method and <code class="literal">service</code> is a mocked object, then from test, we cannot stub <code class="literal">callMethod</code> with a specific <code class="literal">request</code> as the <code class="literal">request</code> object is local to the <code class="literal">someMethod</code>:</p><div class="informalexample"><pre class="programlisting">public void someMethod(Object obj){
  Request req = new Request();
  req.setValue(obj);
  Response resp = service.callMethod(req);
}</pre></div><div class="informalexample" title="Note"><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre9">If we are using argument matchers, all arguments have to be provided by matchers.</p><p class="calibre9">We're passing three arguments and all of them are passed using matchers:</p><div class="informalexample"><pre class="programlisting">verify(mock).someMethod(anyInt(), anyString(), eq("third argument"));</pre></div><p class="calibre9">The following example will fail because the first and the third arguments are not passed using matcher:</p><div class="informalexample"><pre class="programlisting">verify(mock).someMethod(1, anyString(), "third argument");</pre></div></div></div><div class="book" title="The ArgumentMatcher class"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch04lvl4sec13" class="calibre1"/>The ArgumentMatcher class</h4></div></div></div><p class="calibre9">The <code class="literal">ArgumentMatcher</code> class allows<a id="id376" class="calibre1"/> the creation of customized<a id="id377" class="calibre1"/> argument matchers. <code class="literal">ArgumentMatcher</code> is a Hamcrest matcher with the predefined <code class="literal">describeTo()</code> method.</p><p class="calibre9">Use the <code class="literal">Matchers.argThat(org.hamcrest.Matcher)</code> method and pass an instance of the Hamcrest matcher.</p><p class="calibre9">Consider the <code class="literal">MarketWatcher</code> class; it takes a stock symbol and then gets the quote from the market.</p><p class="calibre9">We will create a mock for the <code class="literal">MarketWatcher.getQuote</code> method that takes a <code class="literal">String</code> object. We wish to make this method conditional. If a blue chip stock symbol is passed to the method, then the method will return $1000.00; otherwise, it will return $5.00.</p><p class="calibre9">How will we identify a blue chip share? A <a id="id378" class="calibre1"/>blue chip share is a common stock of a well-known company whose value<a id="id379" class="calibre1"/> and dividends are reliable and usually safe for investment. For example, if the stock symbol is FB or AAPL, we will consider the stock as a blue chip stock.</p><p class="calibre9">Let us create a custom matcher to identify blue chip stocks. The following code shows a custom argument matcher:</p><div class="informalexample"><pre class="programlisting">  class BlueChipStockMatcher extends ArgumentMatcher&lt;String&gt;{
    @Override
    public boolean matches(Object symbol) {
       return "FB".equals(symbol) ||  
         "AAPL".equals(symbol);
    }
  }</pre></div><p class="calibre9">The following class extends <code class="literal">BlueChipStockMatcher</code> and then negates the result to indicate that the stock is not a blue chip stock:</p><div class="informalexample"><pre class="programlisting">  class OtherStockMatcher extends BlueChipStockMatcher{
    @Override
    public boolean matches(Object symbol) {
      return !super.matches(symbol);
    }
  }</pre></div><p class="calibre9">The following test uses the custom matchers to sell the shares:</p><div class="informalexample"><pre class="programlisting">@Test
public void argument_matcher() {
    when(portfolio.getAvgPrice(isA(Stock.class))).
      thenReturn(new BigDecimal("10.00"));

    Stock blueChipStock = new Stock("FB", "FB Corp", new BigDecimal(1000.00));
    Stock otherStock = new Stock("XY", "XY Corp", new BigDecimal(5.00));

    when(marketWatcher.getQuote(argThat(new <span class="strong"><strong class="calibre10">      BlueChipStockMatcher</strong></span>()))).thenReturn(<span class="strong"><strong class="calibre10">blueChipStock</strong></span>);
    when(marketWatcher.getQuote(argThat(new <span class="strong"><strong class="calibre10">      OtherStockMatcher</strong></span>()))).thenReturn(<span class="strong"><strong class="calibre10">otherStock</strong></span>);

    broker.perform(portfolio, blueChipStock);
    verify(portfolio).sell(blueChipStock,10);

    broker.perform(portfolio, otherStock);
    verify(portfolio, <span class="strong"><strong class="calibre10">never()</strong></span>).sell(otherStock,10);
  }</pre></div><p class="calibre9">In the preceding code, <code class="literal">marketWatcher</code> is stubbed to return a blue chip share when the stock symbol is <code class="literal">FB</code> or <code class="literal">AAPL</code>; otherwise, it returns<a id="id380" class="calibre1"/> a normal stock.</p></div></div><div class="book" title="Throwing exceptions"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec35" class="calibre1"/>Throwing exceptions</h3></div></div></div><p class="calibre9">Unit tests are not meant for only happy path testing. We should test our code for the failure conditions too. Mockito provides an API to raise an error during testing. Suppose we are testing a flow where we compute a value and then print it to a printer. If the printer is not configured, or a network error happens, or a page is not loaded, the system throws an exception. We can test this using Mockito's exception APIs.</p><p class="calibre9">How do we test exceptional <a id="id381" class="calibre1"/>conditions such as database access failure?</p><p class="calibre9">Mockito provides a method called <code class="literal">thenThrow(Throwable)</code>; this method throws an exception when the stubbed method is invoked.</p><p class="calibre9">We will stub the <code class="literal">getAvgPrice</code> method to throw an exception when the method is called, as follows:</p><div class="informalexample"><pre class="programlisting">  @Test(expected = IllegalStateException.class)
  public void throwsException() throws Exception {
    when(portfolio.getAvgPrice(isA(Stock.class))).thenThrow(new IllegalStateException("Database down"));

    portfolio.getAvgPrice(new Stock(null, null, null));
  }</pre></div><p class="calibre9">We are stubbing <code class="literal">portfolio</code> to throw an exception when <code class="literal">getAvgPrice()</code> is invoked. The following is the syntax to throw an exception from a method that returns <code class="literal">void</code>:</p><div class="informalexample"><pre class="programlisting">doThrow(exception).when(mock).voidmethod(arguments);</pre></div><p class="calibre9">The <code class="literal">buy</code> method in <code class="literal">Portfolio</code> is a <code class="literal">void</code> method; we will stub the <code class="literal">buy</code> method to throw an exception. The following test code throws <code class="literal">IllegalStateException</code> when the <code class="literal">buy</code> method is invoked on the <code class="literal">portfolio</code> object. Note that <code class="literal">doThrow().when()</code> will be used to raise the error from the <code class="literal">buy</code> method:</p><div class="informalexample"><pre class="programlisting">  @Test(expected = IllegalStateException.class)
  public void throwsException_void_methods() throws Exception {
    <span class="strong"><strong class="calibre10">doThrow</strong></span>(new IllegalStateException()).
      when(portfolio).buy(isA(Stock.class));
    portfolio.buy(new Stock(null, null, null));
  }</pre></div></div><div class="book" title="Stubbing consecutive calls"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec36" class="calibre1"/>Stubbing consecutive calls</h3></div></div></div><p class="calibre9">Stubbing a method for consecutive calls is required in the following situations:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Calling a stubbed method in a<a id="id382" class="calibre1"/> loop when you need different results for different calls</li><li class="listitem">When you need one invocation to throw an exception and other invocations to return a value</li></ul></div><p class="calibre9">We need to test a condition where the<a id="id383" class="calibre1"/> first call will return a value, the next call should not find any value, and then again it should return a value.</p><p class="calibre9">The varargs version of <code class="literal">thenReturn(objects...)</code> takes comma-separated return values and returns the arguments in order such that if we pass two arguments to the <code class="literal">thenReturn</code> method, then the first call to the stubbed method will return the first argument. Thereafter, all other calls will return the second argument, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">   @Test
  public void consecutive_calls() throws Exception {
    Stock stock = new Stock(null, null, null);
    when(portfolio.getAvgPrice(stock)).thenReturn(BigDecimal.TEN, BigDecimal.ZERO);
    assertEquals(BigDecimal.TEN, portfolio.getAvgPrice(stock));
    assertEquals(BigDecimal.ZERO, portfolio.getAvgPrice(stock));
    assertEquals(BigDecimal.ZERO, portfolio.getAvgPrice(stock));
  }</pre></div><p class="calibre9">Note that <code class="literal">thenReturn</code> takes two values: <code class="literal">BigDecimal.TEN</code> and <code class="literal">BigDecimal.ZERO</code>. The first call to <code class="literal">getAvgPrice</code> will return <code class="literal">BigDecimal.TEN</code>, and then each call will return <code class="literal">BigDecimal.ZERO</code>.</p><p class="calibre9">This can be done in another way—Mockito methods return stub objects and follow a builder pattern to allow a chain of calls.</p><p class="calibre9">In the following example, <code class="literal">thenReturn</code> and <code class="literal">thenThrow</code> are combined to build a chain of response. After the second call, each <code class="literal">getAvgPrice</code> invocation will throw an exception:</p><div class="informalexample"><pre class="programlisting">when(portfolio.getAvgPrice(stock)).thenReturn(BigDecimal.TEN).thenReturn(BigDecimal.TEN).thenThrow(new IllegalStateException())</pre></div></div><div class="book" title="Stubbing with an Answer"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec37" class="calibre1"/>Stubbing with an Answer</h3></div></div></div><p class="calibre9">Stubbed methods return a hardcoded value but cannot return an on the fly result. The Mockito framework provides the<a id="id384" class="calibre1"/> callbacks to compute the on the fly results.</p><p class="calibre9">Mockito allows stubbing with the generic <code class="literal">Answer</code> interface. This is a callback; when a stubbed method on a mock object is invoked, the <code class="literal">answer(InvocationOnMock invocation)</code> method of the <code class="literal">Answer</code> object is called. This <code class="literal">Answer</code> object's <code class="literal">answer()</code> method returns the actual object.</p><p class="calibre9">The syntax of <code class="literal">Answer</code> is <code class="literal">when(mock.someMethod()).thenAnswer(new Answer() {…});</code> or <code class="literal">when(mock.someMethod()).then(answer);</code>, which is similar to  <code class="literal">thenReturn()</code> and <code class="literal">thenThrow()</code>.</p><p class="calibre9">The <code class="literal">Answer</code> interface is defined as follows:</p><div class="informalexample"><pre class="programlisting">public interface Answer&lt;T&gt; {
   T answer(InvocationOnMock invocation) throws Throwable;
}</pre></div><p class="calibre9">The <code class="literal">InvocationOnMock</code> argument is an important part of callback. It can return the arguments passed to the method and also return the mock object as follows:</p><div class="informalexample"><pre class="programlisting">Object[] args = invocation.getArguments();
Object mock = invocation.getMock();</pre></div><p class="calibre9">Add a new method to the <code class="literal">Portfolio</code> class to return the total stock value. We are using a mock <code class="literal">Portfolio</code> instance, so we cannot return the total stock value. We can fix this using <code class="literal">Answer</code> and make the test totally configurable.</p><p class="calibre9">When a new stock is bought, we will store the stock in <code class="literal">HashMap,</code> and when the <code class="literal">getCurrentValue</code> method will be invoked, we will compute the value dynamically from <code class="literal">HashMap</code>. So, we need two <code class="literal">Answer</code> objects, one to store stocks and the other to compute the total.</p><p class="calibre9">The following code snippet creates two <code class="literal">Answer</code> classes. Add <code class="literal">HashMap</code> to the test class:</p><div class="informalexample"><pre class="programlisting">Map&lt;String, List&lt;Stock&gt;&gt; stockMap = new HashMap&lt;String, List&lt;Stock&gt;&gt;();</pre></div><p class="calibre9">One can buy 10 stocks of Facebook or 10 different stocks. The <code class="literal">stockMap</code> object stores a key-value pair. The key is the <code class="literal">Stock</code> symbol and the value is a list of stocks. 10 Facebook stocks will add a single key, <code class="literal">FB,</code> and a list of 10 Facebook stocks. An Apple stock will add another entry to the map with an <code class="literal">AAPL</code> key and value and a list with a single Apple stock.</p><p class="calibre9">The following <code class="literal">Answer</code> implementation is called when the <code class="literal">buy</code> method is invoked. The <code class="literal">invocationOnMock</code> object<a id="id385" class="calibre1"/>  returns the arguments, and the <code class="literal">buy</code> method accepts only one argument, that is, a <code class="literal">Stock</code> object. So, type casted the 0<sup class="calibre18">th</sup> argument to <code class="literal">Stock</code>. Then, insert <code class="literal">Stock</code> to the <code class="literal">stockMap</code> object:</p><div class="informalexample"><pre class="programlisting">class BuyAnswer implements Answer&lt;Object&gt;{
  @Override
  public Object answer(InvocationOnMock invocation) throws Throwable 
   {
    Stock newStock = (Stock)invocation.getArguments()[0];
    List&lt;Stock&gt; stocks = stockMap.get(newStock.getSymbol());
    if(stocks != null) {
      stocks.add(newStock);
    }else {
      stocks = new ArrayList&lt;Stock&gt;();
      stocks.add(newStock);
      stockMap.put(newStock.getSymbol(), stocks);
    }
    return null;
  }
}</pre></div><p class="calibre9">The following <code class="literal">answer</code> object implements the total price computation logic:</p><div class="informalexample"><pre class="programlisting">class TotalPriceAnswer implements Answer&lt;BigDecimal&gt;{
  @Override  
  public BigDecimal answer(InvocationOnMock invocation) throws Throwable  {
    BigDecimal totalPrice = BigDecimal.ZERO;

    for(String stockId: stockMap.keySet()) {
      for(Stock stock:stockMap.get(stockId)) {
        totalPrice = totalPrice.add(stock.getPrice());
      }
    }
    return totalPrice;
  }
}</pre></div><p class="calibre9">The <code class="literal">getCurrentValue()</code> method will be stubbed to return the preceding answer implementation.</p><p class="calibre9">The following JUnit test code uses the <code class="literal">TotalPriceAnswer</code> method:</p><div class="informalexample"><pre class="programlisting">@Test
  public void answering() throws Exception {
    stockMap.clear();
    doAnswer(new BuyAnswer()).when(portfolio).
      buy(isA(Stock.class));

    when(portfolio.getCurrentValue()).
    then(new TotalPriceAnswer());
    
    portfolio.buy(new Stock("A", "A", BigDecimal.TEN));
    portfolio.buy(new Stock("B", "B", BigDecimal.ONE));
    
    assertEquals(new BigDecimal("11"), portfolio.getCurrentValue());
  }</pre></div><p class="calibre9">Check that the <code class="literal">stockMap</code> object is cleared to remove existing data. Then, the <code class="literal">void</code> <code class="literal">buy</code> method is stubbed to add<a id="id386" class="calibre1"/> stocks to <code class="literal">stockMap</code> using the <code class="literal">doAnswer</code> method, and then the <code class="literal">getCurrentValue</code> method is stubbed to the <code class="literal">TotalPriceAnswer</code> answer.</p></div><div class="book" title="Spying objects"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec38" class="calibre1"/>Spying objects</h3></div></div></div><p class="calibre9">A Mockito <code class="literal">spy</code> object allows us to use real objects instead of mocks by replacing some of the methods with the <a id="id387" class="calibre1"/>stubbed ones. This behavior allows us to test the legacy code; one cannot mock a class that needs to be tested. Legacy <a id="id388" class="calibre1"/>code comes with methods that cannot be tested, but other methods use them; so, these methods need to be stubbed to work with the other methods. A <code class="literal">spy</code> object can stub the nontestable methods so that other methods can be tested easily.</p><p class="calibre9">Once an expectation is set for a method on a <code class="literal">spy</code> object, then <code class="literal">spy</code> no longer returns the original value. It starts returning the stubbed value, but still it exhibits the original behavior for the other methods that are not stubbed.</p><p class="calibre9">Mockito can create a <code class="literal">spy</code> of a real object. Unlike stubbing, when we use <code class="literal">spy</code>, the real methods are called (unless a method was stubbed).</p><p class="calibre9">
<code class="literal">Spy</code> is also known as <a id="id389" class="calibre1"/>partial mock; one example of the use of <code class="literal">spy</code> in the real world is dealing with legacy code.</p><p class="calibre9">Declaration of <code class="literal">spy</code> is done using the following code:</p><div class="informalexample"><pre class="programlisting">SomeClass realObject = new RealImplemenation();
SomeClass spyObject = spy(realObject);</pre></div><p class="calibre9">The following is a self-explanatory example of <code class="literal">spy</code>:</p><div class="informalexample"><pre class="programlisting">@Test public void spying() throws Exception {
    Stock realStock = new Stock("A", "Company A", BigDecimal.ONE);
    Stock spyStock = spy(realStock);
    //call real method from  spy
    assertEquals("A", spyStock.getSymbol());
    
    //Changing value using spy
    spyStock.updatePrice(BigDecimal.ZERO);
    
    //verify spy has the changed value
    assertEquals(BigDecimal.ZERO, spyStock.getPrice());
    
    //Stubbing method
    when(spyStock.getPrice()).thenReturn(BigDecimal.TEN);
   
    //Changing value using spy
    spyStock.updatePrice(new BigDecimal("7"));
    
    //Stubbed method value 10.00  is returned NOT 7
    assertNotEquals(new BigDecimal("7"), spyStock.getPrice());
    //Stubbed method value 10.00
    assertEquals(BigDecimal.TEN,  spyStock.getPrice());

}</pre></div></div><div class="book" title="Stubbing void methods"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec39" class="calibre1"/>Stubbing void methods</h3></div></div></div><p class="calibre9">In the <span class="strong"><em class="calibre11">Throwing exceptions</em></span> section of this chapter, we learned that <code class="literal">doThrow</code> is used for throwing exceptions for the <code class="literal">void</code> methods. The <span class="strong"><em class="calibre11">Stubbing with an Answer</em></span> section of this chapter showed you how to use <code class="literal">doAnswer</code> for the void methods.</p><p class="calibre9">In this section, we will explore the other <code class="literal">void</code> methods: <code class="literal">doNothing</code>, <code class="literal">doReturn</code>, <code class="literal">doThrow</code>, and <code class="literal">doCallRealMethod</code>.</p><p class="calibre9">The <code class="literal">doNothing()</code> API does nothing. <a id="id390" class="calibre1"/>By default, all the <code class="literal">void</code> methods do nothing. However, if you need consecutive calls on a <code class="literal">void</code> method, the first call is to throw an error, the next call is to do nothing, and then the next call to perform some logic using <code class="literal">doAnswer()</code> and then follow this syntax:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre10">  doThrow</strong></span>(new RuntimeException()).
<span class="strong"><strong class="calibre10">  doNothing</strong></span>().
<span class="strong"><strong class="calibre10">  doAnswer</strong></span>(someAnswer).
<span class="strong"><strong class="calibre10">  when</strong></span>(mock).someVoidMethod();

  //this call throws exception
  mock.someVoidMethod(); 
  // this call does nothing 
  mock.someVoidMethod();</pre></div><p class="calibre9">The <code class="literal">doCallRealMethod()</code> API is<a id="id391" class="calibre1"/> used when you want to call the real implementation of a method on a mock or a <code class="literal">spy</code> object as follows:</p><div class="informalexample"><pre class="programlisting">doCallRealMethod().when(mock).someVoidMethod();</pre></div><p class="calibre9">The <code class="literal">doReturn()</code> method is similar<a id="id392" class="calibre1"/> to stubbing a method and returning an expected value. However, this is used only when <code class="literal">when(mock).thenReturn(return)</code> cannot be used.</p><p class="calibre9">The <code class="literal">when-thenReturn</code> method is <a id="id393" class="calibre1"/>more readable than <code class="literal">doReturn()</code>; also, <code class="literal">doReturn()</code> is not a safe type. The <a id="id394" class="calibre1"/>
<code class="literal">thenReturn</code> method checks the method return types and raises a compilation error if an unsafe type is passed.</p><p class="calibre9">Here is the syntax for using the <code class="literal">doReturn()</code> test:</p><div class="informalexample"><pre class="programlisting">doReturn(value).when(mock).method(argument);</pre></div><p class="calibre9">The following code snippet provides an example of unsafe usage of <code class="literal">doReturn</code>:</p><div class="informalexample"><pre class="programlisting">@Test public void doReturn_is_not_type_safe() throws Exception {
  //then return is type safe- It has to return a BigDecimal
  when(portfolio.getCurrentValue()).thenReturn(BigDecimal.ONE);
   //method call works fine
  portfolio.getCurrentValue();

    //returning a String instead of BigDecimal
  doReturn("See returning a String").
    when(portfolio.getCurrentValue());
    //this call will fail with an error
  portfolio.getCurrentValue();
}</pre></div><p class="calibre9">The following screenshot shows how the test fails:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Stubbing void methods" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">Spying real objects and calling real methods on a spy has side effects; to counter this side effect, use <code class="literal">doReturn()</code> instead of <code class="literal">thenReturn()</code>.</p><p class="calibre9">The following code describes<a id="id395" class="calibre1"/> the side effect of spying and calling <code class="literal">thenReturn()</code>:</p><div class="informalexample"><pre class="programlisting">@Test
  public void doReturn_usage() throws Exception {
    List&lt;String&gt; list = new ArrayList&lt;String&gt;();
    List&lt;String&gt; spy = spy(list);
    //impossible the real list.get(0) is called and fails
    //with IndexOutofBoundsException, as the list is empty
    when(spy.get(0)).thenReturn("not reachable");
  }</pre></div><p class="calibre9">In the preceding code, the spy object calls a real method while trying to stub <code class="literal">get(index)</code>, and unlike the mock objects, the real method was called and it failed with an <code class="literal">ArrayIndexOutOfBounds</code> error.</p><p class="calibre9">The following screenshot displays the failure message:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Stubbing void methods" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">This can be protected using<a id="id396" class="calibre1"/> <code class="literal">doReturn()</code> as shown in the following code, but note that typically we don't mock lists or domain objects; this is just an example:</p><div class="informalexample"><pre class="programlisting">@Test public void doReturn_usage() throws Exception {
  List&lt;String&gt; list = new ArrayList&lt;String&gt;();
  List&lt;String&gt; spy = spy(list);
  
  //doReturn fixed the issue
  doReturn("now reachable").when(spy).get(0);
  assertEquals("now reachable", spy.get(0));
}</pre></div></div><div class="book" title="Capturing arguments with ArgumentCaptor"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec40" class="calibre1"/>Capturing arguments with ArgumentCaptor</h3></div></div></div><p class="calibre9">
<code class="literal">ArgumentCaptor</code> is used to verify the arguments passed to a stubbed method. Sometimes, we compute a<a id="id397" class="calibre1"/> value, then create another object using the computed value, and then call a mock object using that new object. This computed value is not returned from the original method, but it is used for some other computation.</p><p class="calibre9">
<code class="literal">ArgumentCaptor</code> provides an API to access objects that are instantiated within the method under the test.</p><p class="calibre9">The following code snippet explains the problem behind the inaccessibility of the method arguments:</p><div class="informalexample"><pre class="programlisting">public void buildPerson(String firstName, String lastName, String middleName, int age){
  Person person = new Person();
  person.setFirstName(firstName);
  person.setMiddleName(middleName);
  person.setLastName(lastName);
  person.setAge(age);
<span class="strong"><strong class="calibre10">  this,personService.save(person);</strong></span>
}</pre></div><p class="calibre9">We are passing a first name, middle name, last name, and an age to the <code class="literal">buildPerson</code> method. This method creates a <code class="literal">Person</code> object and sets the name and age to it. Finally, it invokes the <code class="literal">personService</code> class and saves the <code class="literal">person</code> object to a database.</p><p class="calibre9">Here, we cannot stub the <code class="literal">save</code> behavior of <code class="literal">personService</code> from a JUnit test with a specific value since the <code class="literal">Person</code> object is created inside the method. We can mock <code class="literal">save</code> using a generic matcher object such as <code class="literal">isA(Person.class)</code> and then verify whether the <code class="literal">Person</code> object contains the<a id="id398" class="calibre1"/> correct name and age using the argument captor.</p><p class="calibre9">Mockito verifies argument values in natural Java style by using an <code class="literal">equals()</code> method. This is also the recommended way of matching arguments because it makes tests clean and simple. In some situations though, it is necessary to assert on certain arguments after the actual verification.</p><p class="calibre9">The following code uses two <code class="literal">ArgumentCaptors</code> and verifies whether it uses a specific stock symbol, <code class="literal">A,</code> and not any other value while calling the method:</p><div class="informalexample"><pre class="programlisting">@Test
public void argument_captor() throws Exception {
  when(portfolio.getAvgPrice(isA(Stock.class))).thenReturn(new BigDecimal("10.00"));
  Stock aCorp = new Stock("A", "A Corp", new BigDecimal(11.20));
  when(marketWatcher.getQuote(anyString())).thenReturn(aCorp);
  broker.perform(portfolio, aCorp);
  
  ArgumentCaptor&lt;String&gt; stockIdCaptor = ArgumentCaptor.forClass(String.class);
  
  verify(marketWatcher).getQuote(stockIdCaptor.capture());
  assertEquals("A", stockIdCaptor.getValue());
  
  //Two arguments captured
  ArgumentCaptor&lt;Stock&gt;  stockCaptor = ArgumentCaptor.forClass(Stock.class);   ArgumentCaptor&lt;Integer&gt; stockSellCountCaptor = ArgumentCaptor.forClass(Integer.class);

  verify(portfolio).sell(stockCaptor.capture(), stockSellCountCaptor.capture());
  assertEquals("A", stockCaptor.getValue().getSymbol());
  assertEquals(10, stockSellCountCaptor.getValue().intValue());
}</pre></div><p class="calibre9">Check that <code class="literal">ArgumentCaptor</code> takes a <code class="literal">Class</code> type in the <code class="literal">forClass</code> method and then the captor is passed to the <code class="literal">verify</code> method to collect the argument details. The <code class="literal">sell</code> method takes two arguments, <code class="literal">Stock</code> and <code class="literal">Integer</code>. So, two <code class="literal">ArgumentCaptors</code> are created. The <code class="literal">stockCaptor</code> object captures the <code class="literal">Stock</code> argument and <code class="literal">stockSellCountCaptor</code> captures the stock <a id="id399" class="calibre1"/>quantity. Finally, the values are compared to verify whether the correct values were passed to the <code class="literal">sell</code> method.</p></div><div class="book" title="Verifying the invocation order"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec41" class="calibre1"/>Verifying the invocation order</h3></div></div></div><p class="calibre9">Mockito facilitates verifying if interactions with a mock were performed in a given order using the <code class="literal">InOrder</code> API. It allows <a id="id400" class="calibre1"/>us to create <code class="literal">InOrder</code> of mocks and verify the call order of all calls of all mocks.</p><p class="calibre9">The following test sequentially invokes the <code class="literal">getAvgPrice</code>, <code class="literal">getCurrentValue</code>, <code class="literal">getQuote</code>, and <code class="literal">buy</code> methods, but verifies whether the <code class="literal">buy()</code> method is invoked before the <code class="literal">getAvgPrice()</code> method. So, the verification order is wrong and hence the test fails:</p><div class="informalexample"><pre class="programlisting">@Test public void inorder() throws Exception {
  Stock aCorp = new Stock("A", "A Corp", new BigDecimal(11.20));
  portfolio.getAvgPrice(aCorp);
  portfolio.getCurrentValue();
  marketWatcher.getQuote("X");
  portfolio.buy(aCorp);
  InOrder inOrder=inOrder(portfolio,marketWatcher);
  inOrder.verify(portfolio).buy(isA(Stock.class));
  inOrder.verify(portfolio).getAvgPrice(isA(Stock.class));
}</pre></div><p class="calibre9">The following screenshot shows the error message output:</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Verifying the invocation order" class="calibre12"/></div><p class="calibre13"> </p><p class="calibre9">Reordering the verification <a id="id401" class="calibre1"/>sequence, we fixed the test as follows:</p><div class="informalexample"><pre class="programlisting">@Test public void inorder() throws Exception {
  Stock aCorp = new Stock("A", "A Corp", new BigDecimal(11.20));
  portfolio.getAvgPrice(aCorp);
  portfolio.getCurrentValue();
  marketWatcher.getQuote("X");
  portfolio.buy(aCorp);
  
  InOrder inOrder=inOrder(portfolio,marketWatcher);
  inOrder.verify(portfolio).getAvgPrice(isA(Stock.class));
  inOrder.verify(portfolio).getCurrentValue();
  inOrder.verify(marketWatcher).getQuote(anyString());
  inOrder.verify(portfolio).buy(isA(Stock.class));
}</pre></div></div><div class="book" title="Changing the default settings"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec42" class="calibre1"/>Changing the default settings</h3></div></div></div><p class="calibre9">We learned that nonstubbed methods of a mock object return default values such as null for an object and false for<a id="id402" class="calibre1"/> a Boolean. However, Mockito allows us to change the default settings.</p><p class="calibre9">The following are the allowed settings:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre10">RETURNS_DEFAULTS</strong></span>: This is the default <a id="id403" class="calibre1"/>setting. It returns null<a id="id404" class="calibre1"/> for object, false for Boolean, and so on.</li><li class="listitem"><span class="strong"><strong class="calibre10">RETURNS_SMART_NULLS</strong></span>: This returns<a id="id405" class="calibre1"/> <code class="literal">spy</code> of a given<a id="id406" class="calibre1"/> type.</li><li class="listitem"><span class="strong"><strong class="calibre10">RETURNS_MOCKS</strong></span>: This returns mocks<a id="id407" class="calibre1"/> for objects and the default value for primitives.</li><li class="listitem"><span class="strong"><strong class="calibre10">RETURNS_DEEP_STUBS</strong></span>: This returns<a id="id408" class="calibre1"/> a deep <a id="id409" class="calibre1"/>stub.</li><li class="listitem"><span class="strong"><strong class="calibre10">CALLS_REAL_METHODS</strong></span>: This calls a <a id="id410" class="calibre1"/>real<a id="id411" class="calibre1"/> method.</li></ul></div><p class="calibre9">The following example overrides the default Mockito<a id="id412" class="calibre1"/> settings and uses different return types:</p><div class="informalexample"><pre class="programlisting">@Test
  public void changing_default() throws Exception {
    Stock aCorp = new Stock("A", "A Corp", new BigDecimal(11.20));
    Portfolio pf = Mockito.mock(Portfolio.class);
    //default null is returned
    assertNull(pf.getAvgPrice(aCorp));
    Portfolio pf1 = Mockito.mock(Portfolio.class, Mockito.RETURNS_SMART_NULLS);
    //a smart null is returned
    System.out.println("#1 "+pf1.getAvgPrice(aCorp));
    assertNotNull(pf1.getAvgPrice(aCorp));
    
    Portfolio pf2 = Mockito.mock(Portfolio.class, Mockito.RETURNS_MOCKS);
    //a mock is returned
    System.out.println("#2 "+pf2.getAvgPrice(aCorp));
    assertNotNull(pf2.getAvgPrice(aCorp));
    
    Portfolio pf3 = Mockito.mock(Portfolio.class, Mockito.RETURNS_DEEP_STUBS);
    //a deep stubbed mock is returned
    System.out.println("#3 "+pf3.getAvgPrice(aCorp));
    assertNotNull(pf3.getAvgPrice(aCorp));
  }</pre></div><p class="calibre9">The following screenshot shows the console output:</p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Changing the default settings" class="calibre12"/></div><p class="calibre13"> </p></div><div class="book" title="Resetting mock objects"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec43" class="calibre1"/>Resetting mock objects</h3></div></div></div><p class="calibre9">A static method <code class="literal">reset(T…)</code> enables resetting mock objects. The <a id="id413" class="calibre1"/>
<code class="literal">reset</code> method should be handled with special care; if you need to<a id="id414" class="calibre1"/> reset a mock, you will most likely need another test.</p><p class="calibre9">A <code class="literal">reset</code> method clears the stubs.</p><p class="calibre9">The following code snippet stubs the <code class="literal">getAvgPrice</code> method to return a value, but <code class="literal">reset</code> clears the stub; after <code class="literal">reset</code>, the <code class="literal">getAvgPrice</code> method returns <code class="literal">NULL</code>:</p><div class="informalexample"><pre class="programlisting">@Test 
public void resetMock() throws Exception {
  Stock aCorp = new Stock("A", "A Corp", new BigDecimal(11.20));
    
  Portfolio portfolio = Mockito.mock(Portfolio.class);
  when(portfolio.getAvgPrice(eq(aCorp))).
    thenReturn(BigDecimal.ONE);
  assertNotNull(portfolio.getAvgPrice(aCorp));
  
  Mockito.reset(portfolio);
  //Resets the stub, so getAvgPrice returns NULL
  assertNull(portfolio.getAvgPrice(aCorp));
}</pre></div></div><div class="book" title="Exploring Mockito annotations"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec44" class="calibre1"/>Exploring Mockito annotations</h3></div></div></div><p class="calibre9">We learned that Mockito <a id="id415" class="calibre1"/>supports the <code class="literal">@Mock</code> annotation for mocking. Just like <code class="literal">@Mock</code>, Mockito supports the following three useful annotations:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">@Captor</code>: This simplifies the <a id="id416" class="calibre1"/>creation of <code class="literal">ArgumentCaptor</code>, which is useful when the argument to capture is a super generic class, such as <code class="literal">List&lt;Map&lt;String,Set&lt;String&gt;&gt;.</code></li><li class="listitem"><code class="literal">@Spy</code>: This creates a <code class="literal">spy</code> of a <a id="id417" class="calibre1"/>given object. Use it instead of <code class="literal">spy (object)</code>.</li><li class="listitem"><code class="literal">@InjectMocks</code>: This injects <code class="literal">mock</code> or <code class="literal">spy</code> fields into the tested object automatically using a <a id="id418" class="calibre1"/>constructor injection, setter<a id="id419" class="calibre1"/> injection, or field injection.</li></ul></div></div><div class="book" title="Working with inline stubbing"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec45" class="calibre1"/>Working with inline stubbing</h3></div></div></div><p class="calibre9">Mockito allows us to create mocks while stubbing it. Basically, it allows creating a stub in one line of code. This<a id="id420" class="calibre1"/> can be helpful to keep the test code clean.</p><p class="calibre9">For example, some stubs can be created and stubbed at field initialization in a test. We use the <code class="literal">Stock</code> objects in almost all tests. We can create a global mock <code class="literal">Stock</code> and stub it at definition, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">Stock globalStock =  when(Mockito.mock(Stock.class).getPrice()).thenReturn(BigDecimal.ONE).getMock();
  
  @Test
  public void access_global_mock() throws Exception {
    assertEquals(BigDecimal.ONE, globalStock.getPrice());
  }</pre></div></div><div class="book" title="Determining mocking details"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec46" class="calibre1"/>Determining mocking details</h3></div></div></div><p class="calibre9">
<code class="literal">Mockito.mockingDetails</code> identifies <a id="id421" class="calibre1"/>whether a particular object is a mock or a spy, as follows:</p><div class="informalexample"><pre class="programlisting">@Test
public void mocking_details() throws Exception {
  Portfolio pf1 = Mockito.mock(Portfolio.class, Mockito.RETURNS_MOCKS);
  
  BigDecimal result = pf1.getAvgPrice(globalStock);
  assertNotNull(result);
  assertTrue(Mockito.mockingDetails(pf1).isMock());
  
  Stock myStock = new Stock(null, null, null);
  Stock spy = spy(myStock);
  assertTrue(Mockito.mockingDetails(spy).isSpy());
  
}</pre></div></div></div></div>

<div class="book" title="Drinking Mockito">
<div class="book" title="Behavior-driven development with Mockito"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch04lvl2sec32" class="calibre1"/>Behavior-driven development with Mockito</h2></div></div></div><p class="calibre9">BDD is a software engineering process based on TDD. BDD combines the <a id="id422" class="calibre1"/>best practices <a id="id423" class="calibre1"/>of TDD, <span class="strong"><strong class="calibre10">domain-driven </strong></span><a id="id424" class="calibre1"/>
<span class="strong"><strong class="calibre10">development</strong></span> (<span class="strong"><strong class="calibre10">DDD</strong></span>), and <a id="id425" class="calibre1"/>
<span class="strong"><strong class="calibre10">object-oriented programming</strong></span> (<span class="strong"><strong class="calibre10">OOP</strong></span>).</p><p class="calibre9">In an agile team, scoping a feature is a mammoth task. The business stakeholders talk about business interests, and the development team talks about technical challenges. BDD provides a universal language that allows useful communication and feedback between the stakeholders.</p><p class="calibre9">Dan North developed BDD, created the <a id="id426" class="calibre1"/>
<span class="strong"><strong class="calibre10">JBehave</strong></span> framework for BDD, and proposed the following best practices:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Unit test names should start with the word <span class="strong"><em class="calibre11">should</em></span> and <span class="strong"><em class="calibre11">should</em></span> be written in the order of the business value</li><li class="listitem"><span class="strong"><strong class="calibre10">Acceptance tests</strong></span> (<span class="strong"><strong class="calibre10">AT</strong></span>) should be <a id="id427" class="calibre1"/>written in a user story manner, such as "As a (role) I want (feature) so that (benefit)"</li><li class="listitem">Acceptance criteria should be written in terms of scenarios and implemented as "Given (initial context), when (event occurs), then (ensure some outcomes)"</li></ul></div><p class="calibre9">Let's write a user story for our stock broker simulation:</p><p class="calibre9">
<span class="strong"><strong class="calibre10">Story</strong></span>: A stock is sold</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre10">In order</strong></span> to maximize profit</li><li class="listitem"><span class="strong"><strong class="calibre10">As a</strong></span> Stock broker</li><li class="listitem"><span class="strong"><strong class="calibre10">I want</strong></span> to sell a stock <span class="strong"><strong class="calibre10">when</strong></span> the price goes up by 10 percent</li></ul></div><p class="calibre9">The following is a scenario example:</p><p class="calibre9">
<span class="strong"><strong class="calibre10">Scenario</strong></span>: 10 percent increase in stock price should sell the stock in the market</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre10">Given</strong></span> a customer previously bought FB stocks at $10.00 per share</li><li class="listitem"><span class="strong"><strong class="calibre10">And</strong></span> he currently has 10 shares left in his portfolio</li><li class="listitem"><span class="strong"><strong class="calibre10">When</strong></span> the FB stock price becomes $11.00</li><li class="listitem"><span class="strong"><strong class="calibre10">Then</strong></span> I should sell all the FB stocks and the portfolio should have zero FB stocks</li></ul></div><p class="calibre9">Mockito supports the BDD style of writing tests using the <code class="literal">given-when-then</code> syntax.</p><div class="book" title="Writing tests in BDD style"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec47" class="calibre1"/>Writing tests in BDD style</h3></div></div></div><p class="calibre9">In BDD, <code class="literal">given</code> represents the initial context and <code class="literal">when</code> represents the event or condition. However, Mockito already has a <code class="literal">when</code> style of (initial context definition) method stubbing; therefore, <code class="literal">when</code> doesn't go <a id="id428" class="calibre1"/>well with BDD. Thus, the <code class="literal">BDDMockito</code> class introduces an alias so that we can stub method calls with the <code class="literal">given(object)</code> method.</p><p class="calibre9">The following JUnit test<a id="id429" class="calibre1"/> is implemented in BDD style:</p><div class="informalexample"><pre class="programlisting">@RunWith(MockitoJUnitRunner.class)
public class StockBrokerBDDTest {
  @Mock MarketWatcher marketWatcher;
  @Mock Portfolio portfolio;

  StockBroker broker;

  @Before public void setUp() {
    broker = new StockBroker(marketWatcher);
  }
  
  @Test
  public void should_sell_a_stock_when_price_increases_by_ten_percent(){
    Stock aCorp = new Stock("FB", "FaceBook", new BigDecimal(11.20));
    //Given a customer previously bought 10 'FB' stocks at  
    //$10.00/per share
    given(portfolio.getAvgPrice(isA(Stock.class))).
      willReturn(new BigDecimal("10.00"));

    given(marketWatcher.getQuote(eq("FB"))).
      willReturn(aCorp);
    
    //when the 'FB' stock price becomes $11.00
    broker.perform(portfolio, aCorp);
    
    //then the 'FB' stocks are sold
    verify(portfolio).sell(aCorp,10);
  }
}</pre></div><p class="calibre9">Note that the test name starts with a <code class="literal">should</code> statement. The <code class="literal">given</code> syntax of <code class="literal">Mockito</code> is used to set the initial context that the portfolio already has <code class="literal">FB</code> stocks bought at $10.00 per share and the current <code class="literal">FB</code> stock price is $11.00 per share.</p><p class="calibre9">The following screenshot shows the test execution output:</p><div class="mediaobject"><img src="../images/00058.jpeg" alt="Writing tests in BDD style" class="calibre12"/></div><p class="calibre13"> </p></div><div class="book" title="The BDD syntax"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch04lvl3sec48" class="calibre1"/>The BDD syntax</h3></div></div></div><p class="calibre9">The following methods are used in<a id="id430" class="calibre1"/> conjunction with <code class="literal">given</code>:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="literal">willReturn</code>(a value to be returned): This returns a <a id="id431" class="calibre1"/>given value</li><li class="listitem"><code class="literal">willThrow</code>(a throwable to be thrown): This throws a <a id="id432" class="calibre1"/>given exception</li><li class="listitem"><code class="literal">will</code>(<code class="literal">Answer</code> answer) and <code class="literal">willAnswer</code>(<code class="literal">Answer</code> answer): This is<a id="id433" class="calibre1"/> similar to <code class="literal">then</code>(answer) and<a id="id434" class="calibre1"/> <code class="literal">thenAnswer</code>(answer)</li><li class="listitem"><code class="literal">willCallRealMethod()</code>: This calls the real <a id="id435" class="calibre1"/>method on the mock object or spy<div class="note" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre9">The <code class="literal">jMock</code> and <code class="literal">EasyMock</code> frameworks are<a id="id436" class="calibre1"/> the other two Java-based unit testing frameworks that support mocking for automated unit tests.</p><p class="calibre9">The <code class="literal">jMock</code> and <code class="literal">EasyMock</code> frameworks provide mocking capabilities, but the syntax is not as simple as Mockito. You can<a id="id437" class="calibre1"/> visit the following URLs to explore the frameworks:</p><div class="book"><ul class="itemizedlist1"><li class="listitem"><a class="calibre1" href="http://jmock.org/">http://jmock.org/</a></li><li class="listitem"><a class="calibre1" href="http://easymock.org/">http://easymock.org/</a></li></ul></div><p class="calibre9">To learn more about<a id="id438" class="calibre1"/> BDD and JBehave, visit <a class="calibre1" href="http://jbehave.org/">http://jbehave.org/</a>.</p></div></li></ul></div></div></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch04lvl1sec24" class="calibre1"/>Summary</h1></div></div></div><p class="calibre9">In this chapter, Mockito is described in detail and technical examples are provided to demonstrate the capability of Mockito.</p><p class="calibre9">By the end of this chapter, you will be able to use advanced features of the Mockito framework, and start BDD with Mockito.</p><p class="calibre9">The next chapter will explain the importance of code coverage, line and branch coverage, how to measure code coverage, Eclipse plugins, setting up Cobertura, and generating coverage report using Ant, Gradle, and Maven.</p></div></body></html>