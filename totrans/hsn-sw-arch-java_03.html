<html><head></head><body>
		<div id="_idContainer022">
			<h1 id="_idParaDest-36"><a id="_idTextAnchor034"/>Chapter 2: Software Requirements – Collecting, Documenting, Managing</h1>
			<p>Collecting requirements is arguably one of the most frustrating activities in software production for several reasons. Difficulties often arise because it is never completely clear who the owner is, as well as because architects cannot do a good design without certain requisites, and developers, of course, can't do a proper job without the designs.</p>
			<p>However, it is fairly common practice for a development team to start doing something without a complete requirements collection job because there is no time. Indeed, what often happens, especially in regards to large and complex projects, is that the milestones are put in place before the project scope is completely defined. In this industry, since software is an intangible product (not like a building or a bridge), budget approval is usually a more <em class="italic">fluid</em> process. Therefore, it's not unusual to have a project approved before all the details (including requirements, feasibility, and architectural design) are fully defined. Needless to say, this is an inherently bad practice. </p>
			<p>In this chapter, we will look at different techniques for requirements gathering and analysis in order to increase the quality of our software deliverables.</p>
			<p>You will learn about the following:</p>
			<ul>
				<li>The different types of requirements: <strong class="bold">functional</strong> and <strong class="bold">non-functional</strong></li>
				<li>What characteristics a requisite must have</li>
				<li>How to formalize requirements in standard formats</li>
				<li>How to collect requirements by using agile and interactive techniques</li>
			</ul>
			<p>Once you have completed this chapter, you will be able to organize productive requirements gathering sessions and document them in a clear way. Being able to collect and properly document requisites can be a real gamechanger for your career in software development in several ways:</p>
			<ul>
				<li>The quality of the software you produce will be better, as you will focus on what's really needed and be able to prioritize well.</li>
				<li>You will have a better understanding of the language of business and the needs of your customers, and you will therefore implement features that better fit their needs.</li>
				<li>You will have the possibility to run informal and interactive sessions on requirements gathering. (As an example, see the <em class="italic">Event Storming</em> section.)</li>
				<li>You will have a primer about international standards in software requirements specifications, which may be a hard constraint in some environments (for example, when working for regulated industries such as government or healthcare).</li>
			</ul>
			<p>Since requirements collection and management is a practice mostly unrelated to a specific programming language, this chapter doesn't directly reference Java technology.</p>
			<p>Now, let's start exploring the discipline of software requirements engineering.</p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor035"/>Introducing requirements engineering</h1>
			<p>From a purely <a id="_idIndexMarker097"/>metaphorical perspective, if an algorithm is similar to a food recipe, a software requirement is the order we place at a restaurant. But the similarity probably ends here. When we order our food, we pick a specific dish from a discrete list of options, possibly with some small amount of <em class="italic">fine tuning</em>.</p>
			<p>Also, continuing with our example, the software requirement has a longer and more complex life cycle (think about the testing and evolution of the requirement itself), while the food order is very well timeboxed: the customer places the order and receives the food. In the worst case, the customer will dislike the food received (like a user acceptance test going wrong), but it's unusual to evolve or change the order. Otherwise, everything is okay when the customer is happy and the cook has done a great job (at least for that particular customer). Once again, unlike the software requirement life cycle, you will likely end up with bug fixes, enhancements, and so forth.</p>
			<p>Requirements for software projects are complex and can be difficult to identify and communicate. Software requirements engineering is an unusual job. It requires a concerted effort by the customer, the architect, the product manager, and sometimes other various professionals. <em class="italic">But what does a technical requirement actually look like?</em></p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor036"/>Feature, Advantage, and Benefit</h2>
			<p>As we will<a id="_idIndexMarker098"/> see in a few sections, requirements collection involves many different professionals working together to shape what the finished product will look like. These professionals usually fall into two groups, business-aware and technology-aware. You should of course expect those two groups to have different visions and use different languages.</p>
			<p>A good way to build common ground and facilitate understanding between these two groups is to use the <strong class="bold">Feature, Advantage, and Benefit logical flow</strong>.</p>
			<p>This popular framework, sometimes referred to as <strong class="bold">FAB</strong>, is a marketing and sales methodology used to build messaging around a product. While it may not seem immediately relevant in the requirements gathering phase, it is worth looking at.</p>
			<p>In the FAB framework, the following apply<a id="_idTextAnchor037"/>:</p>
			<ul>
				<li>A <strong class="bold">Feature</strong> is an<a id="_idIndexMarker099"/> inherent product characteristic, strictly related to what the product can do.</li>
				<li>The <strong class="bold">Advantage</strong> can<a id="_idIndexMarker100"/> be defined as what you achieve when using a particular Feature. It is common to have more than one Advantage linked to the same technical feature.</li>
				<li>The <strong class="bold">Benefit</strong> is the<a id="_idIndexMarker101"/> final reason why you would want to use the Feature. If you want, it's one further step of abstraction starting from advantages, and it is common to have more than one Benefit linked to the same feature.</li>
			</ul>
			<p>Let's see an <a id="_idIndexMarker102"/>example of FAB, related to the mobile payment example that we are carrying over from the previous chapter:</p>
			<ul>
				<li>A <strong class="bold">Feature</strong> is the possibility of authorizing payments with biometric authentication (such as with your fingerprint or face ID). That's just the technical aspect, directly related to the way the application is implemented.</li>
				<li>The related <strong class="bold">Advantage</strong> is that you don't need to insert a PIN or password (and overall, you will need a simpler interaction with your device – possibly just one touch). That's what the feature will enable, in terms of usage of the application.</li>
				<li>The linked <strong class="bold">Benefit</strong> is that your payments will be faster and easier. But another benefit <a id="_idIndexMarker103"/>can be that your payments will also be safer (no one will steal your PIN or password). That's basically the reason why you may want to use this particular feature.</li>
			</ul>
			<p>As you can imagine, a non-technical person (for example, a salesperson or the final customer) will probably think of each requirement in terms of benefits or advantages. And that's the right way to do it. However, having reasoning on the FAB flow could help in having a uniform point of view, and possibly <em class="italic">repositioning</em> desiderata into features and eventually requirements. We can look at a simple example regarding user experience.</p>
			<p>Sticking with our mobile payments sample application, a requirement that business people may want to think about is the advantages that the usage of this solution will bring. </p>
			<p>One simple example of a requirement could be to have a list of payments easily accessible in the app. A feature linked to that example would allow the customers to see their transaction list immediately after logging into the system. </p>
			<p>In order to complete our flow, we should also think about the benefits, which in this case could be described as the ability to keep your expenses under control. However, this could also work the other way around. When reasoning with more tech-savvy stakeholders, it's easier to focus on product features. </p>
			<p>You may come up with a feature such as <em class="italic">a user currently not provisioned in the system should be presented with a demo version of the application</em>.</p>
			<p>The advantage here is having an easy way to try the application's functionalities. The benefit of this for customers is that they can try the application before signing up for an account. The benefit for the business is that they have free advertising to potentially draw in more customers.</p>
			<p>You might now ask, <em class="italic">so what am I looking for, when doing requirements gathering, that is, searching for features?</em> There are no simple answers here. </p>
			<p>My personal experience says that a feature may be directly considered a requirement, or, more often, be composed of more than one requirement. However, your mileage may vary depending on the type of product and the kind of requirements expressed.</p>
			<p>One final thing to note about the FAB reasoning is that it will help with clustering requirements (by affinity to similar requirements or benefits), and with prioritizing them (depending on which benefit is the most important).</p>
			<p>Now we have<a id="_idIndexMarker104"/> a simple process to link the technical qualities of our product to business impacts. However, we haven't yet defined exactly what a requirement is and what its intrinsic characteristics are. Let's explore what a requirement looks like.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor038"/>Features and technical requirements</h2>
			<p>As we saw in <a id="_idIndexMarker105"/>the previous section, requirements are usually strictly related to the <strong class="bold">features</strong> of the system. Depending on who is posing the request, requirements can be specified with varying amounts of technical detail. A requirement may be as low-level as the definition of an API or other software interfaces, including arguments and quantitative input validation/outcome. Here is an example of what a detailed, technically specified requirement may look like:</p>
			<p><em class="italic">When entering the account number (string, six characters), the system must return the profile information. Result code as </em><strong class="source-inline">int</strong><em class="italic"> (0 if operation is successful), name as </em><strong class="source-inline">string</strong><em class="italic">, and surname as </em><strong class="source-inline">string</strong><em class="italic"> [...]. In the case of account in an invalid format, the system must return a result code identifying the reason of the fault, as per a mapping table to be defined.</em></p>
			<p>Often requirements <a id="_idIndexMarker106"/>are less technical, identifying more behavioral aspects of the system. In this case, drawing on the model we discussed in the previous section (<em class="italic">Feature, Advantage, and Benefit</em>), we are talking about something such as a feature or the related advantage.</p>
			<p>An example here, for the same functionality as before, may look like this: </p>
			<p><em class="italic">The user must have the possibility to access their profile, by entering the account number.</em></p>
			<p>It's easy to understand that a non-technical requirement must be detailed in a quantitative and objective way before being handed over to development teams. <em class="italic">But what makes a requirement quantitative and objective?</em></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor039"/>Types and characteristics of requirements</h2>
			<p>There are a number of <a id="_idIndexMarker107"/>characteristics that make a requirement effective, meaning easy to understand and respondent to the customer expectations in a non-ambiguous way. </p>
			<p>From my personal point of view, in order to be effective, a requirement must be the following:</p>
			<ul>
				<li><strong class="bold">Consistent</strong>: The <a id="_idIndexMarker108"/>requirement must not conflict with other requirements or existing functionalities unless this is intentional. If it is intentional (for example, we are removing old functionalities or fixing wrong behaviors), the new requirement must explicitly override older requirements, and it's probably an attention point since corner cases and conflicts are likely to happen. </li>
				<li><strong class="bold">Implementable</strong>: This <a id="_idIndexMarker109"/>means, first of all, that the requirement should be feasible. If our system requires a direct brain interface to be implemented, this of course will not work (at least today). Implementable further means that the requirement must be achievable in the right amount of time and at the right cost. If it needs 100 years to be implemented, it's in theory feasible but probably impractical.</li>
			</ul>
			<p>Moreover, these points need to be considered within the context of the current project, since although it may be easy to implement something in one environment it may not be feasible in another. For example, if we were a start-up, we could probably launch a brand-new service on our app that would have little impact on the existing userbase. If we were a big enterprise, however, with a large customer base and consolidated access patterns, this may need to be evaluated more thoroughly.</p>
			<ul>
				<li><strong class="bold">Explicit</strong>: There<a id="_idIndexMarker110"/> should be no room for interpretation in a software requirement. Ambiguity is likely to happen when the requirement is defined in natural language, given that a lot of unspoken data is taken erroneously for granted. For this reason, it is advised to use tables, flowcharts, interface mockups, or whatever schema can help clarify the natural language and avoid ambiguity. Also, straightforward wording, using defined quantities, imperative verbs, and no metaphors, is strongly advised.</li>
				<li><strong class="bold">Testable</strong>: In<a id="_idIndexMarker111"/> the current development philosophies, heavily focused on experimentation and trial and error (we will see more on this in the upcoming chapters), a requirement must be translated in a software test case, even better if it can be fully automated. While it may be expected that the customer doesn't have any knowledge of software testing techniques, it must be possible to put testing scenarios on paper, including things such as tables of the expected outputs over a significant range of inputs.</li>
			</ul>
			<p>The QA department may, at a later stage, complement this specification with a wider range of cases, in order to test things such as input validation, expected failures (for example, in the case of inputs too large or malformed), and error handling. Security departments may dig into this too, by testing malicious inputs (for example, SQL injections).</p>
			<p>This very last point leads us to think about the technical consequences of a requirement. As we were saying at the beginning of this chapter, requirements are commonly exposed as business features of the system (with a technical standpoint that can vary in the level of detail). </p>
			<p>However, there are <em class="italic">implicit</em> requirements, which are not part of a specific business use case but are essential for <a id="_idIndexMarker112"/>the system to work properly. </p>
			<p>To dig deeper into this concept, we must categorize the requirements into three fundamental types:</p>
			<ul>
				<li><strong class="bold">Functional requirements</strong>: Describing the business features of the system, in terms of<a id="_idIndexMarker113"/> expected behavior and use cases to be covered. These are the usual business requirements impacting the use cases provided by the system to be implemented.</li>
				<li><strong class="bold">Non-functional requirements</strong>: Usually not linked to any specific use case, these <a id="_idIndexMarker114"/>requirements are necessary for the system to work properly. Non-functional requirements are not usually expressed by the same users defining functional requirements. Those are usually <a id="_idIndexMarker115"/>about implicit aspects of the application, necessary to make things work. Examples of non-functional requirements include performance, security, and portability.</li>
				<li><strong class="bold">Constraints</strong>: Implicit<a id="_idIndexMarker116"/> requirements are usually considered a <em class="italic">must</em> and are mandatory. These include external factors and things that need to be taken for granted, such as obeying laws and regulations and complying with standards (both internal and external to the company).</li>
			</ul>
			<p>One example here could be the<a id="_idIndexMarker117"/> well-known <strong class="bold">General Data Protection Regulation</strong> (<strong class="bold">GDPR</strong>), the EU law about data protection and privacy, which you have to comply with if you operate in Europe. But you may also have to comply with the industry standards depending on the particular market in which you are operating (that's pretty common when working with banks and payments), or even standards enforced by the company you are working with. A common example here is the compatibility of the software (such as when it has to be compatible with a certain version of an operating system or a particular browser).</p>
			<p>Now that we've seen the different types of requirements and their characteristics, let's have a look at the life cycle of software requirements.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor040"/>The life cycle of a requirement</h2>
			<p>The <a id="_idIndexMarker118"/>specification of a requirement is usually not immediate. It starts with an idea of how the system should work to satisfy a use case, but it needs reworking and detailing in order to be documented. It must be checked against (or mixed with) non-functional requirements, and of course, may change as the project goes on. In other words, the life cycle of requirements can be summarized as follows. Each phase has an output, which is the input for the following one (the path could be non linear, as we will see):</p>
			<ul>
				<li><strong class="bold">Gathering</strong>: Collection<a id="_idIndexMarker119"/> of use cases and desired system <a id="_idIndexMarker120"/>features, in an unstructured and raw format. This is done in various ways, including interviews, collective sketches, and brainstorming meetings, including both the customer and the internal team. <strong class="bold">Event Storming</strong> (which we will see soon) is a <a id="_idIndexMarker121"/>common structured way to conduct brainstorming meetings, but<a id="_idIndexMarker122"/> less structured techniques are commonly used here, such as using sticky notes to post ideas coming from both customers and internal teams. In this phase, the collection of data usually flows freely without too much elaboration, and people focus more on the creative process and less on the details and impact of the new features. The output for this phase is an unstructured list of requirements, which may be collected in an electronic form (a spreadsheet or text document), or even just a photograph of a wall with sticky notes.</li>
				<li><strong class="bold">Vetting</strong>: As a <a id="_idIndexMarker123"/>natural follow-up, in this phase the<a id="_idIndexMarker124"/> requirements output from the previous phase is roughly analyzed and categorized. Contradicting and unfeasible topics must be addressed. It's not unusual to go back and forth between this phase and the previous one. The output here is still an unstructured list, similar to the one we got from the previous step. But we started to polish it, by removing duplicates, identifying the requirements that need more details, and so on.</li>
				<li><strong class="bold">Analysis</strong>: In <a id="_idIndexMarker125"/>this phase, it's time to conduct a deeper analysis of the output from the previous phase. This includes identifying<a id="_idIndexMarker126"/> the impact of the implementation of every new feature, analyzing the completeness of the requirement (desired behavior on a significant list of inputs, corner cases, and validation), and the prioritization of the requirement. While not necessary, it is not unusual in this case to have a rough idea of the implementation costs of each requirement. The output from this step is a far more stable and polished list, basically a subset of the input we got. But we are still talking about the unstructured data (not having an ID or missing some details, for example), which is what we are going to address in the next phase.</li>
				<li><strong class="bold">Specification</strong>: Given<a id="_idIndexMarker127"/> that we've completed the study of each requirement, it's now time to document it properly, capturing <a id="_idIndexMarker128"/>all the aspects explored so far. We may already have drafts and other data collected during the previous phases (for example, schemas on paper, whiteboard pictures, and so on) that just need to be transcribed and polished. The documentation redacted in this phase has to be accessible and updatable throughout the project. This is essential for tracking purposes. As an output of this phase, you will have each requirement checked and registered in a proper way, in a document or by using a tool. There are more details on this in the <em class="italic">Collecting requirements – formats and tools</em> section of this chapter.</li>
				<li><strong class="bold">Validation</strong>: Since<a id="_idIndexMarker129"/> we got the formal documentation<a id="_idIndexMarker130"/> of each requirement as an output of the previous phase, it is a best practice to double-check with the customer whether the final rework covers their needs. It is not unusual for, after seeing the requirements on paper, a step back to the gathering phase to have to be made in order to refocus on some use cases or explore new scenarios that have been uncovered during the previous phases. The output of this phase has the same format as the output of the previous phase, but you can expect some changes in the content (such as priorities or adding/removing details and contents). Even if some rework is expected, this data can be considered as a good starting point for the development phase.</li>
			</ul>
			<p>So, the requirement life cycle can be seen<a id="_idIndexMarker131"/> as a simple workflow. Some steps directly lead to the next, while sometimes you can loop around phases and step backward. Graphically, it may look like the following diagram:</p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_2.01_B16354.jpg" alt="Figure 2.1 – Software requirements lifecycle&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Software requirements life cycle</p>
			<p>As you can <a id="_idIndexMarker132"/>see in the previous diagram, software requirements specification is often more than a simple phase of the software life cycle. Indeed, since requirements shape the software itself, they may follow a workflow on their own, evolving and going through iterations.</p>
			<p>As per the first step of this flow, let's have a look at requirements gathering.</p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor041"/>Discovering and collecting requirements</h1>
			<p>The first step in<a id="_idIndexMarker133"/> the requirements life cycle is <strong class="bold">gathering</strong>. Elicitation is <a id="_idIndexMarker134"/>an implicit part of that. Before starting to vet, analyze, and ultimately document the requirements, you need to start the conversation and start ideas flowing.</p>
			<p>To achieve this, you<a id="_idIndexMarker135"/> need to have the right people in the room. It may seem trivial, but often it is not clear who the source of requirements should be (for example, the business, a vague set of people including sales, executive management, project sponsors, and so on). <em class="italic">Even if you manage to have those people onboard, who else is relevant for requirement collection?</em></p>
			<p>There is no golden rule here, as it heavily depends on the project environment and team composition:</p>
			<ul>
				<li>You will need for <a id="_idIndexMarker136"/>sure some <strong class="bold">senior technical resources</strong>, usually lead architects. These people will help by giving initial high-level guidance on technical feasibility and ballpark effort estimations.</li>
				<li>Other useful participants are <strong class="bold">enterprise architects</strong> (or business architects), who could be able<a id="_idIndexMarker137"/> to evaluate the impact of the solution on the rest of the enterprise processes and technical architectures. These kinds of profiles are of course more useful in big and complex enterprises and can be less useful in other contexts (such as start-ups). As a further consideration, experienced people with this kind of background can suggest well-known solutions to problems, compared with similar applications already in use (or even reusing functionalities where possible).</li>
				<li><strong class="bold">Quality engineers</strong> can<a id="_idIndexMarker138"/> be a good addition to the team. While they may be less experienced in technical solutions and existing applications, they can think about the suggested requirements in terms of test cases, narrowing them down and making them more specific, measurable, and testable.</li>
				<li><strong class="bold">Security specialists</strong> can be<a id="_idIndexMarker139"/> very helpful. Thinking about security concerns early in the software life cycle can help to avoid surprises later on. While not exhaustive, a quick assessment of the security impacts of proposed requirements can be very useful, increasing the software quality and reducing the need to rework. </li>
			</ul>
			<p>Now that we have all the required people in a room, let's look at a couple of exercises to break the ice and keep ideas flowing to nail down our requirements.</p>
			<p>The first practice we will look at is the <strong class="bold">lean canvas</strong>. This exercise is widely used in the start-up movement, and it focuses on bringing the team together to identify what's important in your idea, and how it will stand out from the competition.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor042"/>The lean canvas</h2>
			<p>The <strong class="bold">lean canvas</strong> is a <a id="_idIndexMarker140"/>kind of holistic approach to requirements, focusing on the product's key aspects, and the overall business context and sustainability.</p>
			<p>Originating as a tool for start-ups, this methodology was developed by Ash Maurya (book author, entrepreneur, and CEO at LEANSTACK) as an evolution/simplification of the Business Model Canvas, which is a similar approach created by Alexander Osterwalder and more oriented to the business model behind the product. This method is based on a one-page template to gather solution requirements out of a business idea. </p>
			<p>The template is <a id="_idIndexMarker141"/>made of nine segments, highlighting nine crucial aspects that the final product must have:</p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_2.02_B16354.jpg" alt="Figure 2.2  – The lean canvas scaffold&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2  – The lean canvas scaffold</p>
			<p>Note that the numbering of each segment reflects the order in which the sections should be filled out. Here is what each segment means:</p>
			<ol>
				<li><strong class="bold">Problem</strong>: <em class="italic">What issues will our customers solve by using our software product?</em></li>
				<li><strong class="bold">Customer Segments</strong>: <em class="italic">Who is the ideal person to use our software product (that is, the person who has the problems that our product will solve)?</em></li>
				<li><strong class="bold">Unique Value Proposition</strong>: <em class="italic">Why is our software product different from other potential alternatives solving similar problems?</em></li>
				<li><strong class="bold">Solution</strong>: <em class="italic">How will our software product solve the problems in section 1?</em></li>
				<li><strong class="bold">Channels</strong>: <em class="italic">How will we reach our target customer?</em> (This is strictly related to how we will market our software solution.)</li>
				<li><strong class="bold">Revenue Streams</strong>: <em class="italic">How we will make money out of our software solution?</em></li>
				<li><strong class="bold">Cost Structure</strong>: <em class="italic">How much will it cost to build, advertise, and maintain our software solution?</em></li>
				<li><strong class="bold">Key Metrics</strong>: <em class="italic">What are the key numbers that need to be used to monitor the health of the project?</em></li>
				<li><strong class="bold">Unfair Advantage</strong>: <em class="italic">What's something that this project has that no one else can copy/buy?</em></li>
			</ol>
			<p>The idea is <a id="_idIndexMarker142"/>to fill each of these areas with one or more propositions about the product's characteristics. This is usually done as a team effort in an informal setting. The canvas is pictured on a whiteboard, and each participant (usually product owners, founders, and tech leads) contributes ideas by sticking Post-it notes in the relevant segments. A <em class="italic">postprocess</em> collective phase usually follows, grouping similar ideas, ditching the less relevant ideas, and prioritizing what's left in each segment.</p>
			<p>As you can see, the focus here is shifted toward the feasibility of the overall project, instead of the detailed list of features and the specification. For this reason, this methodology is often used as a support for doing elevator pitches to potential investors. After this first phase, if the project looks promising and sustainable from the business model point of view, other techniques may be used to create more detailed requirement specifications, including the ones already discussed, and more that we will see in the next sections.</p>
			<p>While the lean canvas is more oriented to the business model and how this maps into software features, in the next section we will explore Event Storming, which is a discovery practice usually more focused on the technical modeling of the solution.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor043"/>Event Storming</h2>
			<p><strong class="bold">Event Storming</strong> is an <a id="_idIndexMarker143"/>agile and interactive way to discover and design business processes and domains. It was described by Alberto Brandolini (IT consultant and founder of the Italian Domain Driven Design community) in a now-famous blog post, and since then has been widely used and perfected.</p>
			<p>The nice thing <a id="_idIndexMarker144"/>about this practice is that it is very friendly and nicely supports brainstorming and cross-team collaboration.</p>
			<p>To run an Event Storming session, you have to collect the right people from across various departments. It usually takes at least business and IT, but you can give various different flavors to this kind of workshop, inviting different profiles (for example, security, UX, testers) to focus on different points of view.</p>
			<p>When you have the right mix of people in the room, you can use a tool to help them interact with each other. When using physical rooms (the workshop can also be run remotely), the best tool is a wall plus sticky notes.</p>
			<p>The aim of the exercise is to design a business process from the user's point of view. <em class="italic">So how do you do that?</em> </p>
			<ol>
				<li value="1">You start <a id="_idIndexMarker145"/>describing <strong class="bold">domain events</strong> related to the user experience (for example, a recipient is selected). Those domain events are transcribed on a sticky note, traditionally orange, and posted to the wall respecting the temporal sequence.</li>
				<li>You then focus on what has caused the domain event. If the cause is a user interaction (for example, the user picks a recipient from a list), it's known as a <strong class="bold">command</strong> and tracked as a blue sticky note, posted close to the related event.</li>
				<li>You may then draft the <strong class="bold">user</strong> behind the command (for example, a customer of the bank). This means drafting a persona description of the user carrying out the command, tracking it on a yellow sticky note posted close to the command.</li>
				<li>If domain events are generated from other domain events (for example, the selected recipient is added to the recently used contacts), they are simply posted close to each other.</li>
				<li>If there are interactions with <strong class="bold">external systems</strong> (for example, the recipient is sent to a CRM system for identification), they are tracked as pink sticky notes and posted near to the related domain event.</li>
			</ol>
			<p>Let's have a look at a <a id="_idIndexMarker146"/>simple example of Event Storming. The following is just a piece of a bigger use case; this subset concisely represents the access of a user to its transactions list. The use case is not relevant here, it's just an example to show the main components of this technique:</p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_2.03_B16354.jpg" alt="Figure 2.3 – The Event Storming components&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – The Event Storming components</p>
			<p>In the diagram, you <a id="_idIndexMarker147"/>can see a small but complete subset of an Event Storming session, including stickies representing the different components (<strong class="bold">User</strong>, <strong class="bold">Command</strong>, and <strong class="bold">Domain Events</strong>) and the grouping representing the aggregates.</p>
			<p><em class="italic">What do you achieve from this kind of representation?</em></p>
			<ul>
				<li>A shared understanding of the overall process.</li>
				<li>A clustering of events and commands, identifying<a id="_idIndexMarker148"/> the so-called <strong class="bold">aggregates</strong>. This concept is very important for the modeling of the solution, and we will come back to this in <a href="B16354_04_Final_JM_ePUB.xhtml#_idTextAnchor089"><em class="italic">Chapter 4</em></a>, <em class="italic">Best Practices for Design and Development</em>, when talking about Domain-Driven Design.</li>
				<li>The visual identification of bottlenecks and unclear links between states of the system.</li>
			</ul>
			<p>It's important to note that this methodology is usually seen as a scaffold. You may want to customize it to fit your needs, tracking different entities, sketching simple user interfaces to define commands, and so on. Moreover, these kinds of sessions are usually iterative. Once you've reached a complete view, you can restart the session with a different audience to further enrich or polish this view, to focus on subdomains and so on.</p>
			<p>In the following section, we will explore some alternative discovery practices.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor044"/>More discovery practices</h2>
			<p>Requirements gathering <a id="_idIndexMarker149"/>and documentation is somewhat of a composite practice. You may find that after brainstorming sessions (for example, a lean canvas, Event Storming, or other comparable practices), other requirement engineering techniques may be needed to complete the vision and explore some scenarios that surfaced during the other sessions. Let's quickly explore these other tools so you can add them to your toolbox.</p>
			<h3>Questionnaires</h3>
			<p>Questions<a id="_idIndexMarker150"/> and answers are a very simple and concise way of capturing fixed points about a software project. If you are capable of compiling a comprehensive set of questions, you can present your questionnaire to the different stakeholders to collect answers and compare the different points of view.</p>
			<p>The hard part is building such a list of questions. You may have some ideas from previous projects, but given that questions and answers are quite a <em class="italic">closed-path</em> exercise, it isn't particularly helpful if you are at the very beginning of the project. Indeed, it is not the best method to use if you are starting from a blank page, as it's not targeted at nurturing creative solutions and ideas. For this reason, I would suggest proceeding with this approach mostly to detail ideas and use cases that surfaced in other ways (for example, after running brainstorming sessions).</p>
			<h3>Mockups and proofs of concepts</h3>
			<p>An excellent <a id="_idIndexMarker151"/>way to clarify ideas is to directly test what the product will look like by playing with a subset of functionalities (even if fake or just stubbed). If you can start to build cheap prototypes, or even just mockups (fake interfaces with no real functionalities behind the scenes), you may be able to get non-technical stakeholders and final users on board sooner, as you give them the opportunity to interact with the product instead of having to imagine it.</p>
			<p>This is <a id="_idIndexMarker152"/>particularly useful in UX design, and for showcasing different solutions. Moreover, in modern development, this technique can be evolved toward a shorter feedback loop (release early, release often), having the stakeholders test alpha releases of the product instead of mockups so they can gain an understanding of what the final product will look like and change the direction as soon as possible.</p>
			<h3>A/B testing </h3>
			<p>A further <a id="_idIndexMarker153"/>use <a id="_idIndexMarker154"/>for this concept is to have the final users test by themselves and drive the product evolution. This technique, known as <strong class="bold">A/B testing</strong>, is used in production by high-performing organizations and requires some technological support to be implemented. The principle is quite simple: you pick two (or more) alternative features, put them into production, and measure how they perform. In an evolutionary design, the best performing will survive, while the others will be discarded.</p>
			<p>As you can imagine, the devil is in the details here. Implementing more alternatives and discarding some of them may be expensive, so often there are just minor differences between them (for example, the color or position of elements in the UI). Also, the performance must be measurable in an objective way, for example, in e-commerce you might measure the impact on purchases, or in advertising the conversions of banners and campaigns.</p>
			<h3>Business intelligence</h3>
			<p>Another <a id="_idIndexMarker155"/>tool to complete and flesh out the requirement <a id="_idIndexMarker156"/>list is <strong class="bold">business intelligence</strong>. This might mean sending surveys to potential customers, exploring competitor functionalities, and doing general market research. You should not expect to get a precise list of features and use cases by using only this technique, but it may be useful for completing your view about the project or coming up with some new ideas.</p>
			<p>You may want to check whether your idea for the finished system resonates with final customers, how your system compares with competitors, or whether there are areas in which you could do better/be different. This tool may be used to validate your idea or gather some last pieces to complete the picture. Looking at <em class="italic">Figure 2.1</em>, this is something you may want to <a id="_idIndexMarker157"/>do during the validation phase.</p>
			<p>Now, we have collected a wide set of requirements and points of view. Following the requirements life cycle that we saw at the beginning of this chapter, it is now time for requirements analysis.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor045"/>Analyzing requirements</h1>
			<p>The discovery <a id="_idIndexMarker158"/>practices that we've seen so far mostly cover the gathering and vetting of requirements. We've basically elicited from the stakeholders details of the desired software functionalities and possibly started organizing them by clustering, removing duplicates, and resolving macroscopic conflicts.</p>
			<p>In the analysis phase, we are going to further explore the implications of the requirements and complete our vision of what the finished product should look like. Take into account that product development is a fluid process, especially if you are using modern project management techniques (more on that in <a href="B16354_05_Final_JM_ePUB.xhtml#_idTextAnchor109"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring the Most Common Development Models</em>). For this reason, you should consider that most probably not every requirement defined will be implemented, and certainly not everything will be implemented in the same release – you could say we are shooting at a moving target. Moreover, it is highly likely that more requirements will be developed later on.</p>
			<p>For this reason, requirements analysis will probably be performed each time, in an iterative approach. Let's start with the first aspect you should consider when analyzing the requirements.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor046"/>Checking for coherence and feasibility</h2>
			<p>In the<a id="_idIndexMarker159"/> first section, we clearly stated that a requirement must be consistent and implementable. That is what we should look for in the analysis phase.</p>
			<p>There is no <a id="_idIndexMarker160"/>specific approach for this. It's a kind of qualitative activity, going through requirements one by one and cross-checking them to ensure they are not conflicting with each other. With big and complex requirement sets, this activity may be seen as a <em class="italic">first pass</em>, as no explicit conflict may arise later during design and implementation. Similar considerations may be made with regard to feasibility. In this phase, it's important to catch the big issues and identify the requirements that seem to be unfeasible, however, more issues can arise during later phases.</p>
			<p>If incoherent <a id="_idIndexMarker161"/>or unfeasible requirements are spotted, it's crucial to review them with the relevant stakeholders (usually business), in <a id="_idIndexMarker162"/>order to reconsider the related features, and make changes. From time to time, small changes to the requirement can make it feasible. A classic scenario is related to picking a subset of the data or making similar compromises. In our mobile payments example, it may not be feasible to show instantaneously the whole list of transactions updated in real time, however, it could be a good compromise to show just a subset of them (for example, last year) or have a small visualization delay (for example, a few seconds) when new transactions occur.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor047"/>Checking for explicitness and testability</h2>
			<p>Continuing <a id="_idIndexMarker163"/>with requirements characteristics, it is now time to check the explicitness and testability of each requirement. This may be a little more systematic and quantitative compared to the previous section. Essentially, you should run through the requirements one by one and check whether each requirement is expressed in a defined way, making it easy to understand whether the implementation has been completed correctly. In other words, the requirement <a id="_idIndexMarker164"/>must be testable and it is best if it is testable in an objective and automatable way.</p>
			<p>Testing for explicitness brings with it the concept of completeness. Once a requirement (and the related feature) is accepted, all the different paths must be covered in order to provide the product with predictable behavior in most foreseeable situations. While this may seem hard and complex, in most situations it's enough to play with possible input ranges and conditional branches to make sure all the possible paths are covered. Default cases are another important aspect to consider; if the software doesn't know how to react to particular conditions it's a good idea to define reasonable, standard answers to fall into.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor048"/>Checking non-functional requirements and constraints</h2>
			<p>As the <a id="_idIndexMarker165"/>last step, it's important to run through the requirements list, looking for non-functional requirements and constraints. The topic here is broad and subjective. It's likely not possible (nor useful) to explicate all the non-functional requirements and constraints and put them on our list. Most of them are shared with existing projects, regulated by external parties, or simply not known.</p>
			<p>However, there are areas that have an important impact on the project implementation, and for this reason, must be considered in the analysis phase.</p>
			<p>One usual suspect here is security. All the considerations about user sessions, what to do with unauthenticated users, and how to manage user logins and such have implications for the feasibility and complexity of the solution, other than having an impact on the user experience. Analog reasoning can be made for performance. As seen in the <em class="italic">Checking for coherence and feasibility</em> section, small changes in the amount of data and the expected performances of the system may make all the difference. It's not unusual to have non-technical staff neglecting these aspects or expecting unreasonable targets. Agreeing (and negotiating) on the expected result is a good way to prevent issues later in the project.</p>
			<p>Other <a id="_idIndexMarker166"/>considerations of non-functional requirements and constraints may be particularly relevant in specific use cases. Take into account that this kind of reasoning may also be carried over into the project planning phase, in which constraints in budget or timeframe may drive the roadmap and release plan.</p>
			<p>Now, we've gone through the analysis phase in the software requirements life cycle. As expected, we will now approach the specification phase. We will start with a very formal and structured approach and then look at a less structured alternative. </p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor049"/>Specifying requirements according to the IEEE standard</h1>
			<p>The <strong class="bold">Institute of Electrical and Electronics Engineers</strong> (<strong class="bold">IEEE</strong>) has<a id="_idIndexMarker167"/> driven various efforts in<a id="_idIndexMarker168"/> the field of software requirements standardization. As usual, in this kind of industry standard, the documents are pretty complete and extensive, covering a lot of aspects in a very verbose way.</p>
			<p>The usage of those standards may be necessary for specific projects in particular environments (for example, the public sector, aviation, medicine). The most famous deliverable by IEEE in<a id="_idIndexMarker169"/> this sense is the 830-1998 standard. This standard has been superseded by the ISO/IEEE/IEC 29148 document family.</p>
			<p>In this section, we are going to cover both standards, looking at what the documents describe in terms of content, templates, and best practices to define requirements adhering to the standard.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor050"/>The 830-1998 standard</h2>
			<p>The <strong class="bold">IEEE 830-1998</strong> standard<a id="_idIndexMarker170"/> focuses on the <strong class="bold">Software Requirement Specification</strong> document (also known as <strong class="bold">SRS</strong>), providing templates<a id="_idIndexMarker171"/> and suggestions on content to be covered.</p>
			<p>Some<a id="_idIndexMarker172"/> concepts are pretty similar to the ones discussed in the previous sections. The standard states all the characteristics that a requirement specification must have. Each requirement specification should be the following:</p>
			<ul>
				<li>Correct</li>
				<li>Unambiguous</li>
				<li>Complete</li>
				<li>Consistent</li>
				<li>Ranked for importance and/or stability</li>
				<li>Verifiable</li>
				<li>Modifiable</li>
				<li>Traceable</li>
			</ul>
			<p>As you can see, this is similar to the characteristics of requirements. One interesting new concept added here is the ranking of requirements. In particular, the document suggests <a id="_idIndexMarker173"/>classifying the requirements by importance, assigning priorities to requirements, such as essential, conditional, optional, and/or stability (stability refers to the number of expected changes to the requirement due to the evolution of the surrounding organization).</p>
			<p>Another<a id="_idIndexMarker174"/> interesting concept discussed in this standard is <strong class="bold">prototyping</strong>. I would<a id="_idIndexMarker175"/> say that this is positively futuristic, considering that this standard was defined in 1998. Well before the possibility to cheaply create stubs and mocks, as is normal today, this standard suggests using prototypes to experiment with the possible outcome of the system and use it as a support for requirements gathering and definition.</p>
			<p>The last important point I want to highlight about IEEE 830-1998 is the template. The standard provides a couple of samples and <a id="_idIndexMarker176"/>a suggested index for software requirements specifications. The agenda includes the following:</p>
			<ul>
				<li><strong class="bold">Introduction</strong>: Covering the overview of the system, and other concepts to set the field, such as the scope of the document, purpose of the project, list of acronyms, and so on.</li>
				<li><strong class="bold">Overall description</strong>: Describing the background and the constructs supporting the requirements. Here, you may define the constraints (including technical constraints), the interfaces to external systems, the intended users of the system (for example, the skill level), and the product functions (intended to give an overview of the product scope, without the details that map to specific requirements).</li>
				<li><strong class="bold">Specific requirements</strong>: This refers to the requirements themselves. Here, everything is expected to be specified with a high amount of detail, focusing on inputs (including validation), expected outputs, internal calculations, and algorithms. The standard offers a lot of suggestions for topics that need to be covered, including database design, object design (as in object-oriented programming), security, and so on.</li>
				<li><strong class="bold">Supporting information</strong>: Containing accessory information such as a table of contents, index, and appendixes.</li>
			</ul>
			<p>As you can see, this <a id="_idIndexMarker177"/>SRS document may appear a little verbose, but it's a comprehensive and detailed way to express software requirements. As we will see in the next section, IEEE and other organizations have superseded this standard, broadening the scope and including more topics to be covered.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor051"/>The 29148 standard</h2>
			<p>As <a id="_idIndexMarker178"/>discussed in the previous sections, the 830-1998 standard was superseded by a broader document. The 29148 family of standards represents a superset of 830-1998. The new standard is rich and articulated. It mentions the SRS document, following exactly the same agenda but adding a new section called <strong class="bold">verification</strong>. This section refers to specifying a testing strategy for each element of the software, suggesting that you should define a verification for each element specified in the other sections of the SRS.</p>
			<p>Other than the SRS document, the<a id="_idIndexMarker179"/> 29148 standard suggests four more deliverables. Let's have a quick look at them:</p>
			<ul>
				<li>The <strong class="bold">Stakeholder Requirements Specification</strong>: This places the software project into<a id="_idIndexMarker180"/> the business perspective, analyzing the business environment around it and the impact it will have by focusing on the point of view of the business stakeholders.</li>
				<li>The <strong class="bold">System Requirements Specification</strong>: This focuses on the technical details of the<a id="_idIndexMarker181"/> interactions between the software being implemented and the other system composing the overall architecture. It specifies the domain of the application and the inputs/outputs.</li>
				<li><strong class="bold">System Operational Concept</strong>: This<a id="_idIndexMarker182"/> describes, from the user's point of view, the system's functionality. It takes a point of view on the operation of the system, policies, and constraints (including supported hardware, software, and performance), user classes (meaning the different kinds of users and how they interact with the system), and operational modes.</li>
				<li><strong class="bold">Concepts of Operations</strong>: This <a id="_idIndexMarker183"/>is not a mandatory document. When provided, it addresses the system as a whole and how it fits the overall business strategy of the customer. It includes things such as the investment plan, business continuity, and compliance.</li>
			</ul>
			<p>As we have seen, the standards documents are a very polished and complete way to rationalize the requirements and document them in a comprehensive way. However, sometimes <a id="_idIndexMarker184"/>it may be unpractical to document the requirements in a such detailed and formalized way. Nevertheless, it's important to take these contents as a reference, and consider providing the same information, even if not using the very same template or level of details. </p>
			<p>In the next section, we will have a look at alternative simplified formats for requirements collection and the tools for managing them.</p>
			<h1 id="_idParaDest-53"><a id="_idTextAnchor052"/>Collecting requirements – formats and tools</h1>
			<p>In order to <a id="_idIndexMarker185"/>manage and document requirements, you can use a tool of your choice. Indeed, many teams use electronic documents to detail requirements and track their progression, that is, in which stage of the requirement life cycle they are. However, when requirements grow in complexity, and the size of the team grows, you may want to start <a id="_idIndexMarker186"/>using more tailored tools.</p>
			<p>Let's start by having a look at the required data, then we will focus on associated tooling.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor053"/>Software requirements data to collect</h2>
			<p>Regardless<a id="_idIndexMarker187"/> of the tool of your choice, there is a subset of information you may want to collect:</p>
			<ul>
				<li><strong class="bold">ID</strong>: A <a id="_idIndexMarker188"/>unique identifier will be needed since the requirement will be cross-referenced in many different contexts, such as test cases, documentation, and code comments. It can follow a naming convention <a id="_idIndexMarker189"/>or simply be an incremental number.</li>
				<li><strong class="bold">Description</strong>: A <a id="_idIndexMarker190"/>verbal explanation of the use case to be implemented.</li>
				<li><strong class="bold">Precondition</strong>: (If relevant) the<a id="_idIndexMarker191"/> situation that the use case originates from.</li>
				<li><strong class="bold">Essential</strong>: How<a id="_idIndexMarker192"/> essential the requirement is, usually classified as <em class="italic">must have, should have, or nice to have</em>. This may be useful in order to filter requirements to be included in a release.</li>
				<li><strong class="bold">Priority</strong>: A<a id="_idIndexMarker193"/> way to order/cluster requirements. Also, a useful way to filter requirements to be included in a release.</li>
				<li><strong class="bold">Source</strong>: The <a id="_idIndexMarker194"/>author of the requirement. It may be a department, but it is better if there is also a named owner to contact in case of clarifications being needed.</li>
				<li><strong class="bold">Group</strong>: A way<a id="_idIndexMarker195"/> to cluster requirements for functional areas. Also, can be a useful way to collect a set of requirements to implement in a release.</li>
				<li><strong class="bold">Parent</strong>: This is<a id="_idIndexMarker196"/> optional, in case you want to implement a hierarchy with a complex/high-level requirement made of a set of sub-requirements.</li>
			</ul>
			<p>These <a id="_idIndexMarker197"/>are the basic attributes to collect for each software requirement, to enrich with any further column that may be relevant in your context. </p>
			<p>You may then want to track the implementation of each requirement. The attributes to do so usually include the following:</p>
			<ul>
				<li><strong class="bold">Status</strong>: A synthetic <a id="_idIndexMarker198"/>description of the implementation status, including states such as UNASSIGNED, ASSIGNED, DEVELOPMENT, TESTING, and COMPLETE.</li>
				<li><strong class="bold">Owner</strong>: The <a id="_idIndexMarker199"/>team member to whom this requirement is assigned. It may be a developer, a quality engineer, or someone else, depending on the status.</li>
				<li><strong class="bold">Target release</strong>: The <a id="_idIndexMarker200"/>software release that is targeted to include this requirement.</li>
				<li><strong class="bold">Blocker</strong>: Whether<a id="_idIndexMarker201"/> this requirement is mandatory for this release or not.</li>
				<li><strong class="bold">Depends on</strong>: Whether<a id="_idIndexMarker202"/> this requirement depends on other requirements to be completed (and what they are) before it can be worked on.</li>
			</ul>
			<p>Also, in<a id="_idIndexMarker203"/> this case, this is a common subset of information useful for tracking the requirement status. It may be changed, depending on the tooling and the project management techniques used in your particular context. Let's now have a look at tools to collect and manage this information.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor054"/>Collecting software requirements in spreadsheets</h2>
			<p>Looking at the<a id="_idIndexMarker204"/> list of attributes described in the previous section, you can imagine that these requirements can be easily collected in spreadsheets. It's a tabular format, with one requirement per row, and columns corresponding to the information we've discussed. Also, you could have the status tracking in the same row or associated by ID in a different sheet. Moreover, you can filter the sheet by attribute (for example, priority, group, status), sort it, and limit/validate the inputs where relevant (for example, restricting values from a specified list). Accessory values may also be added (for example, last modified date).</p>
			<p>This is what a requirements spreadsheet might look like:</p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_2.04_B16354.jpg" alt="Figure 2.4 – A requirements spreadsheet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – A requirements spreadsheet</p>
			<p>As mentioned, we can then have a sheet for tracking the progression of each requirement. It may look like the example that follows:</p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_2.05_B16354.jpg" alt="Figure 2.5 – Status tracking sheet&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – Status tracking sheet</p>
			<p>In the next<a id="_idIndexMarker205"/> sections, we will have a look at tools that can be used to support requirements gathering and documentation.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor055"/>Specialized tools for software requirements management</h2>
			<p>As <a id="_idIndexMarker206"/>mentioned in the previous section, with bigger teams and long-term projects, specialized tools for requirements management can be easier to use than a shared document/spreadsheet. </p>
			<p>The most <a id="_idIndexMarker207"/>useful feature is usually having a centralized repo, avoiding back and forth (and a lack of synchronization), which happens when using documents. Other interesting features to look for are auditing (tracking changes), notifications, reporting, and advanced validation/guided input. Also, integration with source code management (for example, associating features with commits and branches) is pretty common and useful.</p>
			<p>The software for requirements management is usually part of a bigger suite of utilities for project management. Here are some common products:</p>
			<ul>
				<li><strong class="bold">Jira</strong> is a<a id="_idIndexMarker208"/> pretty widespread <a id="_idIndexMarker209"/>project management toolkit. It originated as an issue tracking tool to track defects in software products. It's commonly used for tracking features too. It may also be extended with plugins enriching the functionalities of feature collection, organizing, and reporting.</li>
				<li><strong class="bold">Redmine</strong> is an <a id="_idIndexMarker210"/>open<a id="_idIndexMarker211"/> source tool and includes many different project management capabilities. The most interesting thing about it is its customizability, enabling you to track features, associate custom fields, reference source code management tools (for example, Git), and define Gantt charts/calendars. </li>
				<li><strong class="bold">IBM Rational DOORS</strong> is commercial <a id="_idIndexMarker212"/>software for requirements management, very <a id="_idIndexMarker213"/>complete and oriented to mid-large enterprises. It is part of the Rational suite, originally developed by Rational Software (now part of IBM), which is also famous for contributing to the creation of UML notation, which we will discuss in the next chapter.</li>
			</ul>
			<p>The<a id="_idIndexMarker214"/> selection of a requirements management tool is a complex process, involving cost analysis, feature comparison, and more, which is way beyond the goal of this book. </p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor056"/>Spreadsheets versus tools</h2>
			<p>It is a<a id="_idIndexMarker215"/> common debate whether to use specialized tools versus spreadsheets (or documents) for managing lists of requirements. It is<a id="_idIndexMarker216"/> a common path to start using a simpler approach (such as spreadsheets) and move to a tool once the project becomes too big or too complex to manage this way. Moreover, managers and non-technical users are more willing to use spreadsheets because they are more comfortable with such technology. Conversely, tech teams find it is often more effective to work with specialized tools. As usual, there is no one size that fits all, but honestly, the benefits of using a dedicated tool are many. </p>
			<p>The most<a id="_idIndexMarker217"/> immediate is having a centralized repository. Tools for requirement management are made to be used in real time, acting as a central, single source of truth. This allows us to avoid back and forth (and lack of synchronization), which happens when using documents (while you could object here that many Office suites offer real-time sharing and collaborative editing, nowadays). </p>
			<p>Other interesting features included with a specialized tool are auditing (tracking changes), notifications, reporting, and advanced validation/guided input. </p>
			<p>Also, the integration with the source code management (for example, associating features with commits and branches) is pretty common and appreciated by the development teams. Management can also benefit from planning and insight features, such as charts, aggregated views, and integration with other project management tools.</p>
			<p>So, at the end of the day, I strongly advise adopting a full-fledged requirements management <a id="_idIndexMarker218"/>tool instead of a simple spreadsheet if that is possible.</p>
			<p>In the next section, we will explore requirements validation, as a final step in the software requirements life cycle.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Validating requirements</h1>
			<p>As we've seen, the<a id="_idIndexMarker219"/> final phase of the requirements life cycle involves validating the requirements. In this phase, all the produced documentation is expected to be reviewed and formally agreed by all the stakeholders. </p>
			<p>While sometimes neglected and considered optional, this phase is in fact very important. By having a formal agreement, you will ensure that all the iterations on the requirements list, including double-checking and extending partial requirements, still reflect the original intentions of the project.</p>
			<p>The business makes sure that all the advantages and benefits will be achieved, while the technical staff will check that the features are correctly mapped in a set of implementable requirements so that the development team will clearly understand what's expected.</p>
			<p>This <em class="italic">sign-off</em> phase could be considered the point at which the project first truly kicks off. At this point, we have a clearer idea of what is going to be implemented. This is not the final word, however; when <a id="_idIndexMarker220"/>designing the platform and starting the project plans, you can expect the product to be remodeled. Maybe just a set of features will be implemented, while other functionalities will be put on paper later.</p>
			<p>In this section, we took a journey through the requirements life cycle. As already said, most of these phases can be considered iterative, and more than one loop will be needed before completi<a id="_idTextAnchor058"/>ng the process. Let's have a quick recap of the requirements life cycle and the practices we have seen so far:</p>
			<ul>
				<li><strong class="bold">Gathering</strong> <strong class="bold">and</strong> <strong class="bold">vetting</strong>: As <a id="_idIndexMarker221"/>we have seen, these two phases are strictly related and involve a cross-team effort to creatively express ideas and define how the final product should look. Here, we have seen techniques for brainstorming such as the lean canvas, Event Storming, and more.</li>
				<li><strong class="bold">Analysis</strong>: This<a id="_idIndexMarker222"/> phase includes checking the coherence, testability, and so on.</li>
				<li><strong class="bold">Specification</strong>: This <a id="_idIndexMarker223"/>includes the IEEE standard and some less formalized standards and tools.</li>
				<li><strong class="bold">Validation</strong>: This is<a id="_idIndexMarker224"/> the formal sign-off and acceptance of a set of requirements. As said, it's not unusual to see a further rework of such a set by going back to the previous phases, in an iterative way.</li>
			</ul>
			<p>In the next section, we will continue to look at our mobile payments example, focusing on the requirements analysis phase.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor059"/>Case studies and examples</h1>
			<p>Continuing <a id="_idIndexMarker225"/>with the case study about our mobile payments solution, we are going to look at the requirements gathering phase. For the sake of simplicity, we will focus only on a small specific scenario: a peer-to-peer payment between two users of the platform.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor060"/>The mobile payment application example</h2>
			<p>As we are <a id="_idIndexMarker226"/>doing in every chapter, let's have a look at some examples of the concepts discussed in this <a id="_idIndexMarker227"/>chapter applied to the mobile payment application that we are using as a case study.</p>
			<h3>Requirements life cycle</h3>
			<p>In the real world, the<a id="_idIndexMarker228"/> life cycle of requirements will reasonably take weeks (or months), adding up to a lot of requirements and reworking of them, so it is impractical to build a complete example of the requirements life cycle for our mobile payment scenario. However, I think it will be interesting to have a look at how one particular requirement will evolve over the phases we have seen:</p>
			<ol>
				<li value="1">In <a id="_idIndexMarker229"/>the <strong class="bold">gathering</strong> phase, it is likely we will end up with a lot of ideas around ease of use and security for each payment transaction. Most of the participants will start to think from an end user perspective, focusing on the user experience, and so it's likely we will have sketches and mockups of the application. Some more ideas will<a id="_idIndexMarker230"/> revolve around how to authorize the payment itself along with its options (<em class="italic">how about a secret swipe sequence, a PIN code, a face ID, a</em> <strong class="bold">One-Time Password</strong> (<strong class="bold">OTP</strong>)<em class="italic">, or a fingerprint?</em>).</li>
				<li>In <a id="_idIndexMarker231"/>the <strong class="bold">vetting</strong> phase (likely during, or shortly after, the previous phase), we will cluster and clean up what we have collected. The unpractical ideas will be dropped (such as the OTP, which may be cumbersome to implement), while others will be grouped (face ID and fingerprint) under biometric authorization. More concepts will be further explored and detailed: <em class="italic">What does it mean to be fast and easy to use? How many steps should be done to complete the payment?</em> <em class="italic">Is entering a PIN code easy enough (in cases where we cannot use biometric authorization)?</em></li>
				<li>It's now time <a id="_idIndexMarker232"/>to <strong class="bold">analyze</strong> each requirement collected so far. In our case, maybe the payment authorization. It is likely that the user will be presented with a screen asking for biometric authentication. <em class="italic">But what happens if the device doesn't have a supported hardware?</em> <em class="italic">Should the customer be asked for other options, such as a PIN code?</em> <em class="italic">What should happen if the transaction is not authorized?</em> And of course, this kind of reasoning may go further and link more than one requirement: <em class="italic">What if a network is not available? What should happen after the transaction is completed successfully?</em> Maybe the information we have at that moment (where the customer is, what they have bought, the balance of their account) allows for some interesting use cases, such as<a id="_idIndexMarker233"/> contextual advertising, offering discounts, and so on.</li>
				<li>Now that <a id="_idIndexMarker234"/>we have clarified our requirements (and discovered new ones), it's time for <strong class="bold">specification</strong>. Once we pick a format (IEEE, or something simpler, such as a specialized tool or a spreadsheet), we start inserting our requirements one by one. Now, it's time to go for the maximum level of details. Let's think about bad paths (<em class="italic">what happens when things go wrong?</em>), corner cases, alternative solutions, and so on.</li>
				<li>The last phase<a id="_idIndexMarker235"/> is the <strong class="bold">validation</strong> of what we have collected into our tool of choice. It is likely that only a subset of the team has done the analysis and specification, so it's good to share the result of those phases with everyone (especially with non-technical staff and the project sponsors) to understand whether there is anything missing: maybe the assumptions we have made are not what they were expecting. It's not uncommon that having a look at the full list will trigger discussions about prioritization or brand-new ideas (such as the one about contextual advertising that we mentioned in the analysis phase).</li>
			</ol>
			<p>In the next sections, we will see some more examples of the specific phases and techniques.</p>
			<h3>Lean canvas for the mobile payment application</h3>
			<p>The<a id="_idIndexMarker236"/> lean canvas can be imagined as an elevator pitch for getting sponsorship for this application (such as for getting funds or approval for the development). In this regard, the lean canvas is a kind of conversation starter when it comes to requirements. It could be good to identify and detail the main, most important features, but you will probably need to use other techniques (such as the ones described so far) to identify and track all the requirements with a reasonable level of detail.</p>
			<p>With that said, here is how I imagine a lean canvas could look in this particular case. Of course, I am aware that other mobile and contactless solutions exist, so consider this just as an example. For readability purposes, I'm going to represent it as a bullet list. This is a transcribed version, as it happens after collecting all those aspects as sticky notes on a whiteboard:</p>
			<ul>
				<li><strong class="bold">Problem</strong>: The<a id="_idIndexMarker237"/> payment procedure is cumbersome and requires cash or card. Payment with card requires a PIN code or a signature. The existing alternatives are credit or debit cards.</li>
				<li><strong class="bold">Customer segment</strong>: Everybody<a id="_idIndexMarker238"/> with a not-too-old mobile phone. The early adopters could be people that don't own a credit card or don't have one to hand (maybe runners, who don't bring a wallet but only a mobile phone, or office workers during their lunch/coffee break).</li>
				<li><strong class="bold">Unique value proposition</strong>: Pay <a id="_idIndexMarker239"/>with one touch, safely.</li>
				<li><strong class="bold">Solution</strong>: A <a id="_idIndexMarker240"/>sleek, fast, and easy-to-use mobile application, allowing users to authorize payment transactions with biometric authentication.</li>
				<li><strong class="bold">Unfair advantage</strong>: Credit/debit cards that don't need biometric authentication. (Of course I am<a id="_idIndexMarker241"/> aware, as I said, that contactless payments are available with credit cards, and other NFC options are bundled with mobile phones. So, in the real world, our application doesn't really have an advantage over other existing options.)</li>
				<li><strong class="bold">Revenue streams</strong>: Transaction<a id="_idIndexMarker242"/> fees and profiling data over customer spending habits.</li>
				<li><strong class="bold">Cost structure</strong>: App<a id="_idIndexMarker243"/> development, hosting, advertising. (In the real world, you may want to have a ballpark figure for it and even have a hypothesis of how many customers/transactions you will need to break even. This will put you in a better position for pitching the project to investors and sponsors.)</li>
				<li><strong class="bold">Key metrics</strong>: Number <a id="_idIndexMarker244"/>of active users, transactions per day, average amount per transaction.</li>
				<li><strong class="bold">Channels</strong>: Search <a id="_idIndexMarker245"/>engine optimization, affiliation programs, cashback programs.</li>
			</ul>
			<p>In the next section, we'll look at Event Storming for peer-to-peer payments.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor061"/>Event Storming for peer-to-peer payments</h1>
			<p>As we <a id="_idIndexMarker246"/>saw in the <em class="italic">Event Storming</em> section, in an Event Storming session it's important to have a variety of representations from different departments in order to have meaningful discussions. In this case, let's suppose we have business analysts, chief architects, site reliability engineers, and UX designers. This is what our wall may look like after our brainstorming session:</p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_2.06_B16354.jpg" alt="Figure 2.6 – Event Storming for peer-to-peer payment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – Event Storming for peer-to-peer payment</p>
			<p>As you <a id="_idIndexMarker247"/>can see from the preceding diagram, even in this simplified example we begin to develop a clear picture of the people involved in this use case and the external systems. </p>
			<p>We can see that two systems are<a id="_idIndexMarker248"/> identified, <strong class="bold">Identity Management</strong> (<strong class="bold">IDM</strong>) for dealing with customer profiles and <strong class="bold">Backend</strong> for dealing with balances and transactions.</p>
			<p>In terms of command and domain events, this is something you may want to reiterate in order to understand whether more interactions are needed, testing unhappy paths and defining aggregates (probably the hardest and most interesting step toward the translation of this model into software objects).</p>
			<p>In the next section, we will see what a related spreadsheet of requirements might look like.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor062"/>Requirements spreadsheet</h2>
			<p>Now, let's imagine<a id="_idIndexMarker249"/> we successfully completed the Event Storming workshop (or even better, a couple of iterations of it). The collected inputs may be directly worked on and translated into software, especially if developers actively participated in the activity. However, for the sake of tracking, double-checking, and completing the requirements list, it's common to translate those views into a document with a different format. While you can complete a standard IEEE requirement document, especially if you can do some further reworking and have access to all the stakeholders, a leaner format is often more suitable.</p>
			<p>Now, starting<a id="_idIndexMarker250"/> from the features we have identified before, let's start to draft a spreadsheet for collecting and classifying the related requirements:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_2.07_B16354.jpg" alt="Figure 2.7 – Requirement list of a peer-to-peer payment&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – Requirements list of a peer-to-peer payment</p>
			<p>As you can see, the list is not complete, however, it's already clear that from a concept nice and concisely expressed on a couple of sticky notes, you can potentially derive a lot of rows with requirements and relative preconditions.</p>
			<p>Moreover, it is often debated whether you should include all potential paths (for example, including failed logins, error conditions, and other corner cases) in lists like these. The answer is usually common sense; the path is specified if special actions come from it (for example, retries, offering help, and so on). If it's just followed by an error message, this can be specified elsewhere (for example, in the test list and in user acceptance documents).</p>
			<p>Another relevant discussion is about supporting information. From time to time, you may have important information to be conveyed in other formats. The most common example is the user interface, commonly specified with graphical mockups. It is up to you whether attaching the mockups somewhere else and referring to them in a field (for example, notes), or directly embedding everything (a list of requirements plus graphic mockups) into the same document is better. This is not very important, however, and it heavily depends on your specific context and what makes your team feel comfortable.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we have covered a complete overview of software requirements. Knowing the characteristics of a well-defined software requirement, how to collect it, and how to document it is a very good foundation to build software architecture upon. Regardless of the technology and methodologies used in your projects, these ideas will help you to get your project up to speed and to build a collaborative, trusting relationship with your business counterparts.</p>
			<p>On the business side, the use of such tools and practices will allow for a structured way to provide input to the technical team and track the progression and coverage of the features implemented.</p>
			<p>In the next chapter, we will look at software architecture modeling and what methodologies can be used for representing an architectural design.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor064"/>Further reading</h1>
			<ul>
				<li>Ash Maurya, <em class="italic">The Lean Canvas</em> (<a href="https://leanstack.com/leancanvas">https://leanstack.com/leancanvas</a>)</li>
				<li>Alberto Brandolini, <em class="italic">Introducing Event Storming</em> (<a href="http://ziobrando.blogspot.com/2013/11/introducing-event-storming.html">http://ziobrando.blogspot.com/2013/11/introducing-event-storming.html</a>)</li>
				<li>Atlassian, <em class="italic">Jira Software</em> (<a href="https://www.atlassian.com/software/jira">https://www.atlassian.com/software/jira</a>)</li>
				<li>Jean-Philippe Lang, <em class="italic">Redmine</em> (<a href="https://www.redmine.org/">https://www.redmine.org/</a>)</li>
				<li>IBM, <em class="italic">Rational Doors</em> (<a href="https://www.ibm.com/it-it/products/requirements-management">https://www.ibm.com/it-it/products/requirements-management</a>)</li>
			</ul>
		</div>
	</body></html>