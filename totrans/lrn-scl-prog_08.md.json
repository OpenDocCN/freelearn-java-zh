["```java\nfinal case class Fish(volume: Int, weight: Int, teeth: Int, poisonousness: Int)\n\nsealed trait Eatable\n\nfinal case class FreshFish(fish: Fish)\nfinal case class FriedFish(weight: Int) extends Eatable\nfinal case class CookedFish(goodTaste: Boolean) extends Eatable\nfinal case class Sushi(freshness: Int) extends Eatable\n```", "```java\nimport ch08.Model._\nimport ch08.ModelCheck._\nval check: Fish => FreshFish = f => FreshFish(f)\nval prepare: FreshFish => FriedFish = f => FriedFish(f.fish.weight)\nval eat: Eatable => Unit = _ => println(\"Yum yum...\")\n```", "```java\ndef prepareAndEat: Fish => Unit = check andThen prepare andThen eat\n\n```", "```java\nval fish: Fish = fishGen.sample.get\nval freshFish = check(fish)\n```", "```java\nimport scala.language.higherKinds\ntrait Functor[F[_]] {\n  def map[A,B](in: F[A])(f: A => B): F[B]\n}\n```", "```java\ndef mapC[A,B](f: A => B): F[A] => F[B]\n```", "```java\ndef id[A, F[_]](implicit F: Functor[F], arbFA: Arbitrary[F[A]]): Prop =\n  forAll { as: F[A] => F.map(as)(identity) == as }\n```", "```java\nimport org.scalacheck._\nimport org.scalacheck.Prop._\n\ndef associativity[A, B, C, F[_]](implicit F: Functor[F],\n                                 arbFA: Arbitrary[F[A]],\n                                 arbB: Arbitrary[B],\n                                 arbC: Arbitrary[C],\n                                 cogenA: Cogen[A],\n                                 cogenB: Cogen[B]): Prop = {\n  forAll((as: F[A], f: A => B, g: B => C) => {\n    F.map(F.map(as)(f))(g) == F.map(as)(f andThen g)\n  })\n}\n```", "```java\nimplicit val optionFunctor: Functor[Option] = new Functor[Option] {\n  override def map[A, B](in: Option[A])(f: A => B): Option[B] = in.map(f)\n  def mapC[A, B](f: A => B): Option[A] => Option[B] = (_: Option[A]).map(f)\n}\n```", "```java\nproperty(\"Functor[Option] and Int => String, String => Long\") = {\n  import Functor.optionFunctor\n  functor[Int, String, Long, Option]\n}\n+ Functor.Functor[Option] and Int => String, String => Long: OK, passed 100 tests.\n\nproperty(\"Functor[Option] and String => Int, Int => Boolean\") = {\n  import Functor.optionFunctor\n  functor[String, Int, Boolean, Option]\n}\n+ Functor.Functor[Option] and String => Int, Int => Boolean: OK, passed 100 tests.\n```", "```java\nimplicit def eitherFunctor[L] = new Functor[({ type T[A] = Either[L, A] })#T] {\n  override def map[A, B](in: Either[L, A])(f: A => B): Either[L, B] = in.map(f)\n  def mapC[A, B](f: A => B): Either[L, A] => Either[L, B] = (_: Either[L, A]).map(f)\n}\n```", "```java\nimplicit val bucketFunctor: Functor[List] = new Functor[List] {\n  override def map[A, B](in: List[A])(f: A => B): List[B] = in.map(f)\n  def mapC[A, B](f: A => B): List[A] => List[B] = (_: List[A]).map(f)\n}\n```", "```java\ntype Bucket[S] = List[S]\nval bucketOfFishGen: Gen[List[Fish]] = Gen.listOf(fishGen)\n\nval bucketOfFriedFish: Bucket[FriedFish] = ch08.Functor.bucketFunctor.map(bucketOfFishGen.sample.get)(check andThen prepare)\n```", "```java\ndef mapFunc[A, B, F[_]](as: F[A])(f: A => B)(implicit functor: ch08.Functor[F]): F[B] = functor.map(as)(f)\n```", "```java\nimport ch08.Functor._\nimport ch08.ModelCheck._\n{\n type Bucket[S] = Option[S]\n mapFunc(optionOfFishGen.sample.get)(check)\n}\n{\n type Bucket[S] = Either[Exception, S]\n mapFunc(eitherFishGen.sample.get)(check andThen prepare)\n}\n{\n type Bucket[S] = List[S]\n mapFunc(listOfFishGen.sample.get)(prepareAndEat)\n}\n```", "```java\nfinal case class FishPie(weight: Int)\nimport ch08.Model._\ndef bakePie(fish: FreshFish, potatoes: Int, milk: Float): FishPie = FishPie(fish.fish.weight)\n```", "```java\nmapFunc(listOfFishGen.sample.get)(bakePie)\n```", "```java\nval freshFishMaker: List[Fish] => List[FreshFish] = ch08.Functor.bucketFunctor.mapC(check)\n```", "```java\ndef bucketOfFish: Bucket[Fish] = listOfFishGen.sample.get\n\ndef bakeFishAtOnce(potatoes: Int, milk: Float): FreshFish => FishPie = \n  bakePie(_: FreshFish, potatoes, milk)\n\nval pie: Seq[FishPie] = mapFunc(freshFishMaker(bucketOfFish))(bakeFishAtOnce(20, 0.5f))\n```", "```java\ndef bakeFish: FreshFish => Int => Float => FishPie = (bakePie _).curried\nval pieInProgress: List[Int => Float => FishPie] = \n  mapFunc(freshFishMaker(bucketOfFish))(bakeFish)\n```", "```java\nmapFunc(pieInProgress) { (pieFactory: Int => Float => FishPie) =>\n  mapFunc(bucketOfPotatoes) { potato =>\n    mapFunc(bucketOfMilk) { milk =>\n      pieFactory(potato)(milk)\n    }\n  }\n}\n```", "```java\ntrait Applicative[F[_]] extends Functor[F] {\n  def apply[A,B](a: F[A])(f: F[A => B]): F[B]\n  def unit[A](a: => A): F[A]\n}\n```", "```java\ndef identityProp[A, F[_]](implicit A: Applicative[F],\n                          arbFA: Arbitrary[F[A]]): Prop =\n  forAll { as: F[A] =>\n    A(as)(A.unit((a: A) => a)) == as\n  }\n```", "```java\ndef homomorphism[A, B, F[_]](implicit A: Applicative[F],\n                             arbA: Arbitrary[A],\n                             arbB: Arbitrary[B],\n                             cogenA: Cogen[A]): Prop = {\n  forAll((f: A => B, a: A) => {\n    A(A.unit(a))(A.unit(f)) == A.unit(f(a))\n  })\n}\n```", "```java\ndef interchange[A, B, F[_]](implicit A: Applicative[F],\n                            arbFA: Arbitrary[F[A]],\n                            arbA: Arbitrary[A],\n                            arbB: Arbitrary[B],\n                            cogenA: Cogen[A]): Prop = {\n  forAll((f: A => B, a: A) => {\n    val leftSide = A(A.unit(a))(A.unit(f))\n    val func = (ff: A => B) => ff(a)\n    val rightSide = A(A.unit(f))(A.unit(func))\n    leftSide == rightSide\n  })\n}\n```", "```java\ndef composeF[A, B, C]: (B => C) => (A => B) => (A => C) = _.compose\n```", "```java\ndef composition[A, B, C, F[_]](implicit A: Applicative[F],\n                               arbFA: Arbitrary[F[A]],\n                               arbB: Arbitrary[B],\n                               arbC: Arbitrary[C],\n                               cogenA: Cogen[A],\n                               cogenB: Cogen[B]): Prop = {\n  forAll((as: F[A], f: A => B, g: B => C) => {\n    val af: F[A => B] = A.unit(f)\n    val ag: F[B => C] = A.unit(g)\n    val ac: F[(B => C) => (A => B) => (A => C)] = A.unit(composeF)\n    val leftSide = A(as)(A(af)(A(ag)(ac)))\n    val rightSide = A(A(as)(af))(ag)\n\n    leftSide == rightSide\n  })\n}\n```", "```java\nidentityProp[A, F] && homomorphism[A, B, F] && interchange[A, B, F] && composition[A, B, C, F] && FunctorSpecification.functor[A, B, C, F]\n```", "```java\nimplicit val optionApplicative: Applicative[Option] = new Applicative[Option] {\n  ... // map and mapC are the same as in Functor\n  override def apply[A, B](a: Option[A])(f: Option[A => B]): Option[B] = (a,f) match {\n    case (Some(a), Some(f)) => Some(f(a))\n    case _ => None\n  }\n  override def unit[A](a: => A): Option[A] = Some(a)\n}\n```", "```java\nimplicit val bucketApplicative: Applicative[List] = new Applicative[List] {\n  ... // map and mapC are the same as in Functor\n  override def apply[A, B](a: List[A])(f: List[A => B]): List[B] = (a, f) match {\n    case (Nil, _) => Nil\n    case (_, Nil) => Nil\n    case (aa :: as, ff :: fs) =>\n      val fab: (A => B) => B = f => f(aa)\n      ff(aa) :: as.map(ff) ::: fs.map(fab) ::: apply(as)(fs)\n  }\n  override def unit[A](a: => A): List[A] = List(a)\n}\n```", "```java\ndef bakeFish: FreshFish => Int => Float => FishPie = (bakePie _).curried\n\nval pieInProgress: List[Int => Float => FishPie] = \n  mapFunc(freshFishMaker(bucketOfFish))(bakeFish)\n\ndef pie(potato: Bucket[Int], milk: Bucket[Float]) = \n  bucketApplicative(milk)(bucketApplicative(potato)(pieInProgress))\n\nscala> pie(List(10), List(2f))\nres0: List[ch08.Model.FishPie] = List(FishPie(21), FishPie(11), FishPie(78))\n```", "```java\ntrait Applicative[F[_]] extends Functor[F] {\n  // ...\n  def map2[A,B,C](fa: F[A], fb: F[B])(f: (A, B) => C): F[C] =\n    apply(fb)(map(fa)(f.curried))\n}\n```", "```java\noverride def map[A,B](fa: F[A])(f: A => B): F[B] = apply(fa)(unit(f))\n```", "```java\ndef mapC[A,B](f: A => B): F[A] => F[B] = fa => map(fa)(f)\n```", "```java\ndef product[G[_]](G: Applicative[G]): Applicative[({type f[x] = (F[x], G[x])})#f] = {\n  val F = this\n  new Applicative[({type f[x] = (F[x], G[x])})#f] {\n    def unit[A](a: => A) = (F.unit(a), G.unit(a))\n    override def apply[A,B](p: (F[A], G[A]))(fs: (F[A => B], G[A => B])) =\n      (F.apply(p._1)(fs._1), G.apply(p._2)(fs._2))\n  }\n}\n```", "```java\ndef pie3[F[_]: Applicative](fish: F[FreshFish], potato: F[Int], milk: F[Float]): F[FishPie] =\n  implicitly[Applicative[F]].map3(fish, potato, milk)(bakePie)\n```", "```java\ndef map3[A,B,C,D](fa: F[A],\n                  fb: F[B],\n                  fc: F[C])(f: (A, B, C) => D): F[D] =\n  apply(fc)(apply(fb)(apply(fa)(unit(f.curried))))\n```", "```java\ndef map4[A,B,C,D,E](fa: F[A],\n                    fb: F[B],\n                    fc: F[C],\n                    fd: F[D])(f: (A, B, C, D) => E): F[E] = {\n  val ff: (A, B, C) => D => E  = (a,b,c) => d => f(a,b,c,d) \n  apply(fd)(map3(fa, fb, fc)(ff))\n}\n```", "```java\nlazy val check: Fish => FreshFish = f => FreshFish(f)\n```", "```java\nlazy val check: Fish => Option[FreshFish]\n```", "```java\ndef checkHonestly[F[_] : Applicative](noFish: F[FreshFish])(fish: Fish): F[FreshFish] =\n  if (scala.util.Random.nextInt(3) == 0) noFish else implicitly[Applicative[F]].unit(FreshFish(fish))\n```", "```java\ndef freshPotato(count: Int) = List(Some(count))\ndef freshMilk(gallons: Float) = List(Some(gallons))\n\nval trueFreshFish: List[Option[FreshFish]] = \n  bucketOfFish.map(checkHonestly(Option.empty[FreshFish]))\n```", "```java\nimport ch08.Applicative._\ndef freshPie = pie3[({ type T[x] = Bucket[Option[x]]})#T](trueFreshFish, freshPotato(10), freshMilk(0.2f))\n```", "```java\n  def compose[G[_]](G: Applicative[G]): Applicative[({type f[x] = F[G[x]]})#f] = {\n    val F = this\n\n    def fab[A, B]: G[A => B] => G[A] => G[B] = (gf: G[A => B]) => (ga: G[A]) => G.apply(ga)(gf)\n\n    def fg[B, A](f: F[G[A => B]]): F[G[A] => G[B]] = F.map(f)(fab)\n\n    new Applicative[({type f[x] = F[G[x]]})#f] {\n      def unit[A](a: => A) = F.unit(G.unit(a))\n      override def apply[A, B](a: F[G[A]])(f: F[G[A => B]]): F[G[B]] =\n        F.apply(a)(fg(f))\n    }\n  }\n```", "```java\nimplicit val bucketOfFresh: ch08.Applicative[({ type T[x] = Bucket[Option[x]]})#T] = \n  bucketApplicative.compose(optionApplicative)\n```", "```java\nscala> println(freshPie)\nList(Some(FishPie(40)), None, Some(FishPie(36)))\n```", "```java\nimport scala.util._\nimport ch08.Applicative\ndef deep[X](x: X) = Success(Right(x))\ntype DEEP[x] = Bucket[Try[Either[Unit, Option[x]]]]\n\nimplicit val deepBucket: Applicative[DEEP] =\n bucketApplicative.compose(tryApplicative.compose(eitherApplicative[Unit].compose(optionApplicative)))\n\nval deeplyPackaged =\n  pie3[DEEP](trueFreshFish.map(deep), freshPotato(10).map(deep), freshMilk(0.2f).map(deep))\n```", "```java\nscala> println(deeplyPackaged)\nList(Success(Right(Some(FishPie(46)))), Success(Right(Some(FishPie(54)))), Success(Right(None)))\n```", "```java\ntype DEEP[x] = Try[Either[Unit, Bucket[Option[x]]]]\n\nimplicit val deepBucket: Applicative[DEEP] = \n tryApplicative.compose(eitherApplicative[Unit].compose(bucketApplicative.compose(optionApplicative)))\n\nval deeplyPackaged =\n  pie3[DEEP](deep(trueFreshFish), deep(freshPotato(10)), deep(freshMilk(0.2f)))\n```", "```java\nscala> println(deeplyPackaged)\nSuccess(Right(List(Some(FishPie(45)), Some(FishPie(66)), None)))\n```", "```java\nimport scala.{ Traversable => _ }\n\ntrait Traversable[F[_]] extends Functor[F] {\n  def sequence[A,G[_]: Applicative](a: F[G[A]]): G[F[A]]\n  def traverse[A,B,G[_]: Applicative](a: F[A])(f: A => G[B]): G[F[B]]\n}\n```", "```java\nscala> println(freshPie)\nList(None, None, Some(FishPie(38)))\n\nscala>println(ch08.Traversable.bucketTraversable.sequence(freshPie))\nNone\n```", "```java\nscala> println(freshPie)\nList(Some(FishPie(40)), Some(FishPie(27)), Some(FishPie(62)))\n\nscala> println(ch08.Traversable.bucketTraversable.sequence(freshPie))\nSome(List(FishPie(40), FishPie(27), FishPie(62)))\n\n```", "```java\nch08.Traversable.bucketTraversable.traverse(bucketOfFish) { a: Fish =>\n  checkHonestly(Option.empty[FreshFish])(a).map(f => bakePie(f, 10, 0.2f))\n}\n```", "```java\noverride def traverse[A, B, G[_] : Applicative](a: Bucket[A])(f: A => G[B]): G[Bucket[B]] = {\n  val G = implicitly[Applicative[G]]\n  a.foldRight(G.unit(List[B]()))((aa, fbs) => G.map2(f(aa), fbs)(_ :: _))\n}\n```", "```java\nimplicit val optionTraversable = new Traversable[Option] {\n  override def map[A, B](in: Option[A])(f: A => B): Option[B] =\n   Functor.optionFunctor.map(in)(f)\n  override def traverse[A, B, G[_] : Applicative](a: Option[A])(f: A => G[B]): G[Option[B]] = {\n    val G = implicitly[Applicative[G]]\n    a match {\n      case Some(s) => G.map(f(s))(Some.apply)\n      case None => G.unit(None)\n    }\n  }\n}\n```", "```java\ndef sequence[A,G[_]: Applicative](a: F[G[A]]): G[F[A]] = traverse(a)(identity)\n```", "```java\ntrait Traversable[F[_]] extends Functor[F] {\n  // ...\n  def compose[H[_]](implicit H: Traversable[H]): Traversable[({type f[x] = F[H[x]]})#f]\n}\n```", "```java\ntype DEEP[x] = scala.util.Try[Either[Unit, Bucket[Option[x]]]]\n```", "```java\nimport ch08.Traversable._\nval deepTraverse = tryTraversable.compose(eitherTraversable[Unit].compose(bucketTraversable))\n\nval deepYummi = deepTraverse.traverse(deeplyPackaged) { pie: Option[FishPie] =>\n  pie.foreach(p => println(s\"Yummi $p\"))\n  pie\n}\nprintln(deepYummi)\n```", "```java\nYummi FishPie(71)\nYummi FishPie(5)\nYummi FishPie(82)\nSome(Success(Right(List(FishPie(82), FishPie(5), FishPie(71)))))\n```"]