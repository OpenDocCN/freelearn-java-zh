- en: Chapter 7. Artificial Intelligence
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。人工智能
- en: '|   | *"Wisdom begins with Wonder."* |   |'
  id: totrans-1
  prefs: []
  type: TYPE_TB
  zh: '|    | *"智慧始于惊奇。"|'
- en: '|   | --*Socrates* |'
  id: totrans-2
  prefs: []
  type: TYPE_TB
  zh: '|    | --*苏格拉底*|'
- en: We looked at moving, controlling, detecting collisions between, and animating
    Greenfoot actors up to now in this book. What we will look at in this chapter,
    is giving our actors a semblance of intelligent behavior. Doing so will allow
    us to tell better stories and create more engaging user interactions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中已经探讨了如何移动、控制、检测Greenfoot演员之间的碰撞以及为这些演员添加动画。在本章中，我们将探讨如何让我们的演员展现出类似智能的行为。这样做将使我们能够讲述更好的故事并创造更具吸引力的用户交互。
- en: 'Now, the field of **Artificial Intelligence** (**AI**) is very complex, and
    creating truly intelligent behavior for our actors is beyond the scope of this
    book. However, there are some simple techniques we can use to simulate various
    levels of intelligent behavior using probability and heuristics. We will then
    look at a popular algorithm (used in many AAA games) that will allow an actor
    to traverse a path through a set of obstacles. Specifically, you will learn how
    to apply the following to simulate intelligence:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，人工智能（AI）领域非常复杂，为我们的演员创建真正的智能行为超出了本书的范围。然而，我们可以使用一些简单的技术来模拟各种程度的智能行为，这些技术包括概率和启发式方法。然后我们将探讨一个流行的算法（在许多AAA游戏中使用），它将允许一个演员穿过一系列障碍物。具体来说，你将学习如何应用以下内容来模拟智能：
- en: Randomness
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机性
- en: Behavior heuristics
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为启发式
- en: A* (pronounced A-star) pathfinding
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A*（发音为A-star）路径查找
- en: Throughout this book, you have been acquiring the skills to create the *wow*
    factor in your applications, animations, and games. Adding simple AI techniques
    to your repertoire is going to elevate your ability to create and be creative.
    The more wisdom you have around Java programming, the more wonder you will be
    able to provide to your audience.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你一直在学习如何为你的应用程序、动画和游戏增添“哇”的元素。将简单的AI技术加入你的技能库将提升你创造力和创造力的能力。你对Java编程的了解越深，你就能为你的观众提供越多的惊奇。
- en: The MazeWorld scenario
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MazeWorld场景
- en: In the preceding chapter, we learned how to create tile-based worlds. We will
    augment the Hiking World scenario we created using the tile-based method to create
    our new scenario entitled `MazeWorld`. In this scenario, our hero will need to
    navigate around obstacles and avoid three intelligent actors, in order to reach
    the gold at the end of the maze. *Figure 1* contains a screenshot of the completed
    scenario.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何创建基于瓦片的世界。我们将使用基于瓦片的方法增强我们创建的Hiking World场景，以创建一个新的场景，命名为`MazeWorld`。在这个场景中，我们的英雄需要绕过障碍物并避开三个智能演员，才能到达迷宫尽头的金子。*图1*展示了完成后的场景截图。
- en: '![The MazeWorld scenario](img/image00315.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![MazeWorld场景](img/image00315.jpeg)'
- en: 'Figure 1: This is the completed version of MazeWorld'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图1：这是MazeWorld的完成版本
- en: There are a few significant differences between the `HikingWorld` scenario from
    the previous chapter and the new `MazeWorld` scenario we are building in this
    chapter. The redundant area will be quickly explained, and we will slow down and
    explain in detail the changes necessary to create our intelligent actors. Please
    review [Chapter 6](part0042.xhtml "Chapter 6. Scrolling and Mapped Worlds"), *Scrolling
    and Mapped Worlds*, if needed, for a full description of tile-based world creation.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章的`HikingWorld`场景相比，本章我们将构建的新的`MazeWorld`场景有一些显著的不同。我们将快速解释冗余区域，然后放慢速度并详细解释创建智能演员所需的更改。如有需要，请查阅[第6章](part0042.xhtml
    "第6章。滚动和映射世界")，*滚动和映射世界*，以获取基于瓦片的世界创建的完整描述。
- en: The MazeWorld class
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MazeWorld类
- en: 'Create a new scenario and call it `MazeWorld`. In the new scenario, create
    a subclass of the `World` class entitled `MazeWorld`. Choose **no image** as the
    image for this scenario. Here is the implementation of the `MazeWorld` class:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的场景，命名为`MazeWorld`。在新场景中，创建一个名为`MazeWorld`的`World`类的子类。选择**无图像**作为此场景的图像。以下是`MazeWorld`类的实现：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We first start by declaring all of the instance variables for this class. We
    added the `TILEOFFSET` constant (used to record half of the value of the width
    of a tile) and `String validspaces` (used to indicate which tiles our hero can
    walk on). The `WORLD` array defines the tile's type and placement in our world.
    We augmented the `WORLD` array to create various static obstacles with the letter
    `U` and added a goal destination in the lower-right corner via the letter `G`.
    The `W` character designates the walkable background area and `B` designates an
    impassable area.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声明这个类的所有实例变量。我们添加了`TILEOFFSET`常量（用于记录地砖宽度值的一半）和`String validspaces`（用于指示我们的英雄可以走上的地砖）。`WORLD`数组定义了地砖的类型和在我们世界中的位置。我们通过使用字母`U`创建各种静态障碍物并添加了通过字母`G`在右下角的目标目的地来增强`WORLD`数组。`W`字符表示可走动的背景区域，而`B`表示不可通过的区域。
- en: The `shiftWorld`, `shiftWorldActors`, and `createWorldFromTiles` methods and
    the constructor are the same as they were in `HikingWorld`. The `addActorAtTileLocation`
    method simply had one case added to the `switch` statement to handle the creation
    and placement of gold tiles. Getting to the gold tiles is the goal of this scenario.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`shiftWorld`、`shiftWorldActors`、`createWorldFromTiles`方法和构造函数与`HikingWorld`中的相同。`addActorAtTileLocation`方法只是在`switch`语句中添加了一个处理创建和放置金币地砖的情况。到达金币地砖是本场景的目标。'
- en: 'The following methods were added to provide an easy way to access information
    contained in our world: `getTileWidth`, `getTileHeight`, `getTileOffset`, `getStringWorld`,
    `getXHiker`, `getYHiker`, and `getValidSpaces`. We will see their use in the classes
    we define in this chapter. The last method provided in the implementation of `MazeWorld`
    is `prepare()`, which is, by default, used to place the initial actors in our
    world.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法被添加以提供一种方便的方式来访问我们世界中包含的信息：`getTileWidth`、`getTileHeight`、`getTileOffset`、`getStringWorld`、`getXHiker`、`getYHiker`和`getValidSpaces`。我们将在本章定义的类中看到它们的使用。`MazeWorld`实现中提供的最后一个方法是`prepare()`，默认情况下用于将初始演员放置到我们的世界中。
- en: The Hiker class
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 漫步者类
- en: 'Our `Hiker` class is the same as the one we saw in the previous chapter in
    `HikingWorld,` except that we have expanded the ability of this class to move
    up and down as well. Moving in two dimensions was covered in previous chapters,
    and we will provide a summary explanation of this class. Here is the code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Hiker`类与我们在上一章中在`HikingWorld`中看到的是一样的，只不过我们扩展了这个类的上下移动能力。二维移动在之前的章节中已经介绍过，我们将对此类进行总结性解释。以下是代码：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code for the `Hiker` class handles the left, right, up, and down arrow key
    presses and ensures that the actor does not walk through obstacles and calls `shiftWorld()`
    appropriately. It also checks for collision with one of the `ScrollingEnemy` actors
    and stops the game if there is a collision.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Hiker`类的代码处理左右上下箭头键的按下，并确保演员不会穿过障碍物，并适当地调用`shiftWorld()`。它还检查与`ScrollingEnemy`演员之一的碰撞，并在发生碰撞时停止游戏。'
- en: The code for handling up and down movement mirrors the code to handle left and
    right movement. The `handleKeyPresses()` and `boundedMove()`methods have been
    extended by simply adding the cases for up and down movement.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 处理上下移动的代码与处理左右移动的代码类似。`handleKeyPresses()`和`boundedMove()`方法通过简单地添加上下移动的情况进行了扩展。
- en: Scrolling actor
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动演员
- en: 'The `ScrollingActor` class is the same as it was in the previous chapter, and
    we reproduce it here for completeness:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollingActor`类与上一章中的相同，我们在此处重新呈现以保持完整性：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are four classes that subclass `ScrollingActor`. The first two are the
    implementations of `GoldBlock` and `WhiteBlock`. These two actors are the parts
    of the background world that are walkable and thus do not need any special handling.
    Make sure when you create them, that you associate an image of a gold block and
    an image of a white block, respectively. Here is the code for both:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有四个类继承自`ScrollingActor`。前两个是`GoldBlock`和`WhiteBlock`的实现。这两个演员是可走动的背景世界的一部分，因此不需要任何特殊处理。确保在创建它们时，分别关联金币块和白色块的图像。以下是两者的代码：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The other two subclasses of `ScrollingActor` are intended to be subclassed
    (note that they do not have an image associated with them) and help us group actors
    into one of two categories: obstacles or enemies. We will discuss these two subclasses
    next.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollingActor`的其他两个子类旨在被继承（注意它们没有与之关联的图像）并帮助我们将演员分为两类之一：障碍物或敌人。我们将在下一节讨论这两个子类。'
- en: The ScrollingObstacle class
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动障碍物类
- en: 'This class does not add any additional functionality. It merely serves as a
    convenient way to group tiles that instances of the `Hiker` class cannot pass
    through. This makes it easier to perform collision detection in the `Hiker` class.
    Here is the code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类没有添加任何额外的功能。它仅仅是一个方便的方式来分组`Hiker`类的实例无法穿过的砖块。这使得在`Hiker`类中执行碰撞检测变得更容易。以下是代码：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We only have two obstacle tiles: `BlackBlock` and `BlueBlock`. When you create
    these, make sure you associate the appropriate images (as we did in the previous
    chapter) with each other. Here is the code for both:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只有两种障碍砖块：`BlackBlock`和`BlueBlock`。当你创建这些时，确保将适当的图像（就像我们在上一章中做的那样）与它们关联起来。以下是两者的代码：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are now in a position to describe the implementation of the classes that
    exhibit intelligent behavior.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以描述展示智能行为的类的实现。
- en: Intelligently behaving actors
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 智能行为演员
- en: We are now going to add enemies to our `MazeWorld` scenario that implement different
    methods of simulating intelligent behavior. The first method we will discuss uses
    probabilistic movement, the second method uses simple heuristics, and the last
    method uses the **A* pathfinding** algorithm to guide actor movement. Before discussing
    each method, we present the `ScrollingEnemy` class that implements a common structure
    for intelligently behaving actors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将向我们的`MazeWorld`场景添加实现不同智能行为模拟方法的敌人。我们将讨论的第一种方法是概率移动，第二种方法是简单启发式方法，最后一种方法使用**A*路径查找**算法来引导演员移动。在讨论每种方法之前，我们首先展示实现智能行为演员通用结构的`ScrollingEnemy`类。
- en: The ScrollingEnemy class
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ScrollingEnemy类
- en: The class `ScrollingEnemy` inherits from `ScrollingActor`, so it will be placed
    properly within a scrolling world. Then, it sets up a pattern of behavior that
    is conducive to intelligently moving actors. Modeling actual sentient animals,
    `ScrollingEnemy` provides a three-phase action-taking process in its `act()` method.
    First, it calls a method that requires the actor to sense its environment, then
    it calls a method to choose a course of action based on what it has sensed, and
    then it calls a method to move the actor. Please note that this class is `abstract`
    and cannot be instantiated directly.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollingEnemy`类从`ScrollingActor`继承，因此它将被正确地放置在滚动世界中。然后，它设置了一个有利于智能移动演员的行为模式。模仿实际有感知的动物，`ScrollingEnemy`在其`act()`方法中提供了一个三阶段动作处理过程。首先，它调用一个要求演员感知其环境的方法，然后它调用一个基于感知结果选择行动方案的方法，最后它调用一个移动演员的方法。请注意，这个类是`abstract`的，不能直接实例化。'
- en: 'Here is the code for `ScrollingEnemy`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`ScrollingEnemy`类的代码：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `sense()` and `reaction()` methods are empty, as they are intended to be
    overridden by subclasses implementing one of our strategies for intelligent movement.
    The end result of these methods are that they will change the values of the variables
    `speedX` and `speedY` to affect movement. The last method, `boundedMove()`, is
    fully implemented as once the values of `speedX` and `speedY` are set, the movement
    for every subclass of `ScrollingEnemy` is the same.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`sense()`和`reaction()`方法为空，因为它们打算由实现我们智能移动策略之一的子类覆盖。这些方法的结果是它们将`speedX`和`speedY`变量的值改变以影响移动。最后一个方法`boundedMove()`完全实现，一旦`speedX`和`speedY`的值被设置，`ScrollingEnemy`的每个子类的移动都是相同的。'
- en: Randomness
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机性
- en: Algorithms using pure probability to determine solutions to problems are surprisingly
    effective and not uncommon in computer science. While they are almost never the
    best answer, they make for good comparisons against new algorithms developed for
    things such as memory management or scheduling.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纯概率确定问题解决方案的算法出奇地有效，在计算机科学中并不罕见。虽然它们几乎从未是最好的答案，但它们与为内存管理或调度等事物开发的新算法进行了良好的比较。
- en: For games, an actor that moves randomly provides a unique challenge for players
    to avoid or capture. We are going to add an actor to our `MazeWorld` scenario
    that moves around the world randomly.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于游戏来说，一个随机移动的演员为玩家提供了独特的挑战，让他们避免或捕捉。我们将在我们的`MazeWorld`场景中添加一个随机移动的演员。
- en: Spider
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Spider
- en: 'Let us create a new actor by right-clicking on `ScrollingEnemy`, choosing **New
    subclass…**, entering **Spider** as the new class name, and then selecting the
    image `spider.png` in the animals category. Add the following code to this new
    class:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过在`ScrollingEnemy`上右键单击，选择**新建子类…**，输入**Spider**作为新的类名，然后在动物类别中选择图像`spider.png`来创建一个新的演员。将以下代码添加到这个新类中：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: One of the first things to notice, is that we do not provide an implementation
    for the empty `sense()` method defined in `ScrollingEnemy`. Since we are moving
    randomly, we do not need to do any sensing of the environment. The `reaction()`
    method randomly sets both the `speedX` and `speedY` variables to `1`, `0`, or
    `-1`. It only changes the values of those variables 2 percent of the time so that
    movement is not too sporadic.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，我们没有为在`ScrollingEnemy`中定义的空`sense()`方法提供实现。由于我们是随机移动的，所以我们不需要对环境进行任何感知。`reaction()`方法随机地将`speedX`和`speedY`变量设置为`1`、`0`或`-1`。它只有2%的时间改变这些变量的值，这样移动就不会太零散。
- en: You can now test the scenario. First, comment out the additions of the `Mouse`
    and `Snake` objects in the `prepare()` method in `MazeWorld`, and then compile
    and run the scenario. Observe the movements of the Spider objects. Can you get
    around them? Play with the values in the `Spider` class and see how they affect
    the movement of `Spider` objects.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以测试这个场景了。首先，在`MazeWorld`的`prepare()`方法中注释掉`Mouse`和`Snake`对象的添加，然后编译并运行场景。观察蜘蛛对象的移动。你能绕过它们吗？在`Spider`类中调整值，看看它们如何影响蜘蛛对象的移动。
- en: With a little code, we have constructed an enemy that is hard to avoid.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用一点代码，我们就构建了一个难以避免的敌人。
- en: Behavior heuristics
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为启发式
- en: In this method, we supply some simple rules for movement that provide pretty
    good intelligence without complex coding. A good example of an animal in nature
    that follows simple behavior heuristics, is an ant. Ants follow a few rules of
    movement that provide a proven method of finding food in the environment and returning
    to the hive.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们提供了一些简单的移动规则，这些规则提供了相当不错的智能，而不需要复杂的编码。自然界中遵循简单行为启发式算法的动物的一个好例子是蚂蚁。蚂蚁遵循一些移动规则，这些规则提供了一种在环境中找到食物并返回巢穴的可靠方法。
- en: 'Examples of these simple heuristics are:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单启发式算法的例子包括：
- en: If you hit an obstacle, turn left
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你撞到障碍物，就向左转
- en: Follow the sun
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟随太阳
- en: If you are close to prey, run at it
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你靠近猎物，就朝它跑去
- en: Walk in a circular path
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 沿着圆形路径行走
- en: Let us create an actor that will attack the hiker if the hiker gets too close;
    otherwise, it paces back and forth.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个角色，如果徒步者太靠近，它就会攻击徒步者；否则，它就会来回踱步。
- en: The Snake class
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蛇类
- en: Create a class called `Snake` in the same way that we created the previous `Spider`
    class. Of course, you will need to choose the image for a snake, `snake2.png`,
    instead of the spider image.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Snake`的类，就像我们之前创建的`Spider`类一样。当然，你需要选择蛇的图片`snake2.png`，而不是蜘蛛的图片。
- en: 'Here is the code for the `Snake` class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`Snake`类的代码：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `sense()` method for the `Snake` actor is simple. It looks to see whether
    the hiker is within range using the `getObjectsInRange()` collision detection
    method. If the hiker is within range, then `getObjectsInRange()` will return a
    list containing a reference to the `Hiker` object; otherwise, the list will be
    empty. Next, we check whether the returned list is empty by calling the `isEmpty()`
    method and saving the result in the `pathing` variable. We will use the value
    of `pathing` to determine whether the snake should move back and forth or chase
    the hiker.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Snake`角色的`sense()`方法很简单。它使用`getObjectsInRange()`碰撞检测方法查看远处的徒步者是否在范围内。如果徒步者在范围内，那么`getObjectsInRange()`将返回一个包含对`Hiker`对象的引用的列表；否则，列表将为空。接下来，我们通过调用`isEmpty()`方法并保存结果到`pathing`变量来检查返回的列表是否为空。我们将使用`pathing`的值来确定蛇应该来回移动还是追逐徒步者。'
- en: '![The Snake class](img/image00316.jpeg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![蛇类](img/image00316.jpeg)'
- en: 'Figure 2: This shows the movement decision made by the Snake actors. The snake
    moves back and forth, as shown by the arrows, unless the hiker is within the green
    circle. In that case, the snake will move towards the hiker.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图2：这显示了蛇角色所做的移动决策。蛇来回移动，如箭头所示，除非徒步者在绿色圆圈内。在这种情况下，蛇将朝向徒步者移动。
- en: In the `reaction()` method, we have the snake march back and forth if `pathing`
    is true; otherwise, we have the snake chase the hiker. *Figure 2* shows the two
    cases. To march back and forth, we use a delay variable, `pathCounter`, to define
    how long the snake marches in each direction. When the variable expires (has a
    value of `0`), we have the snake switch directions and reset the delay variable.
    To chase the hiker, we simply set the `speedX` and `speedY` variables using a
    simple calculation. If the hiker is to the right of the snake, we set `speedX`
    to be `1`; otherwise, it is set to `-1`. If the hiker is below the snake, then
    we set `speedY` to be `1`; otherwise, we set it to `-1`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reaction()`方法中，如果`pathing`为真，蛇会在两个方向上来回移动；否则，蛇会追逐徒步旅行者。*图2*显示了这两种情况。为了来回移动，我们使用一个延迟变量`pathCounter`来定义蛇在每个方向上移动多长时间。当变量到期（值为`0`）时，我们让蛇改变方向并重置延迟变量。为了追逐徒步旅行者，我们只需使用简单的计算来设置`speedX`和`speedY`变量。如果徒步旅行者在蛇的右边，我们将`speedX`设置为`1`；否则，设置为`-1`。如果徒步旅行者在蛇的下方，那么我们将`speedY`设置为`1`；否则，设置为`-1`。
- en: Let's test the scenario. Because we have not yet implemented the `Mouse` class,
    you will need to comment out the addition of `Mouse` objects in the `prepare()`
    method present in the `MazeWorld` class. Compile and run the scenario. Observe
    the movements of the `Snake` objects. Try getting close to one. Are the `Spider`
    objects or `Snake` objects harder to avoid?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试这个场景。因为我们还没有实现`Mouse`类，所以你需要在`MazeWorld`类中存在的`prepare()`方法中注释掉添加`Mouse`对象的部分。编译并运行场景。观察`Snake`对象的移动。尝试靠近一个。是`Spider`对象还是`Snake`对象更难避开？
- en: A* pathfinding
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: A*路径查找
- en: The A* pathfinding algorithm finds a path between a start location and an end
    location that intelligently avoids obstacles. This algorithm is used heavily in
    the gaming industry. *Ever wonder how enemies in games you have played are able
    to chase you while avoiding obstacles?* Their movement is programmed using this
    algorithm. While the algorithm is fairly complex (as we will soon see), understanding
    it is fairly straightforward. *Figure 3* shows the different areas considered
    by the A* algorithm when determining a path between the mouse actor and the hiker.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: A*路径查找算法在起始位置和目标位置之间找到一个路径，该路径智能地避开障碍物。这个算法在游戏行业中得到了广泛的应用。*你是否曾经好奇过你在游戏中玩过的敌人是如何在避开障碍物的同时追逐你的？*他们的移动是通过使用这个算法来编程的。虽然这个算法相当复杂（我们很快就会看到），但理解它是相当直接的。*图3*显示了A*算法在确定鼠标演员和徒步旅行者之间的路径时考虑的不同区域。
- en: '![A* pathfinding](img/image00317.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![A*路径查找](img/image00317.jpeg)'
- en: 'Figure 3: The first round of comparisons is done on the areas containing a
    red "1", the second round on the areas containing a green "2", the third round
    on the areas containing a blue "3", and the fourth round on the areas containing
    a purple "4". The competing paths are shown with a black square in the upper-right
    corner. After round four, the upper path continues to progress until it reaches
    the goal destination'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图3：第一轮比较是在包含红色“1”的区域进行的，第二轮是在包含绿色“2”的区域进行的，第三轮是在包含蓝色“3”的区域进行的，第四轮是在包含紫色“4”的区域进行的。竞争路径用右上角的黑方块表示。经过第四轮后，上方的路径继续前进，直到达到目标目的地
- en: Overview
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 概述
- en: Before starting the algorithm, you need to divide the world into a grid of uniform-sized
    areas. Each individual area immediately surrounding an actor defines a potential
    location the actor could move to. With this in place, we can start. The A* algorithm
    works by comparing the areas an actor could move to using a heuristic that approximates
    the remaining distance to the goal location (often referred to as the `H` value)
    and combines that with the distance traveled thus far (referred to as the `G`
    value). For example, in *Figure 3*, the mouse can initially move to any of the
    squares marked with a red `1`. When an area contains an obstacle, it is not used
    in the comparison. Therefore, we calculate `H + G` (referred to as `F`) for the
    squares above, below, and to the left of the mouse. The `H` value is approximated
    by just counting how far away we are from the goal destination, ignoring any obstacles
    in the way. The `G` value is determined by counting the number of squares back
    to the starting location of the mouse. Knowing that, we can calculate the `F`
    value (`G+H`) for each of the walkable squares around the mouse. For our example,
    the `F` value for each square is `10` (`H`=9, `G`=1). The algorithm will then
    pretend that the actor has moved to the most favorable current location (the one
    with the lowest `F` value) and then repeat the process. If there is a tie for
    the best `F` values, the algorithm will just choose one at random. *Figure 3*
    depicts this and a few more iterations of the algorithm pictorially. *Our mouse
    can only move up, down, left, and right—not diagonally*. However, the algorithm
    works just as well for actors that can move diagonally.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given that we now have a base understanding of the algorithm, we can state
    it a bit more formally. Here are the steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Add the starting location to the `open` list.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the node in the `open` list that has the minimum `F` value. Let's call
    that *n*.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove *n* from the `open` list and add it to the `closed` list.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For every neighbor of *n* not already in the `closed` list and not containing
    an obstacle, perform the following steps:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate its `F` value, set its parent to be *n*.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it to the `open` list if not already in that list.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Update its `F` value and its parent node if it is in the open list.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not reached the destination, go back to step 2.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have reached the destination node, then construct the path from the start
    location to the end location by backtracking through the parent links.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our algorithm, these are the definitions of `G`, `H`, and `F`:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '`G`: This is the number of locations we need to traverse from the start location
    to get to this node.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: This is approximately how far we are from the destination node. This is
    calculated by summing the absolute value of the difference in the *x* location
    of the current node and the destination node with the absolute value of the difference
    in the *y* location of the current node and the destination node. This is known
    as the *Manhattan distance*.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`H`: 这大约是我们与目标节点的距离。这是通过将当前节点和目标节点在 *x* 位置上的差值的绝对值与当前节点和目标节点在 *y* 位置上的差值的绝对值相加来计算的。这被称为
    *曼哈顿距离*。'
- en: '`F`: This is the sum of `H` and `G`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`F`: 这是 `H` 和 `G` 的和。'
- en: Now, let's look at the implementation of this algorithm in our `MazeWorld` scenario.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这个算法在我们 `MazeWorld` 场景中的实现。
- en: Tip
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To learn more about A* pathfinding, refer to the following resources:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 A* 路径查找的信息，请参考以下资源：
- en: '[http://www.policyalmanac.org/games/aStarTutorial.htm](http://www.policyalmanac.org/games/aStarTutorial.htm)'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[A* 演示教程](http://www.policyalmanac.org/games/aStarTutorial.htm)'
- en: '[http://theory.stanford.edu/~amitp/GameProgramming/](http://theory.stanford.edu/~amitp/GameProgramming/)'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://theory.stanford.edu/~amitp/GameProgramming/](http://theory.stanford.edu/~amitp/GameProgramming/)'
- en: '[http://www.raywenderlich.com/4946/introduction-to-a-pathfinding](http://www.raywenderlich.com/4946/introduction-to-a-pathfinding)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[路径查找简介](http://www.raywenderlich.com/4946/introduction-to-a-pathfinding)'
- en: '[http://en.wikipedia.org/wiki/Pathfinding](http://en.wikipedia.org/wiki/Pathfinding)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[路径查找](http://en.wikipedia.org/wiki/Pathfinding)'
- en: The Mouse class
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 鼠标类
- en: 'We are going to create a `Mouse` actor that will use A* pathfinding to track
    down the hiker. Start by right-clicking on `ScrollingEnemy`, select **New subclass…**,
    then enter `Mouse` as the new class name, and then select the `mouse.png` image
    in the **animals** category. Open Greenfoot''s editor for this new class and enter
    the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个 `Mouse` 角色来使用 A* 路径查找追踪徒步者。首先，在 `ScrollingEnemy` 上右键点击，选择 **New subclass…**，然后输入
    `Mouse` 作为新的类名，接着在 **animals** 类别中选择 `mouse.png` 图片。为这个新类打开 Greenfoot 的编辑器并输入以下代码：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the implementation of the `Mouse` class, the `sense()` method runs the A*
    algorithm to find a path to the hiker, and the `reaction()` method sets `speedX`
    and `speedY` to move the `Mouse` object along the found path. As the hiker can
    move, the `Mouse` class will need to update its calculated path periodically.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Mouse` 类的实现中，`sense()` 方法运行 A* 算法以找到通往徒步者的路径，而 `reaction()` 方法将 `speedX`
    和 `speedY` 设置为沿着找到的路径移动 `Mouse` 对象。由于徒步者可以移动，`Mouse` 类需要定期更新其计算出的路径。
- en: The `Mouse` class needs to perform a one-time initialization of the A* pathfinding
    algorithm code in the `addedToWorld()` method. First, a call to the parent's `addedToWorld()`
    method is performed to ensure any initialization needed in that class, for example,
    scaling the actor's image is not skipped. Next, we create a new instance of the
    `TiledWorldPathfinding` class. This is the class that implements A* pathfinding,
    and we will go over it in detail soon. For now, we can just assume it works flawlessly.
    To create a new instance of `TiledWorldPathfinding`, we need to provide the string
    representation of the world defined in the `MazeWorld` class and the set of spaces
    in this representation that are walkable, also defined in `MazeWorld`. The last
    thing this method accomplishes is making sure the actor is aligned to be at the
    center of a grid in the new grid-view of the world needed by the A* algorithm.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mouse` 类需要在 `addedToWorld()` 方法中一次性初始化 A* 路径查找算法代码。首先，执行对父类 `addedToWorld()`
    方法的调用，以确保在该类中执行任何必要的初始化，例如，缩放角色的图像不会跳过。接下来，我们创建 `TiledWorldPathfinding` 类的新实例。这是实现
    A* 路径查找的类，我们将在稍后详细讨论它。现在，我们只需假设它完美无缺地工作。要创建 `TiledWorldPathfinding` 的新实例，我们需要提供在
    `MazeWorld` 类中定义的世界的字符串表示以及在此表示中可通行的空间集合，这些也在 `MazeWorld` 中定义。此方法完成的最后一件事是确保角色在所需的新网格视图中对齐，以便位于网格的中心。 '
- en: The `sense()` method runs the A* pathfinding algorithm. It is wrapped in a delay
    variable in order to lower the rate at which we rerun the algorithm, in order
    to be more efficient as the hiker will not really be able to move very far during
    the delay. When `searchDelay` is less than zero, we ask our world for the location
    of the `Hiker` object and determine what row and column the hiker is on. We pass
    our location and the location of the hiker to the `findShortestFeasiblePath()`
    method of `TiledWorldPathfinding`. For convenience, we have chosen to represent
    locations in the world as points defined by the `Point` class. We will look at
    the implementation of `Point` soon. The `findShortestFeasiblePath()` method then
    returns the shortest feasible path from the location of the mouse to the location
    of the hiker. The path returned contains our current location, so we remove that
    from the path and then reset the `searchDelay` value.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`sense()`方法运行A*路径查找算法。它被延迟变量包装，以便降低我们重新运行算法的速率，使其更高效，因为在延迟期间徒步者实际上无法移动很远。当`searchDelay`小于零时，我们向我们的世界请求`Hiker`对象的位置，并确定徒步者所在的行和列。我们将我们的位置和徒步者的位置传递给`TiledWorldPathfinding`的`findShortestFeasiblePath()`方法。为了方便，我们选择将世界中的位置表示为由`Point`类定义的点。我们很快就会看到`Point`类的实现。然后，`findShortestFeasiblePath()`方法返回从鼠标位置到徒步者位置的最短可行路径。返回的路径包含我们的当前位置，因此我们从路径中移除它，然后重置`searchDelay`值。'
- en: In the `reaction()` method, we just move the `Mouse` object according to the
    path determined in the `sense()` method. First, we check to see whether `walkDelay`
    has become less than zero. We need this delay variable so that the mouse moves
    at a reasonable pace towards the hiker. Inside the `if` statement, we pop off
    the next location from the path to the hiker and then set `speedX` and `speedY`
    to values that will properly move the mouse.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`reaction()`方法中，我们只是根据`sense()`方法中确定的路径移动`Mouse`对象。首先，我们检查`walkDelay`是否小于零。我们需要这个延迟变量，以便鼠标以合理的速度向徒步者移动。在`if`语句内部，我们从路径中弹出下一个位置到徒步者那里，然后将`speedX`和`speedY`设置为将鼠标正确移动到该位置的值。
- en: The `Mouse` class actually has a straightforward implementation. The real heavy
    coding is done in the `TiledWorldPathfinding` class—the class that implements
    A* pathfinding.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`Mouse`类的实现实际上很简单。真正的重头戏是在`TiledWorldPathfinding`类中完成的——这个类实现了A*路径查找。'
- en: The `TiledWorldPathfinding` class is not going to be a subclass of `Actor`.
    It is a non-graphical class that will be used solely to encapsulate the implementation
    of A* pathfinding. To create this class, click on **Edit** in Greenfoot's main
    menu bar and then select **New class…**. In the pop-up window, type `TiledWorldPathfinding`.
    You will see the new class appear below all of the `Actor` classes in Greenfoot's
    main scenario window. Later in this chapter, you will create the `Point` class
    and the `Tile` class in the same way.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`TiledWorldPathfinding`类不会成为`Actor`的子类。它是一个非图形类，将仅用于封装A*路径查找的实现。要创建此类，请点击Greenfoot主菜单栏中的**编辑**，然后选择**新建类…**。在弹出的窗口中，键入`TiledWorldPathfinding`。您将在Greenfoot主场景窗口中所有`Actor`类下方看到新类。在本章的后面部分，您将以相同的方式创建`Point`类和`Tile`类。'
- en: 'Here is the code:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是代码：
- en: '[PRE10]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The main method of this class is `findShortestFeasiblePath()`. The other methods
    in the class support this method, so let's first look at it. The method `findShortestFeasiblePath()`
    accepts two locations in the form of `Point`. The `Point` class is very simple.
    It simply records the row and column values of a location. The `findShortestFeasiblePath()`method
    starts by checking the simple case where the start and end locations are the same
    using the `equals()` method defined in the `Point` class. If so, we can return
    a path that just contains the starting node, and we are done. Next, we check that
    both the starting and end locations are walkable; if they are not, then we really
    can't run the algorithm as it ignores locations that are not walkable, so we return
    `null`. We then set the end node as our destination, add the start node to the
    open list (`openList`), and then run the A* algorithm. We will now look into the
    implementation of `runAStar()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Because we use good functional decomposition, the implementation of `runAStar()`
    is fairly concise. We remove a node from `openList`, process all of its valid
    neighbors, set the node to `done`, and add it to `closedList`. As we are processing
    the neighbors, we add new nodes to `openList`. If we encounter the end node, we
    set `done` to `true` and break out of the loop. This is a straightforward implementation
    of the A* pathfinding algorithm we discussed previously. To complete our discussion,
    we need to look at the implementation of `processNeighbor()`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: In `processNeighbor()`, we check for two things. If the node is not valid (we
    have already processed it or it is not walkable), we skip it. We then check whether
    the node is our target destination. If so, we set the node we just came from as
    the parent and return `true`. If not, we calculate `G`, `H`, and `F`, set the
    parent node, and then add this node to `openList`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: After `runAStar()` completes, we return to the `findShortestFeasiblePath()`
    method. We now have either found a path to the target location or have determined
    that there is no feasible path. If we have found a valid path, we construct a
    list of points stored in `Stack` (see the information box after the following
    two paragraphs) using `deriveWaypoints()`, reset the state of this class so that
    we can be called again, and return the answer to the caller.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: The `deriveWaypoints()` method is small. It derives the path from the `tiledWorld`
    matrix by following the parent pointers from the destination back to the start.
    Along the way, it pushes each node onto a stack. This is why we set parent references
    in `processNeighbor()`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: The last method we discuss in this class is `resetWorld()`. It has the responsibility
    of initializing the `tiledWorld` matrix and making sure it accurately represents
    the current state of the game (where obstacles are and where the destination is).
    We run the A* pathfinding algorithm on `tiledWorld` and not the actual screen
    of the game.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stacks and priority queues**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'In programming, you will use many different types of data structures to store
    your data. We have already used arrays and lists (The List class was first used
    in [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision Detection*).
    Sometimes, we want the ordering to occur in a certain way when storing data, as
    lists and arrays are unordered. In the implementation of A* pathfinding, we use
    two new data structures: a stack and a priority queue. A stack stores data in
    the **Last-in First-out** (**LIFO**) order, while a priority queue stores data
    in sorted order. To learn more about these two data structures, refer to the following
    links:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html](http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html](http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.oopweb.com/Java/Documents/ThinkCSJav/Volume/chap16.htm](http://www.oopweb.com/Java/Documents/ThinkCSJav/Volume/chap16.htm)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.tutorialspoint.com/java/java_stack_class.htm](http://www.tutorialspoint.com/java/java_stack_class.htm)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have two classes that we used to support the running of the A* pathfinding
    algorithm: `Tile` and `Point`. Let''s first discuss the `Tile` class. This class
    is used to represent an area of the screen and is stored in the `tiledWorld` matrix.
    As we progress through the pathfinding algorithm, we need to track information
    about each area. For example, we need to store the `G`, `H`, and `F` values for
    that area; note whether it is the destination node and whether it is walkable
    and record parent information. The class is set up to store that information and
    allow easy access to it. The code is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Comparable interface**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision
    Detection*, we already discussed Java interfaces in general. The `Comparable`
    interface is an interface that requires the implementing class to provide a `compareTo()`
    method. This method will then be used in classes such as `PriorityQueue` to help
    determine ordering within the queue.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the `Point` class gives us a convenient way to refer
    to locations in `tiledWorld`. It concisely tracks the row and column position
    and also provides an easy way to compare points (see whether they are equal).
    Here is the code to accomplish this:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We have now fully implemented the `Mouse` class. That was quite a bit of coding!
    But now, we have an actor that can effectively chase our hiker. Compile the scenario
    and fix any typos you made along the way. We now have a very interesting scenario.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Play test
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have spent a long time on this scenario. Time to play!
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment all of the actors in the `prepare()` method, compile the scenario,
    and then try it out. Can you reach the gold square? Which enemy is hardest to
    avoid?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We really covered a lot of ground in this chapter. As we saw, adding intelligent
    behavior to an actor can range from very simple to very complex. Quite often,
    using randomness or heuristics, or a combination of both can create some very
    challenging enemies and will suffice for many of the games/simulations you create.
    However, there is no substitute for an enemy that knows how to track you down
    through the A* pathfinding algorithm. I hope you find new and creative ways to
    bring challenge, intrigue, and surprise into the behavior of your actors.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the book, we have really covered a lot of topics to help you
    create an interesting and engaging interactive application. Next, we will look
    at creating user interfaces to accept more information from our user and to provide
    them with more feedback.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
