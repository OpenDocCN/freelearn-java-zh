- en: Chapter 7. Artificial Intelligence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '|   | *"Wisdom begins with Wonder."* |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | --*Socrates* |'
  prefs: []
  type: TYPE_TB
- en: We looked at moving, controlling, detecting collisions between, and animating
    Greenfoot actors up to now in this book. What we will look at in this chapter,
    is giving our actors a semblance of intelligent behavior. Doing so will allow
    us to tell better stories and create more engaging user interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the field of **Artificial Intelligence** (**AI**) is very complex, and
    creating truly intelligent behavior for our actors is beyond the scope of this
    book. However, there are some simple techniques we can use to simulate various
    levels of intelligent behavior using probability and heuristics. We will then
    look at a popular algorithm (used in many AAA games) that will allow an actor
    to traverse a path through a set of obstacles. Specifically, you will learn how
    to apply the following to simulate intelligence:'
  prefs: []
  type: TYPE_NORMAL
- en: Randomness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Behavior heuristics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A* (pronounced A-star) pathfinding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout this book, you have been acquiring the skills to create the *wow*
    factor in your applications, animations, and games. Adding simple AI techniques
    to your repertoire is going to elevate your ability to create and be creative.
    The more wisdom you have around Java programming, the more wonder you will be
    able to provide to your audience.
  prefs: []
  type: TYPE_NORMAL
- en: The MazeWorld scenario
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding chapter, we learned how to create tile-based worlds. We will
    augment the Hiking World scenario we created using the tile-based method to create
    our new scenario entitled `MazeWorld`. In this scenario, our hero will need to
    navigate around obstacles and avoid three intelligent actors, in order to reach
    the gold at the end of the maze. *Figure 1* contains a screenshot of the completed
    scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![The MazeWorld scenario](img/image00315.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: This is the completed version of MazeWorld'
  prefs: []
  type: TYPE_NORMAL
- en: There are a few significant differences between the `HikingWorld` scenario from
    the previous chapter and the new `MazeWorld` scenario we are building in this
    chapter. The redundant area will be quickly explained, and we will slow down and
    explain in detail the changes necessary to create our intelligent actors. Please
    review [Chapter 6](part0042.xhtml "Chapter 6. Scrolling and Mapped Worlds"), *Scrolling
    and Mapped Worlds*, if needed, for a full description of tile-based world creation.
  prefs: []
  type: TYPE_NORMAL
- en: The MazeWorld class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new scenario and call it `MazeWorld`. In the new scenario, create
    a subclass of the `World` class entitled `MazeWorld`. Choose **no image** as the
    image for this scenario. Here is the implementation of the `MazeWorld` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We first start by declaring all of the instance variables for this class. We
    added the `TILEOFFSET` constant (used to record half of the value of the width
    of a tile) and `String validspaces` (used to indicate which tiles our hero can
    walk on). The `WORLD` array defines the tile's type and placement in our world.
    We augmented the `WORLD` array to create various static obstacles with the letter
    `U` and added a goal destination in the lower-right corner via the letter `G`.
    The `W` character designates the walkable background area and `B` designates an
    impassable area.
  prefs: []
  type: TYPE_NORMAL
- en: The `shiftWorld`, `shiftWorldActors`, and `createWorldFromTiles` methods and
    the constructor are the same as they were in `HikingWorld`. The `addActorAtTileLocation`
    method simply had one case added to the `switch` statement to handle the creation
    and placement of gold tiles. Getting to the gold tiles is the goal of this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods were added to provide an easy way to access information
    contained in our world: `getTileWidth`, `getTileHeight`, `getTileOffset`, `getStringWorld`,
    `getXHiker`, `getYHiker`, and `getValidSpaces`. We will see their use in the classes
    we define in this chapter. The last method provided in the implementation of `MazeWorld`
    is `prepare()`, which is, by default, used to place the initial actors in our
    world.'
  prefs: []
  type: TYPE_NORMAL
- en: The Hiker class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `Hiker` class is the same as the one we saw in the previous chapter in
    `HikingWorld,` except that we have expanded the ability of this class to move
    up and down as well. Moving in two dimensions was covered in previous chapters,
    and we will provide a summary explanation of this class. Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code for the `Hiker` class handles the left, right, up, and down arrow key
    presses and ensures that the actor does not walk through obstacles and calls `shiftWorld()`
    appropriately. It also checks for collision with one of the `ScrollingEnemy` actors
    and stops the game if there is a collision.
  prefs: []
  type: TYPE_NORMAL
- en: The code for handling up and down movement mirrors the code to handle left and
    right movement. The `handleKeyPresses()` and `boundedMove()`methods have been
    extended by simply adding the cases for up and down movement.
  prefs: []
  type: TYPE_NORMAL
- en: Scrolling actor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ScrollingActor` class is the same as it was in the previous chapter, and
    we reproduce it here for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'There are four classes that subclass `ScrollingActor`. The first two are the
    implementations of `GoldBlock` and `WhiteBlock`. These two actors are the parts
    of the background world that are walkable and thus do not need any special handling.
    Make sure when you create them, that you associate an image of a gold block and
    an image of a white block, respectively. Here is the code for both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The other two subclasses of `ScrollingActor` are intended to be subclassed
    (note that they do not have an image associated with them) and help us group actors
    into one of two categories: obstacles or enemies. We will discuss these two subclasses
    next.'
  prefs: []
  type: TYPE_NORMAL
- en: The ScrollingObstacle class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This class does not add any additional functionality. It merely serves as a
    convenient way to group tiles that instances of the `Hiker` class cannot pass
    through. This makes it easier to perform collision detection in the `Hiker` class.
    Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We only have two obstacle tiles: `BlackBlock` and `BlueBlock`. When you create
    these, make sure you associate the appropriate images (as we did in the previous
    chapter) with each other. Here is the code for both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We are now in a position to describe the implementation of the classes that
    exhibit intelligent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Intelligently behaving actors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now going to add enemies to our `MazeWorld` scenario that implement different
    methods of simulating intelligent behavior. The first method we will discuss uses
    probabilistic movement, the second method uses simple heuristics, and the last
    method uses the **A* pathfinding** algorithm to guide actor movement. Before discussing
    each method, we present the `ScrollingEnemy` class that implements a common structure
    for intelligently behaving actors.
  prefs: []
  type: TYPE_NORMAL
- en: The ScrollingEnemy class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The class `ScrollingEnemy` inherits from `ScrollingActor`, so it will be placed
    properly within a scrolling world. Then, it sets up a pattern of behavior that
    is conducive to intelligently moving actors. Modeling actual sentient animals,
    `ScrollingEnemy` provides a three-phase action-taking process in its `act()` method.
    First, it calls a method that requires the actor to sense its environment, then
    it calls a method to choose a course of action based on what it has sensed, and
    then it calls a method to move the actor. Please note that this class is `abstract`
    and cannot be instantiated directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for `ScrollingEnemy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `sense()` and `reaction()` methods are empty, as they are intended to be
    overridden by subclasses implementing one of our strategies for intelligent movement.
    The end result of these methods are that they will change the values of the variables
    `speedX` and `speedY` to affect movement. The last method, `boundedMove()`, is
    fully implemented as once the values of `speedX` and `speedY` are set, the movement
    for every subclass of `ScrollingEnemy` is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Randomness
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Algorithms using pure probability to determine solutions to problems are surprisingly
    effective and not uncommon in computer science. While they are almost never the
    best answer, they make for good comparisons against new algorithms developed for
    things such as memory management or scheduling.
  prefs: []
  type: TYPE_NORMAL
- en: For games, an actor that moves randomly provides a unique challenge for players
    to avoid or capture. We are going to add an actor to our `MazeWorld` scenario
    that moves around the world randomly.
  prefs: []
  type: TYPE_NORMAL
- en: Spider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let us create a new actor by right-clicking on `ScrollingEnemy`, choosing **New
    subclass…**, entering **Spider** as the new class name, and then selecting the
    image `spider.png` in the animals category. Add the following code to this new
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: One of the first things to notice, is that we do not provide an implementation
    for the empty `sense()` method defined in `ScrollingEnemy`. Since we are moving
    randomly, we do not need to do any sensing of the environment. The `reaction()`
    method randomly sets both the `speedX` and `speedY` variables to `1`, `0`, or
    `-1`. It only changes the values of those variables 2 percent of the time so that
    movement is not too sporadic.
  prefs: []
  type: TYPE_NORMAL
- en: You can now test the scenario. First, comment out the additions of the `Mouse`
    and `Snake` objects in the `prepare()` method in `MazeWorld`, and then compile
    and run the scenario. Observe the movements of the Spider objects. Can you get
    around them? Play with the values in the `Spider` class and see how they affect
    the movement of `Spider` objects.
  prefs: []
  type: TYPE_NORMAL
- en: With a little code, we have constructed an enemy that is hard to avoid.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior heuristics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this method, we supply some simple rules for movement that provide pretty
    good intelligence without complex coding. A good example of an animal in nature
    that follows simple behavior heuristics, is an ant. Ants follow a few rules of
    movement that provide a proven method of finding food in the environment and returning
    to the hive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of these simple heuristics are:'
  prefs: []
  type: TYPE_NORMAL
- en: If you hit an obstacle, turn left
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the sun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are close to prey, run at it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Walk in a circular path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us create an actor that will attack the hiker if the hiker gets too close;
    otherwise, it paces back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: The Snake class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create a class called `Snake` in the same way that we created the previous `Spider`
    class. Of course, you will need to choose the image for a snake, `snake2.png`,
    instead of the spider image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the `Snake` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `sense()` method for the `Snake` actor is simple. It looks to see whether
    the hiker is within range using the `getObjectsInRange()` collision detection
    method. If the hiker is within range, then `getObjectsInRange()` will return a
    list containing a reference to the `Hiker` object; otherwise, the list will be
    empty. Next, we check whether the returned list is empty by calling the `isEmpty()`
    method and saving the result in the `pathing` variable. We will use the value
    of `pathing` to determine whether the snake should move back and forth or chase
    the hiker.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Snake class](img/image00316.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: This shows the movement decision made by the Snake actors. The snake
    moves back and forth, as shown by the arrows, unless the hiker is within the green
    circle. In that case, the snake will move towards the hiker.'
  prefs: []
  type: TYPE_NORMAL
- en: In the `reaction()` method, we have the snake march back and forth if `pathing`
    is true; otherwise, we have the snake chase the hiker. *Figure 2* shows the two
    cases. To march back and forth, we use a delay variable, `pathCounter`, to define
    how long the snake marches in each direction. When the variable expires (has a
    value of `0`), we have the snake switch directions and reset the delay variable.
    To chase the hiker, we simply set the `speedX` and `speedY` variables using a
    simple calculation. If the hiker is to the right of the snake, we set `speedX`
    to be `1`; otherwise, it is set to `-1`. If the hiker is below the snake, then
    we set `speedY` to be `1`; otherwise, we set it to `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's test the scenario. Because we have not yet implemented the `Mouse` class,
    you will need to comment out the addition of `Mouse` objects in the `prepare()`
    method present in the `MazeWorld` class. Compile and run the scenario. Observe
    the movements of the `Snake` objects. Try getting close to one. Are the `Spider`
    objects or `Snake` objects harder to avoid?
  prefs: []
  type: TYPE_NORMAL
- en: A* pathfinding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The A* pathfinding algorithm finds a path between a start location and an end
    location that intelligently avoids obstacles. This algorithm is used heavily in
    the gaming industry. *Ever wonder how enemies in games you have played are able
    to chase you while avoiding obstacles?* Their movement is programmed using this
    algorithm. While the algorithm is fairly complex (as we will soon see), understanding
    it is fairly straightforward. *Figure 3* shows the different areas considered
    by the A* algorithm when determining a path between the mouse actor and the hiker.
  prefs: []
  type: TYPE_NORMAL
- en: '![A* pathfinding](img/image00317.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: The first round of comparisons is done on the areas containing a
    red "1", the second round on the areas containing a green "2", the third round
    on the areas containing a blue "3", and the fourth round on the areas containing
    a purple "4". The competing paths are shown with a black square in the upper-right
    corner. After round four, the upper path continues to progress until it reaches
    the goal destination'
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before starting the algorithm, you need to divide the world into a grid of uniform-sized
    areas. Each individual area immediately surrounding an actor defines a potential
    location the actor could move to. With this in place, we can start. The A* algorithm
    works by comparing the areas an actor could move to using a heuristic that approximates
    the remaining distance to the goal location (often referred to as the `H` value)
    and combines that with the distance traveled thus far (referred to as the `G`
    value). For example, in *Figure 3*, the mouse can initially move to any of the
    squares marked with a red `1`. When an area contains an obstacle, it is not used
    in the comparison. Therefore, we calculate `H + G` (referred to as `F`) for the
    squares above, below, and to the left of the mouse. The `H` value is approximated
    by just counting how far away we are from the goal destination, ignoring any obstacles
    in the way. The `G` value is determined by counting the number of squares back
    to the starting location of the mouse. Knowing that, we can calculate the `F`
    value (`G+H`) for each of the walkable squares around the mouse. For our example,
    the `F` value for each square is `10` (`H`=9, `G`=1). The algorithm will then
    pretend that the actor has moved to the most favorable current location (the one
    with the lowest `F` value) and then repeat the process. If there is a tie for
    the best `F` values, the algorithm will just choose one at random. *Figure 3*
    depicts this and a few more iterations of the algorithm pictorially. *Our mouse
    can only move up, down, left, and right—not diagonally*. However, the algorithm
    works just as well for actors that can move diagonally.
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Given that we now have a base understanding of the algorithm, we can state
    it a bit more formally. Here are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the starting location to the `open` list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the node in the `open` list that has the minimum `F` value. Let's call
    that *n*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remove *n* from the `open` list and add it to the `closed` list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For every neighbor of *n* not already in the `closed` list and not containing
    an obstacle, perform the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate its `F` value, set its parent to be *n*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Add it to the `open` list if not already in that list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Update its `F` value and its parent node if it is in the open list.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have not reached the destination, go back to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have reached the destination node, then construct the path from the start
    location to the end location by backtracking through the parent links.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our algorithm, these are the definitions of `G`, `H`, and `F`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`G`: This is the number of locations we need to traverse from the start location
    to get to this node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`H`: This is approximately how far we are from the destination node. This is
    calculated by summing the absolute value of the difference in the *x* location
    of the current node and the destination node with the absolute value of the difference
    in the *y* location of the current node and the destination node. This is known
    as the *Manhattan distance*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`F`: This is the sum of `H` and `G`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's look at the implementation of this algorithm in our `MazeWorld` scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To learn more about A* pathfinding, refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www.policyalmanac.org/games/aStarTutorial.htm](http://www.policyalmanac.org/games/aStarTutorial.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://theory.stanford.edu/~amitp/GameProgramming/](http://theory.stanford.edu/~amitp/GameProgramming/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.raywenderlich.com/4946/introduction-to-a-pathfinding](http://www.raywenderlich.com/4946/introduction-to-a-pathfinding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://en.wikipedia.org/wiki/Pathfinding](http://en.wikipedia.org/wiki/Pathfinding)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Mouse class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We are going to create a `Mouse` actor that will use A* pathfinding to track
    down the hiker. Start by right-clicking on `ScrollingEnemy`, select **New subclass…**,
    then enter `Mouse` as the new class name, and then select the `mouse.png` image
    in the **animals** category. Open Greenfoot''s editor for this new class and enter
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the implementation of the `Mouse` class, the `sense()` method runs the A*
    algorithm to find a path to the hiker, and the `reaction()` method sets `speedX`
    and `speedY` to move the `Mouse` object along the found path. As the hiker can
    move, the `Mouse` class will need to update its calculated path periodically.
  prefs: []
  type: TYPE_NORMAL
- en: The `Mouse` class needs to perform a one-time initialization of the A* pathfinding
    algorithm code in the `addedToWorld()` method. First, a call to the parent's `addedToWorld()`
    method is performed to ensure any initialization needed in that class, for example,
    scaling the actor's image is not skipped. Next, we create a new instance of the
    `TiledWorldPathfinding` class. This is the class that implements A* pathfinding,
    and we will go over it in detail soon. For now, we can just assume it works flawlessly.
    To create a new instance of `TiledWorldPathfinding`, we need to provide the string
    representation of the world defined in the `MazeWorld` class and the set of spaces
    in this representation that are walkable, also defined in `MazeWorld`. The last
    thing this method accomplishes is making sure the actor is aligned to be at the
    center of a grid in the new grid-view of the world needed by the A* algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The `sense()` method runs the A* pathfinding algorithm. It is wrapped in a delay
    variable in order to lower the rate at which we rerun the algorithm, in order
    to be more efficient as the hiker will not really be able to move very far during
    the delay. When `searchDelay` is less than zero, we ask our world for the location
    of the `Hiker` object and determine what row and column the hiker is on. We pass
    our location and the location of the hiker to the `findShortestFeasiblePath()`
    method of `TiledWorldPathfinding`. For convenience, we have chosen to represent
    locations in the world as points defined by the `Point` class. We will look at
    the implementation of `Point` soon. The `findShortestFeasiblePath()` method then
    returns the shortest feasible path from the location of the mouse to the location
    of the hiker. The path returned contains our current location, so we remove that
    from the path and then reset the `searchDelay` value.
  prefs: []
  type: TYPE_NORMAL
- en: In the `reaction()` method, we just move the `Mouse` object according to the
    path determined in the `sense()` method. First, we check to see whether `walkDelay`
    has become less than zero. We need this delay variable so that the mouse moves
    at a reasonable pace towards the hiker. Inside the `if` statement, we pop off
    the next location from the path to the hiker and then set `speedX` and `speedY`
    to values that will properly move the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The `Mouse` class actually has a straightforward implementation. The real heavy
    coding is done in the `TiledWorldPathfinding` class—the class that implements
    A* pathfinding.
  prefs: []
  type: TYPE_NORMAL
- en: The `TiledWorldPathfinding` class is not going to be a subclass of `Actor`.
    It is a non-graphical class that will be used solely to encapsulate the implementation
    of A* pathfinding. To create this class, click on **Edit** in Greenfoot's main
    menu bar and then select **New class…**. In the pop-up window, type `TiledWorldPathfinding`.
    You will see the new class appear below all of the `Actor` classes in Greenfoot's
    main scenario window. Later in this chapter, you will create the `Point` class
    and the `Tile` class in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The main method of this class is `findShortestFeasiblePath()`. The other methods
    in the class support this method, so let's first look at it. The method `findShortestFeasiblePath()`
    accepts two locations in the form of `Point`. The `Point` class is very simple.
    It simply records the row and column values of a location. The `findShortestFeasiblePath()`method
    starts by checking the simple case where the start and end locations are the same
    using the `equals()` method defined in the `Point` class. If so, we can return
    a path that just contains the starting node, and we are done. Next, we check that
    both the starting and end locations are walkable; if they are not, then we really
    can't run the algorithm as it ignores locations that are not walkable, so we return
    `null`. We then set the end node as our destination, add the start node to the
    open list (`openList`), and then run the A* algorithm. We will now look into the
    implementation of `runAStar()`.
  prefs: []
  type: TYPE_NORMAL
- en: Because we use good functional decomposition, the implementation of `runAStar()`
    is fairly concise. We remove a node from `openList`, process all of its valid
    neighbors, set the node to `done`, and add it to `closedList`. As we are processing
    the neighbors, we add new nodes to `openList`. If we encounter the end node, we
    set `done` to `true` and break out of the loop. This is a straightforward implementation
    of the A* pathfinding algorithm we discussed previously. To complete our discussion,
    we need to look at the implementation of `processNeighbor()`.
  prefs: []
  type: TYPE_NORMAL
- en: In `processNeighbor()`, we check for two things. If the node is not valid (we
    have already processed it or it is not walkable), we skip it. We then check whether
    the node is our target destination. If so, we set the node we just came from as
    the parent and return `true`. If not, we calculate `G`, `H`, and `F`, set the
    parent node, and then add this node to `openList`.
  prefs: []
  type: TYPE_NORMAL
- en: After `runAStar()` completes, we return to the `findShortestFeasiblePath()`
    method. We now have either found a path to the target location or have determined
    that there is no feasible path. If we have found a valid path, we construct a
    list of points stored in `Stack` (see the information box after the following
    two paragraphs) using `deriveWaypoints()`, reset the state of this class so that
    we can be called again, and return the answer to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: The `deriveWaypoints()` method is small. It derives the path from the `tiledWorld`
    matrix by following the parent pointers from the destination back to the start.
    Along the way, it pushes each node onto a stack. This is why we set parent references
    in `processNeighbor()`.
  prefs: []
  type: TYPE_NORMAL
- en: The last method we discuss in this class is `resetWorld()`. It has the responsibility
    of initializing the `tiledWorld` matrix and making sure it accurately represents
    the current state of the game (where obstacles are and where the destination is).
    We run the A* pathfinding algorithm on `tiledWorld` and not the actual screen
    of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Stacks and priority queues**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In programming, you will use many different types of data structures to store
    your data. We have already used arrays and lists (The List class was first used
    in [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision Detection*).
    Sometimes, we want the ordering to occur in a certain way when storing data, as
    lists and arrays are unordered. In the implementation of A* pathfinding, we use
    two new data structures: a stack and a priority queue. A stack stores data in
    the **Last-in First-out** (**LIFO**) order, while a priority queue stores data
    in sorted order. To learn more about these two data structures, refer to the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html](http://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html](http://docs.oracle.com/javase/7/docs/api/java/util/Stack.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.oopweb.com/Java/Documents/ThinkCSJav/Volume/chap16.htm](http://www.oopweb.com/Java/Documents/ThinkCSJav/Volume/chap16.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[http://www.tutorialspoint.com/java/java_stack_class.htm](http://www.tutorialspoint.com/java/java_stack_class.htm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have two classes that we used to support the running of the A* pathfinding
    algorithm: `Tile` and `Point`. Let''s first discuss the `Tile` class. This class
    is used to represent an area of the screen and is stored in the `tiledWorld` matrix.
    As we progress through the pathfinding algorithm, we need to track information
    about each area. For example, we need to store the `G`, `H`, and `F` values for
    that area; note whether it is the destination node and whether it is walkable
    and record parent information. The class is set up to store that information and
    allow easy access to it. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Comparable interface**'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](part0024.xhtml "Chapter 3. Collision Detection"), *Collision
    Detection*, we already discussed Java interfaces in general. The `Comparable`
    interface is an interface that requires the implementing class to provide a `compareTo()`
    method. This method will then be used in classes such as `PriorityQueue` to help
    determine ordering within the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned earlier, the `Point` class gives us a convenient way to refer
    to locations in `tiledWorld`. It concisely tracks the row and column position
    and also provides an easy way to compare points (see whether they are equal).
    Here is the code to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have now fully implemented the `Mouse` class. That was quite a bit of coding!
    But now, we have an actor that can effectively chase our hiker. Compile the scenario
    and fix any typos you made along the way. We now have a very interesting scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Play test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have spent a long time on this scenario. Time to play!
  prefs: []
  type: TYPE_NORMAL
- en: Uncomment all of the actors in the `prepare()` method, compile the scenario,
    and then try it out. Can you reach the gold square? Which enemy is hardest to
    avoid?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We really covered a lot of ground in this chapter. As we saw, adding intelligent
    behavior to an actor can range from very simple to very complex. Quite often,
    using randomness or heuristics, or a combination of both can create some very
    challenging enemies and will suffice for many of the games/simulations you create.
    However, there is no substitute for an enemy that knows how to track you down
    through the A* pathfinding algorithm. I hope you find new and creative ways to
    bring challenge, intrigue, and surprise into the behavior of your actors.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in the book, we have really covered a lot of topics to help you
    create an interesting and engaging interactive application. Next, we will look
    at creating user interfaces to accept more information from our user and to provide
    them with more feedback.
  prefs: []
  type: TYPE_NORMAL
