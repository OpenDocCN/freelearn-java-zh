<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Pattern Matching</h1>
                </header>
            
            <article>
                
<p>As a Java programmer, imagine having the option of skipping usage of the <kbd>instanceof</kbd> operator and explicit casting operators to retrieve a value from your objects. Pattern matching (<strong>JDK Enhancement Proposals</strong> (<strong>JEP</strong>) 305) addresses this pain point by a<span>dding type test patterns and constant patterns. </span>It enhances the Java programming language to introduce functionality that enables you to determine the type of instances and derived classes, and access their members without using explicit casting.</p>
<p>In this chapter, we'll cover the following topics:</p>
<ul>
<li>Pattern matching</li>
<li>Type test patterns</li>
<li>Constant patterns</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The code in this chapter uses the features defined in pattern matching (JEP 305) that haven't been targeted for any JDK release version yet. To experiment with the code, you can clone the relevant repository.</p>
<p>All code in this chapter can be accessed at <a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features">https://github.com/PacktPublishing/Java-11-and-12-New-Features</a><a href="https://github.com/PacktPublishing/Java-11-and-12-New-Features"><span class="MsoHyperlink">.</span></a></p>
<p>Let's cover the issues with using <kbd>instanceof</kbd> and explicit type-casting operators.</p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Pattern matching</h1>
                </header>
            
            <article>
                
<p>Pattern matching will enhance the Java programming language. To start with, it will add type test patterns and constant patterns that<em> </em>will be supported by the <kbd>switch</kbd> statement and the <kbd>matches</kbd> expression. Later, this JEP might extend the supported patterns and language construct.</p>
<p>Pattern matching is an age-old technique (approximately 65 years old) that has been adapted and is used by various languages such as text-oriented, functional (Haskell), and object-oriented languages (Scala, C#).</p>
<p>A pattern is a combination of the following:</p>
<ul>
<li>A predicate</li>
<li>A target</li>
<li>A set of binding variables</li>
</ul>
<p>When a predicate is successfully applied to a target, a set of binding variables are extracted from the target. The patterns covered in this chapter are type test patterns and constant patterns. </p>
<p>Before working with the examples in detail, let's understand what the existing issues are and why we need pattern matching.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Existing issues with type testing</h1>
                </header>
            
            <article>
                
<p>As a Java developer, you should have worked with code such as the one highlighted in bold in the following block:</p>
<pre>Object obj = new Ocean();                         // variable type - Object <br/>if (<strong>obj instanceof Ocean</strong>) {                         // check instance type 
    System.out.println(((Ocean)obj).getBottles());  // cast &amp; extract value 
} 
// A basic class - Ocean  
class Ocean { 
   private long bottles; 
   public long getBottles() { 
         return bottles; 
   } 
}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p class="mce-root"/>
<p>The preceding code includes three steps to use the value of the <kbd>bottles</kbd> variable:</p>
<ol>
<li><kbd>obj instanceof Ocean</kbd>: Testing of the type of the <kbd>obj</kbd> <span>variable </span></li>
<li><kbd>(Ocean)obj</kbd>: Casting of the reference variable, <kbd>obj</kbd>, to <kbd>Ocean</kbd></li>
<li><kbd>((Ocean)obj).getBottles()</kbd>: Destruction of the instance to get a value</li>
</ol>
<p>As developers, we have been writing similar code for a long time, but have also been hating it secretly. It is like repeating the same instructions again and again. These steps to test, cast, and deconstruct an instance to extract a value are unnecessarily verbose. We all know that code repetition is one of the best ways for errors to go unnoticed. To add to this, it only gets bigger with multiple instances of code repetition in one place. Take the following code sample as an example:</p>
<pre>void dyingFish(Object obj) { 
    if (obj instanceof Ocean) {                          // test 
        System.out.println(((Ocean)obj).getBottles());   // cast &amp; <br/>                                                         // destruct 
    } 
    else if (obj instanceof Sea) {                       // test 
        System.out.println(((Sea)obj).getDeadFish()); 
    } 
    else if (obj instanceof River) {                     // test 
        if ( ((Ocean)obj).getPlasticBags() &gt; 100) {      // cast &amp; <br/>                                                        // destruct 
            System.out.println("Say no to plastic bags. Fish are dying!"); 
        } 
    } 
} 
class Ocean { .. } 
class Sea { .. } 
class River { .. } </pre>
<p>As you add more occurrences of the testing-casting-instance destruction pattern to retrieve the field values, you lose the business logic in the complexity that is induced by the language. It is very common for developers to literally copy and paste such code and modify the pieces that aren't the same—but it is also common for some code parts to be left unchanged (which either become logic errors or should be labeled as copy and paste errors).</p>
<p>This code is also less optimizable; it will have <em>O(n)</em> time complexity, even though the underlying problem is often <em>O(1)</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Type test patterns</h1>
                </header>
            
            <article>
                
<p>To get around the issues created by the testing-casting-instance destruction pattern, Java proposes to embrace pattern matching.</p>
<p>Here's an example of the proposed changes to the language:</p>
<pre>Object obj = new Ocean();                         // variable type - Object 
if (obj <strong>matches</strong> Ocean o) {                        // check &amp; bind  
    System.out.println(o.getBottles());           // extract  
} </pre>
<p>The preceding code introduces a new Java keyword, <kbd>matches</kbd>, which includes a <strong>predicate </strong>(<kbd>obj</kbd>) and a <strong>target</strong> (<kbd>Ocean o</kbd>). The predicate, that is, <kbd>obj</kbd> is applied to the target, that is, <kbd>Ocean o</kbd>, which binds the <kbd>o</kbd> variable to the instance referred by <kbd>obj</kbd>. If the matching is successful, you can access members of the instance using the <kbd>bound</kbd> variable, that is, <kbd>o</kbd>. The following diagram compares the code changes of using <kbd>instanceof</kbd> and <kbd>matches</kbd>. As is evident, the <kbd>matches</kbd> operator takes off the ugly explicit casting from the code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/621278e7-de02-4d3e-86aa-84ea02e07b07.png"/></p>
<p>Let's see whether type matching eases our code with multiple occurrences:</p>
<pre>void dyingFish(Object obj) { 
    if (obj matches Ocean o) {                          // check &amp; bind 
        System.out.println(o.getBottles());             // extract 
    } 
    else if (obj matches Sea sea) {                       // test 
        System.out.println(sea.getDeadFish()); 
    } 
    else if (obj matches River riv) {                     // test 
        if (riv.getPlasticBags() &gt; 100) {      // cast &amp; destruct 
            System.out.println("Say no to plastic bags. Fish are <br/>            dying!"); 
        } 
    } 
} 
class Ocean { .. } 
class Sea { .. } 
class River { .. } </pre>
<p>The test pattern is not limited to the <kbd>if</kbd>-<kbd>else</kbd> statements. Let's see how it can be used with <kbd>switch</kbd> constructs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using pattern matching with switch constructs</h1>
                </header>
            
            <article>
                
<p>The <kbd>switch</kbd> statement seems to be one of the best constructs that can use pattern matching. At present, a <kbd>switch</kbd> construct can match primitive literal values (excluding <kbd>long</kbd>, <kbd>float</kbd>, and <kbd>double</kbd>), <kbd>String</kbd>, and enum constants.</p>
<p>If a <kbd>case</kbd> label can specify a pattern, the code in the preceding section (the one that uses multiple instances of object checking and value extraction) can be modified as follows:</p>
<pre>void dyingFish(Object obj) { 
    switch (obj) { 
        case Ocean o:   System.out.println(o.getBottles()); 
                        break; 
        case Sea sea:   System.out.println(sea.getDeadFish()); 
                        break; 
        case River riv: if (riv.getPlasticBags() &gt; 100) { 
                            System.out.println("Humans enjoy! Fish die!"); 
                        } 
                        break; 
    } 
} </pre>
<p>With pattern matching, the business logic takes the limelight. It also reduces the complexity of the syntax, which improves code readability. The preceding code is also optimizable because we are likely to dispatch in <em>O(1)</em> time.</p>
<div class="packt_infobox">Under pattern matching, work is also being done on the deconstruction pattern (which is the opposite of instance construction).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you covered how pattern matching would change your everyday code. Pattern matching introduces a new keyword, <kbd>matches</kbd>, to ease the checking, casting, and retrieval of values from instances.</p>
<p><span>This book took you through the latest Java versions—10, 11 and 12, and also Project Amber. </span>Java has a strong development road map and it continues to excite the developers and enterprises with its existing features and new capabilities. With a new six-month release cadence, Java is advancing at a fast pace that we haven't witnessed earlier. As developers, you get to work with newer Java features and improvements, sooner than ever before.</p>
<p>I encourage all developers to check out the improvements and additions to new Java versions, as they are released. Also, don't miss to browse through projects such as Valhalla, Loom, Panama, and many other projects at Oracle's website. These projects will advance Java's capabilities such as light-weight threading, simpler access to foreign libraries, and newer language candidates such as value types and generic specialization. Stay tuned!</p>


            </article>

            
        </section>
    </body></html>