["```java\nNetworkChannel bind(SocketAddress local) throws IOException \n```", "```java\nSocketAddress getLocalAddress() throws IOException \n```", "```java\n<T> T getOption(SocketOption<T> op_name) throws IOException\n<T> NetworkChannel setOption(SocketOption<T> op_name, T op_value) \n  throws IOException \n```", "```java\nSet<SocketOption<?>> supportedOptions() \n```", "```java\nServerSocketChannel serverSC = ServerSocketChannel.open(); \n```", "```java\nif (serverSC.isOpen()) {\n  ...\n} \n```", "```java\nserverSC.configureBlocking(true); \n```", "```java\nserverSC.setOption(StandardSocketOptions.SO_RCVBUF, 4 * 1024);\nserverSC.setOption(StandardSocketOptions.SO_REUSEADDR, true); \n```", "```java\nSet<SocketOption<?>> options = serverSC.supportedOptions();\nfor (SocketOption<?> option : options)  {\n  System.out.println(option);\n} \n```", "```java\nprivate static final int SERVER_PORT = 4444;\nprivate static final String SERVER_IP = \"127.0.0.1\";\n...\nserverSC.bind(new InetSocketAddress(SERVER_IP, SERVER_PORT)); \n```", "```java\nserverSC.bind(new InetSocketAddress(SERVER_PORT)); \n```", "```java\npublic abstract ServerSocketChannel bind(\n  SocketAddress local_addr,int pending_c) throws IOException \n```", "```java\nSocketChannel acceptSC = serverSC.accept(); \n```", "```java\nSystem.out.println(\"New connection: \" \n  + acceptSC.getRemoteAddress()); \n```", "```java\nByteBuffer tBuffer = ByteBuffer.allocateDirect(1024);\n...\nwhile (acceptSC.read(tBuffer) != -1) {\n  tBuffer.flip();\n  acceptSC.write(tBuffer);\n  if (tBuffer.hasRemaining()) {\n    tBuffer.compact();\n  } else {\n    tBuffer.clear();\n  }\n} \n```", "```java\n    public abstract int read(ByteBuffer dest_buffer) \n      throws IOException\n    public final long read(ByteBuffer[] dests_buffers) \n      throws IOException\n    public abstract long read(ByteBuffer[] dests_buffers, \n      int buffer_offset, int buffer_length) throws IOException \n    ```", "```java\n    public abstract int write(ByteBuffer source_buffer)\n     throws IOException\n    public final long write(ByteBuffer[] source_buffers)\n     throws IOException\n    public abstract long write(ByteBuffer[] source_buffers, \n      int buffer_offset, int buffer_length) throws IOException \n    ```", "```java\nInputStream in = acceptSC.socket().getInputStream();\nOutputStream out = acceptSC.socket().getOutputStream(); \n```", "```java\nBufferedReader in = new BufferedReader(\n  new InputStreamReader(acceptSC.getInputStream()));\nPrintWriter out = new PrintWriter(\n  acceptSC.getOutputStream(), true); \n```", "```java\n// connection will be shut down for reading\nacceptSC.shutdownInput();\n// connection will be shut down for writing\nacceptSC.shutdownOutput(); \n```", "```java\nboolean inputdown = acceptSC.socket().isInputShutdown();\nboolean outputdown = acceptSC.socket().isOutputShutdown(); \n```", "```java\nacceptSC.close(); // close a specific client\nserverSC.close(); // close the server itself \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final String SERVER_IP = \"127.0.0.1\";\n  public static void main(String[] args) {\n    ByteBuffer tBuffer = ByteBuffer.allocateDirect(1024);\n    // open a brand new server socket channel\n    try (ServerSocketChannel serverSC\n           = ServerSocketChannel.open()) {\n      // server socket channel was created\n      if (serverSC.isOpen()) {\n        // configure the blocking mode\n        serverSC.configureBlocking(true);\n        // optionally, configure the server side options\n        serverSC.setOption(\n          StandardSocketOptions.SO_RCVBUF, 4 * 1024);\n        serverSC.setOption(\n          StandardSocketOptions.SO_REUSEADDR, true);\n        // bind the server socket channel to local address\n        serverSC.bind(new InetSocketAddress(\n          SERVER_IP, SERVER_PORT));\n        // waiting for clients\n        System.out.println(\"Waiting for clients ...\");\n        // ready to accept incoming connections\n        while (true) {\n          try (SocketChannel acceptSC = serverSC.accept()) {\n            System.out.println(\"New connection: \" \n              + acceptSC.getRemoteAddress());\n            // sending data\n            while (acceptSC.read(tBuffer) != -1) {\n              tBuffer.flip();\n              acceptSC.write(tBuffer);\n              if (tBuffer.hasRemaining()) {\n                tBuffer.compact();\n              } else {\n                tBuffer.clear();\n              }\n            }\n          } catch (IOException ex) {\n            // handle exception\n          }\n        }\n      } else {\n        System.out.println(\n          \"Server socket channel unavailable!\");\n      }\n    } catch (IOException ex) {\n      System.err.println(ex);\n      // handle exception\n    }\n  }\n} \n```", "```java\nSocketChannel clientSC = SocketChannel.open(); \n```", "```java\nif (clientSC.isOpen()) {\n   ...\n} \n```", "```java\nclientSC.configureBlocking(true); \n```", "```java\nclientSC.setOption(\n  StandardSocketOptions.SO_RCVBUF, 131072); // 128 * 1024\nclientSC.setOption(\n  StandardSocketOptions.SO_SNDBUF, 131072); // 128 * 1024\nclientSC.setOption(\n  StandardSocketOptions.SO_KEEPALIVE, true);\nclientSC.setOption(\n  StandardSocketOptions.SO_LINGER, 5); \n```", "```java\nSet<SocketOption<?>> options = clientSC.supportedOptions();\nfor (SocketOption<?> option : options)  {\n  System.out.println(option);\n} \n```", "```java\nprivate final int SERVER_PORT = 4444;\nprivate final String SERVER_IP = \"127.0.0.1\";\n...\nclientSC.connect(\n  new InetSocketAddress(SERVER_IP, SERVER_PORT)); \n```", "```java\nif (clientSC.isConnected()) {\n  ...\n} \n```", "```java\nByteBuffer tBuffer = ByteBuffer.allocateDirect(1024);\nByteBuffer hBuffer = ByteBuffer.wrap(\"Hey !\".getBytes());\nByteBuffer rBuffer;\nCharBuffer cBuffer;\nCharset charset = Charset.defaultCharset();\nCharsetDecoder chdecoder = charset.newDecoder();\n...\nclientSC.write(hBuffer);\nwhile (clientSC.read(tBuffer) != -1) {\n  tBuffer.flip();\n  cBuffer = chdecoder.decode(tBuffer);\n  System.out.println(cBuffer.toString());\n  if (tBuffer.hasRemaining()) {\n    tBuffer.compact();\n  } else {\n    tBuffer.clear();\n  }\n  int r = new Random().nextInt(100);\n  if (r == 50) {\n    System.out.println(\n      \"Number 50 is here so the channel will be closed\");\n    break;\n  } else {\n    rBuffer = ByteBuffer.wrap(\n      \"Random number:\".concat(String.valueOf(r)).getBytes());\n    clientSC.write(rBuffer);\n  }\n} \n```", "```java\nclientSC.close(); \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final String SERVER_IP = \"127.0.0.1\";\n  public static void main(String[] args) {\n    ByteBuffer tBuffer = ByteBuffer.allocateDirect(1024);\n    ByteBuffer hBuffer = ByteBuffer.wrap(\"Hey !\".getBytes());\n    ByteBuffer rBuffer;\n    CharBuffer cBuffer;\n    Charset charset = Charset.defaultCharset();\n    CharsetDecoder chdecoder = charset.newDecoder();\n    // create a brand new client socket channel\n    try (SocketChannel clientSC = SocketChannel.open()) {\n      // client socket channel was created\n      if (clientSC.isOpen()) {\n        // configure the blocking mode\n        clientSC.configureBlocking(true);\n        // optionally, configure the client side options\n        clientSC.setOption(\n          StandardSocketOptions.SO_RCVBUF, 128 * 1024);\n        clientSC.setOption(\n          StandardSocketOptions.SO_SNDBUF, 128 * 1024);\n        clientSC.setOption(\n          StandardSocketOptions.SO_KEEPALIVE, true);\n        clientSC.setOption(\n          StandardSocketOptions.SO_LINGER, 5);\n        // connect this channel's socket to the proper address\n        clientSC.connect(\n          new InetSocketAddress(SERVER_IP, SERVER_PORT));\n        // check the connection availability\n          if (clientSC.isConnected()) {\n            // sending data\n            clientSC.write(hBuffer);\n            while (clientSC.read(tBuffer) != -1) {\n              tBuffer.flip();\n              cBuffer = chdecoder.decode(tBuffer);\n              System.out.println(cBuffer.toString());\n              if (tBuffer.hasRemaining()) {\n                tBuffer.compact();\n              } else {\n                tBuffer.clear();\n              }\n              int r = new Random().nextInt(100);\n              if (r == 50) {\n                System.out.println(\n                 \"Number 50 is here so the channel\n                  will be closed\");\n                break;\n              } else {\n                rBuffer = ByteBuffer.wrap(\n                  \"Random number:\".concat(\n                    String.valueOf(r)).getBytes());\n                clientSC.write(rBuffer);\n            }\n          }\n        } else {\n          System.out.println(\"Connection unavailable!\");\n        }\n      } else {\n        System.out.println(\n          \"Client socket channel unavailable!\");\n      }\n    } catch (IOException ex) {\n      System.err.println(ex);\n      // handle exception\n    }\n  }\n} \n```", "```java\nHey !\nRandom number:17\nRandom number:31\nRandom number:53\nâ€¦\nRandom number:7\nNumber 50 is here so the channel will be closed \n```", "```java\npublic final SelectionKeyregister(\n  Selector s, int p, Object a) throws ClosedChannelException \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private final Map<SocketChannel, List<byte[]>>\n    registerTrack = new HashMap<>();\n  private final ByteBuffer tBuffer\n    = ByteBuffer.allocate(2 * 1024);\n  private void startEchoServer() { \n    // call the open() method for Selector/ServerSocketChannel\n    try (Selector selector = Selector.open();\n      ServerSocketChannel serverSC\n        = ServerSocketChannel.open()) {\n      // ServerSocketChannel and Selector successfully opened\n      if ((serverSC.isOpen()) && (selector.isOpen())) {\n        // configure non-blocking mode\n        serverSC.configureBlocking(false);\n        // optionally, configure the client side options\n        serverSC.setOption(\n          StandardSocketOptions.SO_RCVBUF, 256 * 1024);\n        serverSC.setOption(\n          StandardSocketOptions.SO_REUSEADDR, true);\n        // bind the server socket channel to the port\n        serverSC.bind(new InetSocketAddress(SERVER_PORT));\n        // register this channel with the selector\n        serverSC.register(selector, SelectionKey.OP_ACCEPT);\n        // waiting for clients\n        System.out.println(\"Waiting for clients ...\");\n        ... \n```", "```java\n while (true) {\n          // waiting for events\n          selector.select();\n          // the selected keys have something to be processed\n          Iterator itkeys =selector.selectedKeys().iterator();\n          while (itkeys.hasNext()) {\n            SelectionKey selkey\n              = (SelectionKey) itkeys.next();\n             // avoid processing the same key twice\n            itkeys.remove();\n            if (!selkey.isValid()) {\n              continue;\n            }\n            if (selkey.isAcceptable()) {\n              acceptOperation(selkey, selector);\n            } else if (selkey.isReadable()) {\n              this.readOperation(selkey);\n            } else if (selkey.isWritable()) {\n              this.writeOperation(selkey);\n            }\n          }\n        }\n      } else {\n        System.out.println(\n          \"Cannot open the selector/channel\");\n      }\n    } catch (IOException ex) {\n      System.err.println(ex);\n      // handle exception\n    }\n  }\n... \n```", "```java\n // isAcceptable = true\n  private void acceptOperation(SelectionKey selkey, \n        Selector selector) throws IOException {\n    ServerSocketChannel serverSC\n      = (ServerSocketChannel) selkey.channel();\n    SocketChannel acceptSC = serverSC.accept();\n    acceptSC.configureBlocking(false);\n    System.out.println(\"New connection: \" \n      + acceptSC.getRemoteAddress());\n    // send an welcome message\n    acceptSC.write(ByteBuffer.wrap(\n      \"Hey !\\n\".getBytes(\"UTF-8\")));\n    // register the channel with selector to support more I/O\n    registerTrack.put(acceptSC, new ArrayList<>());\n    acceptSC.register(selector, SelectionKey.OP_READ);\n  }\n  ... \n```", "```java\n// isReadable = true\n  private void readOperation(SelectionKey selkey) {\n    try {\n      SocketChannel socketC\n        = (SocketChannel) selkey.channel();\n      tBuffer.clear();\n      int byteRead = -1;\n      try {\n        byteRead = socketC.read(tBuffer);\n      } catch (IOException e) {\n        System.err.println(\"Read error!\");\n        // handle exception\n      }\n      if (byteRead == -1) {\n        this.registerTrack.remove(socketC);\n        System.out.println(\"Connection was closed by: \" \n          + socketC.getRemoteAddress());\n        socketC.close();\n        selkey.cancel();\n        return;\n      }\n      byte[] byteData = new byte[byteRead];\n      System.arraycopy(\n        tBuffer.array(), 0, byteData, 0, byteRead);\n      System.out.println(new String(byteData, \"UTF-8\") \n        + \" from \" + socketC.getRemoteAddress());\n      // send the bytes back to client\n      doEchoTask(selkey, byteData);\n    } catch (IOException ex) {\n      System.err.println(ex);\n      // handle exception\n    }\n  }\n  // isWritable = true\n  private void writeOperation(SelectionKey selkey) \n        throws IOException {\n    SocketChannel socketC = (SocketChannel) selkey.channel();\n    List<byte[]> channelByteData = registerTrack.get(socketC);\n    Iterator<byte[]> iter = channelByteData.iterator();\n    while (iter.hasNext()) {\n      byte[] itb = iter.next();\n      iter.remove();\n      socketC.write(ByteBuffer.wrap(itb));\n    }\n    selkey.interestOps(SelectionKey.OP_READ);\n  }\n  private void doEchoTask(\n        SelectionKey selkey, byte[] dataByte) {\n    SocketChannel socketC = (SocketChannel) selkey.channel();\n    List<byte[]> channelByteData = registerTrack.get(socketC);\n    channelByteData.add(dataByte);\n    selkey.interestOps(SelectionKey.OP_WRITE);\n  }\n  ... \n```", "```java\n public static void main(String[] args) {\n    Main main = new Main();\n    main.startEchoServer();\n  }\n} \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final String SERVER_IP = \"127.0.0.1\";\n  private static final int TIMEOUT_SELECTOR = 1_000;\n  public static void main(String[] args) \n        throws InterruptedException { \n    ByteBuffer tBuffer = ByteBuffer.allocateDirect(2 * 1024);\n    ByteBuffer rBuffer;\n    CharBuffer cBuffer;\n    Charset charset = Charset.defaultCharset();\n    CharsetDecoder chdecoder = charset.newDecoder();\n    // call the open() for ServerSocketChannel and Selector\n    try (Selector selector = Selector.open();\n      SocketChannel clientSC = SocketChannel.open()) {\n      // ServerSocketChannel and Selector successfully opened\n      if ((clientSC.isOpen()) && (selector.isOpen())) {\n        // configure non-blocking mode\n        clientSC.configureBlocking(false);\n        // optionally, configure the client side options\n        clientSC.setOption(\n          StandardSocketOptions.SO_RCVBUF, 128 * 1024);\n        clientSC.setOption(\n          StandardSocketOptions.SO_SNDBUF, 128 * 1024);\n        clientSC.setOption(\n          StandardSocketOptions.SO_KEEPALIVE, true);\n        // register this channel with the selector\n        clientSC.register(selector, SelectionKey.OP_CONNECT);\n        // connecting to the remote host\n        clientSC.connect(new java.net.InetSocketAddress(\n          SERVER_IP, SERVER_PORT));\n        System.out.println(\"Local host: \" \n          + clientSC.getLocalAddress());\n        ... \n```", "```java\n // waiting for the connection\n        while (selector.select(TIMEOUT_SELECTOR) > 0) {\n          // get the keys\n          Set selkeys = selector.selectedKeys();\n          Iterator iter = selkeys.iterator();\n          // traverse and process the keys\n          while (iter.hasNext()) {\n            SelectionKey selkey = (SelectionKey) iter.next();\n            // remove the current key\n            iter.remove();\n            // get the key's socket channel\n            try (SocketChannel keySC\n                  = (SocketChannel) selkey.channel()) {\n              // attempt a connection\n              if (selkey.isConnectable()) {\n                // connection successfully achieved\n                System.out.println(\n                  \"Connection successfully achieved!\");\n                // pending connections will be closed\n                if (keySC.isConnectionPending()) {\n                  keySC.finishConnect();\n                }\n                ... \n```", "```java\n // read/write from/to server \n                while (keySC.read(tBuffer) != -1) {\n                  tBuffer.flip();\n                  cBuffer = chdecoder.decode(tBuffer);\n                  System.out.println(cBuffer.toString());\n                  if (tBuffer.hasRemaining()) {\n                    tBuffer.compact();\n                  } else {\n                    tBuffer.clear();\n                  }\n                  int r = new Random().nextInt(100);\n                  if (r == 50) {\n                    System.out.println(\n                      \"Number 50 is here so \n                       the channel will be closed\");\n                    break;\n                  } else {\n                    rBuffer = ByteBuffer.wrap(\n                      \"Random number:\".concat(\n                        String.valueOf(r).concat(\" \"))\n                        .getBytes(\"UTF-8\"));\n                    keySC.write(rBuffer);\n                  }\n                }\n              }\n            } catch (IOException ex) {\n              System.err.println(ex);\n              // handle exception\n            }\n          }\n        }\n      } else {\n        System.out.println(\n          \"Cannot open the selector/channel\");\n      }\n    } catch (IOException ex) {\n      System.err.println(ex);\n      // handle exception\n    }\n  }\n} \n```", "```java\nDatagramChannel dchannel\n  = DatagramChannel.open(StandardProtocolFamily.INET); \n```", "```java\nif (dchannel.isOpen()) {\n  ...\n} \n```", "```java\ndchannel.setOption(StandardSocketOptions.SO_RCVBUF, 4 * 1024);\ndchannel.setOption(StandardSocketOptions.SO_SNDBUF, 4 * 1024); \n```", "```java\nSet<SocketOption<?>> options = dchannel.supportedOptions();\nfor(SocketOption<?> option : options) {\n  System.out.println(option);\n} \n```", "```java\nprivate static final int SERVER_PORT = 4444;\nprivate static final String SERVER_IP = \"127.0.0.1\";\n...\ndchannel.bind(new InetSocketAddress(SERVER_IP, SERVER_PORT));\n// or, if you prefer the wildcard address\ndchannel.bind(new InetSocketAddress(SERVER_PORT)); \n```", "```java\nprivate static final int MAX_SIZE_OF_PACKET = 65507;\n...\nByteBuffer echoBuffer\n  = ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);\n...\nwhile (true) {\n  SocketAddress clientSocketAddress\n    = dchannel.receive(echoBuffer);\n  echoBuffer.flip();\n  System.out.println(\"Received \" + echoBuffer.limit()\n    + \" bytes from \" + clientSocketAddress.toString() \n    + \"! Echo ...\");\n  dchannel.send(echoBuffer, clientSocketAddress);\n  echoBuffer.clear();\n} \n```", "```java\ndchannel.close(); \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final String SERVER_IP = \"127.0.0.1\";\n  private static final int MAX_SIZE_OF_PACKET = 65507;\n  public static void main(String[] args) {\n    ByteBuffer echoBuffer\n      = ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);\n    // create a datagram channel\n    try (DatagramChannel dchannel\n      = DatagramChannel.open(StandardProtocolFamily.INET)) {\n      // if the channel was successfully opened\n      if (dchannel.isOpen()) {\n        System.out.println(\"The echo server is ready!\");\n        // optionally, configure the server side options\n        dchannel.setOption(\n          StandardSocketOptions.SO_RCVBUF, 4 * 1024);\n        dchannel.setOption(\n          StandardSocketOptions.SO_SNDBUF, 4 * 1024);\n        // bind the channel to local address\n        dchannel.bind(new InetSocketAddress(\n          SERVER_IP, SERVER_PORT));\n        System.out.println(\"Echo server available at: \" \n          + dchannel.getLocalAddress());\n        System.out.println(\"Ready to echo ...\");\n        // sending data packets\n        while (true) {\n          SocketAddress clientSocketAddress\n            = dchannel.receive(echoBuffer);\n          echoBuffer.flip();\n          System.out.println(\"Received \" + echoBuffer.limit()\n            + \" bytes from \" + clientSocketAddress.toString() \n            + \"! Echo ...\");\n          dchannel.send(echoBuffer, clientSocketAddress);\n          echoBuffer.clear();\n        }\n      } else {\n        System.out.println(\"The channel is unavailable!\");\n      }\n    } catch (SecurityException | IOException ex) {\n      System.err.println(ex);\n      // handle exception\n  }\n  }\n} \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final String SERVER_IP = \"127.0.0.1\";\n  private static final int MAX_SIZE_OF_PACKET = 65507;\n  public static void main(String[] args) \n        throws InterruptedException {\n    CharBuffer cBuffer;\n    Charset charset = Charset.defaultCharset();\n    CharsetDecoder chdecoder = charset.newDecoder();\n    ByteBuffer bufferToEcho = ByteBuffer.wrap(\n      \"Echo: I'm a great server!\".getBytes());\n    ByteBuffer echoedBuffer\n      = ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);\n    // create a datagram channel\n    try (DatagramChannel dchannel\n      = DatagramChannel.open(StandardProtocolFamily.INET)) {\n      // if the channel was successfully opened\n      if (dchannel.isOpen()) {\n        // optionally, configure the client side options\n        dchannel.setOption(\n          StandardSocketOptions.SO_RCVBUF, 4 * 1024);\n        dchannel.setOption(\n          StandardSocketOptions.SO_SNDBUF, 4 * 1024);\n        // sending data packets\n        int sentBytes = dchannel.send(bufferToEcho, \n          new InetSocketAddress(SERVER_IP, SERVER_PORT));\n        System.out.println(\"Sent \" + sentBytes\n          + \" bytes to the server\");\n        dchannel.receive(echoedBuffer);\n        // hack to wait for the server to echo\n        Thread.sleep(5000);\n        echoedBuffer.flip();\n        cBuffer = chdecoder.decode(echoedBuffer);\n        System.out.println(cBuffer.toString());\n        echoedBuffer.clear();\n      } else {\n        System.out.println(\"Cannot open the channel\");\n      }\n    } catch (SecurityException | IOException ex) { \n      System.err.println(ex);\n      // handle exception\n    }\n  }\n} \n```", "```java\nThe echo server is ready!\nEcho server available at: /127.0.0.1:4444\nReady to echo ... \n```", "```java\nSent 25 bytes to the server \n```", "```java\nReceived 25 bytes from /127.0.0.1:59111! Echo ... \n```", "```java\nEcho: I'm a great server! \n```", "```java\nprivate static final int SERVER_PORT = 4444;\nprivate static final String SERVER_IP = \"127.0.0.1\";\n...\ndchannel.connect(new InetSocketAddress(\n  SERVER_IP, SERVER_PORT)); \n```", "```java\nif (dchannel.isConnected()) {\n  ...\n} \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final String SERVER_IP = \"127.0.0.1\";\n  private static final int MAX_SIZE_OF_PACKET = 65507;\n  public static void main(String[] args) {\n    CharBuffer cBuffer;\n    Charset charset = Charset.defaultCharset();\n    CharsetDecoder chdecoder = charset.newDecoder();\n    ByteBuffer bufferToEcho = ByteBuffer.wrap(\n      \"Echo: I'm a great server!\".getBytes());\n    ByteBuffer echoedBuffer\n      = ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);\n    // create a datagram channel\n    try (DatagramChannel dchannel\n        = DatagramChannel.open(StandardProtocolFamily.INET)) {\n      // optionally, configure the client side options\n      dchannel.setOption(\n        StandardSocketOptions.SO_RCVBUF, 4 * 1024);\n      dchannel.setOption(\n        StandardSocketOptions.SO_SNDBUF, 4 * 1024);\n      // if the channel was successfully opened\n      if (dchannel.isOpen()) {\n        // connect to server (remote address)\n        dchannel.connect(new InetSocketAddress(\n          SERVER_IP, SERVER_PORT));\n        // if the channel was successfully connected\n        if (dchannel.isConnected()) {\n          // sending data packets\n          int sentBytes = dchannel.write(bufferToEcho);\n          System.out.println(\"Sent \" + sentBytes\n            + \" bytes to the server\");\n          dchannel.read(echoedBuffer);\n          echoedBuffer.flip();\n          cBuffer = chdecoder.decode(echoedBuffer);\n          System.out.println(cBuffer.toString());\n          echoedBuffer.clear();\n        } else {\n          System.out.println(\"Cannot connect the channel\");\n        }\n      } else {\n        System.out.println(\"Cannot open the channel\");\n      }\n    } catch (SecurityException | IOException ex) { \n      System.err.println(ex);\n      // handle exception\n    }\n  }\n} \n```", "```java\nMembershipKey join(InetAddress g, NetworkInterface i) \n  throws IOException\nMembershipKey join(InetAddress g, NetworkInterface i, \n  InetAddress s) throws IOException \n```", "```java\npublic class Main {\n  public static void main(String[] args) \n         throws SocketException {\n    Enumeration allNetworkInterfaces\n      = NetworkInterface.getNetworkInterfaces();\n    while (allNetworkInterfaces.hasMoreElements()) {\n      NetworkInterface ni = (NetworkInterface) \n        allNetworkInterfaces.nextElement();\n      System.out.println(\"\\nDisplay Name: \" \n        + ni.getDisplayName());\n      System.out.println(ni.getDisplayName() \n        + \" is up and running ? \" + ni.isUp());\n      System.out.println(ni.getDisplayName() \n        + \" is multicast capable ? \" \n        + ni.supportsMulticast());\n      System.out.println(ni.getDisplayName() + \" name: \"  \n        + ni.getName());\n      System.out.println(ni.getDisplayName() \n        + \" is virtual ? \" + ni.isVirtual());\n      Enumeration ips = ni.getInetAddresses();\n      if (!ips.hasMoreElements()) {\n        System.out.println(\"IP addresses: none\");\n      } else {\n        System.out.println(\"IP addresses:\");\n        while (ips.hasMoreElements()) {\n          InetAddress ip = (InetAddress) ips.nextElement();\n          System.out.println(\"IP: \" + ip);\n        }\n      }\n    }\n  }\n} \n```", "```java\nprivate static final String \n  MULTICAST_NI_NAME = \"ethernet_32775\";\n...\nNetworkInterface mni\n  = NetworkInterface.getByName(MULTICAST_NI_NAME);\ndchannel.setOption(\n  StandardSocketOptions.IP_MULTICAST_IF, mni);\ndchannel.setOption(\n  StandardSocketOptions.SO_REUSEADDR, true);\n... \n```", "```java\nprivate static final int SERVER_PORT = 4444;\n...\ndchannel.bind(new InetSocketAddress(SERVER_PORT)); \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final String MULTICAST_GROUP = \"225.4.5.6\";\n  private static final String MULTICAST_NI_NAME \n    = \"ethernet_32775\";\n  public static void main(String[] args) {\n    ByteBufferd tBuffer;\n    // create a channel\n    try (DatagramChannel dchannel\n      = DatagramChannel.open(StandardProtocolFamily.INET)) {\n      // if the channel was successfully opened\n      if (dchannel.isOpen()) {\n        // get the multicast network interface\n        NetworkInterface mni\n          = NetworkInterface.getByName(MULTICAST_NI_NAME);\n        // optionally, configure the server side options\n        dchannel.setOption(\n          StandardSocketOptions.IP_MULTICAST_IF, mni);\n        dchannel.setOption(\n          StandardSocketOptions.SO_REUSEADDR, true);\n        // bind the channel to local address\n        dchannel.bind(new InetSocketAddress(SERVER_PORT));\n        System.out.println(\n          \"Server is ready...sending date-time info soon...\");\n        // sending datagrams\n        while (true) {\n          // sleep for 10000 ms (10 seconds)\n          try {\n            Thread.sleep(10000);\n          } catch (InterruptedException ex) {}\n          System.out.println(\"Sending date-time ...\");\n          dtBuffer = ByteBuffer.wrap(\n            new Date().toString().getBytes());\n          dchannel.send(dtBuffer, new InetSocketAddress(\n            InetAddress.getByName(MULTICAST_GROUP), \n              SERVER_PORT));\n            dtBuffer.flip();\n          }\n      } else {\n        System.out.println(\"The channel is unavailable!\");\n      }\n    } catch (IOException ex) {\n      System.err.println(ex);\n    }\n  }\n} \n```", "```java\npublic class Main {\n  private static final int SERVER_PORT = 4444;\n  private static final int MAX_SIZE_OF_PACKET = 65507;\n  private static final String MULTICAST_GROUP = \"225.4.5.6\";\n  private static final String MULTICAST_NI_NAME \n    = \"ethernet_32775\";\n  public static void main(String[] args) {\n    CharBuffer cBuffer;\n    Charset charset = Charset.defaultCharset();\n    CharsetDecoder chdecoder = charset.newDecoder();\n    ByteBuffer dtBuffer\n      = ByteBuffer.allocateDirect(MAX_SIZE_OF_PACKET);\n    // create a channel\n    try (DatagramChannel dchannel\n      = DatagramChannel.open(StandardProtocolFamily.INET)) {\n      InetAddress multigroup \n        = InetAddress.getByName(MULTICAST_GROUP);\n      // if the group address is multicast\n      if (multigroup.isMulticastAddress()) {\n        // if the channel was successfully open\n        if (dchannel.isOpen()) {\n          // get the multicast network interface\n          NetworkInterface mni\n            = NetworkInterface.getByName(MULTICAST_NI_NAME);\n          // optionally, configure the client side options\n          dchannel.setOption(\n            StandardSocketOptions.SO_REUSEADDR, true);\n          // bind the channel to remote address \n          dchannel.bind(new InetSocketAddress(SERVER_PORT));\n          // join the multicast group and receive datagrams\n          MembershipKeymemkey = dchannel.join(\n            multigroup, mni);\n          // wait to receive datagrams\n          while (true) {\n            if (memkey.isValid()) {\n              dchannel.receive(dtBuffer);\n              dtBuffer.flip();\n              cBuffer = chdecoder.decode(dtBuffer);\n              System.out.println(cBuffer.toString());\n              dtBuffer.clear();\n            } else {\n                break;\n            }\n          }\n        } else {\n          System.out.println(\"The channel is unavailable!\");\n        }\n      } else {\n        System.out.println(\"Not a multicast address!\");\n      }\n    } catch (IOException ex) {\n        System.err.println(ex);\n      // handle exception\n    } \n  }\n} \n```", "```java\nList<InetAddress> dislike = ...;\nDatagramChannel datagramChannel = ...;\nMembershipKey memkey = datagramChannel\n  .join(group, network_interface);\nif(!dislike.isEmpty()){\n  for(InetAddress source : dislike){\n    memkey.block(source);\n  }\n} \n```", "```java\nList<InetAddress> like = ...;\nDatagramChannel dchannel = ...;\nif (!like.isEmpty()){\n  for (InetAddress source : like){\n    dchannel.join(group, network_interface, source); \n  }\n} \n```", "```java\nServer is ready ... sending date-time info soon ... \n```", "```java\nServer is ready ... sending date-time info soon ...\nSending date-time ...\nSending date-time ...\nSending date-time ... \n```", "```java\nFri Aug 25 08:17:30 EEST 2023\nFri Aug 25 08:17:40 EEST 2023\nFri Aug 25 08:17:50 EEST 2023 \n```", "```java\nprivate static PublicKey publicKey;\nprivate static PrivateKey privateKey;\n...\nstatic {\n  try {\n    KeyPairGenerator kpg\n      = KeyPairGenerator.getInstance(\"X25519\");\n    KeyPair kp = kpg.generateKeyPair();\n    publicKey = kp.getPublic();\n    privateKey = kp.getPrivate();\n  } catch (NoSuchAlgorithmException ex) {...}\n} \n```", "```java\ntry (SocketChannel socketChannel = SocketChannel.open()) {\n  ...\n  socketChannel.write(\n    ByteBuffer.wrap(publicKey.getEncoded()));\n  ...\n} \n```", "```java\nKeyFactory kf = KeyFactory.getInstance(\"X25519\");\nPublicKey publicKeyReceiver = kf.generatePublic(\n  new X509EncodedKeySpec(buffer.array())); \n```", "```java\nKEM kemSender = KEM.getInstance(\"DHKEM\"); \n```", "```java\nprivate static SecretKey secretKeySender;\n...\nKEM.Encapsulator encorSender\n  = kemSender.newEncapsulator(publicKeyReceiver);\nKEM.Encapsulate dencedSender = encorSender.encapsulate(\n  0, encorSender.secretSize(), \"AES\");\nsecretKeySender = encedSender.key(); \n```", "```java\nsocketChannel.write(ByteBuffer.wrap(\n  encedSender.encapsulation())); \n```", "```java\nprivate static SecretKey secretKeyReceiver;\n...\nKEM kemReceiver = KEM.getInstance(\"DHKEM\");\nKEM.Decapsulator decReceiver\n  = kemReceiver.newDecapsulator(privateKey);\nsecretKeyReceiver = decReceiver.decapsulate(\n    buffer.array(), 0, decReceiver.secretSize(), \"AES\"); \n```", "```java\nCipher cipher = Cipher.getInstance(\"...\");\ncipher.init(Cipher.ENCRYPT_MODE/DECRYPT_MODE, \n  secretKeyReceiver/secretKeySender);\nsocketChannel.write(ByteBuffer.wrap(\n  cipher.doFinal(\"some message\".getBytes()))); \n```", "```java\nCipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\ncipher.init(Cipher.ENCRYPT_MODE, secretKeyReceiver);\nsocketChannel.write(ByteBuffer.wrap(\n  cipher.doFinal(\"My token is: 763\".getBytes()))); \n```", "```java\n// decrypt the token\nCipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\ncipher.init(Cipher.DECRYPT_MODE, secretKeySender);\nString decMessage = new String(\n  cipher.doFinal(message), Charset.defaultCharset());\n// generating the password based on token\n// encrypt the password and send it\ncipher.init(Cipher.ENCRYPT_MODE, secretKeySender);\nsocketChannel.write(ByteBuffer.wrap(cipher.doFinal(\n  \"The generated password is: O98S!\".getBytes()))); \n```", "```java\njwebserver -b 172.27.128.1 -p 9009 \n```", "```java\nHttpServer sws = SimpleFileServer.createFileServer(\n  new InetSocketAddress(9009),\n  Path.of(\"./docs\").toAbsolutePath(),\n  OutputLevel.VERBOSE);\nsws.start(); \n```", "```java\nHttpHandler fileHandler = SimpleFileServer.createFileHandler(\n  Path.of(\"./docs\").toAbsolutePath()); \n```", "```java\nHttpServer sws = HttpServer.create(\n  new InetSocketAddress(9009), 10, \"/mybooks\", fileHandler); \nsws.start(); \n```", "```java\nprivate static final Path ROOT_DIRECTORY_PATH = \n  Path.of(\"./docs\").toAbsolutePath();\n...\nHttpHandler fileHandler\n  = SimpleFileServer.createFileHandler(ROOT_DIRECTORY_PATH);\nHttpServer sws = SimpleFileServer.createFileServer(\n  new InetSocketAddress(9009),\n  ROOT_DIRECTORY_PATH,\n  OutputLevel.VERBOSE);\nsws.createContext(\"/mybooks\").setHandler(fileHandler);\nsws.start(); \n```", "```java\nHttpHandler fileHandler = SimpleFileServer.createFileHandler(\n  Path.of(\"./docs\").toAbsolutePath());\nPath swslog = Paths.get(\"swslog.txt\");\nBufferedOutputStream output = new \n  BufferedOutputStream(Files.newOutputStream(swslog, \n    StandardOpenOption.CREATE, StandardOpenOption.WRITE));\nFilter filter = SimpleFileServer.createOutputFilter(output, \n  SimpleFileServer.OutputLevel.VERBOSE);\nHttpServer sws = HttpServer.create(\n  new InetSocketAddress(9009), 10, \"/mybooks\", \n  fileHandler, filter);\nsws.start(); \n```", "```java\nHttpServer sws = SimpleFileServer.createFileServer(\n  new InetSocketAddress(9009),\n  Path.of(\"./docs\").toAbsolutePath(),\n  OutputLevel.VERBOSE);\n    sws.setExecutor(Executors.newVirtualThreadPerTaskExecutor());\n  sws.start(); \n```", "```java\nHttpHandler fileHandler = ...;\nFilter preFilter = Filter.adaptRequest(\n  \"Add 'Author' header\", r -> r.with(\n    \"Author\", List.of(\"Anghel Leonard\")));\nFilter postFilter = SimpleFileServer.createOutputFilter(\n  out, SimpleFileServer.OutputLevel.VERBOSE);\nHttpServer sws = HttpServer.create(\n  new InetSocketAddress(9009), 10, \"/mybooks\", \n    fileHandler, preFilter, postFilter);\nsws.start(); \n```", "```java\nFilter preFilter = Filter.beforeHandler(\"some description\", \n  exchange -> { \n    // do something with the exchange before handler\n  });\nFilter postFilter = Filter.afterHandler(\"some description\", \n  exchange -> { \n    // do something with the exchange after handler\n  }); \n```", "```java\nHttpHandler fileHandler = SimpleFileServer.createFileHandler(\n  Path.of(\"./docs\").toAbsolutePath()); \n```", "```java\nHttpHandler complementHandler = HttpHandlers.of(200,   \n  Headers.of(\"Content-Type\", \"text/plain\"), \n    \"No data available\"); \n```", "```java\nPredicate<Request> predicate = request ->\n  request.getRequestMethod().equalsIgnoreCase(\"GET\"); \n```", "```java\nHttpHandler handler = HttpHandlers.handleOrElse(\n  predicate, fileHandler, complementHandler); \n```", "```java\nHttpServer sws = HttpServer.create(\n  new InetSocketAddress(9009), 10, \"/mybooks\", handler); \nsws.start(); \n```", "```java\nprivate static Path inMemoryDirectory() throws IOException {\n  FileSystem fileSystem\n    = Jimfs.newFileSystem(Configuration.forCurrentPlatform());\n  Path docs = fileSystem.getPath(\"docs\");\n  Files.createDirectory(docs);\n  Path books = docs.resolve(\"books.txt\"); // /docs/books.txt\n  Files.write(books, ImmutableList.of(\n    \"Java Coding Problems 1st Edition\",\n    \"Java Coding Problems 2nd Edition\",\n    \"jOOQ Masterclass\",\n    \"The Complete Coding Interview Guide in Java\"),\n    StandardCharsets.UTF_8);\n  return docs.toAbsolutePath();\n} \n```", "```java\nHttpServer sws = SimpleFileServer.createFileServer(\n  new InetSocketAddress(9009), inMemoryDirectory(),\n  OutputLevel.VERBOSE);\nsws.start(); \n```", "```java\njava.nio.file API and returns the corresponding path:\n```", "```java\nprivate static Path zipFileSystem() throws IOException {\n  Map<String, String> env = new HashMap<>();\n  env.put(\"create\", \"true\");\n  Path root = Path.of(\"./zips\").toAbsolutePath();\n  Path zipPath = root.resolve(\"docs.zip\")\n    .toAbsolutePath().normalize();\n  FileSystem zipfs = FileSystems.newFileSystem(zipPath, env);\n  Path externalTxtFile = Paths.get(\"./docs/books.txt\");\n  Path pathInZipfile = zipfs.getPath(\"/bookszipped.txt\");\n  // copy a file into the zip file\n  Files.copy(externalTxtFile, pathInZipfile,\n             StandardCopyOption.REPLACE_EXISTING);\n  return zipfs.getPath(\"/\");\n} \n```", "```java\nHttpServer sws = SimpleFileServer.createFileServer(\n  new InetSocketAddress(9009), zipFileSystem(),\n  OutputLevel.VERBOSE);\nsws.start(); \n```", "```java\njrt:/[$MODULE[/$PATH]] \n```", "```java\njrt:/java.base/java/io/File.class \n```", "```java\nprivate static Path jrtFileSystem() {\n  URI uri = URI.create(\"jrt:/\");\n  FileSystem jrtfs = FileSystems.getFileSystem(uri);\n  Path jrtRoot = jrtfs.getPath(\"modules\").toAbsolutePath();\n  return jrtRoot;\n} \n```", "```java\nHttpServer sws = SimpleFileServer.createFileServer(\n  new InetSocketAddress(9009), jrtFileSystem(),\n  OutputLevel.VERBOSE);\nsws.start(); \n```"]