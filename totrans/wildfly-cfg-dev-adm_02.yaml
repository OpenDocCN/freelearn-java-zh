- en: Chapter 2. Configuring the Core WildFly Subsystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first chapter gave us the basis to get started with WildFly 8\. It is time
    for us to dive right into the configuration of WildFly and see how to manage a
    standalone instance of the application server. You will see that the entire server
    is configured within a single file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration file is made up of a list of subsystems, including the application
    server core services and standard Java EE services. It is not possible to discuss
    all the subsystems within a single chapter, so they have been divided over a couple
    of chapters. By the end of this chapter, you should understand and be able to
    configure:'
  prefs: []
  type: TYPE_NORMAL
- en: The server configuration file `standalone.xml`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application server's thread pool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application server's logging subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring our application server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The default configuration files are named `standalone.xml`, for standalone servers,
    and `domain.xml` for an application server domain. An application server domain
    can be seen as a specialized server configuration, which also includes the domain
    and host controller setup. We will discuss the application server domain in [Chapter
    5](ch05.html "Chapter 5. Configuring a WildFly Domain"), *Configuring a WildFly
    Domain*. However, as far as the core services configuration is concerned, what
    we cover here will be suitable for the domain configuration as well. The configuration
    files (`standalone.xml` and `domain.xml`) are non-static files, which means that
    runtime changes are persisted to them, for example, adding a new component, such
    as a JMS destination, or deploying an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define as many configuration files as you need. The WildFly 8.1.0 release
    provides a few variants of `standalone.xml` (web profile), such as `standalone-full.xml`
    (full profile), and the `standalone-ha.xml` (web profile with high availability).
    You can also find some example configuration files in `JBOSS_HOME/docs/examples/configs`.
    If you want to start the server with a different configuration file, you can start
    the server with the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `standalone.xml` file is located in the `JBOSS_HOME/standalone/configuration`
    folder. This configuration file is in XML format and is validated by a set of
    `.xsd` files found in the `JBOSS_HOME/docs/schema` folder.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to check the single `.xsd` files, you can find them in the `JBOSS_HOME/docs/schema`
    folder of your server distribution. You can get to know all the available server
    parameters with a simple inspection of these files or by importing them into your
    Eclipse environment. Once they are located in your project, right-click on your
    file, and navigate to **Generate** | **XML File**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The application server configuration follows a tree-like structure that contains,
    at the root element, the server definition, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring our application server](img/6232OS_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following sections, we will show in detail the important parts of the
    server configuration. This will be helpful to understand the role of each single
    component in the application server, although you are advised not to manually
    change the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Manually changing the configuration file can lead to unchecked data modifications.
    This can corrupt the format of the file, preventing WildFly from starting up.
    If you do need to update the file manually, you should consider making a backup
    copy first.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The best practice for changing the server configuration is to use the **command-line
    interface** (**CLI**) or the web admin console, which are described in [Chapter
    7](ch07.html "Chapter 7. Using the Management Interfaces"), *Using the Management
    Interfaces*.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The application server contains a list of modules that are used to extend the
    core of the application server. The core of WildFly is very light, and these extensions
    provide much of the functionality you expect from an application server. Just
    like regular static modules, they are stored in the `JBOSS_HOME/modules` folder.
    Each extension defined in the `standalone.xml` or `domain.xml` file is picked
    up by the WildFly class loader when you start the server, before any applications
    are deployed. The following code shows an extract from the server configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Logical names for a filesystem path can be defined using the `paths` element.
    These paths can then be referenced by their logical name, rather than having to
    type the full path each time within the configuration file. By default, the `path`
    entry is excluded from the configuration. If you want to include it, you will
    have to manually add the full configuration. The following example defines a path
    relative to the WildFly server log with the logical name of `log.dir`. For a standalone
    server, this directory translates into `JBOSS_HOME/standalone/log/mylogdir`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To reference this path in other sections of the configuration file, simply
    use the logical name as the path. The following example shows the path being used
    to store the logging, rotating file handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that the property `relative-to` is not mandatory. If you don't include
    it in your path configuration, the path is assumed to be an absolute path.
  prefs: []
  type: TYPE_NORMAL
- en: WildFly provides a set of system paths that are available for you to use without
    the need to configure them manually. The pre-configured paths are outlined in
    the following table. The first five paths cannot be overridden, but the rest can
    be overridden using the path element as shown in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: '| Path | Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `jboss.home` | The root directory of the WildFly distribution |'
  prefs: []
  type: TYPE_TB
- en: '| `user.home` | The user''s home directory |'
  prefs: []
  type: TYPE_TB
- en: '| `user.dir` | The user''s current working directory |'
  prefs: []
  type: TYPE_TB
- en: '| `java.home` | The Java installation directory |'
  prefs: []
  type: TYPE_TB
- en: '| `jboss.server.base.dir` | The root directory for an individual server instance
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jboss.server.data.dir` | The directory the server will use for persistent
    data file storage |'
  prefs: []
  type: TYPE_TB
- en: '| `jboss.server.log.dir` | The directory the server will use for logfile storage
    |'
  prefs: []
  type: TYPE_TB
- en: '| `jboss.server.tmp.dir` | The directory the server will use for temporary
    file storage |'
  prefs: []
  type: TYPE_TB
- en: '| `jboss.domain.servers.dir` | The directory under which a host controller
    will create the working area for individual server instances |'
  prefs: []
  type: TYPE_TB
- en: Management interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The management interfaces are configured within the `management` element. This
    configuration is used by the CLI, the administration console, and by JMX. Both
    the native CLI interface and the web console run on admin port number 9990\. The
    following example is taken from the default server configuration and highlights
    the ports used for the management interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code snippet, we show the preceding `socket-binding` configuration
    being referenced by the `management-interfaces` section of the `standalone.xml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Management interfaces are discussed in detail in [Chapter 7](ch07.html "Chapter 7. Using
    the Management Interfaces"), *Using the Management Interfaces*, which provides
    detailed coverage of the application server management tools.
  prefs: []
  type: TYPE_NORMAL
- en: Profiles and subsystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A profile can be seen as a collection of subsystems, and each subsystem in turn
    contains a subset of functionalities added to the application server by means
    of extensions (see the *Extensions* section). For example, the web subsystem contains
    the definition of a set of connectors used by the container, the messaging subsystem
    defines the JMS configuration and modules used by the AS's messaging provider,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: One important difference between a standalone file and a domain configuration
    file is the number of profiles contained in it. When using a standalone configuration,
    there's a single profile that contains the set of subsystem configurations. Domain
    configuration can, on the other hand, provide multiple profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces define a logical name for where network interfaces/IP address or
    host names can be bound.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the standalone application server defines two available network
    interfaces, the `management` interface and the `public` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `public` network interface is intended to be used for the application server
    core services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `management` network interface is referenced by the AS management interfaces,
    as shown in the *Management interfaces* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, both network interfaces resolve to the loop back address `127.0.0.1`.
    This means that the application server public services and the management services
    are accessible only from the local machine. By changing the `inet-address` value,
    you can bind the network interface to another IP address. The following example
    shows the server listening on IP `192.168.1.1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you want to bind the network interface to all available
    sets of IP addresses, you can use the `<any-address />` element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Another useful variation of network interface is the **Network** **Interface**
    **Card** (**nic**) element, which gathers the address information from the network
    card name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Binding management interfaces via CLI**'
  prefs: []
  type: TYPE_NORMAL
- en: You can also bind your public interface using the `-b` switch, followed by a
    valid host/IP address. This will cause the server to listen on the host/IP address
    provided. For example, to bind all public interfaces to all IPv4 addresses, you
    will use `$JBOSS_HOME/bin/standalone.sh -b=0.0.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: The socket-binding groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A socket-binding group defines a logical name for a socket. Each socket-binding
    name can be referenced in other parts of the configuration file. In this section,
    you are able to configure the network port that will be listening for incoming
    connections. Every socket-binding group references a network interface through
    the `default-interface` attribute. Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to change the port where a service is bound, you can change the `port`
    attribute of its service, but a better approach is to use one of the management
    interfaces. This will provide an immediate outcome of the affected change. In
    the following example, we are going to change the default port for the `http`
    connector using the CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed in the response shown above that a reload is required.
    This can be achieved by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: System properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This section contains a set of system-wide properties, which can be added to
    the application server as part of the booting process. By default, the `system-properties`
    entry is excluded from the configuration. If you want to use this feature, you
    will need to add the full configuration. The following configuration snippet sets
    the property named example to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The property can be later retrieved on the application server using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Deployments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last section of the configuration file contains all the deployed applications
    that have been registered on the application server. Each time a new application
    is deployed or undeployed, this section is updated to reflect the new application
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring core subsystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you have grasped the basic concepts of the WildFly configuration file,
    we will look in more detail at single services.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can find a rough representation of core WildFly
    8 subsystems (for the sake of simplicity, we are including just the subsystems
    that are covered throughout this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring core subsystems](img/6232OS_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a first taste of configuring the application server, we will explore the
    areas that are highlighted in bold in the preceding diagram. These include the
    following core application server subsystems:'
  prefs: []
  type: TYPE_NORMAL
- en: The thread pool subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JBoss logging subsystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's move straight to the first subsystem, the thread pool.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the thread pool subsystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thread pools address two different problems. Firstly, they usually deliver improved
    performance when executing large numbers of asynchronous tasks due to reduced
    per-task invocation overhead. Secondly, they provide a means of bounding and managing
    resources, including threads, consumed when executing a collection of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: In releases of JBoss server prior to JBoss AS 7, the thread pool configuration
    was centralized in a single file or deployment descriptor. In WildFly, any subsystem
    that uses thread pools manages its own thread configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'By appropriately configuring the thread pool section, you can tune the specific
    areas that use that kind of pool to deliver new tasks. The application server
    thread pool configuration can include the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: Thread factory configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bounded-queue thread configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking bounded-queue thread configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unbounded-queue thread configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Queueless thread pool configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocking queueless thread pool configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled thread configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that the thread subsystem will probably be marked for
    deprecation in WildFly 9, but in WildFly 8 this configuration is completely valid.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at each single element in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the thread factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **thread** **factory** (implementing `java.util.concurrent.ThreadFactory`)
    is an object that creates new threads on demand. Using thread factories removes
    the hardwiring of calls to a new thread, enabling applications to use special
    thread subclasses, priorities, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: The thread factory is not included in the server configuration by default, as
    it relies on default values that you will rarely need to modify. Nevertheless,
    we will provide a simple configuration example for the experienced user who may
    require complete control of the thread configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a custom thread factory configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the possible attributes that you can use when defining a
    thread factory:'
  prefs: []
  type: TYPE_NORMAL
- en: The `name` attribute is the name of the created thread factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional `priority` attribute may be used to specify the thread priority
    of created threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optional `group-name` attribute specifies the name of the thread group to
    create for this thread factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `thread-name-pattern` is the template used to create names for threads.
    The following patterns can be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Pattern | Output |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `%%` | Emits a percentage sign |'
  prefs: []
  type: TYPE_TB
- en: '| `%g` | Emits the per-factory thread sequence number |'
  prefs: []
  type: TYPE_TB
- en: '| `%f` | Emits the global thread sequence number |'
  prefs: []
  type: TYPE_TB
- en: '| `%i` | Emits the thread ID |'
  prefs: []
  type: TYPE_TB
- en: '| `%G` | Emits the thread group name |'
  prefs: []
  type: TYPE_TB
- en: The bounded-queue thread pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A bounded-queue thread pool is the most common kind of pool used by the application
    server. It helps prevent resource exhaustion by defining a constraint on the thread
    pool''s size. It is also the most complex to use. Its inherent complexity derives
    from the fact that it maintains both a fixed-length queue and two pool sizes:
    a **core** **size** and a **maximum** **size**.'
  prefs: []
  type: TYPE_NORMAL
- en: If, each time a new task is submitted, the number of running threads is less
    than the core size, a new thread is created. Otherwise, if there is room in the
    queue, the task is queued.
  prefs: []
  type: TYPE_NORMAL
- en: If none of these options are viable, the executor needs to evaluate if it can
    still create a new thread. If the number of running threads is less than the maximum
    size, a new thread is created. Otherwise, the task is assigned to the designated
    `hand-off` executor, if one is specified. In the absence of a designated `hand-off`
    executor, the task will be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram summarizes the whole process, showing how all the pieces
    fit together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The bounded-queue thread pool](img/6232OS_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is a sample configuration of a bounded-queue thread pool taken
    from the configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table gives a short description of each attribute/element:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute/element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Specifies the bean name of the created executor |'
  prefs: []
  type: TYPE_TB
- en: '| `allow-core-timeout` | Specifies whether core threads time out or not; if
    `false`, only threads above the core size will time out |'
  prefs: []
  type: TYPE_TB
- en: '| `core-threads` | Specifies the core thread pool size, which is smaller than
    the maximum pool size |'
  prefs: []
  type: TYPE_TB
- en: '| `max-threads` | Specifies the maximum thread pool size |'
  prefs: []
  type: TYPE_TB
- en: '| `queue-length` | Specifies the executor queue length |'
  prefs: []
  type: TYPE_TB
- en: '| `keepalive-time` | Specifies the amount of time that threads beyond the core
    pool size should be kept running when idle |'
  prefs: []
  type: TYPE_TB
- en: '| `thread-factory` | Specifies the bean name of a specific thread factory to
    use to create worker threads |'
  prefs: []
  type: TYPE_TB
- en: '| `handoff-executor` | Specifies an executor to delegate tasks to in the event
    that a task cannot be accepted |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Performance focus**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Queue size** and **pool size** values are a performance tradeoff, and the
    right balance needs to be found between the two. When using a small pool with
    a large queue, you minimize CPU usage, OS resources, and context-switching overhead.
    It can, however, produce an artificially low throughput. If tasks are strongly
    I/O bound (and thus frequently blocked), a system may be able to schedule time
    for more threads than you otherwise allow. The use of small queues generally requires
    larger pool sizes, which keep the CPUs busier but may encounter unacceptable scheduling
    overhead, which also decreases throughput.'
  prefs: []
  type: TYPE_NORMAL
- en: The blocking bounded-queue thread pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The blocking bounded-queue thread pool has a very similar configuration to the
    bounded-queue thread pool; it has a slightly different workflow. The difference
    being, rather than attempting to hand off to the designated hand-off executor,
    the caller blocks until room becomes available in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'The flowchart for this thread pool is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The blocking bounded-queue thread pool](img/6232OS_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is an example configuration for a blocking bounded-queue thread
    pool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Please see the following table for the bounded-queue thread pool for a description
    of each attribute/element. The attributes/elements available for the blocking
    bounded-queue thread pool are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute/element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Specifies the bean name of the created executor |'
  prefs: []
  type: TYPE_TB
- en: '| `allow-core-timeout` | Specifies whether core threads may time out or not;
    if `false`, only threads above the core size will time out |'
  prefs: []
  type: TYPE_TB
- en: '| `core-threads` | Specifies the core thread pool size, which is smaller than
    the maximum pool size |'
  prefs: []
  type: TYPE_TB
- en: '| `max-threads` | Specifies the maximum thread pool size |'
  prefs: []
  type: TYPE_TB
- en: '| `queue-length` | Specifies the executor queue length |'
  prefs: []
  type: TYPE_TB
- en: '| `keepalive-time` | Specifies the amount of time that threads beyond the core
    pool size should be kept running when idle |'
  prefs: []
  type: TYPE_TB
- en: '| `thread-factory` | Specifies the bean name of a specific thread factory to
    use to create worker threads |'
  prefs: []
  type: TYPE_TB
- en: The unbounded-queue thread pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The unbounded-queue thread pool executor follows a simpler but more risky approach
    than the bounded thread pool; that is, it always accepts new tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In practice, the unbounded thread pool has a core size and a queue with no
    upper limit. When a task is submitted, if the number of running threads is less
    than the core size, a new thread is created. Otherwise, the task is placed in
    a queue. If too many tasks are allowed to be submitted to this type of executor,
    an out-of-memory condition may occur. Have a look at the following flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The unbounded-queue thread pool](img/6232OS_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Due to its inherent risk, unbounded thread pools are not included by default
    in the server configuration. We will provide a sample here, with only one recommendation:
    don''t try this at home, kids!'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you want to know more about the meaning of each thread pool element/attribute,
    you can refer to the bounded thread pool table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The attributes/elements available for the unbounded-queue thread pool are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute/element | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Specifies the bean name of the created executor |'
  prefs: []
  type: TYPE_TB
- en: '| `max-threads` | Specifies the maximum thread pool size |'
  prefs: []
  type: TYPE_TB
- en: '| `keepalive-time` | Specifies the amount of time that threads beyond the core
    pool size should be kept running when idle |'
  prefs: []
  type: TYPE_TB
- en: '| `thread-factory` | Specifies the bean name of a specific thread factory to
    use to create worker threads |'
  prefs: []
  type: TYPE_TB
- en: The queueless thread pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As its name implies, the queueless thread pool is a thread pool executor with
    no queue. Basically, this executor short-circuits the logic of the bounded thread
    executor, as it does not attempt to store the task in a queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when a task is submitted, if the number of running threads is less than
    the maximum size, a new thread is created. Otherwise, the task is assigned to
    the designated `hand-off` executor if one is specified. Without any designated
    `hand-off`, the task will be discarded. Have a look at the following flowchart:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The queueless thread pool](img/6232OS_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Queueless executors are also not included by default in the configuration file.
    However, we will provide a sample configuration here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The blocking queueless thread pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The blocking queueless thread pool has a similar configuration to the queueless
    thread pool. Similar to the blocking queue thread pool, the difference is that
    rather than attempting to hand off to the designated hand-off executor, the caller
    blocks until room becomes available in the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The blocking queueless thread pool](img/6232OS_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although not included in the default configuration file, here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The attributes/elements available for the unbounded-queue thread pool are `name`,
    `max-threads`, `keepalive-time`, and `thread-factory`.
  prefs: []
  type: TYPE_NORMAL
- en: The scheduled thread pool
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The server-scheduled thread pool is used for activities on the server side
    that require running periodically or with delays. It maps internally to a `java.util.concurrent.ScheduledThreadPoolExecutor`
    instance. Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The scheduled thread pool](img/6232OS_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This type of executor is configured with the `scheduled-thread-pool` executor
    element, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The scheduled thread pool is used by the `remoting` framework and by the HornetQ
    subsystem, which uses both a bounded JCA thread executor and a scheduled pool
    for delayed delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring application server logging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every application needs to trace logging statements. At the moment, there are
    several implementations of logging libraries for Java applications, the most popular
    ones are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Log4j**: It is a flexible open source logging library from Apache. Log4j
    is widely used in the open source community, and it was the default logging implementation
    on earlier releases of JBoss AS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Java SE logging libraries (JUL)**: It provides the logging classes and interfaces
    as part of the Java SE platform''s standard libraries.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log4j and JUL have very similar APIs. They differ conceptually only in small
    details, but do more or less the same thing, with the exception of log4j, which
    has more features. You may or may not need these features.
  prefs: []
  type: TYPE_NORMAL
- en: 'The JBoss logging framework is based on JUL, which is built around three main
    concepts: **loggers**, **handlers**, and **formatters**. These concepts allow
    developers to log messages according to their type and priority and to control
    where messages end up and how they look when they get there.'
  prefs: []
  type: TYPE_NORMAL
- en: The following diagram shows the logging cycle using the JUL framework. The application
    makes logging calls on the logger objects. These logger objects allocate the `LogRecord`
    objects, which are passed to the handler objects for publication. Both logger
    and handler may use the formatter to arrange the layout of logs and filter to
    decide whether they are interested in a particular log record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring application server logging](img/6232OS_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Choosing your logging implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The WildFly/JBoss application server, through its releases, has used different
    frameworks to handle application server logs. In JBoss AS 5 and earlier, log4j
    was the default logging API used by the application server.
  prefs: []
  type: TYPE_NORMAL
- en: Since JBoss AS 6, the logging provider switched to JBoss's own implementation,
    which is based on the JDK 1.4 logging system. However, it provides several fixes
    and workarounds for many shortcomings in the default JDK implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the default implementation of `java.util.logging` provided in the
    JDK does not have per-web application logging, as the configuration is per-VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, WildFly replaces the default JUL log manager implementation with
    its own implementation, which addresses these issues. The following diagram illustrates
    the modules that make up the WildFly 8 logging subsystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Choosing your logging implementation](img/6232OS_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At the top of the hierarchy, there's the `org.jboss.logmanager` module, which
    is the top-level library that manages logs for the JBoss logging subsystem. Under
    `jboss` `logmanager`, you can find concrete implementations, such as the `org.jboss.logging`
    and `org.jboss.log4j.logmanager` modules. By default, the application server uses
    the former module (`org.jboss.logging`), which is implemented in turn by `org.jboss.as.logging`
    to manage your logs inside the application server. However, if you want to switch
    to the `log4j` implementation, the `org.jboss.log4j.logmanager` module is what
    you need (in the last section of this chapter, we will include an example of how
    to use `log4j` in your application).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WildFly is not limited to JBoss logging or log4j. You can use any logging library,
    including slf4j or commons logging.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the logging subsystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The logging subsystem contains a set of log handlers out of the box. A handler
    object takes log messages from a logger and exports them. For example, it might
    write them to a console or a file, send them to a network logging service, or
    forward them to an OS log. By default, the following handlers are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '`console-handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`periodic-rotating-file-handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`size-rotating-file-handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async-handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syslog-handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`custom-handler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The console-handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `console-handler` defines a handler that simply writes log messages to
    the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The optional `autoflush` attribute determines if buffered logs are flushed automatically.
    The default value for this option is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `level` element defines the lowest log level associated with the handler,
    which means that anything with this log level and a higher value will be logged.
    The full range of log levels, from lowest to highest, are: `OFF`, `FINEST`, `FINER`,
    `FINE`, `CONFIG`, `INFO`, `WARNING`, `SEVERE`, and `ALL`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `formatter` element provides support to format `LogRecords`. The log formatting
    inherits the same pattern strings as that of the layout pattern of `log4j`, which
    was in turn inspired by dear old C's `printf` function. Check the log4j documentation
    at [http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html](http://logging.apache.org/log4j/1.2/apidocs/org/apache/log4j/PatternLayout.html).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will just mention that `%d{HH:mm:ss,SSS}` outputs the date of the logging
    event using the conversion included in brackets.
  prefs: []
  type: TYPE_NORMAL
- en: The string `%-5p` outputs the priority of the logging event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string `[%c]` is used to output the category of the logging event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string `(%t)` outputs the thread that generated the logging event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string `%s` outputs the log message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `%n` string outputs the platform-dependent line separator character
    or characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The periodic-rotating-file-handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `periodic-rotating-file-handler` defines a handler that writes to a file
    and rotates the log after a time period derived from the given suffix string,
    which should be in a format understood by `java.text.SimpleDateFormat`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This handler introduces the file element containing the path, which is the actual
    filename and its `relative-to` position. In our case, the relative position corresponds
    to the `jboss.server.log.dir` application server parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the default suffix configuration, logs are rolled at 12 PM. By changing
    the value of `SimpleDateFormat`, you can also change the period when logs are
    rotated, for example, the suffix `yyyy-MM-dd-HH` will rotate the logs every hour.
  prefs: []
  type: TYPE_NORMAL
- en: The size-rotating-file-handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `size-rotating-file-handler` defines a handler that writes to a file, rotating
    the log after the size of the file grows beyond a certain point. It also keeps
    a fixed number of backups.
  prefs: []
  type: TYPE_NORMAL
- en: 'There''s no size handler defined in the standard configuration. However, we
    can find out its basic configuration from the `JBOSS_HOME/docs/schema/jboss-as-logging_2_0.xsd`
    file. Have a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The async-handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `async-handler` is a composite handler that attaches to other handlers
    to produce asynchronous logging events. Behind the scenes, this handler uses a
    bounded queue to store events. Every time a log is emitted, the asynchronous handler
    appends the log into the queue and returns immediately. Here''s an example of
    asynchronous logging for the `FILE` appender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this handler, we also specify the size of the queue, where events are sent,
    and the action to take when the `async` queue overflows. You can opt between `block`,
    causing the calling thread to be blocked, and `discard`, causing the message to
    be discarded.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**When should I use the asynchronous handler?**'
  prefs: []
  type: TYPE_NORMAL
- en: The asynchronous handler produces a substantial performance benefit to applications
    that are heavily I/O bound. Conversely, CPU-bound applications may not benefit
    from asynchronous logging, as it will put additional stress on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: The syslog-handler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `syslog-handler` can be used to write logs to a remote logging server. This
    allows multiple applications to send their log messages to the same server, where
    they can all be parsed together. Both RFC3164 and RFC5424 formats are supported.
    Here is an example of a `syslog-handler`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Custom handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have seen just a few basic log handlers, which are usually included
    in your server configuration. If you need a more advanced approach to managing
    your logs, you can define a custom logging handler. In order to add a custom handler,
    you need to define a class that extends the `java.util.logging.Handler` interface
    and then override its abstract methods. For example, the following class, named
    `JdbcLogger`, is used to write the logs to a database (full code is available
    at [http://community.jboss.org/wiki/CustomLogHandlersOn701](http://community.jboss.org/wiki/CustomLogHandlersOn701)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that, although this article was written for JBoss AS 7, it remains valid
    for WildFly 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once compiled, this class needs to be packaged in an archive (for example,
    `logger.jar`) and installed as a module in the application server. We will name
    the module `com.JDBCLogger`, which requires the following structure under the
    `modules` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom handlers](img/6232OS_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The label **Path to be created** shows the directory structure under which
    we will place the `logger.jar` archive and its configuration file (`module.xml`),
    which follows here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note that this module has a dependency on another module, `com.mysql`. In the
    next chapter, we will show how to connect to a database after installing the appropriate
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost done. Now, insert the handler in the logging subsystem, which
    contains within its properties the database connection strings and the statement
    that will be used to insert logs into the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The new `handler`, named `DB`, is enlisted in the `root-logger` to collect
    all logging statements that have a priority of `INFO` or higher. Before testing
    the logger, don''t forget to create the required tables on your MySQL database,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have carefully followed all the required steps, you will notice that
    `log_table` contains the logging events that have been triggered since server
    startup. Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Custom handlers](img/6232OS_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring loggers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A logger object is used to log messages for a specific system or application
    components. Loggers are normally named using a hierarchical dot-separated namespace.
    Logger names can be arbitrary strings, but they should normally be based on the
    package name or class name of the logged component. For example, the logger instructs
    the logging system to emit logging statements for the package `com.sample` if
    they have the log level `WARN` or higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of the hierarchy, there''s the `root-logger`. There are two important
    things to note about `root-logger`:'
  prefs: []
  type: TYPE_NORMAL
- en: It always exists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It cannot be retrieved by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the default server configuration, the root-logger defines two handlers that
    are connected to `CONSOLE` and to the `FILE` handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Per-deployment logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WildFly has the ability to configure per-deployment logging. This is enabled
    by default. This means that if you add a logging configuration file to your deployment,
    its configuration will be used to log for that deployment. The valid logging configuration
    files are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`logging.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jboss-logging.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j.properties`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log4j.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jboss-log4j.xml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you package your application into an EAR, your logging configuration file
    should go into the `META-INF` directory. If you are packaging your application
    into a JAR or WAR, then it can be placed into either the `META-INF` directory
    or the `WEB-INF` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Should you want to disable per-deployment logging, you will need to set the
    `use-deployment-logging-config` value to `false`. Have a look at the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The system property `org.jboss.as.logging.per-deployment` has been deprecated
    in WildFly 8\. You should use `use-deployment-logging-config` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Bypassing container logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may, for some reason, wish to bypass container logging altogether. To do
    this, add the `add-logging-api-dependencies` property to your logging configuration
    and set its value to `false`. This will disable the adding of the implicit server
    logging dependencies, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: To bypass logging on per-application basis only, you will need to use the `jboss-deployment-structure.xml`
    file to exclude the logging subsystem. We will cover the `jboss-deployment-structure.xml`
    file in detail in [Chapter 6](ch06.html "Chapter 6. Application Structure and
    Deployment"), *Application Structure and Deployment*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we've gone through the basics of the application server configuration,
    which is now composed of a single monolithic file that contains the configuration
    for all the installed services.
  prefs: []
  type: TYPE_NORMAL
- en: Although this main configuration file will be your main point of reference to
    get a full understanding of the WildFly infrastructure, we must stress the importance
    of modifying it via one of the management interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We have examined each of the sections within the thread pool configuration in
    detail. We have also seen that the thread pool relies on the Java Standard Edition
    Thread Executor API to define a set of pools, and that these pools are used by
    the application servers' core services.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed the JBoss logging framework, which is built on top of the
    Java Util Logging framework and addresses some known shortcomings of JUL. We described
    how to configure per-application logging in your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a look at some core enterprise service configurations,
    such as the datasource and messaging subsystems. These services are the backbone
    of many enterprise applications.
  prefs: []
  type: TYPE_NORMAL
