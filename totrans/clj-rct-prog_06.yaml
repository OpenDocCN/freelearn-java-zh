- en: Chapter 6. Building a Simple ClojureScript Game with Reagi
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how a framework for **Compositional Event
    Systems** (**CES**) works by building our own framework, which we called *respondent*.
    It gave us a great insight into the main abstractions involved in such a piece
    of software as well as a good overview of `core.async`, Clojure's library for
    asynchronous programming and the foundation of our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Respondent is but a toy framework, however. We paid little attention to cross-cutting
    concerns such as memory efficiency and exception handling. That is okay as we
    used it as a vehicle for learning more about handling and composing event systems
    with `core.async`. Additionally, its design is intentionally similar to Reagi's
    design.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn about Reagi, a CES framework built on top of `core.async`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Reagi to build the rudiments of a ClojureScript game that will teach us
    how to handle user input in a clean and maintainable way
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Briefly compare Reagi to other CES frameworks and get a feel for when to use
    each one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever played Asteroids? If you haven't, Asteroids is an arcade space
    shooter first released by Atari in 1979\. In Asteroids, you are the pilot of a
    ship flying through space. As you do so, you get surrounded by asteroids and flying
    saucers you have to shoot and destroy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developing the whole game in one chapter is too ambitious and would distract
    us from the subject of this book. We will limit ourselves to making sure we have
    a ship on the screen we can fly around as well as shoot space bullets into the
    void. By the end of this chapter, we will have something that looks like what
    is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the project](img/00017.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To get started, we will create a `newClojureScript` project using the same
    leiningen template we used in the previous chapter, `cljs-start` (see [https://github.com/magomimmo/cljs-start](https://github.com/magomimmo/cljs-start)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, add the following dependencies to your project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The last dependency, monet (see [https://github.com/rm-hull/monet](https://github.com/rm-hull/monet)),
    is a ClojureScript library you can use to work with HTML 5 Canvas. It is a high-level
    wrapper on top of the Canvas API and makes interacting with it a lot simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we continue, it''s probably a good idea to make sure our setup is working
    properly. Change into the project directory, start a Clojure REPL, and then start
    the embedded web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will compile the ClojureScript source files to JavaScript and start the
    sample web server. In your browser, navigate to `http://localhost:3000/`. If you
    see something like the following, we are good to go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the project](img/00018.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As we will be working with HTML 5 Canvas, we need an actual canvas to render
    to. Let''s update our HTML document to include that. It''s located under `dev-resources/public/index.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have added a `canvas` DOM element to our document. All rendering will happen
    in this context.
  prefs: []
  type: TYPE_NORMAL
- en: Game entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our game will have only two entities: one representing the spaceship and the
    other representing bullets. To better organize the code, we will put all entity-related
    code in its own file, `src/cljs/reagi_game/entities.cljs`. This file will also
    contain some of the rendering logic, so we''ll need to require `monet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we''ll add a few helper functions to avoid repeating ourselves too much:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The first three functions are simply a shorter way of getting data out of our
    shape data structure. The `shape-data` function creates a structure. Note that
    we are using `atoms`, one of Clojure's reference types, to represent a shape's
    position and angle.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can safely pass our shape data into monet's rendering functions
    and still be able to update it in a consistent way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is our ship constructor function. This is where the bulk of the interaction
    with monet happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There is quite a bit going on, so let's break it down.
  prefs: []
  type: TYPE_NORMAL
- en: '`canvas/entity` is a monet constructor and expects you to provide three arguments
    that describe our ship: its initial x, y coordinates and angle, an update function
    that gets called in the draw loop, and a draw function that is responsible for
    actually drawing the shape onto the screen after each update.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The update function is fairly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We simply update its attributes to the current values from the ship's atoms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function, responsible for drawing, interacts with monet''s API more
    heavily:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We start by saving the current context so that we can restore things such as
    drawing style and canvas positioning later. Next, we translate the canvas to the
    ship's x,y coordinates and rotate it according to its angle. We then start drawing
    our shape, a triangle, and finish by restoring our saved context.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next function also creates an entity, our bullet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, let''s inspect the `update` and `drawing` functions. We''ll start
    with `update`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Bullets have a little more logic in their update function. As you fire them
    from the ship, we might create hundreds of these entities, so it''s a good practice
    to get rid of them as soon as they go off the visible canvas area. That''s the
    first thing the function does: it uses `geom/contained?` to check whether the
    entity is within the dimensions of the canvas, removing it when it isn''t.'
  prefs: []
  type: TYPE_NORMAL
- en: Different from the ship, however, bullets don't need user input in order to
    move. Once fired, they move on their own. That's why the next thing we do is call
    `move-forward!` We haven't implemented this function yet, so we had to declare
    it beforehand. We'll get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Once the bullet's coordinates and angle have been updated, we simply return
    the new entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The draw function is a bit simpler than the ship''s version mostly due to its
    shape being simpler; it''s just a red circle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll move on to the functions responsible for updating our shape''s
    coordinates and angle, starting with `move!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To keep things simple, both the ship and bullets use the same speed value to
    calculate their positioning, here defined as `200`.
  prefs: []
  type: TYPE_NORMAL
- en: '`move!` takes two arguments: the shape map and a function `f`. This function
    will either be the `+` (plus) or the `-` (minus) function, depending on whether
    we''re moving forward or backward, respectively. Next, it updates the shape''s
    x,y coordinates using some basic trigonometry.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re wondering why we are passing the plus and minus functions as arguments,
    it''s all about not repeating ourselves, as the next two functions show:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'With movement taken care of, the next step is to write the rotation functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we''ve got ship movement covered! But what good is our ship if we can''t
    fire bullets? Let''s make sure we have that covered as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `fire!` function takes two arguments: a reference to the game canvas and
    the ship. It then creates a new bullet by calling `make-bullet-entity` and adds
    it to the canvas.'
  prefs: []
  type: TYPE_NORMAL
- en: Note how we use Clojure's `gensym` function to create a unique key for the new
    entity. We use this key to remove an entity from the game.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes the code for the `entities` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`gensym` is quite heavily used in writing hygienic macros as you can be sure
    that the generated symbols will not clash with any local bindings belonging to
    the code using the macro. Macros are beyond the scope of this book, but you might
    find this series of macro exercises useful in the learning process, at [https://github.com/leonardoborges/clojure-macros-workshop](https://github.com/leonardoborges/clojure-macros-workshop).'
  prefs: []
  type: TYPE_NORMAL
- en: Putting it all together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re now ready to assemble our game. Go ahead and open the core namespace
    file, `src/cljs/reagi_game/core.cljs`, and add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We start by creating `monet-canvas` from a reference to our `canvas` DOM element.
    We then create our ship data, placing it at the center of the canvas, and add
    the entity to `monet-canvas`. Finally, we start a draw-loop, which will handle
    our animations using the browser's native capabilities—internally it calls `window.requestAnimationFrame()`,
    if available, but it falls back to `window.setTimemout()` otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to try the application now, this would be enough to draw the ship
    on the middle of the screen, but nothing else would happen as we haven't started
    handling user input yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as user input goes, we''re concerned with a few actions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ship movement: rotation, forward, and backward'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing the ship's gun
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pausing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To account for these actions, we''ll define some constants that represent the
    ASCII codes of the keys involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This should look sensible as we are using the keys traditionally used for these
    types of actions.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling user input as event streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the things discussed in the earlier chapters is that if you can think
    of events as a list of things that haven''t happened yet; you can probably model
    it as an event stream. In our case, this list is composed by the keys the player
    presses during the game and can be visualized like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modeling user input as event streams](img/00019.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There is a catch though. Most games need to handle simultaneously pressed keys.
  prefs: []
  type: TYPE_NORMAL
- en: Say you're flying the spaceship forwards. You don't want to have to stop it
    in order to rotate it to the left and then continue moving forwards. What you
    want is to press left at the same time you're pressing up and have the ship respond
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This hints at the fact that we need to be able to tell whether the player is
    currently pressing multiple keys. Traditionally this is done in JavaScript by
    keeping track of which keys are being held down in a map-like object, using flags.
    Something similar to the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, later in the game loop, you would check whether there are multiple keys
    being pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While this code works, it relies on mutating the `keysPressed` object which
    isn't ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, with a setup similar to the preceding one, the `keysPressed` object
    is global to the application as it is needed both in the `keyup`/`keydown` event
    handlers as well as in the game loop itself.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, we strive to eliminate or reduce the amount of global
    mutable state in order to write readable, maintainable code that is less error-prone.
    We will apply these principles here.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding JavaScript example, we can register callbacks to be
    notified whenever a `keyup` or `keydown` event happens. This is useful as we can
    easily turn them into event streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Both `keydown-stream` and `keyup-stream` return a new stream to which they deliver
    events whenever they happen. Each event is tagged with a keyword, so we can easily
    identify its type.
  prefs: []
  type: TYPE_NORMAL
- en: We would like to handle both types of events simultaneously and as such we need
    a way to combine these two streams into a single one.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways in which we can combine streams, for example, using operators
    such as `zip` and `flatmap`. For this instance, however, we are interested in
    the `merge` operator. `merge` creates a new stream that emits values from both
    streams as they arrive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modeling user input as event streams](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'This gives us enough to start creating our stream of active keys. Based on
    what we have discussed so far, our stream looks something like the following at
    the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: To keep track of which keys are currently pressed, we will use a ClojureScript
    set. This way we don't have to worry about setting flags to true or false—we can
    simply perform standard set operations and add/remove keys from the data structure.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing we need is a way to accumulate the pressed keys into this set
    as new events are emitted from the merged stream.
  prefs: []
  type: TYPE_NORMAL
- en: In functional programming, whenever we wish to accumulate or aggregate some
    type of data over a sequence of values, we use `reduce`.
  prefs: []
  type: TYPE_NORMAL
- en: Most—if not all—CES frameworks have this function built-in. RxJava calls it
    `scan`. Reagi, on the other hand, calls it `reduce`, making it intuitive to functional
    programmers in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is the function we will use to finish the implementation of `active-keys-stream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`r/reduce` takes three arguments: a reducing function, an optional initial/seed
    value, and the stream to reduce over.'
  prefs: []
  type: TYPE_NORMAL
- en: Our seed value is an empty set as initially the user hasn't yet pressed any
    keys. Then, our reducing function checks the event type, removing or adding the
    key from/to the set as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a result, what we have is a stream like the one represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modeling user input as event streams](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Working with the active keys stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ground work we've done so far will make sure we can easily handle game events
    in a clean and maintainable way. The main idea behind having a stream representing
    the game keys is that now we can partition it much like we would a normal list.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if we''re interested in all events where the key pressed is `UP`,
    we would run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for events involving the `FIRE` key, we could do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because in Clojure, sets can be used as predicates. We can quickly
    verify this at the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: By representing the events as a stream, we can easily operate on them using
    familiar sequence functions such as `map` and `filter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing code like this, however, is a little repetitive. The two previous examples
    are pretty much saying something along these lines: filter all events matching
    a given predicate `pred` and then map the `f` function over them. We can abstract
    this pattern in a function we''ll call `filter-map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With this helper function in place, it becomes easy to handle our game actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The only thing missing now is taking care of pausing the animations when the
    player presses the `PAUSE` key. We follow the same logic as above, but with a
    slight change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Monet makes a flag available that tells us whether it is currently updating
    the animation state. We use that as a cheap mechanism to "pause" the game.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `active-keys-stream` pushes events as they happen so, if a user is
    holding a button down for any amount of time, we will get multiple events for
    that key. As such, we would probably get multiple occurrences of the `PAUSE` key
    in a very short amount of time. This would cause the game to frantically stop/start.
    In order to prevent this from happening, we throttle the filtered stream and ignore
    all `PAUSE` events that happen in a window shorter than 100 milliseconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make sure we didn''t miss anything, this is what our `src/cljs/reagi_game/core.cljs`
    file should look like, in full:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This completes the code and we're now ready to have a look at the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still have the server running from earlier in this chapter, simply exit
    the REPL, start it again, and start the embedded web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This will compile the latest version of our ClojureScript source to JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can leave the REPL running and simply ask `cljsbuild` to
    auto-compile the source code from another terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now you can point your browser to `http://localhost:3000/` and fly around your
    spaceship! Don't forget to shoot some bullets as well!
  prefs: []
  type: TYPE_NORMAL
- en: Reagi and other CES frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Back in [Chapter 4](part0033_split_000.html#page "Chapter 4. Introduction to
    core.async"), *Introduction to core.async*, we had an overview of the main differences
    between `core.async` and CES. Another question that might have arisen in this
    chapter is this: how do we decide which CES framework to use?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is less clear than before and often depends on the specifics of
    the tool being looked at. We have learned about two such tools so far: Reactive
    Extensions (encompassing RxJS, RxJava, and RxClojure) and Reagi.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reactive Extensions** (**Rx**) is a much more mature framework. Its first
    version for the .NET platform was released in 2011 and the ideas in it have since
    evolved substantially.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, ports for other platforms such as RxJava are being heavily used
    in production by big names such as Netflix.
  prefs: []
  type: TYPE_NORMAL
- en: A drawback of Rx is that if you would like to use it both in the browser and
    on the server, you have to use two separate frameworks, RxJS and RxJava, respectively.
    While they do share the same API, they are different codebases, which can incur
    bugs that might have been solved in one port but not yet in another.
  prefs: []
  type: TYPE_NORMAL
- en: For Clojure developers, it also means relying more on interoperability to interact
    with the full API of Rx.
  prefs: []
  type: TYPE_NORMAL
- en: Reagi, on the other hand, is a new player in this space but builds on the solid
    foundation laid out by `core.async`. It is fully developed in Clojure and solves
    the in-browser/on-server issue by compiling to both Clojure and ClojureScript.
  prefs: []
  type: TYPE_NORMAL
- en: Reagi also allows seamless integration with `core.async` via functions such
    as `port` and `subscribe`, which allow channels to be created from event streams.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the use of `core.async` in ClojureScript applications is becoming
    ubiquitous, so chances are you already have it as a dependency. This makes Reagi
    an attractive option for the times when we need a higher level of abstraction
    than the one provided by `core.async`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how we can use the techniques from reactive programming
    we have learned so far in order to write code that is cleaner and easier to maintain.
    To do so, we insisted on thinking about asynchronous events simply as lists and
    saw how that way of thinking lends itself quite easily to being modeled as an
    event stream. All our game has to do, then, is operate on these streams using
    familiar sequence processing functions.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned the basics of Reagi, a framework for CES similar to the one
    we created in [Chapter 4](part0033_split_000.html#page "Chapter 4. Introduction
    to core.async"), *Introduction to core.async*, but that is more feature rich and
    robust.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take a break from CES and see how a more traditional
    reactive approach based on data flows can be useful.
  prefs: []
  type: TYPE_NORMAL
