<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer122">
			</div>
		</div>
		<div class="Content" id="_idContainer123">
			<h1 id="_idParaDest-332"><a id="_idTextAnchor344"/>18. Unit Testing</h1>
		</div>
		<div class="Content" id="_idContainer126">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter focuses on testing with JUnit, one of the primary testing frameworks for Java. In its earliest sections and exercises, you will learn to write a successful unit test with JUnit to test your code, using assertions to verify that your code is correct. You will then be introduced to parameterized tests—a type of unit test which allows you to run the same test on a set of data inputs—which you will also learn to write. Finally, the chapter will define mocking, which is the technique whereby you will practice how to 'mock out' external dependencies so that you can concentrate on testing a single Java class.</p>
			<h1 id="_idParaDest-333"><a id="_idTextAnchor345"/>Introduction</h1>
			<p>Testing allows you to make sure your Java code performs correctly. For example, if you were calculating employees' pay, you would want the code to be accurate; otherwise, your organization may face legal consequences. While not every programming issue leads to legal doom, it is still a good idea to test your code. </p>
			<p>Writing tests while you code, as opposed to when you are done, can speed up your work. This is because you won't be spending time trying to figure out why things don't seem to work. Instead, you will know exactly what part of the code isn't correct. This is especially useful for any code that requires complex logic.</p>
			<p>In addition to this, as new enhancements are added to the code, you will want to make sure that nothing in the new code breaks the old functionality. Having a suite of well-written unit tests can really help in this regard. If you are a new developer hired into a team that has been working on an application for some time, a good suite of tests is a sign that your team follows engineering best practices.</p>
			<h1 id="_idParaDest-334"><a id="_idTextAnchor346"/>Getting Started with Unit Tests</h1>
			<p>A unit test tests one unit of code. In Java terms, this usually means that a unit test tests a single Java class. The test should run quickly, so you know whether there are any problems as soon as possible.</p>
			<p>A unit test is a separate Java class designed just for testing. You should write separate test methods for each part of the original class you want to test. Typically, the more fine-grained the test, the better.</p>
			<p>Sometimes, due to necessity, a unit test will test more than one class. That's OK and not something to worry about. In general, though, you want to concentrate on writing separate tests for each class in your Java application.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Writing your Java classes so that they are easy to test will improve your code. You'll have better code organization, clearer code, and better quality as a result.</p>
			<p>Integration tests, on the other hand, test a part of the entire system, including external dependencies. For example, a unit test should not access a database. That's the job of integration tests.</p>
			<p>Functional tests go further and test an entire system all in one, such as an online banking application or a retail store application. This is sometimes called end-to-end testing.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Software development job interviews tend to go badly if you say you do not believe in writing tests.</p>
			<h2 id="_idParaDest-335"><a id="_idTextAnchor347"/>Introducing JUnit</h2>
			<p>JUnit provides the most widely used test framework for Java code. Now on version 5, JUnit has been around for years.</p>
			<p>With JUnit, your tests reside in test classes, that is, classes that use JUnit's framework to validate your code. These test classes reside outside of the main application code. That's why both Maven and Gradle projects have two subdirectories under the <strong class="source-inline">src</strong> directory: main, for your application code, and test, for the tests.</p>
			<p>Typically, tests are not part of your built application. So, if you build a JAR file for your application, the tests will not be part of that JAR file. </p>
			<p>JUnit has been around for a long time, and you will find the official documentation at <a href="https://packt.live/2J9seWE">https://packt.live/2J9seWE</a> and the official site at <a href="https://packt.live/31xFtXu">https://packt.live/31xFtXu</a>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Another popular test framework is called Spock. Spock uses the Groovy language, which is a JVM language that is similar to Java. You can refer to <a href="https://packt.live/2P4fPqG">https://packt.live/2P4fPqG</a> for more information about Spock. TestNG is another Java unit testing framework. You can refer to <a href="https://packt.live/33X2nct">https://packt.live/33X2nct</a> for more information about TestNG.</p>
			<h2 id="_idParaDest-336"><a id="_idTextAnchor348"/>Writing Unit Tests with JUnit</h2>
			<p>Oozie is a workflow scheduler for the Hadoop big data clusters. Oozie workflows are jobs that perform tasks on potentially massive amounts of data stored in Hadoop clusters. Oozie coordinator jobs run workflow jobs on a schedule.</p>
			<p>When defining a schedule, you typically set three values:</p>
			<ul>
				<li>The starting timestamp, which defines when the coordinator should start a workflow job.</li>
				<li>The ending timestamp, which defines when the coordinator should end.</li>
				<li>A frequency, in minutes, at which the coordinator should launch jobs. For example, a frequency of 60 specifies launching a workflow job every 60 minutes (that is, each hour), from the starting timestamp to the ending timestamp.<p class="callout-heading">Note</p><p class="callout">You can refer to <a href="https://packt.live/2BzqlOJ">https://packt.live/2BzqlOJ</a> for more information about Oozie coordinators and even more scheduling options. For now, we'll just concentrate on validating the coordinator scheduling information.</p></li>
			</ul>
			<p>Here, we're going to define a simple JavaBean class that holds the scheduling information and then write a JUnit test to validate a coordinator schedule.</p>
			<p>The basic bean looks like the following (with the getters, setters, and constructors not shown):</p>
			<p class="source-code">public class CoordSchedule {</p>
			<p class="source-code">    private String startingTimestamp;</p>
			<p class="source-code">    private String endingTimestamp;</p>
			<p class="source-code">    private int frequency;</p>
			<p class="source-code">        </p>
			<p class="source-code">}</p>
			<p>The starting and ending timestamps are <strong class="source-inline">String</strong> values based on an assumption that this bean would hold data read in from a configuration file. It also allows us to validate the <strong class="source-inline">String</strong> format for the timestamps.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Remember that IntelliJ can generate constructors along with the getter and setter methods.</p>
			<p>Now, consider what you would want to test, along with how you would write those tests. Testing edge cases is a good idea.</p>
			<p>For a coordinator, here are the rules: </p>
			<ul>
				<li>The ending timestamp must be after the starting timestamp.</li>
				<li>Both timestamps must be in UTC in the format of <strong class="source-inline">yyyy-MM-ddTHH:mmZ</strong> (this is the ISO 8601 format).</li>
				<li>The frequency must be less than 1,440 (that is, the number of minutes in a normal day). Oozie provides alternative configuration settings to go beyond this limitation. For now, we'll just test against this limit.</li>
				<li>The frequency should be greater than 5 (this is an arbitrary rule designed to prevent new workflows starting while another workflow is still running).</li>
			</ul>
			<p>To create a test, you create a separate test class. Test classes should have a single no-argument constructor. Test classes cannot be abstract classes. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you work with the Maven build tool (refer to <em class="italic">Chapter 6</em>, <em class="italic">Libraries, Packages, and Modules</em>), then your test classes should all have names that end in <strong class="source-inline">Test</strong>, <strong class="source-inline">Tests</strong>, or <strong class="source-inline">TestCase</strong>. All test classes in this chapter have names ending in <strong class="source-inline">Test</strong>.</p>
			<p>JUnit uses the <strong class="source-inline">@Test</strong> annotation to identify a test method. You can add a <strong class="source-inline">@DisplayName</strong> annotation to specify the text to be displayed should the test fail. This can make your test reports easier to read:</p>
			<p class="source-code">@Test</p>
			<p class="source-code">@DisplayName("Frequency must be less than 1440")</p>
			<p class="source-code">void testFrequency() {</p>
			<p class="source-code">}</p>
			<p>Inside your test methods, use the <strong class="source-inline">Assertions</strong> class methods to validate the results:</p>
			<p class="source-code">Assertions.assertTrue(schedule.getFrequency() &lt; 1440);</p>
			<p class="callout-heading">Note</p>
			<p class="callout">JUnit provides a few other assertion methods, such as <strong class="source-inline">assertEquals()</strong> and <strong class="source-inline">assertAll()</strong>.</p>
			<h2 id="_idParaDest-337"><a id="_idTextAnchor349"/>Exercise 1: Writing a First Unit Test</h2>
			<p>This example will show the basics of writing a JUnit unit test. For this exercise, we will simply test whether the properties are correct; though, typically, you would also test program logic:</p>
			<ol>
				<li>Select <strong class="source-inline">New</strong> and then <strong class="source-inline">Project…</strong> from the <strong class="source-inline">File</strong> menu in IntelliJ. </li>
				<li>Select <strong class="source-inline">Gradle</strong> for the type of project. Click on <strong class="source-inline">Next</strong>.</li>
				<li>For <strong class="source-inline">Group Id</strong>, enter <strong class="source-inline">com.packtpub.testing</strong>.</li>
				<li>For <strong class="source-inline">Artifact Id</strong>, enter <strong class="source-inline">chapter18</strong>.</li>
				<li>For <strong class="source-inline">Version</strong>, enter <strong class="source-inline">1.0</strong>.</li>
				<li>Accept the default settings on the next pane. Click on <strong class="source-inline">Next</strong>.</li>
				<li>Leave the project name as <strong class="source-inline">chapter18</strong>.</li>
				<li>Click on <strong class="source-inline">Finish</strong>.</li>
				<li>Call up <strong class="source-inline">build.gradle</strong> in the IntelliJ text editor.</li>
				<li>Change <strong class="source-inline">sourceCompatibility</strong> so that it is set to <strong class="source-inline">12</strong>:<p class="source-code">sourceCompatibility = 12</p></li>
				<li>Remove the JUnit dependency defined in the <strong class="source-inline">build.gradle</strong> file (it is for an older version). Replace that dependency with the following dependencies:<p class="source-code">testImplementation('org.junit.jupiter:junit-jupiter-api:5.4.2')</p><p class="source-code">testImplementation('org.junit.jupiter:junit-jupiter-engine:5.4.2')</p><p>This brings in JUnit 5 to our project, rather than JUnit 4.</p><p>Add the following to <strong class="source-inline">build.gradle</strong> after the dependencies section:</p><p class="source-code">test {</p><p class="source-code">    useJUnitPlatform()</p><p class="source-code">}</p><p>This ensures that you use the JUnit 5 test platform for running tests.</p></li>
				<li>In the <strong class="source-inline">src/main/java</strong> folder, create a new Java package.</li>
				<li>Enter <strong class="source-inline">com.packtpub.testing</strong> as the package name.</li>
				<li>In the <strong class="source-inline">src/test/java</strong> folder, create a new Java package.</li>
				<li>Enter the same name, <strong class="source-inline">com.packtpub.testing</strong>.<p>The <strong class="source-inline">src/test/java</strong> folder is where you will place your test classes. The <strong class="source-inline">src/main/java</strong> folder is where the application classes are located.</p></li>
				<li>Right-click on this package in the <strong class="source-inline">src/main/java</strong> folder and create a new Java class named <strong class="source-inline">CoordSchedule</strong>.</li>
				<li>Enter two constants that we'll use to validate the data:<p class="source-code">public static final int MAX_FREQUENCY = 1440;</p><p class="source-code">public static final int MIN_FREQUENCY = 5;</p></li>
				<li>Enter the properties of this class:<p class="source-code">private String startingTimestamp;</p><p class="source-code">private String endingTimestamp;</p><p class="source-code">private int frequency;</p></li>
				<li>With the editor cursor inside the class (that is, between the starting and ending curly braces), right-click and choose <strong class="source-inline">Generate…</strong>.</li>
				<li>Select <strong class="source-inline">Constructor</strong> and then select all three properties. You should see a constructor like the following:<p class="source-code">public CoordinatorSchedule(String startingTimestamp, </p><p class="source-code">    String endingTimestamp, int frequency) {</p><p class="source-code">    this.startingTimestamp = startingTimestamp;</p><p class="source-code">    this.endingTimestamp = endingTimestamp;</p><p class="source-code">    this.frequency = frequency;</p><p class="source-code">}</p></li>
				<li>Again, with the editor cursor inside the class (that is, between the starting and ending curly braces), right-click and choose <strong class="source-inline">Generate…</strong>.</li>
				<li>Select <strong class="source-inline">Getter</strong> and <strong class="source-inline">Setter</strong> and then select all three properties. You will then see the <strong class="source-inline">get</strong> and <strong class="source-inline">set</strong> methods for each of the three properties.</li>
				<li>Enter the following method to parse the <strong class="source-inline">String</strong> timestamp value:<p class="source-code">private Date parseTimestamp(String timestamp) {</p><p class="source-code">    Date date = null;</p><p class="source-code">    SimpleDateFormat format =       new SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'",Locale.getDefault());</p><p class="source-code">    format.setTimeZone(TimeZone.getTimeZone("UTC"));</p><p class="source-code">    try {</p><p class="source-code">        date = format.parse(timestamp);</p><p class="source-code">    } catch (ParseException e) {</p><p class="source-code">        e.printStackTrace();</p><p class="source-code">    }</p><p class="source-code">    return date;</p><p class="source-code">}</p></li>
				<li>Enter the following two utility methods to return the <strong class="source-inline">Date</strong> objects for the two timestamps:<p class="source-code">public Date getStartingTimestampAsDate() {</p><p class="source-code">    return parseTimestamp(startingTimestamp);</p><p class="source-code">}</p><p class="source-code">public Date getEndingTimestampAsDate() {</p><p class="source-code">    return parseTimestamp(endingTimestamp);</p><p class="source-code">}</p><p>These methods allow other code to get the timestamps in date format, rather than as a string.</p><p>We now have the Java class that we are going to test.</p><p>The next step is to create a unit test class.</p></li>
				<li>Right-click on this package in the <strong class="source-inline">src/test/java</strong> folder and create a new Java class named <strong class="source-inline">CoordScheduleTest</strong>.</li>
				<li>Enter the following test method:<p class="source-code">@Test</p><p class="source-code">@DisplayName("Frequency must be less than 1440")</p><p class="source-code">void testFrequency() {</p><p class="source-code">    CoordSchedule schedule = new CoordSchedule(</p><p class="source-code">            "2020-12-15T15:32Z",</p><p class="source-code">            "2020-12-30T05:15Z",</p><p class="source-code">            60</p><p class="source-code">    );</p><p class="source-code">    Assertions.assertTrue(schedule.getFrequency() &lt; 50);</p><p class="source-code">}</p><p>Note that this test should fail because we use a maximum value of <strong class="source-inline">50</strong> instead of the actual requirement, which is a maximum of <strong class="source-inline">1,440</strong>. It is good to see what failure will look like first.</p></li>
				<li>Click on the <strong class="source-inline">Gradle</strong> pane. Expand <strong class="source-inline">Tasks</strong> and then expand <strong class="source-inline">verification</strong>. </li>
				<li>Double-click on <strong class="source-inline">Test</strong>. This runs the Gradle <strong class="source-inline">test</strong> task. This will show an output like the following (with most of the stack trace omitted for clarity):<p class="source-code">&gt; Task :compileJava UP-TO-DATE</p><p class="source-code">&gt; Task :processResources NO-SOURCE</p><p class="source-code">&gt; Task :classes UP-TO-DATE</p><p class="source-code">&gt; Task :compileTestJava UP-TO-DATE</p><p class="source-code">&gt; Task :processTestResources NO-SOURCE</p><p class="source-code">&gt; Task :testClasses UP-TO-DATE</p><p class="source-code">&gt; Task :test FAILED</p><p class="source-code">expected: &lt;true&gt; but was: &lt;false&gt;</p><p class="source-code">org.opentest4j.AssertionFailedError: expected: &lt;true&gt; but was: &lt;false&gt;</p><p class="source-code">at com.packtpub.testing.CoordScheduleTest.testFrequency(CoordScheduleTest.java:19)</p><p class="source-code">com.packtpub.testing.CoordScheduleTest &gt; testFrequency() FAILED</p><p class="source-code">    org.opentest4j.AssertionFailedError at CoordScheduleTest.java:19</p><p class="source-code">1 test completed, 1 failed</p><p class="source-code">FAILURE: Build failed with an exception.</p></li>
				<li>This isn't a very nice test report. Luckily, JUnit provides a much nicer report. Click on the Gradle elephant icon and the test report will appear in your web browser:<div class="IMG---Figure" id="_idContainer124"><img alt="Figure 18.1: The IntelliJ Run pane with the Gradle icon shown&#13;&#10;" src="image/C13927_18_01.jpg"/></div><p class="figure-caption">Figure 18.1: The IntelliJ Run pane with the Gradle icon shown</p></li>
				<li>Switch to your web browser and you will see the test report:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer125">
					<img alt="Figure 18.2: The test report as displayed in the browser" src="image/C13927_18_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 18.2: The test report as displayed in the browser</p>
			<p>You will see a list of failed tests with the text from the <strong class="source-inline">DisplayName</strong> annotation. For each failed test, you can drill down into the test. This provides a much better format with which to display the test results.</p>
			<p>Next, we'll fix the broken test and validate the other rules.</p>
			<h2 id="_idParaDest-338"><a id="_idTextAnchor350"/>Exercise 2: Writing a Successful Test</h2>
			<p>Now that we have a test that fails, we'll need to fix the test and add test methods to verify the starting and ending timestamps:</p>
			<ol>
				<li value="1">Edit <strong class="source-inline">CoordScheduleTest</strong> in IntelliJ.</li>
				<li>Replace the <strong class="source-inline">testFrequency()</strong> method with the following code:<p class="source-code">@Test</p><p class="source-code">@DisplayName("Frequency must be less than 1440")</p><p class="source-code">void testFrequency() {</p><p class="source-code">    CoordSchedule schedule = new CoordSchedule(</p><p class="source-code">            "2020-12-15T15:32Z",</p><p class="source-code">            "2020-12-30T05:15Z",</p><p class="source-code">            60</p><p class="source-code">    );</p><p class="source-code">    int frequency = schedule.getFrequency();</p><p class="source-code">    Assertions.assertTrue(frequency</p><p class="source-code">            &lt; CoordSchedule.MAX_FREQUENCY);</p><p class="source-code">    Assertions.assertTrue(frequency</p><p class="source-code">            &gt; CoordSchedule.MIN_FREQUENCY);</p><p class="source-code">}</p></li>
				<li>Add a test method to check for an incorrectly formatted date:<p class="source-code">@Test</p><p class="source-code">@DisplayName("Timestamp will be null if not formatted correctly")</p><p class="source-code">void testStartingTimestamps() {</p><p class="source-code">    CoordSchedule schedule = new CoordSchedule(</p><p class="source-code">            "2020/12/15T15:32Z",</p><p class="source-code">            "2020-12-15T15:35Z",</p><p class="source-code">            60</p><p class="source-code">    );</p><p class="source-code">    Date starting = schedule.getStartingTimestampAsDate();</p><p class="source-code">    // Timestamp is not formatted properly.</p><p class="source-code">    Assertions.assertNull(starting);</p><p class="source-code">}</p></li>
				<li>Add a test method to verify that the ending timestamp is later than the starting timestamp:<p class="source-code">@Test</p><p class="source-code">@DisplayName("Ending timestamp must be after starting")</p><p class="source-code">void testTimestamps() {</p><p class="source-code">    CoordSchedule schedule = new CoordSchedule(</p><p class="source-code">            "2020-12-15T15:32Z",</p><p class="source-code">            "2020-12-15T15:35Z",</p><p class="source-code">            60</p><p class="source-code">    );</p><p class="source-code">    Date starting = schedule.getStartingTimestampAsDate();</p><p class="source-code">    Assertions.assertNotNull(starting);</p><p class="source-code">    Date ending = schedule.getEndingTimestampAsDate();</p><p class="source-code">    Assertions.assertNotNull(ending);</p><p class="source-code">    Assertions.assertTrue(ending.after(starting));</p><p class="source-code">}</p></li>
				<li>Click on the <strong class="source-inline">Gradle</strong> pane. Expand <strong class="source-inline">Tasks</strong> and then expand <strong class="source-inline">verification</strong>.</li>
				<li>Double-click on <strong class="source-inline">Test</strong>. This runs the Gradle <strong class="source-inline">test</strong> task. This will show an output like the following (with most of the stack trace omitted for clarity):<p class="source-code">Testing started at 14:59 ...</p><p class="source-code">14:59:33: Executing tasks ':cleanTest :test --tests "com.packtpub.testing.CoordScheduleTest"'...</p><p class="source-code">&gt; Task :cleanTest</p><p class="source-code">&gt; Task :compileJava</p><p class="source-code">&gt; Task :processResources NO-SOURCE</p><p class="source-code">&gt; Task :classes</p><p class="source-code">&gt; Task :compileTestJava</p><p class="source-code">&gt; Task :processTestResources NO-SOURCE</p><p class="source-code">&gt; Task :testClasses</p><p class="source-code">&gt; Task :test</p><p class="source-code">java.text.ParseException: Unparseable date: "2020/12/15T15:32Z"</p><p class="source-code">at java.base/java.text.DateFormat.parse(DateFormat.java:395)</p><p class="source-code">at com.packtpub.testing.CoordSchedule.parseTimestamp(CoordSchedule.java:64)</p><p class="source-code">at com.packtpub.testing.CoordSchedule.getStartingTimestampAsDate(CoordSchedule.java:49)</p><p class="source-code">at com.packtpub.testing.CoordScheduleTest.testStartingTimestamps(CoordScheduleTest.java:41)</p><p class="source-code">…</p><p class="source-code">BUILD SUCCESSFUL in 0s</p><p class="source-code">4 actionable tasks: 4 executed</p><p class="source-code">14:59:34: Tasks execution finished ':cleanTest :test --tests "com.packtpub.testing.CoordScheduleTest"'.</p></li>
			</ol>
			<p>Notice that the incorrectly formatted timestamp shows an exception stack trace (truncated here for length). This was expected (the input timestamp was not correct), so it is not an error. These tests should succeed.</p>
			<h2 id="_idParaDest-339"><a id="_idTextAnchor351"/>Deciding What to Test</h2>
			<p>You can always write more tests, so, sooner or later, you need to decide on what you really do need to test.</p>
			<p>It is normally a good idea to focus on:</p>
			<ul>
				<li>What code, if in error, would cause the greatest impact?</li>
				<li>What code is depended on the most by other code? This code should get extra tests.</li>
				<li>Are you checking for edge cases, such as maximum and minimum values?</li>
			</ul>
			<p>In order to simplify writing better tests, and especially to deal with a few edge cases, you may want to use parameterized tests.</p>
			<h2 id="_idParaDest-340"><a id="_idTextAnchor352"/>Writing Parameterized Tests</h2>
			<p>A parameterized test is a unit test that accepts parameters. Instead of all the test values being set in the <strong class="source-inline">test</strong> method, you can pass parameters. This makes it much easier to test multiple cases. For example, when processing string data, you may want to test multiple strings, including null and empty strings.</p>
			<p>With a parameterized test, you need to specify the parameters you want to pass to the test. JUnit will pass these parameters as actual method parameters to your test. For example, look at the following:</p>
			<p class="source-code">@ParameterizedTest</p>
			<p class="source-code">@ValueSource(ints = { 10000, 11000 })</p>
			<p class="source-code">public void testMetStepGoal(int steps) {</p>
			<p class="source-code">    DailyGoal dailyGoal = new DailyGoal(DAILY_GOAL);</p>
			<p class="source-code">    Assertions.assertTrue(dailyGoal.hasMetGoal(steps));</p>
			<p class="source-code">}</p>
			<p>In this example, you use a <strong class="source-inline">@ParameterizedTest</strong> annotation instead of <strong class="source-inline">@Test</strong>. This tells JUnit to look for the parameters.</p>
			<p>The <strong class="source-inline">@ValueSource</strong> annotation defines two values to get passed to the <strong class="source-inline">test</strong> method: <strong class="source-inline">10000</strong> and <strong class="source-inline">11000</strong>. In both cases, this test assumes that the passed-in parameters will each result in the <strong class="source-inline">hasMetGoal()</strong> method returning <strong class="source-inline">true</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Parameterized tests make JUnit much more acceptable to someone who uses Spock.</p>
			<p>JUnit will call the <strong class="source-inline">test</strong> method once for each value in the <strong class="source-inline">@ValueSource</strong> list, so two times in this example.</p>
			<p>The <strong class="source-inline">@ValueSource</strong> annotation expects a list of values to pass to the test method. If you have more complex values, you can use the <strong class="source-inline">@CsvSource</strong> annotation instead.</p>
			<p>The <strong class="source-inline">@CsvSource</strong> annotation takes a comma-separated set of values. For example, look at the following:</p>
			<p class="source-code">@ParameterizedTest</p>
			<p class="source-code">@CsvSource({</p>
			<p class="source-code">    "10,     false",</p>
			<p class="source-code">    "9999,   false",</p>
			<p class="source-code">    "10000,  true",</p>
			<p class="source-code">    "20000,  true"</p>
			<p class="source-code">})</p>
			<p class="source-code">public void testHasMetStepGoal(int steps, boolean expected) {</p>
			<p class="source-code">   // …</p>
			<p class="source-code">}</p>
			<p>In this example, the first call to <strong class="source-inline">testHasMetStepGoal()</strong> will return <strong class="source-inline">10</strong> for the <strong class="source-inline">steps</strong> parameter and <strong class="source-inline">false</strong> for the <strong class="source-inline">expected</strong> parameter. Note that JUnit converts the types for you. Similar to <strong class="source-inline">@ValueSource</strong>, each data line results in a separate call to the <strong class="source-inline">test</strong> method.</p>
			<p><strong class="source-inline">@CsvSource</strong> is very handy if you want to pass in a number of values to be compared against each other, or in the case here, where you would want to pass both good and bad values, along with a parameter that indicates whether the test is expected to be <strong class="source-inline">true</strong> or not.</p>
			<p>Because the values within <strong class="source-inline">@CsvSource</strong> are stored as strings, you need some special syntax to handle empty strings, null strings, and strings with spaces:</p>
			<p class="source-code">@CsvSource({</p>
			<p class="source-code">    "'A man, a plan, a canal. Panama',  7",</p>
			<p class="source-code">    "'Able was I ere I saw Elba',  7",</p>
			<p class="source-code">    ", 0",</p>
			<p class="source-code">    "'', 0"</p>
			<p class="source-code">})</p>
			<p>The first line has a string with spaces. Use single quote characters (<strong class="source-inline">'</strong>) to delimit strings with spaces.</p>
			<p>The third line has just a comma for the first parameter. JUnit will pass <strong class="source-inline">null</strong> for this construct.</p>
			<p>The fourth line has two single quotes used to generate an empty string.</p>
			<p>In addition to <strong class="source-inline">@CsvSource</strong>, you can load the data from an external comma-separated value (CSV) file using the <strong class="source-inline">@CsvFileSource </strong>annotation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">JUnit supports a few other ways to get the parameter values, including from a separate file, from a method you write, and more. You can refer to <a href="https://packt.live/2J8oXGU">https://packt.live/2J8oXGU</a> for more information about parameterized tests.</p>
			<h2 id="_idParaDest-341"><a id="_idTextAnchor353"/>Exercise 3: Writing a Parameterized Test</h2>
			<p>Let's assume that you are writing code that accesses a wearable fitness device. One of the things the device tracks is the number of steps the wearer takes on a given day. You can then compare the number of steps taken against a daily goal. Has the wearer met this goal?</p>
			<p>This example demonstrates how to write a parameterized test, based on the daily step goal from <em class="italic">Chapter 6</em>,<em class="italic"> Libraries, Packages, and Modules</em>:</p>
			<ol>
				<li value="1">Edit <strong class="source-inline">build.gradle</strong>.</li>
				<li>Add the following to the dependencies block:<p class="source-code">testImplementation('org.junit.jupiter:junit-jupiter-params:5.4.2')</p></li>
				<li>This dependency brings in support for the parameterized tests.</li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.testing</strong> package in the <strong class="source-inline">src/main/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">DailyGoal</strong> as the class name.</li>
				<li>Enter the following code for this class:<p class="source-code">int dailyGoal = 10000;</p><p class="source-code">public DailyGoal(int dailyGoal) {</p><p class="source-code">    this.dailyGoal = dailyGoal;</p><p class="source-code">}</p><p class="source-code">public boolean hasMetGoal(int steps) {</p><p class="source-code">    if (steps &gt;= dailyGoal) {</p><p class="source-code">        return true;</p><p class="source-code">    }</p><p class="source-code">    return false;</p><p class="source-code">}</p><p>This is the class we will test.</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.testing</strong> package in the <strong class="source-inline">src/test/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">DailyGoalTest</strong> as the class name.</li>
				<li>Enter the following constant for the device wearer's daily step goal:<p class="source-code">public static final int DAILY_GOAL = 10000;</p></li>
				<li>Next, enter a <strong class="source-inline">test</strong> method for step counts that meet or exceed the daily goal:<p class="source-code">@ParameterizedTest</p><p class="source-code">@ValueSource(ints = { 10000, 11000 })</p><p class="source-code">public void testMetStepGoal(int steps) {</p><p class="source-code">    DailyGoal dailyGoal = new DailyGoal(DAILY_GOAL);</p><p class="source-code">    Assertions.assertTrue(dailyGoal.hasMetGoal(steps));</p><p class="source-code">}</p><p>With a daily step goal of <strong class="source-inline">10000</strong> steps, <strong class="source-inline">10000</strong> and <strong class="source-inline">11000</strong> both meet this goal.</p></li>
				<li>Next, we'll test the result when the step count is lower than the daily step goal:<p class="source-code">@ParameterizedTest</p><p class="source-code">@ValueSource(ints = { 10, 9999 })</p><p class="source-code">public void testNotMetStepGoal(int steps) {</p><p class="source-code">    DailyGoal dailyGoal = new DailyGoal(DAILY_GOAL);</p><p class="source-code">    Assertions.assertFalse(dailyGoal.hasMetGoal(steps));</p><p class="source-code">}</p><p>Notice how <strong class="source-inline">9999</strong> is just one step below the goal.</p><p>Next, enter a test method using the <strong class="source-inline">@CsvSource</strong> values for the test parameters:</p><p class="source-code">@ParameterizedTest</p><p class="source-code">@CsvSource({</p><p class="source-code">    "10,     false",</p><p class="source-code">    "9999,   false",</p><p class="source-code">    "10000,  true",</p><p class="source-code">    "20000,  true"</p><p class="source-code">})</p><p class="source-code">public void testHasMetStepGoal(int steps, boolean expected) {</p><p class="source-code">    DailyGoal dailyGoal = new DailyGoal(DAILY_GOAL);</p><p class="source-code">    // Using a lambda will lazily evaluate the expression</p><p class="source-code">    Assertions.assertTrue(</p><p class="source-code">            dailyGoal.hasMetGoal(steps) == expected,</p><p class="source-code">            () -&gt; "With " + steps +</p><p class="source-code">                  " steps, hasMetGoal() should return " +</p><p class="source-code">                    expected);</p><p class="source-code">}</p><p>This test method is a bit more complicated. Each call to the test passes two parameters. </p><p>The lambda expression in the call to <strong class="source-inline">Assertions.assertTrue()</strong> is the error message. Using a lambda expression means that the error message won't get evaluated unless the test assertion fails.</p><p>When you run this test class, it should succeed.</p></li>
			</ol>
			<h2 id="_idParaDest-342"><a id="_idTextAnchor354"/>When Tests Won't Work—Disabling Tests</h2>
			<p>The <strong class="source-inline">@Disabled</strong> annotation allows you to disable a test. Normally, it is not good practice to simply disable any test that fails. This defeats the whole idea of testing. However, you may come across times where, due to some condition outside of your control, you just must disable tests. For example, if you are using the code from another group, and that group has broken an expectation or introduced a bug in its code, you may need to—temporarily—disable tests that depend on that code:</p>
			<p class="source-code">@Disabled("Until platform team fixes issue 5578")</p>
			<p class="source-code">@Test</p>
			<p class="source-code">public void testThatShouldNotFail() {</p>
			<p class="source-code">   // …</p>
			<p class="source-code">}</p>
			<p>You can add the <strong class="source-inline">@Disabled</strong> annotation to an entire test class, or just to a test method, as shown in the preceding code block.</p>
			<h2 id="_idParaDest-343"><a id="_idTextAnchor355"/>Test Setup</h2>
			<p>In many tests, you may need to perform some setup work, as well as cleanup work after the test. For example, you may want to initialize the objects that are needed for the test. JUnit provides a number of life cycle annotations to support such work.</p>
			<p>If you annotate a method with <strong class="source-inline">@BeforeEach</strong>, JUnit will run that method before running each test method. Similarly, methods annotated with <strong class="source-inline">@AfterEach</strong> are run after each test method. If you want to run the setup or clean up the code just once for a test class, you can use <strong class="source-inline">@BeforeAll</strong> and <strong class="source-inline">@AfterAll</strong>. These two methods come with some restrictions, though.</p>
			<p>JUnit creates a new instance of your test class for each test method. This ensures your tests run in isolation and avoid what is called test pollution, where one test impacts another test. Normally, this is a good thing, because tracking down test failures that depend on the order of the test execution is particularly frustrating.</p>
			<p>Because JUnit creates a new instance of the test class for each test method, the <strong class="source-inline">@BeforeAll</strong> and <strong class="source-inline">@AfterAll</strong> methods must be <strong class="source-inline">static</strong>. Additionally, the data that these methods initialize or clean up should also be <strong class="source-inline">static</strong>.</p>
			<p>If you don't want to create <strong class="source-inline">static</strong> methods, you can change JUnit's policy of creating a new instance of the test class for each test method.</p>
			<p>If you annotate your test class with the following, JUnit will create just one instance of the test class shared by all the test methods:</p>
			<p class="source-code">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</p>
			<p>You'll see an example of this in the <em class="italic">Mocking</em> section.</p>
			<p><em class="italic">Exercise 4</em>,<em class="italic"> Using Test Setup and Cleanup Methods</em> demonstrates how to code these setup and cleanup methods.</p>
			<h2 id="_idParaDest-344"><a id="_idTextAnchor356"/>Exercise 4: Using Test Setup and Cleanup Methods</h2>
			<p>This exercise demonstrates a simple unit test with placeholder methods for both setting up and cleaning up. The test will verify a simple class that converts Celsius temperature values to Fahrenheit:</p>
			<ol>
				<li value="1">Right-click on the <strong class="source-inline">com.packtpub.testing</strong> package in the <strong class="source-inline">src/main/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">TempConverter</strong> as the class name.</li>
				<li>Enter the following method:<p class="source-code">public static double convertToF(double degreesC) {</p><p class="source-code">    double degreesF = (degreesC * 9/5) + 32;</p><p class="source-code">    // Round to make nicer output.</p><p class="source-code">    return Math.round(degreesF * 10.0) / 10.0;</p><p class="source-code">}</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.testing</strong> package in the <strong class="source-inline">src/test/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">TempConverterTest</strong> as the class name.</li>
				<li>Enter the following test method that checks for <strong class="source-inline">-40.0</strong> degrees on both temperature scales:<p class="source-code">@Test</p><p class="source-code">public void testFahrenheitWhenCold() {</p><p class="source-code">    // -40 C == -40 F</p><p class="source-code">    double degreesC = -40.0;</p><p class="source-code">    double degreesF = TempConverter.convertToF(degreesC);</p><p class="source-code">    Assertions.assertEquals(degreesC, degreesF);</p><p class="source-code">}</p><p>This temperature is unpleasant regardless of the temperature scale used.</p><p>Notice how this test uses the <strong class="source-inline">assertEquals()</strong> assertion.</p></li>
				<li>Enter another test method to ensure the conversion works when the temperature is <strong class="source-inline">100.0</strong> degrees Celsius:<p class="source-code">@Test</p><p class="source-code">public void testFahrenheitWhenHot() {</p><p class="source-code">    // 100 C == 212 F</p><p class="source-code">    double degreesC = 100.0;</p><p class="source-code">    double degreesF = TempConverter.convertToF(degreesC);</p><p class="source-code">    Assertions.assertEquals(212.0, degreesF);</p><p class="source-code">}</p></li>
				<li>Next, enter a method to be run before all the tests:<p class="source-code">@BeforeAll</p><p class="source-code">public static void runBeforeAllTests() {</p><p class="source-code">    System.out.println("Before all tests");</p><p class="source-code">}</p><p>Note that this method must be static (or you must use the class-level annotation listed previously).</p><p>Normally, you would use this method to set up complex test data instead of just printing a value.</p></li>
				<li>Enter a method to be run after all the tests:<p class="source-code">@AfterAll</p><p class="source-code">public static void runAfterAllTests() {</p><p class="source-code">    System.out.println("After all tests");</p><p class="source-code">}</p><p>Again, this method must be static.</p></li>
				<li>Now, enter a method to be run before each of the two test methods:<p class="source-code">@BeforeEach</p><p class="source-code">public void runBeforeEachTest() {</p><p class="source-code">    System.out.println("Before each test");</p><p class="source-code">}</p></li>
				<li>Similarly, enter a method to be run after each test method:<p class="source-code">@AfterEach</p><p class="source-code">public void runAfterEachTest() {</p><p class="source-code">    System.out.println("After each test");</p><p class="source-code">}</p></li>
				<li>Click on the green arrow by the class statement and select <strong class="source-inline">Run 'TempConverterTest'</strong>. The test should run without errors.<p>You will see an output like the following:</p><p class="source-code">Before all tests</p><p class="source-code">Before each test</p><p class="source-code">After each test</p><p class="source-code">Before each test</p><p class="source-code">After each test</p><p class="source-code">After all tests</p><p class="source-code">BUILD SUCCESSFUL in 0s</p><p class="source-code">4 actionable tasks: 2 executed, 2 up-to-date</p><p>Note that the <strong class="source-inline">@BeforeAll</strong> method is only run once. Then, with each test method, the <strong class="source-inline">@BeforeEach</strong> and <strong class="source-inline">@AfterEach</strong> methods are executed. Finally, the <strong class="source-inline">@AfterAll</strong> method is executed.</p></li>
			</ol>
			<h2 id="_idParaDest-345"><a id="_idTextAnchor357"/>Mocking</h2>
			<p>A unit test is supposed to test just one Java class. There are times, however, where a class is heavily dependent on other classes, and perhaps even external systems such as databases or handheld devices. In these cases, a technique called mocking proves useful. Mocking is where you mo<a id="_idTextAnchor358"/>ck out the other dependencies so that you can test just the class you want to look at.</p>
			<p>A <strong class="bold">mock</strong> is a class used just for testing that pretends to be some external dependency. With a mocking framework, you can examine a mocked class to ensure that the right methods were called the right number of times with the right parameters.</p>
			<p>Mocking works great when you have code that queries for data in a database or external system. What you do is create an instance that is a mock for a particular class. Then, when the query method gets called, you have the mock return arbitrary test data. This avoids the dependency on the external system.</p>
			<p>Mocking also works great when you want to verify that a particular method was called, without actually calling that method. Think of an email notifier that sends email messages on some kind of failure. In a unit test, you don't want actual email messages to get sent. (In an integration or functional test, however, you should verify that the messages do get sent.)</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor359"/>Testing with Mocks Using Mockito</h2>
			<p>Mockito is a great framework for adding mocks to your testing. Say that you have an application that monitors workflows running in a big data cluster; these could be Oozie workflows mentioned previously, or any other type of workflows.</p>
			<p>Your application gets the status of the workflows by calling a remote web service. In your unit tests, you don't want to call the remote web service. Instead, you just want to mock out the external system.</p>
			<p>The code we want to test will look something like the following:</p>
			<p class="source-code">WorkflowStatus workflowStatus = workflowClient.getStatus(id);</p>
			<p class="source-code">if (!workflowStatus.isOk()) {</p>
			<p class="source-code">    emailNotifier.sendFailureEmail(workflowStatus);</p>
			<p class="source-code">}</p>
			<p>First, the code calls a remote web service to get the status of a workflow, based on the workflow ID. Then, if the workflow status is not OK, the code sends an email message. For unit tests, we need to mock both the call to <strong class="source-inline">getStatus()</strong> and the call to <strong class="source-inline">sendFailureEmail()</strong>.</p>
			<p>The <strong class="source-inline">WorkflowClient</strong> class manages the HTTP communication to the remote web service.</p>
			<p>A call to the <strong class="source-inline">getStatus()</strong> method with a workflow ID returns the status of that given workflow:</p>
			<p class="source-code">WorkflowStatus workflowStatus = workflowClient.getStatus(id);</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can refer to <em class="italic">Chapter 9</em>, <em class="italic">Working with HTTP</em>, for more information about HTTP and web services.</p>
			<p>With Mockito, the first thing you need to do is to create a mock of the <strong class="source-inline">WorkflowClient</strong> class:</p>
			<p class="source-code">import static org.mockito.Mockito.*;</p>
			<p class="source-code">workflowClient = mock(WorkflowClient.class);</p>
			<p>The next step is to stub out the call to <strong class="source-inline">getStatus()</strong>. In Mockito terminology, when something happens, then a particular result is returned. In this case, the stubbed code should return a prebuilt <strong class="source-inline">WorkflowStatus</strong> object with the desired status of a test:</p>
			<p class="source-code">String id = "WORKFLOW-1";</p>
			<p class="source-code">WorkflowStatus workflowStatus =   new WorkflowStatus(id, WorkflowStatus.OK);</p>
			<p class="source-code">when(workflowClient.getStatus(id)).thenReturn(workflowStatus);</p>
			<p>In this code, we first set up a string of the workflow ID and then construct a <strong class="source-inline">WorkflowStatus</strong> object with a successful status (<strong class="source-inline">OK</strong>). The crucial code starts with <strong class="source-inline">when()</strong>. Read this code when the <strong class="source-inline">getStatus</strong> call is made with the given ID on the mock <strong class="source-inline">WorkflowClient</strong> class, and then return our prebuilt <strong class="source-inline">WorkflowStatus</strong> object.</p>
			<p>In this case, Mockito is looking for an exact match. The passed-in workflow ID must match, or the mock will not return the specified result. You can also specify that the mock should return the result with any input workflow ID, as shown in the following:</p>
			<p class="source-code">when(workflowClient.getStatus(anyString())).thenReturn(workflowStatus);</p>
			<p>In this case, the <strong class="source-inline">anyString()</strong> call means any string value passed in will match. Note that Mockito has other calls, such as <strong class="source-inline">anyInt()</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Mockito includes very good documentation at <a href="https://packt.live/31xFtXu">https://packt.live/2P6ogl9</a>. You can do a lot more with mocks than the examples shown here, but you should avoid the temptation to mock everything.</p>
			<p>With the call to the external web service mocked out, the next step is to check whether a failure email gets sent. To do this, mock the class that sends email failure messages:</p>
			<p class="source-code">import static org.mockito.Mockito.*;</p>
			<p class="source-code">EmailNotifier emailNotifier = mock(EmailNotifier.class);</p>
			<p>In the code we want to test, the email message is sent only on failures. So, we will want to test two things:</p>
			<ul>
				<li>The email is not sent if the status is OK.</li>
				<li>The email is sent if the status is <em class="italic">not</em> OK.</li>
			</ul>
			<p>In both cases, we will use Mockito to check the number of times the <strong class="source-inline">sendFailureEmail()</strong> method gets called. If it is zero times, then no email is sent. If it is one or more times, then an email message is sent.</p>
			<p>To ensure that no email message was sent, use code like the following:</p>
			<p class="source-code">verify(emailNotifier, times(0)).sendFailureEmail(workflowStatus);</p>
			<p>This code checks that the <strong class="source-inline">sendFailureEmail()</strong> method was called zero times, that is, not called at all.</p>
			<p>To verify that the email message was sent, you can specify the number of times as <strong class="source-inline">1</strong>:</p>
			<p class="source-code">verify(emailNotifier, times(1)).sendFailureEmail(workflowStatus);</p>
			<p>You can also use Mockito's shortcut, which assumes the method gets called just once:</p>
			<p class="source-code">verify(emailNotifier).sendFailureEmail(workflowStatus);</p>
			<p>In more complex tests, you may want to ensure a method gets called a few times.</p>
			<p>As mentioned previously, JUnit creates a new instance of your test class for each test method. When mocking, you may want to set up the mocks once, instead of every time a test method runs.</p>
			<p>To tell JUnit to create just one instance of the test class and share it among all test methods, add the following annotation to the class:</p>
			<p class="source-code">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</p>
			<p class="source-code">public class WorkflowMonitorTest {</p>
			<p class="source-code">    private EmailNotifier emailNotifier;</p>
			<p class="source-code">    private WorkflowClient workflowClient;</p>
			<p class="source-code">    private WorkflowMonitor workflowMonitor;</p>
			<p class="source-code">    @BeforeAll</p>
			<p class="source-code">    public void setUpMocks() {</p>
			<p class="source-code">        emailNotifier = mock(EmailNotifier.class);</p>
			<p class="source-code">        workflowClient = mock(WorkflowClient.class);</p>
			<p class="source-code">        workflowMonitor =</p>
			<p class="source-code">                new WorkflowMonitor(emailNotifier, workflowClient);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">setUpMocks()</strong> method will get called once before all the test methods run. It sets up the two mock classes and then passes the mock objects to the constructor for the <strong class="source-inline">WorkflowMonitor</strong> class.</p>
			<p>The following exercise shows all these classes together, using Mockito-based mocks in the unit test.</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor360"/>Exercise 5: Using Mocks when Testing</h2>
			<p>This exercise creates a <strong class="source-inline">WorkflowMonitor</strong> class and then uses mock objects to handle external dependencies:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">src/main/java</strong> folder in the IntelliJ <strong class="source-inline">Project</strong> pane, create a new Java package.</li>
				<li>Enter <strong class="source-inline">com.packtpub.workflow</strong> as the package name.</li>
				<li>In the <strong class="source-inline">src/test/java</strong> folder, create a new Java package.</li>
				<li>Enter the same name, <strong class="source-inline">com.packtpub.workflow</strong>.</li>
				<li>Edit <strong class="source-inline">build.gradle</strong>.</li>
				<li>Add the following to the dependencies block:<p class="source-code">testImplementation("org.mockito:mockito-core:2.+")</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.workflow</strong> package in the <strong class="source-inline">src/main/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">WorkflowStatus</strong> as the class name.</li>
				<li>Enter the following code for this simple value object class:<p class="source-code">public static final String OK = "OK";</p><p class="source-code">public static final String ERROR = "ERROR";</p><p class="source-code">private String id;</p><p class="source-code">private String status = OK;</p><p class="source-code">public WorkflowStatus(String id, String status) {</p><p class="source-code">    this.id = id;</p><p class="source-code">    this.status = status;</p><p class="source-code">}</p><p class="source-code">public boolean isOk() {</p><p class="source-code">    if (OK.equals(status)) {</p><p class="source-code">        return true;</p><p class="source-code">    }</p><p class="source-code">    return false;</p><p class="source-code">}</p><p>In a real system, this class would hold additional values, such as when the workflow started, when it stopped, and other information on the workflow. The status information was simplified for this exercise.</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.workflow</strong> package in the <strong class="source-inline">src/main/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">EmailNotifier</strong> as the class name.</li>
				<li>Enter the following method:<p class="source-code">public void sendFailureEmail(WorkflowStatus workflowStatus) {</p><p class="source-code">    // This would have actual code...</p><p class="source-code">}</p><p>In a real application, this would send email messages. For simplicity, we'll leave that blank.</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.workflow</strong> package in the <strong class="source-inline">src/main/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">WorkflowClient</strong> as the class name.</li>
				<li>Enter the following method:<p class="source-code">public WorkflowStatus getStatus(String id) {</p><p class="source-code">    // This would use HTTP to get the status.</p><p class="source-code">    return new WorkflowStatus(id, WorkflowStatus.OK);</p><p class="source-code">}</p><p>Again, this is simplified.</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.workflow</strong> package in the <strong class="source-inline">src/main/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">WorkflowMonitor</strong> as the class name.</li>
				<li>Enter the following properties:<p class="source-code">private EmailNotifier emailNotifier;</p><p class="source-code">private WorkflowClient workflowClient;</p></li>
				<li>Right-click on the class, choose <strong class="source-inline">Generate…</strong> and then choose <strong class="source-inline">Constructor</strong>.</li>
				<li>Select both properties and then click on <strong class="source-inline">OK</strong>.</li>
				<li>Enter the following method:<p class="source-code">public void checkStatus(String id) {</p><p class="source-code">    WorkflowStatus workflowStatus = workflowClient.getStatus(id);</p><p class="source-code">    if (!workflowStatus.isOk()) {</p><p class="source-code">        emailNotifier.sendFailureEmail(workflowStatus);</p><p class="source-code">    }</p><p class="source-code">}</p><p>This is the method we will test using mock objects.</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.workflow</strong> package in the <strong class="source-inline">src/test/java</strong> folder. Select <strong class="source-inline">New</strong> and <strong class="source-inline">Java Class</strong>.</li>
				<li>Enter <strong class="source-inline">WorkflowMonitorTest</strong> as the class name.</li>
				<li>Annotate the class so that we can create a <strong class="source-inline">@BeforeAll</strong> method:<p class="source-code">@TestInstance(TestInstance.Lifecycle.PER_CLASS)</p></li>
				<li>Enter the following properties and set up the <strong class="source-inline">@BeforeAll</strong> method:<p class="source-code">private EmailNotifier emailNotifier;</p><p class="source-code">private WorkflowClient workflowClient;</p><p class="source-code">private WorkflowMonitor workflowMonitor;</p><p class="source-code">@BeforeAll</p><p class="source-code">public void setUpMocks() {</p><p class="source-code">    emailNotifier = mock(EmailNotifier.class);</p><p class="source-code">    workflowClient = mock(WorkflowClient.class);</p><p class="source-code">    workflowMonitor =       new WorkflowMonitor(emailNotifier, workflowClient);</p><p class="source-code">}</p><p>This sets up the mock objects and then instantiates a <strong class="source-inline">WorkflowMonitor</strong> object using the mocked dependencies.</p></li>
				<li>Enter the following test method to test a case when the workflow is successful:<p class="source-code">@Test</p><p class="source-code">public void testSuccess() {</p><p class="source-code">    String id = "WORKFLOW-1";</p><p class="source-code">    WorkflowStatus workflowStatus =       new WorkflowStatus(id, WorkflowStatus.OK);</p><p class="source-code">    when(workflowClient.getStatus(id)).thenReturn(workflowStatus);</p><p class="source-code">    workflowMonitor.checkStatus(id);</p><p class="source-code">    verify(emailNotifier, times(0)).sendFailureEmail(workflowStatus);</p><p class="source-code">}</p><p>We should also test a case where the workflow status is not OK.</p></li>
				<li>Enter the following test method:<p class="source-code">    @Test</p><p class="source-code">    public void testFailure() {</p><p class="source-code">        String id = "WORKFLOW-1";</p><p class="source-code">        WorkflowStatus workflowStatus =           new WorkflowStatus(id, WorkflowStatus.ERROR);</p><p class="source-code">        when(workflowClient.getStatus(anyString()))          .thenReturn(workflowStatus);</p><p class="source-code">        workflowMonitor.checkStatus(id);</p><p class="source-code">        verify(emailNotifier).sendFailureEmail(workflowStatus);</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Click on the green arrow by the class statement and select <strong class="source-inline">Run 'WorkflowMonitorTest'</strong>. The test should run without errors.</li>
			</ol>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor361"/>Activity 1: Counting the Words in the String</h2>
			<p>Word count is of paramount value in the publishing industry. Write a class that, given a string, will count all the words in the string. </p>
			<ol>
				<li value="1">You can use the <strong class="source-inline">split()</strong> method to break up the string into words, using the <strong class="source-inline">\s+</strong> regular expression to separate the words, which matches whitespace characters(that is, spaces and tabs). Name this class <strong class="source-inline">WordCount</strong>.</li>
				<li>Trim the input string to remove any spaces at the beginning or end.<p>Note that an empty string should generate zero for the word count; so should a <strong class="source-inline">null</strong> string. Input strings that are all spaces should generate zero as well.</p></li>
				<li>Once you have the class written, write a parameterized unit test for that class. Use the parameters and <strong class="source-inline">@CsvSource</strong> to pass in a string along with the expected word count. Be sure to include punctuation such as commas and periods in your input strings. In addition to this, be sure to include input strings with null strings and empty strings in the input parameters.<p class="callout-heading">Note</p><p class="callout">The solution for this activity can be found on page 569.</p></li>
			</ol>
			<h1 id="_idParaDest-349"><a id="_idTextAnchor362"/>Summary</h1>
			<p>This chapter introduced unit testing. Testing is good and you want to write tests for all your Java code. If you write successful tests, then you can feel confident your code was written correctly.</p>
			<p>JUnit provides the most popular testing framework for writing Java unit tests, though there are other frameworks you can try as well. The <strong class="source-inline">@Test</strong> annotation on a method tells JUnit that the given code is considered a test. JUnit will execute the test and see whether it succeeds. The JUnit assertions class contains a few <strong class="source-inline">static</strong> methods that you can use to verify the test results.</p>
			<p>A parameterized test is a test into which you pass a few parameters. This is very useful when writing tests for code that you want to ensure can handle a variety of inputs. Mocking is a technique where you mock out external dependencies so that a unit test can concentrate on testing just one class.</p>
		</div>
	</body></html>