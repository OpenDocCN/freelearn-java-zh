["```java\ncase class Person(name: String, age: Int)\ncase class AgeNegativeException(message: String) extends Exception(message)\n\ndef createPerson(description: String): Person = {\n  val split = description.split(\" \")\n  val age = split(1).toInt\n  if (age < 0)\n    throw AgeNegativeException(s\"age: $age should be > 0\")\n  else\n    Person(split(0), age)\n```", "```java\nscala> createPerson(\"John 25\")\nres0: Person = Person(John,25)\n\nscala> createPerson(\"John25\")\njava.lang.ArrayIndexOutOfBoundsException: 1\n  at .createPerson(<console>:17)\n  ... 24 elided\n\nscala> createPerson(\"John -25\")\nAgeNegativeException: age: -25 should be > 0\n  at .createPerson(<console>:19)\n  ... 24 elided\n\nscala> createPerson(\"John 25.3\")\njava.lang.NumberFormatException: For input string: \"25.3\"\n  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)\n  at java.lang.Integer.parseInt(Integer.java:580)\n  at java.lang.Integer.parseInt(Integer.java:615)\n  at scala.collection.immutable.StringLike.toInt(StringLike.scala:301)\n  at scala.collection.immutable.StringLike.toInt$(StringLike.scala:301)\n  at scala.collection.immutable.StringOps.toInt(StringOps.scala:29)\n  at .createPerson(<console>:17)\n  ... 24 elided\n```", "```java\ndef averageAge(descriptions: Vector[String]): Double = {\n  val total = descriptions.map(createPerson).map(_.age).sum\n  total / descriptions.length\n}\n```", "```java\nimport scala.util.control.NonFatal\ndef personsSummary(personsInput: String): String = {\n  val descriptions = personsInput.split(\"\\n\").toVector\n  val avg = try {\n    averageAge(descriptions)\n  } catch {\n    case e:AgeNegativeException =>\n      println(s\"one of the persons has a negative age: $e\")\n      0\n    case NonFatal(e) =>\n      println(s\"something was wrong in the input: $e\")\n      0\n  }\n  s\"${descriptions.length} persons with an average age of $avg\"\n}\n```", "```java\nscala> personsSummary(\n  \"\"\"John 25\n    |Sharleen 45\"\"\".stripMargin)\nres1: String = 2 persons with an average age of 35.0\n\nscala> personsSummary(\n  \"\"\"John 25\n    |Sharleen45\"\"\".stripMargin)\nsomething was wrong in the input: java.lang.ArrayIndexOutOfBoundsException: 1\nres2: String = 2 persons with an average age of 0.0\n\nscala> personsSummary(\n \"\"\"John -25\n |Sharleen 45\"\"\".stripMargin)\none of the persons has a negative age: $line5.$read$$iw$$iw$AgeNegativeException: age should be > 0\nres3: String = 2 persons with an average age of 0.0\n```", "```java\nimport java.io.IOException\nimport java.net.URL\nimport scala.annotation.tailrec\n\nval stream = new URL(\"https://www.packtpub.com/\").openStream()\nval htmlPage: String =\n  try {\n    @tailrec\n    def loop(builder: StringBuilder): String = {\n      val i = stream.read()\n      if (i != -1)\n        loop(builder.append(i.toChar))\n      else\n        builder.toString()\n    }\n    loop(StringBuilder.newBuilder)\n  } catch {\n    case e: IOException => s\"cannot read URL: $e\"\n  }\n  finally {\n    stream.close()\n  }\n```", "```java\nval htmlPage2 = scala.io.Source.fromURL(\"https://www.packtpub.com/\").mkString\n```", "```java\ndef pureSquare(x: Int): Int = x * x\nval pureExpr = pureSquare(4) + pureSquare(3)\n// pureExpr: Int = 25\n\nval pureExpr2 = 16 + 9\n// pureExpr2: Int = 25\n```", "```java\nvar globalState = 1\ndef impure(x: Int): Int = {\n  globalState = globalState + x\n  globalState\n}\nval impureExpr = impure(3)\n// impureExpr: Int = 4\nval impureExpr2 = 4\n\n```", "```java\nimport scala.util.Random\ndef impureRand(): Int = Random.nextInt()\nimpureRand()\n//res0: Int = -528134321\nval impureExprRand = impureRand() + impureRand()\n//impureExprRand: Int = 681209667\nval impureExprRand2 = -528134321 + -528134321\n```", "```java\ndef pureRand(seed: Int): Int = new Random(seed).nextInt()\npureRand(10)\n//res1: Int = -1157793070\nval pureExprRand = pureRand(10) + pureRand(10)\n//pureExprRand: Int = 1979381156\nval pureExprRand2 = -1157793070 + -1157793070\n//pureExprRand2: Int = 1979381156\n```", "```java\ndef impurePrint(): Unit = println(\"Hello impure\")\nval impureExpr1: Unit = impurePrint()\nval impureExpr2: Unit = ()\n```", "```java\ndef foldLeft[B](z: B)(op: (B, A) => B): B = {\n  var result = z\n  this foreach (x => result = op(result, x))\n  result\n}\n```", "```java\ncase class Rectangle(width: Double, height: Double)\n\ndef area(r: Rectangle): Double =\n  if (r.width > 5 || r.height > 5)\n    throw new IllegalArgumentException(\"too big\")\n  else\n    r.width * r.height\n```", "```java\nval area1 = area(3, 2)\nval area2 = area(4, 2)\n\nval total = try {\n  area1 + area2\n} catch {\n  case e: IllegalArgumentException => 0\n}\n```", "```java\nval total = try {\n  area(3, 2) + area(4, 2)\n} catch {\n  case e: IllegalArgumentException => 0\n}\n```", "```java\nval area1 = area(6, 2)\nval area2 = area(4, 2)\n\nval total = try {\n  area1 + area2\n} catch {\n  case e: IllegalArgumentException => 0\n}\n```", "```java\nval total = try {\n  area(6, 2) + area(4, 2)\n} catch {\n  case e: IllegalArgumentException => 0\n}\n```", "```java\nsealed trait Option[+A]\ncase class Some[A](value: A) extends Option[A]\ncase object None extends Option[Nothing]\n```", "```java\nval opt0: Option[Int] = None\n// opt0: Option[Int] = None\n\nval opt1: Option[Int] = Some(1)\n// opt1: Option[Int] = Some(1)\n\nval list0 = List.empty[String]\nlist0.headOption\n// res0: Option[String] = None\nlist0.lastOption\n// res1: Option[String] = None\n\nval list3 = List(\"Hello\", \"World\")\nlist3.headOption\n// res2: Option[String] = Some(Hello)\nlist3.lastOption\n// res3: Option[String] = Some(World)\n```", "```java\ndef personDescription(name: String, db: Map[String, Int]): String =\n  db.get(name) match {\n    case Some(age) => s\"$name is $age years old\"\n    case None => s\"$name is not present in db\"\n  }\n\nval db = Map(\"John\" -> 25, \"Rob\" -> 40)\npersonDescription(\"John\", db)\n// res4: String = John is 25 years old\npersonDescription(\"Michael\", db)\n// res5: String = Michael is not present in db\n```", "```java\ndef personDesc(name: String, db: Map[String, Int]): String = {\n  val optString: Option[String] = db.get(name).map(age => s\"$name is \n  $age years old\")\n  optString.getOrElse(s\"$name is not present in db\")\n}\n```", "```java\ndef averageAgeA(name1: String, name2: String, db: Map[String, Int]): Option[Double] = {\n  val optOptAvg: Option[Option[Double]] =\n    db.get(name1).map(age1 =>\n      db.get(name2).map(age2 =>\n        (age1 + age2).toDouble / 2))\n  optOptAvg.flatten\n}\nval db = Map(\"John\" -> 25, \"Rob\" -> 40)\naverageAge(\"John\", \"Rob\", db)\n// res6: Option[Double] = Some(32.5)\naverageAge(\"John\", \"Michael\", db)\n// res7: Option[Double] = None\n```", "```java\ndef averageAgeB(name1: String, name2: String, db: Map[String, Int]): Option[Double] =\n  db.get(name1).flatMap(age1 =>\n    db.get(name2).map(age2 =>\n      (age1 + age2).toDouble / 2))\n```", "```java\ndef averageAgeC(name1: String, name2: String, db: Map[String, Int]): Option[Double] =\n  for {\n    age1 <- db.get(name1)\n    age2 <- db.get(name2)\n  } yield (age1 + age2).toDouble / 2\n```", "```java\nfor {\n  i <- Vector(\"one\", \"two\")\n  j <- Vector(1, 2, 3)\n} yield (i, j)\n// res8: scala.collection.immutable.Vector[(String, Int)] = \n// Vector((one,1), (one,2), (one,3), (two,1), (two,2), (two,3))\n```", "```java\ndef nbOfMonthsSaving(params: RetCalcParams, \n                     returns: Returns): Option[Int] = {\n  import params._\n  @tailrec\n  def loop(months: Int): Int = {\n    val (capitalAtRetirement, capitalAfterDeath) = \n      simulatePlan(returns, params, months)\n\n    if (capitalAfterDeath > 0.0)\n      months\n    else\n      loop(months + 1)\n  }\n\n  if (netIncome > currentExpenses)\n    Some(loop(0))\n  else\n    None\n}\n```", "```java\nError:(65, 14) types Option[Int] and Int do not adhere to the type constraint selected for the === and !== operators; the missing implicit parameter is of type org.scalactic.CanEqual[Option[Int],Int]\n      actual should ===(expected)\n```", "```java\nactual should ===(Some(expected))\n```", "```java\n\"not loop forever if I enter bad parameters\" in {\n  val actual = RetCalc.nbOfMonthsSaving(params.copy(netIncome = 1000), FixedReturns(0.04))\n  actual should ===(None)\n}\n```", "```java\nsealed trait Either[A, B]\ncase class Left[A, B](value: A) extends Either[A, B]\ncase class Right[A, B](value: B) extends Either[A, B]\n```", "```java\ndef divide(x: Double, y: Double): Either[String, Double] =\n  if (y == 0)\n    Left(s\"$x cannot be divided by zero\")\n  else\n    Right(x / y)\n\ndivide(6, 3)\n// res0: Either[String,Double] = Right(2.0)\ndivide(6, 0)\n// res1: Either[String,Double] = Left(6.0 cannot be divided by zero) \n```", "```java\ndef getPersonAge(name: String, db: Map[String, Int]): Either[String, Int] =\n  db.get(name).toRight(s\"$name is not present in db\")\n\ndef personDescription(name: String, db: Map[String, Int]): String =\n  getPersonAge(name, db) match {\n    case Right(age) => s\"$name is $age years old\"\n    case Left(error) => error\n  }\n\nval db = Map(\"John\" -> 25, \"Rob\" -> 40)\npersonDescription(\"John\", db)\n// res4: String = John is 25 years old\npersonDescription(\"Michael\", db)\n// res5: String = Michael is not present in db\n```", "```java\ndef averageAge(name1: String, name2: String, db: Map[String, Int]): Either[String, Double] =\n  getPersonAge(name1, db).flatMap(age1 =>\n    getPersonAge(name2, db).map(age2 =>\n      (age1 + age2).toDouble / 2))\n\naverageAge(\"John\", \"Rob\", db)\n// res4: Either[String,Double] = Right(32.5)\naverageAge(\"John\", \"Michael\", db)\n// res5: Either[String,Double] = Left(Michael is not present in db)\n```", "```java\ngetPersonAge(\"bob\", db).left.map(err => s\"The error was: $err\")\n// res6: scala.util.Either[String,Int] = Left(The error was: bob is not present in db)\n```", "```java\ndef averageAge2(name1: String, name2: String, db: Map[String, Int]): Either[String, Double] =\n  for {\n    age1 <- getPersonAge(name1, db)\n    age2 <- getPersonAge(name2, db)\n  } yield (age1 + age2).toDouble / 2\n```", "```java\npackage retcalc\n\nsealed abstract class RetCalcError(val message: String)\n\nobject RetCalcError {\n  case class MoreExpensesThanIncome(income: Double, expenses: Double) \n  extends RetCalcError(\n    s\"Expenses: $expenses >=  $income. You will never be able to save \n    enough to retire !\")\n}\n```", "```java\ndef nbOfMonthsSaving(params: RetCalcParams, \n                     returns: Returns): Either[RetCalcError, Int] = {\n  import params._\n  @tailrec\n  def loop(months: Int): Int = {\n    val (capitalAtRetirement, capitalAfterDeath) = \n      simulatePlan(returns, params, months)\n    if (capitalAfterDeath > 0.0)\n      months\n    else\n      loop(months + 1)\n  }\n\n  if (netIncome > currentExpenses)\n    Right(loop(0))\n  else\n    Left(MoreExpensesThanIncome(netIncome, currentExpenses))\n}\n```", "```java\nclass RetCalcSpec extends WordSpec with Matchers with TypeCheckedTripleEquals \n  with EitherValues {\n```", "```java\n\"RetCalc.nbOfMonthsSaving\" should {\n  \"calculate how long I need to save before I can retire\" in {\n    val actual = RetCalc.nbOfMonthsSaving(params, \n    FixedReturns(0.04)).right.value\n    val expected = 23 * 12 + 1\n    actual should ===(expected)\n  }\n\n  \"not crash if the resulting nbOfMonths is very high\" in {\n    val actual = RetCalc.nbOfMonthsSaving(\n      params = RetCalcParams(\n        nbOfMonthsInRetirement = 40 * 12,\n        netIncome = 3000, currentExpenses = 2999, initialCapital = 0),\n      returns = FixedReturns(0.01)).right.value\n    val expected = 8280\n    actual should ===(expected)\n  }\n\n  \"not loop forever if I enter bad parameters\" in {\n    val actual = RetCalc.nbOfMonthsSaving(\n      params.copy(netIncome = 1000), FixedReturns(0.04)).left.value\n    actual should ===(RetCalcError.MoreExpensesThanIncome(1000, 2000))\n  }\n}\n```", "```java\ncase class ReturnMonthOutOfBounds(month: Int, maximum: Int) extends RetCalcError(\n  s\"Cannot get the return for month $month. Accepted range: 0 to $maximum\")\n```", "```java\n\"Returns.monthlyReturn\" should {\n  \"return a fixed rate for a FixedReturn\" in {\n    Returns.monthlyRate(FixedReturns(0.04), 0).right.value should ===\n    (0.04 / 12)\n    Returns.monthlyRate(FixedReturns(0.04), 10).right.value should ===\n    (0.04 / 12)\n  }\n\n  val variableReturns = VariableReturns(\n    Vector(VariableReturn(\"2000.01\", 0.1), VariableReturn(\"2000.02\", \n    0.2)))\n  \"return the nth rate for VariableReturn\" in {\n    Returns.monthlyRate(variableReturns, 0).right.value should ===(0.1)\n    Returns.monthlyRate(variableReturns, 1).right.value should ===(0.2)\n  }\n\n  \"return None if n > length\" in {\n    Returns.monthlyRate(variableReturns, 2).left.value should ===(\n      RetCalcError.ReturnMonthOutOfBounds(2, 1))\n    Returns.monthlyRate(variableReturns, 3).left.value should ===(\n      RetCalcError.ReturnMonthOutOfBounds(3, 1))\n  }\n\n  \"return the n+offset th rate for OffsetReturn\" in {\n    val returns = OffsetReturns(variableReturns, 1)\n    Returns.monthlyRate(returns, 0).right.value should ===(0.2)\n  }\n}\n```", "```java\ndef monthlyRate(returns: Returns, month: Int): Either[RetCalcError, Double] = returns match {\n  case FixedReturns(r) => Right(r / 12)\n\n  case VariableReturns(rs) =>\n    if (rs.isDefinedAt(month))\n      Right(rs(month).monthlyRate)\n    else\n      Left(RetCalcError.ReturnMonthOutOfBounds(month, rs.size - 1))\n\n  case OffsetReturns(rs, offset) => monthlyRate(rs, month + offset)\n}\n```", "```java\nError:(55, 26) overloaded method value + with alternatives:\n(...)\n cannot be applied to (Either[retcalc.RetCalcError,Double])\n        accumulated * (1 + Returns.monthlyRate(returns, month)) + \n        monthlySavings\n```", "```java\ndef futureCapital(returns: Returns, nbOfMonths: Int, netIncome: Int, currentExpenses: Int,\n                  initialCapital: Double): Either[RetCalcError, Double] = {\n  val monthlySavings = netIncome - currentExpenses\n  (0 until nbOfMonths).foldLeft[Either[RetCalcError, Double]] (Right(initialCapital)) {\n    case (accumulated, month) =>\n      for {\n        acc <- accumulated\n        monthlyRate <- Returns.monthlyRate(returns, month)\n      } yield acc * (1 + monthlyRate) + monthlySavings\n  }\n}\n```", "```java\ndef simulatePlan(returns: Returns, params: RetCalcParams, nbOfMonthsSavings: Int,\n                 monthOffset: Int = 0): Either[RetCalcError, (Double, \nDouble)] = {\n  import params._\n\n  for {\n    capitalAtRetirement <- futureCapital(\n      returns = OffsetReturns(returns, monthOffset),\n      nbOfMonths = nbOfMonthsSavings, netIncome = netIncome, \n      currentExpenses = currentExpenses,\n      initialCapital = initialCapital)\n\n    capitalAfterDeath <- futureCapital(\n      returns = OffsetReturns(returns, monthOffset + \n      nbOfMonthsSavings),\n      nbOfMonths = nbOfMonthsInRetirement,\n      netIncome = 0, currentExpenses = currentExpenses,\n      initialCapital = capitalAtRetirement)\n  } yield (capitalAtRetirement, capitalAfterDeath)\n}\n```", "```java\ndef nbOfMonthsSaving(params: RetCalcParams, returns: Returns): Either[RetCalcError, Int] = {\n  import params._\n  @tailrec\n  def loop(months: Int): Either[RetCalcError, Int] = {\n    simulatePlan(returns, params, months) match {\n      case Right((capitalAtRetirement, capitalAfterDeath)) =>\n        if (capitalAfterDeath > 0.0)\n          Right(months)\n        else\n          loop(months + 1)\n\n      case Left(err) => Left(err)\n    }\n  }\n\n  if (netIncome > currentExpenses)\n    loop(0)\n  else\n    Left(MoreExpensesThanIncome(netIncome, currentExpenses))\n}\n```", "```java\n  \"SimulatePlanApp.strMain\" should {\n    \"simulate a retirement plan using market returns\" in {...}\n\n    \"return an error when the period exceeds the returns bounds\" in {\n      val actualResult = SimulatePlanApp.strMain(\n        Array(\"1952.09,2017.09\", \"25\", \"60\", \"3000\", \"2000\", \"10000\"))\n      val expectedResult = \"Cannot get the return for month 780\\. \n      Accepted range: 0 to 779\"\n      actualResult should === (expectedResult)\n    }\n  }\n```", "```java\nobject SimulatePlanApp extends App {\n  println(strMain(args))\n\n  def strMain(args: Array[String]): String = {\n    val (from +: until +: Nil) = args(0).split(\",\").toList\n    val nbOfYearsSaving = args(1).toInt\n    val nbOfYearsRetired = args(2).toInt\n\n    val allReturns = Returns.fromEquityAndInflationData(\n      equities = EquityData.fromResource(\"sp500.tsv\"),\n      inflations = InflationData.fromResource(\"cpi.tsv\"))\n\n    RetCalc.simulatePlan(\n      returns = allReturns.fromUntil(from, until),\n      params = RetCalcParams(\n        nbOfMonthsInRetirement = nbOfYearsRetired * 12,\n        netIncome = args(3).toInt,\n        currentExpenses = args(4).toInt,\n        initialCapital = args(5).toInt),\n      nbOfMonthsSavings = nbOfYearsSaving * 12\n    ) match {\n      case Right((capitalAtRetirement, capitalAfterDeath)) =>\n        s\"\"\"\n           |Capital after $nbOfYearsSaving years of savings:    \n            ${capitalAtRetirement.round}\n           |Capital after $nbOfYearsRetired years in retirement: \n            ${capitalAfterDeath.round}\n        \"\"\".stripMargin\n\n      case Left(err) => err.message\n    }\n  }\n}\n```", "```java\ndef sequentialErrorHandling(x: String): Either[MyError, String] =\n  for {\n    a <- function1(x)\n    b <- function2(a)\n    c <- function3(b)\n  } yield c\n```", "```java\nlibraryDependencies += \"org.typelevel\" %% \"cats-core\" % \"1.0.1\"\nscalacOptions += \"-Ypartial-unification\"\n```", "```java\nimport cats.data.NonEmptyList\n\nNonEmptyList(1, List(2, 3))\n// res0: cats.data.NonEmptyList[Int] = NonEmptyList(1, 2, 3)\nNonEmptyList.fromList(List(1, 2, 3))\n// res3: Option[cats.data.NonEmptyList[Int]] = Some(NonEmptyList(1, 2, 3))\nNonEmptyList.fromList(List.empty[Int])\n// res4: Option[cats.data.NonEmptyList[Int]] = None\nval nel = NonEmptyList.of(1, 2, 3)\n// nel: cats.data.NonEmptyList[Int] = NonEmptyList(1, 2, 3)\n\nnel.head\n// res0: Int = 1\nnel.tail\n// res1: List[Int] = List(2, 3)\nnel.map(_ + 1)\n// res2: cats.data.NonEmptyList[Int] = NonEmptyList(2, 3, 4)\n```", "```java\nsealed trait Validated[+E, +A]\ncase class Valid[+A](a: A) extends Validated[Nothing, A]\ncase class Invalid[+E](e: E) extends Validated[E, Nothing]\n```", "```java\nimport cats.data._\nimport cats.data.Validated._\nimport cats.implicits._\n\nval valid1: Validated[NonEmptyList[String], Int] = Valid(1)\n// valid1: cats.data.Validated[cats.data.NonEmptyList[String],Int] = Valid(1)\n\nval valid2 = 2.validNel[String]\n// valid2: cats.data.ValidatedNel[String,Int] = Valid(2)\n\n(valid1, valid2).mapN { case (i1, i2) => i1 + i2 }\n// res1: cats.data.ValidatedNel[String,Int] = Valid(3)\n\nval invalid3: ValidatedNel[String, Int] = Invalid(NonEmptyList.of(\"error\"))\nval invalid4 = \"another error\".invalidNel[Int]\n(valid1, valid2, invalid3, invalid4).mapN { case (i1, i2, i3, i4) => i1 + i2 + i3 + i4 }\n// res2: cats.data.ValidatedNel[String,Int] = Invalid(NonEmptyList(error, another error))\n\n```", "```java\ntype ValidatedNel[+E, +A] = Validated[NonEmptyList[E], A]\n```", "```java\npackage retcalc\n\nimport cats.data.Validated.{Invalid, Valid}\nimport org.scalactic.TypeCheckedTripleEquals\nimport org.scalatest.{Matchers, WordSpec}\n\nclass SimulatePlanAppIT extends WordSpec with Matchers with TypeCheckedTripleEquals {\n  \"SimulatePlanApp.strMain\" should {\n    \"simulate a retirement plan using market returns\" in {\n      val actualResult = SimulatePlanApp.strMain(\n        Array(\"1952.09,2017.09\", \"25\", \"40\", \"3000\", \"2000\", \"10000\"))\n\n      val expectedResult =\n        s\"\"\"\n           |Capital after 25 years of savings:    468925\n           |Capital after 40 years in retirement: 2958842\n           |\"\"\".stripMargin\n      actualResult should ===(Valid(expectedResult))\n    }\n\n    \"return an error when the period exceeds the returns bounds\" in {\n      val actualResult = SimulatePlanApp.strMain(\n        Array(\"1952.09,2017.09\", \"25\", \"60\", \"3000\", \"2000\", \"10000\"))\n      val expectedResult = \"Cannot get the return for month 780\\. \n      Accepted range: 0 to 779\"\n      actualResult should ===(Invalid(expectedResult))\n    }\n\n    \"return an usage example when the number of arguments is incorrect\" \n      in {\n      val result = SimulatePlanApp.strMain(\n        Array(\"1952.09:2017.09\", \"25.0\", \"60\", \"3'000\", \"2000.0\"))\n      result should ===(Invalid(\n        \"\"\"Usage:\n          |simulatePlan from,until nbOfYearsSaving nbOfYearsRetired \n          netIncome currentExpenses initialCapital\n          |\n          |Example:\n          |simulatePlan 1952.09,2017.09 25 40 3000 2000 10000\n          |\"\"\".stripMargin))\n    }\n\n    \"return several errors when several arguments are invalid\" in {\n      val result = SimulatePlanApp.strMain(\n        Array(\"1952.09:2017.09\", \"25.0\", \"60\", \"3'000\", \"2000.0\", \n        \"10000\"))\n      result should ===(Invalid(\n        \"\"\"Invalid format for fromUntil. Expected: from,until, actual: \n          1952.09:2017.09\n          |Invalid number for nbOfYearsSaving: 25.0\n          |Invalid number for netIncome: 3'000\n          |Invalid number for currentExpenses: 2000.0\"\"\".stripMargin))\n    }\n  }\n}\n```", "```java\nobject RetCalcError {\n type RetCalcResult[A] = ValidatedNel[RetCalcError, A]\n\n  case class MoreExpensesThanIncome(income: Double, expenses: Double) \n    extends RetCalcError(...)\n\n  case class ReturnMonthOutOfBounds(month: Int, maximum: Int) extends \n    RetCalcError(...)\n\n  case class InvalidNumber(name: String, value: String) extends \n  RetCalcError(\n    s\"Invalid number for $name: $value\")\n\n  case class InvalidArgument(name: String, \n                             value: String, \n                             expectedFormat: String) extends \n  RetCalcError(\n    s\"Invalid format for $name. Expected: $expectedFormat, actual: \n    $value\")\n}\n```", "```java\ndef parseInt(name: String, value: String): RetCalcResult[Int] =\n  Validated\n    .catchOnly[NumberFormatException](value.toInt)\n    .leftMap(_ => NonEmptyList.of(InvalidNumber(name, value)))\n```", "```java\nimport cats.implicits._\ndef parseFromUntil(fromUntil: String): RetCalcResult[(String, String)] = {\n  val array = fromUntil.split(\",\")\n  if (array.length != 2)\n    InvalidArgument(\n      name = \"fromUntil\", value = fromUntil, \n      expectedFormat = \"from,until\"\n    ).invalidNel\n  else\n    (array(0), array(1)).validNel\n}\n```", "```java\ndef parseParams(args: Array[String]): RetCalcResult[RetCalcParams] =\n  (\n    parseInt(\"nbOfYearsRetired\", args(2)),\n    parseInt(\"netIncome\", args(3)),\n    parseInt(\"currentExpenses\", args(4)),\n    parseInt(\"initialCapital\", args(5))\n  ).mapN { case (nbOfYearsRetired, netIncome, currentExpenses, \n    initialCapital) =>\n    RetCalcParams(\n      nbOfMonthsInRetirement = nbOfYearsRetired * 12,\n      netIncome = netIncome,\n      currentExpenses = currentExpenses,\n      initialCapital = initialCapital)\n  }\n```", "```java\ndef strSimulatePlan(returns: Returns, nbOfYearsSaving: Int, params: RetCalcParams)\n: RetCalcResult[String] = {\n  RetCalc.simulatePlan(\n    returns = returns,\n    params = params,\n    nbOfMonthsSavings = nbOfYearsSaving * 12\n  ).map {\n    case (capitalAtRetirement, capitalAfterDeath) =>\n      val nbOfYearsInRetirement = params.nbOfMonthsInRetirement / 12\n      s\"\"\"\n         |Capital after $nbOfYearsSaving years of savings:    \n        ${capitalAtRetirement.round}\n         |Capital after $nbOfYearsInRetirement years in retirement: \n        ${capitalAfterDeath.round}\n         |\"\"\".stripMargin\n  }.toValidatedNel\n}\n```", "```java\ndef strMain(args: Array[String]): Validated[String, String] = {\n  if (args.length != 6)\n    \"\"\"Usage:\n      |simulatePlan from,until nbOfYearsSaving nbOfYearsRetired \n       netIncome currentExpenses initialCapital\n      |\n      |Example:\n      |simulatePlan 1952.09,2017.09 25 40 3000 2000 10000\n      |\"\"\".stripMargin.invalid\n  else {\n    val allReturns = Returns.fromEquityAndInflationData(\n      equities = EquityData.fromResource(\"sp500.tsv\"),\n      inflations = InflationData.fromResource(\"cpi.tsv\"))\n\n    val vFromUntil = parseFromUntil(args(0))\n    val vNbOfYearsSaving = parseInt(\"nbOfYearsSaving\", args(1))\n    val vParams = parseParams(args)\n\n    (vFromUntil, vNbOfYearsSaving, vParams)\n      .tupled\n      .andThen { case ((from, until), nbOfYearsSaving, params) =>\n        strSimulatePlan(allReturns.fromUntil(from, until), \n        nbOfYearsSaving, params)\n      }\n      .leftMap(nel => nel.map(_.message).toList.mkString(\"\\n\"))\n  }\n```"]