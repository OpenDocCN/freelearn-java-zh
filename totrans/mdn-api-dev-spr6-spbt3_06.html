<html><head></head><body>
<div id="_idContainer023">
<h1 class="chapter-number" id="_idParaDest-149"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.2.1">Securing REST Endpoints Using Authorization and Authentication</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In previous chapters, we developed a RESTful web service using imperative and reactive coding styles. </span><span class="koboSpan" id="kobo.3.2">Now, you’ll learn how you can secure these REST endpoints using Spring Security. </span><span class="koboSpan" id="kobo.3.3">You’ll implement token-based authentication and authorization for REST endpoints. </span><span class="koboSpan" id="kobo.3.4">A successful authentication provides two types of tokens – a </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">JavaScript Object Notation</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">JSON</span></strong><span class="koboSpan" id="kobo.7.1">) </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Web Token</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">JWT</span></strong><span class="koboSpan" id="kobo.11.1">) as</span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.12.1"> an access token, and a refresh token in response. </span><span class="koboSpan" id="kobo.12.2">This JWT-based access token is then used to access the secured </span><strong class="bold"><span class="koboSpan" id="kobo.13.1">Uniform Resource Locators</span></strong><span class="koboSpan" id="kobo.14.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.15.1">URLs</span></strong><span class="koboSpan" id="kobo.16.1">). </span><span class="koboSpan" id="kobo.16.2">A</span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.17.1"> refresh token is used to request a new JWT if the existing JWT has expired, and a valid request token provides a new JWT </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">to use.</span></span></p>
<p><span class="koboSpan" id="kobo.19.1">You’ll associate users with roles such as </span><em class="italic"><span class="koboSpan" id="kobo.20.1">admin</span></em><span class="koboSpan" id="kobo.21.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.22.1">user</span></em><span class="koboSpan" id="kobo.23.1">. </span><span class="koboSpan" id="kobo.23.2">These roles will be used as authorization to make sure that REST endpoints can only be accessed if a user holds certain roles. </span><span class="koboSpan" id="kobo.23.3">We’ll also</span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.24.1"> briefly </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.25.1">discuss </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">cross-site request forgery</span></strong><span class="koboSpan" id="kobo.27.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.28.1">CSRF</span></strong><span class="koboSpan" id="kobo.29.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.30.1">cross-origin resource </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.31.1">sharing</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.32.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.33.1">CORS</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.34.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.35.1">The topics of this chapter are divided into the </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">following sections:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.37.1">Implementing authentication using Spring Security </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">and JWTs</span></span></li>
<li><span class="koboSpan" id="kobo.39.1">Securing REST APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">with JWTs</span></span></li>
<li><span class="koboSpan" id="kobo.41.1">Configuring CORS </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">and CSRF</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.43.1">Understanding authorization</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.44.1">Testing security</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.45.1">By the end of the chapter, you will know how to implement authentication and authorization using Spring Security and protect your web service from CORS and </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">CSRF attacks.</span></span></p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.47.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.48.1">The code for this chapter is available </span><span class="No-Break"><span class="koboSpan" id="kobo.49.1">at </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter06"><span class="No-Break"><span class="koboSpan" id="kobo.50.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/main/Chapter06</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.51.1">.</span></span></p>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.52.1">Implementing authentication using Spring Security  and JWT</span></h1>
<p><span class="koboSpan" id="kobo.53.1">Spring Security</span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.54.1"> is a framework consisting of a collection of libraries that allow you to implement enterprise application security without worrying about </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.55.1">writing boilerplate code. </span><span class="koboSpan" id="kobo.55.2">In this chapter, we will use the Spring Security framework to implement token-based (JWT) authentication</span><a id="_idIndexMarker447"/><span class="koboSpan" id="kobo.56.1"> and authorization. </span><span class="koboSpan" id="kobo.56.2">Throughout the course of this chapter, you will also learn about CORS and </span><span class="No-Break"><span class="koboSpan" id="kobo.57.1">CSRF configuration.</span></span></p>
<p><span class="koboSpan" id="kobo.58.1">It’s useful to know </span><a id="_idIndexMarker448"/><span class="koboSpan" id="kobo.59.1">that Spring Security also provides support for opaque tokens, just like it does for JWTs. </span><span class="koboSpan" id="kobo.59.2">The main difference between them is how information is read from the token. </span><span class="koboSpan" id="kobo.59.3">You can’t read the information from an opaque token the way you can with a JWT –  only the issuer is aware of how to </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">do this.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.61.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.62.1">A token is a string of characters </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">such as</span></span></p>
<p class="callout"><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.64.1">5rm1tc1obfshrm2354lu9dlt5reqm1ddjchqh81 7rbk37q95b768bib0j</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.65.1"> f44df6suk1638sf78cef7 </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.66.1">hfolg4ap3bkighbnk7inr68ke780744fpej0gtd 9qflm999o8q</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">.</span></span></p>
<p class="callout"><span class="koboSpan" id="kobo.68.1">It allows you to call secured HTTP endpoints or resources that are stateless by using various </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">authorization flows.</span></span></p>
<p><span class="koboSpan" id="kobo.70.1">You learned about </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.72.1"> in </span><a href="B19349_02.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.73.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.74.1">, </span><em class="italic"><span class="koboSpan" id="kobo.75.1">Spring Concepts and REST APIs</span></em><span class="koboSpan" id="kobo.76.1">. </span><span class="koboSpan" id="kobo.76.2">This is an interface between a client request and the REST controller. </span><span class="koboSpan" id="kobo.76.3">Therefore, if you want to place logic for token-based authentication and authorization, you will have to do this before a request reaches </span><strong class="source-inline"><span class="koboSpan" id="kobo.77.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.78.1">. </span><span class="koboSpan" id="kobo.78.2">Spring Security libraries provide the servlet with pre-filters (as a part of the filter chain), which are processed before the request reaches </span><strong class="source-inline"><span class="koboSpan" id="kobo.79.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.80.1">. </span><span class="koboSpan" id="kobo.80.2">A </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">pre-filter</span></strong><span class="koboSpan" id="kobo.82.1"> is a </span><a id="_idIndexMarker449"/><span class="koboSpan" id="kobo.83.1">servlet filter that is processed before it reaches the actual servlet, which in Spring Security’s case is </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.85.1">. </span><span class="koboSpan" id="kobo.85.2">Similarly, </span><strong class="bold"><span class="koboSpan" id="kobo.86.1">post-filters</span></strong><span class="koboSpan" id="kobo.87.1"> get </span><a id="_idIndexMarker450"/><span class="koboSpan" id="kobo.88.1">processed after a request has been </span><a id="_idIndexMarker451"/><span class="koboSpan" id="kobo.89.1">processed by </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the servlet/controller.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">There are</span><a id="_idIndexMarker452"/><span class="koboSpan" id="kobo.92.1"> two ways you can implement</span><a id="_idIndexMarker453"/><span class="koboSpan" id="kobo.93.1"> token-based (JWT) authentication – by using either </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">spring-boot-starter-security</span></strong><span class="koboSpan" id="kobo.95.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">spring-boot-starter-oauth2-resource-server</span></strong><span class="koboSpan" id="kobo.97.1">. </span><span class="koboSpan" id="kobo.97.2">We will use the latter because it does the boilerplate configuration </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">for us.</span></span></p>
<p><span class="koboSpan" id="kobo.99.1">The former contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">following libraries:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">spring-security-core</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">spring-security-config</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">spring-security-web</span></strong></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">spring-boot-starter-oauth2-resource-server</span></strong><span class="koboSpan" id="kobo.105.1"> provides the following, along with all three </span><a id="_idIndexMarker454"/><span class="koboSpan" id="kobo.106.1">preceding </span><strong class="bold"><span class="koboSpan" id="kobo.107.1">Java ARchive</span></strong><span class="koboSpan" id="kobo.108.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.109.1">JAR</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">) files:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.111.1">spring-security-oauth2-core</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">spring-security-oauth2-jose</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.113.1">spring-security-oauth2-resource-server</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.114.1">When you start this chapter’s code, you will find the following log. </span><span class="koboSpan" id="kobo.114.2">You can see that, by default, </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">DefaultSecurityFilterChain</span></strong><span class="koboSpan" id="kobo.116.1"> is </span><strong class="source-inline"><span class="koboSpan" id="kobo.117.1">auto-configured</span></strong><span class="koboSpan" id="kobo.118.1">. </span><span class="koboSpan" id="kobo.118.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.119.1">log</span></strong><span class="koboSpan" id="kobo.120.1"> statement lists the configured filters in </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">DefaultSecurityFilterChain</span></strong><span class="koboSpan" id="kobo.122.1">, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.123.1">log block:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.124.1">
INFO [Chapter06,,,] [null] [null] [null] [null] 31975 --- [           main] o.s.s.web.</span><strong class="bold"><span class="koboSpan" id="kobo.125.1">DefaultSecurityFilterChain</span></strong><span class="koboSpan" id="kobo.126.1">     : Will secure any request with [org.springframework.security.web.session.DisableEncodeUrlFilter@781dac73, org.springframework.security.web.context.request.async.</span><strong class="bold"><span class="koboSpan" id="kobo.127.1">WebAsyncManagerIntegrationFilter</span></strong><span class="koboSpan" id="kobo.128.1">@3a4e524, org.springframework.security.web.context.</span><strong class="bold"><span class="koboSpan" id="kobo.129.1">SecurityContextHolderFilter</span></strong><span class="koboSpan" id="kobo.130.1">@22048bd6, org.springframework.security.web.header.</span><strong class="bold"><span class="koboSpan" id="kobo.131.1">HeaderWriterFilter</span></strong><span class="koboSpan" id="kobo.132.1">@5844a2d1, org.springframework.web.filter.</span><strong class="bold"><span class="koboSpan" id="kobo.133.1">CorsFilter</span></strong><span class="koboSpan" id="kobo.134.1">@5e67a490, org.springframework.security.web.csrf.</span><strong class="bold"><span class="koboSpan" id="kobo.135.1">CsrfFilter</span></strong><span class="koboSpan" id="kobo.136.1">@7b95bdb0, org.springframework.security.web.authentication.logout.</span><strong class="bold"><span class="koboSpan" id="kobo.137.1">LogoutFilter</span></strong><span class="koboSpan" id="kobo.138.1">@6bcdd6e4, org.springframework.security.oauth2.server.resource.web.authentication.</span><strong class="bold"><span class="koboSpan" id="kobo.139.1">BearerTokenAuthenticationFilter</span></strong><span class="koboSpan" id="kobo.140.1">@6826b70f, org.springframework.security.web.savedrequest.</span><strong class="bold"><span class="koboSpan" id="kobo.141.1">RequestCacheAwareFilter</span></strong><span class="koboSpan" id="kobo.142.1">@2e2f20b8, org.springframework.security.web.servletapi.</span><strong class="bold"><span class="koboSpan" id="kobo.143.1">SecurityContextHolderAwareRequestFilter</span></strong><span class="koboSpan" id="kobo.144.1">@504497fa, org.springframework.security.web.authentication.</span><strong class="bold"><span class="koboSpan" id="kobo.145.1">AnonymousAuthenticationFilter</span></strong><span class="koboSpan" id="kobo.146.1">@2dac2e1b, org.springframework.security.web.session.</span><strong class="bold"><span class="koboSpan" id="kobo.147.1">SessionManagementFilter</span></strong><span class="koboSpan" id="kobo.148.1">@4af7dd6a, org.springframework.security.web.access.</span><strong class="bold"><span class="koboSpan" id="kobo.149.1">ExceptionTranslationFilter</span></strong><span class="koboSpan" id="kobo.150.1">@401317a0, org.springframework.security.web.access.intercept.</span><strong class="bold"><span class="koboSpan" id="kobo.151.1">FilterSecurityInterceptor</span></strong><span class="koboSpan" id="kobo.152.1">@1ad1c363</span></pre> <p><span class="koboSpan" id="kobo.153.1">Therefore, when</span><a id="_idIndexMarker455"/><span class="koboSpan" id="kobo.154.1"> a client fires an HTTP request, it</span><a id="_idIndexMarker456"/><span class="koboSpan" id="kobo.155.1"> will go </span><a id="_idIndexMarker457"/><span class="koboSpan" id="kobo.156.1">through all the following security filters one after the other before reaching the REST controller (although the order may vary based on the authentication outcome) </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">DefaultSecurityFilterChain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.159.1">:</span></span></p>
<ol>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">WebAsyncManagerIntegrationFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">SecurityContextPersistenceFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">HeaderWriterFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">CorsFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">CsrfFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">LogoutFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">BearerTokenAuthenticationFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.167.1">RequestCacheAwareFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">SecurityContextHolderAwareRequestFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">AnonymousAuthenticationFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">SessionManagementFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.171.1">ExceptionTranslationFilter</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">FilterSecurityInterceptor</span></strong></span></li>
</ol>
<p><span class="koboSpan" id="kobo.173.1">This</span><a id="_idIndexMarker458"/><span class="koboSpan" id="kobo.174.1"> filter</span><a id="_idIndexMarker459"/><span class="koboSpan" id="kobo.175.1"> chain may change in future releases. </span><span class="koboSpan" id="kobo.175.2">Also, the security</span><a id="_idIndexMarker460"/><span class="koboSpan" id="kobo.176.1"> filter chain will be different if you just used </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">spring-boot-starter-security</span></strong><span class="koboSpan" id="kobo.178.1"> or changed the configuration. </span><span class="koboSpan" id="kobo.178.2">You can find all the filters available in </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">springSecurityFilterChain</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.180.1">at </span></span><a href="https://docs.spring.io/spring-security/reference/servlet/architecture.html#servlet-security-filters"><span class="No-Break"><span class="koboSpan" id="kobo.181.1">https://docs.spring.io/spring-security/reference/servlet/architecture.html#servlet-security-filters</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.182.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.183.1">Now, you know about the different filters and their order in the default security chain. </span><span class="koboSpan" id="kobo.183.2">Next, let’s add the required dependencies, making use of the Spring OAuth 2.0 resource server for authentication in the </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">following subsections.</span></span></p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.185.1">Adding the required Gradle dependencies</span></h2>
<p><span class="koboSpan" id="kobo.186.1">Let’s add</span><a id="_idIndexMarker461"/><span class="koboSpan" id="kobo.187.1"> the following dependencies to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">build.gradle</span></strong><span class="koboSpan" id="kobo.189.1"> file, as </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">shown next:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.191.1">
implementation 'org.springframework.boot:</span><strong class="bold"><span class="koboSpan" id="kobo.192.1">spring-boot-starter-oauth2-resource-server</span></strong><span class="koboSpan" id="kobo.193.1">'implementation 'com.auth0:</span><strong class="bold"><span class="koboSpan" id="kobo.194.1">java-jwt</span></strong><span class="koboSpan" id="kobo.195.1">:4.3.0'</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/build.gradle"><span class="No-Break"><span class="koboSpan" id="kobo.196.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/build.gradle</span></span></a></p>
<p><span class="koboSpan" id="kobo.197.1">The Spring Boot Starter OAuth 2 resource server dependency will add the </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">following JARs:</span></span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">spring-security-core</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">spring-security-config</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">spring-security-web</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">spring-security-cropto</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">spring-security-oauth2-core</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">spring-security-oauth2-jose</span></strong></span></li>
<li><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">spring-security-oauth2-resource-server</span></strong></span></li>
</ul>
<p><span class="koboSpan" id="kobo.206.1">For</span><a id="_idIndexMarker462"/><span class="koboSpan" id="kobo.207.1"> JWT implementation, we will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">java-jwt</span></strong><span class="koboSpan" id="kobo.209.1"> library </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">from </span></span><a href="http://auth0.com"><span class="No-Break"><span class="koboSpan" id="kobo.211.1">auth0.com</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.212.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.213.1">We will now explore how to code these two filters – through login and </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">token-based authentication.</span></span></p>
<h2 id="_idParaDest-154"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.215.1">Authentication using the OAuth 2.0 resource server</span></h2>
<p><span class="koboSpan" id="kobo.216.1">The </span><a id="_idIndexMarker463"/><span class="koboSpan" id="kobo.217.1">Spring Security OAuth 2.0 resource server</span><a id="_idIndexMarker464"/><span class="koboSpan" id="kobo.218.1"> allows you to implement authentication and authorization using </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">BearerTokenAuthenticationFilter</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">This contains the bearer token authentication logic. </span><span class="koboSpan" id="kobo.220.3">However, you still need to write the REST endpoint to generate the token. </span><span class="koboSpan" id="kobo.220.4">Let’s explore how the authentication flow works in the OAuth2.0 resource server. </span><span class="koboSpan" id="kobo.220.5">Take a look at the </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.222.1"><img alt="Figure 6.1 – A token authentication flow using the OAuth 2.0 resource server" src="image/Figure_06.1_B19349.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.223.1">Figure 6.1 – A token authentication flow using the OAuth 2.0 resource server</span></p>
<p><span class="koboSpan" id="kobo.224.1">Let’s </span><a id="_idIndexMarker465"/><span class="koboSpan" id="kobo.225.1">understand the flow depicted</span><a id="_idIndexMarker466"/><span class="koboSpan" id="kobo.226.1"> in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.227.1">Figure 6</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.228.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.229.1">:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.230.1">The client sends a </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">GET</span></strong><span class="koboSpan" id="kobo.232.1"> HTTP request </span><span class="No-Break"><span class="koboSpan" id="kobo.233.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">/api/v1/addresses</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.235.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">BearerTokenAuthenticationFilter</span></strong><span class="koboSpan" id="kobo.237.1"> comes into action. </span><span class="koboSpan" id="kobo.237.2">If the request doesn’t contain the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Authorization</span></strong><span class="koboSpan" id="kobo.239.1"> header, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">BearerTokenAuthenticationFilter</span></strong><span class="koboSpan" id="kobo.241.1"> does not authenticate the request since it did not find the bearer token. </span><span class="koboSpan" id="kobo.241.2">It passes the call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.242.1">FilterSecurityInterceptor</span></strong><span class="koboSpan" id="kobo.243.1">, which does the authorization. </span><span class="koboSpan" id="kobo.243.2">It throws an </span><strong class="source-inline"><span class="koboSpan" id="kobo.244.1">AccessDeniedException</span></strong><span class="koboSpan" id="kobo.245.1"> exception (marked as </span><strong class="bold"><span class="koboSpan" id="kobo.246.1">2</span></strong><span class="koboSpan" id="kobo.247.1"> in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.248.1">Figure 6</span></em></span><em class="italic"><span class="koboSpan" id="kobo.249.1">.1</span></em><span class="koboSpan" id="kobo.250.1">). </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">ExceptionTranslationFilter</span></strong><span class="koboSpan" id="kobo.252.1"> springs into action. </span><span class="koboSpan" id="kobo.252.2">Control is moved to </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">BearerTokenAuthenticationEntryPoint</span></strong><span class="koboSpan" id="kobo.254.1">, which responds with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">401 Unauthorized</span></strong><span class="koboSpan" id="kobo.256.1"> status and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.257.1">WWW-Authenticate</span></strong><span class="koboSpan" id="kobo.258.1"> header, with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">Bearer</span></strong><span class="koboSpan" id="kobo.260.1"> value. </span><span class="koboSpan" id="kobo.260.2">If the client receives a </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">WWW-Authenticate</span></strong><span class="koboSpan" id="kobo.262.1"> header with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">Bearer</span></strong><span class="koboSpan" id="kobo.264.1"> value in response, it means it must retry with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">Authorization</span></strong><span class="koboSpan" id="kobo.266.1"> header that holds the valid bearer token. </span><span class="koboSpan" id="kobo.266.2">At this stage, the request cache is </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">NullRequestCache</span></strong><span class="koboSpan" id="kobo.268.1"> (that is, empty) due to security reasons – the client can replay </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">the request.</span></span></li>
<li><span class="koboSpan" id="kobo.270.1">Let’s </span><a id="_idIndexMarker467"/><span class="koboSpan" id="kobo.271.1">assume the HTTP request </span><a id="_idIndexMarker468"/><span class="koboSpan" id="kobo.272.1">contains an </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">Authorization</span></strong><span class="koboSpan" id="kobo.274.1"> header. </span><span class="koboSpan" id="kobo.274.2">It extracts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">Authorization</span></strong><span class="koboSpan" id="kobo.276.1"> header from the HTTP request and, apparently, the token from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">Authorization</span></strong><span class="koboSpan" id="kobo.278.1"> header. </span><span class="koboSpan" id="kobo.278.2">It creates an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.279.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">BearerTokenAuthentication</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.281.1"> Token</span></strong><span class="koboSpan" id="kobo.282.1"> using the token value. </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">BearerTokenAuthenticationToken</span></strong><span class="koboSpan" id="kobo.284.1"> is a type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">AbstractAuthenticationToken</span></strong><span class="koboSpan" id="kobo.286.1"> class that implements an </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">Authentication</span></strong><span class="koboSpan" id="kobo.288.1"> interface, representing the token/principal for the </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">authenticated request.</span></span></li>
<li><span class="koboSpan" id="kobo.290.1">The HTTP request is passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">AuthenticationManagerResolver</span></strong><span class="koboSpan" id="kobo.292.1">, which provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.293.1">AuthenticationManager</span></strong><span class="koboSpan" id="kobo.294.1"> based on the configuration. </span><strong class="source-inline"><span class="koboSpan" id="kobo.295.1">AuthenticationManager</span></strong><span class="koboSpan" id="kobo.296.1"> verifies the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">BearerTokenAuthenticationToken</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1"> token.</span></span></li>
<li><span class="koboSpan" id="kobo.299.1">If authentication is successful, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Authentication</span></strong><span class="koboSpan" id="kobo.301.1"> is set on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">SecurityContext</span></strong><span class="koboSpan" id="kobo.303.1"> instance. </span><span class="koboSpan" id="kobo.303.2">This instance is then passed to </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">SecurityContextHolder.setContext()</span></strong><span class="koboSpan" id="kobo.305.1">. </span><span class="koboSpan" id="kobo.305.2">The request is passed to the remaining filters for processing, then routes to </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">DispatcherServlet</span></strong><span class="koboSpan" id="kobo.307.1">, and then, finally, </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">AddressController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.311.1">If authentication fails, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.312.1">SecurityContextHolder.clearContext()</span></strong><span class="koboSpan" id="kobo.313.1"> is called to clear the context value. </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">ExceptionTranslationFilter</span></strong><span class="koboSpan" id="kobo.315.1"> springs into action. </span><span class="koboSpan" id="kobo.315.2">Control is moved to </span><strong class="source-inline"><span class="koboSpan" id="kobo.316.1">BearerTokenAuthenticationEntryPoint</span></strong><span class="koboSpan" id="kobo.317.1">, which responds with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.318.1">401 Unauthorized</span></strong><span class="koboSpan" id="kobo.319.1"> status and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.320.1">WWW-Authenticate</span></strong><span class="koboSpan" id="kobo.321.1"> header, with</span><a id="_idIndexMarker469"/><span class="koboSpan" id="kobo.322.1"> a value that contains the appropriate error message, such as </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">the following:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.324.1">
Bearer error="invalid_token", error_description="An error occurred while attempting to decode the Jwt: Jwt expired at 2022-12-14T17:23:30Z", error_uri="https://tools.ietf. </span><span class="koboSpan" id="kobo.324.2">org/html/rfc6750#section-3.1".</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.325.1">Now that you</span><a id="_idIndexMarker470"/><span class="koboSpan" id="kobo.326.1"> have learned about the complete authentication flow using the OAuth 2.0 resource server, let’s learn the fundamentals </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">of JWT.</span></span></p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.328.1">Exploring the structure of JWT</span></h2>
<p><span class="koboSpan" id="kobo.329.1">You need </span><a id="_idIndexMarker471"/><span class="koboSpan" id="kobo.330.1">authority in the form of permissions </span><a id="_idIndexMarker472"/><span class="koboSpan" id="kobo.331.1">or rights to carry out any activity or access any information in general. </span><span class="koboSpan" id="kobo.331.2">This authority is known as a claim with respect to JWT. </span><span class="koboSpan" id="kobo.331.3">A claim is represented as a key-value pair. </span><span class="koboSpan" id="kobo.331.4">The key contains the claim name and the value contains the claim, which can be a valid JSON value. </span><span class="koboSpan" id="kobo.331.5">A claim can also be metadata about </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">the JWT.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.333.1">How to pronounce JWT</span></p>
<p class="callout"><span class="koboSpan" id="kobo.334.1">As per </span><a href="https://tools.ietf.org/html/rfc7519"><span class="koboSpan" id="kobo.335.1">https://tools.ietf.org/html/rfc7519</span></a><span class="koboSpan" id="kobo.336.1">, the suggested pronunciation of </span><em class="italic"><span class="koboSpan" id="kobo.337.1">JWT</span></em><span class="koboSpan" id="kobo.338.1"> is the same as the English </span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">word </span></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.340.1">jot</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.341.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.342.1">A JWT is an</span><a id="_idIndexMarker473"/><span class="koboSpan" id="kobo.343.1"> encoded string that contains a set of claims. </span><span class="koboSpan" id="kobo.343.2">These claims are either digitally signed by a </span><strong class="bold"><span class="koboSpan" id="kobo.344.1">JSON Web Signature</span></strong><span class="koboSpan" id="kobo.345.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.346.1">JWS</span></strong><span class="koboSpan" id="kobo.347.1">) or encrypted</span><a id="_idIndexMarker474"/><span class="koboSpan" id="kobo.348.1"> by </span><strong class="bold"><span class="koboSpan" id="kobo.349.1">JSON Web Encryption</span></strong><span class="koboSpan" id="kobo.350.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.351.1">JWE</span></strong><span class="koboSpan" id="kobo.352.1">). </span><em class="italic"><span class="koboSpan" id="kobo.353.1">JWT is a self-contained way to transmit claims securely between parties</span></em><span class="koboSpan" id="kobo.354.1">. </span><span class="koboSpan" id="kobo.354.2">The links to these </span><strong class="bold"><span class="koboSpan" id="kobo.355.1">Request for Comments</span></strong><span class="koboSpan" id="kobo.356.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.357.1">RFC</span></strong><span class="koboSpan" id="kobo.358.1">)-proposed</span><a id="_idIndexMarker475"/><span class="koboSpan" id="kobo.359.1"> standards are provided in the </span><em class="italic"><span class="koboSpan" id="kobo.360.1">Further reading</span></em><span class="koboSpan" id="kobo.361.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">A JWT is an encoded string such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">aaa.bbb.ccc</span></strong><span class="koboSpan" id="kobo.365.1">, consisting of the following three parts, separated by </span><span class="No-Break"><span class="koboSpan" id="kobo.366.1">dots (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">.</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.368.1">):</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.369.1">Header</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.370.1">Payload</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.371.1">Signature</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.372.1">A few websites, such as </span><a href="https://jwt.io"><span class="koboSpan" id="kobo.373.1">https://jwt.io</span></a><span class="koboSpan" id="kobo.374.1">, allow you </span><a id="_idIndexMarker476"/><span class="koboSpan" id="kobo.375.1">to view the content of a JWT and </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">generate one.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">Let’s have a look at the following sample JWT string. </span><span class="koboSpan" id="kobo.377.2">You can paste it into one of the aforementioned websites to decode </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">the content:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.379.1">
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><strong class="bold"><span class="koboSpan" id="kobo.380.1">.</span></strong><span class="koboSpan" id="kobo.381.1">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5 MDIyfQ</span><strong class="bold"><span class="koboSpan" id="kobo.382.1">.</span></strong><span class="koboSpan" id="kobo.383.1">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span></pre> <p><span class="koboSpan" id="kobo.384.1">This sample token demonstrates how a JWT is formed and divided into three parts </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">using dots.</span></span></p>
<h3><span class="koboSpan" id="kobo.386.1">Header</span></h3>
<p><span class="koboSpan" id="kobo.387.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.388.1">header</span></strong><span class="koboSpan" id="kobo.389.1"> consists </span><a id="_idIndexMarker477"/><span class="koboSpan" id="kobo.390.1">of a Base64URL-encoded JSON string, normally containing </span><a id="_idIndexMarker478"/><span class="koboSpan" id="kobo.391.1">two key-value pairs – a type of token (with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">typ</span></strong><span class="koboSpan" id="kobo.393.1"> key) and a signing algorithm (with an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">alg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1"> key).</span></span></p>
<p><span class="koboSpan" id="kobo.396.1">This sample JWT string contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">following header:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.398.1">
{  "alg": "HS256",
  "typ": "JWT"
}</span></pre>
<p><span class="koboSpan" id="kobo.399.1">The preceding header contains the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">typ</span></strong><span class="koboSpan" id="kobo.401.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">alg</span></strong><span class="koboSpan" id="kobo.403.1"> fields, representing the type and </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">algorithm, respectively.</span></span></p>
<h3><span class="koboSpan" id="kobo.405.1">Payload</span></h3>
<p><span class="koboSpan" id="kobo.406.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.407.1">payload</span></strong><span class="koboSpan" id="kobo.408.1"> is the</span><a id="_idIndexMarker479"/><span class="koboSpan" id="kobo.409.1"> second part of the JWT, which contains the claims and also </span><a id="_idIndexMarker480"/><span class="koboSpan" id="kobo.410.1">comprises a Base64URL-encoded JSON string. </span><span class="koboSpan" id="kobo.410.2">There are three types of claims – registered, public, and private. </span><span class="koboSpan" id="kobo.410.3">These are outlined </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">as follows:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.412.1">Registered claims</span></strong><span class="koboSpan" id="kobo.413.1">: A </span><a id="_idIndexMarker481"/><span class="koboSpan" id="kobo.414.1">few claims are registered on</span><a id="_idIndexMarker482"/><span class="koboSpan" id="kobo.415.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.416.1">Internet Assigned Numbers Authority (IANA) JWT Claims</span></strong><span class="koboSpan" id="kobo.417.1"> registry; therefore, these claims are known as registered claims. </span><span class="koboSpan" id="kobo.417.2">These are not mandatory </span><a id="_idIndexMarker483"/><span class="koboSpan" id="kobo.418.1">but are recommended. </span><span class="koboSpan" id="kobo.418.2">Some registered claims are </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">listed here:</span></span><ul><li><strong class="bold"><span class="koboSpan" id="kobo.420.1">Issuer claim</span></strong><span class="koboSpan" id="kobo.421.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">iss</span></strong><span class="koboSpan" id="kobo.423.1"> key): This </span><a id="_idIndexMarker484"/><span class="koboSpan" id="kobo.424.1">claim identifies the principal who issued </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">a token</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.426.1">Subject claim</span></strong><span class="koboSpan" id="kobo.427.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.428.1">sub</span></strong><span class="koboSpan" id="kobo.429.1"> key): This</span><a id="_idIndexMarker485"/><span class="koboSpan" id="kobo.430.1"> should be a unique value that represents the subject of </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">the JWT</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.432.1">Expiration time claim</span></strong><span class="koboSpan" id="kobo.433.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">exp</span></strong><span class="koboSpan" id="kobo.435.1"> key): This </span><a id="_idIndexMarker486"/><span class="koboSpan" id="kobo.436.1">is a numeric value representing the expiration time on or after which a JWT should </span><span class="No-Break"><span class="koboSpan" id="kobo.437.1">be rejected</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.438.1">Issued at claim</span></strong><span class="koboSpan" id="kobo.439.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">iat</span></strong><span class="koboSpan" id="kobo.441.1"> key): This</span><a id="_idIndexMarker487"/><span class="koboSpan" id="kobo.442.1"> claim identifies the time at which a JWT </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">is issued</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.444.1">JWT ID claim</span></strong><span class="koboSpan" id="kobo.445.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">jti</span></strong><span class="koboSpan" id="kobo.447.1"> key): This</span><a id="_idIndexMarker488"/><span class="koboSpan" id="kobo.448.1"> claim represents the unique identifier for </span><span class="No-Break"><span class="koboSpan" id="kobo.449.1">a JWT</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.450.1">Audience claim</span></strong><span class="koboSpan" id="kobo.451.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.452.1">aud</span></strong><span class="koboSpan" id="kobo.453.1"> key): This </span><a id="_idIndexMarker489"/><span class="koboSpan" id="kobo.454.1">claim identifies the recipients, which JWT is </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">intended for</span></span></li><li><strong class="bold"><span class="koboSpan" id="kobo.456.1">Not before claim</span></strong><span class="koboSpan" id="kobo.457.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.458.1">nbf</span></strong><span class="koboSpan" id="kobo.459.1"> key): This</span><a id="_idIndexMarker490"/><span class="koboSpan" id="kobo.460.1"> represents the time before which a JWT must </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">be rejected</span></span></li></ul></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.462.1">Public claims</span></strong><span class="koboSpan" id="kobo.463.1">: These </span><a id="_idIndexMarker491"/><span class="koboSpan" id="kobo.464.1">are defined by JWT issuers and must not collide with registered claims. </span><span class="koboSpan" id="kobo.464.2">Therefore, these should either be registered with the IANA JWT Claims registry or defined as a URI with a </span><span class="No-Break"><span class="koboSpan" id="kobo.465.1">collision-resistant namespace.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.466.1">Private claims</span></strong><span class="koboSpan" id="kobo.467.1">: These </span><a id="_idIndexMarker492"/><span class="koboSpan" id="kobo.468.1">are custom claims defined and used by the issuer and audience. </span><span class="koboSpan" id="kobo.468.2">They are neither registered </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">nor public.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.470.1">Here is a </span><a id="_idIndexMarker493"/><span class="koboSpan" id="kobo.471.1">sample JWT string containing </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">a payload:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.473.1">
{  "sub": "scott2",
  "roles": [
    "ADMIN"
  ],
  "iss": "Modern API Development with Spring and
     Spring Boot",
  "exp": 1676526792,
  "iat": 1676525892
}</span></pre>
<p><span class="koboSpan" id="kobo.474.1">The preceding payload contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">sub</span></strong><span class="koboSpan" id="kobo.476.1"> (subject), </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">iss</span></strong><span class="koboSpan" id="kobo.478.1"> (issuer), </span><strong class="source-inline"><span class="koboSpan" id="kobo.479.1">roles</span></strong><span class="koboSpan" id="kobo.480.1"> (custom claim roles), </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">exp</span></strong><span class="koboSpan" id="kobo.482.1"> (expires), </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">iat</span></strong><span class="koboSpan" id="kobo.484.1"> (issued at), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">jti</span></strong><span class="koboSpan" id="kobo.486.1"> (JWT </span><span class="No-Break"><span class="koboSpan" id="kobo.487.1">ID) fields.</span></span></p>
<h3><span class="koboSpan" id="kobo.488.1">Signature</span></h3>
<p><span class="koboSpan" id="kobo.489.1">A </span><strong class="bold"><span class="koboSpan" id="kobo.490.1">signature</span></strong><span class="koboSpan" id="kobo.491.1"> is </span><a id="_idIndexMarker494"/><span class="koboSpan" id="kobo.492.1">also a Base64-encoded string and makes up the third part </span><a id="_idIndexMarker495"/><span class="koboSpan" id="kobo.493.1">of a JWT-encoded string. </span><span class="koboSpan" id="kobo.493.2">A signature is there to protect the content of the JWT. </span><span class="koboSpan" id="kobo.493.3">The content is visible but cannot be modified if the token is signed. </span><span class="koboSpan" id="kobo.493.4">A Base64-encoded header and payload are passed to the signature’s algorithm, along with either a secret or a public key to make the token a signed token. </span><span class="koboSpan" id="kobo.493.5">If you wish to include any sensitive or secret information in the payload, then it’s better to encrypt it before assigning it to </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">the payload.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">A signature makes sure that the content is not modified once it is received. </span><span class="koboSpan" id="kobo.495.2">The use of a public/private key enhances the security step by verifying </span><span class="No-Break"><span class="koboSpan" id="kobo.496.1">the sender.</span></span></p>
<p><span class="koboSpan" id="kobo.497.1">You can use a combination of both a JWT and JWE. </span><span class="koboSpan" id="kobo.497.2">However, the recommended way is to first encrypt the payload using JWE and then </span><span class="No-Break"><span class="koboSpan" id="kobo.498.1">sign it.</span></span></p>
<p><span class="koboSpan" id="kobo.499.1">We’ll use public/private keys to sign the token in the next section. </span><span class="koboSpan" id="kobo.499.2">Let’s jump into coding in the </span><span class="No-Break"><span class="koboSpan" id="kobo.500.1">next section.</span></span></p>
<h1 id="_idParaDest-156"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.501.1">Securing REST APIs with JWT</span></h1>
<p><span class="koboSpan" id="kobo.502.1">In this section, you’ll secure the REST endpoints exposed in </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.503.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.504.1">, </span><em class="italic"><span class="koboSpan" id="kobo.505.1">Writing Business Logic for APIs</span></em><span class="koboSpan" id="kobo.506.1">. </span><span class="koboSpan" id="kobo.506.2">Therefore, we’ll use the code from </span><a href="B19349_04.xhtml#_idTextAnchor097"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.507.1">Chapter 4</span></em></span></a><span class="koboSpan" id="kobo.508.1"> and enhance it to secure </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">the APIs.</span></span></p>
<p><span class="koboSpan" id="kobo.510.1">The REST APIs</span><a id="_idIndexMarker496"/><span class="koboSpan" id="kobo.511.1"> should be protected using the </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">following techniques:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.513.1">No secure API should be accessed without </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">a JWT.</span></span></li>
<li><span class="koboSpan" id="kobo.515.1">A JWT can be generated using sign-in/sign-up or a </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">refresh token.</span></span></li>
<li><span class="koboSpan" id="kobo.517.1">A JWT and a refresh token should only be provided for a valid user’s username/password combination or a valid </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">user sign-up.</span></span></li>
<li><span class="koboSpan" id="kobo.519.1">The password should be stored in an encoded format using a </span><strong class="source-inline"><span class="koboSpan" id="kobo.520.1">bcrypt</span></strong><span class="koboSpan" id="kobo.521.1"> strong </span><span class="No-Break"><span class="koboSpan" id="kobo.522.1">hashing function.</span></span></li>
<li><span class="koboSpan" id="kobo.523.1">The JWT should be signed with </span><strong class="bold"><span class="koboSpan" id="kobo.524.1">Rivest-Shamir-Adleman</span></strong><span class="koboSpan" id="kobo.525.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.526.1">RSA</span></strong><span class="koboSpan" id="kobo.527.1">) keys with a </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">strong algorithm.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.529.1">RSA</span></p>
<p class="callout"><span class="koboSpan" id="kobo.530.1">RSA is an algorithm approved by the </span><strong class="bold"><span class="koboSpan" id="kobo.531.1">Federal Information Processing Standards</span></strong><em class="italic"> </em><span class="koboSpan" id="kobo.532.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.533.1">FIPS</span></strong><span class="koboSpan" id="kobo.534.1">) (FIPS 186) for digital signatures and in </span><strong class="bold"><span class="koboSpan" id="kobo.535.1">Special Publication</span></strong><span class="koboSpan" id="kobo.536.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.537.1">SP</span></strong><span class="koboSpan" id="kobo.538.1">) (SP800-56B) for </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">key establishment.</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.540.1">Claims in the payload should not store sensitive or secured information. </span><span class="koboSpan" id="kobo.540.2">If they do, then they should </span><span class="No-Break"><span class="koboSpan" id="kobo.541.1">be encrypted.</span></span></li>
<li><span class="koboSpan" id="kobo.542.1">You should be able to authorize API access for </span><span class="No-Break"><span class="koboSpan" id="kobo.543.1">certain roles.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.544.1">We need to include new APIs for the authorization flow. </span><span class="koboSpan" id="kobo.544.2">Let’s add </span><span class="No-Break"><span class="koboSpan" id="kobo.545.1">them first.</span></span></p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.546.1">Adding new APIs</span></h2>
<p><span class="koboSpan" id="kobo.547.1">You will </span><a id="_idIndexMarker497"/><span class="koboSpan" id="kobo.548.1">enhance the existing APIs by adding four new APIs – sign-up, sign-in, sign-out, and a refresh token. </span><span class="koboSpan" id="kobo.548.2">The sign-up, sign-in, and sign-out operations </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">are self-explanatory.</span></span></p>
<p><span class="koboSpan" id="kobo.550.1">The refresh token provides a new access token (JWT) once the existing token expires. </span><span class="koboSpan" id="kobo.550.2">This is the reason why the sign-up/sign-in API provides two types of tokens – an access token and a refresh token as a part of its response. </span><span class="koboSpan" id="kobo.550.3">The JWT access token self-expires; therefore, a sign-out operation would only remove the </span><span class="No-Break"><span class="koboSpan" id="kobo.551.1">refresh token.</span></span></p>
<p><span class="koboSpan" id="kobo.552.1">Let’s add these APIs to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">openapi.yaml</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.554.1">document next.</span></span></p>
<p><span class="koboSpan" id="kobo.555.1">Apart from adding the new APIs, you also need to add a new user tag for these APIs that will expose all these APIs through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.556.1">UserApi</span></strong><span class="koboSpan" id="kobo.557.1"> interface. </span><span class="koboSpan" id="kobo.557.2">Let’s first add a </span><span class="No-Break"><span class="koboSpan" id="kobo.558.1">sign-up endpoint.</span></span></p>
<h3><span class="koboSpan" id="kobo.559.1">Sign-up endpoint</span></h3>
<p><span class="koboSpan" id="kobo.560.1">Add the following</span><a id="_idIndexMarker498"/><span class="koboSpan" id="kobo.561.1"> specification for the sign-up endpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.562.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">openapi.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.564.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.565.1">/api/v1/users</span></strong><span class="koboSpan" id="kobo.566.1">:  post:
    tags:
      - user
    summary: Signup the a new customer (user)
    description: Creates a new customer (user)
    operationId: signUp
    requestBody:
      content:
        application/xml:
          schema:
            $ref: '#/components/schemas/User'
        application/json:
          schema:
            $ref: '#/components/schemas/User'
    responses:
      201:
        description: For successful user creation.
</span><span class="koboSpan" id="kobo.566.2">        content:
          application/xml:
            schema:
              $ref: '#/components/schemas/SignedInUser'
          application/json:
            schema:
              $ref: '#/components/schemas/</span><strong class="bold"><span class="koboSpan" id="kobo.567.1">SignedInUser'</span></strong></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/api/openapi.yaml"><span class="No-Break"><span class="koboSpan" id="kobo.568.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/api/openapi.yaml</span></span></a></p>
<p><span class="koboSpan" id="kobo.569.1">The sign-up</span><a id="_idIndexMarker499"/><span class="koboSpan" id="kobo.570.1"> API call returns the new </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.572.1"> model. </span><span class="koboSpan" id="kobo.572.2">This contains </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">accessToken</span></strong><span class="koboSpan" id="kobo.574.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">refreshToken</span></strong><span class="koboSpan" id="kobo.576.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.577.1">username</span></strong><span class="koboSpan" id="kobo.578.1">, and user ID fields. </span><span class="koboSpan" id="kobo.578.2">The code to add the model is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">following snippet:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.580.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.581.1">:  description: Signed-in user information
  type: object
  properties:
    refreshToken:
      description: Refresh Token
      type: string
    accessToken:
      description: JWT Token aka access token
      type: string
    username:
      description: User Name
      type: string
    userId:
      description: User Identifier
      type: string</span></pre>
<p><span class="koboSpan" id="kobo.582.1">Now, let’s add </span><a id="_idIndexMarker500"/><span class="koboSpan" id="kobo.583.1">the </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">sign-in endpoint.</span></span></p>
<h3><span class="koboSpan" id="kobo.585.1">Sign-in endpoint definition</span></h3>
<p><span class="koboSpan" id="kobo.586.1">Add the</span><a id="_idIndexMarker501"/><span class="koboSpan" id="kobo.587.1"> following specification for the sign-in endpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">openapi.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.590.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.591.1">/api/v1/auth/token</span></strong><span class="koboSpan" id="kobo.592.1">:  post:
    tags:
      - user
    summary: Signin the customer (user)
    description: Generates the JWT and refresh token
    operationId: signIn
    requestBody:
      content:
        application/xml:
          schema:
            $ref: '#/components/schemas/SignInReq'
        application/json:
          schema:
            $ref: '#/components/schemas/</span><strong class="bold"><span class="koboSpan" id="kobo.593.1">SignInReq'</span></strong><span class="koboSpan" id="kobo.594.1">
    responses:
      200:
        description: Returns the access and refresh token.
</span><span class="koboSpan" id="kobo.594.2">        content:
          application/xml:
            schema:
              $ref: '#/components/schemas/SignedInUser'
          application/json:
            schema:
              $ref: '#/components/schemas/SignedInUser'</span></pre>
<p><span class="koboSpan" id="kobo.595.1">The </span><a id="_idIndexMarker502"/><span class="koboSpan" id="kobo.596.1">sign-in API uses the new request payload object – </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">SignInReq</span></strong><span class="koboSpan" id="kobo.598.1">. </span><span class="koboSpan" id="kobo.598.2">The object just contains the username and password fields. </span><span class="koboSpan" id="kobo.598.3">Let’s add it, </span><span class="No-Break"><span class="koboSpan" id="kobo.599.1">as follows:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.600.1">SignInReq</span></strong><span class="koboSpan" id="kobo.601.1">:  description: Request body for Sign-in
  type: object
  properties:
    username:
      description: username of the User
      type: string
    password:
      description: password of the User
      type: string</span></pre>
<p><span class="koboSpan" id="kobo.602.1">Now, let’s add the </span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">sign-out endpoint.</span></span></p>
<h3><span class="koboSpan" id="kobo.604.1">Sign-out endpoint</span></h3>
<p><span class="koboSpan" id="kobo.605.1">Add </span><a id="_idIndexMarker503"/><span class="koboSpan" id="kobo.606.1">the following specification for the sign-out endpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.607.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">openapi.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.609.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.610.1">
# </span><strong class="bold"><span class="koboSpan" id="kobo.611.1">Under the /api/v1/auth/token</span></strong><span class="koboSpan" id="kobo.612.1">delete:
  tags:
    - user
  summary: Signouts the customer (user)
  description: Signouts the customer (user).
</span><span class="koboSpan" id="kobo.612.2">  operationId: signOut
  requestBody:
    content:
      application/xml:
        schema:
          $ref: '#/components/schemas/RefreshToken'
      application/json:
        schema:
          $ref: '#/components/schemas/</span><strong class="bold"><span class="koboSpan" id="kobo.613.1">RefreshToken'</span></strong><span class="koboSpan" id="kobo.614.1">
  responses:
    202:
      description: Accepts the request for logout.</span></pre>
<p><span class="koboSpan" id="kobo.615.1">In an ideal scenario, you should remove the refresh token of a user received from the request. </span><span class="koboSpan" id="kobo.615.2">You can fetch the user ID from the token itself and then use that ID to remove the refresh token from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.616.1">USER_TOKEN</span></strong><span class="koboSpan" id="kobo.617.1"> table. </span><span class="koboSpan" id="kobo.617.2">This endpoint requires you to send a valid </span><span class="No-Break"><span class="koboSpan" id="kobo.618.1">access token.</span></span></p>
<p><span class="koboSpan" id="kobo.619.1">We have opted for </span><a id="_idIndexMarker504"/><span class="koboSpan" id="kobo.620.1">an easy way to remove the token, which is for it to be sent by the user as a payload. </span><span class="koboSpan" id="kobo.620.2">Therefore, this endpoint needs the following new model, </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">RefreshToken</span></strong><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">Here is the code to add </span><span class="No-Break"><span class="koboSpan" id="kobo.623.1">the model:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.624.1">RefreshToken:</span></strong><span class="koboSpan" id="kobo.625.1">  description: Contains the refresh token
  type: object
  properties:
    refreshToken:
      description: Refresh Token
      type: string</span></pre>
<p><span class="koboSpan" id="kobo.626.1">Finally, let’s add an endpoint to refresh the </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">access token.</span></span></p>
<h3><span class="koboSpan" id="kobo.628.1">Refresh token endpoint</span></h3>
<p><span class="koboSpan" id="kobo.629.1">Add the</span><a id="_idIndexMarker505"/><span class="koboSpan" id="kobo.630.1"> following specification for the refresh token endpoint </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.632.1">openapi.yaml</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.634.1">/api/v1/auth/token/refresh:</span></strong><span class="koboSpan" id="kobo.635.1">  post:
    tags:
      - user
    summary: Provides new JWT based on valid refresh token.
</span><span class="koboSpan" id="kobo.635.2">    description: Provides JWT based on valid refresh token.
</span><span class="koboSpan" id="kobo.635.3">    operationId: getAccessToken
    requestBody:
      content:
        application/json:
          schema:
            $ref: '#/components/schemas/RefreshToken'
    responses:
      200:
        description: For successful operation.
</span><span class="koboSpan" id="kobo.635.4">        content:
          application/json:
            schema:
              $ref: '#/components/schemas/SignedInUser'</span></pre>
<p><span class="koboSpan" id="kobo.636.1">Here, we </span><a id="_idIndexMarker506"/><span class="koboSpan" id="kobo.637.1">have used an exception by defining the refresh endpoint, in terms of forming a URI that represents the refresh token resources. </span><span class="koboSpan" id="kobo.637.2">Ideally, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.638.1">POST</span></strong><span class="koboSpan" id="kobo.639.1"> call generates the new resource defined in URI. </span><span class="koboSpan" id="kobo.639.2">However, this endpoint generates the access token in place of the refresh token inside the response </span><span class="No-Break"><span class="koboSpan" id="kobo.640.1">object, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.641.1">SignedInUser</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.642.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.643.1">In the existing code, we don’t have a table to store the refresh token. </span><span class="koboSpan" id="kobo.643.2">Therefore, let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.644.1">add one.</span></span></p>
<h3><span class="koboSpan" id="kobo.645.1">Storing the refresh token using a database table</span></h3>
<p><span class="koboSpan" id="kobo.646.1">You can </span><a id="_idIndexMarker507"/><span class="koboSpan" id="kobo.647.1">modify the Flyway database script to add a new table, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.648.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.649.1">
create TABLE IF NOT EXISTS ecomm.</span><strong class="bold"><span class="koboSpan" id="kobo.650.1">user_token</span></strong><span class="koboSpan" id="kobo.651.1"> (   id uuid NOT NULL DEFAULT random_uuid(),
   refresh_token varchar(128),
   user_id uuid NOT NULL,
   PRIMARY KEY(id),
   FOREIGN KEY (user_id)
      REFERENCES ecomm.</span><strong class="bold"><span class="koboSpan" id="kobo.652.1">"user"</span></strong><span class="koboSpan" id="kobo.653.1">(id)
);</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/db/migration/V1.0.0__Init.sql"><span class="No-Break"><span class="koboSpan" id="kobo.654.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/db/migration/V1.0.0__Init.sql</span></span></a></p>
<p><span class="koboSpan" id="kobo.655.1">Here, the</span><a id="_idIndexMarker508"/><span class="koboSpan" id="kobo.656.1"> table contains three fields – </span><strong class="source-inline"><span class="koboSpan" id="kobo.657.1">id</span></strong><span class="koboSpan" id="kobo.658.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.659.1">refresh_token</span></strong><span class="koboSpan" id="kobo.660.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.661.1">user_id</span></strong><span class="koboSpan" id="kobo.662.1"> – for storing the row identifier (primary key), the refresh token, and the user’s ID, respectively. </span><span class="koboSpan" id="kobo.662.2">Also, we have put the table name </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">user</span></strong><span class="koboSpan" id="kobo.664.1"> in double quotation marks because the H2 database also makes use of the </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">term </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.666.1">"user"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.667.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.668.1">Now, you have completed the API specification modification for authentication and authorization. </span><span class="koboSpan" id="kobo.668.2">Next, let’s start writing the implementation code for </span><span class="No-Break"><span class="koboSpan" id="kobo.669.1">JWT-based authentication.</span></span></p>
<h2 id="_idParaDest-158"><a id="_idTextAnchor157"/><span class="koboSpan" id="kobo.670.1">Implementing the JWT manager</span></h2>
<p><span class="koboSpan" id="kobo.671.1">Let’s add a </span><a id="_idIndexMarker509"/><span class="koboSpan" id="kobo.672.1">constant class that contains </span><a id="_idIndexMarker510"/><span class="koboSpan" id="kobo.673.1">all the constants related to the security functionality before we implement the JWT manager class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.674.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.675.1">
public class </span><strong class="bold"><span class="koboSpan" id="kobo.676.1">Constants</span></strong><span class="koboSpan" id="kobo.677.1"> {  public static final String ENCODER_ID = "bcrypt";
  public static final String API_URL_PREFIX = "/api/v1/**";
  public static final String H2_URL_PREFIX = "/h2-console/**";
  public static final String SIGNUP_URL = "/api/v1/users";
  public static final String TOKEN_URL = "/api/v1/auth/token";
  public static final String REFRESH_URL =
                                "/api/v1/auth/token/refresh";
  public static final String PRODUCTS_URL =
     "/api/v1/products/**";
  public static final String AUTHORIZATION =
    "Authorization";
  public static final String TOKEN_PREFIX = "Bearer ";
  public static final String SECRET_KEY = "SECRET_KEY";
  public static final long EXPIRATION_TIME = 900_000;
  public static final String ROLE_CLAIM = "roles";
  public static final String AUTHORITY_PREFIX = "ROLE_";
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/Constants.java"><span class="No-Break"><span class="koboSpan" id="kobo.678.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/Constants.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.679.1">These constants are self-explanatory, except the </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">EXPIRATION_TIME</span></strong><span class="koboSpan" id="kobo.681.1"> long value (</span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">900_000</span></strong><span class="koboSpan" id="kobo.683.1">), which represents 15 minutes as a </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">time unit.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">Now, we</span><a id="_idIndexMarker511"/><span class="koboSpan" id="kobo.686.1"> can define the JWT manager class – </span><strong class="source-inline"><span class="koboSpan" id="kobo.687.1">JwtManager</span></strong><span class="koboSpan" id="kobo.688.1">. </span><strong class="bold"><span class="koboSpan" id="kobo.689.1">JwtManager</span></strong><span class="koboSpan" id="kobo.690.1"> is a </span><a id="_idIndexMarker512"/><span class="koboSpan" id="kobo.691.1">custom class that is responsible </span><a id="_idIndexMarker513"/><span class="koboSpan" id="kobo.692.1">for generating a new JWT. </span><span class="koboSpan" id="kobo.692.2">It uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.693.1">java-jwt</span></strong><span class="koboSpan" id="kobo.694.1"> library from </span><a href="http://auth0.com"><span class="koboSpan" id="kobo.695.1">auth0.com</span></a><span class="koboSpan" id="kobo.696.1">. </span><span class="koboSpan" id="kobo.696.2">We will use public/private keys to sign the token. </span><span class="koboSpan" id="kobo.696.3">Let’s define this class, </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.698.1">
@Componentpublic class </span><strong class="bold"><span class="koboSpan" id="kobo.699.1">JwtManager</span></strong><span class="koboSpan" id="kobo.700.1"> {
  private final RSAPrivateKey privateKey;
  private final RSAPublicKey publicKey;
  public JwtManager(@Lazy RSAPrivateKey privateKey,
    @Lazy RSAPublicKey publicKey) {
    this.privateKey = privateKey;
    this.publicKey = publicKey;
  }
  public String create(UserDetails principal) {
    final long now = System.currentTimeMillis();
    return </span><strong class="bold"><span class="koboSpan" id="kobo.701.1">JWT</span></strong><span class="koboSpan" id="kobo.702.1">.create()
        .withIssuer("Modern API Development with Spring…")
        .withSubject(principal.getUsername())
        .withClaim(
            ROLE_</span><strong class="bold"><span class="koboSpan" id="kobo.703.1">CLAIM</span></strong><span class="koboSpan" id="kobo.704.1">,
            principal.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(toList()))
        .withIssuedAt(new Date(now))
        .withExpiresAt(new Date(now + EXPIRATION_TIME))
        .</span><strong class="bold"><span class="koboSpan" id="kobo.705.1">sign</span></strong><span class="koboSpan" id="kobo.706.1">(Algorithm.</span><strong class="bold"><span class="koboSpan" id="kobo.707.1">RSA256</span></strong><span class="koboSpan" id="kobo.708.1">(publicKey, privateKey));
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/JwtManager.java"><span class="No-Break"><span class="koboSpan" id="kobo.709.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/JwtManager.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.710.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">JWT</span></strong><span class="koboSpan" id="kobo.712.1"> is</span><a id="_idIndexMarker514"/><span class="koboSpan" id="kobo.713.1"> a class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">java-jwt</span></strong><span class="koboSpan" id="kobo.715.1"> library that provides a fluent API to generate the token. </span><span class="koboSpan" id="kobo.715.2">It adds issuer (</span><strong class="source-inline"><span class="koboSpan" id="kobo.716.1">iss</span></strong><span class="koboSpan" id="kobo.717.1">), subject (</span><strong class="source-inline"><span class="koboSpan" id="kobo.718.1">sub</span></strong><span class="koboSpan" id="kobo.719.1">), issued at (</span><strong class="source-inline"><span class="koboSpan" id="kobo.720.1">iat</span></strong><span class="koboSpan" id="kobo.721.1">), and expired at (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.722.1">exp</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.723.1">) claims.</span></span></p>
<p><span class="koboSpan" id="kobo.724.1">It also </span><a id="_idIndexMarker515"/><span class="koboSpan" id="kobo.725.1">adds a custom claim, </span><strong class="source-inline"><span class="koboSpan" id="kobo.726.1">ROLE_CLAIM</span></strong><span class="koboSpan" id="kobo.727.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">roles</span></strong><span class="koboSpan" id="kobo.729.1">), which is populated using authorities from </span><strong class="source-inline"><span class="koboSpan" id="kobo.730.1">UserDetails</span></strong><span class="koboSpan" id="kobo.731.1">. </span><span class="koboSpan" id="kobo.731.2">This is an interface provided by Spring Security. </span><span class="koboSpan" id="kobo.731.3">You can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.732.1">org.springframework.security. </span><span class="koboSpan" id="kobo.732.2">core.userdetails.User.builder()</span></strong><span class="koboSpan" id="kobo.733.1"> method to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.734.1">UserBuilder</span></strong><span class="koboSpan" id="kobo.735.1"> class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">UserBuilder</span></strong><span class="koboSpan" id="kobo.737.1"> is a final builder class that allows you to build an instance </span><span class="No-Break"><span class="koboSpan" id="kobo.738.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">UserDetails</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.741.1">Finally, this </span><a id="_idIndexMarker516"/><span class="koboSpan" id="kobo.742.1">method (</span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">JwtManager.create()</span></strong><span class="koboSpan" id="kobo.744.1">) signs the JWT, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">SHA256</span></strong><span class="koboSpan" id="kobo.746.1"> with the RSA algorithm by calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.747.1">sign</span></strong><span class="koboSpan" id="kobo.748.1"> operation, which uses the </span><a id="_idIndexMarker517"/><span class="koboSpan" id="kobo.749.1">provided public and private RSA keys. </span><span class="koboSpan" id="kobo.749.2">The JWT header specifies an </span><strong class="source-inline"><span class="koboSpan" id="kobo.750.1">HS256</span></strong><span class="koboSpan" id="kobo.751.1"> value for the algorithm (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">alg</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">) claim.</span></span></p>
<p><span class="koboSpan" id="kobo.754.1">Signing is done using the public and private RSA keys. </span><span class="koboSpan" id="kobo.754.2">Let’s add the code for RSA key management in our sample </span><span class="No-Break"><span class="koboSpan" id="kobo.755.1">e-commerce application.</span></span></p>
<h3><span class="koboSpan" id="kobo.756.1">Generating the public/private keys</span></h3>
<p><span class="koboSpan" id="kobo.757.1">You can </span><a id="_idIndexMarker518"/><span class="koboSpan" id="kobo.758.1">use JDK’s keytool to create a key store and generate public/private keys, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.759.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.760.1">
$ </span><strong class="bold"><span class="koboSpan" id="kobo.761.1">keytool</span></strong><span class="koboSpan" id="kobo.762.1"> -genkey -alias </span><strong class="bold"><span class="koboSpan" id="kobo.763.1">"jwt-sign-key"</span></strong><span class="koboSpan" id="kobo.764.1"> -keyalg RSA -keystore </span><strong class="bold"><span class="koboSpan" id="kobo.765.1">jwt-keystore.jks</span></strong><span class="koboSpan" id="kobo.766.1"> -keysize 4096Enter keystore password:
Re-enter new password:
What is your first and last name?
</span><span class="koboSpan" id="kobo.766.2">[Unknown]: Modern API Development
What is the name of your organizational unit?
</span><span class="koboSpan" id="kobo.766.3">[Unknown]: Org Unit
What is the name of your organization?
</span><span class="koboSpan" id="kobo.766.4">[Unknown]: Packt
What is the name of your City or Locality?
</span><span class="koboSpan" id="kobo.766.5">[Unknown]: City
What is the name of your State or Province?
</span><span class="koboSpan" id="kobo.766.6">[Unknown]: State
What is the two-letter country code for this unit?
</span><span class="koboSpan" id="kobo.766.7">[Unknown]: IN
Securing REST APIs with JWT 191
Is CN=Modern API Development, OU=Org Unit, O=Packt, L=City, ST=State, C=IN correct?
</span><span class="koboSpan" id="kobo.766.8">[no]: yes
Generating 4,096 bit RSA key pair and self-signed certificate (SHA384withRSA) with a </span><strong class="bold"><span class="koboSpan" id="kobo.767.1">validity of 90 days</span></strong><span class="koboSpan" id="kobo.768.1">
for: CN=Modern API Development, OU=Org Unit, O=Packt, L=City, ST=State, C=IN</span></pre>
<p><span class="koboSpan" id="kobo.769.1">The</span><a id="_idIndexMarker519"/><span class="koboSpan" id="kobo.770.1"> generated key store should be placed under the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">src/main/resources</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.772.1"> directory.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.773.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.774.1">Public/private keys are valid only for 90 days from the time they are generated. </span><span class="koboSpan" id="kobo.774.2">Therefore, make sure that you create a new set of public/private keys before you run this </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">chapter’s code.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">Required values used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.777.1">keytool</span></strong><span class="koboSpan" id="kobo.778.1"> command should also be configured in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.779.1">application.properties</span></strong><span class="koboSpan" id="kobo.780.1"> file, as </span><span class="No-Break"><span class="koboSpan" id="kobo.781.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.782.1">
app.security.jwt.keystore-location=</span><strong class="bold"><span class="koboSpan" id="kobo.783.1">jwt-keystore.jks</span></strong><span class="koboSpan" id="kobo.784.1">app.security.jwt.keystore-password=password
app.security.jwt.key-alias=</span><strong class="bold"><span class="koboSpan" id="kobo.785.1">jwt-sign-key</span></strong><span class="koboSpan" id="kobo.786.1">
app.security.jwt.private-key-passphrase=password</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/application.properties"><span class="No-Break"><span class="koboSpan" id="kobo.787.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/resources/application.properties</span></span></a></p>
<p><span class="koboSpan" id="kobo.788.1">Now, we can configure the key store and public/private keys in the security </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">configuration class.</span></span></p>
<h3><span class="koboSpan" id="kobo.790.1">Configuring the key store and keys</span></h3>
<p><span class="koboSpan" id="kobo.791.1">Let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.792.1">SecurityConfig</span></strong><span class="koboSpan" id="kobo.793.1"> configuration class to configure the security relation configurations. </span><span class="koboSpan" id="kobo.793.2">This </span><a id="_idIndexMarker520"/><span class="koboSpan" id="kobo.794.1">class extends</span><a id="_idIndexMarker521"/><span class="koboSpan" id="kobo.795.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.796.1">WebSecurityConfigurerAdapter</span></strong><span class="koboSpan" id="kobo.797.1"> class. </span><span class="koboSpan" id="kobo.797.2">Here’s the code to </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">do this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.799.1">
@Configuration@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class </span><strong class="bold"><span class="koboSpan" id="kobo.800.1">SecurityConfig</span></strong><span class="koboSpan" id="kobo.801.1"> {
  @Value("${app.security.jwt.keystore-location}")
  private String keyStorePath;
  @Value("${app.security.jwt.keystore-password}")
  private String keyStorePassword;
  @Value("${app.security.jwt.key-alias}")
  private String keyAlias;
  @Value("${app.security.jwt.private-key-passphrase}")
  private String privateKeyPassphrase;
  …
  …
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java"><span class="No-Break"><span class="koboSpan" id="kobo.802.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.803.1">Here, we have added all the properties defined </span><span class="No-Break"><span class="koboSpan" id="kobo.804.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">application.properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.806.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.807.1">Now, we can make use of the properties defined in </span><strong class="source-inline"><span class="koboSpan" id="kobo.808.1">application.properties</span></strong><span class="koboSpan" id="kobo.809.1"> to configure the </span><strong class="source-inline"><span class="koboSpan" id="kobo.810.1">KeyStore</span></strong><span class="koboSpan" id="kobo.811.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.812.1">RSAPrivateKey</span></strong><span class="koboSpan" id="kobo.813.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.814.1">RSAPublicKey</span></strong><span class="koboSpan" id="kobo.815.1"> beans in the security configuration class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">few subsections.</span></span></p>
<h3><span class="koboSpan" id="kobo.817.1">KeyStore bean</span></h3>
<p><span class="koboSpan" id="kobo.818.1">You can </span><a id="_idIndexMarker522"/><span class="koboSpan" id="kobo.819.1">create a new bean for KeyStore by adding the following method and annotating it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.820.1">@Bean</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.821.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.822.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.823.1">:</span></span></p>
<pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.824.1">@Bean</span></strong><span class="koboSpan" id="kobo.825.1">public KeyStore </span><strong class="bold"><span class="koboSpan" id="kobo.826.1">keyStore</span></strong><span class="koboSpan" id="kobo.827.1">() {
  try {
    KeyStore keyStore =
            KeyStore.getInstance(KeyStore.getDefaultType());
    InputStream resStream = Thread.currentThread().
</span><span class="koboSpan" id="kobo.827.2">      getContextClassLoader().getResourceAsStream
        (</span><strong class="bold"><span class="koboSpan" id="kobo.828.1">keyStorePath</span></strong><span class="koboSpan" id="kobo.829.1">);
    keyStore.load(resStream, </span><strong class="bold"><span class="koboSpan" id="kobo.830.1">keyStorePassword</span></strong><span class="koboSpan" id="kobo.831.1">.
</span><span class="koboSpan" id="kobo.831.2">      toCharArray());
    return keyStore;
  } catch (IOException | CertificateException |
     NoSuchAlgorithmException | KeyStoreException e) {
    LOG.error("Unable to load keystore: {}",
      keyStorePath, e);
  }
  throw new IllegalArgumentException
    ("Can't load keystore");
}</span></pre>
<p><span class="koboSpan" id="kobo.832.1">This creates a </span><strong class="source-inline"><span class="koboSpan" id="kobo.833.1">KeyStore</span></strong><span class="koboSpan" id="kobo.834.1"> instance, using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.835.1">KeyStore</span></strong><span class="koboSpan" id="kobo.836.1"> class from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.837.1">java.security</span></strong><span class="koboSpan" id="kobo.838.1"> package. </span><span class="koboSpan" id="kobo.838.2">It loads the key store from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.839.1">src/main/resources</span></strong><span class="koboSpan" id="kobo.840.1"> package and uses the password configuration in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.841.1">application.properties</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.842.1"> file.</span></span></p>
<p><span class="koboSpan" id="kobo.843.1">Let’s define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">RSAPrivateKey</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.845.1">bean next.</span></span></p>
<h3><span class="koboSpan" id="kobo.846.1">RSAPrivateKey bean</span></h3>
<p><span class="koboSpan" id="kobo.847.1">You can </span><a id="_idIndexMarker523"/><span class="koboSpan" id="kobo.848.1">create a new bean for </span><strong class="source-inline"><span class="koboSpan" id="kobo.849.1">RSAPrivateKey</span></strong><span class="koboSpan" id="kobo.850.1"> by adding the following method and annotating it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.851.1">@Bean</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.852.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.854.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.855.1">
@Beanpublic </span><strong class="bold"><span class="koboSpan" id="kobo.856.1">RSAPrivateKey</span></strong><span class="koboSpan" id="kobo.857.1"> jwtSigningKey(KeyStore keyStore) {
  try {
    Key key = keyStore.getKey(</span><strong class="bold"><span class="koboSpan" id="kobo.858.1">keyAlias</span></strong><span class="koboSpan" id="kobo.859.1">,
                         </span><strong class="bold"><span class="koboSpan" id="kobo.860.1">privateKeyPassphrase</span></strong><span class="koboSpan" id="kobo.861.1">.toCharArray());
    if (key instanceof RSAPrivateKey) {
      return (RSAPrivateKey) key;
    }
  } catch (UnrecoverableKeyException |
     NoSuchAlgorithmException | KeyStoreException e) {
    LOG.error("key from keystore: {}", keyStorePath, e);
  }
  throw new IllegalArgumentException("Cant load
     private key");
}</span></pre>
<p><span class="koboSpan" id="kobo.862.1">This method uses a key alias and a private key password to retrieve the private key, which is used to return the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">RSAPrivateKey</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.864.1"> bean.</span></span></p>
<p><span class="koboSpan" id="kobo.865.1">Let’s define the </span><strong class="source-inline"><span class="koboSpan" id="kobo.866.1">RSAPublicKey</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.867.1">bean next.</span></span></p>
<h3><span class="koboSpan" id="kobo.868.1">RSAPublicKey bean</span></h3>
<p><span class="koboSpan" id="kobo.869.1">You can </span><a id="_idIndexMarker524"/><span class="koboSpan" id="kobo.870.1">create a new bean for </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">RSAPublicKey</span></strong><span class="koboSpan" id="kobo.872.1"> by adding the following method and annotating it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">@Bean</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.874.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.876.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.877.1">
@Beanpublic </span><strong class="bold"><span class="koboSpan" id="kobo.878.1">RSAPublicKey</span></strong><span class="koboSpan" id="kobo.879.1"> jwtValidationKey(KeyStore keyStore) {
 try {
  Certificate certificate = keyStore.getCertificate
    (</span><strong class="bold"><span class="koboSpan" id="kobo.880.1">keyAlias</span></strong><span class="koboSpan" id="kobo.881.1">);
  PublicKey publicKey = </span><strong class="bold"><span class="koboSpan" id="kobo.882.1">certificate.getPublicKey()</span></strong><span class="koboSpan" id="kobo.883.1">;
  if (publicKey instanceof RSAPublicKey) {
    return (RSAPublicKey) publicKey;
  }
 } catch (KeyStoreException e) {
   LOG.error("key from keystore: {}", keyStorePath, e);
 }
 throw new IllegalArgumentException("Can't load public key");
}</span></pre>
<p><span class="koboSpan" id="kobo.884.1">Again, a key alias is used to retrieve the certificate from the key store. </span><span class="koboSpan" id="kobo.884.2">Then, the public key is retrieved from the certificate </span><span class="No-Break"><span class="koboSpan" id="kobo.885.1">and returned.</span></span></p>
<p><span class="koboSpan" id="kobo.886.1">As you know, </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">JwtManager</span></strong><span class="koboSpan" id="kobo.888.1"> uses these public and private RSA keys to sign the JWT; therefore, a JWT decoder should use the same public key to decode the token. </span><span class="koboSpan" id="kobo.888.2">The Spring OAuth 2.0 resource server uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">org.springframework.security.oauth2.jwt. </span><span class="koboSpan" id="kobo.889.2">JwtDecoder</span></strong><span class="koboSpan" id="kobo.890.1"> interface to decode the token. </span><span class="koboSpan" id="kobo.890.2">Therefore, we need to create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.891.1">JwtDecoder</span></strong><span class="koboSpan" id="kobo.892.1"> implementation and set the same public key in it to decode </span><span class="No-Break"><span class="koboSpan" id="kobo.893.1">the token.</span></span></p>
<p><span class="koboSpan" id="kobo.894.1">The Spring OAuth 2.0 resource server provides a </span><strong class="source-inline"><span class="koboSpan" id="kobo.895.1">NimbusJwtDecoder</span></strong><span class="koboSpan" id="kobo.896.1"> implementation class of </span><strong class="source-inline"><span class="koboSpan" id="kobo.897.1">JwtDecoder</span></strong><span class="koboSpan" id="kobo.898.1">. </span><span class="koboSpan" id="kobo.898.2">Let’s now create a bean of it with the </span><span class="No-Break"><span class="koboSpan" id="kobo.899.1">public key.</span></span></p>
<h3><span class="koboSpan" id="kobo.900.1">JwtDecoder bean</span></h3>
<p><span class="koboSpan" id="kobo.901.1">You can </span><a id="_idIndexMarker525"/><span class="koboSpan" id="kobo.902.1">create a new bean for </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">JwtDecoder</span></strong><span class="koboSpan" id="kobo.904.1"> by adding the following method and annotating it with </span><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">@Bean</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.906.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.907.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.908.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.909.1">
@Beanpublic </span><strong class="bold"><span class="koboSpan" id="kobo.910.1">JwtDecoder</span></strong><span class="koboSpan" id="kobo.911.1"> jwtDecoder(RSAPublicKey rsaPublicKey) {
  return NimbusJwtDecoder.</span><strong class="bold"><span class="koboSpan" id="kobo.912.1">withPublicKey</span></strong><span class="koboSpan" id="kobo.913.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.914.1">rsaPublicKey</span></strong><span class="koboSpan" id="kobo.915.1">).build();
}</span></pre>
<p><span class="koboSpan" id="kobo.916.1">You have defined all the beans required to sign the JWT token. </span><span class="koboSpan" id="kobo.916.2">Now, you can implement the newly added </span><span class="No-Break"><span class="koboSpan" id="kobo.917.1">REST APIs.</span></span></p>
<h2 id="_idParaDest-159"><a id="_idTextAnchor158"/><span class="koboSpan" id="kobo.918.1">Implementing new APIs</span></h2>
<p><span class="koboSpan" id="kobo.919.1">Let’s </span><a id="_idIndexMarker526"/><span class="koboSpan" id="kobo.920.1">implement</span><a id="_idIndexMarker527"/><span class="koboSpan" id="kobo.921.1"> the APIs exposed using </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">UserApi</span></strong><span class="koboSpan" id="kobo.923.1">. </span><span class="koboSpan" id="kobo.923.2">This is a code part that was autogenerated using OpenAPI Codegen. </span><span class="koboSpan" id="kobo.923.3">First, you need to define a new entity mapped to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">user_token</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.925.1"> table.</span></span></p>
<h3><span class="koboSpan" id="kobo.926.1">Coding user token functionality</span></h3>
<p><span class="koboSpan" id="kobo.927.1">You</span><a id="_idIndexMarker528"/><span class="koboSpan" id="kobo.928.1"> can create </span><strong class="source-inline"><span class="koboSpan" id="kobo.929.1">UserTokenEntity</span></strong><span class="koboSpan" id="kobo.930.1"> based on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.931.1">user_token</span></strong><span class="koboSpan" id="kobo.932.1"> table, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.933.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.934.1">
@Entity@Table(name = "user_token")
public class UserTokenEntity {
  @Id
  @GeneratedValue
  @Column(name = "ID", updatable = false, nullable = false)
  private UUID id;
  @NotNull(message = "Refresh token is required.")
  @Basic(optional = false)
  @Column(name = "refresh_token")
  private String refreshToken;
  @ManyToOne(fetch = FetchType.LAZY)
  private UserEntity user;
  …
  …
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/UserTokenEntity.java"><span class="No-Break"><span class="koboSpan" id="kobo.935.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/UserTokenEntity.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.936.1">Similarly, we </span><a id="_idIndexMarker529"/><span class="koboSpan" id="kobo.937.1">can expose the following CRUD repository for </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">UserTokenEntity</span></strong><span class="koboSpan" id="kobo.939.1"> with the following two methods – </span><strong class="source-inline"><span class="koboSpan" id="kobo.940.1">deleteByUserId()</span></strong><span class="koboSpan" id="kobo.941.1">, which will remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.942.1">UserToken</span></strong><span class="koboSpan" id="kobo.943.1"> table record based on a given user ID, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.944.1">findByRefreshToken()</span></strong><span class="koboSpan" id="kobo.945.1">, which will find the </span><strong class="source-inline"><span class="koboSpan" id="kobo.946.1">UserToken</span></strong><span class="koboSpan" id="kobo.947.1"> table record based on a given refresh token. </span><span class="koboSpan" id="kobo.947.2">The code is illustrated in the </span><span class="No-Break"><span class="koboSpan" id="kobo.948.1">following snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.949.1">
public interface UserTokenRepository extends   CrudRepository&lt;UserTokenEntity, UUID&gt; {
  Optional&lt;UserTokenEntity&gt; findByRefreshToken
    (StringrefreshToken);
  Optional&lt;UserTokenEntity&gt; deleteByUserId(UUID userId);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserTokenRepository.java"><span class="No-Break"><span class="koboSpan" id="kobo.950.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserTokenRepository.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.951.1">You have defined both</span><a id="_idIndexMarker530"/><span class="koboSpan" id="kobo.952.1"> the entity and its repository. </span><span class="koboSpan" id="kobo.952.2">Now, you will add new operations in </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">UserService</span></strong><span class="koboSpan" id="kobo.954.1"> that will consume these </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">new classes.</span></span></p>
<h3><span class="koboSpan" id="kobo.956.1">Enhancing the UserService class</span></h3>
<p><span class="koboSpan" id="kobo.957.1">We also</span><a id="_idIndexMarker531"/><span class="koboSpan" id="kobo.958.1"> need to add new methods to </span><strong class="source-inline"><span class="koboSpan" id="kobo.959.1">UserService</span></strong><span class="koboSpan" id="kobo.960.1"> for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.961.1">UserApi</span></strong><span class="koboSpan" id="kobo.962.1"> interface. </span><span class="koboSpan" id="kobo.962.2">Let’s add new methods to the service, </span><span class="No-Break"><span class="koboSpan" id="kobo.963.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.964.1">
UserEntity findUserByUsername(String username);Optional&lt;SignedInUser&gt; createUser(User user);
SignedInUser getSignedInUser(UserEntity userEntity); Optional&lt;SignedInUser&gt; getAccessToken(RefreshToken refToken);
void removeRefreshToken(RefreshToken refreshToken);</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserService.java"><span class="No-Break"><span class="koboSpan" id="kobo.965.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserService.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.966.1">Here, each method performs a specific operation, as </span><span class="No-Break"><span class="koboSpan" id="kobo.967.1">outlined here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">findUserByUsername()</span></strong><span class="koboSpan" id="kobo.969.1">: This finds and returns a user based on a </span><span class="No-Break"><span class="koboSpan" id="kobo.970.1">given username.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">createUser()</span></strong><span class="koboSpan" id="kobo.972.1">: This adds a new signed-up user to </span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">the database.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">getSignedInUser()</span></strong><span class="koboSpan" id="kobo.975.1">: This creates a new model instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.976.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.977.1"> that holds the refresh token, access token (JWT), user ID, </span><span class="No-Break"><span class="koboSpan" id="kobo.978.1">and username.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.979.1">getAccessToken()</span></strong><span class="koboSpan" id="kobo.980.1">: This generates and returns a new access token (JWT) for a given valid </span><span class="No-Break"><span class="koboSpan" id="kobo.981.1">refresh token.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.982.1">removeRefreshToken()</span></strong><span class="koboSpan" id="kobo.983.1">: This removes the refresh token from the database. </span><span class="koboSpan" id="kobo.983.2">It is </span><a id="_idIndexMarker532"/><span class="koboSpan" id="kobo.984.1">called when the user wants to </span><span class="No-Break"><span class="koboSpan" id="kobo.985.1">sign out.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.986.1">Let’s implement each of these methods in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">UserServiceImpl</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.988.1"> class.</span></span></p>
<h3><span class="koboSpan" id="kobo.989.1">Implementing findUserByUsername()</span></h3>
<p><span class="koboSpan" id="kobo.990.1">First, you can</span><a id="_idIndexMarker533"/><span class="koboSpan" id="kobo.991.1"> add the implementation for </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">findUserByUsername()</span></strong><span class="koboSpan" id="kobo.993.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.994.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.995.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.997.1">
public UserEntity findUserByUsername(String username) {  if (Strings.isBlank(username)) {
    throw new UsernameNotFoundException("Invalid user.");
  }
  final String uname = username.trim();
  Optional&lt;UserEntity&gt; oUserEntity =
     repository.findByUsername(uname);
  UserEntity userEntity = oUserEntity.orElseThrow
    (() -&gt; new UsernameNotFoundException(String.format(
      "Given user(%s) not found.", uname)));
  return userEntity;
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserServiceImpl.java"><span class="No-Break"><span class="koboSpan" id="kobo.998.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/service/UserServiceImpl.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.999.1">This is a straightforward operation. </span><span class="koboSpan" id="kobo.999.2">You query the database based on a given username. </span><span class="koboSpan" id="kobo.999.3">If the username is found, then it returns the user; otherwise, it throws a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1000.1">UsernameNotFoundException</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1001.1">exception.</span></span></p>
<h3><span class="koboSpan" id="kobo.1002.1">createUser() implementation</span></h3>
<p><span class="koboSpan" id="kobo.1003.1">Next, you </span><a id="_idIndexMarker534"/><span class="koboSpan" id="kobo.1004.1">can add the implementation for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1005.1">createUser()</span></strong><span class="koboSpan" id="kobo.1006.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1007.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.1008.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1009.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1010.1">
@Transactionalpublic Optional&lt;SignedInUser&gt; createUser(User user) {
  Integer count = repository.findByUsernameOrEmail(
    user.getUsername(), user.getEmail());
  if (count &gt; 0) {
    throw new GenericAlreadyExistsException
      ("Use different username and email.");
  }
  UserEntity userEntity = repository.save(toEntity(user));
  return Optional.of(createSignedUserWithRefreshToken(
    userEntity));
}</span></pre>
<p><span class="koboSpan" id="kobo.1011.1">Here, we first check whether an existing user was assigned the same username or email in the sign-up request. </span><span class="koboSpan" id="kobo.1011.2">If there was, an exception is simply raised; otherwise, a new user is created in the database and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1012.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.1013.1"> instance is returned with refresh and access tokens, using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1014.1">createSignedUserWithRefreshToken()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1016.1">First, we can add a private </span><strong class="source-inline"><span class="koboSpan" id="kobo.1017.1">createSignedUserWithRefreshToken()</span></strong><span class="koboSpan" id="kobo.1018.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.1020.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1021.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1022.1">
private SignedInUser createSignedUserWithRefreshToken(   UserEntity userEntity) {
  return </span><strong class="bold"><span class="koboSpan" id="kobo.1023.1">createSignedInUser</span></strong><span class="koboSpan" id="kobo.1024.1">(userEntity)
     .refreshToken(</span><strong class="bold"><span class="koboSpan" id="kobo.1025.1">createRefreshToken</span></strong><span class="koboSpan" id="kobo.1026.1">(userEntity));
}</span></pre>
<p><span class="koboSpan" id="kobo.1027.1">This also uses another private method, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">createSignedInUser()</span></strong><span class="koboSpan" id="kobo.1029.1">, which returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.1031.1">; then, it adds the refresh token by calling the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">createRefreshToken()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1033.1"> method.</span></span></p>
<p><span class="koboSpan" id="kobo.1034.1">Let’s </span><a id="_idIndexMarker535"/><span class="koboSpan" id="kobo.1035.1">define the two </span><strong class="source-inline"><span class="koboSpan" id="kobo.1036.1">createSignedInUser()</span></strong><span class="koboSpan" id="kobo.1037.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">createRefreshToken()</span></strong><span class="koboSpan" id="kobo.1039.1"> private methods in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.1041.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1042.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1043.1">
private SignedInUser </span><strong class="bold"><span class="koboSpan" id="kobo.1044.1">createSignedInUser</span></strong><span class="koboSpan" id="kobo.1045.1">(UserEntity uEntity) {  String token = </span><strong class="bold"><span class="koboSpan" id="kobo.1046.1">tokenManager.create</span></strong><span class="koboSpan" id="kobo.1047.1">(
          org.springframework.security.core.userdetails
             .User.builder()
          .username(userEntity.getUsername())
          .password(userEntity.getPassword())
          .authorities(Objects.nonNull
            (userEntity.getRole()) ?
</span><span class="koboSpan" id="kobo.1047.2">             userEntity.getRole().name() : "")
          .build());
  return new SignedInUser()
      .username(userEntity.getUsername())
      .accessToken(token)
      .userId(userEntity.getId().toString());
}
private String </span><strong class="bold"><span class="koboSpan" id="kobo.1048.1">createRefreshToken</span></strong><span class="koboSpan" id="kobo.1049.1">(UserEntity user) {
  String token = </span><strong class="bold"><span class="koboSpan" id="kobo.1050.1">RandomHolder.randomKey</span></strong><span class="koboSpan" id="kobo.1051.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.1052.1">128</span></strong><span class="koboSpan" id="kobo.1053.1">);
  userTokenRepository.save(new UserTokenEntity().
</span><span class="koboSpan" id="kobo.1053.2">    setRefreshToken(token).setUser(user));
  return token;
}</span></pre>
<p><span class="koboSpan" id="kobo.1054.1">Here, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">tokenManager</span></strong><span class="koboSpan" id="kobo.1056.1"> is used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1057.1">createSignedIn()</span></strong><span class="koboSpan" id="kobo.1058.1"> method to create the JWT. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1059.1">tokenManager</span></strong><span class="koboSpan" id="kobo.1060.1"> is an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">JwtManager</span></strong><span class="koboSpan" id="kobo.1062.1">. </span><span class="koboSpan" id="kobo.1062.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">User.builder()</span></strong><span class="koboSpan" id="kobo.1064.1"> method is used to create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">UserBuilder</span></strong><span class="koboSpan" id="kobo.1066.1"> class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">UserBuilder</span></strong><span class="koboSpan" id="kobo.1068.1">, which is a final builder class, is used to create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">UserDetails</span></strong><span class="koboSpan" id="kobo.1070.1">. </span><span class="koboSpan" id="kobo.1070.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">JwtManager.create()</span></strong><span class="koboSpan" id="kobo.1072.1"> method uses this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1073.1">UserDetails</span></strong><span class="koboSpan" id="kobo.1074.1"> instance to create </span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">a token.</span></span></p>
<p><span class="koboSpan" id="kobo.1076.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">createRefreshToken()</span></strong><span class="koboSpan" id="kobo.1078.1"> method uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">RandomHolder</span></strong><span class="koboSpan" id="kobo.1080.1"> private static class to </span><a id="_idIndexMarker536"/><span class="koboSpan" id="kobo.1081.1">generate a refresh token. </span><span class="koboSpan" id="kobo.1081.2">This token is not a JWT; we can use a longer-lasting valid token, such as one valid for a day, as a refresh token. </span><span class="koboSpan" id="kobo.1081.3">Saving a JWT as a refresh token in the database removes the sole purpose of using the JWT because it expires by the configured time, and it should not be stored in the database, as it automatically becomes invalid. </span><span class="koboSpan" id="kobo.1081.4">Therefore, we should think carefully before using a JWT as a refresh token and then saving it in </span><span class="No-Break"><span class="koboSpan" id="kobo.1082.1">the database.</span></span></p>
<p><span class="koboSpan" id="kobo.1083.1">Let’s add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">RandomHolder</span></strong><span class="koboSpan" id="kobo.1085.1"> private static class to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.1087.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1088.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1089.1">
// https://stackoverflow.com/a/31214709/109354private static class RandomHolder {
  static final Random random = new SecureRandom();
  public static String randomKey(int length) {
    return String.format("%"+length+"s",new BigInteger
      (length * 5 /*base32, 2^5*/,random).toString(32)).
</span><span class="koboSpan" id="kobo.1089.2">      replace('\u0020', '0');
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.1090.1">This class uses a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1091.1">SecureRandom</span></strong><span class="koboSpan" id="kobo.1092.1"> instance to generate a random </span><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">BigInteger</span></strong><span class="koboSpan" id="kobo.1094.1"> instance. </span><span class="koboSpan" id="kobo.1094.2">Then, this random </span><strong class="source-inline"><span class="koboSpan" id="kobo.1095.1">BigInteger</span></strong><span class="koboSpan" id="kobo.1096.1"> value is converted into a string with a radix size of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">32</span></strong><span class="koboSpan" id="kobo.1098.1">. </span><span class="koboSpan" id="kobo.1098.2">Finally, the space is replaced with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1099.1">0</span></strong><span class="koboSpan" id="kobo.1100.1"> if found in a </span><span class="No-Break"><span class="koboSpan" id="kobo.1101.1">converted string.</span></span></p>
<p><span class="koboSpan" id="kobo.1102.1">You can also use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1103.1">org.apache.commons.lang3.RandomStringUtils. </span><span class="koboSpan" id="kobo.1103.2">randomAlphanumeric()</span></strong><span class="koboSpan" id="kobo.1104.1"> method, or use any other secured random key generator, to generate a</span><a id="_idIndexMarker537"/> <span class="No-Break"><span class="koboSpan" id="kobo.1105.1">refresh token.</span></span></p>
<p><span class="koboSpan" id="kobo.1106.1">We also need to modify the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">UserRepository</span></strong><span class="koboSpan" id="kobo.1108.1"> class to add a new method that returns the count of users with a given username </span><span class="No-Break"><span class="koboSpan" id="kobo.1109.1">or email.</span></span></p>
<h3><span class="koboSpan" id="kobo.1110.1">getSignedInUser() implementation</span></h3>
<p><span class="koboSpan" id="kobo.1111.1">The</span><a id="_idIndexMarker538"/><span class="koboSpan" id="kobo.1112.1"> implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">getSignedInUser()</span></strong><span class="koboSpan" id="kobo.1114.1"> method is straightforward. </span><span class="koboSpan" id="kobo.1114.2">Add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.1116.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1117.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1118.1">
@Transactionalpublic SignedInUser getSignedInUser(UserEntity userEntity) {
  userTokenRepository.</span><strong class="bold"><span class="koboSpan" id="kobo.1119.1">deleteByUserId</span></strong><span class="koboSpan" id="kobo.1120.1">(userEntity.getId());
  return </span><strong class="bold"><span class="koboSpan" id="kobo.1121.1">createSignedUserWithRefreshToken</span></strong><span class="koboSpan" id="kobo.1122.1">(userEntity);
}</span></pre>
<p><span class="koboSpan" id="kobo.1123.1">Here, this method first removes the existing token from the database associated with the given user, and then it returns the new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.1125.1"> that was created using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1126.1">createSignedUserWithRefreshToken()</span></strong><span class="koboSpan" id="kobo.1127.1">, defined previously in the </span><em class="italic"><span class="koboSpan" id="kobo.1128.1">createUser() </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1129.1">implementation</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1130.1"> subsection.</span></span></p>
<h3><span class="koboSpan" id="kobo.1131.1">getAccessToken() implementation</span></h3>
<p><span class="koboSpan" id="kobo.1132.1">The</span><a id="_idIndexMarker539"/><span class="koboSpan" id="kobo.1133.1"> implementation of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">getAccessToken()</span></strong><span class="koboSpan" id="kobo.1135.1"> method is, again, straightforward. </span><span class="koboSpan" id="kobo.1135.2">Add it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.1137.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1138.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1139.1">
public Optional&lt;SignedInUser&gt; getAccessToken(   RefreshToken refreshToken) {
  return userTokenRepository
      .findByRefreshToken(refreshToken.getRefreshToken())
      .map(ut -&gt;
            Optional.of(createSignedInUser(ut.getUser())
               .refreshToken(refreshToken.getRefreshToken())))
      .orElseThrow(() -&gt;
          new InvalidRefreshTokenException
            ("Invalid token."));
}</span></pre>
<p><span class="koboSpan" id="kobo.1140.1">First, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1141.1">getAccessToke()</span></strong><span class="koboSpan" id="kobo.1142.1"> method finds the user’s token entity using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1143.1">UserTokenRepository</span></strong><span class="koboSpan" id="kobo.1144.1"> instance. </span><span class="koboSpan" id="kobo.1144.2">Then, it populates the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1145.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.1146.1"> POJO using the retrieved </span><strong class="source-inline"><span class="koboSpan" id="kobo.1147.1">UserToken</span></strong><span class="koboSpan" id="kobo.1148.1"> entity. </span><span class="koboSpan" id="kobo.1148.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1149.1">createSignedInUser()</span></strong><span class="koboSpan" id="kobo.1150.1"> method does not </span><a id="_idIndexMarker540"/><span class="koboSpan" id="kobo.1151.1">populate the refresh token; therefore, we assign the same refresh token back. </span><span class="koboSpan" id="kobo.1151.2">If it does find the user token entry in the database based on the refresh token, it throws </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">an exception.</span></span></p>
<p><span class="koboSpan" id="kobo.1153.1">Also, you can add a validation for time that will remove/invalidate the refresh token, which has not been added here </span><span class="No-Break"><span class="koboSpan" id="kobo.1154.1">for simplicity.</span></span></p>
<p><span class="koboSpan" id="kobo.1155.1">You can also add a time validation logic for the refresh token – for example, storing the refresh token creation time in the database and using the configured valid time for refresh token validation, which is a kind of expiration logic </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">for JWTs.</span></span></p>
<h3><span class="koboSpan" id="kobo.1157.1">removeRefreshToken() implementation</span></h3>
<p><span class="koboSpan" id="kobo.1158.1">You</span><a id="_idIndexMarker541"/><span class="koboSpan" id="kobo.1159.1"> can add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">removeRefreshToken()</span></strong><span class="koboSpan" id="kobo.1161.1"> method to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">UserServiceImpl</span></strong><span class="koboSpan" id="kobo.1163.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1165.1">
public void removeRefreshToken(RefreshToken refreshToken) { userTokenRepository
  .findByRefreshToken(refreshToken.getRefreshToken())
  .ifPresentOrElse(
    userTokenRepository::delete,
    () -&gt; {
     throw new InvalidRefreshTokenException
       ("Invalid token.");
    });
}</span></pre>
<p><span class="koboSpan" id="kobo.1166.1">First, the </span><a id="_idIndexMarker542"/><span class="koboSpan" id="kobo.1167.1">method finds the given refresh token in the database. </span><span class="koboSpan" id="kobo.1167.2">If this is not found, then it throws an exception. </span><span class="koboSpan" id="kobo.1167.3">If the given refresh token is found in the database, then it </span><span class="No-Break"><span class="koboSpan" id="kobo.1168.1">deletes it.</span></span></p>
<p><span class="koboSpan" id="kobo.1169.1">You have implemented all the extra methods added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1170.1">UserService</span></strong><span class="koboSpan" id="kobo.1171.1"> class. </span><span class="koboSpan" id="kobo.1171.2">Now, you will add additional methods in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1172.1">UserRespository</span></strong><span class="koboSpan" id="kobo.1173.1"> too in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1174.1">following section.</span></span></p>
<h3><span class="koboSpan" id="kobo.1175.1">Enhancing the UserRepository class</span></h3>
<p><span class="koboSpan" id="kobo.1176.1">Let’s add</span><a id="_idIndexMarker543"/><span class="koboSpan" id="kobo.1177.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1178.1">findByUsername()</span></strong><span class="koboSpan" id="kobo.1179.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1180.1">findByUsernameOrEmail()</span></strong><span class="koboSpan" id="kobo.1181.1"> methods to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">UserRepository</span></strong><span class="koboSpan" id="kobo.1183.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1184.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1185.1">
public interface UserRepository extends   CrudRepository&lt;UserEntity, UUID&gt; {
 Optional&lt;UserEntity&gt; findByUsername(String username);
 @Query( value = "select count(u.*) from ecomm.\"user\" u
         where u.username = :username or u.email = :email",
         nativeQuery = true)
 Integer </span><strong class="bold"><span class="koboSpan" id="kobo.1186.1">findByUsernameOrEmail</span></strong><span class="koboSpan" id="kobo.1187.1">(String username,
   String email);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserRepository.java"><span class="No-Break"><span class="koboSpan" id="kobo.1188.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/repository/UserRepository.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1189.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1190.1">findByUsernameOrEmail</span></strong><span class="koboSpan" id="kobo.1191.1"> method returns a count of the records matching the given username </span><span class="No-Break"><span class="koboSpan" id="kobo.1192.1">or email.</span></span></p>
<p><span class="koboSpan" id="kobo.1193.1">You are now ready to implement the new APIs added to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1194.1">UserApi</span></strong><span class="koboSpan" id="kobo.1195.1"> interface to write the REST controllers. </span><span class="koboSpan" id="kobo.1195.2">Let’s do </span><span class="No-Break"><span class="koboSpan" id="kobo.1196.1">that next.</span></span></p>
<h2 id="_idParaDest-160"><a id="_idTextAnchor159"/><span class="koboSpan" id="kobo.1197.1">Implementing the REST controllers</span></h2>
<p><span class="koboSpan" id="kobo.1198.1">In the </span><a id="_idIndexMarker544"/><span class="koboSpan" id="kobo.1199.1">previous section, you </span><a id="_idIndexMarker545"/><span class="koboSpan" id="kobo.1200.1">developed and enhanced the services and repositories required to implement the APIs defined in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1201.1">UserApi</span></strong><span class="koboSpan" id="kobo.1202.1"> interface, generated by OpenAPI Codegen. </span><span class="koboSpan" id="kobo.1202.2">The only pending dependency is </span><strong class="source-inline"><span class="koboSpan" id="kobo.1203.1">PasswordEncoder</span></strong><span class="koboSpan" id="kobo.1204.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">PasswordEncoder</span></strong><span class="koboSpan" id="kobo.1206.1"> is required to encode the password before storing and matching the given password in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">sign-in request.</span></span></p>
<h3><span class="koboSpan" id="kobo.1208.1">Adding a bean for PasswordEncoder</span></h3>
<p><span class="koboSpan" id="kobo.1209.1">You </span><a id="_idIndexMarker546"/><span class="koboSpan" id="kobo.1210.1">should expose the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1211.1">PasswordEncoder</span></strong><span class="koboSpan" id="kobo.1212.1"> bean because Spring Security needs to know which encoding you want to use for password encoding, as well as for decoding the passwords. </span><span class="koboSpan" id="kobo.1212.2">Let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1213.1">PasswordEncoder</span></strong><span class="koboSpan" id="kobo.1214.1"> bean to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1215.1">AppConfig</span></strong><span class="koboSpan" id="kobo.1216.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1217.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1218.1">
@Beanpublic PasswordEncoder passwordEncoder() {
  Map&lt;String, PasswordEncoder&gt; encoders =
      Map.of(
          ENCODER_ID, new BCryptPasswordEncoder(),
          "pbkdf2", Pbkdf2PasswordEncoder.
</span><span class="koboSpan" id="kobo.1218.2">            defaultsForSpringSecurity_v5_8(),
          "scrypt", ScryptPasswordEncoder
            .defaultsForSpringSecurity_v5_8());
  return new DelegatingPasswordEncoder
    (ENCODER_ID, encoders);
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/AppConfig.java"><span class="No-Break"><span class="koboSpan" id="kobo.1219.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/AppConfig.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1220.1">Here, you can directly create a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1221.1">BcryptPasswordEncoder</span></strong><span class="koboSpan" id="kobo.1222.1"> and return it for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1223.1">bcrypt</span></strong><span class="koboSpan" id="kobo.1224.1"> encoding. </span><span class="koboSpan" id="kobo.1224.2">However, the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1225.1">DelegatingPasswordEncoder</span></strong><span class="koboSpan" id="kobo.1226.1"> not only allows you to support existing passwords but also facilitates migration to a new, better encoder if one is available in the future. </span><span class="koboSpan" id="kobo.1226.2">This </span><a id="_idIndexMarker547"/><span class="koboSpan" id="kobo.1227.1">code uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1228.1">Bcrypt</span></strong><span class="koboSpan" id="kobo.1229.1"> as a default password encoder, which is the best among the currently </span><span class="No-Break"><span class="koboSpan" id="kobo.1230.1">available encoders.</span></span></p>
<p><span class="koboSpan" id="kobo.1231.1">For </span><strong class="source-inline"><span class="koboSpan" id="kobo.1232.1">DelegatingPasswordEncoder</span></strong><span class="koboSpan" id="kobo.1233.1"> to work, you need to add a hashing algorithm prefix such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1234.1">{bcrypt}</span></strong><span class="koboSpan" id="kobo.1235.1"> to encoded passwords – for example, add </span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">{bcrypt}$2a$10$neR0EcYY5./tLVp4litNyuBy/ kfrTsqEv8hiyqEKX0TXIQQwC/5Rm</span></strong><span class="koboSpan" id="kobo.1237.1"> to the persistent store if you already have a hashed password in the database, or if you’re adding any seed/test users to the database script. </span><span class="koboSpan" id="kobo.1237.2">The new password will store the password with a prefix anyway, as configured in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">DelegatingPasswordEncoder</span></strong><span class="koboSpan" id="kobo.1239.1"> constructor. </span><span class="koboSpan" id="kobo.1239.2">You have passed </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">bcrypt</span></strong><span class="koboSpan" id="kobo.1241.1"> into the constructor; therefore, all new passwords will be stored with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1242.1">{</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1243.1">bcrypt}</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1244.1"> prefix.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">PasswordEncoder</span></strong><span class="koboSpan" id="kobo.1246.1"> reads</span><a id="_idIndexMarker548"/><span class="koboSpan" id="kobo.1247.1"> the password from the persistence store and removes the prefix before matching. </span><span class="koboSpan" id="kobo.1247.2">It uses the same prefix to find out which encoder it needs to use for matching. </span><span class="koboSpan" id="kobo.1247.3">Now, you can start implementing the new APIs based </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1249.1">UserApi</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1250.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.1251.1">Implementing the Controller class</span></h3>
<p><span class="koboSpan" id="kobo.1252.1">First, create a </span><a id="_idIndexMarker549"/><span class="koboSpan" id="kobo.1253.1">new </span><strong class="source-inline"><span class="koboSpan" id="kobo.1254.1">AuthController</span></strong><span class="koboSpan" id="kobo.1255.1"> class, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1256.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1257.1">
@RestControllerpublic class AuthController implements UserApi {
  private final UserService service;
  private final PasswordEncoder passwordEncoder;
  public AuthController(UserService s, PasswordEncoder e) {
    this.service = s;
    this.passwordEncoder = e;
  }
  …
  …
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/controller/AuthController.java"><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/controller/AuthController.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1259.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1260.1">AuthController</span></strong><span class="koboSpan" id="kobo.1261.1"> class is annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1262.1">@RestController</span></strong><span class="koboSpan" id="kobo.1263.1"> to mark it as a REST controller. </span><span class="koboSpan" id="kobo.1263.2">Then, it uses two beans, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">UserService</span></strong><span class="koboSpan" id="kobo.1265.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1266.1">PasswordEncoder</span></strong><span class="koboSpan" id="kobo.1267.1">, which will </span><a id="_idIndexMarker550"/><span class="koboSpan" id="kobo.1268.1">be injected at the time of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">AuthController</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1270.1"> construction.</span></span></p>
<p><span class="koboSpan" id="kobo.1271.1">First, let’s add the sign-in operation, </span><span class="No-Break"><span class="koboSpan" id="kobo.1272.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1273.1">
public ResponseEntity&lt;SignedInUser&gt; </span><strong class="bold"><span class="koboSpan" id="kobo.1274.1">signIn</span></strong><span class="koboSpan" id="kobo.1275.1">(@Valid SignInReq signInReq) {  UserEntity userEntity = service
      .findUserByUsername(signInReq.getUsername());
  if (</span><strong class="bold"><span class="koboSpan" id="kobo.1276.1">passwordEncoder.matches</span></strong><span class="koboSpan" id="kobo.1277.1">(signInReq.getPassword(),
      userEntity.getPassword())) {
    return ok(service.getSignedInUser(userEntity));
  }
  throw new InsufficientAuthenticationException
    ("Unauthrzed");
}</span></pre>
<p><span class="koboSpan" id="kobo.1278.1">The operation first finds the user and matches the password using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">PasswordEncoder</span></strong><span class="koboSpan" id="kobo.1280.1"> instance. </span><span class="koboSpan" id="kobo.1280.2">If everything goes through successfully, it returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1281.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.1282.1"> instance with refresh and access tokens; otherwise, it throws </span><span class="No-Break"><span class="koboSpan" id="kobo.1283.1">an exception.</span></span></p>
<p><span class="koboSpan" id="kobo.1284.1">Let’s add </span><a id="_idIndexMarker551"/><span class="koboSpan" id="kobo.1285.1">other operations to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1286.1">AuthController</span></strong><span class="koboSpan" id="kobo.1287.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1288.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1289.1">
public ResponseEntity&lt;Void&gt; signOut(  @Valid RefreshToken refreshToken) {
  service.removeRefreshToken(refreshToken);
  return accepted().build();
}
public ResponseEntity&lt;SignedInUser&gt; signUp
   (@Valid User user) {
 return status(HttpStatus.CREATED)
    .body(service.createUser(user).get());
}
public ResponseEntity&lt;SignedInUser&gt; getAccessToken(
   @Valid RefreshToken refreshToken) {
  return ok(service.getAccessToken(refreshToken)
     .orElseThrow(InvalidRefreshTokenException::new));
}</span></pre>
<p><span class="koboSpan" id="kobo.1290.1">All operations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1291.1">signOut()</span></strong><span class="koboSpan" id="kobo.1292.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">signUp()</span></strong><span class="koboSpan" id="kobo.1294.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1295.1">getAccessToken()</span></strong><span class="koboSpan" id="kobo.1296.1"> are straightforward, as </span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">outlined here:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1298.1">signOut()</span></strong><span class="koboSpan" id="kobo.1299.1"> uses the user service to remove the given refresh token. </span><span class="koboSpan" id="kobo.1299.2">Ideally, you would like to get the user ID from the logged-in user’s request and remove the refresh token, based on the retrieved user ID from </span><span class="No-Break"><span class="koboSpan" id="kobo.1300.1">the request.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1301.1">signUp()</span></strong><span class="koboSpan" id="kobo.1302.1"> creates a valid new user and returns the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.1304.1"> instance as a response. </span><span class="koboSpan" id="kobo.1304.2">Here, we haven’t added the validation of the payload for simplicity. </span><span class="koboSpan" id="kobo.1304.3">In a </span><a id="_idIndexMarker552"/><span class="koboSpan" id="kobo.1305.1">real-world application, you must validate the </span><span class="No-Break"><span class="koboSpan" id="kobo.1306.1">request payload.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1307.1">getAccessToken()</span></strong><span class="koboSpan" id="kobo.1308.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">SignedInUser</span></strong><span class="koboSpan" id="kobo.1310.1"> with a new access token if the given refresh token </span><span class="No-Break"><span class="koboSpan" id="kobo.1311.1">is valid.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1312.1">We have finished coding the controllers. </span><span class="koboSpan" id="kobo.1312.2">Let’s configure security in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1313.1">next subsection.</span></span></p>
<h2 id="_idParaDest-161"><a id="_idTextAnchor160"/><span class="koboSpan" id="kobo.1314.1">Configuring web-based security</span></h2>
<p><span class="koboSpan" id="kobo.1315.1">This is </span><a id="_idIndexMarker553"/><span class="koboSpan" id="kobo.1316.1">the last puzzle </span><a id="_idIndexMarker554"/><span class="koboSpan" id="kobo.1317.1">to sort out the authentication and authorization piece. </span><span class="koboSpan" id="kobo.1317.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1318.1">SecurityConfig</span></strong><span class="koboSpan" id="kobo.1319.1"> class is also annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1320.1">@EnableWebSecurity</span></strong><span class="koboSpan" id="kobo.1321.1">. </span><span class="koboSpan" id="kobo.1321.2">With the new version of Spring Security, you now don’t need to extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.1322.1">WebSecurityConfigurerAdapter</span></strong><span class="koboSpan" id="kobo.1323.1"> and override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1324.1">configure()</span></strong><span class="koboSpan" id="kobo.1325.1"> method, as we did in the last edition of this book. </span><span class="koboSpan" id="kobo.1325.2">Instead, you now create a bean that returns the configured instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1326.1">SecurityFilterChain</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1327.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.1328.1">The method (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1329.1">filterChain</span></strong><span class="koboSpan" id="kobo.1330.1">) that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1331.1">SecurityFilterChain</span></strong><span class="koboSpan" id="kobo.1332.1"> takes </span><strong class="source-inline"><span class="koboSpan" id="kobo.1333.1">HttpSecurity</span></strong><span class="koboSpan" id="kobo.1334.1"> as a parameter. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1335.1">HttpSecurity</span></strong><span class="koboSpan" id="kobo.1336.1"> contains DSL (fluent methods). </span><span class="koboSpan" id="kobo.1336.2">You can make use of these methods to configure web-based security, such as which web paths to allow and which method to allow. </span><span class="koboSpan" id="kobo.1336.3">Let’s make the following configurations using these fluent methods to return the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1337.1">SecurityFilterChain</span></strong><span class="koboSpan" id="kobo.1338.1"> instance, as shown in the following code snippet </span><span class="No-Break"><span class="koboSpan" id="kobo.1339.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1340.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1341.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1342.1">
@Beanprotected SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
  http.httpBasic().disable()
      .formLogin().disable()
      .</span><strong class="bold"><span class="koboSpan" id="kobo.1343.1">csrf().</span></strong><span class="koboSpan" id="kobo.1344.1">ignoringRequestMatchers(API_URL_PREFIX)
          .ignoringRequestMatchers(</span><strong class="bold"><span class="koboSpan" id="kobo.1345.1">toH2Console()</span></strong><span class="koboSpan" id="kobo.1346.1">)
      .and()
      .</span><strong class="bold"><span class="koboSpan" id="kobo.1347.1">headers().frameOptions().sameOrigin()</span></strong><span class="koboSpan" id="kobo.1348.1">
      .and()
      .</span><strong class="bold"><span class="koboSpan" id="kobo.1349.1">cors()</span></strong><span class="koboSpan" id="kobo.1350.1">
      .and()
      .authorizeHttpRequests(req -&gt;
         req.requestMatchers(toH2Console()).permitAll()
          .requestMatchers(new AntPathRequestMatcher(
             TOKEN_URL, HttpMethod.POST.name()))
               .permitAll()
          .requestMatchers(new AntPathRequestMatcher(
             TOKEN_URL, HttpMethod.DELETE.name())).
</span><span class="koboSpan" id="kobo.1350.2">               permitAll()
          .requestMatchers(new AntPathRequestMatcher(
             SIGNUP_URL, HttpMethod.POST.name()))
               .permitAll()
          .requestMatchers(new AntPathRequestMatcher(
             REFRESH_URL, HttpMethod.POST.name())).
</span><span class="koboSpan" id="kobo.1350.3">               permitAll()
          .requestMatchers(new AntPathRequestMatcher(
             PRODUCTS_URL, HttpMethod.GET.name())).
</span><span class="koboSpan" id="kobo.1350.4">               permitAll()
          .requestMatchers("/api/v1/addresses/**")
             .hasAuthority(RoleEnum.ADMIN.getAuthority())
          .anyRequest().authenticated())
      .oauth2ResourceServer(oauth2ResourceServer -&gt;
          oauth2ResourceServer.jwt(jwt -&gt;
            jwt.jwtAuthenticationConverter(
              getJwtAuthenticationConverter())))
      .sessionManagement().sessionCreationPolicy(
          SessionCreationPolicy.STATELESS);
  return http.build();
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java"><span class="No-Break"><span class="koboSpan" id="kobo.1351.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1352.1">Here, you</span><a id="_idIndexMarker555"/><span class="koboSpan" id="kobo.1353.1"> configure the following </span><a id="_idIndexMarker556"/><span class="No-Break"><span class="koboSpan" id="kobo.1354.1">security settings:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.1355.1">First of all, you disable the basic authentication and form login using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1356.1">disable()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1"> method.</span></span></li>
<li><span class="koboSpan" id="kobo.1358.1">Then, you ignore the CSRF configuration for the API base path and H2 </span><span class="No-Break"><span class="koboSpan" id="kobo.1359.1">console URLs.</span></span></li>
<li><span class="koboSpan" id="kobo.1360.1">Then, you set the headers setting for frame options that have the same origin to allow the H2 console application to work fine in the browser. </span><span class="koboSpan" id="kobo.1360.2">The H2 console UI is based on HTML frames. </span><span class="koboSpan" id="kobo.1360.3">The H2 console UI won’t display in browsers because, by default, the security header (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1361.1">X-Frame-Options</span></strong><span class="koboSpan" id="kobo.1362.1">) is not sent with permission to allow frames with the same origin. </span><span class="koboSpan" id="kobo.1362.2">Therefore, you need to </span><span class="No-Break"><span class="koboSpan" id="kobo.1363.1">configure </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1364.1">headers().frameOptions().sameOrigin()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1365.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1366.1">Then, you enable the CORS setting. </span><span class="koboSpan" id="kobo.1366.2">You’ll learn more about this in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1367.1">next section.</span></span></li>
<li><span class="koboSpan" id="kobo.1368.1">Then, you configure the authorization of the request, which takes the request object as a parameter. </span><span class="koboSpan" id="kobo.1368.2">You use this request object to restrict access, based on URL patterns, by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1369.1">requestMatchers()</span></strong><span class="koboSpan" id="kobo.1370.1"> method and an instance of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1371.1">AntPathRequestMatcher</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1372.1"> class:</span></span><ul><li><span class="koboSpan" id="kobo.1373.1">Configure URL patterns and respective HTTP methods </span><a id="_idIndexMarker557"/><span class="koboSpan" id="kobo.1374.1">using </span><strong class="bold"><span class="koboSpan" id="kobo.1375.1">Ant matchers</span></strong><span class="koboSpan" id="kobo.1376.1">, which allows you to use Ant (build tool) pattern-matching styles. </span><span class="koboSpan" id="kobo.1376.2">You can also use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1377.1">mvcMatchers()</span></strong><span class="koboSpan" id="kobo.1378.1">, which uses the same pattern-matching style as a </span><a id="_idIndexMarker558"/><span class="koboSpan" id="kobo.1379.1">Spring </span><strong class="bold"><span class="koboSpan" id="kobo.1380.1">Model-View-Controller</span></strong><span class="koboSpan" id="kobo.1381.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1382.1">MVC</span></strong><span class="koboSpan" id="kobo.1383.1">) and works well with MVC-based </span><span class="No-Break"><span class="koboSpan" id="kobo.1384.1">Spring applications.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1385.1">Static method toH2Console()</span></strong><span class="koboSpan" id="kobo.1386.1"> is a utility that provides a matcher that includes the H2 </span><span class="No-Break"><span class="koboSpan" id="kobo.1387.1">console location.</span></span></li><li><span class="koboSpan" id="kobo.1388.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1389.1">/api/v1/addresses/** </span></strong><span class="koboSpan" id="kobo.1390.1"> pattern has been configured to be accessed only by the user who has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1391.1">ADMIN</span></strong><span class="koboSpan" id="kobo.1392.1"> role, by calling </span><strong class="source-inline"><span class="koboSpan" id="kobo.1393.1">hasAuthority()</span></strong><span class="koboSpan" id="kobo.1394.1"> and passing the admin authority in it. </span><span class="koboSpan" id="kobo.1394.2">You’ll learn more about it in the </span><em class="italic"><span class="koboSpan" id="kobo.1395.1">Understanding authorization</span></em><span class="koboSpan" id="kobo.1396.1"> section of </span><span class="No-Break"><span class="koboSpan" id="kobo.1397.1">this chapter.</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.1398.1">All URLs, except</span><a id="_idIndexMarker559"/><span class="koboSpan" id="kobo.1399.1"> those configured explicitly by </span><strong class="source-inline"><span class="koboSpan" id="kobo.1400.1">authorizeHttpRequests()</span></strong><span class="koboSpan" id="kobo.1401.1">, should be allowed by any authenticated user (by using </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1402.1">anyRequest(). </span><span class="koboSpan" id="kobo.1402.2">authenticated()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">).</span></span><ul><li><span class="koboSpan" id="kobo.1404.1">Enable JWT bearer token support for the OAuth 2.0 resource </span><span class="No-Break"><span class="koboSpan" id="kobo.1405.1">server (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1406.1">oauth2ResourceServer.jwt()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1407.1">).</span></span></li><li><span class="koboSpan" id="kobo.1408.1">Enable the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1409.1">STATELESS</span></strong><span class="koboSpan" id="kobo.1410.1"> session creation policy (that is, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1411.1">sessionManagement().sessionCreationPolicy</span></strong><span class="koboSpan" id="kobo.1412.1"> won’t create </span><span class="No-Break"><span class="koboSpan" id="kobo.1413.1">any </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1414.1">HTTPSession</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1415.1">)</span></span></li></ul></li>
<li><span class="koboSpan" id="kobo.1416.1">Finally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1417.1">filterChain</span></strong><span class="koboSpan" id="kobo.1418.1"> method returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1419.1">SecurityFilterChain</span></strong><span class="koboSpan" id="kobo.1420.1"> by building the instance</span><a id="_idIndexMarker560"/><span class="koboSpan" id="kobo.1421.1"> from the configured </span><strong class="source-inline"><span class="koboSpan" id="kobo.1422.1">HttpSecurity</span></strong><span class="koboSpan" id="kobo.1423.1"> instance (the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1424.1">http.build()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1425.1"> call).</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.1426.1">In this section, you learned how to configure Spring security for authentication and authorization. </span><span class="koboSpan" id="kobo.1426.2">Next, we will learn about the CORS </span><span class="No-Break"><span class="koboSpan" id="kobo.1427.1">and CSRF.</span></span></p>
<h1 id="_idParaDest-162"><a id="_idTextAnchor161"/><span class="koboSpan" id="kobo.1428.1">Configuring CORS and CSRF</span></h1>
<p><span class="koboSpan" id="kobo.1429.1">Browsers</span><a id="_idIndexMarker561"/><span class="koboSpan" id="kobo.1430.1"> restrict cross-origin requests from scripts for security reasons. </span><span class="koboSpan" id="kobo.1430.2">For example, a call from </span><strong class="source-inline"><span class="koboSpan" id="kobo.1431.1">http://mydomain.com</span></strong><span class="koboSpan" id="kobo.1432.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1433.1">http://mydomain-2.com</span></strong><span class="koboSpan" id="kobo.1434.1"> can’t be made using a script. </span><span class="koboSpan" id="kobo.1434.2">Also, an origin not only indicates a domain but also includes a scheme and </span><span class="No-Break"><span class="koboSpan" id="kobo.1435.1">a port.</span></span></p>
<p><span class="koboSpan" id="kobo.1436.1">Before hitting </span><a id="_idIndexMarker562"/><span class="koboSpan" id="kobo.1437.1">any endpoint, the browser sends a pre-flight request using the HTTP method option to check whether the server will permit the actual request. </span><span class="koboSpan" id="kobo.1437.2">This request contains the </span><span class="No-Break"><span class="koboSpan" id="kobo.1438.1">following headers:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1439.1">The actual request’s </span><span class="No-Break"><span class="koboSpan" id="kobo.1440.1">headers (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1441.1">Access-Control-Request-Headers</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1442.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1443.1">A header containing the actual request’s HTTP method (</span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1444.1">Access-Control- Request-Method</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1445.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1446.1">An </span><strong class="source-inline"><span class="koboSpan" id="kobo.1447.1">Origin</span></strong><span class="koboSpan" id="kobo.1448.1"> header that contains the requesting origin (scheme, domain, </span><span class="No-Break"><span class="koboSpan" id="kobo.1449.1">and port).</span></span></li>
<li><span class="koboSpan" id="kobo.1450.1">If the response from the server is successful, then only the browser allows the actual request to fire. </span><span class="koboSpan" id="kobo.1450.2">The server responds with other headers, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1451.1">Access- Control-Allow-Origin</span></strong><span class="koboSpan" id="kobo.1452.1">, which contains the allowed origins (an asterisk </span><strong class="source-inline"><span class="koboSpan" id="kobo.1453.1">*</span></strong><span class="koboSpan" id="kobo.1454.1"> value means any origin), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1455.1">Access-Control-Allow-Methods</span></strong><span class="koboSpan" id="kobo.1456.1"> (allowed methods), </span><strong class="source-inline"><span class="koboSpan" id="kobo.1457.1">Access-Control-Allow-Headers</span></strong><span class="koboSpan" id="kobo.1458.1"> (allowed headers), and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1459.1">Access-Control-Max-Age</span></strong><span class="koboSpan" id="kobo.1460.1"> (allowed time </span><span class="No-Break"><span class="koboSpan" id="kobo.1461.1">in seconds).</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1462.1">You can configure CORS to take care of cross-origin requests. </span><span class="koboSpan" id="kobo.1462.2">For that, you need to make the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1463.1">two changes:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1464.1">Add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1465.1">CorsConfigurationSource</span></strong><span class="koboSpan" id="kobo.1466.1"> bean that takes care of the CORS configuration using a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1467.1">CorsConfiguration</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1468.1"> instance.</span></span></li>
<li><span class="koboSpan" id="kobo.1469.1">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1470.1">cors()</span></strong><span class="koboSpan" id="kobo.1471.1"> method to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1472.1">HTTPSecurity</span></strong><span class="koboSpan" id="kobo.1473.1"> in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1474.1">configure()</span></strong><span class="koboSpan" id="kobo.1475.1"> method. </span><span class="koboSpan" id="kobo.1475.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1476.1">cors()</span></strong><span class="koboSpan" id="kobo.1477.1"> method uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1478.1">CorsFilter</span></strong><span class="koboSpan" id="kobo.1479.1"> if a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1480.1">corsFilter</span></strong><span class="koboSpan" id="kobo.1481.1"> bean is added; otherwise, it uses </span><strong class="source-inline"><span class="koboSpan" id="kobo.1482.1">CorsConfigurationSource</span></strong><span class="koboSpan" id="kobo.1483.1">. </span><span class="koboSpan" id="kobo.1483.2">If neither is configured, then it uses the Spring MVC pattern </span><span class="No-Break"><span class="koboSpan" id="kobo.1484.1">inspector handler.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1485.1">Let’s now add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1486.1">CorsConfigurationSource</span></strong><span class="koboSpan" id="kobo.1487.1"> bean to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1488.1">SecurityConfig</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1489.1"> class.</span></span></p>
<p><span class="koboSpan" id="kobo.1490.1">The default permitted values (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1491.1">new CorsConfiguraton(). </span><span class="koboSpan" id="kobo.1491.2">applyPermitDefaultValues()</span></strong><span class="koboSpan" id="kobo.1492.1">) configure CORS for any origin (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1493.1">*</span></strong><span class="koboSpan" id="kobo.1494.1">), all headers, and simple methods (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1495.1">GET</span></strong><span class="koboSpan" id="kobo.1496.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1497.1">HEAD</span></strong><span class="koboSpan" id="kobo.1498.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1499.1">POST</span></strong><span class="koboSpan" id="kobo.1500.1">), which have an allowed max age of </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1501.1">30</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1502.1"> minutes.</span></span></p>
<p><span class="koboSpan" id="kobo.1503.1">You </span><a id="_idIndexMarker563"/><span class="koboSpan" id="kobo.1504.1">need </span><a id="_idIndexMarker564"/><span class="koboSpan" id="kobo.1505.1">to allow mostly all of the HTTP methods, including the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1506.1">DELETE</span></strong><span class="koboSpan" id="kobo.1507.1"> method, and you need more custom configuration; therefore, we will use the following bean definition </span><span class="No-Break"><span class="koboSpan" id="kobo.1508.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1509.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1510.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1511.1">
@BeanCorsConfigurationSource corsConfigurationSource() {
  CorsConfiguration configuration = new CorsConfiguration();
  configuration.setAllowedOrigins(List.of("*"));
  configuration.setAllowedMethods(Arrays.asList("HEAD",
     "GET", "PUT", "POST", "DELETE", "PATCH"));
  // For CORS response headers
  configuration.addAllowedOrigin("*");
  configuration.addAllowedHeader("*");
  configuration.addAllowedMethod("*");
  UrlBasedCorsConfigurationSource source = new
     UrlBasedCorsConfigurationSource();
  source.registerCorsConfiguration("/**", configuration);
  return source;
}</span></pre>
<p><span class="koboSpan" id="kobo.1512.1">Here, you create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1513.1">CorsConfiguration</span></strong><span class="koboSpan" id="kobo.1514.1"> instance using the default constructor and then set the allowed origins, allowed methods, and response headers. </span><span class="koboSpan" id="kobo.1514.2">Finally, you pass it as an argument while registering it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1515.1">UrlBasedCorsConfigurationSource</span></strong><span class="koboSpan" id="kobo.1516.1"> instance and </span><span class="No-Break"><span class="koboSpan" id="kobo.1517.1">returning it.</span></span></p>
<p><span class="koboSpan" id="kobo.1518.1">In the previous section, inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1519.1">SecurityChainFilter</span></strong><span class="koboSpan" id="kobo.1520.1"> method annotated with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1521.1">@Bean</span></strong><span class="koboSpan" id="kobo.1522.1">, you have configured CSRF using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1523.1">csrf()</span></strong><span class="koboSpan" id="kobo.1524.1"> DSL. </span><span class="koboSpan" id="kobo.1524.2">We have applied CSRF protection to all URLs, except URLs starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1525.1">/api/v1</span></strong><span class="koboSpan" id="kobo.1526.1"> and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1527.1">/h2-console</span></strong><span class="koboSpan" id="kobo.1528.1"> H2 database console URLs. </span><span class="koboSpan" id="kobo.1528.2">You can change the configuration based on </span><span class="No-Break"><span class="koboSpan" id="kobo.1529.1">your requirement.</span></span></p>
<p><span class="koboSpan" id="kobo.1530.1">Let’s first </span><a id="_idIndexMarker565"/><span class="koboSpan" id="kobo.1531.1">understand </span><a id="_idIndexMarker566"/><span class="koboSpan" id="kobo.1532.1">what CSRF/XSRF is. </span><strong class="bold"><span class="koboSpan" id="kobo.1533.1">CSRF</span></strong><span class="koboSpan" id="kobo.1534.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.1535.1">XSRF</span></strong><span class="koboSpan" id="kobo.1536.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.1537.1">cross-site request forgery</span></strong><span class="koboSpan" id="kobo.1538.1">, which is a web security vulnerability. </span><span class="koboSpan" id="kobo.1538.2">To understand how this vulnerability comes into effect, let’s assume you are a bank customer and are currently signed in to your account online. </span><span class="koboSpan" id="kobo.1538.3">While you are logged in, you may receive an email and click on a link in it, or on any other malicious website’s link, that contains a malicious script. </span><span class="koboSpan" id="kobo.1538.4">This script can then send a request to your bank for a fund transfer. </span><span class="koboSpan" id="kobo.1538.5">The bank then transfers the funds to a perpetrator’s account because the bank thinks that the request has been sent by you, as you are signed in. </span><span class="koboSpan" id="kobo.1538.6">Hackers can use this vulnerability similarly for different </span><span class="No-Break"><span class="koboSpan" id="kobo.1539.1">hacking activities.</span></span></p>
<p><span class="koboSpan" id="kobo.1540.1">To prevent such attacks, the application sends new unique CSRF tokens associated with the signed-in user for each new request. </span><span class="koboSpan" id="kobo.1540.2">These tokens are stored in hidden form fields. </span><span class="koboSpan" id="kobo.1540.3">When a user submits a form, the same token should be sent back with the request. </span><span class="koboSpan" id="kobo.1540.4">The application then verifies the CSRF token and only processes the request if the verification is successful. </span><span class="koboSpan" id="kobo.1540.5">This works because malicious scripts can’t read the token due to the same </span><span class="No-Break"><span class="koboSpan" id="kobo.1541.1">origin policy.</span></span></p>
<p><span class="koboSpan" id="kobo.1542.1">However, if a perpetrator also tricks you into revealing the CSRF token, then it is very difficult to prevent such attacks. </span><span class="koboSpan" id="kobo.1542.2">You can disable CSRF protection for this web service by using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1543.1">csrf().disable()</span></strong><span class="koboSpan" id="kobo.1544.1"> because we only expose </span><span class="No-Break"><span class="koboSpan" id="kobo.1545.1">REST endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.1546.1">Now, let’s move on to the final section, where you will configure the authorization based on the </span><span class="No-Break"><span class="koboSpan" id="kobo.1547.1">user’s role.</span></span></p>
<h1 id="_idParaDest-163"><a id="_idTextAnchor162"/><span class="koboSpan" id="kobo.1548.1">Understanding authorization</span></h1>
<p><span class="koboSpan" id="kobo.1549.1">Your valid</span><a id="_idIndexMarker567"/><span class="koboSpan" id="kobo.1550.1"> username/password or access token for authentication gives you access to secure resources, such as URLs, web resources, or secure web pages. </span><span class="koboSpan" id="kobo.1550.2">Authorization is one step ahead; it allows you to configure access security further with scopes such as read, write, or roles such as Admin, User, and Manager. </span><span class="koboSpan" id="kobo.1550.3">Spring Security allows you to configure any </span><span class="No-Break"><span class="koboSpan" id="kobo.1551.1">custom authority.</span></span></p>
<p><span class="koboSpan" id="kobo.1552.1">We will configure three types of roles for our sample e-commerce app – namely, Customer (user), Admin, and Customer Support Representative (CSR). </span><span class="koboSpan" id="kobo.1552.2">Obviously, each user will have their own specific authority. </span><span class="koboSpan" id="kobo.1552.3">For example, a user can place an order and buy stuff online </span><a id="_idIndexMarker568"/><span class="koboSpan" id="kobo.1553.1">but should not be able to access the CSR or admin resources. </span><span class="koboSpan" id="kobo.1553.2">Similarly, a CSR should not be able to have access to admin-only resources. </span><span class="koboSpan" id="kobo.1553.3">A security configuration that allows authority or role-based access to resources is known as authorization. </span><span class="koboSpan" id="kobo.1553.4">A failed authentication should return an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.1554.1">401</span></strong><span class="koboSpan" id="kobo.1555.1"> status (unauthorized), and a failed authorization should return an HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.1556.1">403</span></strong><span class="koboSpan" id="kobo.1557.1"> status (forbidden), which means the user is authenticated but does not have the required authority/role to access </span><span class="No-Break"><span class="koboSpan" id="kobo.1558.1">the resource.</span></span></p>
<p><span class="koboSpan" id="kobo.1559.1">Let’s introduce these three roles in a sample e-commerce app, as shown in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.1560.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1561.1">
public enum RoleEnum implements </span><strong class="bold"><span class="koboSpan" id="kobo.1562.1">GrantedAuthority</span></strong><span class="koboSpan" id="kobo.1563.1"> {  </span><strong class="bold"><span class="koboSpan" id="kobo.1564.1">USER</span></strong><span class="koboSpan" id="kobo.1565.1">(Const.USER), </span><strong class="bold"><span class="koboSpan" id="kobo.1566.1">ADMIN</span></strong><span class="koboSpan" id="kobo.1567.1">(Const.ADMIN), </span><strong class="bold"><span class="koboSpan" id="kobo.1568.1">CSR</span></strong><span class="koboSpan" id="kobo.1569.1">(Const.CSR);
  private String </span><strong class="bold"><span class="koboSpan" id="kobo.1570.1">authority</span></strong><span class="koboSpan" id="kobo.1571.1">;
  RoleEnum(String authority) {
    this.authority = authority;
  }
  @JsonCreator
  public static RoleEnum fromAuthority(String authority) {
    for (RoleEnum b : RoleEnum.values()) {
      if (b.authority.equals(authority)) {
        return b;
      }
    }
  }
  @Override
  public String toString() {
    return String.valueOf(authority);
  }
  @Override
  @JsonValue
  public String getAuthority() {
    return authority;
  }
  public </span><strong class="bold"><span class="koboSpan" id="kobo.1572.1">class Const</span></strong><span class="koboSpan" id="kobo.1573.1"> {
    public static final String ADMIN = "ROLE_ADMIN";
    public static final String USER = "ROLE_USER";
    public static final String CSR = "ROLE_CSR";
  }
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/RoleEnum.java"><span class="No-Break"><span class="koboSpan" id="kobo.1574.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/entity/RoleEnum.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1575.1">Here, we</span><a id="_idIndexMarker569"/><span class="koboSpan" id="kobo.1576.1"> declared an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1577.1">enum</span></strong><span class="koboSpan" id="kobo.1578.1"> that implements Spring Security’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.1579.1">GrantedAuthority</span></strong><span class="koboSpan" id="kobo.1580.1"> interface to override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1581.1">getAuthority()</span></strong><span class="koboSpan" id="kobo.1582.1"> method. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1583.1">GrantedAuthority</span></strong><span class="koboSpan" id="kobo.1584.1"> is an authority granted to an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1585.1">Authentication</span></strong><span class="koboSpan" id="kobo.1586.1"> (interface) object. </span><span class="koboSpan" id="kobo.1586.2">As you know, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1587.1">BearerTokenAuthenticationToken</span></strong><span class="koboSpan" id="kobo.1588.1"> is a type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1589.1">AbstractAuthenticationToken</span></strong><span class="koboSpan" id="kobo.1590.1"> class that implements the authentication interface, which represents the token/principal for an authenticated request. </span><span class="koboSpan" id="kobo.1590.2">We have used the string constants for the user’s roles in this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1591.1">enum</span></strong><span class="koboSpan" id="kobo.1592.1">, as we need these when we configure the role-based restriction at a </span><span class="No-Break"><span class="koboSpan" id="kobo.1593.1">method level.</span></span></p>
<p><span class="koboSpan" id="kobo.1594.1">Let’s discuss the </span><a id="_idIndexMarker570"/><span class="koboSpan" id="kobo.1595.1">role and authority </span><span class="No-Break"><span class="koboSpan" id="kobo.1596.1">in detail.</span></span></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor163"/><span class="koboSpan" id="kobo.1597.1">Role and authority</span></h2>
<p><span class="koboSpan" id="kobo.1598.1">An authority </span><a id="_idIndexMarker571"/><span class="koboSpan" id="kobo.1599.1">can be assigned for fine-grained control, whereas roles should be applied to large sets of permissions. </span><span class="koboSpan" id="kobo.1599.2">A role is an authority that has the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1600.1">ROLE_</span></strong><span class="koboSpan" id="kobo.1601.1"> prefix. </span><span class="koboSpan" id="kobo.1601.2">This prefix is configurable in </span><span class="No-Break"><span class="koboSpan" id="kobo.1602.1">Spring Security.</span></span></p>
<p><span class="koboSpan" id="kobo.1603.1">Spring Security provides the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1604.1">hasRole()</span></strong><span class="koboSpan" id="kobo.1605.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1606.1">hasAuthority()</span></strong><span class="koboSpan" id="kobo.1607.1"> methods to apply role- and authority-based restrictions. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1608.1">hasRole()</span></strong><span class="koboSpan" id="kobo.1609.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1610.1">hasAuthority()</span></strong><span class="koboSpan" id="kobo.1611.1"> are almost identical, but the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1612.1">hasRole()</span></strong><span class="koboSpan" id="kobo.1613.1"> method maps with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1614.1">Authority</span></strong><span class="koboSpan" id="kobo.1615.1"> without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1616.1">ROLE_</span></strong><span class="koboSpan" id="kobo.1617.1"> prefix. </span><span class="koboSpan" id="kobo.1617.2">If you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1618.1">hasRole</span></strong><span class="koboSpan" id="kobo.1619.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1620.1">'ADMIN'</span></strong><span class="koboSpan" id="kobo.1621.1">), your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1622.1">Admin</span></strong><span class="koboSpan" id="kobo.1623.1"> enum must be </span><strong class="source-inline"><span class="koboSpan" id="kobo.1624.1">ROLE_ADMIN</span></strong><span class="koboSpan" id="kobo.1625.1"> instead of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1626.1">ADMIN</span></strong><span class="koboSpan" id="kobo.1627.1"> because a role is an authority and should have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1628.1">ROLE_</span></strong><span class="koboSpan" id="kobo.1629.1"> prefix, whereas if you use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1630.1">hasAuthority</span></strong><span class="koboSpan" id="kobo.1631.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1632.1">'ADMIN'</span></strong><span class="koboSpan" id="kobo.1633.1">), your </span><strong class="source-inline"><span class="koboSpan" id="kobo.1634.1">Admin</span></strong><span class="koboSpan" id="kobo.1635.1"> enum must be </span><span class="No-Break"><span class="koboSpan" id="kobo.1636.1">only </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1637.1">ADMIN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1638.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1639.1">The OAuth 2.0 resource server, by default, populates authorities based on the scope (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1640.1">scp</span></strong><span class="koboSpan" id="kobo.1641.1">) claim. </span><span class="koboSpan" id="kobo.1641.2">If you provide access to a user’s resources, such as order history for integration with another application, then you can limit an application’s access to a user’s account before granting access to other applications for third-party integration. </span><span class="koboSpan" id="kobo.1641.3">Third-party applications can request one or more scopes; this information is then presented to the user on the consent screen, and the access token issued to the application will be limited to the scopes granted. </span><span class="koboSpan" id="kobo.1641.4">However, in this chapter, we haven't provided OAuth 2.0 authorization flows and will limit security access to </span><span class="No-Break"><span class="koboSpan" id="kobo.1642.1">REST endpoints.</span></span></p>
<p><span class="koboSpan" id="kobo.1643.1">If the JWT contains a claim with the name </span><em class="italic"><span class="koboSpan" id="kobo.1644.1">scope</span></em><span class="koboSpan" id="kobo.1645.1"> (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1646.1">scp</span></strong><span class="koboSpan" id="kobo.1647.1">), then Spring Security will use the value in that claim to construct the authorities by prefixing each value with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1648.1">SCOPE_</span></strong><span class="koboSpan" id="kobo.1649.1">. </span><span class="koboSpan" id="kobo.1649.2">For example, if a payload contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1650.1">scp=["READ","WRITE"]</span></strong><span class="koboSpan" id="kobo.1651.1"> claim, this means that an </span><strong class="source-inline"><span class="koboSpan" id="kobo.1652.1">Authority</span></strong><span class="koboSpan" id="kobo.1653.1"> list will consist of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1654.1">SCOPE_READ</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1655.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1656.1">SCOPE_WRITE</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1657.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1658.1">We need to change the default authority mapping behavior because a scope (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1659.1">scp</span></strong><span class="koboSpan" id="kobo.1660.1">) claim is the default authority for the OAuth2.0 resource server in Spring. </span><span class="koboSpan" id="kobo.1660.2">We can do that by adding a custom authentication converter to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1661.1">JwtConfigurer</span></strong><span class="koboSpan" id="kobo.1662.1"> in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1663.1">OAuth2ResourceServer</span></strong><span class="koboSpan" id="kobo.1664.1"> in your security configuration. </span><span class="koboSpan" id="kobo.1664.2">Let’s add a method that returns the converter, </span><span class="No-Break"><span class="koboSpan" id="kobo.1665.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1666.1">
private Converter&lt;Jwt, AbstractAuthenticationToken&gt;   getJwtAuthenticationConverter() {
  JwtGrantedAuthoritiesConverter </span><strong class="bold"><span class="koboSpan" id="kobo.1667.1">authorityConverter</span></strong><span class="koboSpan" id="kobo.1668.1"> =
    new JwtGrantedAuthoritiesConverter();
  authorityConverter.setAuthorityPrefix(AUTHORITY_PREFIX);
  authorityConverter.setAuthoritiesClaimName(ROLE_CLAIM);
  </span><strong class="bold"><span class="koboSpan" id="kobo.1669.1">JwtAuthenticationConverter</span></strong><span class="koboSpan" id="kobo.1670.1"> converter =
    new JwtAuthenticationConverter();
  converter.setJwtGrantedAuthoritiesConverter(authorityConverter);
  return converter;
}</span></pre>
<p><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java"><span class="No-Break"><span class="koboSpan" id="kobo.1671.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/src/main/java/com/packt/modern/api/security/SecurityConfig.java</span></span></a></p>
<p><span class="koboSpan" id="kobo.1672.1">Here, we </span><a id="_idIndexMarker572"/><span class="koboSpan" id="kobo.1673.1">first create a new instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1674.1">JwtGrantedAuthorityConverter</span></strong><span class="koboSpan" id="kobo.1675.1"> and then assign an authority prefix (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1676.1">ROLE_</span></strong><span class="koboSpan" id="kobo.1677.1">) and authority claim name (the key of the claim in JWT) </span><span class="No-Break"><span class="koboSpan" id="kobo.1678.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1679.1">roles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1680.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1681.1">Now, we can use this private method to configure the OAuth 2.0 resource server. </span><span class="koboSpan" id="kobo.1681.2">You can now modify the existing configuration with the following code. </span><span class="koboSpan" id="kobo.1681.3">We can also add configuration to add role-based restrictions to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1682.1">POST</span></strong> <strong class="source-inline"><span class="koboSpan" id="kobo.1683.1">/api/v1/addresses</span></strong><span class="koboSpan" id="kobo.1684.1"> API call, in the following code snippet </span><span class="No-Break"><span class="koboSpan" id="kobo.1685.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1686.1">SecurityConfig.java</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1687.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1688.1">
.requestMatchers("/</span><strong class="bold"><span class="koboSpan" id="kobo.1689.1">api/v1/addresses/**</span></strong><span class="koboSpan" id="kobo.1690.1">")     .</span><strong class="bold"><span class="koboSpan" id="kobo.1691.1">hasAuthority</span></strong><span class="koboSpan" id="kobo.1692.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.1693.1">RoleEnum.ADMIN.getAuthority(</span></strong><span class="koboSpan" id="kobo.1694.1">))
.anyRequest().authenticated())
.oauth2ResourceServer(oauth2ResourceServer -&gt;
  oauth2ResourceServer.jwt(jwt -&gt;
     jwt.jwtAuthenticationConverter(
      </span><strong class="bold"><span class="koboSpan" id="kobo.1695.1">getJwtAuthenticationConverter</span></strong><span class="koboSpan" id="kobo.1696.1">())))</span></pre>
<p><span class="koboSpan" id="kobo.1697.1">After setting this configuration to add an address (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1698.1">POST /api/v1/addresses</span></strong><span class="koboSpan" id="kobo.1699.1">), it now requires both authentication and authorization. </span><span class="koboSpan" id="kobo.1699.2">This means the logged-in user must have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1700.1">ADMIN</span></strong><span class="koboSpan" id="kobo.1701.1"> role to call this endpoint successfully. </span><span class="koboSpan" id="kobo.1701.2">Also, we changed the default claim from scope </span><span class="No-Break"><span class="koboSpan" id="kobo.1702.1">to role.</span></span></p>
<p><span class="koboSpan" id="kobo.1703.1">Now, we can</span><a id="_idIndexMarker573"/><span class="koboSpan" id="kobo.1704.1"> proceed further with method-level, role-based restrictions. </span><span class="koboSpan" id="kobo.1704.2">Spring Security provides a feature that allows you to place authority- and role-based restrictions on public methods of Spring beans, using a set of annotations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1705.1">@PreAuthorize</span></strong><span class="koboSpan" id="kobo.1706.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1707.1">@Secured</span></strong><span class="koboSpan" id="kobo.1708.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1709.1">@RolesAllowed</span></strong><span class="koboSpan" id="kobo.1710.1">. </span><span class="koboSpan" id="kobo.1710.2">By default, these are disabled; therefore, you need to enable </span><span class="No-Break"><span class="koboSpan" id="kobo.1711.1">them explicitly.</span></span></p>
<p><span class="koboSpan" id="kobo.1712.1">Let’s enable these by adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1713.1">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></strong><span class="koboSpan" id="kobo.1714.1"> annotation to the Spring Security configuration class, </span><span class="No-Break"><span class="koboSpan" id="kobo.1715.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1716.1">
@Configuration</span><strong class="bold"><span class="koboSpan" id="kobo.1717.1">@EnableWebSecurity</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1718.1">@EnableGlobalMethodSecurity(prePostEnabled = true)</span></strong><span class="koboSpan" id="kobo.1719.1">
public class SecurityConfig {</span></pre>
<p><span class="koboSpan" id="kobo.1720.1">Now, you can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1721.1">@PreAuthorize</span></strong><span class="koboSpan" id="kobo.1722.1"> (the given access-control expression would be evaluated before the method invocation) and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1723.1">@PostAuthorize</span></strong><span class="koboSpan" id="kobo.1724.1"> (the given access-control expression would be evaluated after the method invocation) annotations to place restrictions on public methods of Spring beans because you have set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1725.1">prePostEnabled</span></strong><span class="koboSpan" id="kobo.1726.1"> property to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1727.1">true</span></strong><span class="koboSpan" id="kobo.1728.1"> when enabling the global </span><span class="No-Break"><span class="koboSpan" id="kobo.1729.1">method-level security.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1730.1">@EnableGlobalMethodSecurity</span></strong><span class="koboSpan" id="kobo.1731.1"> also supports the </span><span class="No-Break"><span class="koboSpan" id="kobo.1732.1">following properties:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1733.1">securedEnabled</span></strong><span class="koboSpan" id="kobo.1734.1">: This allows you to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1735.1">@Secured</span></strong><span class="koboSpan" id="kobo.1736.1"> annotation on </span><span class="No-Break"><span class="koboSpan" id="kobo.1737.1">public methods.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1738.1">jsr250Enabled</span></strong><span class="koboSpan" id="kobo.1739.1">: This allows you to use JSR-250 annotations such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1740.1">@RolesAllowed</span></strong><span class="koboSpan" id="kobo.1741.1">, which can be applied to both public classes and methods. </span><span class="koboSpan" id="kobo.1741.2">As the name suggests, you can use a list of roles for </span><span class="No-Break"><span class="koboSpan" id="kobo.1742.1">access restrictions.</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1743.1">@PreAuthorize</span></strong><span class="koboSpan" id="kobo.1744.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1745.1">@PostAuthorize</span></strong><span class="koboSpan" id="kobo.1746.1"> are more powerful than the other security annotations because not only can they be configured for authorities/roles but also for any </span><a id="_idIndexMarker574"/><span class="koboSpan" id="kobo.1747.1">valid </span><strong class="bold"><span class="koboSpan" id="kobo.1748.1">Spring Expression Language</span></strong><span class="koboSpan" id="kobo.1749.1"> (</span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1750.1">SpEL</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1751.1">) expression:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1752.1">
For demonstration purposes, let's add the </span><strong class="bold"><span class="koboSpan" id="kobo.1753.1">@PreAuthorize</span></strong><span class="koboSpan" id="kobo.1754.1"> annotation to the </span><strong class="bold"><span class="koboSpan" id="kobo.1755.1">deleteAddressesById()</span></strong><span class="koboSpan" id="kobo.1756.1"> method, which is associated with </span><strong class="bold"><span class="koboSpan" id="kobo.1757.1">DELETE /v1/auth/addresses/{id}</span></strong><span class="koboSpan" id="kobo.1758.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.1759.1">AddressController</span></strong><span class="koboSpan" id="kobo.1760.1">, as shown in the following code snippet:</span><strong class="bold"><span class="koboSpan" id="kobo.1761.1">@PreAuthorize("hasRole('" + Const.ADMIN + "')")</span></strong><span class="koboSpan" id="kobo.1762.1">
@Override
public ResponseEntity&lt;Void&gt; deleteAddressesById(String id) {
  service.deleteAddressesById(id);
  return accepted().build();
}</span></pre>
<p><span class="koboSpan" id="kobo.1763.1">Let’s break </span><a id="_idIndexMarker575"/><span class="koboSpan" id="kobo.1764.1">down the preceding </span><span class="No-Break"><span class="koboSpan" id="kobo.1765.1">code snippet:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1766.1">hasRole()</span></strong><span class="koboSpan" id="kobo.1767.1"> is a built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1768.1">SpEL</span></strong><span class="koboSpan" id="kobo.1769.1"> expression. </span><span class="koboSpan" id="kobo.1769.2">We need to pass a valid </span><strong class="source-inline"><span class="koboSpan" id="kobo.1770.1">SpEL</span></strong><span class="koboSpan" id="kobo.1771.1"> expression, and it should be a string. </span><span class="koboSpan" id="kobo.1771.2">Any variable used to form this </span><strong class="source-inline"><span class="koboSpan" id="kobo.1772.1">SpEL</span></strong><span class="koboSpan" id="kobo.1773.1"> expression should be final. </span><span class="koboSpan" id="kobo.1773.2">Therefore, we have declared the final string constants in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1774.1">RoleEnum</span></strong><span class="koboSpan" id="kobo.1775.1"> enum (for </span><span class="No-Break"><span class="koboSpan" id="kobo.1776.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1777.1">Const.ADMIN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1778.1">).</span></span></li>
<li><span class="koboSpan" id="kobo.1779.1">Now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1780.1">DELETE /api/v1/addresses/{id}</span></strong><span class="koboSpan" id="kobo.1781.1"> REST API can only be invoked if the user has the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1782.1">ADMIN</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1783.1"> role.</span></span></li>
<li><span class="koboSpan" id="kobo.1784.1">Spring Security provides various built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1785.1">SpEL</span></strong><span class="koboSpan" id="kobo.1786.1"> expressions, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1787.1">hasRole()</span></strong><span class="koboSpan" id="kobo.1788.1">. </span><span class="koboSpan" id="kobo.1788.2">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.1789.1">some others:</span></span><ul><li><strong class="source-inline"><span class="koboSpan" id="kobo.1790.1">hasAnyRole(String… roles)</span></strong><span class="koboSpan" id="kobo.1791.1">: This returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1792.1">true</span></strong><span class="koboSpan" id="kobo.1793.1"> if the principal’s role matches any of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1794.1">given roles.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1795.1">hasAuthority(String authority)</span></strong><span class="koboSpan" id="kobo.1796.1">: This returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1797.1">true</span></strong><span class="koboSpan" id="kobo.1798.1"> if the principal has given authority. </span><span class="koboSpan" id="kobo.1798.2">Similarly, you can also use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1799.1">hasAnyAuthority(String… authorities)</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1800.1">.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1801.1">permitAll</span></strong><span class="koboSpan" id="kobo.1802.1">: This </span><span class="No-Break"><span class="koboSpan" id="kobo.1803.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1804.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1805.1">.</span></span></li><li><strong class="source-inline"><span class="koboSpan" id="kobo.1806.1">denyAll</span></strong><span class="koboSpan" id="kobo.1807.1">: This </span><span class="No-Break"><span class="koboSpan" id="kobo.1808.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1809.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1810.1">.</span></span></li></ul></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1811.1">isAnonymous()</span></strong><span class="koboSpan" id="kobo.1812.1">: This returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1813.1">true</span></strong><span class="koboSpan" id="kobo.1814.1"> if the current user </span><span class="No-Break"><span class="koboSpan" id="kobo.1815.1">is anonymous.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1816.1">isAuthenticated()</span></strong><span class="koboSpan" id="kobo.1817.1">: This returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1818.1">true</span></strong><span class="koboSpan" id="kobo.1819.1"> if the current user is </span><span class="No-Break"><span class="koboSpan" id="kobo.1820.1">not anonymous.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1821.1">A full list of these expressions is available </span><span class="No-Break"><span class="koboSpan" id="kobo.1822.1">at </span></span><a href="https://docs.spring.io/spring-security/site/docs/3.0.x/reference/el-access.html"><span class="No-Break"><span class="koboSpan" id="kobo.1823.1">https://docs.spring.io/spring-security/site/docs/3.0.x/reference/el-access.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1824.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1825.1">Similarly, you </span><a id="_idIndexMarker576"/><span class="koboSpan" id="kobo.1826.1">can apply access restrictions for other APIs. </span><span class="koboSpan" id="kobo.1826.2">Let’s test security in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1827.1">next section.</span></span></p>
<h1 id="_idParaDest-165"><a id="_idTextAnchor164"/><span class="koboSpan" id="kobo.1828.1">Testing security</span></h1>
<p><span class="koboSpan" id="kobo.1829.1">By now, you </span><a id="_idIndexMarker577"/><span class="koboSpan" id="kobo.1830.1">must be looking forward to testing. </span><span class="koboSpan" id="kobo.1830.2">You can find the API client collection at the following location. </span><span class="koboSpan" id="kobo.1830.3">You can import it and then test the APIs, using any API client that supports the HAR type file </span><span class="No-Break"><span class="koboSpan" id="kobo.1831.1">import: </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har"><span class="No-Break"><span class="koboSpan" id="kobo.1832.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1833.1">.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1834.1">Important note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1835.1">Make sure to generate the keys again, as keys generated by the JDK keytool are only valid for </span><span class="No-Break"><span class="koboSpan" id="kobo.1836.1">90 days.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.1837.1">Building and running the Chapter 06 code</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1838.1">You can build the code by running </span><strong class="source-inline"><span class="koboSpan" id="kobo.1839.1">gradlew clean build</span></strong><span class="koboSpan" id="kobo.1840.1"> from the root of the project, and you can run the service using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1841.1">java -jar build/libs/Chapter06-0.0.1-SNAPSHOT.jar</span></strong><span class="koboSpan" id="kobo.1842.1">. </span><span class="koboSpan" id="kobo.1842.2">Make sure to use Java 17 in </span><span class="No-Break"><span class="koboSpan" id="kobo.1843.1">the path.</span></span></p>
<p><span class="koboSpan" id="kobo.1844.1">Now, let’s test our first </span><span class="No-Break"><span class="koboSpan" id="kobo.1845.1">use case.</span></span></p>
<p><span class="koboSpan" id="kobo.1846.1">Let’s fire the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1847.1">GET /api/vi/addresses</span></strong><span class="koboSpan" id="kobo.1848.1"> API without the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1849.1">Authorization</span></strong><span class="koboSpan" id="kobo.1850.1"> header, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1851.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1852.1">
$ curl -v 'http://localhost:8080/api/v1/addresses' -H 'Content- Type: application/json' -H 'Accept: application/json'&lt; </span><strong class="bold"><span class="koboSpan" id="kobo.1853.1">HTTP/1.1 401</span></strong><span class="koboSpan" id="kobo.1854.1">
&lt; Vary: Origin
&lt; Vary: Access-Control-Request-Method
&lt; Vary: Access-Control-Request-Headers
&lt; </span><strong class="bold"><span class="koboSpan" id="kobo.1855.1">WWW-Authenticate: Bearer</span></strong><span class="koboSpan" id="kobo.1856.1">
&lt; X-Content-Type-Options: nosniff
&lt; X-XSS-Protection: 1; mode=block
&lt; Cache-Control: no-cache, no-store, max-age=0, must
revalidate
&lt; Other information is removed for brevity</span></pre>
<p><span class="koboSpan" id="kobo.1857.1">This returns the HTTP </span><strong class="source-inline"><span class="koboSpan" id="kobo.1858.1">401</span></strong><span class="koboSpan" id="kobo.1859.1"> status (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1860.1">unauthorized</span></strong><span class="koboSpan" id="kobo.1861.1">) and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1862.1">WWW-Authenticate: Bearer</span></strong><span class="koboSpan" id="kobo.1863.1"> response header, which suggests the request should be sent with an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1864.1">Authorization</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1865.1"> header.</span></span></p>
<p><span class="koboSpan" id="kobo.1866.1">Let’s send the request </span><a id="_idIndexMarker578"/><span class="koboSpan" id="kobo.1867.1">again with an invalid token, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1868.1">following command:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1869.1">
$ curl -v 'http://localhost:8080/api/v1/addresses' -H 'Content-Type: application/json' -H 'Accept: application/json' -H </span><strong class="bold"><span class="koboSpan" id="kobo.1870.1">'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9…</span></strong><span class="koboSpan" id="kobo.1871.1">rest of the JWT string removed for brevity'
&lt; </span><strong class="bold"><span class="koboSpan" id="kobo.1872.1">HTTP/1.1 401</span></strong><span class="koboSpan" id="kobo.1873.1">
&lt; Vary: Origin
&lt; Vary: Access-Control-Request-Method
&lt; Vary: Access-Control-Request-Headers
&lt; </span><strong class="bold"><span class="koboSpan" id="kobo.1874.1">WWW-Authenticate: Bearer</span></strong><span class="koboSpan" id="kobo.1875.1">
&lt; Other information is removed for brevity</span></pre>
<p><span class="koboSpan" id="kobo.1876.1">Again, it returns the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1877.1">401</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1878.1"> response.</span></span></p>
<p><span class="koboSpan" id="kobo.1879.1">We have created two users using a Flyway database migration script – </span><strong class="source-inline"><span class="koboSpan" id="kobo.1880.1">scott/tiger</span></strong><span class="koboSpan" id="kobo.1881.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1882.1">scott2/tiger</span></strong><span class="koboSpan" id="kobo.1883.1">. </span><span class="koboSpan" id="kobo.1883.2">Now, let’s perform a sign-in with the username </span><strong class="source-inline"><span class="koboSpan" id="kobo.1884.1">scott</span></strong><span class="koboSpan" id="kobo.1885.1"> to get the valid JWT, </span><span class="No-Break"><span class="koboSpan" id="kobo.1886.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1887.1">
$ curl -X POST http://localhost:8080/api/v1/auth/token -H  'Accept: application/json' -H  'Content-Type: application/json' -d '{    "username": "scott",
    "password": "tiger"
  }'
{"</span><strong class="bold"><span class="koboSpan" id="kobo.1888.1">refreshToken</span></strong><span class="koboSpan" id="kobo.1889.1">":"9rdk5b35faafkneqg9519s6p4tbbqcdt412t7h5st9savkonqnnd 5e8ntr334m8rffgo6bio1vglng1hqqse3igdonoabc971lpdgt3bjoc3je3m81ldp2au vimts8p6","</span><strong class="bold"><span class="koboSpan" id="kobo.1890.1">accessToken</span></strong><span class="koboSpan" id="kobo.1891.1">":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJzdWI iOiJzY290dCIsInJvbGVzIjpbIlVTRVIiXSwiaXNzIjoiTW9kZXJuIEFQSSBEZXZlbG9 wbWVudCB3aXRoIFNwcmluZyBhbmQgU3ByaW5nIEJvb3QiLCJleHAiOjE2Nzc0OTYzMzk sImlhdCI6MTY3NzQ5NTQzOX0.a77O7ZbSAOw5v6Tb3w-MtBwotMEUvc1H1y2W0IU2QJh0m lSJxSBCfdrNBl0mVk1HnwX4kOpj4grbNasBjpIpHtyOLXdp-gngxdvVfaKSPuptrW4YzA3 ikxbUMWDdEtij_y2DRxJXQ6CrPTjA40L7yB_SXswnHT988Qq6ZALeGW-Lmz-vzAZiRcZUe 6bPPn7F-p4lK_qi1nsUJ1rnWmmffLWCH37ztllcgh6bB1UJuOn9Hw2A1nQExfUutRKgFK0 -LxBUOKOKdRESOnJR9hwOL6v10IFl9xNm53LVMIcuJrndCxvmv7mv0fUOxY63UwhO9kOT RCXViGKCa3H8RxUFwG52q2nZelle_4I8CUSeDDdmD2Rlax2NyQNe-HHEJb9c91JSzhFm0 K0-c34-kiNGqaB3jljndHoGXCBLM5prphlSdlV4U9PYhmL8ZCaDv8q6rCPSAEcRoiOBPPn dxEApHKulj9vrO_p7K1T9dLamJSFJKw9Yz8M3_ngiE3qtEBQ3tEUFkZsJpGop5HIxrkB0O e7L_oETir_wUe1qs8AIZcKSwP9X6fpUuOlONKDpDc-f-n5PjEAvts3BcxuM8Jrw80F6z6T OJrcikrMt8DGaIXs2WHNP7C605l-JgwCVuZz_8S4LLtaCFnqq4xLU1Gy2qj5CBbALVoFcB fjoVLN2fq4","</span><strong class="bold"><span class="koboSpan" id="kobo.1892.1">username</span></strong><span class="koboSpan" id="kobo.1893.1">":"scott","</span><strong class="bold"><span class="koboSpan" id="kobo.1894.1">userId</span></strong><span class="koboSpan" id="kobo.1895.1">":"a1b9b31d-e73c-4112-af7c-b68530f38222"}</span></pre>
<p><span class="koboSpan" id="kobo.1896.1">This returns</span><a id="_idIndexMarker579"/><span class="koboSpan" id="kobo.1897.1"> with both a refresh and an access token. </span><span class="koboSpan" id="kobo.1897.2">Let’s use this access token to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1898.1">GET /api/v1/addresses</span></strong><span class="koboSpan" id="kobo.1899.1"> API again (please note that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1900.1">Bearer</span></strong><span class="koboSpan" id="kobo.1901.1"> token value in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1902.1">Authorization</span></strong><span class="koboSpan" id="kobo.1903.1"> header is taken from the response of the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.1904.1">POST /api/v1/ auth/token</span></strong><span class="koboSpan" id="kobo.1905.1"> API call). </span><span class="koboSpan" id="kobo.1905.2">The command is shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1906.1">following block:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1907.1">
$ curl -v 'http://localhost:8080/api/v1/addresses' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGci…rest of the JWT string removed for brevity'
&lt; HTTP/1.1 403
&lt; Vary: Origin
&lt; Vary: Access-Control-Request-Method
&lt; Vary: Access-Control-Request-Headers
&lt; WWW-Authenticate: Bearer error="insufficient_scope", error_description="The request requires higher privileges than provided by the access token.", error_uri="https://tools.ietf.org/html/rfc6750#section-3.1"</span></pre>
<p><span class="koboSpan" id="kobo.1908.1">This </span><a id="_idIndexMarker580"/><span class="koboSpan" id="kobo.1909.1">command execution returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.1910.1">403</span></strong><span class="koboSpan" id="kobo.1911.1">. </span><span class="koboSpan" id="kobo.1911.2">It means that the user was authenticated successfully. </span><span class="koboSpan" id="kobo.1911.3">However, the user doesn’t contain the required role to access </span><span class="No-Break"><span class="koboSpan" id="kobo.1912.1">the endpoint.</span></span></p>
<p><span class="koboSpan" id="kobo.1913.1">Let’s try again, with user </span><strong class="source-inline"><span class="koboSpan" id="kobo.1914.1">scott2</span></strong><span class="koboSpan" id="kobo.1915.1"> this time, who has an </span><span class="No-Break"><span class="koboSpan" id="kobo.1916.1">ADMIN role:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1917.1">
$ curl -X POST http://localhost:8080/api/v1/auth/token -H  'Accept: application/json' -H  'Content-Type: application/json' -d '{    "username": "scott2",
    "password": "tiger"
  }'
{"refreshToken":"a6hidhaeb8scj3p6kei61g4a649dghcf5jit1v6rba2mn92o0dm0g 6gs6qfh7suiv68p2em0t0nnue8unm10bg079f39590jig0sccisecim5ep3ipuiu29ceao c793h","accessToken":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9…","usernam e":"scott2","userId":"a1b9b31d-e73c-4112-af7c-b68530f38223"}
## Some of the output removed for brevity
$ curl -v 'http://localhost:8080/api/v1/addresses' -H 'Content-Type: application/json' -H 'Accept: application/json' -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9…'
[{"links":[{"rel":"self","href":"http://localhost:8080/a731fda1-aaad-42ea-bdbc-a27eeebe2cc0"},{"rel":"self","href":"http://localhost:8080/api/v1/addresses/a731fda1-aaad-42ea-bdbc-a27eeebe2cc0"}],"id":"a731fda1-aaad-42ea-bdbc-a27eeebe2cc0","number":"9I-999","residency":"Fraser Suites Le Claridge","street":"Champs-Elysees","city":"Paris","state":"Île-de-France","country":"France","pincode":"75008"}]</span></pre>
<p><span class="koboSpan" id="kobo.1918.1">This time, the </span><a id="_idIndexMarker581"/><span class="koboSpan" id="kobo.1919.1">call is successful. </span><span class="koboSpan" id="kobo.1919.2">Now, let’s use the refresh token to get a new access token, </span><span class="No-Break"><span class="koboSpan" id="kobo.1920.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1921.1">
$  curl -X POST 'http://localhost:8080/api/v1/auth/token/refresh' -H 'Content-Type: application/json' -H 'Accept: application/json' -d '{"refreshToken": "a6hidhaeb8scj3p6kei61g4a649dghcf5jit1v6rba2mn92o0dm0 g6gs6qfh7suiv68p2em0t0nnue8unm10bg079f39590jig0sccisecim5ep3ipuiu29ce aoc793h"
}'
{"refreshToken":"a6hidhaeb8scj3p6kei61g4a649dghcf5jit1v6rba2mn92o0dm0g 6gs6qfh7suiv68p2em0t0nnue8unm10bg079f39590jig0sccisecim5ep3ipuiu29ceao c793h","accessToken":"eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9… rest of the token truncated for brevity","username":"scott2","userId":"a1b9b31d-e73c-4112-af7c-b68530f38223"}</span></pre>
<p><span class="koboSpan" id="kobo.1922.1">This time, it returns a new access token with the same refresh token given in </span><span class="No-Break"><span class="koboSpan" id="kobo.1923.1">the payload.</span></span></p>
<p><span class="koboSpan" id="kobo.1924.1">If you pass an invalid refresh token while calling the refresh token API, it will provide the </span><span class="No-Break"><span class="koboSpan" id="kobo.1925.1">following response:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1926.1">
{  "errorCode":"PACKT-0010",
  "message":"Requested resource not found. </span><span class="koboSpan" id="kobo.1926.2">Invalidtoken.",
  "status":404,
  "url":"http://localhost:8080/api/v1/auth/token/refresh",
  "reqMethod":"POST","timestamp":"2023-02-27T11:13:27.183172Z"
}</span></pre>
<p><span class="koboSpan" id="kobo.1927.1">Similarly, you</span><a id="_idIndexMarker582"/><span class="koboSpan" id="kobo.1928.1"> can call other API endpoints. </span><span class="koboSpan" id="kobo.1928.2">Alternatively, you can import the following HAR file in an API client, such as Insomnia, and then test the remaining </span><span class="No-Break"><span class="koboSpan" id="kobo.1929.1">APIs: </span></span><a href="https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har"><span class="No-Break"><span class="koboSpan" id="kobo.1930.1">https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/blob/main/Chapter06/Chapter06-API-Collection.har</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.1931.1">.</span></span></p>
<h1 id="_idParaDest-166"><a id="_idTextAnchor165"/><span class="koboSpan" id="kobo.1932.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1933.1">In this chapter, you learned about JWTs, Spring Security, authentication using filters, and JWT token validation, using filters and authentication with the Spring OAuth 2.0 resource server. </span><span class="koboSpan" id="kobo.1933.2">You also learned how you can add CORS and CSRF protection and why these </span><span class="No-Break"><span class="koboSpan" id="kobo.1934.1">are necessary.</span></span></p>
<p><span class="koboSpan" id="kobo.1935.1">You also learned about access protection based on roles and authorities. </span><span class="koboSpan" id="kobo.1935.2">You have now the skills to implement JWTs, Spring Security, and the Spring Security OAuth 2.0 resource server to protect your </span><span class="No-Break"><span class="koboSpan" id="kobo.1936.1">web resources.</span></span></p>
<p><span class="koboSpan" id="kobo.1937.1">In the next chapter, you will develop a sample e-commerce app’s UI using the Spring Security framework and APIs used in this chapter. </span><span class="koboSpan" id="kobo.1937.2">This integration will allow you to understand the UI flows and how to consume REST APIs </span><span class="No-Break"><span class="koboSpan" id="kobo.1938.1">using JavaScript.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor166"/><span class="koboSpan" id="kobo.1939.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.1940.1">What is a security context and </span><span class="No-Break"><span class="koboSpan" id="kobo.1941.1">a principal?</span></span></li>
<li><span class="koboSpan" id="kobo.1942.1">Which is the preferred way to secure a JWT – signing or encrypting </span><span class="No-Break"><span class="koboSpan" id="kobo.1943.1">a token?</span></span></li>
<li><span class="koboSpan" id="kobo.1944.1">What are the best practices to use </span><span class="No-Break"><span class="koboSpan" id="kobo.1945.1">a JWT?</span></span></li>
</ol>
<h1 id="_idParaDest-168"><a id="_idTextAnchor167"/><span class="koboSpan" id="kobo.1946.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.1947.1">The security context stores the principal using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1948.1">SecurityContextHolder</span></strong><span class="koboSpan" id="kobo.1949.1"> and is always available in the same thread of execution. </span><span class="koboSpan" id="kobo.1949.2">The security context allows you to extract the principal during the flow execution and use it wherever you want. </span><span class="koboSpan" id="kobo.1949.3">This is where a security annotation such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1950.1">@PreAuthorize</span></strong><span class="koboSpan" id="kobo.1951.1"> makes use of it for validation. </span><span class="koboSpan" id="kobo.1951.2">The principal is the currently logged-in user. </span><span class="koboSpan" id="kobo.1951.3">It can either be an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1952.1">UserDetails</span></strong><span class="koboSpan" id="kobo.1953.1"> or a string carrying a username. </span><span class="koboSpan" id="kobo.1953.2">You can use the following code to </span><span class="No-Break"><span class="koboSpan" id="kobo.1954.1">extract it:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.1955.1">
Object principal = SecurityContextHolder                   .getContext().getAuthentication()                   .getPrincipal();if (principal instanceof UserDetails) {  String username =              ((UserDetails)principal).getUsername();} else {  String username = principal.toString();}</span></pre></li> <li><span class="koboSpan" id="kobo.1956.1">This is a subjective question. </span><span class="koboSpan" id="kobo.1956.2">However, it is recommended to use the signing of tokens (JWS) if a JWT doesn’t contain sensitive and private information, such as date of birth or credit card information. </span><span class="koboSpan" id="kobo.1956.3">In such cases, you should make use of JWE to encrypt the information. </span><span class="koboSpan" id="kobo.1956.4">If you want to use both together, then the preferred way is to use encryption for information carried by the token and then sign it </span><span class="No-Break"><span class="koboSpan" id="kobo.1957.1">with keys.</span></span></li>
<li><span class="koboSpan" id="kobo.1958.1">You can follow the following guidelines and add to them if you discover any </span><span class="No-Break"><span class="koboSpan" id="kobo.1959.1">new ones:</span></span><ul><li><span class="koboSpan" id="kobo.1960.1">Make sure that JWT always has issuer and </span><span class="No-Break"><span class="koboSpan" id="kobo.1961.1">audience validations.</span></span></li><li><span class="koboSpan" id="kobo.1962.1">Make sure that a JWT validation does not allow a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1963.1">none</span></strong><span class="koboSpan" id="kobo.1964.1"> algorithm (i.e., no algorithm mentioned in JWT or when the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1965.1">alg</span></strong><span class="koboSpan" id="kobo.1966.1"> field in the JWT header contains a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1967.1">none</span></strong><span class="koboSpan" id="kobo.1968.1"> value). </span><span class="koboSpan" id="kobo.1968.2">Instead, make sure that you have verification in place that checks the specific algorithm (whatever you configured) and </span><span class="No-Break"><span class="koboSpan" id="kobo.1969.1">a key.</span></span></li><li><span class="koboSpan" id="kobo.1970.1">Keep an eye on the </span><strong class="bold"><span class="koboSpan" id="kobo.1971.1">National Vulnerability </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1972.1">Database</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1973.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1974.1">NVD</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1975.1">).</span></span></li><li><span class="koboSpan" id="kobo.1976.1">Don’t use a weak key (secret). </span><span class="koboSpan" id="kobo.1976.2">Instead, use the asymmetric private/public keys with SHA 256, SHA 384, and </span><span class="No-Break"><span class="koboSpan" id="kobo.1977.1">SHA 512.</span></span></li><li><span class="koboSpan" id="kobo.1978.1">Use a minimum key size of 2,048 for normal cases and 3,072 for </span><span class="No-Break"><span class="koboSpan" id="kobo.1979.1">business cases.</span></span></li><li><span class="koboSpan" id="kobo.1980.1">A private key should be used for authentication, and the verification server should use a </span><span class="No-Break"><span class="koboSpan" id="kobo.1981.1">public key.</span></span></li><li><span class="koboSpan" id="kobo.1982.1">Make sure clients use the security guidelines to store the tokens, and web applications should use HTTPS for communication </span><span class="No-Break"><span class="koboSpan" id="kobo.1983.1">with servers.</span></span></li><li><span class="koboSpan" id="kobo.1984.1">Make sure the web application is tested thoroughly for </span><strong class="bold"><span class="koboSpan" id="kobo.1985.1">cross-site scripting</span></strong><span class="koboSpan" id="kobo.1986.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.1987.1">XSS</span></strong><span class="koboSpan" id="kobo.1988.1">) attacks. </span><span class="koboSpan" id="kobo.1988.2">It is always best to use a </span><strong class="bold"><span class="koboSpan" id="kobo.1989.1">content security </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1990.1">policy</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1991.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.1992.1">CSP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1993.1">).</span></span></li><li><span class="koboSpan" id="kobo.1994.1">Keep a short expiration time, and use a refresh token to refresh an </span><span class="No-Break"><span class="koboSpan" id="kobo.1995.1">access token.</span></span></li><li><span class="koboSpan" id="kobo.1996.1">Keep an eye on OWASP security guidelines and </span><span class="No-Break"><span class="koboSpan" id="kobo.1997.1">new threats.</span></span></li></ul></li>
</ol>
<h1 id="_idParaDest-169"><a id="_idTextAnchor168"/><span class="koboSpan" id="kobo.1998.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.1999.1">Hands-On Spring Security 5.x</span></em><span class="koboSpan" id="kobo.2000.1"> (video </span><span class="No-Break"><span class="koboSpan" id="kobo.2001.1">course): </span></span><a href="https://www.packtpub.com/product/hands-on-spring-security-5-x-video/9781789802931"><span class="No-Break"><span class="koboSpan" id="kobo.2002.1">https://www.packtpub.com/product/hands-on-spring-security-5-x-video/9781789802931</span></span></a></li>
<li><span class="koboSpan" id="kobo.2003.1">Spring Security </span><span class="No-Break"><span class="koboSpan" id="kobo.2004.1">documentation: </span></span><a href="https://docs.spring.io/spring-security/site/docs/current/reference/html5/"><span class="No-Break"><span class="koboSpan" id="kobo.2005.1">https://docs.spring.io/spring-security/site/docs/current/reference/html5/</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2006.1">JWT: </span></span><a href="https://tools.ietf.org/html/rfc7519"><span class="No-Break"><span class="koboSpan" id="kobo.2007.1">https://tools.ietf.org/html/rfc7519</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2008.1">JWS: </span></span><a href="https://www.rfc-editor.org/info/rfc7515"><span class="No-Break"><span class="koboSpan" id="kobo.2009.1">https://www.rfc-editor.org/info/rfc7515</span></span></a></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.2010.1">JWE: </span></span><a href="https://www.rfc-editor.org/info/rfc7516"><span class="No-Break"><span class="koboSpan" id="kobo.2011.1">https://www.rfc-editor.org/info/rfc7516</span></span></a></li>
<li><span class="koboSpan" id="kobo.2012.1">Spring Security in-built </span><strong class="source-inline"><span class="koboSpan" id="kobo.2013.1">SpEL</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.2014.1">expressions: </span></span><a href="https://docs.spring.io/spring-security/site/docs/3.0.x/refsseerence/el-access.html"><span class="No-Break"><span class="koboSpan" id="kobo.2015.1">https://docs.spring.io/spring-security/site/docs/3.0.x/refsseerence/el-access.html</span></span></a></li>
</ul>
</div>
</body></html>