- en: Sorting Algorithms and Fundamental Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how the intersection problem can be improved
    by using a sorting algorithm. This is common with many problems. If the data is
    organized in an ordered manner, a more efficient algorithm can be developed. In
    this chapter, we will start by exploring three types of sorting techniques, which
    are bubble, quick, and merge sorting. Later, we will learn different ways to organize
    data using fundamental data structures.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Describe how bubble sorting works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement faster sorting with quick sort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characterize merge sorting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build a linked list data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describe the stack data structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Bubble Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bubble sorting is the simplest sorting algorithm out there. The technique involves making
    multiple passes over the input array and swapping unordered elements close to
    one another. The technique is called bubble sort, as the sorted list "bubbles"
    up from the tail end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Bubble Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All sorting algorithms accept a list of elements and return them ordered. The
    main difference between each algorithm is the manner in which the sorting is done.
    Bubble sorting works by swapping adjacent elements. This pushes the sorted elements
    toward the end of the list.
  prefs: []
  type: TYPE_NORMAL
- en: '*Snippet 2.1* shows the pseudocode for bubble sort. The algorithm involves
    three simple tasks, which involves repeatedly stepping through the list to sort,
    comparing adjacent elements, and swapping them around if the first element is
    bigger than the second.'
  prefs: []
  type: TYPE_NORMAL
- en: How many passes do we need to perform on the array until our list is sorted?
    It turns out that to guarantee that our list is sorted, we need to do *(n - 1)*
    passes on the list, *n* being the length of our array. We will show why *(n -
    1)* passes are needed in the next section, but this is the main reason why bubble
    sort has a runtime complexity of *O(n²)*, since we're processing *n* elements
    for *n - 1* times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode for bubble sort is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.1: Bubble sort pseudocode'
  prefs: []
  type: TYPE_NORMAL
- en: The swap function in the *Snippet 2.1* switches the values of the two array
    pointers `j` and `j+1` using a temporary variable.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Bubble Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement bubble sort in Java, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Apply the pseudocode shown in *Snippet 2.1* in Java. Create a class and a method,
    accepting an array to sort as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The slightly tricky part of this algorithm is the swapping logic. This is done by
    assigning one of the elements to be swapped to a temporary variable, as shown
    in *Snippet 2.2*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.2: Bubble sort solution. Source class name: BubbleSort'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/7atHVR](https://goo.gl/7atHVR) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: Although bubble sort is very easy to implement, it's also one of the slowest
    sorting methods out there. In the next section, we will look at how we can slightly
    improve the performance of this algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Bubble Sorting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two main techniques we can adopt to improve the performance of bubble
    sort. It's important to realize that although both of these strategies improve
    the overall performance of bubble sort in the average case; in the worst case,
    the algorithm still has the same poor runtime complexity of *O(n²)*.
  prefs: []
  type: TYPE_NORMAL
- en: The first small enhancement we can make to the original bubble sort is to make
    use of the fact that a sorted "bubble" is building at the end of the list. With
    every pass we make, another item is added at the end portion of this bubble. This
    is the reason why *(n - 1)* passes are needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also shown in *Figure 2.1*. In this diagram, the items shown in the
    dotted circle are already sorted in the correct place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/35c38596-9b67-43de-9b6a-857729e91c1d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: Bubble forming toward the end of the list'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use this fact so we don''t try to sort the elements inside this bubble.
    We can do this by slightly modifying our Java code, as shown in *Snippet 2.3*.
    In the inner loop, instead of processing until the end of the list, we can stop
    just before the sorted bubble, until `numbers.length - i`. For brevity, in *Snippet
    2.3* we have replaced the swap logic with a method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.3: Bubble sort improvement 1\. Source class name: BubbleSort'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/vj267K](https://goo.gl/vj267K) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: If we give a sorted list to our bubble sort algorithm, we will still make multiple
    passes on it without modifying it. We can further improve the algorithm by cutting
    short the outer loop when the list inside the array is fully sorted. We can check
    that the array is sorted by checking if any swaps were done during our last pass.
    In this manner, if we give our method an already sorted list, we just need to
    do one pass on the array and leave it untouched. This means that the best case
    is now *O(n)*, although the worst case stays the same.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Bubble Sort Improvement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to improve the bubble sort algorithm by reducing the number of passes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to do this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the bubble sort method so that it stops sorting if the array is untouched
    after an inner loop pass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The solution can be developed easily if the outer for loop is changed into
    a `while` loop and a flag is kept to indicate if any elements have been swapped
    while going through the array. This is shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.4: Bubble sort improvement 2\. Source class name: BubbleSort'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/HgVYfL](https://goo.gl/HgVYfL) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have seen some simple tricks on how to improve the bubble
    sort algorithm. In the following sections, we shall look at some other sorting
    techniques that perform much faster than bubble sort.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Implementing Selection Sort in Java'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: Selection sort is best understood by imagining that you have two lists, A and
    B. Initially, we have list A, containing all the unsorted elements, and list B
    is empty. The idea is to use B to store the sorted elements. The algorithm would
    work by finding the smallest element from A and moving it to the end of B. We
    keep on doing this until A is empty and B is full. Instead of using two separate
    lists, we can just use the same input array, but keeping a pointer to divide the
    array in two.
  prefs: []
  type: TYPE_NORMAL
- en: In real life, this can be explained by picturing how you would sort a deck of
    cards. Using a shuffled deck, you can go through the cards one by one until you
    find the lowest card. You set this aside as a new, second pile. You then look
    for the next-lowest card and once found, you put it at the bottom of the second
    pile. You repeat this until the first pile is empty.
  prefs: []
  type: TYPE_NORMAL
- en: One way to arrive at the solution is to first write the pseudocode that uses
    two arrays (A and B, in the preceding description). Then, adopt the pseudocode
    to store the sorted list (array B) in the same input array by using the swapping
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the selection sort in Java
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implement the sort method found in the following class, which is available
    on the GitHub repository for the book at the following path:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/selectionsort/SelectionSort.java)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `sort` method should accept an integer array and sort it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have your project set up, you can run the unit test for this activity
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.selectionsort*`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Split the input array in two by using an array index pointer
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `sort` method should accept an integer array and sort it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Iterate over the unsorted portion of the array to find the minimum
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The minimum item is then swapped so that it can be added to the end of the sorted
    portion
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding Quick Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quick sort is a big improvement over bubble sort. This sorting technique was developed
    by British computer scientist Tony Hoare. The algorithm works in three main steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select a pivot
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Partition the list so that elements on the left of the pivot are less than the value
    of the pivot and the ones on the right are greater
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 1 and 2 on the left and right parts separately
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since recursion is required for quick sort, we will begin this section by giving
    an example of recursion. Later, we will see how the partitioning in the quick
    sort algorithm works, and in the end, we will put the recursion techniques to
    use in the final part.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Recursion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Recursion is a really useful tool for algorithm designers. It allows you to
    solve large problems by solving a smaller occurrence of the same problem. Recursive
    functions usually have a common structure with the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '*One or more stopping conditions*: Under certain conditions, it would stop
    the function from calling itself again'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*One or more recursive calls*: This is when a function (or method) calls itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the next example, we will pick the binary search problem seen in the previous
    chapter and change the algorithm to work in a recursive manner. Consider the binary
    search problem discussed in [Chapter 1](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml),
    *Algorithms and Complexities*, listed in *Snippet 1.7*. The implementation is
    iterative, that is, it loops until an item is found or the `end` parameter is
    equal or greater than the `start` variable. The following code snippet shows pseudocode
    on how we can change this method into a recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.5: Recursive binary search pseudocode'
  prefs: []
  type: TYPE_NORMAL
- en: There are actually two stopping conditions in a recursive binary search. The
    function stops the recursive chain if it either finds the search item at the midpoint
    or if the start array pointer is greater than the end, meaning the item wasn't
    found. The stopping condition can easily be found by examining any return paths
    that don't involve further recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Binary Search Recursively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement binary search recursively in Java, we''ll follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the pseudocode shown in *Snippet 2.5*, implement a recursive binary search
    function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide another method with a signature that only contains the search item
    and the sorted array as input. This method will then call the recursive function
    with appropriate values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Output**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the additional method making the initial call and
    the recursive function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.6: Recursive binary search. Source class name: BinarySearchRecursive'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/pPaZVZ](https://goo.gl/pPaZVZ) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is an essential tool for any developer and we'll make use of it in
    many parts in this book. In this section, we implemented an example for binary
    searching. In the next section, we shall look at how partitioning works in the
    quicksort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort Partitioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Partitioning is the process by which we reorder our array so that elements with
    a value less than our pivot are moved to the left of the pivot and those with
    a larger value are moved to the right (see *Figure 2.2*). There are numerous manners
    in which we can do this. Here, we will describe an easy-to-understand scheme known
    as **Lomuto Partitioning**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b53ef27e-6226-464d-9cbd-ff60637422d3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: Before and after partitioning of an array'
  prefs: []
  type: TYPE_NORMAL
- en: Many other schemes exist. The Lomuto scheme has the drawback that it is not
    very performant when it is used on already-sorted lists. The original Hoare partition
    scheme performs better and works by having the array processed from both ends.The
    original Hoare scheme performs better as it does fewer swaps, although it also
    suffers from slow performance when a sorted list is used as input. Both the Lomuto
    and Hoare schemes result in non-stable sorting. A stable sort means that if two
    or more elements have the same key value, they will appear in the same input order
    as the sorted output. There are other schemes that can be used to make quick sort
    stable, but they utilize more memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a good perception on this partitioning scheme, it is best to simplify
    what the algorithm is doing in five simple steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Pick the right most element of the array as the pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start from the left and find the next element that is larger than the pivot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swap this element with the next, which is smaller than pivot element.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat steps 2 and 3 until no more swapping is possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Swap the first item which is larger than the pivot's value with the pivot itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To perform efficient partitioning using the steps mentioned, we can make use
    of two pointers, one pointing to the first item larger than the pivot value and
    the other used to search for the value that is smaller than pivot value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, these are the integer pointers named `x` and `i`, respectively.
    The algorithm starts by choosing the pivot as the last item on the input array.
    It then processes the array from left to right in a single pass using the variable
    `i`. If the element currently being processed at `i` is smaller than the pivot,
    `x` is incremented and swapped. Using this technique, variable `x` is either pointing
    to a value larger than the pivot or the value of `x` is the same as `i`, in which
    case swapping will not modify the array. Once the loop exits, we perform the final
    step of swapping the first item that is larger than the pivot''s value with the
    pivot. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.7: Partitioning for quick sort. Source class name: QuickSort'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/vrStai](https://goo.gl/vrStai) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Understanding the Partitioning Method'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the partitioning method used in *Snippet 2.7*, walk through
    it one step at a time using an example.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how the Lomuto partitioning works.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Dry run the code mentioned in *Snippet 2.7* for each element in the array by incrementing
    the values of variables `x` and `i`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Complete the following table, assuming that the pivot is the last element of the
    list, that is, 16:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **i** | **Array** | **x** |'
  prefs: []
  type: TYPE_TB
- en: '| `-` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `-1` |'
  prefs: []
  type: TYPE_TB
- en: '| `0` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `0` |'
  prefs: []
  type: TYPE_TB
- en: '| `1` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `2` | `[4, 5, 33, 17, 3, 21, 1, 16]` | `1` |'
  prefs: []
  type: TYPE_TB
- en: '| `3` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `4` | `[4, 5, 3, 17, 33, 21, 1, 16]` | `2` |'
  prefs: []
  type: TYPE_TB
- en: '| `5` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `6` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| `7` |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| final | `[4, 5, 3, 1, 16, 21, 17, 33]` | `3` |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.1: Steps through the partitioning method'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have gained an understanding of how partitioning in quick
    sort works. In the next section, we'll put the partitioning method to use by including
    it in the full quick sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The quick sort is from a class of algorithms called divide and conquer. We will
    see many other examples from this class in the book, and we will go into detail
    on divide and conquer in [Chapter 4](da07fa18-a8ce-4d4c-91eb-9dc893de7273.xhtml),
    *Algorithm Design Paradigms*. For now, it's important to know that divide and
    conquer algorithms keep on splitting the problem into smaller ones until the problem
    is small enough that it becomes trivial to solve. This splitting can be easily
    implemented using recursion.
  prefs: []
  type: TYPE_NORMAL
- en: 'In quick sorting, we keep on recursively partitioning the array in this manner
    until the problem is small enough that we can easily solve it. When the array
    has only one element, the solution is simple: the array stays exactly as it is,
    as there is nothing to sort. This is the stopping condition of our recursive algorithm.
    When the array is larger than one element, we can keep dividing our array and
    use the partitioning method we developed in the previous section.'
  prefs: []
  type: TYPE_NORMAL
- en: There is also a non-recursive quick sort algorithm which makes use of a stack
    data structure, although it is a bit more complex to write. We will discuss stacks
    and lists later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the pseudocode for the complete quick sort.
    Just like most recursive functions, the code starts by checking the stopping condition.
    In this case, we check if the array has at least two elements by ensuring that
    the start array pointer is less than the end. The pseudocode is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.8: Recursive quick sort pseudocode'
  prefs: []
  type: TYPE_NORMAL
- en: When we have at least two elements in the array, we call the partitioning method.
    Then, using the pivot's last position (returned by the partitioning method), we
    recursively quick sort the left part and then the right part.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by calling the same quick sort code using pointers of `(start,
    p - 1)` and
  prefs: []
  type: TYPE_NORMAL
- en: '`(p + 1, end)`, not including the `p`, which is the pivot''s position.'
  prefs: []
  type: TYPE_NORMAL
- en: The trick to understanding how quick sort works is to realize that once we perform
    the partition call on the array, the element at the returned position (the pivot)
    doesn't need to move within the array anymore. This is because all the elements
    on its right are larger and the ones on the left are smaller, so the pivot is
    in the correct final position.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Quick Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement quick sort in Java, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the pseudocode shown in *Snippet 2.8* in Java, calling the partitioning
    method shown in *Snippet 2.7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows the recursive implementation in Java, making use of
    the partition method developed in the preceding section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.9: Solution for quick sort. Source class name: Quicksort'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have described the quick sort algorithm, which is much faster
    than the bubble sort algorithm that we saw in the previous section. On average,
    this algorithm performs in *O(n log n)*, a huge improvement over bubble sort's
    *O(n²)*. However, in the worst case, the algorithm still performs in *O(n²)*.
    The worst-case input of quick sort depends on the type of partitioning scheme
    in use. In the Lomuto scheme discussed in this section, the worst case occurs
    when the input is already sorted. In the next section, we will examine another
    sorting algorithm for which the worst runtime case is *O(n log n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Using Merge Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although the quicksort on average is pretty fast, it still has the theoretical
    worst time complexity of *O(n²)*. In this section, we shall examine another sorting
    algorithm, called **merge sort**, in which the worst time complexity is *O(n log
    n)*. Similar to quick sort, merge sort belongs to the divide and conquer class
    of algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Merge sort can be summarized in three simple steps as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Split the array in the middle
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Recursively sort each part separately
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merge the two sorted parts together
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following section, we will develop the preceding steps gradually, at
    each turn slowly building our understanding of how merge sorting works.
  prefs: []
  type: TYPE_NORMAL
- en: Although merge sort is theoretically faster than quick sort, in practice, some
    implementations of quick sort can be more efficient than merge sort. Additionally,
    the merge sort uses about *O(n)* memory as opposed to quick sort, which is *O(log
    n)*.
  prefs: []
  type: TYPE_NORMAL
- en: Dividing the Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding section, we saw how we can use a recursive technique to split
    the problem into smaller multiple ones until the solution becomes easy to solve.
    Merge sort uses the same approach. The base case for our recursive technique is
    the same as quick sort. This is when the array is only one element long. When
    the array to sort only contains one item, the array is already sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.3* shows how merge sort array splitting occurs. At each step, we
    find the midpoint of the array and split the array in two. We then recursively
    sort the left and right part of the split array separately. We can stop the recursive
    call once the total elements to sort is equal to one as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/31934f86-5e69-48c3-8cf4-2917b9760159.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 Showing the dividing steps for the merge sort algorithm
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Merge Sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to complete the pseudocode for a merge sort algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind that the merge sort''s recursive part is very similar to the
    quick sort algorithm we saw in the preceding section, complete the pseudocode
    shown in the following code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.10: Recursive merge sort pseudocode exercise'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudocode for merge sort can be completed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.11: Recursive merge sort pseudocode solution'
  prefs: []
  type: TYPE_NORMAL
- en: The merge sort algorithm is from the same class of algorithms as quick sort;
    however, its runtime and space complexity are different. Instead of dividing the
    array from the pivot's position, the merge sort always partitions the array at
    the midpoint. This is a similar process to binary search and results in *log[2]
    n* array divisions. In the next section, we will introduce the merge part of the
    merge sort algorithm, where the two different parts of the split array are combined
    into a sorted one.
  prefs: []
  type: TYPE_NORMAL
- en: Merging the Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you merge two sorted lists into a sorted one? This is the task of the
    `merge()` function, which is found at the end of the pseudocode shown in the preceding
    section. This process is shown in *Figure 2.4*. Merging two sorted lists is an
    easier task than sorting from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the intersection problem we saw in [Chapter 1](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml),
    *Algorithms and Complexities*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can merge in linear time utilizing just two pointers and an empty array
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/deeaf0cf-05a5-4e78-991f-1bf79f1cd9e2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: Before and after merging two sorted arrays'
  prefs: []
  type: TYPE_NORMAL
- en: Since the two parts of the split array are both sorted, it's easy to merge the
    two together. A useful analogy is to refer back to how the intersection problem
    we saw in [Chapter 1](52b469c2-7203-4188-9e37-6ab0bf659ca7.xhtml), *Algorithms
    and Complexities*, got a lot easier once the input arrays were both sorted. A
    similar algorithm can be used here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.12: Merge pseudocode for the merge sort'
  prefs: []
  type: TYPE_NORMAL
- en: In the merging part of the merge sort, we create a temporary array which is
    of size equal to the size of two array parts together. We then do a single pass
    on this array, filling the temporary array one item at a time by picking the smallest
    item between the two input lists (represented by the start, middle, and end pointers).
    After picking an item from one of the lists, we advance the pointer of that list
    and repeat until the merge is complete.
  prefs: []
  type: TYPE_NORMAL
- en: There are various Java tools we can use to implement the `copyArray()` function
    shown at the end of *Snippet 2.12*. We can simply implement a `for` loop and implement
    the `copy()` function ourselves. Alternatively, we can make use of Java's streams
    and write the copy in a single line. Possibly the easiest manner is to make use
    of the `System.arrayCopy()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Merge sort is theoretically one of the fastest sorting algorithms. The drawback
    of its speed is that it consumes a bit more memory, although some implementations
    exist that perform the merge step in place to save memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For comparison, we present multiple sorting techniques with their runtime and
    memory performances in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Algorithm name** | **Average case** | **Worst case** | **Memory** | **Stability**
    |'
  prefs: []
  type: TYPE_TB
- en: '| Bubble | *O(n²)* | *O(n²)* | *O(1)* | Stable |'
  prefs: []
  type: TYPE_TB
- en: '| Selection | *O(n²)* | *O(n²)* | *O(1)* | Unstable |'
  prefs: []
  type: TYPE_TB
- en: '| Insertion | *O(n²)* | *O(n²)* | *O(1)* | Stable |'
  prefs: []
  type: TYPE_TB
- en: '| Quick | *O(n log n)* | *O(n²)* | *O(1)* | Unstable |'
  prefs: []
  type: TYPE_TB
- en: '| Merge | *O(n log n)* | *O(n log n)* | *O(n)* | Stable |'
  prefs: []
  type: TYPE_TB
- en: '| Heap | *O(n log n)* | *O(n log n)* | *O(1)* | Unstable |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.2: Sorting algorithms'
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Implementing Merge Sort in Java'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: Merge sorting is one of the fastest sorting techniques. It is used in many bundled libraries
    and APIs. In this activity, we will write an algorithm in Java to sort an array using
    merge sort.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To use the pseudocode shown in this section to implement the full merge sort algorithm
    in Java.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this activity, you have to implement the methods found in the following class,
    which is available on the GitHub repository for the book at the following path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/mergesort/MergeSort.java)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have your project set up, you can run the unit test for this activity
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.mergesort*`**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Start from the `mergeSort` method, which splits the array in two, recursively sorts
    both, and merges the result
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, implement the merge method, which merges both ends of the split array
    into another space
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the merge is done, copy the new array back in place of the input array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting Started with Fundamental Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data structures are a way to organize data so that it is efficiently accessible
    for the problem you are trying to solve. Choosing the right data structure will
    depend on the type of problem you're trying to solve (dictating the manner you
    access your data), the amount of data you need to organize, and the medium you
    use to store your data (memory, disk, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: We have already seen and used one example of a data structure. In the preceding
    sections, we have made extensive use of arrays. Arrays are the most primitive
    of data structures. They provide access to your data using an index and are fixed
    in size (also called static). This is opposed to other dynamic data structures
    that can grow and make more space for data whenever it's needed.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'More formally, a data structure is an organization of data elements, a collection
    of functions that can be applied on the data (such as add, delete, and search)
    and any relations between the different data elements. The following table shows
    common operations that some data structures provide:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operation** | **Type** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `search(key)` | Non-modifying | An operation that, given the key to a particular value,
    will return the value stored in the data structure if it can be found. |'
  prefs: []
  type: TYPE_TB
- en: '| `side()` | Non-modifying | The total number of values stored in the data
    structure. |'
  prefs: []
  type: TYPE_TB
- en: '| `add(value)` | Modifying | Inserts a value in the data structure. |'
  prefs: []
  type: TYPE_TB
- en: '| `update(key, value)` | Modifying | Updates an existing entry using the provided key
    and value. |'
  prefs: []
  type: TYPE_TB
- en: '| `delete(value)` | Modifying | Removes an item of data from the data structure.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `minimum()` | Non-modifying | An operation supported only by ordered data structures,
    which will return the value with the minimal key. |'
  prefs: []
  type: TYPE_TB
- en: '| `maximum()` | Non-modifying | An operation supported only by ordered data structures,
    which will return the value with the minimal key. |'
  prefs: []
  type: TYPE_TB
- en: 'Table 2.3: Some common operations on data structures'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will see various types of dynamic data structures. We will
    start with linked lists, which are optimized for dynamic growth but are slow while
    searching. Then, we'll use these linked lists to implement other data structures
    on top, such as queues and stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Linked Lists Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A linked list is a list of data items where each item only knows about the next
    item in the list if there is one. *Figure 2.5* shows one such example. Each box
    in the figure represents a container for a data item we need to store. This container,
    called a node, contains our data values and a pointer to the next node in the
    list. As the diagram shows, the node on the front of the list is called the head
    of the list and the last item of the list is called the tail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Separate pointers to these nodes are stored for easy access of the data structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/335eb13f-be8e-4b8f-bcdd-09dab74fb329.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.5: Linked list example'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using a linked list as opposed to an array is that a linked
    list can grow dynamically. When using an array, you allocate space in the start
    and that space remains fixed. If you allocate too much and the space remains unused,
    you're wasting resources. On the other hand, if you make your array too small,
    the data might not ft. In a linked list, however, the space is not fixed. The
    structure grows dynamically as you add more data and it shrinks, freeing memory
    space as you remove it.
  prefs: []
  type: TYPE_NORMAL
- en: Using an object-oriented language, such as Java, let's model the linked list
    using separate node instances that are connected together to build our linked
    list. The following code shows how we can model a linked list node in a Java class.
  prefs: []
  type: TYPE_NORMAL
- en: The class contains a self-reference so we can link multiple nodes in list fashion,
    as shown in the *Figure 2.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.13: Linked list node class, with getters and setters omitted for
    brevity. Source class name: Linkedlistnode'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/SAefic](https://goo.gl/SAefic) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we use Java's optional classes (instead of returning null pointers)
    to represent whether there is a link to the next node. The tail node of a linked
    list will always have an empty optional. We also make use of generics to model
    the type of data we want to store. This way, we can keep the structure as general
    as possible so that it can used by any data type.
  prefs: []
  type: TYPE_NORMAL
- en: The `Optional` class was introduced in Java 8 to give the ability to represent
    optional values instead of using nulls.
  prefs: []
  type: TYPE_NORMAL
- en: Converting the Linked List to a Doubly Linked List Structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to modify the Java node class to support the doubly linked list structure.
  prefs: []
  type: TYPE_NORMAL
- en: A doubly linked list is a linked list in which each node contains a relation
    to the following and previous nodes. Modify the preceding code in *Snippet 2.13*
    to support this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the solution to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.14: Doubly linked list node class, with getters and setters omitted
    for brevity. Source class name: Dbllinkedlistnode'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/oJDQ8g](https://goo.gl/oJDQ8g) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: In a doubly linked list, the head node will have a null previous pointer while
    the tail node will have a null next pointer.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to model a linked list node using classes, generics,
    and optional references. In the next section, we shall see how to implement some
    of the linked list operations.
  prefs: []
  type: TYPE_NORMAL
- en: Linked Lists Operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can use any linked list operations, we need to initialize the data
    structure and mark it as empty. Conceptually, this is when the head of the list
    is pointing to nothing. We can do this in Java by adding this logic in a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows this. Notice that, once again, we use generics
    to hold the type of the items we want to store in the linked list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.15: Initializing the linked list data structure using constructors.
    Source class name: Linkedlist'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/vxpkRt](https://goo.gl/vxpkRt) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we add and remove items from the head of the list? Adding a node in
    a linked list requires a two pointer reassignment. On the new node, you set the
    next pointer to point to whatever the head pointer is assigned to. Then, you set
    the head pointer to point to this newly created node. This process is shown in
    *Figure 2.6*. Deleting from the front of the list is the reverse. You set the
    head pointer to point to the next pointer of the node at the old head. For completeness,
    you can set this next pointer to point to nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d869c0c-805c-4240-888a-808d38be4d54.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.6: Adding a node to the front of the list'
  prefs: []
  type: TYPE_NORMAL
- en: To locate an item in a list, we need to traverse the entire list until we find
    the item we're searching or reach the end of the list. This can be done easily
    by starting at the head pointer and always following the node's next pointer until
    you either find the node with the value you're looking for or you run out of nodes.
    For example, the next pointer is a null one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.16: Adding and deleting from the front of the linked list. Source
    class name: Linkedlist'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/D5NAoT](https://goo.gl/D5NAoT) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.17: Adding and deleting from the front of the linked list. Source
    class name: Linkedlist'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/6pQm3T](https://goo.gl/6pQm3T) to access the code. The
    `find()` method on a linked list has the worst runtime complexity of *O(n)*. This
    happens when either the matching item is at the end of the list or the item is
    not in the list at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we have shown how to add an item at the head of the
    list. How can we insert this into a linked list at an arbitrary point? *Figure
    2.7* shows how we can do this in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bb7a80c-3e61-4cd4-940b-61298bba2e4d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.7: Adding a node at an arbitrary position in the list'
  prefs: []
  type: TYPE_NORMAL
- en: '*Snippet 2.18* shows how we can do this. It is a Java method called `addAfter()` accepting
    a node and an item to insert. The method adds a node, containing the item, after
    the `aNode` argument. The implementation follows the steps shown in *Figure 2.7*.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.18: Solution method for addAfter operation. Source class name: Linkedlist'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/Sjxc6T](https://goo.gl/Sjxc6T) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Traversing the Linked List'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: We have a linked list containing some elements and we need to build a string
    of the form `[3,6,4,2,4]`. If the list is empty, it should output `[]`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To write code in Java for traversing the linked list.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write a `toString()` method in the `LinkedList` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Use a `while` loop to traverse the linked list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we have seen how we can implement the various operations found
    in the linked list. The data structure will be a base tool that we will use to
    model queues and stacks. Linked lists will also be extensively used in more advanced
    algorithms further along the book.
  prefs: []
  type: TYPE_NORMAL
- en: Queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Queues are abstract data structures that are meant to emulate the workings of
    real life queues. They are used extensively in various applications, such resource
    allocation, scheduling, sorting, and many others. They are typically implemented
    using a double linked list, although many other implementations exists. A queue
    usually consists of two operations; an `enqueue` operation, where items are added
    to the rear of the queue, and an opposite `dequeue` operation, where items are
    removed from the front of the queue. These two operations make the mode of operation
    of this data structure **First In First Out** (**FIFO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement an efficient queue using a double linked list. This enables
    us implement the `dequeue` operation by removing an item from the head of the
    linked list. `enqueue` is simply adding an item to the tail of the linked list.
    *Figure 2.8* shows how the two operations are performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/05f0f5c4-28b6-4eb2-8e4f-cfe31143e049.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.8: Enqueuing and dequeuing using a double linked list'
  prefs: []
  type: TYPE_NORMAL
- en: 'To dequeue an item using a double linked list as a base data structure, we
    just need to move the head to the next item in the list and unlink the old head
    by pointing the previous pointer to nothing. Enqueuing at the tail is a three-step
    process. Point the new node''s preceding pointer to the current tail, then point
    the current tail''s next pointer to the new node, and finally moving the tail
    to the new node. The pseudocode for both of these operations is shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.19: Enqueuing and dequeuing using a doubly linked list'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and Deleting the Elements from the Queue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement the `enqueue()` and `dequeue()` methods in Java, follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a double linked list, implement the dequeue and enqueue pseudocode shown
    in the preceding code in Java. Follow the structure and method signature shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.20: Exercise class structure and method signatures'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `enqueue()` method can be implemented as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.21: Exercise class structure and method signatures. Source class
    name: Queue'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/FddeYu](https://goo.gl/FddeYu) to access the code for
    `dequeue()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Queues are dynamic data structures that have a FIFO ordering. In the next section, we
    shall explore another data structure with a different ordering called a stack.
  prefs: []
  type: TYPE_NORMAL
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stacks, typically also implemented using linked lists, work differently than
    queues. Instead of the FIFO ordering, they have a **Last In First Out** (**LIFO**)
    ordering (see *Figure 2.9*). They have two main operations called push, which
    adds an item on top of the stack, and pop, which removes and returns one item
    from the top of the stack. Like queues, stacks are heavily used in many algorithms,
    such as depth first search traversal, expression evaluations, and many others:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9fcff6f4-1791-4ac3-a673-b1f420fdc65a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.9: Pushing and popping operations on a stack of papers'
  prefs: []
  type: TYPE_NORMAL
- en: To model a stack, it's enough to use a simple linked list. The head of the linked
    list can be used to reference the top of the stack. Every time we need to push
    something on the top of our stack, we can use the `addFront()` method we developed
    in the preceding sections. The implementations differ only in the fact that the
    pop operation returns the optional item on the top of the stack. Both push and
    pop can been seen in the Java implementation in the following code snippet. Notice
    how the pop operations return an optional value which is populated if the stack
    is not empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'A one-way linked list is enough to model a stack since we only need to operate
    from one end of the list. For a queue, we needed to modify both the head and tail
    of the linked list, hence it was more efficient to use a double linked list. The
    following code shows the implementation of the `push()` and `pop()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.22: Push and pop operations in java. Source class name: Stack'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/uUhuqg](https://goo.gl/uUhuqg) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: Reversing a String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to make use of a stack data structure for reversing a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To reverse the string, push of each character of the input string and then pop
    everything out, one at a time, building a reversed string. The method signature
    can be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows how a string can be reversed using the stack data structure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.23: Reverse a string solution Source class name: StringReverse'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/UN2d5U](https://goo.gl/UN2d5U) to access the code.
  prefs: []
  type: TYPE_NORMAL
- en: Stack data structures are extensively used in computer science for many algorithms.
    In this section, we have seen how to implement them in a dynamic fashion using
    linked lists. In the next section, we shall see how to model stacks and queue
    in a static manner using arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Modeling Stacks and Queues Using Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stacks and queues don't necessarily need to be dynamic. You may want a more
    concise implementation if you know your data requirements are of a fixed size.
    Using an array approach to model stacks and queues guarantees that your data structure
    will only grow up to a certain size. The other advantage of using an array is
    that the array approach is more memory efficient if you can live with having a
    static data structure. The catch with static data structures is that the queue
    or stack can only grow to a maximum fixed size of your initially allocated array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing a stack using an array involves first initializing an empty array
    with a fixed size. Then, it''s a matter of keeping an index pointer to the top
    of the stack, initially pointing to zero. As we push items on the stack, we place
    the item at this index and increment the pointer by one. When we need to pop an
    element, we reduce this pointer by one and read the value. This process is shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.24: Stack using an array instead of linked list. Source class name:
    Stackarray'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/T61L33](https://goo.gl/T61L33) to access the code
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a queue using an array requires a little more thinking. The difficulty
    with a queue is that the structure is modified from both ends since it grows from
    the tail and shrinks from the head.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we enqueue and dequeue the contents of the queue, it seems to be moving
    towards the right of the array. We need to deal with what happens when the contents
    reaches the end of our array. To make the queue work in an array, we just need
    to let our data wrap around the edges (think *Pacman*, *Figure 2.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e942fe9-67f4-4fcd-9f60-bf6ba43bc06d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.10: Array wrap around analogy'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The implementation in *Snippet 2.25* does not check if the circular buffer is
    full before enqueuing another item. Implementing this check is given as an exercise
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.25: Enqueue and dequeue using an array. Source class name: QueueArray'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/LJuYz9](https://goo.gl/LJuYz9) to access this code.
  prefs: []
  type: TYPE_NORMAL
- en: Safe Enqueuing in an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to write a safe `enqueue()` method that will fail when the queue is
    full.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steps for completion:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify the enqueue and dequeue methods shown in the preceding code so that the
    enqueue returns a Boolean value which is `false` when the queue is full and cannot
    accept further elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement the method signatures as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The following *Snippet 2.26* provides an implementation of the `enqueueSafe()` method,
    returning a Boolean value when the queue is full:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Snippet 2.26: Safe Enqueue and dequeue solution. Source class name: QueueArray'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://goo.gl/cBszQL](https://goo.gl/cBszQL) to access the code for
    implementation of `dequeueSafe()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how both queues and stacks can be implemented using a static array
    structure instead of using the dynamic linked list. This has the advantage of
    consuming less memory per element as a linked list has to store pointers to other
    nodes. However, this comes at the cost of having a limit on the structure size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Evaluating the Postfix Expression'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are used to writing mathematical expressions in the form of *1 + 2 * 3*.
    This type of notation is called an **infix**. Using infix notation, an operator
    is always in between two operators. There is a different notation called postfix,
    where the operator is after the operands. Examples of such expressions are shown
    in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Infix expression** | **Postfix expression** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 + 2 | 1 2 + |'
  prefs: []
  type: TYPE_TB
- en: '| 1 + 2 * 3 | 1 2 3 * + |'
  prefs: []
  type: TYPE_TB
- en: '| (1 + 2) * 3 | 1 2 + 3 * |'
  prefs: []
  type: TYPE_TB
- en: '| 5 + 4 / 2 * 3 | 5 4 2 / 3 * + |'
  prefs: []
  type: TYPE_TB
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement an algorithm that accepts a postfix string, evaluates it, and returns the
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prerequisites**'
  prefs: []
  type: TYPE_NORMAL
- en: Implement the following method in the class which is available on the
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub repository for the book at the following path:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java](https://github.com/TrainingByPackt/Data-Structures-and-Algorithms-in-Java/blob/master/src/main/java/com/packt/datastructuresandalg/lesson2/activity/postfix/EvalPostfix.java)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Assume the operator and operands are always separated by a space, such as *"5
    2 +"*. The input string will look like the examples shown in the preceding table.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have your project set up, you can run the unit test for this activity
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**`gradlew test --tests com.packt.datastructuresandalg.lesson2.activity.postfix*`**'
  prefs: []
  type: TYPE_NORMAL
- en: The solution becomes a lot simpler if you use one of the data structures we
    studied in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Use the stack data structure to solve this problem
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start processing the expression from left to right
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you encounter a numeric operand, push it on the stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you encounter an operator, pop two items from the stack and perform the operation
    accordingly (addition, subtraction, and so on) and push the result back on the
    stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have processed the entire expression, the result should be the on the
    top of the stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we laid the foundations for the more complex upcoming sections.
    In the first few sections, we saw how a simple problem such as sorting can have
    many solutions, all with different performance properties. We explored three main
    implementations, which were bubble, quick, and merge sort.
  prefs: []
  type: TYPE_NORMAL
- en: In later sections, we introduced data structures and studied various implementations
    and use cases of linked lists, queues, and stacks. We also saw how some data structures
    can be used as building blocks to build more complex ones on top. In the next
    chapter, we will study hash tables and binary trees, two important and widely
    used data structures.
  prefs: []
  type: TYPE_NORMAL
