["```java\npublic interface Mapper {    <T> Map<String, Object> toMap(T entity);\n    <T> T toEntity(Map<String, Object> map);\n}\n```", "```java\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)\npublic @interface Column {\n    String value() default \"\";\n}\n```", "```java\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)\npublic @interface Entity {\n}\n```", "```java\n@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)\npublic @interface Appends {\n    Append[] value();\n}\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\n@Repeatable(Appends.class)\npublic @interface Append {\n    String key();\n    String value();\n}\n```", "```java\n@Overridepublic <T> T toEntity(Map<String, Object> map) {\n    Objects.requireNonNull(map, \"map is required\");\n    // Step 1: Obtain the fully qualified class name from the map\n    T entity = getEntity(map.get(ENTITY_ENTRY).toString());\n    // Step 2: Retrieve the class type of the entity\n    Class<?> type = entity.getClass();\n    // Step 3: Iterate over the declared fields of the class\n    for (Field field : type.getDeclaredFields()) {\n        // Step 4: Determine the key associated with the field using \n        // @Column annotation \n        String key = Optional.ofNullable(field.getAnnotation(Column.\n          class))\n                .map(Column::value)\n                .filter(Predicate.not(String::isBlank))\n                .orElse(field.getName());\n        // Step 5: Retrieve the corresponding value from the map\n        Optional<Object> value = Optional.ofNullable(map.get(key));\n        // Step 6: Set the value in the object using reflection\n        value.ifPresent(v -> setValue(entity, field, v));\n    }\n    // Step 7: Return the reconstructed entity\n    return entity;\n}\n```", "```java\n    Objects.requireNonNull(map, \"map is required\");\n    ```", "```java\n    T entity = getEntity(map.get(ENTITY_ENTRY).toString());\n    ```", "```java\n    Class<?> type = entity.getClass();\n    ```", "```java\n    for (Field field : type.getDeclaredFields()) {\n    ```", "```java\n    String key = Optional.ofNullable(field.getAnnotation(Column.class))        .map(Column::value)        .filter(Predicate.not(String::isBlank))        .orElse(field.getName());\n    ```", "```java\n    Optional<Object> value = Optional.ofNullable(map.get(key));value.ifPresent(v -> setValue(entity, field, v));\n    ```", "```java\n    return entity;\n    ```", "```java\n@Overridepublic <T> Map<String, Object> toMap(T entity) {\n    Objects.requireNonNull(entity, \"entity is required\");\n    // Step 1: Initialize the map to store key-value pairs\n    Map<String, Object> map = new HashMap<>();\n    // Step 2: Retrieve the class type of the entity\n    Class<?> type = entity.getClass();\n    map.put(ENTITY_ENTRY, type.getName());\n    // Step 3: Iterate over the declared fields of the class\n    for (Field field : type.getDeclaredFields()) {\n        // Step 4: Set accessibility to true to allow access to \n        // private fields \n        field.setAccessible(true);\n        // Step 5: Check for the presence of the @Column annotation\n        Optional<Column> column = Optional.ofNullable(field.\n          getAnnotation(Column.class));\n        if (column.isPresent()) {\n            // Step 6: Determine the key associated with the field \n            // using @Column annotation\n            String key = column.map(Column::value)\n                    .filter(Predicate.not(String::isBlank))\n                    .orElse(field.getName());\n            // Step 7: Retrieve the field value using reflection and \n            // add it to the map \n            Object value = getValue(entity, field);\n            map.put(key, value);\n        }\n    }\n    // Step 8: Process @Append annotations at the class level and add \n    // default values to the map \n    Append[] appends = type.getAnnotationsByType(Append.class);\n    for (Append append : appends) {\n        map.put(append.key(), append.value());\n    }\n    // Step 9: Return the resulting map\n    return map;\n}\n```", "```java\n    Objects.requireNonNull(entity, \"entity is required\");\n    ```", "```java\n    Map<String, Object> map = new HashMap<>();\n    ```", "```java\n    Class<?> type = entity.getClass();map.put(ENTITY_ENTRY, type.getName());\n    ```", "```java\n    for (Field field : type.getDeclaredFields()) {\n    ```", "```java\n    field.setAccessible(true);\n    ```", "```java\n    Optional<Column> column = Optional.ofNullable(field.getAnnotation(Column.class));if (column.isPresent()) {\n    ```", "```java\n    String key = column.map(Column::value)        .filter(Predicate.not(String::isBlank))        .orElse(field.getName());\n    ```", "```java\n    Object value = getValue(entity, field);map.put(key, value);\n    ```", "```java\n    Append[] appends = type.getAnnotationsByType(Append.class);for (Append append : appends) {    map.put(append.key(), append.value());}\n    ```", "```java\n    return map;\n    ```", "```java\n@Entitypublic class Pet {\n    @Column\n    private String name;\n    @Column\n    private int age;\n    // Constructors, getters, and setters...\n}\n```", "```java\n@Entity@Append(key = \"type\", value = \"Fruit\")\n@Append(key = \"category\", value = \"Natural\")\npublic class Fruit {\n    @Column\n    private String name;\n    public Fruit(String name) {\n        this.name = name;\n    }\n    @Deprecated\n    public Fruit() {\n    }\n    public String name() {\n        return name;\n    }\n    // Additional methods...\n}\n```", "```java\nclass MapperTest {    private Mapper mapper;\n    @BeforeEach\n    public void setUp() {\n        this.mapper = new ReflectionMapper();\n    }\n    @Test\n    public void shouldConvertToMap() {\n        // Test for converting Pet entity to map\n        Pet ada = Pet.of(\"Ada\", 8);\n        Map<String, Object> map = mapper.toMap(ada);\n        assertThat(map)\n                .isNotNull()\n                .isNotEmpty()\n                .containsKeys(\"_entity\", \"name\", \"age\")\n                .containsEntry(\"name\", \"Ada\")\n                .containsEntry(\"age\", 8)\n                .containsEntry(\"_entity\", Pet.class.getName());\n    }\n    @Test\n    public void shouldConvertEntity() {\n        // Test for converting map to Pet entity\n        Map<String, Object> map = Map.of(\"_entity\", Pet.class.\n          getName() , \"name\", \"Ada\", \"age\", 8);\n        Pet pet = mapper.toEntity(map);\n        assertThat(pet).isNotNull()\n                .isInstanceOf(Pet.class)\n                .matches(p -> p.name().equals(\"Ada\"))\n                .matches(p -> p.age() == 8);\n    }\n    @Test\n    public void shouldConvertEntityRepeatable() {\n        // Test for converting Fruit entity with repeatable \n        // annotations to map \n        Fruit fruit = new Fruit(\"Banana\");\n        Map<String, Object> map = this.mapper.toMap(fruit);\n        assertThat(map).isNotNull().isNotEmpty()\n                .containsEntry(\"type\", \"Fruit\")\n                .containsEntry(\"category\", \"Natural\")\n                .containsEntry(\"name\", \"Banana\")\n                .containsEntry(\"_entity\", Fruit.class.getName());\n    }\n}\n```", "```java\npublic interface MapperRepository {    <T> T entity(Map<String, Object> map);\n    <T> Map<String, Object> map(T entity);\n}\n```", "```java\npublic class MapperInvocationHandler implements InvocationHandler {    private Mapper mapper = new ReflectionMapper();\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] params) \n      throws Throwable {\n        String name = method.getName();\n        switch (name) {\n            case \"entity\":\n                Map<String, Object> map = (Map<String, Object>) \n                  params[0];\n                Objects.requireNonNull(map, \"map is required\");\n                return mapper.toEntity(map);\n            case \"map\":\n                Object entity = params[0];\n                Objects.requireNonNull(entity, \"entity is required\");\n                return mapper.toMap(entity);\n        }\n        if(method.isDefault()) {\n            return InvocationHandler.invokeDefault(proxy, method, \n              params);\n        }\n        throw new UnsupportedOperationException(\"The proxy is not \n          supported for the method: \" + method);\n    }\n}\n```"]