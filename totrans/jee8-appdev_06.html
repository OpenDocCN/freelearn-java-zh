<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">JSON Processing with JSON-P and JSON-B</h1>
                </header>
            
            <article>
                
<p><strong>JSON</strong>, or the <strong>JavaScript Object Notation</strong>, is a human-readable data interchange format. As its name implies, JSON is derived from JavaScript. Java EE 7 introduced <strong>JSON-P</strong>, the Java API for JSON processing. Java EE 8 introduced an additional JSON API, namely, the Java API for <strong>JSON Binding</strong> (<strong>JSON-B</strong>). In this chapter, we will cover both JSON-P and JSON-B.</p>
<p>JSON-P includes two APIs for processing JSON, the <strong>Model API</strong> and the <strong>Streaming API</strong>, both of which will be covered in this chapter. JSON-B transparently populates Java objects from JSON strings, as well as easily generating JSON strings from Java objects.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The JSON-P Model API:
<ul>
<li>Generating JSON data with the Model API</li>
<li>Parsing JSON data with the Model API</li>
</ul>
</li>
<li>The JSON-P Streaming API:
<ul>
<li>Generating JSON data with the Streaming API</li>
<li>Parsing JSON data with the Streaming API</li>
</ul>
</li>
<li>Populating Java objects from JSON with JSON-B</li>
<li>Generating JSON strings from Java objects with JSON-B</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JSON-P Model API</h1>
                </header>
            
            <article>
                
<p>The JSON-P Model API allows us to generate an in-memory representation of a JSON object. This API is more flexible than the Streaming API discussed later in this chapter, however, it is slower and requires more memory, which can be a concern when handling large volumes of data.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating JSON data with the Model API</h1>
                </header>
            
            <article>
                
<p>At the heart of the JSON-P Model API is the <kbd>JsonObjectBuilder</kbd> class. This class has several overloaded <kbd>add()</kbd> methods, which can be used to add properties and their corresponding values to generated JSON data.</p>
<p>The following code sample illustrates how to generate JSON data using the Model API:</p>
<pre>    package net.ensode.javaee8book.jsonpobject; 
 
    //other imports omitted for brevity. 
    import javax.inject.Named; 
    import javax.json.Json; 
    import javax.json.JsonObject; 
    import javax.json.JsonReader; 
    import javax.json.JsonWriter; 
 
    @Named 
    @SessionScoped 
    public class JsonpBean implements Serializable{ 
 
      private String jsonStr; 
 
      @Inject 
      private Customer customer; 
 
      public String buildJson() { 
       <strong> JsonObjectBuilder jsonObjectBuilder =  
            Json.createObjectBuilder(); 
        JsonObject jsonObject = jsonObjectBuilder. 
            add("firstName", "Scott"). 
            add("lastName", "Gosling"). 
            add("email", "sgosling@example.com"). 
            build(); 
 
        StringWriter stringWriter = new StringWriter(); 
 
        try (JsonWriter jsonWriter = Json.createWriter(stringWriter)) 
         { 
           jsonWriter.writeObject(jsonObject); 
         }    
 
        setJsonStr(stringWriter.toString());</strong> 
 
        return "display_json"; 
 
     } 
    //getters and setters omitted for brevity 
    }  </pre>
<p>As can be seen in the preceding example, we generate an instance of <kbd>JsonObject</kbd> by invoking the <kbd>add()</kbd> method on an instance of <kbd>JsonObjectBuilder</kbd>. In the preceding example, we see how we can add <kbd>String</kbd> values to our <kbd>JsonObject</kbd> by invoking the <kbd>add()</kbd> method on <kbd>JsonObjectBuilder</kbd>. The first parameter of the <kbd>add()</kbd> method is the property name of the generated JSON object, and the second parameter corresponds to the value of said property. The return value of the <kbd>add()</kbd> method is another instance of <kbd>JsonObjectBuilder</kbd>, therefore, invocations to the <kbd>add()</kbd> method can be chained, as shown in the preceding example.</p>
<div class="packt_infobox">The preceding example is a CDI-named bean corresponding to a larger JSF application. Other parts of the application are not shown because they are not relevant to the discussion. The complete sample application can be obtained as part of this book's example code download.</div>
<p>Once we have added all the desired properties, we need to invoke the <kbd>build()</kbd> method of <kbd>JsonObjectBuilder</kbd>, which returns an instance of a class implementing the <kbd>JsonObject</kbd> interface.</p>
<p>In many cases, we will want to generate a <kbd>String</kbd> representation of the JSON object we created so that it can be processed by another process or service. We can do this by creating an instance of a class implementing the <kbd>JsonWriter</kbd> interface by invoking the static <kbd>createWriter()</kbd> method of the <kbd>Json</kbd> class and passing an instance of <kbd>StringWriter</kbd> as its sole parameter. Once we have an instance of the <kbd>JsonWriter</kbd> implementation, we need to invoke its <kbd>writeObject()</kbd> method, passing our <kbd>JsonObject</kbd> instance as its sole parameter.</p>
<p>At this point, our <kbd>StringWriter</kbd> instance will have the <kbd>String</kbd> representation of our JSON object as its value, so invoking its <kbd>toString()</kbd> method will return a <kbd>String</kbd> containing our JSON object.</p>
<p>Our specific example will generate a JSON string that looks like this:</p>
<pre>    {"firstName":"Scott","lastName":"Gosling","email":"<br/>    sgosling@example.com "}</pre>
<p><span class="NormalPACKTChar">Although, in our example, we added only</span> <kbd>String</kbd> <span class="NormalPACKTChar">objects to our JSON object, we are not limited to this type of value;</span> <kbd>JsonObjectBuilder</kbd> <span class="NormalPACKTChar">has several overloaded versions of its</span> <kbd>add()</kbd> <span class="NormalPACKTChar">method, allowing us to add several different types of values to our JSON objects.</span></p>
<p><span class="NormalPACKTChar">The following table summarizes all of the available versions of the</span> <kbd>add()</kbd> <span class="NormalPACKTChar">method:</span></p>
<table class="table">
<tbody>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>BigDecimal</kbd> value)</p>
</td>
<td>
<p>Adds a <kbd>BigDecimal</kbd> value to our JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>BigInteger</kbd> value)</p>
</td>
<td>
<p>Adds a <kbd>BigInteger</kbd> value to our JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>JsonArrayBuilder</kbd> value)</p>
</td>
<td>
<p>Adds an array to our JSON object. A <kbd>JsonArrayBuilder</kbd> implementation allows us to create JSON arrays.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>JsonObjectBuilder</kbd> value)</p>
</td>
<td>
<p>Adds another JSON object to our original JSON object (property values for JSON objects can be other JSON objects). The added <kbd>JsonObject</kbd> implementation is built from the provided <kbd>JsonObjectBuilder</kbd> parameter.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>JsonValue</kbd> value)</p>
</td>
<td>
<p>Adds another JSON object to our original JSON object (property values for JSON objects can be other JSON objects).</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>String</kbd> value)</p>
</td>
<td>
<p>Adds a <kbd>String</kbd> value to our JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>boolean</kbd> value)</p>
</td>
<td>
<p>Adds a <kbd>boolean</kbd> value to our JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>double</kbd> value)</p>
</td>
<td>
<p>Adds a <kbd>double</kbd> value to our JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>int</kbd> value)</p>
</td>
<td>
<p>Adds an <kbd>int</kbd> value to our JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd>(<kbd>String</kbd> name, <kbd>long</kbd> value)</p>
</td>
<td>
<p>Adds a <kbd>long</kbd> value to our JSON object.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span class="NormalPACKTChar">In all cases, the first parameter of the</span> <kbd>add()</kbd> <span class="NormalPACKTChar">method corresponds to the name of the property in our JSON object, and the second parameter corresponds to the value of the property.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing JSON data with the Model API</h1>
                </header>
            
            <article>
                
<p>In the last section, we saw how to generate JSON data from our Java code with the object model API. In this section, we will see how we can read and parse existing JSON data. The following code sample illustrates how to do this:</p>
<pre>    package net.ensode.javaee8book.jsonpobject; 
 
    //other imports omitted 
    import javax.json.Json; 
    import javax.json.JsonObject; 
    import javax.json.JsonReader; 
    import javax.json.JsonWriter; 
 
    @Named 
    @SessionScoped 
    public class JsonpBean implements Serializable{ 
 
      private String jsonStr; 
 
      @Inject 
      private Customer customer; 
 
 
      public String parseJson() { 
       <strong> JsonObject jsonObject; 
        try (JsonReader jsonReader = Json.createReader( 
             new StringReader(jsonStr))) { 
               jsonObject = jsonReader.readObject(); 
             } 
         
        customer.setFirstName( 
          jsonObject.getString("firstName")); 
        customer.setLastName( 
          jsonObject.getString("lastName")); 
        customer.setEmail(jsonObject.getString("email"));</strong> 
         
        return "display_parsed_json"; 
      } 
 
      //getters and setters omitted 
 
    } </pre>
<p>To parse an existing JSON string, we need to create a <kbd>StringReader</kbd> object, passing the <kbd>String</kbd> object containing the JSON to be parsed as a parameter. We then pass the resulting <kbd>StringReader</kbd> instance to the static <kbd>createReader()</kbd> method of the <kbd>Json</kbd> class. This method invocation will return an instance of <kbd>JsonReader</kbd>. We can then obtain an instance of <kbd>JsonObject</kbd> by invoking the <kbd>readObject()</kbd> method on it.</p>
<p>In the preceding example, we used the <kbd>getString()</kbd> method to obtain the values of all properties in our JSON object. The first and only argument for this method is the name of the property we wish to retrieve. Unsurprisingly, the return value is the value of the property.</p>
<p>In addition to the <kbd>getString()</kbd> method, there are several other similar methods to obtain values of other types. The following table summarizes these methods:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><kbd>get</kbd>(<kbd>Object</kbd> key)</p>
</td>
<td>
<p>Retrieves an instance of a class implementing the <kbd>JsonValue</kbd> interface.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getBoolean</kbd>(<kbd>String</kbd> name)</p>
</td>
<td>
<p>Retrieves a <kbd>boolean</kbd> value corresponding to the given key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getInt</kbd>(<kbd>String</kbd> name)</p>
</td>
<td>
<p>Retrieves a <kbd>int</kbd> value corresponding to the given key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getJsonArray</kbd>(<kbd>String</kbd> name)</p>
</td>
<td>
<p>Retrieves the instance of a class implementing the <kbd>JsonArray</kbd> interface corresponding to the given key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getJsonNumber</kbd>(<kbd>String</kbd> name)</p>
</td>
<td>
<p>Retrieves the instance of a class implementing the <kbd>JsonNumber</kbd> interface corresponding to the given key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getJsonObject</kbd>(<kbd>String</kbd> name)</p>
</td>
<td>
<p>Retrieves the instance of a class implementing the <kbd>JsonObject</kbd> interface corresponding to the given key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getJsonString</kbd>(<kbd>String</kbd> name)</p>
</td>
<td>
<p>Retrieves the instance of a class implementing the <kbd>JsonString</kbd> interface corresponding to the given key.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getString</kbd>(<kbd>String</kbd> name)</p>
</td>
<td>
<p>Retrieves a <kbd>String</kbd> corresponding to the given key.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>In all cases, the <kbd>String</kbd> parameter of the method corresponds to the key name, and the return value is the JSON property value we wish to retrieve.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The JSON-P Streaming API</h1>
                </header>
            
            <article>
                
<p>The JSON-P Streaming API allows sequential reading of a JSON object from a stream (a subclass of <kbd>java.io.OutputStream</kbd> or a subclass of <kbd>java.io.Writer</kbd>). It is faster and more memory efficient than the Model API, however, the trade-off is that it is more limited, since the JSON data needs to be read sequentially and we cannot access specific JSON properties directly the way the Model API allows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating JSON data with the Streaming API</h1>
                </header>
            
            <article>
                
<p>The JSON Streaming API has a <kbd>JsonGenerator</kbd> class that we can use to generate JSON data and write it to a stream. This class has several overloaded <kbd>write()</kbd> methods, which can be used to add properties and their corresponding values to the generated JSON data.</p>
<p>The following code sample illustrates how to generate JSON data using the Streaming API:</p>
<pre>    package net.ensode.javaee8book.jsonpstreaming; 
 
    //other imports omitted 
    import javax.json.Json; 
    import javax.json.stream.JsonGenerator; 
    import javax.json.stream.JsonParser; 
    import javax.json.stream.JsonParser.Event; 
 
    @Named 
    @SessionScoped 
    public class JsonpBean implements Serializable { 
 
      private String jsonStr; 
 
      @Inject 
      private Customer customer; 
 
      public String buildJson() { 
        StringWriter stringWriter = new StringWriter(); 
        <strong>try (JsonGenerator jsonGenerator = 
          Json.createGenerator(stringWriter)) { 
           jsonGenerator.writeStartObject(). 
             write("firstName", "Larry"). 
             write("lastName", "Gates"). 
             write("email", "lgates@example.com"). 
             writeEnd(); 
         } 
     
         setJsonStr(stringWriter.toString());</strong> 
         return "display_json"; 
     } 
 
     //getters and setters omitted 
    } </pre>
<p>We create an instance of <kbd>JsonGenerator</kbd> by invoking the <kbd>createGenerator()</kbd> static method of the <kbd>Json</kbd> class. The JSON-P API provides two overloaded versions of this method: one takes an instance of a class that extends <kbd>java.io.Writer</kbd> (such as <kbd>StringWriter</kbd>, which we used in our example), and the other one takes an instance of a class that extends <kbd>java.io.OutputStream</kbd>.</p>
<p>Before we can start adding properties to the generated JSON stream, we need to invoke the <kbd>writeStartObject()</kbd> method on <kbd>JsonGenerator</kbd>. This method writes the JSON start object character (represented by an opening curly brace ("<kbd>{</kbd>") in JSON strings), and returns another instance of <kbd>JsonGenerator</kbd>, allowing us to chain write() invocations to add properties to our JSON stream.</p>
<p>The <kbd>write()</kbd> method on <kbd>JsonGenerator</kbd> allows us to add properties to the JSON stream we are generating. Its first parameter is a <kbd>String</kbd> corresponding to the name of the property we are adding, and the second parameter is the value of the property.</p>
<p>In our example, we are adding only <kbd>String</kbd> values to the JSON stream we are creating, however, we are not limited to Strings; the JSON-P Streaming API provides several overloaded <kbd>write()</kbd> methods that allow us to add several different types of data to our JSON stream. The following table summarizes all of the available versions of the <kbd>write()</kbd> method:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><kbd>write(String name, BigDecimal value)</kbd></p>
</td>
<td>
<p>Writes a <kbd>BigDecimal</kbd> value to our JSON stream.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>write(String name, BigInteger value)</kbd></p>
</td>
<td>
<p>Writes a <kbd>BigInteger</kbd> value to our JSON stream</p>
</td>
</tr>
<tr>
<td>
<p><kbd>write(String name, JsonValue value)</kbd></p>
</td>
<td>
<p>Writes a JSON object to our JSON stream (property values for JSON streams can be other JSON objects)</p>
</td>
</tr>
<tr>
<td>
<p><kbd>write(String name, String value)</kbd></p>
</td>
<td>
<p>Writes a <kbd>String</kbd> value to our JSON stream</p>
</td>
</tr>
<tr>
<td>
<p><kbd>write(String name, boolean value)</kbd></p>
</td>
<td>
<p>Writes a <kbd>boolean</kbd> value to our JSON stream</p>
</td>
</tr>
<tr>
<td>
<p><kbd>write(String name, double value)</kbd></p>
</td>
<td>
<p>Writes a <kbd>double</kbd> value to our JSON<br/>
stream</p>
</td>
</tr>
<tr>
<td>
<p><kbd>write(String name, int value)</kbd></p>
</td>
<td>
<p>Writes an <kbd>int</kbd> value to our JSON stream</p>
</td>
</tr>
<tr>
<td>
<p><kbd>write(String name, long value)</kbd></p>
</td>
<td>
<p>Writes a <kbd>long</kbd> value to our JSON stream</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><span class="NormalPACKTChar">In all cases, the first parameter of the</span> <kbd>write()</kbd> <span class="NormalPACKTChar">method corresponds to the name of the property we are adding to our JSON stream, and the second parameter corresponds to the value of the property.</span></p>
<p><span class="NormalPACKTChar">Once we are done adding properties to our JSON stream, we need to invoke the</span> <kbd>writeEnd()</kbd> <span class="NormalPACKTChar">method on</span> <kbd>JsonGenerator</kbd>. <span class="NormalPACKTChar">This method adds the JSON end object character (represented by a closing curly brace (<kbd>}</kbd>) in JSON strings).</span></p>
<p><span class="NormalPACKTChar">At this point, our stream or reader is populated with the JSON data we generated. What we do with it depends on our application logic. In our example, we simply invoked the</span> <kbd>toString()</kbd> <span class="NormalPACKTChar">method of our</span> <kbd>StringReader</kbd> <span class="NormalPACKTChar">to obtain the <kbd>String</kbd> representation of the JSON data we created.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Parsing JSON data with the Streaming API</h1>
                </header>
            
            <article>
                
<p>In this section, we will cover how to parse the JSON data we receive from a stream. Please refer to the following code:</p>
<pre>    package net.ensode.javaee8book.jsonpstreaming; 
 
    //other imports omitted 
    import javax.json.Json; 
    import javax.json.stream.JsonGenerator; 
    import javax.json.stream.JsonParser; 
    import javax.json.stream.JsonParser.Event; 
 
    @Named 
    @SessionScoped 
    public class JsonpBean implements Serializable { 
 
      private String jsonStr; 
 
      @Inject 
      private Customer customer; 
 
      public String parseJson() { 
 
        StringReader stringReader = new StringReader(jsonStr); 
 
       <strong> JsonParser jsonParser = Json.createParser(stringReader);</strong> 
 
        Map&lt;String, String&gt; keyValueMap = new HashMap&lt;&gt;(); 
        String key = null; 
        String value = null; 
 
       <strong> while (jsonParser.hasNext()) { 
            JsonParser.Event event = jsonParser.next(); 
 
            if (event.equals(Event.KEY_NAME)) { 
                key = jsonParser.getString(); 
            } else if (event.equals(Event.VALUE_STRING)) { 
                value = jsonParser.getString(); 
            } 
 
            keyValueMap.put(key, value); 
        }</strong> 
 
        customer.setFirstName(keyValueMap.get("firstName")); 
        customer.setLastName(keyValueMap.get("lastName")); 
        customer.setEmail(keyValueMap.get("email")); 
 
        return "display_parsed_json"; 
      } 
 
      //getters and setters omitted 
 
    } </pre>
<p>The first thing we need to do to read JSON data using the Streaming API is to create an instance of <kbd>JsonParser</kbd> by invoking the static <kbd>createJsonParser()</kbd> method on the <kbd>Json</kbd> class. There are two overloaded versions of the <kbd>createJsonParser()</kbd> method: one takes an instance of a class that extends <kbd>java.io.InputStream</kbd>, the other one takes an instance of a class that extends <kbd>java.io.Reader</kbd>. In our example, we use the latter, passing an instance of <kbd>java.io.StringReader</kbd>, which is a subclass of <kbd>java.io.Reader</kbd>.</p>
<p>The next step is to loop through the JSON data to obtain the data to be parsed. We can achieve this by invoking the <kbd>hasNext()</kbd> method on <kbd>JsonParser</kbd>, which returns true if there is more data to be read, and false otherwise.</p>
<p>We then need to read the next piece of data in our stream. The <kbd>JsonParser.next()</kbd> method returns an instance of <kbd>JsonParser.Event</kbd>, which indicates the type of data that we just read. In our example, we check only for key names (that is, <kbd>firstName</kbd>, <kbd>lastName</kbd>, and <kbd>email</kbd>), and the corresponding string values. We check for the type of data we just read by comparing the event returned by <kbd>JsonParser.next()</kbd> against several values defined in the <kbd>Event</kbd> enum defined in <kbd>JsonParser</kbd>.</p>
<p>The following table summarizes all of the possible events that can be returned from <kbd>JsonParser.next()</kbd>:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><kbd>Event.START_OBJECT</kbd></p>
</td>
<td>
<p>Indicates the start of a JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.END_OBJECT</kbd></p>
</td>
<td>
<p>Indicates the end of a JSON object.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.START_ARRAY</kbd></p>
</td>
<td>
<p>Indicates the start of an array.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.END_ARRAY</kbd></p>
</td>
<td>
<p>Indicates the end of an array.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.KEY_NAME</kbd></p>
</td>
<td>
<p>Indicates the name of a JSON property was read; we can obtain the key name by invoking <kbd>getString()</kbd> on <kbd>JsonParser</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.VALUE_TRUE</kbd></p>
</td>
<td>
<p>Indicates that a Boolean value of <kbd>true</kbd> was read.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.VALUE_FALSE</kbd></p>
</td>
<td>
<p>Indicates that a Boolean value of <kbd>false</kbd> was read.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.VALUE_NULL</kbd></p>
</td>
<td>
<p>Indicates that a <kbd>null</kbd> value was read.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.VALUE_NUMBER</kbd></p>
</td>
<td>
<p>Indicates that a <kbd>numeric</kbd> value was read.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>Event.VALUE_STRING</kbd></p>
</td>
<td>
<p>Indicates that a <kbd>string</kbd> value was read.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>As shown in the example, <kbd>String</kbd> values can be retrieved by invoking <kbd>getString()</kbd> on <kbd>JsonParser</kbd>. Numeric values can be retrieved in several different formats; the following table summarizes the methods in <kbd>JsonParser</kbd> that can be used to retrieve numeric values:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><kbd>getInt()</kbd></p>
</td>
<td>
<p>Retrieves the numeric value as an <kbd>int</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getLong()</kbd></p>
</td>
<td>
<p>Retrieves the numeric value as a <kbd>long</kbd>.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>getBigDecimal()</kbd></p>
</td>
<td>
<p>Retrieves the numeric value as an instance of <kbd>java.math.BigDecimal</kbd>.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p><kbd>JsonParser</kbd> also provides a convenience <kbd>isIntegralNumber()</kbd> method, which returns <kbd>true</kbd> if the numeric value can be safely cast to an <kbd>int</kbd> or a <kbd>long</kbd>.</p>
<p>What we do with the values we obtain from the stream depends on our application logic. In our example, we place them on a <kbd>Map</kbd>, then use said <kbd>Map</kbd> to populate a Java class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON pointer</h1>
                </header>
            
            <article>
                
<p>JSON-P 1.1, introduced in Java EE 8, introduces support for JSON Pointer. JSON Pointer is an <strong>Internet Engineering Task Force</strong> (<strong>IETF</strong>) standard that defines a string syntax to identify a specific value within a JSON document, similar to what XPath provides for XML documents.</p>
<p>The syntax for JSON Pointer is straightforward, for example, suppose we have the following JSON document:</p>
<pre style="padding-left: 60px"> { <br/>  "dateOfBirth": "1997-03-03",<br/>  "firstName": "David",<br/>  "lastName": "Heffelfinger",<br/>  "middleName": "Raymond",<br/>  "salutation": "Mr" <br/> }</pre>
<p>If we would like to obtain the value of the <kbd>lastName</kbd> property of the document, the JSON Pointer expression to use would be <kbd>"/lastName"</kbd>.</p>
<p>If our JSON document consisted of an array, then we would have to prefix the property with the index in the array, for example, to obtain the <kbd>lastName</kbd> property of the second element in the following JSON array:</p>
<pre>    [  
     {  
       "dateOfBirth": "1997-01-01", 
       "firstName": "David", 
       "lastName": "Delabassee", 
       "salutation": "Mr"  
      }, 
     {  
       "dateOfBirth": "1997-03-03", 
       "firstName": "David", 
       "lastName": "Heffelfinger", 
       "middleName": "Raymond", 
       "salutation": "Mr" 
     } 
    ] </pre>
<p>The JSON Pointer expression to do so would be <kbd>"/1/lastName"</kbd>. The <kbd>"/1"</kbd> at the beginning of the expression refers to the element index in the array. Just as in Java, JSON arrays are <kbd>0</kbd> indexed, therefore, in this example, we are obtaining the value of the <kbd>lastName</kbd> property in the second element of the array. Let's now look at an example of how we would use the new JSON-P JSON Pointer API to perform this task:</p>
<pre>    package net.ensode.javaee8book.jsonpointer; 
    //imports omitted 
 
    @Path("jsonpointer") 
    public class JsonPointerDemoService { 
 
      private String jsonString; //initialization omitted 
 
      @GET 
      public String jsonPointerDemo() { 
        initializeJsonString(); //method body omitted for brevity 
       <strong> JsonReader jsonReader = Json.createReader</strong><br/><strong>            (new StringReader(jsonString)); 
        JsonArray jsonArray = jsonReader.readArray(); 
        JsonPointer jsonPointer = Json.createPointer("/1/lastName"); 
         
        return jsonPointer.getValue(jsonArray).toString();</strong> 
      } 
    } </pre>
<p>The preceding code sample is a RESTful web service written using Java EE's JAX-RS API (see <a href="4987ac18-1f2a-410c-9613-530174a64bad.xhtml" target="_blank">Chapter 10</a>, <em>RESTful Web Services with JAX-RS</em> for details). In order to read property values from a JSON document, we first need to create an instance of <kbd>javax.json.JsonReader</kbd> by invoking the static <kbd>createReader()</kbd> method on <kbd>javax.json.Json</kbd>. The <kbd>createReader()</kbd> method takes an instance of any class implementing the <kbd>java.io.Reader</kbd> interface as an argument. In our example, we are creating a new instance of <kbd>java.io.StringReader</kbd> on the fly, and passing our JSON string as a parameter to its constructor.</p>
<div class="packt_infobox">There is an overloaded version of <kbd>JSON.createReader()</kbd> that takes an instance of any class implementing <kbd>java.io.InputStream</kbd>.</div>
<p>In our example, our JSON document consists of an array of objects, therefore, we populate an instance of <kbd>javax.json.JsonArray</kbd> by invoking the <kbd>readArray()</kbd> method on the <kbd>JsonReader</kbd> object we created (if our JSON document had consisted of a single JSON object, we would have invoked <kbd>JsonReader.readObject()</kbd> instead).</p>
<p>Now that we have populated our <kbd>JsonArray</kbd> variable, we create an instance of <kbd>javax.json.JsonPointer</kbd> and initialize it with the JSON Pointer expression we want to use to obtain the value we are searching for. Remember that we are looking for the value of the <kbd>lastName</kbd> property in the second element of the array, therefore, the appropriate JSON Pointer expression is <kbd>/1/lastName</kbd>.</p>
<p>Now that we have created an instance of <kbd>JsonPointer</kbd> with the appropriate JSON Pointer expression, we simply invoke its <kbd>getValue()</kbd> method, passing our <kbd>JsonArray</kbd> object as a parameter, then invoke <kbd>toString()</kbd> on the result. The return value of this invocation will be the value of the <kbd>lastName</kbd> property on the JSON document ("Heffelfinger", in our example).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JSON Patch</h1>
                </header>
            
            <article>
                
<p>JSON-P 1.1 also introduced support for JSON Patch, another <strong>Internet Engineering Task Force</strong> standard, this one providing a series of operations that can be applied to a JSON document. JSON Patch allows us to perform partial updates on a JSON object.</p>
<p>The following operations are supported by JSON Patch:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>JSON Patch Operation</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>add</kbd></p>
</td>
<td>
<p>Adds an element to a JSON document.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>remove</kbd></p>
</td>
<td>
<p>Removes an element from a JSON document.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>replace</kbd></p>
</td>
<td>
<p>Replaces a value in a JSON document with a new value.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>move</kbd></p>
</td>
<td>
<p>Moves a value in a JSON document from its current location in the document to a new position.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>copy</kbd></p>
</td>
<td>
<p>Copies a value in a JSON document to a new location in the document.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>test</kbd></p>
</td>
<td>
<p>Verifies that the value in a specific location in a JSON document is equal to the specified value.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>JSON-P supports all of the preceding JSON Patch operations, which rely on JSON Pointer expressions to locate the source and target locations in JSON documents.</p>
<p>The following example illustrates how we can use JSON Patch with JSON-P 1.1:</p>
<pre>    package net.ensode.javaee8book.jsonpatch; 
 
    //imports omitted for brevity 
 
    @Path("jsonpatch") 
    public class JsonPatchDemoService { 
 
      private String jsonString; 
 
      @GET 
      public Response jsonPatchDemo() { 
        initializeJsonString(); //method declaration omitted 
        JsonReader jsonReader = Json.createReader( 
            new StringReader(jsonString)); 
        JsonArray jsonArray = jsonReader.readArray(); 
        <strong>JsonPatch jsonPatch = Json.createPatchBuilder() 
                .replace("/1/dateOfBirth", "1977-01-01") 
                .build(); 
        JsonArray modifiedJsonArray =jsonPatch.apply(jsonArray);</strong> 
 
        return Response.ok(modifiedJsonArray.toString(), <br/>        MediaType.APPLICATION_JSON).build(); 
      } 
    } </pre>
<p>In this example, let's assume we are dealing with the same JSON document we used in our previous example: an array of two individual JSON objects, each with a <kbd>dateOfBirth</kbd> property (among other properties).</p>
<p>In our example, we create an instance of <kbd>JsonArray</kbd>, as before, then modify the <kbd>dateOfBirth</kbd> of the second element in the array. In order to do this, we create an instance of <kbd>javax.json.JsonPatchBuilder</kbd> via the static <kbd>createPatchBuilder()</kbd> method in the <kbd>javax.json.Json</kbd> class. In our example, we are replacing the value of one of the properties with a new value. We use the <kbd>replace()</kbd> method of our <kbd>JsonPatch</kbd> instance to accomplish this; the first argument in the method is a JSON Pointer expression indicating the location of the property we are going to modify, the second argument is the new value for the property. As its name implies <kbd>JsonPatchBuilder</kbd> follows the <kbd>Builder</kbd> design pattern, meaning that most of its methods return another instance of <kbd>JsonPatchBuilder</kbd>; this allows us to chain method calls on the resulting instances of <kbd>JsonPatchBuilder</kbd> (in our example, we are performing only one operation, but this doesn't have to be the case).</p>
<p>Once we are done specifying the operation(s) to perform on our JSON object, we create an instance of <kbd>javax.json.JsonPatch</kbd> by invoking the <kbd>build()</kbd> method on <kbd>JsonPatchBuilder</kbd>.</p>
<p>Once we have created the patch, we apply it to our JSON object (an instance of <kbd>JsonArray</kbd>, in our example), by invoking its <kbd>patch()</kbd> method, passing the JSON object as a parameter.</p>
<p>In our example of how to replace the value of a JSON property with another via JSON Patch support in JSON-P 1.1, JSON-P supports all operations currently supported by JSON Patch. The API is straightforward. For details on how to use other JSON Patch operations with JSON-P, consult the Java EE 8 API documentation at <a href="https://javaee.github.io/javaee-spec/javadocs/"><span class="URLPACKT">https://javaee.github.io/javaee-spec/javadocs/</span></a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Populating Java objects from JSON with JSON-B</h1>
                </header>
            
            <article>
                
<p>A common programming task is to populate Java objects from JSON strings. It is such a common tasks that several libraries have been created to transparently populate Java objects from JSON, freeing application developers from having to manually code this functionality. There are some non-standard Java libraries that accomplish this task, such as Jackson (<a href="https://github.com/FasterXML/jackson"><span class="URLPACKT">https://github.com/FasterXML/jackson</span></a>), JSON-simple (<a href="https://github.com/fangyidong/json-simple"><span class="URLPACKT">https://github.com/fangyidong/json-simple</span></a>), and Gson (<a href="https://github.com/google/gson"><span class="URLPACKT">https://github.com/google/gson</span></a>). Java EE 8 introduces a new API providing this functionality, namely the Java API for JSON Binding (JSON-B). In this section, we will cover how to transparently populate a Java object from a JSON string.</p>
<p>The following example shows a RESTful web service written using the Java API for RESTful Web Services (JAX-RS). The service responds to HTTP POST requests in its <kbd>addCustomer()</kbd> method. This method takes a <kbd>String</kbd> as a parameter and this string is expected to contain valid JSON. Please refer to the following code:</p>
<pre>    package net.ensode.javaee8book.jaxrs21example.service; 
 
    import net.ensode.javaee8book.jaxrs21example.dto.Customer; 
    import java.util.logging.Level; 
    import java.util.logging.Logger; 
    import javax.json.bind.Jsonb; 
    import javax.json.bind.JsonbBuilder; 
    import javax.ws.rs.POST; 
    import javax.ws.rs.Consumes; 
    import javax.ws.rs.Path; 
    import javax.ws.rs.core.MediaType; 
    import javax.ws.rs.core.Response; 
 
    @Path("/customercontroller") 
    public class CustomerControllerService { 
 
    private static final Logger LOG = <br/>    Logger.getLogger(CustomerControllerService.class.getName()); 
 
    @POST 
    @Consumes(MediaType.APPLICATION_JSON) 
    public Response addCustomer(String customerJson) { 
      Response response; 
      <strong>Jsonb jsonb = JsonbBuilder.create(); 
 </strong><br/><strong>      Customer customer = jsonb.fromJson(customerJson, 
          Customer.class);</strong> 
      LOG.log(Level.INFO, "Customer object populated from JSON"); 
      LOG.log(Level.INFO, String.format("%s %s %s %s %s", 
      customer.getSalutation(), 
      customer.getFirstName(), 
      customer.getMiddleName(), 
      customer.getLastName(), 
      customer.getDateOfBirth())); 
      response = Response.ok("{}").build(); 
      return response; 
     } 
 
    } </pre>
<p>The JSON-B implementation provided by our application server provides an instance of a class implementing the <kbd>JsonbBuilder</kbd> interface. This class provides a static <kbd>create()</kbd> method that we can use to obtain an instance of <kbd>Jsonb</kbd>.</p>
<p>Once we have an instance of <kbd>Jsonb</kbd>, we can use it to parse a JSON string and automatically populate a Java object. This is done via its <kbd>fromJson()</kbd> method. The <kbd>fromJson()</kbd> method takes a <kbd>String</kbd> containing the JSON data we need to parse as its first parameter, and the type of the object we wish to populate as its second parameter. In our example, we are populating a simple <kbd>Customer</kbd> class containing fields such as <kbd>firstName</kbd>, <kbd>middleName</kbd>, <kbd>lastName</kbd>, and <kbd>dateOfBirth</kbd>. JSON-B will look for JSON property names matching the property names in the Java object and automatically populate the Java object with the corresponding JSON properties. It couldn't be more simple than that.</p>
<p>Once we have populated our Java object, we can do whatever we need to do with it. In our example, we simply log the properties of the Java object to verify that it was populated correctly.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating JSON strings from Java objects with JSON-B</h1>
                </header>
            
            <article>
                
<p>In addition to populating Java objects from JSON data, JSON-B can also generate JSON strings from Java objects. The following example illustrates how to do this:</p>
<pre>    package net.ensode.javaee8book.jsonbjavatojson.service; 
 
    //imports omitted for brevity 
 
    @Path("/customersearchcontroller") 
    public class CustomerSearchControllerService { 
      private final List&lt;Customer&gt; customerList = new ArrayList&lt;&gt;(); 
 
      @GET 
      @Path("{firstName}") 
      public Response getCustomerByFirstName(@PathParam("firstName")   <br/>      String firstName) { 
        List&lt;Customer&gt; filteredCustomerList; 
        String jsonString; 
        initializeCustomerList(); //method declaration omitted 
 
        Jsonb jsonb = JsonbBuilder.create(); 
 
        filteredCustomerList = customerList.stream().filter( 
                customer -&gt; customer.getFirstName().equals(firstName)). 
                collect(Collectors.toList()); 
 
        <strong>jsonString = jsonb.toJson(filteredCustomerList);</strong> 
 
        return Response.ok(jsonString).build(); 
     } 
   } </pre>
<p>In this example, we are converting a <kbd>List</kbd> of <kbd>Customer</kbd> objects to JSON.</p>
<div class="packt_infobox">We chose a <kbd>List</kbd> for the example to illustrate that JSON-B supports this functionality, but of course, we could also convert a single object to its JSON representation.</div>
<p>Just as before, we create an instance of <kbd>javax.json.bind.Jsonb</kbd> by invoking the static <kbd>javax.json.bind.JsonbBuilder.create()</kbd> method. Once we have our <kbd>Jsonb</kbd> instance, we simply invoke its <kbd>toJson()</kbd> method to convert the list of objects to its equivalent JSON representation.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we covered the Java API for JSON Processing (JSON-P). We illustrated how to generate and parse JSON data via JSON-P's model and Streaming APIs. Additionally, we covered new JSON-P 1.1 features, such as support for JSON Pointer and JSON Patch. Finally, we covered how to seamlessly populate Java objects from JSON, and how to easily generate JSON strings from Java objects via the new JSON-B API.</p>


            </article>

            
        </section>
    </body></html>