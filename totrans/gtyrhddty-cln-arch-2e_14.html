<html><head></head><body>
<div id="_idContainer100">
<h1 class="hapter-number" id="_idParaDest-118"><a id="_idTextAnchor118"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-119"><a id="_idTextAnchor119"/><span class="koboSpan" id="kobo.2.1">A Component-Based Approach to Software Architecture</span></h1>
<p><span class="koboSpan" id="kobo.3.1">When we’re starting a software project, we never know all the requirements that the users will throw at us once they are actually using the software. </span><span class="koboSpan" id="kobo.3.2">A software project is always associated with taking chances and making educated guesses (we like to call them “assumptions” to make it sound more professional). </span><span class="koboSpan" id="kobo.3.3">The environment of a software project is just too volatile to know in advance how everything will play out. </span><span class="koboSpan" id="kobo.3.4">This volatility is why the Agile movement was born. </span><span class="koboSpan" id="kobo.3.5">Agile practices make organizations flexible enough to adapt </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">But how can we create a software architecture that can cope with such an agile environment? </span><span class="koboSpan" id="kobo.5.2">If everything can change at any time, should we even bother </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">with architecture?</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">Yes, we should. </span><span class="koboSpan" id="kobo.7.2">As discussed in </span><a href="B19916_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.8.1">Chapter 1</span></em></span></a><span class="koboSpan" id="kobo.9.1">, </span><em class="itali"><span class="koboSpan" id="kobo.10.1">Maintainability</span></em><span class="koboSpan" id="kobo.11.1">, we should make sure that our software architecture enables maintainability. </span><span class="koboSpan" id="kobo.11.2">A maintainable code base can evolve over time, adapting to </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">external factors.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">Hexagonal Architecture takes a big step toward maintainability. </span><span class="koboSpan" id="kobo.13.2">It’s creating a boundary between our application and the outside world. </span><span class="koboSpan" id="kobo.13.3">On the inside of our application (within the hexagon), we have our domain code, which provides dedicated ports to the outside world. </span><span class="koboSpan" id="kobo.13.4">These ports connect the application to adapters, which talk to the outside world, translating between the language of our application and the languages of outside systems. </span><span class="koboSpan" id="kobo.13.5">This architecture enhances maintainability because the application can mostly evolve independently of the outside world. </span><span class="koboSpan" id="kobo.13.6">As long as the ports don’t change, we can evolve anything within the application to react to changes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">agile environment.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">But, as we learned in </span><a href="B19916_13.xhtml#_idTextAnchor112"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.16.1">Chapter 13</span></em></span></a><span class="koboSpan" id="kobo.17.1">, </span><em class="itali"><span class="koboSpan" id="kobo.18.1">Managing Multiple Bounded Contexts</span></em><span class="koboSpan" id="kobo.19.1">, Hexagonal Architecture doesn’t help us to create boundaries within our application core. </span><span class="koboSpan" id="kobo.19.2">We might want to apply a different architecture within our application core that helps us in </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">this regard.</span></span></p>
<p><span class="koboSpan" id="kobo.21.1">Also, I’ve heard quite a few times that Hexagonal Architecture feels hard, especially for a software project just starting out. </span><span class="koboSpan" id="kobo.21.2">It’s hard to get the team on board because not everyone understands the value of dependency inversion and the mapping between the domain model and the outside world. </span><span class="koboSpan" id="kobo.21.3">Hexagonal Architecture might just be overkill for a </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">fledgling application.</span></span></p>
<p><span class="koboSpan" id="kobo.23.1">For cases like this, we might want to start out with a simpler architecture style that still provides the modularity we need to evolve into something else in the future but that’s simple enough to get everyone on board. </span><span class="koboSpan" id="kobo.23.2">I propose that a component-based architecture is a good starting point, and we’ll use this chapter to discuss this </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">architecture style.</span></span></p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor120"/><span class="koboSpan" id="kobo.25.1">Modularity through components</span></h1>
<p><span class="koboSpan" id="kobo.26.1">One of the drivers of maintainability is modularity. </span><span class="koboSpan" id="kobo.26.2">Modularity allows us to conquer the complexity of a software system by dividing it into simpler modules. </span><span class="koboSpan" id="kobo.26.3">We don’t have to understand the whole </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.27.1">system to be able to work on one specific module. </span><span class="koboSpan" id="kobo.27.2">Instead, we can focus on that one module and potentially the modules it interfaces with. </span><span class="koboSpan" id="kobo.27.3">Modules can evolve mostly independently of each other, as long as the interfaces between modules are clearly defined. </span><span class="koboSpan" id="kobo.27.4">We’re probably able to fit a mental model of one module into our working memory, but good luck with creating a mental model if there are no modules in the code base. </span><span class="koboSpan" id="kobo.27.5">We would jump around in the code </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">rather helplessly.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">Only modularity allows us humans to create complex systems. </span><span class="koboSpan" id="kobo.29.2">In his book </span><em class="itali"><span class="koboSpan" id="kobo.30.1">Modern Software Engineering</span></em><span class="koboSpan" id="kobo.31.1">, Dave Farley talks about the modularity of the Apollo </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">space program:</span></span><span class="No-Break"><span id="footnote-046-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-046"><span class="koboSpan" id="kobo.33.1">1</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-046">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-046-backlink"><span class="koboSpan" id="kobo.34.1">1</span></a><span class="koboSpan" id="kobo.35.1">	Modularity of the Apollo space program</span><em class="itali"><span class="koboSpan" id="kobo.36.1">: Modern Software Engineering</span></em><span class="koboSpan" id="kobo.37.1"> by Dave Farley, Pearson, 2022, </span><a href="B19916_06.xhtml#_idTextAnchor056"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.38.1">Chapter 6</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.39.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.40.1">“</span><em class="itali"><span class="koboSpan" id="kobo.41.1">This modularity had lots of advantages. </span><span class="koboSpan" id="kobo.41.2">It meant that each component could be built to focus on one part of the problem and would need to compromise less in its design. </span><span class="koboSpan" id="kobo.41.3">It allowed different groups – in this case, completely different companies – to work on each module largely independently of the others. </span><span class="koboSpan" id="kobo.41.4">As long as the different groups agreed on how the modules would interface with each other, they could work to solve the problems of their module </span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.42.1">without constraint</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">.”</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Modularity allowed us to go to the Moon! </span><span class="koboSpan" id="kobo.44.2">Modularity allows us to build cars, aircraft, and buildings. </span><span class="koboSpan" id="kobo.44.3">It should be no surprise that it also helps us build </span><span class="No-Break"><span class="koboSpan" id="kobo.45.1">complex software.</span></span></p>
<p><span class="koboSpan" id="kobo.46.1">But what is a module? </span><span class="koboSpan" id="kobo.46.2">I feel the term is overloaded in (object-oriented) software development. </span><span class="koboSpan" id="kobo.46.3">Everything and its cat is called a “module,” even if it’s just a bunch of classes that were haphazardly thrown together to do a useful thing. </span><span class="koboSpan" id="kobo.46.4">I prefer the term “component” to describe a group of classes that were thoughtfully engineered to implement certain functionality that can be composed together with other groups of classes to build a complex system. </span><span class="koboSpan" id="kobo.46.5">The composition aspect implies that components can be composed to form </span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.47.1">a bigger whole and potentially even re-composed to react to changes in the environment. </span><span class="koboSpan" id="kobo.47.2">Composability requires a component to define a clear interface that tells us what it provides to and needs from the outside world (input and output ports, anyone?). </span><span class="koboSpan" id="kobo.47.3">Think of LEGO bricks. </span><span class="koboSpan" id="kobo.47.4">A LEGO brick provides a certain layout of studs for other bricks to attach to, and it requires a certain layout of studs to attach to other bricks. </span><span class="koboSpan" id="kobo.47.5">All that said, I won’t judge you if you use the term “module,” but I’ll refer to “components” in the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">For the sake of this chapter, a component is a set of classes that has a dedicated namespace and a clearly </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.50.1">defined API. </span><span class="koboSpan" id="kobo.50.2">If another component needs this component’s functionality, it can call it via its API, but it may not reach into its internals. </span><span class="koboSpan" id="kobo.50.3">A component may be made up of smaller components. </span><span class="koboSpan" id="kobo.50.4">By default, these sub-components live inside the internals of the parent component, so that they are not accessible from the outside. </span><span class="koboSpan" id="kobo.50.5">They can, however, contribute to the parent component’s API if they implement functionality that should be accessible from </span><span class="No-Break"><span class="koboSpan" id="kobo.51.1">the outside.</span></span></p>
<p><span class="koboSpan" id="kobo.52.1">Like any other architecture style, component-based architecture is all about which dependencies </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.53.1">are allowed and which are discouraged. </span><span class="koboSpan" id="kobo.53.2">This is illustrated in </span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.54.1">Figure 14</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.55.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer097">
<span class="koboSpan" id="kobo.57.1"><img alt="Figure 14.1 – Dependencies on an internal package are invalid﻿ but dependencies on an API package are valid, provided that the API package is not nested in an internal package" src="image/Figure_14.1._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.58.1">Figure 14.1 – Dependencies on an internal package are invalid but dependencies on an API package are valid, provided that the API package is not nested in an internal package</span></p>
<p><span class="koboSpan" id="kobo.59.1">Here, we have two top-level components, A and B. </span><span class="koboSpan" id="kobo.59.2">Component A is made up of two sub-components, A1 and A2, while component B only has a single </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">sub-component, B1.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">If A1 needs access to B’s functionality, it can get it by calling B’s API. </span><span class="koboSpan" id="kobo.61.2">It cannot, however, access B1’s API, because, as a sub-component, it’s part of its parent’s internals and thus hidden from the outside. </span><span class="koboSpan" id="kobo.61.3">B1 can still contribute functionality to its parent’s API, though, by implementing an interface in the parent API. </span><span class="koboSpan" id="kobo.61.4">We will see this in action in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.62.1">study later.</span></span></p>
<p><span class="koboSpan" id="kobo.63.1">The same rules apply between the sibling components, A1 and A2. </span><span class="koboSpan" id="kobo.63.2">If A1 needs access to A2’s functionality, it can call its API, but it cannot call into </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">A2’s internals.</span></span></p>
<p><span class="koboSpan" id="kobo.65.1">And that’s all there is to component-based architecture. </span><span class="koboSpan" id="kobo.65.2">It can be summarized in four </span><span class="No-Break"><span class="koboSpan" id="kobo.66.1">simple rules:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.67.1">A component has </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.68.1">a dedicated namespace to </span><span class="No-Break"><span class="koboSpan" id="kobo.69.1">be addressable.</span></span></li>
<li><span class="koboSpan" id="kobo.70.1">A component has a dedicated API </span><span class="No-Break"><span class="koboSpan" id="kobo.71.1">and internals.</span></span></li>
<li><span class="koboSpan" id="kobo.72.1">A component’s API may be called from the outside, but its internals </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">may not.</span></span></li>
<li><span class="koboSpan" id="kobo.74.1">A component may </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.75.1">contain sub-components as part of </span><span class="No-Break"><span class="koboSpan" id="kobo.76.1">its internals.</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.77.1">To make the abstract concrete, let’s see a component-based architecture in </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">real code.</span></span></p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor121"/><span class="koboSpan" id="kobo.79.1"> Case study – building a “Check Engine” component</span></h1>
<p><span class="koboSpan" id="kobo.80.1">As a case study for the component-based architecture presented in this chapter, I extracted a component </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.81.1">from a real software project I worked on into a standalone GitHub repository.</span><span id="footnote-045-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-045"><span class="koboSpan" id="kobo.82.1">2</span></a></span><span class="supers ript"> </span><span class="koboSpan" id="kobo.83.1">The fact alone that I extracted the component with relatively little effort and that we can reason about this component without knowing anything about the software project it comes from shows that we have successfully conquered complexity by </span><span class="No-Break"><span class="koboSpan" id="kobo.84.1">applying modularity!</span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-045">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-045-backlink"><span class="koboSpan" id="kobo.85.1">2</span></a><span class="koboSpan" id="kobo.86.1">	The GitHub project with the “check engine” implemented in component-based architecture: </span><a href="https://github.com/thombergs/components-example"><span class="No-Break"><span class="koboSpan" id="kobo.87.1">https://github.com/thombergs/components-example</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.88.1">.</span></span></p>
</div>
<p><span class="koboSpan" id="kobo.89.1">The component is written in object-oriented Kotlin, but the concepts apply to any other </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">object-oriented language.</span></span></p>
<p><span class="koboSpan" id="kobo.91.1">The component is called “check engine.” </span><span class="koboSpan" id="kobo.91.2">It was meant to be a kind of web scraper that goes through web pages and runs a set of checks against them. </span><span class="koboSpan" id="kobo.91.3">These checks can be anything from “check that the HTML on that web page is valid” to “return all spelling errors on that </span><span class="No-Break"><span class="koboSpan" id="kobo.92.1">web page.”</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Since a lot can go wrong when scraping web pages, we decided to run the checks asynchronously. </span><span class="koboSpan" id="kobo.93.2">That means that the component needs to provide an API to schedule checks and an API to retrieve the results of a check after it has been executed. </span><span class="koboSpan" id="kobo.93.3">This implies a queue in which to store incoming check requests and a database in which to store the results of </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">these checks.</span></span></p>
<p><span class="koboSpan" id="kobo.95.1">From the outside, it doesn’t matter whether we build the check engine “in one piece” or split it up into sub-components. </span><span class="koboSpan" id="kobo.95.2">As long as the component has a dedicated API, these details are hidden from the outside. </span><span class="koboSpan" id="kobo.95.3">The requirements above, however, outline certain natural boundaries for sub-components within the check engine. </span><span class="koboSpan" id="kobo.95.4">Breaking the check engine up along these boundaries allows us to manage complexity within the check engine component because each sub-component will be simpler to manage than the </span><span class="No-Break"><span class="koboSpan" id="kobo.96.1">whole problem.</span></span></p>
<p><span class="koboSpan" id="kobo.97.1">We came up with three sub-components for the </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">check engine:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.99.1">A queue component that </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.100.1">wraps the access to a queue to queue and dequeue </span><span class="No-Break"><span class="koboSpan" id="kobo.101.1">check requests.</span></span></li>
<li><span class="koboSpan" id="kobo.102.1">A database component that </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.103.1">wraps the access to a database to store and retrieve </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">check results.</span></span></li>
<li><span class="koboSpan" id="kobo.105.1">A checkrunner component that </span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.106.1">knows which checks to run and runs them whenever a check request comes in from </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">the queue.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.108.1">Note that these sub-components introduce mostly technical boundaries. </span><span class="koboSpan" id="kobo.108.2">Very similarly to output adapters in Hexagonal Architecture, we’re hiding away the specifics of accessing an external system (the queue and database) in sub-components. </span><span class="koboSpan" id="kobo.108.3">But then, the check engine component is a very technical component with little to no domain code. </span><span class="koboSpan" id="kobo.108.4">The only component that we could consider “domain code” is the checkrunner, which acts as a controller </span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.109.1">of sorts. </span><span class="koboSpan" id="kobo.109.2">Technical components lend themselves very well to a component-based architecture because the boundaries between them are clearer than the boundaries between different </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">functional domains.</span></span></p>
<p><span class="koboSpan" id="kobo.111.1">Let’s take a look at an architecture diagram of the check engine component to dig into the details (</span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.112.1">Figure 14</span></em></span><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.113.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">).</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer098">
<span class="koboSpan" id="kobo.115.1"><img alt="Figure 14.2 – The check engine component is made up of three sub-components that contribute to the parent component’s API" src="image/Figure_14.2._B19916.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.116.1">Figure 14.2 – The check engine component is made up of three sub-components that contribute to the parent component’s API</span></p>
<p><span class="koboSpan" id="kobo.117.1">The diagram mirrors the structure of the code. </span><span class="koboSpan" id="kobo.117.2">You can think of each box as a Java package (or a simple source code folder in other programming languages). </span><span class="koboSpan" id="kobo.117.3">If a box is within a larger box, it’s a sub-package of that larger box. </span><span class="koboSpan" id="kobo.117.4">The boxes at the lowest level, finally, </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">are classes.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">The public API of the check engine component consists of the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.120.1">CheckScheduler</span></strong><span class="koboSpan" id="kobo.121.1"> and </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.122.1">CheckQueries</span></strong><span class="koboSpan" id="kobo.123.1"> interfaces, which allow scheduling a web page check and retrieving the check </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">results, respectively.</span></span></p>
<p><strong class="sour e-inline"><span class="koboSpan" id="kobo.125.1">CheckScheduler</span></strong><span class="koboSpan" id="kobo.126.1"> is implemented by the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.127.1">SqsCheckScheduler</span></strong><span class="koboSpan" id="kobo.128.1"> class living in the queue component internals. </span><span class="koboSpan" id="kobo.128.2">This way, the queue component contributes to the parent component’s API. </span><span class="koboSpan" id="kobo.128.3">Only when we look at the name of this class does it tell us that it’s using Amazon’s Simple Queue Service (SQS). </span><span class="koboSpan" id="kobo.128.4">This implementation detail is not leaked to the outside </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.129.1">of the check engine component. </span><span class="koboSpan" id="kobo.129.2">Not even the sibling components know which queue technology is used. </span><span class="koboSpan" id="kobo.129.3">You might notice that the queue component doesn’t even have an API package, so all of its classes </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">are internal!</span></span></p>
<p><span class="koboSpan" id="kobo.131.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.132.1">CheckRequestListener</span></strong><span class="koboSpan" id="kobo.133.1"> class, then, listens to incoming requests from the queue. </span><span class="koboSpan" id="kobo.133.2">For each incoming request, it calls the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.134.1">CheckRunner</span></strong><span class="koboSpan" id="kobo.135.1"> interface in the checkrunner sub-component’s API. </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.136.1">DefaultCheckRunner</span></strong><span class="koboSpan" id="kobo.137.1"> implements that interface. </span><span class="koboSpan" id="kobo.137.2">It reads the web page URL from the incoming request, determines which checks to run against it, and then runs </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">those checks.</span></span></p>
<p><span class="koboSpan" id="kobo.139.1">When a check has finished, the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.140.1">DefaultCheckRunner</span></strong><span class="koboSpan" id="kobo.141.1"> class stores the results in the database by calling the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.142.1">CheckMutations</span></strong><span class="koboSpan" id="kobo.143.1"> interface of the database sub-component’s API. </span><span class="koboSpan" id="kobo.143.2">This interface is implemented by the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.144.1">CheckRepository</span></strong><span class="koboSpan" id="kobo.145.1"> class, which handles the details of connecting and talking to a database. </span><span class="koboSpan" id="kobo.145.2">Again, the database technology is not leaked to the outside </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.146.1">of the </span><span class="No-Break"><span class="koboSpan" id="kobo.147.1">database sub-component.</span></span></p>
<p><span class="koboSpan" id="kobo.148.1">The </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.149.1">CheckRepository</span></strong><span class="koboSpan" id="kobo.150.1"> class also implements the </span><strong class="sour e-inline"><span class="koboSpan" id="kobo.151.1">CheckQueries</span></strong><span class="koboSpan" id="kobo.152.1"> interface, which is part of the check engine’s public API. </span><span class="koboSpan" id="kobo.152.2">This interface provides methods to query for </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">check results.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">By splitting up the check engine component into three sub-components, we have divided the complexity. </span><span class="koboSpan" id="kobo.154.2">Each sub-component solves a simpler part of the overall problem. </span><span class="koboSpan" id="kobo.154.3">It can evolve mostly by itself. </span><span class="koboSpan" id="kobo.154.4">A change in queue or database technologies because of costs, scalability, or other reasons doesn’t leak into other sub-components. </span><span class="koboSpan" id="kobo.154.5">We could even replace the sub-components with simple in-memory implementations for tests if </span><span class="No-Break"><span class="koboSpan" id="kobo.155.1">we wanted.</span></span></p>
<p><span class="koboSpan" id="kobo.156.1">All this we get by structuring our code into components, following the convention of having dedicated API and </span><span class="No-Break"><span class="koboSpan" id="kobo.157.1">internal packages.</span></span></p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor122"/><span class="koboSpan" id="kobo.158.1">Enforcing component boundaries</span></h1>
<p><span class="koboSpan" id="kobo.159.1">Conventions are good to have, but if that’s all there is, someone will break them, and the architecture </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.160.1">will erode. </span><span class="koboSpan" id="kobo.160.2">We need to enforce the conventions of the </span><span class="No-Break"><span class="koboSpan" id="kobo.161.1">component architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.162.1">The nice thing about the component architecture is that we can apply a relatively simple fitness function to make sure that no accidental dependencies have crept into our </span><span class="No-Break"><span class="koboSpan" id="kobo.163.1">component architecture:</span></span></p>
<p><em class="itali"><span class="koboSpan" id="kobo.164.1">No classes that are outside of an “internal” package should access a class inside of that “</span></em><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.165.1">internal” package.</span></em></span></p>
<p><span class="koboSpan" id="kobo.166.1">If we put all the internals of a component into a package called “internal” (or a package marked as “internal” in some other way), we just have to check that no class in that package is called from outside of that package. </span><span class="koboSpan" id="kobo.166.2">For JVM-based projects, we can codify this fitness function </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">with ArchUnit:</span></span><span class="No-Break"><span id="footnote-044-backlink"><a class="_idFootnoteLink _idGenColorInherit" href="#footnote-044"><span class="koboSpan" id="kobo.168.1">3</span></a></span></span></p>
<div class="_idFootnote" epub:type="footnote" id="footnote-044">
<p><a class="_idFootnoteAnchor _idGenColorInherit" href="#footnote-044-backlink"><span class="koboSpan" id="kobo.169.1">3</span></a><span class="koboSpan" id="kobo.170.1">	ArchUnit rule to validate that no code accesses code within a certain package: </span><a href="https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/InternalPackageTest.kt"><span class="No-Break"><span class="koboSpan" id="kobo.171.1">https://github.com/thombergs/components-example/blob/main/server/src/test/kotlin/io/reflectoring/components/Internal</span></span>
<span class="No-Break"><span class="koboSpan" id="kobo.172.1">PackageTest.kt</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.173.1">.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer099">
<span class="koboSpan" id="kobo.174.1"><img alt="" src="image/code-14.1.jpg"/></span>
</div>
</div>
<p><span class="koboSpan" id="kobo.175.1">We just need a way to identify internal packages during each build and feed them all into the function above, and the build will fail if we have accidentally introduced a dependency to an </span><span class="No-Break"><span class="koboSpan" id="kobo.176.1">internal class.</span></span></p>
<p><span class="koboSpan" id="kobo.177.1">The fitness function doesn’t even need to know anything about the components in our architecture. </span><span class="koboSpan" id="kobo.177.2">We just need to follow a convention for identifying internal packages and then feed those packages into the function. </span><span class="koboSpan" id="kobo.177.3">This means that we don’t need to update the test that’s running the fitness function whenever we add or remove a component to/from the code base. </span><span class="No-Break"><span class="koboSpan" id="kobo.178.1">Very convenient!</span></span></p>
<p class="allout-heading"><span class="koboSpan" id="kobo.179.1">Note</span></p>
<p class="allout"><span class="koboSpan" id="kobo.180.1">This fitness function is an inverted form of the fitness function we introduced in </span><a href="B19916_12.xhtml#_idTextAnchor105"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.181.1">Chapter 12</span></em></span></a><em class="itali"><span class="koboSpan" id="kobo.182.1">, Enforcing Architecture Boundaries</span></em><span class="koboSpan" id="kobo.183.1">. </span><span class="koboSpan" id="kobo.183.2">In </span><a href="B19916_12.xhtml#_idTextAnchor105"><span class="No-Break"><em class="itali"><span class="koboSpan" id="kobo.184.1">Chapter 12</span></em></span></a><span class="koboSpan" id="kobo.185.1">, we verified that classes from a certain package don’t access classes outside of that package. </span><span class="koboSpan" id="kobo.185.2">Here, we verify that classes from outside the package are not accessing classes inside the package. </span><span class="koboSpan" id="kobo.185.3">This fitness function is much more stable, as we don’t have to add exceptions for every library </span><span class="No-Break"><span class="koboSpan" id="kobo.186.1">we’re using.</span></span></p>
<p><span class="koboSpan" id="kobo.187.1">We can still introduce unwanted dependencies by just not following our convention for internal packages, </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.188.1">of course. </span><span class="koboSpan" id="kobo.188.2">And the rule still allows a loophole: if we put classes directly into the “internal” package of a top-level component, the classes of any sub-components may access it. </span><span class="koboSpan" id="kobo.188.3">So, we might want to introduce another rule that disallows any classes directly in the “internal” package of a </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">top-level component.</span></span></p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor123"/><span class="koboSpan" id="kobo.190.1">How does this help me build maintainable software?</span></h1>
<p><span class="koboSpan" id="kobo.191.1">Component-based architecture is very simple. </span><span class="koboSpan" id="kobo.191.2">As long as each component has a dedicated namespace, dedicated API and internal packages, and classes within an internal package are not called from the outside, we get a very maintainable code base consisting of many composable and re-composable components. </span><span class="koboSpan" id="kobo.191.3">If we add the rule that components may be composed of other components, we can build a whole application out of smaller and smaller parts where each part solves a </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">simpler problem.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">Even though there are loopholes to get around the rules of the component architecture, the architecture itself is so simple that it’s very easy to understand and communicate. </span><span class="koboSpan" id="kobo.193.2">If it’s easy to understand, it’s easy to maintain. </span><span class="koboSpan" id="kobo.193.3">If it’s easy to maintain, the loopholes are less likely to </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">be exploited.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">Hexagonal Architecture cares about boundaries at the application level. </span><span class="koboSpan" id="kobo.195.2">Component-based architecture cares about boundaries at the component level. </span><span class="koboSpan" id="kobo.195.3">We can use this to embed components within a Hexagonal Architecture, or we can choose to start out with a simple component-based architecture and evolve it in any other architecture should the need arise. </span><span class="koboSpan" id="kobo.195.4">A component-based architecture is modular by design and modules are easy to move around </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">and refactor.</span></span></p>
<p><span class="koboSpan" id="kobo.197.1">In the next and last chapter, we’ll close the discussion around architecture and try to answer the question of when we should choose which </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">architecture style.</span></span></p>
</div>
</body></html>