<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Putting It All Together</h1>
                </header>
            
            <article>
                
<p>There are some challenges to face when we adopt the microservices architectural style. The first one handles operational complexity; services such as service discovery and load balancer help us to tackle these points. We solved these challenges in the previous chapters and got to know some important tools while doing so.</p>
<p>There are some other important key points to handle in microservices adoption. The effective way to monitor what happens in our microservices environments is to monitor how many times microservices consume other microservices resources, such as HTTP APIs, and how many times they fail. If we have near real-time statistics, it can save the developer days of troubleshooting and error investigations.</p>
<p>In this chapter, we will create some services which help us monitor the Hystrix commands and aggregate the command's statistics in a distributed environment.</p>
<p>Security is an important characteristic in microservices architecture, especially because of the distributed characteristic adopted by the microservices architecture. There are a lot of microservices in our architecture; we cannot share state between services, so the stateless security fits well for our environment.</p>
<p>The OAuth 2.0 protocol specification has this important characteristic: the stateless implementation. Spring Cloud Security provides support for OAuth 2.0.</p>
<p>Finally, we will Dockerize our microservices to use the images in Docker compose files.</p>
<p>In this chapter, we will learn about:</p>
<ul>
<li>Implementing the Turbine server to aggregate Hystrix streams</li>
<li>Configuring the Hystrix Dashboard to use Turbine and input data</li>
<li>Creating a mail service that will integrate an email API</li>
<li>Understanding Spring Cloud Security</li>
<li>Dockerizing our microservices</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The airline Bookings microservice</h1>
                </header>
            
            <article>
                
<p>The airline <kbd>Bookings</kbd> microservice is a standard Spring Boot Application. There are some interactions with other services, such as the <kbd>flights</kbd> microservice.</p>
<p>These interactions were created using Hystrix to bring some desired behaviors, such as fault-tolerance and resilience, to the airline <kbd>Bookings</kbd> microservice.</p>
<p>There are some business rules on this service, they are is not important to the learning context now, so we will skip the project creation and execution sections.</p>
<div class="packt_tip">The full source code can be found at GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-booking</a>); let's check it <span>out</span> and take a look at some code.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The airline Payments microservice</h1>
                </header>
            
            <article>
                
<p>The Airline <kbd>Payments</kbd> is a microservice that gives payments confirmation for our Airline Ticket System. For learning purposes, we will jump this project because there are some business rules, nothing important in the Spring Framework context.</p>
<p>We can find the full source code on GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/airline-payments</a>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Learning about the Turbine server</h1>
                </header>
            
            <article>
                
<p>There are some integrations in our microservices group; the <kbd>Bookings</kbd> microservice calls the <kbd>Fares</kbd> microservice and the <kbd>Passengers</kbd> microservice, these integrations are done using Hystrix to make it more resilient and fault tolerant.</p>
<p>However, in the microservices world, there are several instances of service. This will require us to aggregate the Hystrix command metrics by instance. Managing the instances panel by panel is not a good idea. The Turbine server helps developers in this context.</p>
<p>By default, <span>Turbine pulls metrics from servers run by Hystrix</span>, but it is not recommended for cloud environments because it can consume high values of network bandwidth and it will increase the traffic costs. We will use Spring Cloud Stream RabbitMQ to push metrics to Turbine via the <strong>Advanced Message Queuing Protocol</strong> (<strong>AMQP</strong>). Due to this, we will need to configure the RabbitMQ connections and put two more dependencies in our microservices, the dependencies are:</p>
<pre style="padding-left: 30px"><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-cloud-netflix-hystrix-stream<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-cloud-starter-stream-rabbit<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>These dependencies will enable the metrics to be sent to the Turbine server via the AMQP protocol.</p>
<p>The Turbine stream, by default, uses the port <kbd>8989</kbd> . We will configure it to run at <kbd>8010</kbd>, and we can use the <kbd>turbine.stream.port</kbd> property in the <kbd>application.yaml</kbd> to customize it.</p>
<p>The Turbine stream will be a Hystrix Dashboard data input to show the commands metrics.</p>
<div class="packt_tip">The full source code can be found on GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/turbine</a>).</div>
<p>There are many configurations to customize the Turbine server. They make the server extremely adaptable for different use cases.</p>
<div class="packt_infobox">We can find the Turbine documentation in the <em>Spring Cloud Turbine</em> section (<a href="https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine">https://cloud.spring.io/spring-cloud-netflix/single/spring-cloud-netflix.html#_turbine</a>). There is a great deal of information, especially if you need to customize some configurations.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Turbine server microservice</h1>
                </header>
            
            <article>
                
<p>Let's create our Turbine server. We will create a standard Spring Boot Application with a couple of annotations to enable Turbine stream and discovery client, as well.</p>
<p>The main class should be:</p>
<pre style="padding-left: 30px"><span>package </span>springfive.airline.turbine<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.<span>EnableEurekaClient</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.turbine.stream.<span>EnableTurbineStream</span><span>;<br/></span><span><br/></span><span>@EnableEurekaClient<br/></span><span><strong>@EnableTurbineStream</strong><br/></span><span>@SpringBootApplication<br/></span><span>public class </span>AirlineTurbineApplication {<br/><br/> <span>public static void </span><span>main</span>(String[] args) {<br/>    SpringApplication.<span>run</span>(AirlineTurbineApplication.<span>class, </span>args)<span>;<br/></span><span> </span>}<br/><br/>}</pre>
<p>As we can see, <kbd>@EnableTurbineStream</kbd> will enable us to push Hystrix commands metrics via the RabbitMQ message broker, which is enough for us.</p>
<p>The Turbine server <kbd>application.yaml</kbd> file can be found on GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/config-files/turbine.yaml</a>). There are a couple of configurations, such as discovery client and Turbine server configuration.</p>
<p>We can run the application, via the command line or IDE. Run it!</p>
<p>Make some calls to the <kbd>flights</kbd> microservice. The Create Flight API will call the <kbd>planes</kbd> microservice, which uses the Hystrix command, and will trigger some Hystrix command calls.</p>
<div class="packt_tip">We can use the Postman Collection located at GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/postman/flights.postman_collection</a>). This collection has a Create Flight request, which will call the <kbd>planes</kbd> microservices to get plane details. It is enough to collect metrics.</div>
<p>Now, we can test whether our Turbine server is running correctly. Go to the Turbine stream endpoint and then the JSON data with metrics should be displayed like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="209" src="assets/897fd218-a456-46b6-b147-7c58822772b2.png" width="816"/></div>
<p>There are some Hystrix commands information, but as we can see, this information needs to be organized to make it useful for us. Turbine uses the <span><strong>Server-Sent Events</strong> (</span><strong>SSE</strong>) technology, which was introduced in <a href="b82dbdb2-c96b-466f-aa29-2e2c40a69d3c.xhtml" target="_blank">Chapter 6</a>, <em>Playing with Server-Sent Events</em>.</p>
<p>In the next section, we will introduce the Hystrix Dashboard. It will help us to organize and make this information useful for us.</p>
<p>Let's jump to the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Hystrix Dashboard</h1>
                </header>
            
            <article>
                
<p>The Hystrix Dashboard will help us to organize the Turbine stream information. As we saw in the previous section, the Turbine server sends information via SSE. It is done using JSON objects.</p>
<p>The Hystrix stream provides a dashboard for us. Let's create our Hystrix Dashboard microservice. The application is a standard Spring Boot Application annotated with <kbd>@EnableHystrixDashboard</kbd>. Let's add the dependency to enable it:</p>
<pre style="padding-left: 30px"><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-cloud-starter-netflix-hystrix-dashboard<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>Good, now we can create the main class for our application. The main class should look like this:</p>
<pre style="padding-left: 30px"><span>package </span>springfive.airline.hystrix.ui<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.<span>EnableEurekaClient</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.hystrix.dashboard.<span>EnableHystrixDashboard</span><span>;<br/></span><span><br/></span><span>@EnableEurekaClient<br/></span><span>@SpringBootApplication<br/></span><span><strong>@EnableHystrixDashboard</strong><br/></span><span>public class </span>HystrixApplication {<br/><br/>  <span>public static void </span><span>main</span>(String[] args) {<br/>    SpringApplication.<span>run</span>(HystrixApplication.<span>class, </span>args)<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<div class="packt_infobox"><span>The full source code can be found at</span> <span>GitHub:</span> <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/hystrix-ui</a>.</div>
<p>As we can see, this is a pretty standard Spring Boot Application annotated with <kbd>@EnableHystrixDashboard</kbd>. It will provide the Hystrix Dashboard for us.</p>
<p>Now, we can run the application via IDE or the Java command line. Run it!</p>
<div class="packt_tip">The Hystrix Dashboard can be accessed using the following URL : <kbd>http://localhost:50010/hystrix</kbd>.</div>
<p>Then, go to the <span class="packt_screen">Hystrix Dashboard</span> main page. The following page should be displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="350" src="assets/4f178ddc-af28-4ae0-b1c6-8176be580b95.png" width="523"/></div>
<p>Awesome – our <span class="packt_screen">Hystrix Dashboard</span> is up and running. On this page, we can point to <kbd>hystrix.stream</kbd> or <kbd>turbine.stream</kbd> to consume and show the commands' metrics.</p>
<p>Keep this application running, we will use it later in this chapter.</p>
<p>Awesome job, guys, let's move to the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Mail microservice</h1>
                </header>
            
            <article>
                
<p>Now, we will create our <kbd>Mail</kbd> microservice. The name is self-explanatory, this component will be responsible for sending emails. We will not configure an <strong>SMTP</strong> (<strong>Simple Mail Transfer Protocol</strong>) server, we will use SendGrid.</p>
<p>SendGrid is an <strong>SaaS</strong> (<strong>Software as a Service</strong>) service for emails, we will use this service to send emails to our Airline Ticket System. There are some triggers to send email, for example, when the user creates a booking and when the payment is accepted.</p>
<p>Our <kbd>Mail</kbd> microservice will listen to a queue. Then the integration will be done using the message broker. We choose this strategy because we <span>do not need the feature that enables us to answer synchronously</span>. Another essential characteristic is the retry policy when the communication is broken. This behavior can be done easily using the message strategy.</p>
<p>We are using RabbitMQ as a message broker. For this project, we will use RabbitMQ Reactor, which is a reactive implementation of RabbitMQ Java client.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the SendGrid account</h1>
                </header>
            
            <article>
                
<p>Before we start to code, we need to create a SendGrid account. We will use the trial account which is enough for our tests. Go to the SendGrid portal (<a href="https://sendgrid.com/">https://sendgrid.com/</a>) and click on the <span class="packt_screen">Try for Free</span> button.</p>
<p>Fill in the required information and click on the <span class="packt_screen">Create Account</span> button.</p>
<p>In the main page, on the left side, click on <span class="packt_screen">Settings</span>, then go to the <span class="packt_screen">API Key</span> section, follow the image shown here:</p>
<div class="CDPAlignCenter CDPAlign"><img height="360" src="assets/f91bfd7e-d7ca-4a5f-9254-3b9028189fc4.png" width="609"/></div>
<p>Then, we can click on the <span class="packt_screen">Create API Key</span> button at the top-right corner. The page should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="33" src="assets/5d9869f8-daef-42e2-8a4b-9da667060d62.png" width="360"/></div>
<p>Fillin the <span class="packt_screen">API Key</span> information and choose <span class="packt_screen">Full Access</span>. After that the <span class="packt_screen">API Key</span> will appear on your screen. Take a note of it in a safe place, as we will use it as an environment variable soon.</p>
<p>Goob job, our SendGrid account is ready to use, now we can code our <kbd>Mail</kbd> microservice.</p>
<p>Let's do it in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Mail microservice project</h1>
                </header>
            
            <article>
                
<p>As we did in <a href="02944733-f452-49bc-bb4f-f4fa819c2405.xhtml" target="_blank">Chapter 8</a>, <em>Circuit Breakers and Security,</em> we will take a look at essential project parts. We will be using Spring Initializr, as we have several times in the previous chapters.</p>
<div class="packt_tip">The full source code can be found at GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service">https://github.com/PacktPublishing/Spring-5.0-By-Example/tree/master/Chapter09/mail-service</a>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding RabbitMQ dependencies</h1>
                </header>
            
            <article>
                
<p>Let's add the RabbitMQ required dependencies. The following dependencies should be added:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>io.projectreactor.rabbitmq<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span><strong>reactor-rabbitmq</strong><span>&lt;/artifactId&gt;<br/></span><span>  &lt;version&gt;</span>1.0.0.M1<span>&lt;/version&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.boot<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span><strong>spring-boot-starter-amqp</strong><span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;</span></pre>
<p>The first one is about the reactive implementation for RabbitMQ and the second one is the starter AMQP, which will set up some configurations automatically.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring some RabbitMQ stuff</h1>
                </header>
            
            <article>
                
<p>We want to configure some RabbitMQ exchanges, queues, and bindings. It can be done using the RabbitMQ client library. We will configure our required infrastructure for the <kbd>Mail</kbd> microservice.</p>
<p>Our configuration class should look like this:</p>
<pre><span>package </span>springfive.airline.mailservice.infra.rabbitmq<span>;<br/></span><span><br/></span><span>// imports are omitted<br/><br/></span><span>@Configuration<br/></span><span>public class </span>RabbitMQConfiguration {<br/><br/>  <span>private final </span>String <span>pass</span><span>;<br/></span><span><br/></span><span>  private final </span>String <span>user</span><span>;<br/></span><span><br/></span><span>  private final </span>String <span>host</span><span>;<br/></span><span><br/></span><span>  private final </span>Integer <span>port</span><span>;<br/></span><span><br/></span><span>  private final </span>String <span>mailQueue</span><span>;<br/></span><span><br/></span><span>  public </span><span>RabbitMQConfiguration</span>(<span>@Value</span>(<span>"${spring.rabbitmq.password}"</span>) String pass<span>,<br/></span><span>      </span><span>@Value</span>(<span>"${spring.rabbitmq.username}"</span>) String user<span>,<br/></span><span>      </span><span>@Value</span>(<span>"${spring.rabbitmq.host}"</span>) String host<span>,<br/></span><span>      </span><span>@Value</span>(<span>"${spring.rabbitmq.port}"</span>) Integer port<span>,<br/></span><span>      </span><span>@Value</span>(<span>"${mail.queue}"</span>) String mailQueue) {<br/>    <span>this</span>.<span>pass </span>= pass<span>;<br/></span><span>    this</span>.<span>user </span>= user<span>;<br/></span><span>    this</span>.<span>host </span>= host<span>;<br/></span><span>    this</span>.<span>port </span>= port<span>;<br/></span><span>    this</span>.<span>mailQueue </span>= mailQueue<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Bean</span>(<span>"springConnectionFactory"</span>)<br/>  <span>public </span>ConnectionFactory <span>connectionFactory</span>() {<br/>    CachingConnectionFactory factory = <span>new </span>CachingConnectionFactory()<span>;<br/></span><span>    </span>factory.setUsername(<span>this</span>.<span>user</span>)<span>;<br/></span><span>    </span>factory.setPassword(<span>this</span>.<span>pass</span>)<span>;<br/></span><span>    </span>factory.setHost(<span>this</span>.<span>host</span>)<span>;<br/></span><span>    </span>factory.setPort(<span>this</span>.<span>port</span>)<span>;<br/></span><span>    return </span>factory<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Bean<br/></span><span>  </span><span>public </span>AmqpAdmin <span>amqpAdmin</span>(<span>@Qualifier</span>(<span>"springConnectionFactory"</span>) ConnectionFactory connectionFactory) {<br/>    <span>return new </span>RabbitAdmin(connectionFactory)<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Bean<br/></span><span>  </span><span>public </span>TopicExchange <span>emailExchange</span>() {<br/>    <span>return new </span>TopicExchange(<span>"email"</span><span>, true, false</span>)<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Bean<br/></span><span>  </span><span>public </span>Queue <span>mailQueue</span>() {<br/>    <span>return new </span>Queue(<span>this</span>.<span>mailQueue</span><span>, true, false, false</span>)<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Bean<br/></span><span>  </span><span>public </span>Binding <span>mailExchangeBinding</span>(Queue mailQueue) {<br/>    <span>return </span>BindingBuilder.<span>bind</span>(mailQueue).to(emailExchange()).with(<span>"*"</span>)<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Bean<br/></span><span>  </span><span>public </span>Receiver <span>receiver</span>() {<br/>    <span>val </span>options = <span>new </span>ReceiverOptions()<span>;<br/></span><span>    </span>com.rabbitmq.client.ConnectionFactory connectionFactory = <span>new </span>com.rabbitmq.client.ConnectionFactory()<span>;<br/></span><span>    </span>connectionFactory.setUsername(<span>this</span>.<span>user</span>)<span>;<br/></span><span>    </span>connectionFactory.setPassword(<span>this</span>.<span>pass</span>)<span>;<br/></span><span>    </span>connectionFactory.setPort(<span>this</span>.<span>port</span>)<span>;<br/></span><span>    </span>connectionFactory.setHost(<span>this</span>.<span>host</span>)<span>;<br/></span><span>    </span>options.connectionFactory(connectionFactory)<span>;<br/></span><span>    return </span>ReactorRabbitMq.<span>createReceiver</span>(options)<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>There is interesting stuff here, but all of it is about infrastructure in RabbitMQ. It is important because when our application is in bootstrapping time, it means our application is preparing to run. This code will be executed and create the necessary queues, exchanges, and bindings. Some configurations are provided by the <kbd>application.yaml</kbd> file, look at the constructor.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modeling a Mail message</h1>
                </header>
            
            <article>
                
<p>Our <kbd>Mail</kbd> service is abstract and can be used for different purposes, so we will create a simple class to represent a mail message in our system. Our <kbd>Mail</kbd> class should look like this:</p>
<pre><span>package </span>springfive.airline.mailservice.domain<span>;<br/></span><span><br/></span><span>import </span>lombok.<span>Data</span><span>;<br/></span><span><br/></span><span>@Data<br/></span><span>public class </span>Mail {<br/><br/>  String <span>from</span><span>;<br/></span><span><br/></span><span>  </span>String <span>to</span><span>;<br/></span><span><br/></span><span>  </span>String <span>subject</span><span>;<br/></span><span><br/></span><span>  </span>String <span>message</span><span>;<br/></span><span><br/></span>}</pre>
<p>Easy, this class represents an abstract message on our system.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The MailSender class</h1>
                </header>
            
            <article>
                
<p>As we can expect, we will integrate with the SendGrid services through the REST APIs. In our case, we will use the reactive <kbd>WebClient</kbd> provided by Spring WebFlux.</p>
<p>Now, we will use the SendGrid API Key created in the previous section. Our <kbd>MailSender</kbd> class should look like this:</p>
<pre><span>package </span>springfive.airline.mailservice.domain.service<span>;<br/></span><span><br/></span><span>import </span>org.springframework.beans.factory.annotation.<span>Value</span><span>;<br/></span><span>import </span>org.springframework.http.HttpStatus<span>;<br/></span><span>import </span>org.springframework.http.ReactiveHttpOutputMessage<span>;<br/></span><span>import </span>org.springframework.stereotype.<span>Service</span><span>;<br/></span><span>import </span>org.springframework.web.reactive.function.BodyInserter<span>;<br/></span><span>import </span>org.springframework.web.reactive.function.BodyInserters<span>;<br/></span><span>import </span>org.springframework.web.reactive.function.client.WebClient<span>;<br/></span><span>import </span>reactor.core.publisher.Flux<span>;<br/></span><span>import </span>reactor.core.publisher.Mono<span>;<br/></span><span>import </span>springfive.airline.mailservice.domain.Mail<span>;<br/></span><span>import </span>springfive.airline.mailservice.domain.service.data.SendgridMail<span>;<br/></span><span><br/></span><span>@Service<br/></span><span>public class </span>MailSender {<br/><br/>  <span>private final </span>String <span>apiKey</span><span>;<br/></span><span><br/></span><span>  private final </span>String <span>url</span><span>;<br/></span><span><br/></span><span>  private final </span>WebClient <span>webClient</span><span>;<br/></span><span><br/></span><span>  public </span><span>MailSender</span>(<span>@Value</span>(<span>"${sendgrid.apikey}"</span>) String apiKey<span>,<br/></span><span>      </span><span>@Value</span>(<span>"${sendgrid.url}"</span>) String url<span>,<br/></span><span>      </span>WebClient webClient) {<br/>    <span>this</span>.<span>apiKey </span>= apiKey<span>;<br/></span><span>    this</span>.<span>webClient </span>= webClient<span>;<br/></span><span>    this</span>.<span>url </span>= url<span>;<br/></span><span>  </span>}<br/><br/>  <span>public </span>Flux&lt;Void&gt; <span>send</span>(Mail mail){<br/>    <span>final </span>BodyInserter&lt;SendgridMail<span>, </span>ReactiveHttpOutputMessage&gt; body = BodyInserters<br/>      .<span>fromObject</span>(SendgridMail.<span>builder</span>().content(mail.getMessage()).from(mail.getFrom()).to(mail.getTo()).subject(mail.getSubject()).build())<span>;<br/></span><span>    return this</span>.<span>webClient</span>.mutate().baseUrl(<span>this</span>.<span>url</span>).build().post()<br/>        .uri(<span>"/v3/mail/send"</span>)<br/>        .body(body)<br/>        .header(<span>"Authorization"</span><span>,</span><span>"Bearer " </span>+ <span>this</span>.<span>apiKey</span>)<br/>        .header(<span>"Content-Type"</span><span>,</span><span>"application/json"</span>)<br/>        .retrieve()<br/>        .onStatus(HttpStatus::is4xxClientError<span>, </span>clientResponse -&gt;<br/>            Mono.<span>error</span>(<span>new </span>RuntimeException(<span>"Error on send email"</span>))<br/>        ).bodyToFlux(Void.<span>class</span>)<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>We received the configurations in the constructor, that is, the <kbd>sendgrid.apikey</kbd> and <kbd>sendgrid.url</kbd>. They will be configured soon. In the <kbd>send()</kbd> method, there are some interesting constructions. Look at <kbd>BodyInserters.fromObject()</kbd>: it allows us to send a JSON object in the HTTP body. In our case, we will create a <kbd>SendGrid</kbd> mail object.</p>
<p>In the <kbd>onStatus()</kbd> function, we can pass a predicate to handle the HTTP errors family. In our case, we are interested in the 4xx error family.</p>
<p>This class will process sending the mail messages, but it is necessary to listen to the RabbbitMQ queue, which we will do in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the RabbitMQ queue listener</h1>
                </header>
            
            <article>
                
<p>Let's create our <kbd>MailQueueConsumer</kbd> class, which will listen to the RabbitMQ queue. The class should look like this:</p>
<pre><span>package </span>springfive.airline.mailservice.domain.service<span>;<br/></span><span><br/></span><span>import </span>com.fasterxml.jackson.databind.ObjectMapper<span>;<br/></span><span>import </span>java.io.IOException<span>;<br/></span><span>import </span>javax.annotation.<span>PostConstruct</span><span>;<br/></span><span>import </span>lombok.extern.slf4j.<span>Slf4j</span><span>;<br/></span><span>import </span>lombok.<span>val</span><span>;<br/></span><span>import </span>org.springframework.beans.factory.annotation.<span>Value</span><span>;<br/></span><span>import </span>org.springframework.stereotype.<span>Service</span><span>;<br/></span><span>import </span>reactor.rabbitmq.Receiver<span>;<br/></span><span>import </span>springfive.airline.mailservice.domain.Mail<span>;<br/></span><span><br/></span><span>@Service<br/></span><span>@Slf4j<br/></span><span>public class </span>MailQueueConsumer {<br/><br/>  <span>private final </span>MailSender <span>mailSender</span><span>;<br/></span><span><br/></span><span>  private final </span>String <span>mailQueue</span><span>;<br/></span><span><br/></span><span>  private final </span>Receiver <span>receiver</span><span>;<br/></span><span><br/></span><span>  private final </span>ObjectMapper <span>mapper</span><span>;<br/></span><span><br/></span><span>  public </span><span>MailQueueConsumer</span>(MailSender mailSender<span>, </span><span>@Value</span>(<span>"${mail.queue}"</span>) String mailQueue<span>,<br/></span><span>      </span>Receiver receiver<span>, </span>ObjectMapper mapper) {<br/>    <span>this</span>.<span>mailSender </span>= mailSender<span>;<br/></span><span>    this</span>.<span>mailQueue </span>= mailQueue<span>;<br/></span><span>    this</span>.<span>receiver </span>= receiver<span>;<br/></span><span>    this</span>.<span>mapper </span>= mapper<span>;<br/></span><span>  </span>}<br/><br/>  <span>@PostConstruct<br/></span><span>  </span><span>public void </span><span>startConsume</span>() {<br/>    <span>this</span>.<span>receiver</span>.consumeAutoAck(<span>this</span>.<span>mailQueue</span>).subscribe(message -&gt; {<br/>      <span>try </span>{<br/>        <span>val </span>mail = <span>this</span>.<span>mapper</span>.readValue(<span>new </span>String(message.getBody())<span>, </span>Mail.<span>class</span>)<span>;<br/></span><span>        this</span>.<span>mailSender</span>.send(mail).subscribe(data -&gt;{<br/>          <span>log</span>.info(<span>"Mail sent successfully"</span>)<span>;<br/></span><span>        </span>})<span>;<br/></span><span>      </span>} <span>catch </span>(IOException e) {<br/>        <span>throw new </span>RuntimeException(<span>"error on deserialize object"</span>)<span>;<br/></span><span>      </span>}<br/>    })<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>The method annotated with <kbd>@PostConstruct</kbd> will be invoked after <kbd>MailQueueConsumer</kbd> is ready, which will mean that the injections are processed. Then <kbd>Receiver</kbd> will start to process the messages.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the Mail microservice</h1>
                </header>
            
            <article>
                
<p>Now, we will run our <kbd>Mail</kbd> microservice. Find the <kbd>MailServiceApplication</kbd> class, the main class of our project. The main class should look like this:</p>
<pre><span>package </span>springfive.airline.mailservice<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.<span>EnableEurekaClient</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.hystrix.<span>EnableHystrix</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.zuul.<span>EnableZuulProxy</span><span>;<br/></span><span><br/></span><span>@EnableHystrix<br/></span><span>@EnableZuulProxy<br/></span><span>@EnableEurekaClient<br/></span><span>@SpringBootApplication<br/></span><span>public class </span>MailServiceApplication {<br/><br/>  <span>public static void </span><span>main</span>(String[] args) {<br/>    SpringApplication.<span>run</span>(MailServiceApplication.<span>class, </span>args)<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>It is a standard Spring Boot Application.</p>
<p>We can run the application in IDE or via the Java command line.</p>
<p>Run it!</p>
<div class="packt_infobox">We need to pass <kbd>${SENDGRID_APIKEY}</kbd> and <kbd>${SENDGRID_URL}</kbd> as environment variables. If you are running the application with the Java command line, the <kbd>-D</kbd> option allows us to pass environment variables. If you are using the IDE, you can configure in the <span class="packt_screen">Run/Debug Configurations</span>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Authentication microservice</h1>
                </header>
            
            <article>
                
<p>We want to secure our microservices. Security is essential for microservices applications, especially because of the distributed characteristics.</p>
<p>On the microservices architectural style, usually, there is a service that will act as an authentication service. It means this service will authenticate the requests in our microservices group.</p>
<p>Spring Cloud Security provides a declarative model to help developers enable security on applications. There is support for commons patterns such as OAuth 2.0. Also, Spring Boot Security enables <strong>Single Sign-On</strong> (<strong>SSO</strong>).</p>
<p>Spring Boot Security also supports relay SSO tokens integrating with Zuul proxy. It means the tokens will be passed to downstream microservices.</p>
<p>For our architecture, we will use the OAuth 2.0 and JWT patterns, both integrate with Zuul proxy.</p>
<p>Before we do so, let's understand the main entities in OAuth 2.0 flow:</p>
<ul>
<li><strong>Protected resource</strong>: T<span>his service will</span> apply security rules; the microservices applications, in our case</li>
<li><strong>OAuth authorization server</strong>: The authentication server is a service between the application, which can be a frontend or a mobile, and a service that applications want to call</li>
<li><strong>Application</strong>: The application that will call the service, <span>the client.</span></li>
<li><strong>Resource Owner</strong>: The user or machine that will authorize the client application to access their account</li>
</ul>
<p>Let's draw the basic OAuth flow:</p>
<div class="CDPAlignCenter CDPAlign"><img height="209" src="assets/917002f4-1c25-4b28-80a2-3994a64c0db5.png" width="331"/></div>
<p>We can observe the following in this diagram:</p>
<ol>
<li>The <strong>Client</strong> requests the authorization</li>
<li>The <strong>Resource Owner</strong> sends the authorization grant</li>
<li>The application client requests the access token from the <strong>Authorization Server</strong></li>
<li>If the authorization grant is valid, the <strong>Authorization Server</strong> will provide the access token</li>
<li>The application calls the protected resource and sends the access token</li>
<li>If the <strong>Resource Server</strong> recognizes the token, the resource will serve for the application</li>
</ol>
<p>These are the basics of the OAuth 2.0 authorization flow. We will implement this flow using Spring Cloud Security. Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Auth microservice</h1>
                </header>
            
            <article>
                
<p>As we have been doing in this chapter, we will take a look at the important parts. Let's start with our dependencies. We need to put in the following dependencies:</p>
<pre>  <span>&lt;dependency&gt;<br/></span><span> &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span> &lt;artifactId&gt;</span>spring-cloud-starter-oauth2<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span><span><br/></span><span>  &lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.springframework.security<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>spring-security-core<span>&lt;/artifactId&gt;<br/></span><span>  &lt;/dependency&gt;<br/></span><span><br/></span><span>  &lt;dependency&gt;<br/></span><span>    &lt;groupId&gt;</span>org.springframework.security<span>&lt;/groupId&gt;<br/></span><span>    &lt;artifactId&gt;</span>spring-security-config<span>&lt;/artifactId&gt;<br/></span><span>  &lt;/dependency&gt;</span></pre>
<p>These dependencies will enable us to use the Spring Cloud Security features. Let's start to code our Authentication microservice.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the security</h1>
                </header>
            
            <article>
                
<p>Let's start coding our <kbd>Auth</kbd> microservice. We will start with the authorization and authentication, as we want to protect all resources in our microservices, then we will configure <kbd>WebSecurityConfigureAdapter</kbd>. The class should look like this:</p>
<pre><span>package </span>springfive.airline.authservice.infra.security<span>;<br/></span><span><br/></span><span>import </span>org.springframework.beans.factory.annotation.<span>Autowired</span><span>;<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration</span><span>;<br/></span><span>import </span>org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder<span>;<br/></span><span>import </span>org.springframework.security.config.annotation.method.configuration.<span>EnableGlobalMethodSecurity</span><span>;<br/></span><span>import </span>org.springframework.security.config.annotation.web.builders.HttpSecurity<span>;<br/></span><span>import </span>org.springframework.security.config.annotation.web.configuration.<span>EnableWebSecurity</span><span>;<br/></span><span>import </span>org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter<span>;<br/></span><span>import </span>org.springframework.security.crypto.password.PasswordEncoder<span>;<br/></span><span>import </span>springfive.airline.authservice.service.CredentialsDetailsService<span>;<br/></span><span><br/></span><span>@Configuration<br/></span><span><strong>@EnableWebSecurity</strong><br/></span><strong>@EnableGlobalMethodSecurity(prePostEnabled = true)</strong><br/><span>public class </span>SecurityConfig <span>extends </span><strong>WebSecurityConfigurerAdapter</strong> {<br/><br/>  <span>private final </span>PasswordEncoder <span>passwordEncoder</span><span>;<br/></span><span><br/></span><span>  private final </span>CredentialsDetailsService <span>credentialUserDetails</span><span>;<br/></span><span><br/></span><span>  public </span><span>SecurityConfig</span>(PasswordEncoder passwordEncoder<span>,<br/></span><span>      </span>CredentialsDetailsService credentialUserDetails) {<br/>    <span>this</span>.<span>passwordEncoder </span>= passwordEncoder<span>;<br/></span><span>    this</span>.<span>credentialUserDetails </span>= credentialUserDetails<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Override<br/></span><span>  @Autowired<br/></span><strong>  protected void configure(AuthenticationManagerBuilder auth) throws Exception {</strong><br/><strong>    auth.userDetailsService(this.credentialUserDetails).passwordEncoder(this.passwordEncoder);<br/>  }</strong><br/><br/>  <strong>@Override<br/>  protected void configure(HttpSecurity http) throws Exception {</strong><br/><strong>    http.csrf().disable()</strong><br/><strong>        .authorizeRequests()</strong><br/><strong>        .antMatchers("/login", "/**/register/**").permitAll()</strong><br/><strong>        .anyRequest().authenticated()</strong><br/><strong>        .and()</strong><br/><strong>        .formLogin().permitAll();<br/>  }</strong><br/><br/>}</pre>
<p>There is a lot of stuff here. Let's start with the <kbd>@EnableWebSecurity</kbd>, this annotation enables Spring Security integrations with Spring MVC. <kbd>@EnableGlobalMethodSecurity</kbd> provides AOP interceptors to enable methods security using the annotations. We can use this feature by annotating the methods on a controller, for instance. The basic idea is to wrap the methods call in AOP interceptors and apply security on the methods.</p>
<p><kbd>WebSecurityConfigurerAdapter</kbd> enables us to configure the secure endpoints and some stuff about how to authenticate users, which can be done using the <kbd>configure(AuthenticationManagerBuilder auth)</kbd> method. We have configured our <kbd>CredentialsDetailsService</kbd> and our <kbd>PasswordEncoder</kbd> to avoid plane password between application layers. In this case, <kbd>CredentialsDetailsService</kbd> is the source of our user's data.</p>
<p>In our method, <kbd>configure(HttpSecurity http)</kbd>, we have configured some HTTP security rules. As we can see, all users can access <kbd>/login</kbd> and <kbd>/**/register/**</kbd>. It's about <em>Sign In</em> and <em>Sign Up</em> features. All other requests need to be authenticated by the Authorization server.</p>
<p>The <span><kbd>CredentialsDetailsService</kbd> should look like this:</span></p>
<pre><span>package </span>springfive.airline.authservice.service<span>;<br/></span><span><br/></span><span>import </span>org.springframework.security.core.userdetails.UserDetailsService<span>;<br/></span><span>import </span>org.springframework.security.core.userdetails.UsernameNotFoundException<span>;<br/></span><span>import </span>org.springframework.stereotype.<span>Component</span><span>;<br/></span><span>import </span>springfive.airline.authservice.domain.Credential<span>;<br/></span><span>import </span>springfive.airline.authservice.domain.data.CredentialData<span>;<br/></span><span>import </span>springfive.airline.authservice.repository.CredentialRepository<span>;<br/></span><span><br/></span><span>@Component<br/></span><span>public class </span>CredentialsDetailsService <span>implements </span>UserDetailsService {<br/><br/>  <span>private final </span>CredentialRepository <span>credentialRepository</span><span>;<br/></span><span><br/></span><span>  public </span><span>CredentialsDetailsService</span>(CredentialRepository credentialRepository) {<br/>    <span>this</span>.<span>credentialRepository </span>= credentialRepository<span>;<br/></span><span>  </span>}<br/><br/>  <span>@Override<br/></span><span>  </span><span>public </span>CredentialData <span>loadUserByUsername</span>(String email) <span>throws </span>UsernameNotFoundException {<br/>    <span>final </span>Credential credential = <span>this</span>.<span>credentialRepository</span>.findByEmail(email)<span>;<br/></span><span>    return </span>CredentialData.<span>builder</span>().email(credential.getEmail()).password(credential.getPassword()).scopes(credential.getScopes()).build()<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>There is nothing special here. We need to override the <kbd>loadUserByUsername(String email)</kbd> method to provide the user data to Spring Security.</p>
<p>Let's configure our token signer and our token store. We will provide these beans using the <kbd>@Configuration</kbd> class, as we did in the previous chapters:</p>
<pre><span>package </span>springfive.airline.authservice.infra.oauth<span>;<br/></span><span><br/></span><span>import </span>org.springframework.beans.factory.annotation.<span>Value</span><span>;<br/></span><span>import </span>org.springframework.context.annotation.<span>Bean</span><span>;<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration</span><span>;<br/></span><span>import </span>org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder<span>;<br/></span><span>import </span>org.springframework.security.crypto.password.PasswordEncoder<span>;<br/></span><span>import </span>org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter<span>;<br/></span><span>import </span>org.springframework.security.oauth2.provider.token.store.JwtTokenStore<span>;<br/></span><span><br/></span><span>@Configuration<br/></span><span>public class </span>OAuthTokenProducer {<br/><br/>    <span>@Value</span>(<span>"${config.oauth2.privateKey}"</span>)<br/>    <span>private </span>String <span>privateKey</span><span>;<br/></span><span><br/></span><span>    </span><span>@Value</span>(<span>"${config.oauth2.publicKey}"</span>)<br/>    <span>private </span>String <span>publicKey</span><span>;<br/></span><span><br/></span><span>    </span><span>@Bean<br/></span><span>    </span><span>public </span>JwtTokenStore <span>tokenStore</span>(JwtAccessTokenConverter tokenEnhancer) {<br/>        <span>return new </span>JwtTokenStore(tokenEnhancer)<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Bean<br/></span><span>    </span><span>public </span>PasswordEncoder <span>passwordEncoder</span>() {<br/>        <span>return new </span>BCryptPasswordEncoder()<span>;<br/></span><span>    </span>}<br/><br/>    <span>@Bean<br/></span><span>    </span><span>public </span>JwtAccessTokenConverter <span>tokenEnhancer</span>() {<br/>        JwtAccessTokenConverter converter = <span>new </span>JwtAccessTokenConverter()<span>;<br/></span><span>        </span>converter.setSigningKey(<span>privateKey</span>)<span>;<br/></span><span>        </span>converter.setVerifierKey(<span>publicKey</span>)<span>;<br/></span><span>        return </span>converter<span>;<br/></span><span>    </span>}<br/><br/>}</pre>
<p>We have configured our private and public keys in the <kbd>application.yaml</kbd> file. Optionally, we can read the <kbd>jks</kbd> files from the classpath as well. Then, we provided our token signer or token enhancer using the <kbd>JwtAccessTokenConverter</kbd> class, where we have used the private and public key.</p>
<p>In our token store, Spring Security Framework will use this object to read data from tokens, then set up the <span><kbd>JwtAccessTokenConverter</kbd> on the <kbd>JwtTokenStore</kbd> instance.</span></p>
<p>Finally, we have provided the password encoder class using the <kbd>BCryptPasswordEncoder</kbd> class.</p>
<p>Our last class is the Authorization server configuration. The configuration can be done using the following class:</p>
<p>Look at the <kbd>OAuth2AuthServer</kbd> class located on GitHub (<a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/src/main/java/springfive/airline/authservice/infra/oauth/OAuth2AuthServer.java</a>).</p>
<p>We have used <kbd>@EnableAuthorizationServer</kbd> to configure the Authorization server mechanism in our <kbd>Auth</kbd> microservice. This class works together with <kbd>AuthorizationServerConfigurerAdapter</kbd> to provide some customizations.</p>
<p>On <kbd>configure(AuthorizationServerSecurityConfigurer oauthServer),</kbd> we have configured the security for token endpoints.</p>
<p>At <kbd>configure(AuthorizationServerEndpointsConfigurer endpoints),</kbd> we have configured the endpoints of the token service such as, <span><kbd>/oauth/token</kbd> and <kbd>/oauth/authorize</kbd>.</span></p>
<p>Finally, on configure (<kbd>ClientDetailsServiceConfigurer</kbd> clients), we have configured the client's ID and secrets. We used in-memory data, but we can use JDBC implementations as well.</p>
<p>The <kbd>Auth</kbd> microservice main class should be:</p>
<pre><span>package </span>springfive.airline.authservice<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.<span>EnableEurekaClient</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.zuul.<span>EnableZuulProxy</span><span>;<br/></span><span><br/></span><strong>@EnableZuulProxy<br/>@EnableEurekaClient<br/></strong><span><strong>@SpringBootApplication</strong><br/></span><span>public class </span>AuthServiceApplication {<br/><br/> <span>public static void </span><span>main</span>(String[] args) {<br/>  SpringApplication.<span>run</span>(AuthServiceApplication.<span>class, </span>args)<span>;<br/></span><span> </span>}<br/><br/>}</pre>
<p><span>Here, we have created a standard</span> Spring Boot Application with service discovery and Zuul proxy enabled.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Testing the Auth microservice</h1>
                </header>
            
            <article>
                
<p>As we can see, the <kbd>Auth</kbd> microservice is ready for testing. Our microservice is listening to port <kbd>7777</kbd>, which we configured using the <kbd>application.yaml</kbd> file on GitHub.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Client credentials flow</h1>
                </header>
            
            <article>
                
<p>Let's start with the client credentials flow.</p>
<p>Our application needs to be up on port <kbd>7777</kbd>, then we can use the following command line to get the token:</p>
<pre><strong>curl -s 442cf4015509eda9c03e5ca3aceef752:4f7ec648a48b9d3fa239b497f7b6b4d8019697bd@localhost:7777/oauth/token   -d grant_type=client_credentials  -d scope=trust | jq .</strong></pre>
<p>As we can see, this <em>client ID</em> and <em>client secret</em> are from the <kbd>planes</kbd> microservice. We did this configuration at the <kbd>OAuth2AuthServer</kbd> class. Let's remember the exact point:</p>
<pre><span>....<br/>@Override<br/></span><span>public void </span><span>configure</span>(ClientDetailsServiceConfigurer clients)<span>throws </span>Exception {<br/>  clients<br/>      .inMemory()<br/>      .withClient(<span>"ecommerce"</span>) <span>// ecommerce microservice<br/></span><span>      </span>.secret(<span>"9ecc8459ea5f39f9da55cb4d71a70b5d1e0f0b80"</span>)<br/>      .authorizedGrantTypes(<span>"authorization_code"</span><span>, </span><span>"refresh_token"</span><span>, </span><span>"implicit"</span><span>,<br/></span><span>          </span><span>"client_credentials"</span>)<br/>      .authorities(<span>"maintainer"</span><span>, </span><span>"owner"</span><span>, </span><span>"user"</span>)<br/>      .scopes(<span>"read"</span><span>, </span><span>"write"</span>)<br/>      .accessTokenValiditySeconds(<span>THREE_HOURS</span>)<br/>      .and()<br/>      <strong>.withClient("442cf4015509eda9c03e5ca3aceef752") // planes microservice<br/>      .secret("4f7ec648a48b9d3fa239b497f7b6b4d8019697bd")</strong><br/><strong>      .authorizedGrantTypes("authorization_code", "refresh_token", "implicit",<br/>          "client_credentials")</strong><br/><strong>      .authorities("operator")</strong><br/><strong>      .scopes("trust")</strong><br/>      .accessTokenValiditySeconds(<span>ONE_DAY</span>)<br/>    <br/>....</pre>
<p>After you call the preceding command, the result should be:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/13bf0165-4bc6-43a7-a57b-3f314d22a2f2.png"/></div>
<p>As we can see, the token was obtained with success. Well done, our client credentials flow was configured successfully. Let's move to the implicit flow, which will be covered in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implicit grant flow</h1>
                </header>
            
            <article>
                
<p>In this section, we will take a look at how to authenticate in our <kbd>Auth</kbd> microservice using the implicit flow.</p>
<p>Before we test our flow, let's create a user to enable authentication in the <kbd>Auth</kbd> microservice. The following command will create a user in the <kbd>Auth</kbd> service:</p>
<pre>curl -H "Content-Type: application/json" -X POST -d '{"name":"John Doe","email":"john@doe.com", "password" : "john"}' http://localhost:7777/register</pre>
<p>As we can see, the email is <kbd>john@doe.com</kbd> and the password is <kbd>john</kbd>.</p>
<p>We will use the browser to do this task. Let's go to the following URL:</p>
<p><kbd>http://localhost:7777/oauth/authorize?client_id=ecommerce&amp;response_type=token&amp;scope=write&amp;state=8777&amp;redirect_uri=https://httpbin.org/anything</kbd></p>
<p>Let's understand the parameters:</p>
<p>The first part is the service address. To use the implicit grant flow, we need the path <kbd>/oauth/authorize</kbd>. Also we will use <kbd>ecommerce</kbd> as a client ID because we have configured it previously. <kbd>response_type=token</kbd> informs the implicit flow, <kbd>scope</kbd> is the scope as what we want in our case is write, <kbd>state</kbd> is a random variable, and <kbd>redirect_uri</kbd> is the URI to go after the <kbd>oauth</kbd> login process.</p>
<p>Put the URL in a web browser, and the following page should be displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="124" src="assets/49f91e24-a935-420e-81b0-cb11e20051be.png" width="395"/></div>
<p>After typing the <span class="packt_screen">User</span> and <span class="packt_screen">Password</span>, the following page will be displayed to authorize our protected resources:</p>
<div class="CDPAlignCenter CDPAlign"><img height="118" src="assets/34998698-9d77-44ee-8a59-60d7fb1309da.png" width="346"/></div>
<p>Click on the <span class="packt_screen">Authorize</span> button. Then we will see the token in the browser URL like this:</p>
<div class="CDPAlignCenter CDPAlign"><img height="72" src="assets/6e1a2819-63ac-45c6-a937-04098bee29aa.png" width="762"/></div>
<p>The full token can be viewed if we copy the browser URL.</p>
<p>Awesome job, guys, our <kbd>Auth</kbd> microservice is fully operational.</p>
<p>In the next sections, we will configure the <kbd>Auth</kbd> microservice to protect Zuul proxy downstream microservices, such as the <kbd>planes</kbd> microservices. Let's jump to the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Protecting the microservices with OAuth 2.0</h1>
                </header>
            
            <article>
                
<p>Now we will configure OAuth 2.0 to protect our microservices; in our case, our microservices are the resource servers. Let's start with the <kbd>planes</kbd> microservices. We will add the new dependency and configure the private and public keys. Also, we will configure our <kbd>JwtTokenStore</kbd>.</p>
<p>Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding the security dependency</h1>
                </header>
            
            <article>
                
<p>To add the newly required dependency, we will change the <kbd>pom.xml</kbd> of the <kbd>planes</kbd> microservice. We will add the following dependency:</p>
<pre><span>&lt;dependency&gt;<br/></span><span>  &lt;groupId&gt;</span>org.springframework.cloud<span>&lt;/groupId&gt;<br/></span><span>  &lt;artifactId&gt;</span>spring-cloud-starter-oauth2<span>&lt;/artifactId&gt;<br/></span><span>&lt;/dependency&gt;<br/></span></pre>
<p>A piece of cake – our required dependency is configured properly.</p>
<p>In the next section, we will configure the <kbd>application.yaml</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring the application.yaml file</h1>
                </header>
            
            <article>
                
<p>To configure our private and public keys, we will use the <kbd>application.yaml</kbd> file. We did this configuration in the <kbd>Auth</kbd> microservice. The configuration is pretty easy. We need to add the following snippet:</p>
<pre>config:
  oauth2:
    privateKey: |
      -----BEGIN RSA PRIVATE KEY-----
      MIICXQIBAAKBgQDNQZKqTlO/+2b4ZdhqGJzGBDltb5PZmBz1ALN2YLvt341pH6i5
      mO1V9cX5Ty1LM70fKfnIoYUP4KCE33dPnC7LkUwE/myh1zM6m8cbL5cYFPyP099t
      hbVxzJkjHWqywvQih/qOOjliomKbM9pxG8Z1dB26hL9dSAZuA8xExjlPmQIDAQAB
      AoGAImnYGU3ApPOVtBf/TOqLfne+2SZX96eVU06myDY3zA4rO3DfbR7CzCLE6qPn
      yDAIiW0UQBs0oBDdWOnOqz5YaePZu/yrLyj6KM6Q2e9ywRDtDh3ywrSfGpjdSvvo
      aeL1WesBWsgWv1vFKKvES7ILFLUxKwyCRC2Lgh7aI9GGZfECQQD84m98Yrehhin3
      fZuRaBNIu348Ci7ZFZmrvyxAIxrV4jBjpACW0RM2BvF5oYM2gOJqIfBOVjmPwUro
      bYEFcHRvAkEAz8jsfmxsZVwh3Y/Y47BzhKIC5FLaads541jNjVWfrPirljyCy1n4
      sg3WQH2IEyap3WTP84+csCtsfNfyK7fQdwJBAJNRyobY74cupJYkW5OK4OkXKQQL
      Hp2iosJV/Y5jpQeC3JO/gARcSmfIBbbI66q9zKjtmpPYUXI4tc3PtUEY8QsCQQCc
      xySyC0sKe6bNzyC+Q8AVvkxiTKWiI5idEr8duhJd589H72Zc2wkMB+a2CEGo+Y5H
      jy5cvuph/pG/7Qw7sljnAkAy/feClt1mUEiAcWrHRwcQ71AoA0+21yC9VkqPNrn3
      w7OEg8gBqPjRlXBNb00QieNeGGSkXOoU6gFschR22Dzy
      -----END RSA PRIVATE KEY-----
    publicKey: |
      -----BEGIN PUBLIC KEY-----
      MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDNQZKqTlO/+2b4ZdhqGJzGBDlt
      b5PZmBz1ALN2YLvt341pH6i5mO1V9cX5Ty1LM70fKfnIoYUP4KCE33dPnC7LkUwE
      /myh1zM6m8cbL5cYFPyP099thbVxzJkjHWqywvQih/qOOjliomKbM9pxG8Z1dB26
      hL9dSAZuA8xExjlPmQIDAQAB
      -----END PUBLIC KEY-----</pre>
<p>Moreover, the user info URI will be done using the following configuration in YAML:</p>
<pre>  oauth2:
    resource:
      userInfoUri: http://localhost:7777/credential</pre>
<p>Awesome – our application is fully configured. Now, we will do the last part: configuring to get the information token.</p>
<p>Let's do that.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the JwtTokenStore Bean</h1>
                </header>
            
            <article>
                
<p>We will create the <kbd>JwtTokenStore</kbd>, which will be used to get token information. The class should look like this:</p>
<pre><span>package </span>springfive.airline.airlineplanes.infra.oauth<span>;<br/></span><span><br/></span><span>import </span>org.springframework.beans.factory.annotation.<span>Value</span><span>;<br/></span><span>import </span>org.springframework.context.annotation.<span>Bean</span><span>;<br/></span><span>import </span>org.springframework.context.annotation.<span>Configuration</span><span>;<br/></span><span>import </span>org.springframework.security.oauth2.provider.token.store.JwtAccessTokenConverter<span>;<br/></span><span>import </span>org.springframework.security.oauth2.provider.token.store.JwtTokenStore<span>;<br/></span><span><br/></span><span>@Configuration<br/></span><span>public class </span>OAuthTokenConfiguration {<br/><br/>  <span>@Value</span>(<span>"${config.oauth2.privateKey}"</span>)<br/>  <span>private </span>String <span>privateKey</span><span>;<br/></span><span><br/></span><span>  </span><span>@Value</span>(<span>"${config.oauth2.publicKey}"</span>)<br/>  <span>private </span>String <span>publicKey</span><span>;<br/></span><span><br/></span><span>  </span><span>@Bean<br/></span><span>  </span><span>public </span>JwtTokenStore <span>tokenStore</span>() <span>throws </span>Exception {<br/>    JwtAccessTokenConverter enhancer = <span>new </span>JwtAccessTokenConverter()<span>;<br/></span><span>    </span>enhancer.setSigningKey(<span>privateKey</span>)<span>;<br/></span><span>    </span>enhancer.setVerifierKey(<span>publicKey</span>)<span>;<br/></span><span>    </span>enhancer.afterPropertiesSet()<span>;<br/></span><span>    return new </span>JwtTokenStore(enhancer)<span>;<br/></span><span>  </span>}<br/><br/>}</pre>
<p>Awesome – our token signer is configured.</p>
<p>Finally, we will add the following annotation to the main class, which should look like this:</p>
<pre><span>package </span>springfive.airline.airlineplanes<span>;<br/></span><span><br/></span><span>import </span>org.springframework.boot.SpringApplication<span>;<br/></span><span>import </span>org.springframework.boot.autoconfigure.<span>SpringBootApplication</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.eureka.<span>EnableEurekaClient</span><span>;<br/></span><span>import </span>org.springframework.cloud.netflix.zuul.<span>EnableZuulProxy</span><span>;<br/></span><span>import </span>org.springframework.security.oauth2.config.annotation.web.configuration.<span>EnableResourceServer</span><span>;<br/></span><span><br/></span><span>@EnableZuulProxy<br/></span><span>@EnableEurekaClient<br/></span><span><strong>@EnableResourceServer</strong><br/></span><span>@SpringBootApplication<br/></span><span>public class </span>AirlinePlanesApplication {<br/><br/> <span>public static void </span><span>main</span>(String[] args) {<br/>  SpringApplication.<span>run</span>(AirlinePlanesApplication.<span>class, </span>args)<span>;<br/></span><span> </span>}<br/><br/>}</pre>
<p>It will protect our application, and it will require the access token to access the application endpoints.</p>
<p>Remember, we need to do the same task for all microservices that we want to protect.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Monitoring the microservices</h1>
                </header>
            
            <article>
                
<p>In the microservice architectural style, monitoring is a crucial part. There are a lot of benefits when we adopt this architecture, such as time to market, source maintenance, and an increase of business performance. This is because we can divide the business goals for different teams, and each team will be responsible for some microservices. Another important characteristic is optimization of computational resources, such as cloud computing costs.</p>
<p>As we know, there is no such thing as a free lunch, and this style brings some drawbacks, such as operational complexity. There are a lot of <em>small services</em> to monitor. There are potentially hundreds of different service instances.</p>
<p>We have implemented some of these services in our infrastructure but until now, we did not have the data to analyze our system health. In this section, we will explore our configured services.</p>
<p>Let's analyze right now!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collecting metrics with Zipkin</h1>
                </header>
            
            <article>
                
<p>We have configured our Zipkin server in the previous chapter. Now we will use this server to analyze our microservices data. Let's do it.</p>
<p>Make some calls to create a flight. The Create Flight API will call the <strong>Auth Service</strong> and the <strong>Flight Service</strong>. Look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="307" src="assets/4d874e0e-edc0-4f67-b1fb-26d3cc25dbce.png" width="532"/></div>
<p>We will take a look at the <kbd>flights</kbd> microservice and the <kbd>planes</kbd> microservice communications. Let's analyze it:</p>
<p>Go to the Zipkin main page, <kbd>http://localhost:9999/</kbd>, select <span class="packt_screen">flights</span>, and then click on <span class="packt_screen">Find a trace</span>. The page should look like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0f5af854-2b36-4d7d-ac13-044f49d8ad00.png"/></div>
<p>As we can see, there is some data on our Zipkin server. Click on <span class="packt_screen">Span</span>, which has the <kbd>flights</kbd> and <kbd>planes</kbd> tags, then we will take a look at this specific trace, and we will be redirected to another page with specific span data, like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9378b77e-cf44-41e0-a450-89baa56db7a6.png"/></div>
<p>On this page, we can see important information, such as the total request time. Then click on the <span class="packt_screen">planes</span> row, where we will be able to see detailed information, as in the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img height="426" src="assets/87230629-9881-4fc9-bd39-fe2636017523.png" width="564"/></div>
<p>Look at the request information. There are some interesting things, such as <kbd>mvc.controller.class</kbd> and <kbd>mvc.controller.method</kbd>. These help developers to troubleshoot errors. Also in the first panel, we have the times of the service's interactions. It is very helpful to find microservices network latencies; for example, it makes environment management easier because we have visual tools to understand data better.</p>
<p>Also, the Zipkin server provides others interesting features to find microservices statistics, such as finding requests that have delayed for more than a specific time. It is very helpful for the operations guys.</p>
<div class="packt_tip">We can find more information about Spring Cloud Sleuth on the documentation page (<a href="http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html">http://cloud.spring.io/spring-cloud-static/spring-cloud-sleuth/2.0.0.M5/single/spring-cloud-sleuth.html</a>) or in the GitHub (<a href="https://github.com/spring-cloud/spring-cloud-sleuth">https://github.com/spring-cloud/spring-cloud-sleuth</a>) project page.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Collection commands statistics with Hystrix</h1>
                </header>
            
            <article>
                
<p>Now, we want to monitor our Hystrix commands. There are several commands in our microservices and probably the most used will be the OAuth token requester, because we always need to have a token to call any microservice in our system. Our Turbine server and Hystrix UI were configured at the beginning of this chapter and we will use these services right now.</p>
<p>Remember, we are using <kbd>spring-cloud-netflix-hystrix-stream</kbd> as an implementation to send Hystrix data to the Turbine server, as it performs better than HTTP and also brings some asynchronous characteristics.</p>
<div class="packt_infobox">Asynchronous calls can make the microservice more resilient. In this case, we will not use HTTP calls (synchronous calls) to register Hystrix Commands statistics. We will use the RabbitMQ queue to register it. In this case, we will put the message in the queue. Also, asynchronous calls make our application more optimized to use computational resources.</div>
<p>Run the Turbine server application and Hystrix UI application. Turbine will aggregate the metrics from the servers. Optionally, you can run several instances of the same service, such as <kbd>flights</kbd>. Turbine will aggregate the statistics properly.</p>
<p>Let's call the Create Flights API; we can use the Postman to do that.</p>
<p>Then we can see the real-time commands statistics. Before that, we will configure <kbd>turbine.stream</kbd> in our Hystrix Dashboard.</p>
<p>Go to the Hystrix Dashboard page: <kbd>http://localhost:50010/hystrix/</kbd>. The following page will be displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img height="361" src="assets/d50d157c-7333-4ef6-a67e-e5dac0d957aa.png" width="545"/></div>
<p>Then we have some work to do. Let's configure our Turbine server stream. Our Turbine stream is running at <kbd>http://localhost:8010/turbine.stream</kbd>. Put this information below the <span class="packt_screen">Hystrix Dashboard</span> information, and then we can click on the <span class="packt_screen">Monitor Stream</span> button.</p>
<p>We will redirect to the Hystrix Commands Dashboard; we called the Create Flights <span>API a few times ago. The commands metrics will be displayed, like the following image:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/42a34f54-fc7b-4bdd-9152-afafc3242b54.png"/></div>
<p>As we can see, we called the Create Flights API eight times. This API uses some commands, such as <kbd>flights.plane-by-id,</kbd> it calls the planes microservice, and the <kbd>flights.request-token</kbd> calls the <kbd>Auth</kbd> service.</p>
<p>Look how easy it is to monitor the commands. Operation guys like the Zipkin server can use this page.</p>
<p>Awesome job, guys, our services integrations are adequately monitored, which makes our microservices adoption more comfortable because we have useful applications to monitor our services instances.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Dockerizing the microservices</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we have used the Fabric8 Maven Docker plugin to enable us to create Docker images, using the Maven goals.</p>
<p>Now, we need to configure our microservices to use this plugin to easily create images for us. It can be helpful to integrate with some Continuous Integration and Delivery tools, such as Jenkins, because we can call the <kbd>docker: build</kbd> goal easily.</p>
<p>Each project has the custom configurations, such as port and image name. We can find the configuration at the GitHub repository. Remember, the configuration is done using the <kbd>pom.xml</kbd>.</p>
<p>The following list has the GitHub repository addresses for all projects; the <kbd>pom.xml</kbd> has the Maven Docker plugin configuration:</p>
<ul>
<li><strong>Flights</strong>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-flights/pom.xml</a></li>
<li><strong>Planes</strong><span>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-planes/pom.xml</a></span></li>
<li><strong>Fares</strong><span>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-fare/pom.xml</a></span></li>
<li><strong>Bookings</strong><span>:</span> <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-booking/pom.xml</a></li>
<li><strong>Admin</strong><span>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/admin/pom.xml</a></span></li>
<li><strong>EDGE</strong><span>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/api-edge/pom.xml</a></span></li>
<li><strong>Passengers</strong><span>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-passengers/pom.xml</a></span></li>
<li><strong>Auth</strong><span>:</span> <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/auth-service/pom.xml</a></li>
<li><strong>Mail</strong><span>:</span> <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/mail-service/pom.xml</a></li>
<li><strong>Turbine</strong><span>:</span> <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/turbine/pom.xml</a></li>
<li><strong>Zipkin</strong><span>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/zipkin-server/pom.xml</a></span></li>
<li><strong>Payments</strong><span>:</span> <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/airline-payments/pom.xml</a></li>
<li><strong>Hystrix-dashboard</strong><span>:</span> <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/hystrix-ui/pom.xml</a></li>
<li><strong>Discovery</strong><span>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/eureka/pom.xml</a></span></li>
<li><strong>Config Server</strong>: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/Chapter09/config-server/pom.xml</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running the system</h1>
                </header>
            
            <article>
                
<p>Now we can run our Docker containers using our images, which were created in the previous section.</p>
<p>We will split the services into two Docker compose files. The first one is about infrastructure services. The second one is about our microservices.</p>
<p>The stacks must be run on the same Docker network, because the service should be connected by the container hostname.</p>
<p>The Docker compose file for infrastructure can be found at GitHub: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-infra.yaml</a>.</p>
<p><span>The Docker compose file for microservices can be found at GitHub: <a href="https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml">https://github.com/PacktPublishing/Spring-5.0-By-Example/blob/master/stacks/docker-compose-micro.yaml</a>.</span></p>
<p>Now, we can run these files using the <kbd>docker-compose</kbd> commands. Type the following commands:</p>
<pre><strong>docker-compose -f docker-compose-infra.yaml up -d</strong><br/><strong>docker-compose -f docker-compose-micro.yaml up -d</strong></pre>
<p>Then the full application will be up and running.</p>
<p>Well done, guys.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have learned some important points on microservices architecture.</p>
<p>We were introduced to some important tools for monitoring the microservices environment. We have learned how the Turbine server can help us to monitor our Hystrix commands in distributed environments.</p>
<p>We were also introduced to the Hystrix Dashboard feature, which helps the developers and operations guys provide a rich dashboard with the commands statistics in near real time.</p>
<p>We learned how Spring Cloud Security enables security features for our microservices, and we implemented the OAuth 2 server, using JWT to enable resilience for our security layer.</p>


            </article>

            
        </section>
    </body></html>