- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: gRPC is an open source framework for general-purpose **Remote Procedure Calls**
    (**RPCs**) across a network. RPCs allow a remote procedure (hosted on a different
    machine) to call as if it were calling a local procedure in connected systems
    without coding the remote interaction details. RPC has a constant meaning in the
    *gRPC* abbreviation. It seems logical that the *g* in gRPC would refer to *Google*
    because it was initially developed there. But the meaning of the *g* has changed
    with every release. For its first release, version 1.0, the *g* in gRPC stood
    for gRPC itself. That is, in version 1.0, it stood for **gRPC** **Remote Procedure
    Call**. In this chapter, you are going to use gRPC version 1.54, where the *g*
    stands for **gracious**. Therefore, you can refer to gRPC as **gracious Remote
    Procedure Call** (for version 1.54). You can find out all the meanings of the
    *g* for different versions at [https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md](https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn the fundamentals of gRPC such as its architecture,
    service definitions, life cycle, server, and client. This chapter will provide
    you with a foundation that you can use to implement gRPC-based APIs. These fundamentals
    will help you to implement inter-service communication in a sample e-commerce
    app.
  prefs: []
  type: TYPE_NORMAL
- en: You will use gRPC-based APIs to develop a basic payment gateway for processing
    payments in an e-commerce app in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: gRPC is pronounced *Jee-Arr-Pee-See*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will explore the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction and gRPC architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding service definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the gRPC life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the gRPC server and gRPC stub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling errors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will understand the gRPC basics, which will
    help you to implement a gRPC-based web service in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains only the theory of gRPC. However, you would generally
    need any gRPC API client such as Insomnia for the development and testing of gRPC-based
    web services.
  prefs: []
  type: TYPE_NORMAL
- en: You are going to learn the fundamentals of gRPC in this chapter, so this chapter
    doesn’t have its own code repository. However, for actual code, you can refer
    to the [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250) code at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11).
  prefs: []
  type: TYPE_NORMAL
- en: How does gRPC work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: gRPC is an open source framework for general-purpose RPCs across a network.
    gRPC supports full-duplex streaming and is also mostly aligned with HTTP/2 semantics.
    It supports different media formats, such as **Protocol Buffers** (**Protobuf**),
    JSON, XML, and Thrift. Protobuf is the default media format. The use of Protobuf
    aces the others because of higher performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC brings the best of **REST** (**Representational State Transfer**) and
    RPC to the table and is well suited for distributed network communication through
    APIs. It offers some prolific features, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is designed for a highly scalable distributed system and offers *low latency*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers load balancing and failover.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be integrated easily at the application layer for interaction with flow
    control because of its layered design.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports cascade call cancellation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It offers wide communication — mobile app to server, web app to server, and
    any gRPC client app to the gRPC server app on different machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’re already aware of REST and its implementation. Let’s find out the differences
    between REST and gRPC in the next subsection, which gives you a different perspective
    and allows you to choose between REST or gRPC based on your requirements and use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: REST versus gRPC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: gRPC is based on client-server architecture, whereas this is not true for REST.
  prefs: []
  type: TYPE_NORMAL
- en: Both gRPC and REST leverage the HTTP protocol. gRPC supports HTTP/2 specifications
    and full-duplex streaming communication in contrast to REST, which serves well
    for various scenarios such as voice or video calls.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass payloads using query parameters, path parameters, and the request
    body in REST. This means that the request payload/data can be passed using different
    sources that lead to the parsing of the payload/data from different sources, which
    adds latency and complexity. On the other hand, gRPC performs better than REST
    as it uses the static paths and single source of the request payload.
  prefs: []
  type: TYPE_NORMAL
- en: As you know, the REST response error depends on HTTP status codes, whereas gRPC
    has formalized the set of errors to make it well aligned with APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The REST API is more flexible in its implementation because it is purely dependent
    on HTTP. This gives you flexibility, but you need standards and conventions for
    strict verification and validation. But do you know why you need these strict
    verifications and validations? It is because you can implement an API in different
    ways. For example, you can delete a resource using any HTTP method instead of
    just using the `HTTP DELETE` method, and this simply sounds horrific.
  prefs: []
  type: TYPE_NORMAL
- en: On top of everything mentioned, gRPC is also built for supporting and handling
    call cancellations, load balancing, and failovers.
  prefs: []
  type: TYPE_NORMAL
- en: REST is mature and widely adopted, but gRPC brings its advantages. Therefore,
    you can choose between them based on their pros and cons. (Mind you, we haven’t
    yet discussed GraphQL, which brings its own offerings. You will learn about GraphQL
    in [*Chapter 13*](B19349_13.xhtml#_idTextAnchor288), *Getting Started with GraphQL*,
    and [*Chapter 14*](B19349_14.xhtml#_idTextAnchor313), *GraphQL API Development*
    *and Testing*.)
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find out whether we can use gRPC for web communication like REST in the
    next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Can I call the gRPC server from web browsers and mobile apps?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of course, you can. The gRPC framework is designed for communication in distributed
    systems and is mostly aligned with HTTP/2 semantics. You can call a gRPC API from
    a mobile app, just like calling any local object. That’s the beauty of gRPC! It
    supports inter-service communication across the intranet and internet and calls
    from the mobile app and web browser to the gRPC server. Therefore, you can utilize
    it for all kinds of communications.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC for web (that is, `gRPC-web`) was quite new in 2018, but now (in 2023),
    it is getting more recognition and is especially being used for **Internet of
    Things** (**IoT**) applications. Ideally, you should adopt it first for your internal
    inter-service communications and then for web/mobile server communication.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s find out more about its architecture in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know the gRPC architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'gRPC is a general-purpose RPC-based framework. It works very well in the RPC
    style, which involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you define the service interface, which includes method signatures, with
    their parameters and return types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you implement the defined service interface as a part of the gRPC server.
    You are now ready to serve the remote calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, you need the stub for clients, which you can generate using the service
    interface. The client application calls the stub, which is a local call. In turn,
    the stub communicates with the gRPC server, and the returned value is passed to
    the gRPC client. This is shown in the following diagram:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.1 – gRPC client-server architecture](img/Figure_10.1_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.1 – gRPC client-server architecture
  prefs: []
  type: TYPE_NORMAL
- en: For client applications, it is just a local call to the stub to get the response.
    You can have a server on either the same machine or a different machine. This
    makes it easier to write distributed services. It is an ideal tool for writing
    microservices. gRPC is language-independent. You can write servers and clients
    in different languages. This provides a lot of flexibility for development.
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC is a layered architecture that has the following layers to make remote
    calling possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.proto` extension if the interface is defined using Protobuf.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`connected` or `idle`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Transport**: This is the lowest layer and uses HTTP/2 as its protocol. Therefore,
    gRPC provides full-duplex communication and multiplex parallel calls over the
    same network connection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can develop a gRPC-based service by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the service interface using the `.proto` file (Protobuf).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the implementation of the service interface defined in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a gRPC server and register the service with it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate the service stub and use it with the gRPC client.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll implement the actual gRPC service in the next chapter, [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250),
    *gRPC API Development* *and Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC stub
  prefs: []
  type: TYPE_NORMAL
- en: A stub is an object that exposes service interfaces. The gRPC client calls the
    stub method, hooks the call to the server, and gets the response back.
  prefs: []
  type: TYPE_NORMAL
- en: You need to understand Protobuf to define the service interfaces. Let’s explore
    it in the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: How gRPC uses Protobuf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Protobuf was created in 2001 and was publicly made available in 2008\. It was
    also used by Google’s microservice-based system, Stubby.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC also works well with JSON and other media types. However, you’ll define
    the service interfaces using Protobuf because it is known for its performance.
    It allows formal contracts, better bandwidth optimization, and code generation.
    Protobuf is also the default format for gRPC. gRPC makes use of Protobuf not only
    for data serialization but also for code generation. Protobuf serializes data
    and, unlike JSON, YAML is not human-readable. Let’s see how it is built.
  prefs: []
  type: TYPE_NORMAL
- en: 'Protobuf messages contain a series of key-value pairs. The key specifies the
    `message` field and its type. Let’s examine the following `Employee` message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s represent this message using Protobuf (with an `id` value of `299` and
    a `firstName` value of `Scott`), as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Employee message representation using Protobuf](img/Figure_10.2_B19349.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10.2 – Employee message representation using Protobuf
  prefs: []
  type: TYPE_NORMAL
- en: The `Id` and `firstName` fields are tagged with numbers, sequenced `1` and `2`,
    respectively, which is required for serialization. The wire type is another aspect
    that provides information to find the length of the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contains the wire types and their respective meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Wire Type** | **Meaning** | **Used For** |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | Var int(variable-length integer) | `int32`, `int64`, `uint32`, `uint64`,
    `sint32`, `sint64`, `bool`, `enum` |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | 64-bit | `fixed64`, `sfixed64`, `double` |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Length-delimited | `string`, `bytes`, embedded messages, packed repeated
    fields |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Start group | `groups` (deprecated) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | End group | `groups` (deprecated) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 32-bit | `fixed32`, `sfixed32`, `float` |'
  prefs: []
  type: TYPE_TB
- en: A Protobuf file is created with the `.proto` extension. You define service interfaces
    in the form of method signatures and messages (objects), which are referred to
    in method signatures. These messages can be method parameters or returned types.
    You can compile a defined service interface with the `protoc` compiler, which
    generates the classes for interfaces and given messages. Similarly, you can also
    generate the stubs for the gRPC client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following sample `.``proto` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Sample service interface of Employee
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s understand this code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: The first line represents the Protobuf version denoted by the `syntax` keyword.
    The value of `syntax` (`proto3`) tells the compiler that version 3 of Protobuf
    is used. The default version is `proto2`. Protobuf version 3 offers more features
    and simplified syntax and supports more languages. gRPC recommends using Protobuf
    version 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you define the `proto` package name using the `package` keyword followed
    by the package name. It prevents name clashes among message types.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you use the `option` keyword to define the Java package name using the
    `java_package` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you use the `option` keyword again to generate a separate file for each
    root-level message type using the `java_multiple_files` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you define the messages, which are nothing but objects, using the `messages`
    keyword. The message and its fields are defined using the strong types, which
    define the objects with exact specifications. You can define nested messages just
    like nested classes in Java. The last point contains the table of Protobuf types
    that you can use for defining the types of `message` fields.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use `Employee.Address` to define the `address` field in other messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The tagging of fields marked with a sequence number is required because it is
    used for serialization and parsing binary messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that you cannot change the message structure once it is serialized.
  prefs: []
  type: TYPE_NORMAL
- en: Service definitions are defined using the `service` keyword. A service definition
    contains the methods. You can define methods using the `rpc` keyword. Please refer
    to the `EmployeeService` service definition for reference. You’ll explore more
    about service definitions in the next subsection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Protobuf has predefined types (scalar types). A `message` field can have one
    of the Protobuf scalar types. When we compile the `.proto` file, it converts the
    `message` field into its respective language type. The following table defines
    the mapping between Protobuf types and Java types:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| **Protobuf types** | **Java types** | **Remarks** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Double` | `Double` | Like Java type `double`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Float` | `Float` | Like Java type `float`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | `Int` | Use `sint32` if the field contains negative values because
    it uses variable-length encoding, which is inefficient for encoding negative numbers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | `Long` | Use `sint64` if the field contains negative values because
    it uses variable-length encoding, which is inefficient for encoding negative numbers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `uint32` | `Int` | It uses variable-length encoding. Use `fixed32` if values
    are greater than 228. |'
  prefs: []
  type: TYPE_TB
- en: '| `uint64` | `Long` | It uses variable-length encoding. Use `fixed64` if values
    are greater than 256. |'
  prefs: []
  type: TYPE_TB
- en: '| `sint32` | `Int` | More efficient for encoding negative numbers because it
    contains a signed `int` value. It uses variable-length encoding. |'
  prefs: []
  type: TYPE_TB
- en: '| `sint64` | `Long` | More efficient for encoding negative numbers because
    it contains a signed `int` value. It uses variable-lengthencoding. |'
  prefs: []
  type: TYPE_TB
- en: '| `fixed32` | `int` | Always 4 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `fixed64` | `long` | Always 8 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| `sfixed32` | `int` | Always 4 bytes. More efficient for encoding values greater
    than 228. |'
  prefs: []
  type: TYPE_TB
- en: '| `sfixed64` | `long` | Always 8 bytes. More efficient for encoding values
    greater than 256. |'
  prefs: []
  type: TYPE_TB
- en: '| `Bool` | `boolean` | `true` or `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | `String` | Contains UTF-8 encoded string or 7-bit ASCII text,
    which should not be longer than 232. |'
  prefs: []
  type: TYPE_TB
- en: '| `Bytes` | `ByteString` | Contains an arbitrary sequence of bytes, which should
    not be longer than 232. |'
  prefs: []
  type: TYPE_TB
- en: 'Protobuf also allows you to define the enumeration types (using the `enum`
    keyword) and maps (using the `map<keytype, valuetype>` keyword). Please refer
    to the following code for examples of enumeration and map types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding sample code creates the `Employee` message, which has a `Grade`
    enumeration field with values such as `I_GRADE`. The `nominees` field is a map
    that has a key with a `string` type and a value with an `int32` type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore service definitions further in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding service definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You define a service by specifying its methods with the respective parameters
    and return types. These methods are exposed by the server, which can be called
    remotely. You defined the `EmployeeService` definition in the previous subsection,
    as shown in the next code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, `Create` is a method exposed by the `EmployeeService` service definition.
    Messages used in the `Create` service should also be defined as a part of the
    service definition. The `Create` service method is a unary service method because
    the client sends a single request object and receives a single response object
    in return from the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dig further into the types of service methods offered by gRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unary**: We have already discussed the unary service method in the previous
    example. This would have a one-way response for a single request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server streaming**: In these types of service methods, the client sends a
    single object to the server and receives the stream response in return. This stream
    contains the sequence of messages. The stream is kept open until the client receives
    all the messages. The message sequence order is guaranteed by gRPC. In the following
    example, the client will keep receiving the live score messages until the match
    is over:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Client streaming**: In these types of service methods, the client sends a
    sequence of messages to the server and receives a response object in return. The
    stream is kept open until the client sends all the messages. The message sequence
    order is guaranteed by gRPC. Once all the messages are sent by the client, it
    waits for the server’s response. In the following example, a client sends the
    data messages to the server until all the data records are sent, and it then waits
    for the report:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Bidirectional streaming**: This is the simultaneous execution of client and
    server streaming. It means both the server and client send a sequence of messages
    using a read-write stream. Here, the order of the sequence is preserved. However,
    these two streams operate independently. Therefore, each can read and write in
    whatever order they like. The server can read and reply to the messages one by
    one or at once or can have any combination. In the following example, processed
    records can be sent immediately one by one or can be sent later in different batches:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that you have learned about the gRPC service definitions, let’s explore
    the RPC life cycle in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the RPC life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, you learned about four types of service definitions.
    Each type of service definition has its own life cycle. Let’s find out more about
    the life cycle of each service definition in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`A stub` also provides the server client’s metadata, the method name, and the
    specified deadline, if applicable, with notification.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metadata** is data about the RPC in the form of key-value pairs, such as
    timeout and authentication details.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, in response, the server sends back its initial metadata. Whether the server
    sends initial metadata immediately or after receiving the client’s request message
    depends on the application. But the server must send it before any response.
  prefs: []
  type: TYPE_NORMAL
- en: The server works on the request and prepares the response after receiving the
    client’s request message. The server sends back the response with the status (code
    and optional message) and optional trailing metadata for successful calls.
  prefs: []
  type: TYPE_NORMAL
- en: The client receives a response and completes the call (for a status of `OK`,
    such as `HTTP` `status 200`).
  prefs: []
  type: TYPE_NORMAL
- en: '*The life cycle of a server-streaming RPC*: The life cycle of a server-streaming
    RPC is almost the same as a unary RPC. It follows the same steps. The only difference
    is the way the response is sent because of the stream response. The server sends
    messages as streams until all the messages are sent. In the end, the server sends
    back the response with the status (code and optional message) and optional trailing
    metadata and completes the server-side processing. The client completes the life
    cycle once it has all the server’s messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The life cycle of a client-streaming RPC*: The life cycle of a client-streaming
    RPC is almost the same as a unary RPC. It follows the same steps. The only difference
    is the way the request is sent because of the stream request. The client sends
    messages as streams until all the messages are sent to the server. The server
    sends back the single message response with the status (code and optional message)
    and optional trailing metadata for successful calls. The server sends the response
    after receiving all the client’s messages in idle scenarios. The client completes
    the life cycle once it receives the server message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The life cycle of a bidirectional streaming RPC*: The first two steps in the
    life cycle of a bidirectional streaming RPC are the same as a unary RPC. Streaming
    processing from both sides is application specific. Both the server and client
    can read and write messages in any order because the two streams are independent
    of each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The server can process streams of request messages sent by the client in any
    order. For example, the server and client can play ping-pong: the client sends
    the request message and the server processes it. Again, the client sends the request
    message, and the server processes it, and the process, as you know, goes on. Or
    the server waits until it receives all the client’s messages before it writes
    its messages.'
  prefs: []
  type: TYPE_NORMAL
- en: The client completes the life cycle once it receives all the server messages.
  prefs: []
  type: TYPE_NORMAL
- en: Events that impact the life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following events may impact the life cycle of the RPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DEADLINE_EXCEEDED` error. Similarly, the server can query to find out whether
    a particular RPC has timed out, or how much time is left to complete the RPC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timeout configuration is language-specific. Some language APIs support timeouts
    (durations of time), and some support deadlines (a fixed point in time). APIs
    may have a default value of deadline/timeout, and some may not.
  prefs: []
  type: TYPE_NORMAL
- en: '**RPC termination**: There are a few scenarios where the RPC gets terminated
    because both the client and server make independent and local determinations of
    the success of the call, and their conclusions may not match. For example, the
    server may finish its part by sending all its messages, but it may fail from the
    client’s side because responses have arrived after the timeout. Another scenario
    would be when a server decides to complete the RPC before the client sends all
    messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Canceling an RPC**: gRPC has a provision to cancel the RPC at any time by
    either the server or client. This terminates the RPC immediately. However, changes
    made before the cancellation are not rolled back.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s explore the gRPC server and stub a bit more in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the gRPC server and gRPC stub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you closely observe *Figure 10**.1*, you’ll find that the gRPC server and
    gRPC stub are core parts of the implementation because gRPC is based on the client-server
    architecture. Once you define the service, you can generate both service interfaces
    and the stub using the Protobuf compiler, `protoc`, with the gRPC Java plugin.
    You’ll find a practical example in [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following types of files are generated by the compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Models**: It generates all the messages (that is, models) defined in the
    service definition file, which contains the Protobuf code to serialize, deserialize,
    and fetch the types of request and response messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**gRPC Java files**: It contains the service base interface and stubs. The
    base interface is implemented and then used as a part of the gRPC server. Stubs
    are used by the clients for communication with the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, you need to implement the interface, as shown in the following code
    for `EmployeeService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you implement the interface, you can run the gRPC server to serve the
    requests from gRPC clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'For clients, first, you need to create the channel using `ChannelBuilder`,
    and then you can use the created channels to create stubs, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, both blocking and asynchronous stubs have been created using the channel
    built using the `ManageChannelBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore error handling in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling errors and error status codes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike REST, which makes use of the HTTP status codes, gRPC uses a `Status`
    model, which contains its error codes and optional error message (string).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you remember, you have used the special class called `Error` to contain
    the error details because HTTP error codes contain limited information. Similarly,
    the gRPC error `Status` model is limited to code and an optional message (string).
    You don''t have sufficient error details for the client to use to handle the error
    or retry. You can make use of the richer error model as described at [https://cloud.google.com/apis/design/errors#error_model](https://cloud.google.com/apis/design/errors#error_model),
    which allows you to pass detailed error information back to the client. You can
    also find the error models in the next code block for quick reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `details` field contains extra information, and you can use it to pass relevant
    information such as `RetryInfo`, `DebugInfo`, `QuotaFailure`, `ErrorInfo`, `PreconditionFailure`,
    `BadRequest`, `RequestInfo`, `ResourceInfo`, `Help`, and `LocalizedMethod`. All
    these message types are available at [https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto](https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto).
  prefs: []
  type: TYPE_NORMAL
- en: These richer error models are described using Protobuf. If you would like to
    use richer error models, you must make sure that support libraries are aligned
    with the practical use of APIs, as described for Protobuf.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like REST, errors can be raised by the RPC for various reasons, such as network
    failure or data validation. Let’s have a look at the following REST error codes
    and their respective gRPC counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **HTTP** **Status Code** | **gRPC** **Status Code** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | `INVALID_ARGUMENT` | For invalid arguments. |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | `FAILED_PRECONDITION` | The action could not be performed due to
    a failed pre-condition. |'
  prefs: []
  type: TYPE_TB
- en: '| `400` | `OUT_OF_RANGE` | If an invalid range is specified by the client.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `401` | `UNAUTHENTICATED` | If the client’s request is not authenticated,
    such as having a missing or expired token. |'
  prefs: []
  type: TYPE_TB
- en: '| `403` | `PERMISSION_DENIED` | The client does not have the sufficient permission.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `404` | `NOT_FOUND` | The requested resource was not found. |'
  prefs: []
  type: TYPE_TB
- en: '| `409` | `ABORTED` | A conflict for read-write operations or any concurrency
    conflict. |'
  prefs: []
  type: TYPE_TB
- en: '| `409` | `ALREADY_EXISTS` | If the request is for creating a new resource
    that already exists. |'
  prefs: []
  type: TYPE_TB
- en: '| `429` | `RESOURCE_EXHAUSTED` | If the request reaches the API rate limiting.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `499` | `CANCELLED` | If the request is canceled by the client. |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | `DATA_LOSS` | For unrecoverable data loss or corruption. |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | `UNKNOWN` | For an unknown error at the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `500` | `INTERNAL` | For an internal server error. |'
  prefs: []
  type: TYPE_TB
- en: '| `501` | `NOT_IMPLEMENTED` | API not implemented by the server. |'
  prefs: []
  type: TYPE_TB
- en: '| `502` | `N/A` | Error due to unreachable network or network misconfiguration.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `503` | `UNAVAILABLE` | The server is down or unavailable due to any reason.
    The client can perform a retry on such errors. |'
  prefs: []
  type: TYPE_TB
- en: '| `504` | `DEADLINE_EXCEEDED` | Either request doesn’t finish within the deadline.
    |'
  prefs: []
  type: TYPE_TB
- en: gRPC error codes are more readable as you don’t need mapping to understand the
    number codes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored Protobuf, IDL, and the serialization utility.
    You also explored gRPC fundamentals such as service definitions, messages, server
    interfaces, and methods. You compared gRPC with REST. I hope this has given you
    enough perspective to understand gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned about the gRPC life cycles, servers, and clients with stubs.
    You covered Protobuf, gRPC architecture, and gRPC fundamentals, which will allow
    you to develop gRPC-based APIs and services.
  prefs: []
  type: TYPE_NORMAL
- en: You will make use of the fundamentals you learned in this chapter in the next
    chapter to implement the gRPC server and client.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is RPC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How is gRPC different in comparison to REST and which one should be used?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which type of service method is useful when you want to view the latest tweets
    or do similar types of work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RPC stands for Remote Procedure Call. A client can call an exposed procedure
    on a remote server, which is just like calling a local procedure, but it gets
    executed on a remote server. An RPC is best suited for inter-service communication
    in connected systems.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: gRPC is based on the client-server architecture, whereas this is not true for
    REST. gRPC also supports full-duplex streaming communication in contrast to REST.
    gRPC performs better than REST as it uses static paths and a single source of
    the request payload.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A REST response error depends on HTTP status codes, whereas gRPC has formalized
    the set of errors to make it well aligned with APIs. gRPC has also been built
    to support and handle call cancellations, load balancing, and failovers. For more
    information, please refer to the *REST versus* *gRPC* subsection.
  prefs: []
  type: TYPE_NORMAL
- en: You should use the server-streaming RPC method because you want to receive the
    latest messages from the server, such as tweets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find out more at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'gRPC documentation: [https://grpc.io/](https://grpc.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Practical* *gRPC*: [https://www.packtpub.com/in/web-development/practical-grpc](https://www.packtpub.com/in/web-development/practical-grpc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
