- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Getting Started with gRPC
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用gRPC
- en: gRPC is an open source framework for general-purpose **Remote Procedure Calls**
    (**RPCs**) across a network. RPCs allow a remote procedure (hosted on a different
    machine) to call as if it were calling a local procedure in connected systems
    without coding the remote interaction details. RPC has a constant meaning in the
    *gRPC* abbreviation. It seems logical that the *g* in gRPC would refer to *Google*
    because it was initially developed there. But the meaning of the *g* has changed
    with every release. For its first release, version 1.0, the *g* in gRPC stood
    for gRPC itself. That is, in version 1.0, it stood for **gRPC** **Remote Procedure
    Call**. In this chapter, you are going to use gRPC version 1.54, where the *g*
    stands for **gracious**. Therefore, you can refer to gRPC as **gracious Remote
    Procedure Call** (for version 1.54). You can find out all the meanings of the
    *g* for different versions at [https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md](https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是一个用于网络中通用远程过程调用（RPC）的开源框架。RPC允许远程过程（托管在不同的机器上）像调用本地过程一样调用，而无需编写远程交互的详细信息。RPC在*gRPC*缩写中具有恒定的意义。看起来很合理，gRPC中的*g*代表*Google*，因为它最初是在那里开发的。但是，*g*的含义随着每个版本的发布而改变。对于其第一个版本1.0，gRPC中的*g*代表gRPC本身。也就是说，在版本1.0中，它代表**gRPC**
    **远程过程调用**。在本章中，你将使用gRPC版本1.54，其中*g*代表**优雅**。因此，你可以将gRPC称为**优雅的远程过程调用**（针对版本1.54）。你可以在[https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md](https://github.com/grpc/grpc/blob/master/doc/g_stands_for.md)找到不同版本中*g*的所有含义。
- en: In this chapter, you’ll learn the fundamentals of gRPC such as its architecture,
    service definitions, life cycle, server, and client. This chapter will provide
    you with a foundation that you can use to implement gRPC-based APIs. These fundamentals
    will help you to implement inter-service communication in a sample e-commerce
    app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习gRPC的基础知识，例如其架构、服务定义、生命周期、服务器和客户端。本章将为你提供一个基础，你可以用它来实现基于gRPC的API。这些基础知识将帮助你在一个示例电子商务应用中实现服务间通信。
- en: You will use gRPC-based APIs to develop a basic payment gateway for processing
    payments in an e-commerce app in the next chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在下一章使用基于gRPC的API来开发一个基本的支付网关，用于处理电子商务应用中的支付。
- en: Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: gRPC is pronounced *Jee-Arr-Pee-See*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC发音为*Jee-Arr-Pee-See*。
- en: 'You will explore the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章中探索以下主题：
- en: Introduction and gRPC architecture
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍和gRPC架构
- en: Understanding service definitions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解服务定义
- en: Exploring the gRPC life cycle
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索gRPC生命周期
- en: Understanding the gRPC server and gRPC stub
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解gRPC服务器和gRPC存根
- en: Handling errors
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理错误
- en: After completing this chapter, you will understand the gRPC basics, which will
    help you to implement a gRPC-based web service in the next chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将理解gRPC的基础知识，这将有助于你在下一章实现基于gRPC的Web服务。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains only the theory of gRPC. However, you would generally
    need any gRPC API client such as Insomnia for the development and testing of gRPC-based
    web services.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅包含gRPC的理论。然而，在开发和使用基于gRPC的Web服务时，你通常需要一个gRPC API客户端，如Insomnia。
- en: You are going to learn the fundamentals of gRPC in this chapter, so this chapter
    doesn’t have its own code repository. However, for actual code, you can refer
    to the [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250) code at [https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章学习gRPC的基础知识，因此本章没有自己的代码仓库。然而，对于实际代码，你可以参考[第11章](B19349_11.xhtml#_idTextAnchor250)的代码，位于[https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11](https://github.com/PacktPublishing/Modern-API-Development-with-Spring-6-and-Spring-Boot-3/tree/dev/Chapter11)。
- en: How does gRPC work?
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gRPC是如何工作的？
- en: gRPC is an open source framework for general-purpose RPCs across a network.
    gRPC supports full-duplex streaming and is also mostly aligned with HTTP/2 semantics.
    It supports different media formats, such as **Protocol Buffers** (**Protobuf**),
    JSON, XML, and Thrift. Protobuf is the default media format. The use of Protobuf
    aces the others because of higher performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是一个用于网络中通用RPC的开源框架。gRPC支持全双工流式传输，并且与HTTP/2语义大致一致。它支持不同的媒体格式，如**协议缓冲区**（**Protobuf**）、JSON、XML和Thrift。Protobuf是默认的媒体格式。由于性能更高，使用Protobuf优于其他格式。
- en: 'gRPC brings the best of **REST** (**Representational State Transfer**) and
    RPC to the table and is well suited for distributed network communication through
    APIs. It offers some prolific features, as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC将**REST**（表示状态传输）和RPC的最佳之处带到了桌面上，非常适合通过API进行分布式网络通信。它提供了一些显著的功能，如下所示：
- en: It is designed for a highly scalable distributed system and offers *low latency*.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是为高度可扩展的分布式系统设计的，并提供了*低延迟*。
- en: It offers load balancing and failover.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了负载均衡和故障转移。
- en: It can be integrated easily at the application layer for interaction with flow
    control because of its layered design.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其分层设计，它可以在应用层轻松集成，以进行与流控制的交互。
- en: It supports cascade call cancellation.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它支持级联调用取消。
- en: It offers wide communication — mobile app to server, web app to server, and
    any gRPC client app to the gRPC server app on different machines.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了广泛的通信——移动应用到服务器、Web应用到服务器以及不同机器上的任何gRPC客户端应用到gRPC服务器应用。
- en: You’re already aware of REST and its implementation. Let’s find out the differences
    between REST and gRPC in the next subsection, which gives you a different perspective
    and allows you to choose between REST or gRPC based on your requirements and use
    case.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了REST及其实现。让我们在下一小节中找出REST和gRPC之间的差异，这为你提供了不同的视角，并允许你根据你的需求和用例在REST或gRPC之间进行选择。
- en: REST versus gRPC
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: REST与gRPC
- en: gRPC is based on client-server architecture, whereas this is not true for REST.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC基于客户端-服务器架构，而REST则不是。
- en: Both gRPC and REST leverage the HTTP protocol. gRPC supports HTTP/2 specifications
    and full-duplex streaming communication in contrast to REST, which serves well
    for various scenarios such as voice or video calls.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 与REST相比，gRPC和REST都利用了HTTP协议。gRPC支持HTTP/2规范和全双工流通信，而REST在语音或视频通话等场景中表现良好。
- en: You can pass payloads using query parameters, path parameters, and the request
    body in REST. This means that the request payload/data can be passed using different
    sources that lead to the parsing of the payload/data from different sources, which
    adds latency and complexity. On the other hand, gRPC performs better than REST
    as it uses the static paths and single source of the request payload.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在REST中，你可以通过查询参数、路径参数和请求体传递有效载荷。这意味着请求有效载荷/数据可以通过不同的来源传递，从而导致从不同来源解析有效载荷/数据，这增加了延迟和复杂性。另一方面，gRPC由于使用静态路径和请求有效载荷的单个来源，在性能上优于REST。
- en: As you know, the REST response error depends on HTTP status codes, whereas gRPC
    has formalized the set of errors to make it well aligned with APIs.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，REST响应错误依赖于HTTP状态码，而gRPC已经将错误集合形式化，使其与API良好对齐。
- en: The REST API is more flexible in its implementation because it is purely dependent
    on HTTP. This gives you flexibility, but you need standards and conventions for
    strict verification and validation. But do you know why you need these strict
    verifications and validations? It is because you can implement an API in different
    ways. For example, you can delete a resource using any HTTP method instead of
    just using the `HTTP DELETE` method, and this simply sounds horrific.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 由于REST API完全依赖于HTTP，其实现更加灵活。这给了你灵活性，但你需要标准和规范来进行严格的验证和验证。但你是否知道为什么你需要这些严格的验证和验证？这是因为你可以以不同的方式实现API。例如，你可以使用任何HTTP方法而不是仅使用`HTTP
    DELETE`方法来删除资源，这听起来很简单。
- en: On top of everything mentioned, gRPC is also built for supporting and handling
    call cancellations, load balancing, and failovers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之上，gRPC还旨在支持和处理调用取消、负载均衡和故障转移。
- en: REST is mature and widely adopted, but gRPC brings its advantages. Therefore,
    you can choose between them based on their pros and cons. (Mind you, we haven’t
    yet discussed GraphQL, which brings its own offerings. You will learn about GraphQL
    in [*Chapter 13*](B19349_13.xhtml#_idTextAnchor288), *Getting Started with GraphQL*,
    and [*Chapter 14*](B19349_14.xhtml#_idTextAnchor313), *GraphQL API Development*
    *and Testing*.)
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: REST成熟且被广泛采用，但gRPC带来了其优势。因此，你可以根据它们的优缺点来选择它们。（请注意，我们尚未讨论GraphQL，它带来了自己的特色。你将在[*第13章*](B19349_13.xhtml#_idTextAnchor288)“开始使用GraphQL”和[*第14章*](B19349_14.xhtml#_idTextAnchor313)“GraphQL
    API开发和测试”中了解GraphQL。）
- en: Let’s find out whether we can use gRPC for web communication like REST in the
    next subsection.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一小节中找出我们是否可以使用gRPC像REST一样进行Web通信。
- en: Can I call the gRPC server from web browsers and mobile apps?
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我能否从Web浏览器和移动应用中调用gRPC服务器？
- en: Of course, you can. The gRPC framework is designed for communication in distributed
    systems and is mostly aligned with HTTP/2 semantics. You can call a gRPC API from
    a mobile app, just like calling any local object. That’s the beauty of gRPC! It
    supports inter-service communication across the intranet and internet and calls
    from the mobile app and web browser to the gRPC server. Therefore, you can utilize
    it for all kinds of communications.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以。gRPC 框架是为分布式系统中的通信而设计的，并且主要与 HTTP/2 语义一致。您可以从移动应用程序中调用 gRPC API，就像调用任何本地对象一样。这就是
    gRPC 的美妙之处！它支持互联网和内网中的跨服务通信，以及从移动应用程序和网页浏览器到 gRPC 服务器的调用。因此，您可以利用它进行各种通信。
- en: gRPC for web (that is, `gRPC-web`) was quite new in 2018, but now (in 2023),
    it is getting more recognition and is especially being used for **Internet of
    Things** (**IoT**) applications. Ideally, you should adopt it first for your internal
    inter-service communications and then for web/mobile server communication.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC for web（即 `gRPC-web`）在 2018 年相当新颖，但现在（在 2023 年），它获得了更多的认可，并且特别用于 **物联网**（**IoT**）应用。理想情况下，您应该首先将其用于您的内部服务间通信，然后用于
    Web/移动服务器通信。
- en: Let’s find out more about its architecture in the next subsection.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一小节中了解更多关于其架构的信息。
- en: Getting to know the gRPC architecture
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解 gRPC 架构
- en: 'gRPC is a general-purpose RPC-based framework. It works very well in the RPC
    style, which involves the following steps:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是一个通用的基于 RPC 的框架。它在 RPC 风格中工作得非常好，涉及以下步骤：
- en: First, you define the service interface, which includes method signatures, with
    their parameters and return types.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您定义服务接口，包括方法签名，以及它们的参数和返回类型。
- en: Then, you implement the defined service interface as a part of the gRPC server.
    You are now ready to serve the remote calls.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您将定义的服务接口作为 gRPC 服务器的一部分进行实现。现在您已准备好提供远程调用服务。
- en: 'Next, you need the stub for clients, which you can generate using the service
    interface. The client application calls the stub, which is a local call. In turn,
    the stub communicates with the gRPC server, and the returned value is passed to
    the gRPC client. This is shown in the following diagram:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要客户端的存根，您可以使用服务接口生成它。客户端应用程序调用存根，这是一个本地调用。然后，存根与 gRPC 服务器通信，并将返回值传递给 gRPC
    客户端。这如图所示：
- en: '![Figure 10.1 – gRPC client-server architecture](img/Figure_10.1_B19349.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – gRPC 客户端-服务器架构](img/Figure_10.1_B19349.jpg)'
- en: Figure 10.1 – gRPC client-server architecture
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – gRPC 客户端-服务器架构
- en: For client applications, it is just a local call to the stub to get the response.
    You can have a server on either the same machine or a different machine. This
    makes it easier to write distributed services. It is an ideal tool for writing
    microservices. gRPC is language-independent. You can write servers and clients
    in different languages. This provides a lot of flexibility for development.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端应用程序，它只是对存根的本地调用以获取响应。您可以在同一台机器或不同机器上有一个服务器。这使得编写分布式服务变得更容易。它是编写微服务的理想工具。gRPC
    是语言无关的。您可以使用不同的语言编写服务器和客户端。这为开发提供了很大的灵活性。
- en: 'gRPC is a layered architecture that has the following layers to make remote
    calling possible:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 是一种分层架构，具有以下层以实现远程调用：
- en: '`.proto` extension if the interface is defined using Protobuf.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果接口使用 Protobuf 定义，则为 `.proto` 扩展。
- en: '`connected` or `idle`.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`connected` 或 `idle`。'
- en: '**Transport**: This is the lowest layer and uses HTTP/2 as its protocol. Therefore,
    gRPC provides full-duplex communication and multiplex parallel calls over the
    same network connection.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**传输层**：这是最低层，使用 HTTP/2 作为其协议。因此，gRPC 提供了全双工通信和在同一网络连接上并行调用复用。 '
- en: 'You can develop a gRPC-based service by following these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下步骤开发基于 gRPC 的服务：
- en: Define the service interface using the `.proto` file (Protobuf).
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `.proto` 文件（Protobuf）定义服务接口。
- en: Write the implementation of the service interface defined in *step 1*.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写在 *步骤 1* 中定义的服务接口的实现。
- en: Create a gRPC server and register the service with it.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 gRPC 服务器并将其服务注册到其中。
- en: Generate the service stub and use it with the gRPC client.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成服务存根并将其与 gRPC 客户端一起使用。
- en: You’ll implement the actual gRPC service in the next chapter, [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250),
    *gRPC API Development* *and Testing*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在下一章中实现实际的 gRPC 服务，[*第 11 章*](B19349_11.xhtml#_idTextAnchor250)，*gRPC API
    开发*和*测试*。
- en: gRPC stub
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 存根
- en: A stub is an object that exposes service interfaces. The gRPC client calls the
    stub method, hooks the call to the server, and gets the response back.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 存根是一个暴露服务接口的对象。gRPC 客户端调用存根方法，将调用钩到服务器，并获取响应。
- en: You need to understand Protobuf to define the service interfaces. Let’s explore
    it in the next subsection.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解 Protobuf 来定义服务接口。让我们在下一个小节中探讨它。
- en: How gRPC uses Protobuf
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: gRPC 如何使用 Protobuf
- en: Protobuf was created in 2001 and was publicly made available in 2008\. It was
    also used by Google’s microservice-based system, Stubby.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 创建于 2001 年，并于 2008 年公开提供。它也被 Google 的基于微服务的系统 Stubby 所使用。
- en: gRPC also works well with JSON and other media types. However, you’ll define
    the service interfaces using Protobuf because it is known for its performance.
    It allows formal contracts, better bandwidth optimization, and code generation.
    Protobuf is also the default format for gRPC. gRPC makes use of Protobuf not only
    for data serialization but also for code generation. Protobuf serializes data
    and, unlike JSON, YAML is not human-readable. Let’s see how it is built.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 也很好地与 JSON 和其他媒体类型协同工作。然而，你将使用 Protobuf 定义服务接口，因为它以其性能而闻名。它允许正式的合约、更好的带宽优化和代码生成。Protobuf
    也是 gRPC 的默认格式。gRPC 不仅使用 Protobuf 进行数据序列化，还用于代码生成。Protobuf 序列化数据，与 JSON 不同，YAML
    不可读。让我们看看它是如何构建的。
- en: 'Protobuf messages contain a series of key-value pairs. The key specifies the
    `message` field and its type. Let’s examine the following `Employee` message:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 消息包含一系列键值对。键指定 `message` 字段及其类型。让我们检查以下 `Employee` 消息：
- en: '[PRE0]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let’s represent this message using Protobuf (with an `id` value of `299` and
    a `firstName` value of `Scott`), as shown in the following diagram:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 Protobuf（`id` 值为 `299` 和 `firstName` 值为 `Scott`）表示此消息，如下所示图所示：
- en: '![Figure 10.2 – Employee message representation using Protobuf](img/Figure_10.2_B19349.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.2 – 使用 Protobuf 表示的员工消息](img/Figure_10.2_B19349.jpg)'
- en: Figure 10.2 – Employee message representation using Protobuf
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 使用 Protobuf 表示的员工消息
- en: The `Id` and `firstName` fields are tagged with numbers, sequenced `1` and `2`,
    respectively, which is required for serialization. The wire type is another aspect
    that provides information to find the length of the value.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`Id` 和 `firstName` 字段分别标记为数字，序列 `1` 和 `2`，这是序列化所必需的。线类型是另一个方面，它提供了查找值长度的信息。'
- en: 'The following table contains the wire types and their respective meanings:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 下表包含线类型及其相应的含义：
- en: '| **Wire Type** | **Meaning** | **Used For** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| **线类型** | **含义** | **用途** |'
- en: '| 0 | Var int(variable-length integer) | `int32`, `int64`, `uint32`, `uint64`,
    `sint32`, `sint64`, `bool`, `enum` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 可变长整数 | `int32`、`int64`、`uint32`、`uint64`、`sint32`、`sint64`、`bool`、`enum`
    |'
- en: '| 1 | 64-bit | `fixed64`, `sfixed64`, `double` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 64位 | `fixed64`、`sfixed64`、`double` |'
- en: '| 2 | Length-delimited | `string`, `bytes`, embedded messages, packed repeated
    fields |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 长度分隔 | `string`、`bytes`、嵌入的消息、打包的重复字段 |'
- en: '| 3 | Start group | `groups` (deprecated) |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 开始组 | `groups`（已弃用）|'
- en: '| 4 | End group | `groups` (deprecated) |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 结束组 | `groups`（已弃用）|'
- en: '| 5 | 32-bit | `fixed32`, `sfixed32`, `float` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 32位 | `fixed32`、`sfixed32`、`float` |'
- en: A Protobuf file is created with the `.proto` extension. You define service interfaces
    in the form of method signatures and messages (objects), which are referred to
    in method signatures. These messages can be method parameters or returned types.
    You can compile a defined service interface with the `protoc` compiler, which
    generates the classes for interfaces and given messages. Similarly, you can also
    generate the stubs for the gRPC client.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf 文件以 `.proto` 扩展名创建。你以方法签名和消息（对象）的形式定义服务接口，这些消息在方法签名中引用。这些消息可以是方法参数或返回类型。你可以使用
    `protoc` 编译器编译定义的服务接口，它为接口和给定消息生成类。同样，你也可以为 gRPC 客户端生成存根。
- en: 'Let’s have a look at the following sample `.``proto` file:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例 `.proto` 文件：
- en: Sample service interface of Employee
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 员工的示例服务接口
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s understand this code line by line:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐行理解这段代码：
- en: The first line represents the Protobuf version denoted by the `syntax` keyword.
    The value of `syntax` (`proto3`) tells the compiler that version 3 of Protobuf
    is used. The default version is `proto2`. Protobuf version 3 offers more features
    and simplified syntax and supports more languages. gRPC recommends using Protobuf
    version 3.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一行表示由 `syntax` 关键字表示的 Protobuf 版本。`syntax` 的值（`proto3`）告诉编译器使用 Protobuf 的第
    3 版。默认版本是 `proto2`。Protobuf 版本 3 提供了更多功能，语法简化，并支持更多语言。gRPC 推荐使用 Protobuf 版本 3。
- en: Next, you define the `proto` package name using the `package` keyword followed
    by the package name. It prevents name clashes among message types.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您使用 `package` 关键字定义 `proto` 包名，后跟包名。它防止消息类型之间的名称冲突。
- en: Next, you use the `option` keyword to define the Java package name using the
    `java_package` parameter.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您使用 `option` 关键字通过 `java_package` 参数定义 Java 包名。
- en: Then, you use the `option` keyword again to generate a separate file for each
    root-level message type using the `java_multiple_files` parameter.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您再次使用 `option` 关键字，通过 `java_multiple_files` 参数为每个根级消息类型生成一个单独的文件。
- en: Then, you define the messages, which are nothing but objects, using the `messages`
    keyword. The message and its fields are defined using the strong types, which
    define the objects with exact specifications. You can define nested messages just
    like nested classes in Java. The last point contains the table of Protobuf types
    that you can use for defining the types of `message` fields.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，您使用 `messages` 关键字定义消息，这些消息不过是对象。消息及其字段使用强类型定义，这些类型定义了具有精确规格的对象。您可以像在 Java
    中定义嵌套类一样定义嵌套消息。最后一点包含了您可以使用来定义 `message` 字段类型的 Protobuf 类型表。
- en: You can use `Employee.Address` to define the `address` field in other messages.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `Employee.Address` 在其他消息中定义 `address` 字段。
- en: The tagging of fields marked with a sequence number is required because it is
    used for serialization and parsing binary messages.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记带有序列号的字段的标记是必需的，因为它用于序列化和解析二进制消息。
- en: Please note that you cannot change the message structure once it is serialized.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一旦消息结构被序列化，您就不能更改它。
- en: Service definitions are defined using the `service` keyword. A service definition
    contains the methods. You can define methods using the `rpc` keyword. Please refer
    to the `EmployeeService` service definition for reference. You’ll explore more
    about service definitions in the next subsection.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务定义使用 `service` 关键字进行定义。服务定义包含方法。您可以使用 `rpc` 关键字定义方法。请参考 `EmployeeService`
    服务定义以获取示例。您将在下一小节中了解更多关于服务定义的内容。
- en: 'Protobuf has predefined types (scalar types). A `message` field can have one
    of the Protobuf scalar types. When we compile the `.proto` file, it converts the
    `message` field into its respective language type. The following table defines
    the mapping between Protobuf types and Java types:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Protobuf 有预定义的类型（标量类型）。`message` 字段可以具有 Protobuf 标量类型之一。当我们编译 `.proto` 文件时，它将
    `message` 字段转换为相应的语言类型。以下表格定义了 Protobuf 类型与 Java 类型之间的映射：
- en: '| **Protobuf types** | **Java types** | **Remarks** |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| **Protobuf types** | **Java types** | **备注** |'
- en: '| --- | --- | --- |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `Double` | `Double` | Like Java type `double`. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `Double` | `Double` | 类似于 Java 类型 `double`。 |'
- en: '| `Float` | `Float` | Like Java type `float`. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Float` | `Float` | 类似于 Java 类型 `float`。 |'
- en: '| `int32` | `Int` | Use `sint32` if the field contains negative values because
    it uses variable-length encoding, which is inefficient for encoding negative numbers.
    |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `int32` | `Int` | 如果字段包含负值，请使用 `sint32`，因为它使用可变长度编码，对于编码负数效率较低。 |'
- en: '| `int64` | `Long` | Use `sint64` if the field contains negative values because
    it uses variable-length encoding, which is inefficient for encoding negative numbers.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `int64` | `Long` | 如果字段包含负值，请使用 `sint64`，因为它使用可变长度编码，对于编码负数效率较低。 |'
- en: '| `uint32` | `Int` | It uses variable-length encoding. Use `fixed32` if values
    are greater than 228. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `uint32` | `Int` | 使用可变长度编码。如果值大于 228，请使用 `fixed32`。 |'
- en: '| `uint64` | `Long` | It uses variable-length encoding. Use `fixed64` if values
    are greater than 256. |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `uint64` | `Long` | 使用可变长度编码。如果值大于 256，请使用 `fixed64`。 |'
- en: '| `sint32` | `Int` | More efficient for encoding negative numbers because it
    contains a signed `int` value. It uses variable-length encoding. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `sint32` | `Int` | 对于编码负数更有效，因为它包含一个有符号的 `int` 值。它使用可变长度编码。 |'
- en: '| `sint64` | `Long` | More efficient for encoding negative numbers because
    it contains a signed `int` value. It uses variable-lengthencoding. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `sint64` | `Long` | 对于编码负数更有效，因为它包含一个有符号的 `int` 值。它使用可变长度编码。 |'
- en: '| `fixed32` | `int` | Always 4 bytes. |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `fixed32` | `int` | 总共 4 字节。 |'
- en: '| `fixed64` | `long` | Always 8 bytes. |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `fixed64` | `long` | 总共 8 字节。 |'
- en: '| `sfixed32` | `int` | Always 4 bytes. More efficient for encoding values greater
    than 228. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed32` | `int` | 总共 4 字节。对于编码大于 228 的值更有效。 |'
- en: '| `sfixed64` | `long` | Always 8 bytes. More efficient for encoding values
    greater than 256. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `sfixed64` | `long` | 总共 8 字节。对于编码大于 256 的值更有效。 |'
- en: '| `Bool` | `boolean` | `true` or `false`. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `Bool` | `boolean` | `true` 或 `false`。 |'
- en: '| `String` | `String` | Contains UTF-8 encoded string or 7-bit ASCII text,
    which should not be longer than 232. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `String` | `String` | 包含UTF-8编码的字符串或7位ASCII文本，长度不应超过232。 |'
- en: '| `Bytes` | `ByteString` | Contains an arbitrary sequence of bytes, which should
    not be longer than 232. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `Bytes` | `ByteString` | 包含任意字节序列，长度不应超过232。 |'
- en: 'Protobuf also allows you to define the enumeration types (using the `enum`
    keyword) and maps (using the `map<keytype, valuetype>` keyword). Please refer
    to the following code for examples of enumeration and map types:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Protobuf还允许您定义枚举类型（使用`enum`关键字）和映射（使用`map<keytype, valuetype>`关键字）。请参考以下代码以获取枚举和映射类型的示例：
- en: '[PRE2]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding sample code creates the `Employee` message, which has a `Grade`
    enumeration field with values such as `I_GRADE`. The `nominees` field is a map
    that has a key with a `string` type and a value with an `int32` type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码创建了`Employee`消息，其中包含具有`I_GRADE`等值的`Grade`枚举字段。`nominees`字段是一个具有`string`类型键和`int32`类型值的映射。
- en: Let’s explore service definitions further in the next section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将进一步探讨服务定义。
- en: Understanding service definitions
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解服务定义
- en: 'You define a service by specifying its methods with the respective parameters
    and return types. These methods are exposed by the server, which can be called
    remotely. You defined the `EmployeeService` definition in the previous subsection,
    as shown in the next code block:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过指定方法及其相应的参数和返回类型来定义一个服务。这些方法由服务器暴露，可以远程调用。您在上一小节中定义了`EmployeeService`定义，如下面的代码块所示：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `Create` is a method exposed by the `EmployeeService` service definition.
    Messages used in the `Create` service should also be defined as a part of the
    service definition. The `Create` service method is a unary service method because
    the client sends a single request object and receives a single response object
    in return from the server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Create`是`EmployeeService`服务定义中暴露的方法。在`Create`服务中使用的消息也应作为服务定义的一部分进行定义。`Create`服务方法是一个一元服务方法，因为客户端发送单个请求对象，并从服务器接收单个响应对象。
- en: 'Let’s dig further into the types of service methods offered by gRPC:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨gRPC提供的服务方法类型：
- en: '**Unary**: We have already discussed the unary service method in the previous
    example. This would have a one-way response for a single request.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一元**：我们已经在之前的示例中讨论了一元服务方法。这将针对单个请求有一个单向响应。'
- en: '**Server streaming**: In these types of service methods, the client sends a
    single object to the server and receives the stream response in return. This stream
    contains the sequence of messages. The stream is kept open until the client receives
    all the messages. The message sequence order is guaranteed by gRPC. In the following
    example, the client will keep receiving the live score messages until the match
    is over:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务器流式传输**：在这些类型的服务方法中，客户端向服务器发送单个对象，并接收流式响应。此流包含消息序列。流保持打开状态，直到客户端接收所有消息。gRPC保证了消息序列的顺序。在以下示例中，客户端将一直接收实时比分消息，直到比赛结束：'
- en: '[PRE4]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Client streaming**: In these types of service methods, the client sends a
    sequence of messages to the server and receives a response object in return. The
    stream is kept open until the client sends all the messages. The message sequence
    order is guaranteed by gRPC. Once all the messages are sent by the client, it
    waits for the server’s response. In the following example, a client sends the
    data messages to the server until all the data records are sent, and it then waits
    for the report:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户端流式传输**：在这些类型的服务方法中，客户端向服务器发送一系列消息，并接收一个响应对象。流保持打开状态，直到客户端发送所有消息。gRPC保证了消息序列的顺序。一旦客户端发送所有消息，它将等待服务器的响应。在以下示例中，客户端将发送数据消息到服务器，直到所有数据记录发送完毕，然后等待报告：'
- en: '[PRE5]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Bidirectional streaming**: This is the simultaneous execution of client and
    server streaming. It means both the server and client send a sequence of messages
    using a read-write stream. Here, the order of the sequence is preserved. However,
    these two streams operate independently. Therefore, each can read and write in
    whatever order they like. The server can read and reply to the messages one by
    one or at once or can have any combination. In the following example, processed
    records can be sent immediately one by one or can be sent later in different batches:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向流式**：这是客户端和服务器流式同时执行。这意味着服务器和客户端都使用读写流发送一系列消息。在这里，序列的顺序被保留。然而，这两个流独立操作。因此，每个都可以按它们喜欢的顺序读取和写入。服务器可以逐个读取和回复消息，或者一次性回复，或者有任意组合。在以下示例中，处理过的记录可以立即逐个发送，也可以稍后以不同的批次发送：'
- en: '[PRE6]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that you have learned about the gRPC service definitions, let’s explore
    the RPC life cycle in the next section.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了gRPC服务定义，让我们在下一节中探索RPC的生命周期。
- en: Exploring the RPC life cycle
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索RPC生命周期
- en: 'In the previous section, you learned about four types of service definitions.
    Each type of service definition has its own life cycle. Let’s find out more about
    the life cycle of each service definition in this section:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你了解了四种类型的服务定义。每种类型的服务定义都有自己的生命周期。让我们在本节中了解更多关于每种服务定义生命周期的信息：
- en: '`A stub` also provides the server client’s metadata, the method name, and the
    specified deadline, if applicable, with notification.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`存根`还提供了服务器客户端的元数据、方法名称以及如果适用的话，指定的截止日期，并带有通知。'
- en: '**Metadata** is data about the RPC in the form of key-value pairs, such as
    timeout and authentication details.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**元数据**是以键值对形式存在的关于RPC的数据，例如超时和认证细节。'
- en: Next, in response, the server sends back its initial metadata. Whether the server
    sends initial metadata immediately or after receiving the client’s request message
    depends on the application. But the server must send it before any response.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，作为回应，服务器发送其初始元数据。服务器是立即发送初始元数据还是收到客户端请求消息后发送，取决于应用程序。但服务器必须在任何响应之前发送它。
- en: The server works on the request and prepares the response after receiving the
    client’s request message. The server sends back the response with the status (code
    and optional message) and optional trailing metadata for successful calls.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器在收到客户端请求消息后处理请求并准备响应。服务器发送带有状态（代码和可选消息）以及可选尾部元数据的响应，对于成功的调用。
- en: The client receives a response and completes the call (for a status of `OK`,
    such as `HTTP` `status 200`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端收到响应并完成调用（对于`OK`状态，例如`HTTP`状态200）。
- en: '*The life cycle of a server-streaming RPC*: The life cycle of a server-streaming
    RPC is almost the same as a unary RPC. It follows the same steps. The only difference
    is the way the response is sent because of the stream response. The server sends
    messages as streams until all the messages are sent. In the end, the server sends
    back the response with the status (code and optional message) and optional trailing
    metadata and completes the server-side processing. The client completes the life
    cycle once it has all the server’s messages.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*服务器流式RPC的生命周期*：服务器流式RPC的生命周期几乎与单一RPC相同。它遵循相同的步骤。唯一的区别是由于流式响应，响应的发送方式不同。服务器以流的形式发送消息，直到所有消息都发送完毕。最后，服务器发送带有状态（代码和可选消息）以及可选的尾部元数据的响应，并完成服务器端处理。客户端在收到所有服务器的消息后完成生命周期。'
- en: '*The life cycle of a client-streaming RPC*: The life cycle of a client-streaming
    RPC is almost the same as a unary RPC. It follows the same steps. The only difference
    is the way the request is sent because of the stream request. The client sends
    messages as streams until all the messages are sent to the server. The server
    sends back the single message response with the status (code and optional message)
    and optional trailing metadata for successful calls. The server sends the response
    after receiving all the client’s messages in idle scenarios. The client completes
    the life cycle once it receives the server message.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*客户端流式RPC的生命周期*：客户端流式RPC的生命周期几乎与单一RPC相同。它遵循相同的步骤。唯一的区别是由于流式请求，请求的发送方式不同。客户端以流的形式发送消息，直到所有消息都发送到服务器。服务器发送带有状态（代码和可选消息）以及可选尾部元数据的单个消息响应，对于成功的调用。在空闲场景下，服务器在收到所有客户端的消息后发送响应。客户端在收到服务器消息后完成生命周期。'
- en: '*The life cycle of a bidirectional streaming RPC*: The first two steps in the
    life cycle of a bidirectional streaming RPC are the same as a unary RPC. Streaming
    processing from both sides is application specific. Both the server and client
    can read and write messages in any order because the two streams are independent
    of each other.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*双向流式 RPC 的生命周期*：双向流式 RPC 生命周期的前两个步骤与单一 RPC 相同。流式处理由双方的应用程序特定。服务器和客户端都可以按任何顺序读取和写入消息，因为这两个流相互独立。'
- en: 'The server can process streams of request messages sent by the client in any
    order. For example, the server and client can play ping-pong: the client sends
    the request message and the server processes it. Again, the client sends the request
    message, and the server processes it, and the process, as you know, goes on. Or
    the server waits until it receives all the client’s messages before it writes
    its messages.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以按任何顺序处理客户端发送的请求消息流。例如，服务器和客户端可以玩乒乓球：客户端发送请求消息，服务器处理它。再次，客户端发送请求消息，服务器处理它，这个过程，正如你所知，会继续进行。或者服务器等待接收到客户端的所有消息后，再发送自己的消息。
- en: The client completes the life cycle once it receives all the server messages.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端在接收到所有服务器消息后完成生命周期。
- en: Events that impact the life cycle
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响生命周期的事件
- en: 'The following events may impact the life cycle of the RPC:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下事件可能会影响 RPC 的生命周期：
- en: '`DEADLINE_EXCEEDED` error. Similarly, the server can query to find out whether
    a particular RPC has timed out, or how much time is left to complete the RPC.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DEADLINE_EXCEEDED` 错误。同样，服务器可以查询以确定特定的 RPC 是否超时，或者完成 RPC 剩余多少时间。'
- en: Timeout configuration is language-specific. Some language APIs support timeouts
    (durations of time), and some support deadlines (a fixed point in time). APIs
    may have a default value of deadline/timeout, and some may not.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 超时配置是语言特定的。一些语言 API 支持超时（时间长度），而一些支持截止日期（固定的时间点）。API 可能有一个默认的截止日期/超时值，而一些可能没有。
- en: '**RPC termination**: There are a few scenarios where the RPC gets terminated
    because both the client and server make independent and local determinations of
    the success of the call, and their conclusions may not match. For example, the
    server may finish its part by sending all its messages, but it may fail from the
    client’s side because responses have arrived after the timeout. Another scenario
    would be when a server decides to complete the RPC before the client sends all
    messages.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**RPC 终止**：有一些场景中，RPC 被终止是因为客户端和服务器各自独立且本地地确定调用的成功，他们的结论可能不匹配。例如，服务器可能通过发送所有消息来完成其部分，但它可能因为客户端超时而失败，因为响应在超时后到达。另一个场景是当服务器决定在客户端发送所有消息之前完成
    RPC。'
- en: '**Canceling an RPC**: gRPC has a provision to cancel the RPC at any time by
    either the server or client. This terminates the RPC immediately. However, changes
    made before the cancellation are not rolled back.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**取消 RPC**：gRPC 提供了一种由服务器或客户端在任何时候取消 RPC 的规定。这会立即终止 RPC。然而，在取消之前所做的更改不会被回滚。'
- en: Let’s explore the gRPC server and stub a bit more in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中更深入地探讨 gRPC 服务器和模拟器。
- en: Understanding the gRPC server and gRPC stub
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 gRPC 服务器和 gRPC 模拟器
- en: If you closely observe *Figure 10**.1*, you’ll find that the gRPC server and
    gRPC stub are core parts of the implementation because gRPC is based on the client-server
    architecture. Once you define the service, you can generate both service interfaces
    and the stub using the Protobuf compiler, `protoc`, with the gRPC Java plugin.
    You’ll find a practical example in [*Chapter 11*](B19349_11.xhtml#_idTextAnchor250).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察 *图 10**.1*，你会发现 gRPC 服务器和 gRPC 模拟器是实现的核心部分，因为 gRPC 基于客户端-服务器架构。一旦你定义了服务，你就可以使用带有
    gRPC Java 插件的 Protobuf 编译器 `protoc` 生成服务接口和模拟器。你将在 [*第 11 章*](B19349_11.xhtml#_idTextAnchor250)
    中找到一个实际示例。
- en: 'The following types of files are generated by the compiler:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器生成的以下类型的文件：
- en: '**Models**: It generates all the messages (that is, models) defined in the
    service definition file, which contains the Protobuf code to serialize, deserialize,
    and fetch the types of request and response messages.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型**：它生成在服务定义文件中定义的所有消息（即模型），该文件包含用于序列化、反序列化和获取请求和响应消息类型的 Protobuf 代码。'
- en: '**gRPC Java files**: It contains the service base interface and stubs. The
    base interface is implemented and then used as a part of the gRPC server. Stubs
    are used by the clients for communication with the server.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**gRPC Java 文件**：它包含服务基接口和存根。基接口被实现并用作 gRPC 服务器的一部分。存根被客户端用于与服务器通信。'
- en: 'First, you need to implement the interface, as shown in the following code
    for `EmployeeService`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要实现接口，如下面的代码所示，这是 `EmployeeService` 的实现：
- en: '[PRE7]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Once you implement the interface, you can run the gRPC server to serve the
    requests from gRPC clients:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了接口，你就可以运行 gRPC 服务器来处理来自 gRPC 客户端的请求：
- en: '[PRE8]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For clients, first, you need to create the channel using `ChannelBuilder`,
    and then you can use the created channels to create stubs, as shown in the following
    code:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于客户端，首先，你需要使用 `ChannelBuilder` 创建通道，然后你可以使用创建的通道来创建存根，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, both blocking and asynchronous stubs have been created using the channel
    built using the `ManageChannelBuilder` class.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，已经使用 `ManageChannelBuilder` 类构建的通道创建了阻塞和异步存根。
- en: Let’s explore error handling in the next section.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在下一节中探索错误处理。
- en: Handling errors and error status codes
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理错误和错误状态码
- en: Unlike REST, which makes use of the HTTP status codes, gRPC uses a `Status`
    model, which contains its error codes and optional error message (string).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 HTTP 状态码的 REST 不同，gRPC 使用一个 `Status` 模型，它包含其错误代码和可选的错误消息（字符串）。
- en: 'If you remember, you have used the special class called `Error` to contain
    the error details because HTTP error codes contain limited information. Similarly,
    the gRPC error `Status` model is limited to code and an optional message (string).
    You don''t have sufficient error details for the client to use to handle the error
    or retry. You can make use of the richer error model as described at [https://cloud.google.com/apis/design/errors#error_model](https://cloud.google.com/apis/design/errors#error_model),
    which allows you to pass detailed error information back to the client. You can
    also find the error models in the next code block for quick reference:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，你曾经使用了一个名为 `Error` 的特殊类来包含错误详情，因为 HTTP 错误代码包含有限的信息。同样，gRPC 错误 `Status`
    模型仅限于代码和一个可选的消息（字符串）。你没有足够的错误详情供客户端用来处理错误或重试。你可以使用更丰富的错误模型，如[https://cloud.google.com/apis/design/errors#error_model](https://cloud.google.com/apis/design/errors#error_model)中所述，这允许你将详细的错误信息传回客户端。你还可以在下一个代码块中找到错误模型，以便快速参考：
- en: '[PRE10]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `details` field contains extra information, and you can use it to pass relevant
    information such as `RetryInfo`, `DebugInfo`, `QuotaFailure`, `ErrorInfo`, `PreconditionFailure`,
    `BadRequest`, `RequestInfo`, `ResourceInfo`, `Help`, and `LocalizedMethod`. All
    these message types are available at [https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto](https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`details` 字段包含额外的信息，你可以使用它来传递相关信息，例如 `RetryInfo`、`DebugInfo`、`QuotaFailure`、`ErrorInfo`、`PreconditionFailure`、`BadRequest`、`RequestInfo`、`ResourceInfo`、`Help`
    和 `LocalizedMethod`。所有这些消息类型都可以在[https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto](https://github.com/googleapis/googleapis/blob/master/google/rpc/error_details.proto)找到。'
- en: These richer error models are described using Protobuf. If you would like to
    use richer error models, you must make sure that support libraries are aligned
    with the practical use of APIs, as described for Protobuf.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更丰富的错误模型使用 Protobuf 描述。如果你想使用更丰富的错误模型，你必须确保支持库与 API 的实际使用相匹配，如 Protobuf 中所述。
- en: 'Like REST, errors can be raised by the RPC for various reasons, such as network
    failure or data validation. Let’s have a look at the following REST error codes
    and their respective gRPC counterparts:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 与 REST 类似，RPC 可以因各种原因引发错误，例如网络故障或数据验证。让我们看看以下 REST 错误代码及其相应的 gRPC 对应代码：
- en: '| **HTTP** **Status Code** | **gRPC** **Status Code** | **Notes** |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| **HTTP** **状态码** | **gRPC** **状态码** | **说明** |'
- en: '| --- | --- | --- |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `400` | `INVALID_ARGUMENT` | For invalid arguments. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `400` | `INVALID_ARGUMENT` | 对于无效的参数。 |'
- en: '| `400` | `FAILED_PRECONDITION` | The action could not be performed due to
    a failed pre-condition. |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `400` | `FAILED_PRECONDITION` | 由于预条件失败，操作无法执行。 |'
- en: '| `400` | `OUT_OF_RANGE` | If an invalid range is specified by the client.
    |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `400` | `OUT_OF_RANGE` | 如果客户端指定了无效的范围。 |'
- en: '| `401` | `UNAUTHENTICATED` | If the client’s request is not authenticated,
    such as having a missing or expired token. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `401` | `UNAUTHENTICATED` | 如果客户端的请求未认证，例如缺少或过期的令牌。 |'
- en: '| `403` | `PERMISSION_DENIED` | The client does not have the sufficient permission.
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| `403` | `PERMISSION_DENIED` | 客户端没有足够的权限。|'
- en: '| `404` | `NOT_FOUND` | The requested resource was not found. |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| `404` | `NOT_FOUND` | 请求的资源未找到。|'
- en: '| `409` | `ABORTED` | A conflict for read-write operations or any concurrency
    conflict. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `409` | `ABORTED` | 读写操作或任何并发冲突的冲突。|'
- en: '| `409` | `ALREADY_EXISTS` | If the request is for creating a new resource
    that already exists. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `409` | `ALREADY_EXISTS` | 如果请求是创建已存在的资源。|'
- en: '| `429` | `RESOURCE_EXHAUSTED` | If the request reaches the API rate limiting.
    |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| `429` | `RESOURCE_EXHAUSTED` | 如果请求达到API速率限制。|'
- en: '| `499` | `CANCELLED` | If the request is canceled by the client. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| `499` | `CANCELLED` | 如果请求被客户端取消。|'
- en: '| `500` | `DATA_LOSS` | For unrecoverable data loss or corruption. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| `500` | `DATA_LOSS` | 对于不可恢复的数据丢失或损坏。|'
- en: '| `500` | `UNKNOWN` | For an unknown error at the server. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| `500` | `UNKNOWN` | 对于服务器上的未知错误。|'
- en: '| `500` | `INTERNAL` | For an internal server error. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| `500` | `INTERNAL` | 对于内部服务器错误。|'
- en: '| `501` | `NOT_IMPLEMENTED` | API not implemented by the server. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| `501` | `NOT_IMPLEMENTED` | 服务器未实现API。|'
- en: '| `502` | `N/A` | Error due to unreachable network or network misconfiguration.
    |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| `502` | `N/A` | 由于网络不可达或网络配置错误而导致的错误。|'
- en: '| `503` | `UNAVAILABLE` | The server is down or unavailable due to any reason.
    The client can perform a retry on such errors. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| `503` | `UNAVAILABLE` | 服务器因任何原因关闭或不可用。客户端可以在这些错误上执行重试。|'
- en: '| `504` | `DEADLINE_EXCEEDED` | Either request doesn’t finish within the deadline.
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `504` | `DEADLINE_EXCEEDED` | 请求未在截止日期内完成。|'
- en: gRPC error codes are more readable as you don’t need mapping to understand the
    number codes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC错误代码更易于阅读，因为您不需要映射来理解数字代码。
- en: Summary
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you explored Protobuf, IDL, and the serialization utility.
    You also explored gRPC fundamentals such as service definitions, messages, server
    interfaces, and methods. You compared gRPC with REST. I hope this has given you
    enough perspective to understand gRPC.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您探讨了Protobuf、IDL和序列化实用工具。您还探讨了gRPC基础知识，如服务定义、消息、服务器接口和方法。您比较了gRPC与REST。我希望这已经为您提供了足够的视角来理解gRPC。
- en: You also learned about the gRPC life cycles, servers, and clients with stubs.
    You covered Protobuf, gRPC architecture, and gRPC fundamentals, which will allow
    you to develop gRPC-based APIs and services.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您还学习了gRPC的生命周期、带有存根的服务器和客户端。您还涵盖了Protobuf、gRPC架构和gRPC基础知识，这将使您能够开发基于gRPC的API和服务。
- en: You will make use of the fundamentals you learned in this chapter in the next
    chapter to implement the gRPC server and client.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在下一章中使用本章学到的基本知识来实现gRPC服务器和客户端。
- en: Questions
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is RPC?
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPC是什么？
- en: How is gRPC different in comparison to REST and which one should be used?
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与REST相比，gRPC有何不同？应该使用哪一个？
- en: Which type of service method is useful when you want to view the latest tweets
    or do similar types of work?
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您想查看最新推文或执行类似类型的工作时，哪种类型的服务方法是有用的？
- en: Answers
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Answers
- en: RPC stands for Remote Procedure Call. A client can call an exposed procedure
    on a remote server, which is just like calling a local procedure, but it gets
    executed on a remote server. An RPC is best suited for inter-service communication
    in connected systems.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: RPC代表远程过程调用。客户端可以调用远程服务器上公开的进程，这就像调用本地进程一样，但它是在远程服务器上执行的。RPC非常适合连接系统中的跨服务通信。
- en: gRPC is based on the client-server architecture, whereas this is not true for
    REST. gRPC also supports full-duplex streaming communication in contrast to REST.
    gRPC performs better than REST as it uses static paths and a single source of
    the request payload.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: gRPC基于客户端-服务器架构，而REST并非如此。与REST相比，gRPC还支持全双工流式通信。由于使用静态路径和请求有效负载的单个来源，gRPC的性能优于REST。
- en: A REST response error depends on HTTP status codes, whereas gRPC has formalized
    the set of errors to make it well aligned with APIs. gRPC has also been built
    to support and handle call cancellations, load balancing, and failovers. For more
    information, please refer to the *REST versus* *gRPC* subsection.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: REST响应错误取决于HTTP状态码，而gRPC已经正式化了错误集，使其与API良好对齐。gRPC还构建了支持和处理调用取消、负载均衡和故障转移的功能。有关更多信息，请参阅*REST与gRPC*子节。
- en: You should use the server-streaming RPC method because you want to receive the
    latest messages from the server, such as tweets.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该使用服务器流式RPC方法，因为您想接收来自服务器的最新消息，例如推文。
- en: Further reading
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can find out more at the following links:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中找到更多信息：
- en: 'gRPC documentation: [https://grpc.io/](https://grpc.io/)'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 文档：[https://grpc.io/](https://grpc.io/)
- en: '*Practical* *gRPC*: [https://www.packtpub.com/in/web-development/practical-grpc](https://www.packtpub.com/in/web-development/practical-grpc)'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用* *gRPC*：[https://www.packtpub.com/in/web-development/practical-grpc](https://www.packtpub.com/in/web-development/practical-grpc)'
