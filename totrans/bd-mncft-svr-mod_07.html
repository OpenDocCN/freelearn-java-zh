<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;The Bukkit Event System" id="1GKCM1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. The Bukkit Event System</h1></div></div></div><p class="calibre8">At this point, you know how to create a plugin that will run some code when a command is executed. This is very useful in many situations. However, we would rather not be required to type in a command sometimes. We'd prefer it if the code could be automatically triggered to be executed. The trigger could be a specific event that occurs on the server, such as a block being broken, a creeper exploding, or a player sending a message in a chat. The Bukkit event system allows a developer to listen for an event and automatically run a block of code based on that event. By using the Bukkit event system, you can automate your server, which means less work for you to maintain the server in the future. In this chapter, we'll cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Choosing an event</li><li class="listitem">Registering an event listener</li><li class="listitem">Listening for an event</li><li class="listitem">Canceling an event</li><li class="listitem">Communicating between events</li><li class="listitem">Modifying an event as it occurs</li><li class="listitem">Creating more plugins on your own</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;The Bukkit Event System" id="1GKCM1-b66e70deee6e4ed481db4b113e303f23">
<div class="book" title="Choosing an event"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec45" class="calibre1"/>Choosing an event</h1></div></div></div><p class="calibre8">All the events that <a id="id181" class="calibre1"/>Bukkit provides can be found in the API documentation in the <code class="email">org.bukkit.event</code> package. Each event is categorized into packages within <code class="email">org.bukkit.event</code>, such as <code class="email">org.bukkit.event.block</code>, <code class="email">org.bukkit.event.player</code>, and <code class="email">org.bukkit.event.world</code>. This makes it easy to find the event that you are looking for. A full list of the Bukkit events<a id="id182" class="calibre1"/> can be found at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html">https://hub.spigotmc.org/javadocs/spigot/org/bukkit/event/class-use/Event.html</a>. I encourage you to take a look at the list to see what type of event you can listen for. Each event has several methods, which give you more information and allow you to modify the event. For example, <code class="email">BlockBreakEvent</code> provides methods to get the block that was broken and the player who broke it. Most events can also be canceled if you wish to not allow the events to occur. This is useful in many situations, such as not letting a new player place a TNT block, or preventing a mob from spawning.</p><p class="calibre8">As mentioned earlier, listening to events can aid in automating your server and reducing the number of commands being sent. In addition to that, they can simply be a lot of fun to work with. Let's look at a few examples of plugins that can be made using the Bukkit event system. We mentioned that you can listen to the player chat event and modify it as you please. You can use this to monitor messages and censor the offensive words that may be spoken. Placing TNT blocks was also mentioned. You can create a plugin that only lets players place TNT if they have the <code class="email">build.tnt</code> permission node. There is also a <code class="email">WeatherChangeEvent class</code> that can be canceled. That being said, there are many server administrators who don't like it when it rains on the server. Rain can be loud and annoying. Admins will issue the <code class="email">/toggledownfall</code> command to stop the rain every time it starts. In this chapter, we will create a plugin that prevents rain from starting in the first place.</p><p class="calibre8">The first thing that <a id="id183" class="calibre1"/>we must do is find the appropriate event that we can listen for. To accomplish this, we will have a look at the Bukkit API documentation. Let's say that we are unfamiliar with the API. Therefore, we are unsure about which event we can use. We can look through the list of events until we find the correct one, but you may have better luck if you first find the right package. There are two categories that rain could fall under, namely world events or weather events. It is more likely that rain would be categorized under weather. So, we will look there first. There is no event that includes the word "rain" because rain is categorized with snow. Therefore, the event that we are looking for is the <code class="email">WeatherChangeEvent class</code>. If you did not find a correct event to use, look in other packages.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip21" class="calibre1"/>Tip</h3><p class="calibre8">If you are ever unable to find the event that you are looking for, then remember that you can ask for help on the Bukkit/Spigot forums. You can perhaps perform a search on the forums first to check whether anyone else was looking for the same information. It is possible that the event that you are attempting to listen for does not exist. Keep in mind that the Spigot project is not associated with the creators of Minecraft. Therefore, it is impossible to detect or modify some events.</p></div><p class="calibre8">Now that we have found the event, we wish to prevent this event from occurring. Viewing the <code class="email">WeatherChangeEvent</code> class reference page, we will see several methods that are offered in this event. We will use the <code class="email">setCancelled</code> method to cancel the event and the <code class="email">toWeatherState</code> method to ensure that we are only preventing the rain from starting and not stopping.</p></div></div>
<div class="book" title="Registering an event listener" id="1HIT81-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec46" class="calibre1"/>Registering an event listener</h1></div></div></div><p class="calibre8">After deciding which <a id="id184" class="calibre1"/>event we will listen for, it is time to start programming. Create a new project, as described in <a class="calibre1" title="Chapter 3. Creating Your First Bukkit Plugin" href="part0026_split_000.html#OPEK1-b66e70deee6e4ed481db4b113e303f23">Chapter 3</a>, <span class="strong"><em class="calibre9">Creating Your First Bukkit Plugin</em></span>, and call it <code class="email">NoRain</code>. Don't forget to create a <code class="email">plugin.yml</code> file as well.</p><p class="calibre8">In order to listen for an event, your plugin must have a class that is registered as a <code class="email">Listener class</code>. We will only have one class, named <code class="email">NoRain.java</code>, for this project. Therefore, we will make this a <code class="email">Listener</code> class as well. The class declaration will look like the following line of code:</p><div class="informalexample"><pre class="programlisting">public class NoRain extends JavaPlugin implements Listener</pre></div><p class="calibre8">Alternatively, if this is a large project, you can make a class for the <code class="email">Listener class</code>, which is similar to how the <code class="email">Enchanter</code> project had <code class="email">CommandExecutor</code> as a separate class. Also, like <code class="email">CommandExecutor</code>, a <code class="email">Listener class</code> will implement an <code class="email">interface method</code>. The <code class="email">interface method</code> that we wish to implement is <code class="email">org.bukkit.event.Listener</code>.</p><p class="calibre8">The class is declared as a <code class="email">Listener</code> class but it is still not registered with Bukkit. To register all the events within the listener, insert the following line of code in the <code class="email">onEnable</code> method:</p><div class="informalexample"><pre class="programlisting">getServer().getPluginManager().registerEvents(this, this);</pre></div><p class="calibre8">This line retrieves the <code class="email">PluginManager class</code> and uses it to register the events. The <code class="email">PluginManager class</code> is used for several things, including handling events, enabling/disabling plugins, and handling player permissions. Most of the time, you will use it to register event listeners. It has a <code class="email">registerEvents</code> method that takes a <code class="email">Listener</code> object and a <code class="email">JavaPlugin</code> object as parameters. The only class that exists is both the <code class="email">Listener</code> and <code class="email">JavaPlugin</code>. So, we will pass the <code class="email">this</code> object to both the parameters. If the <code class="email">Listener</code> class is separated from the <code class="email">main</code> class, then the line will look like the following line of code:</p><div class="informalexample"><pre class="programlisting">getServer().getPluginManager().registerEvents(new WeatherListener(), this);</pre></div><p class="calibre8">This is all that is needed within the <code class="email">onEnable</code> method.</p></div>
<div class="book" title="Listening for an event" id="1IHDQ1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec47" class="calibre1"/>Listening for an event</h1></div></div></div><p class="calibre8">The next method <a id="id185" class="calibre1"/>that we will create is an <code class="email">EventHandler method</code>. We will use the <code class="email">@EventHandler</code> annotation to tell Bukkit which methods are event listeners. Create a new method that has an event of our choice as the only parameter:</p><div class="informalexample"><pre class="programlisting">public void onWeatherChange(WeatherChangeEvent event)</pre></div><p class="calibre8">The method must be <code class="email">public</code>, and it should not return anything. You can name this method anything you wish, but most programmers will keep the name similar to the name of the event.</p><p class="calibre8">Next, we will indicate that this method handles events. Just above the method, add the following annotation:</p><div class="informalexample"><pre class="programlisting">@EventHandler</pre></div><p class="calibre8">On the same line, we can modify some properties for the <code class="email">EventHandler method</code>. A property that you are likely to add to all the <code class="email">EventHandler</code> methods is the one that ignores the canceled events. Setting the <code class="email">ignoreCancelled</code> property to <code class="email">true</code> will result in the method looking like this:</p><div class="informalexample"><pre class="programlisting">@EventHandler (ignoreCancelled = true)
public void onWeatherChange(WeatherChangeEvent event) {
}</pre></div><p class="calibre8">If the event is already canceled by another plugin, then we don't want to bother listening to it.</p><p class="calibre8">The other property<a id="id186" class="calibre1"/> is the event priority. By changing the priority of the <code class="email">EventHandler method</code>, you can choose to listen for the event before or after other plugins. If the <code class="email">EventHandler method</code> has a higher priority than another event, then it is called after the other <code class="email">EventHandler method</code> and thus may override anything that the first <code class="email">EventHandler</code> method has modified. There are six priority levels, and they are called in the following order:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">LOWEST</li><li class="listitem" value="2">LOW</li><li class="listitem" value="3">NORMAL</li><li class="listitem" value="4">HIGH</li><li class="listitem" value="5">HIGHEST</li><li class="listitem" value="6">MONITOR</li></ol><div class="calibre13"/></div><p class="calibre8">Thus, the plugins with the <code class="email">LOWEST</code> priority are called first. Imagine that you have a protection plugin. You would not want any other plugin to reverse its decision to cancel an event. Therefore, you would set the priority to <code class="email">HIGHEST</code> so that no other plugins would be able to modify the event after yours. By default, each <code class="email">EventHandler method</code> has a <code class="email">NORMAL</code> priority. If you are not modifying the event, then you will most likely want to listen at the <code class="email">MONITOR</code> level. The <code class="email">MONITOR</code> priority should not be used when modifying the event, such as canceling it.</p><p class="calibre8">We want to cancel this event before plugins that have a <code class="email">NORMAL</code> priority even see it. Therefore, let's change the priority of this event to <code class="email">LOW</code>. Now, the line that is above the method looks like the following line of code:</p><div class="informalexample"><pre class="programlisting">@EventHandler (ignoreCancelled = true, priority = EventPriority.LOW) </pre></div></div>
<div class="book" title="Canceling an event" id="1JFUC1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec48" class="calibre1"/>Canceling an event</h1></div></div></div><p class="calibre8">Finally, we <a id="id187" class="calibre1"/>want to stop the weather from changing. To do so, we will call the <code class="email">setCancelled</code> method of the event. The method takes a <code class="email">Boolean</code> value as a parameter. We want <code class="email">canceled</code> to equal <code class="email">true</code>. Therefore, we will use the <code class="email">setCancelled(true)</code> code, which is as follows:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.norain;

import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.weather.WeatherChangeEvent;
import org.bukkit.plugin.java.JavaPlugin;

public class NoRain extends JavaPlugin implements Listener {
  @Override
  public void onEnable() {
    getServer().getPluginManager().registerEvents(this, this);
  }

  @EventHandler (ignoreCancelled = true, priority =EventPriority.LOW)
  public void onWeatherChange(WeatherChangeEvent event) {
    event.setCancelled(true);
  }
}</pre></div><p class="calibre8">This plugin will work as is. However, there is room for improvement. What if it is already raining in the server world? This plugin would prevent the rain from ever stopping. Let's add an <code class="email">if</code> statement so that the <code class="email">WeatherChangeEvent class</code> will only be canceled if the weather is starting. The event provides us with a method called <code class="email">toWeatherState</code>, which returns a <code class="email">Boolean</code> value. This method will return <code class="email">true</code> or <code class="email">false</code>, informing us about whether the weather is starting or stopping respectively. This is also made clear in the API documentation:</p><div class="mediaobject"><img src="../images/00038.jpeg" alt="Canceling an event" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">If <code class="email">toWeatherState</code> returns <code class="email">true</code>, then it is starting to rain. This is the case where we want to cancel the <a id="id188" class="calibre1"/>event. Now, let's write the same thing in Java, as follows:</p><div class="informalexample"><pre class="programlisting">if (event.toWeatherState()) {
  event.setCancelled(true);
}</pre></div><p class="calibre8">After adding this <code class="email">if</code> statement, you should test your plugin. Before installing the plugin, log on to your server and use the <code class="email">/toggledownfall</code> command to make it rain. Once it is raining, install your newly created plugin and reload the server. At this point, it will still be raining, but you will be able to stop the rain by issuing the <code class="email">/toggledownfall</code> command again. If you cannot do so, then the <code class="email">if</code> statement that you added may be incorrect; review it to find your mistake and test it again. Once you stop the rain, you can try to use the same command to start the rain again. As long as the code is correct, the rain should not start. If the rain does start, then verify that your event listener is being properly registered within the <code class="email">onEnable</code> method. Also, verify that the server is enabling the correct version of the plugin, as explained in <a class="calibre1" title="Chapter 4. Testing on the Spigot Server" href="part0033_split_000.html#VF2I1-b66e70deee6e4ed481db4b113e303f23">Chapter 4</a>, <span class="strong"><em class="calibre9">Testing on the Spigot Server</em></span>.</p></div>
<div class="book" title="Communicating among events" id="1KEEU1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec49" class="calibre1"/>Communicating among events</h1></div></div></div><p class="calibre8">The plugin works<a id="id189" class="calibre1"/> exactly as intended, but what if we have a change of heart and begin to miss the sound of rain? Alternatively, what if our town bursts into flames and it must be extinguished quickly? We do not want to limit our power as an administrator by denying ourselves the use of the <code class="email">/toggledownfall</code> command. Next, we will listen for this command to be issued, and when it is issued, we will allow the weather to change. Ultimately, we will still be able to control the weather manually, but the weather will not start on its own.</p><p class="calibre8">Let's create another <code class="email">EventHandler method</code>. This time, we will listen for a console command being sent so that we can set a Boolean flag, as follows:</p><div class="informalexample"><pre class="programlisting">@EventHandler (ignoreCancelled = true, priority = EventPriority.MONITOR)
public void onPlayerCommand(PlayerCommandPreprocessEvent event) {
  //Check if the Player is attempting to change the weather
  if (event.getMessage().startsWith("/toggledownfall")) {
    //Verify that the Player has permission to change the weather
    if (event.getPlayer().hasPermission("minecraft.command.toggledownfall")) {
      //Allow the Rain to start for this occasion
      denyRain = false;
    }
  }
}</pre></div><p class="calibre8">We will not actually be modifying this event at all. Therefore, the event priority will be set to <code class="email">MONITOR</code>. We also want to ignore canceled events. The event that we will listen for is <code class="email">PlayerCommandPreprocessEvent</code>, which will occur every time a player issues a command, whether they are for Minecraft, Bukkit, or another plugin. We only care about one command, namely <code class="email">/toggledownfall</code>. So, the first <code class="email">if</code> statement checks whether the message starts with <code class="email">/toggledownfall</code>. If it is a different command, we will ignore it. As the event name suggests, this event occurs before the command is actually executed. Therefore, we must verify that a player has the permission to run the command. The permission node for the command is <code class="email">minecraft.command.toggledownfall</code>. If these two conditions are met, then we want to allow rain to start on the next <code class="email">WeatherChangeEvent class</code>. The second <code class="email">EventHandler method</code> is completed by using the two <code class="email">if</code> statements and setting a Boolean variable to <code class="email">false</code>.</p><p class="calibre8">At this point, a light<a id="id190" class="calibre1"/> bulb will appear, informing you that the <code class="email">denyRain</code> symbol cannot be found. When you click on the bulb, you can select <code class="email">Create Field denyRain in com.codisimus.norain.NoRain</code>. This will automatically create a private variable called <code class="email">denyRain</code> inside the class. Note the placement of the new line of code. It is outside the existing method blocks and yet still inside the class. This is important because it defines the variable's scope. The scope of a variable is where it can be accessed. The <code class="email">denyRain</code> variable is private. Therefore, no other class, such as a class from another plugin, can modify it. However, within the <code class="email">NoRain</code> class, all the methods can access it. This is useful because if the variable was declared within the curly braces of the <code class="email">onPlayerCommand</code> method, we would not be able to see it from the <code class="email">onWeatherChange</code> method.</p><p class="calibre8">Now that the plugin knows when we wish to allow the rain to start, we must slightly modify the <code class="email">onWeatherChange</code> method to allow for such an exception. Currently, to cancel the event, we will call the <code class="email">setCancelled</code> method with <code class="email">true</code> as the parameter. If we were to pass <code class="email">false</code> as a parameter, then the event would not be cancelled. The <code class="email">denyRain</code> variable is equal to <code class="email">true</code> when we wish to cancel the event. Therefore, rather than passing <code class="email">true</code> or <code class="email">false</code>, we can pass the value of <code class="email">denyRain</code>. So, when <code class="email">denyRain</code> is set to <code class="email">false</code>, we will call <code class="email">setCancelled</code> using the following line of code:</p><div class="informalexample"><pre class="programlisting">event.setCancelled(false);</pre></div><p class="calibre8">At the end of the <code class="email">onWeatherChange</code> method, we want to reset the value of <code class="email">denyRain</code> to <code class="email">true</code>. In this <a id="id191" class="calibre1"/>way, we can ensure that we allow the weather to change only once each time the <code class="email">/toggledownfall</code> command is issued. The final code looks like this:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.norain;

import org.bukkit.event.EventHandler;
import org.bukkit.event.EventPriority;
import org.bukkit.event.Listener;
import org.bukkit.event.player.PlayerCommandPreprocessEvent;
import org.bukkit.event.weather.WeatherChangeEvent;
import org.bukkit.plugin.java.JavaPlugin;

public class NoRain extends JavaPlugin implements Listener {
  //This is a variable that our two methods will use to "communicate" with each other
  private boolean denyRain = true;

  @Override
  public void onEnable() {
    //Register all of the EventHandlers within this class
    getServer().getPluginManager().registerEvents(this, this);
  }

  @EventHandler (ignoreCancelled = true, priority =EventPriority.LOW)
  public void onWeatherChange(WeatherChangeEvent event) {
    if (event.toWeatherState()) { //Rain is trying to turn on
      //Cancel the event if denyRain is set to true
      event.setCancelled(denyRain);
    }
    //Reset the denyRain value until next time a Player issues the /toggledownfall command
    denyRain = true;
  }

  @EventHandler (ignoreCancelled = true, priority =EventPriority.MONITOR)
  public void onPlayerCommand(PlayerCommandPreprocessEvent event) {
    //Check if the Player is attempting to change the weather
    if (event.getMessage().startsWith("/toggledownfall")) {
      //Verify that the Player has permission to change the weather
      if (event.getPlayer().hasPermission("minecraft.command.toggledownfall")) { 
        //Allow the Rain to start for this occasion
        denyRain = false;
      }
    }
  }
}</pre></div><p class="calibre8">Note that when we declare the Boolean <code class="email">denyRain method</code>, we set its initial value to <code class="email">true</code>.</p><p class="calibre8">This completes <a id="id192" class="calibre1"/>the <code class="email">NoRain</code> plugin. Build the JAR file and test it out on your server. With this new version, you will be able to use the <code class="email">/toggledownfall</code> command to stop and start rain.</p></div>
<div class="book" title="Modifying an event as it occurs" id="1LCVG1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec50" class="calibre1"/>Modifying an event as it occurs</h1></div></div></div><p class="calibre8">The Bukkit API <a id="id193" class="calibre1"/>allows a programmer to do more than just cancel an event. Depending on the event, you can modify many of its aspects. In this next project, we will modify zombies as they spawn. Every time a zombie spawns, we will give it <code class="email">40</code> health rather than the default <code class="email">20</code>. This will make zombies more difficult to kill.</p><p class="calibre8">Create a new project as you would for any plugin. We will call this plugin <code class="email">MobEnhancer</code>. Similar to what we did with the <code class="email">NoRain</code> plugin, have the <code class="email">main</code> class implement <code class="email">Listener</code> and add the following line of code to the <code class="email">onEnable</code> method to register the <code class="email">EventHandlers method</code>:</p><div class="informalexample"><pre class="programlisting">getServer().getPluginManager().registerEvents(this, this);</pre></div><p class="calibre8">For this project, we will have an <code class="email">EventHandler method</code> that listens for mobs spawning. This will be the <code class="email">CreatureSpawnEvent class</code>. This event has many methods that we can call to either modify the event or gain more information about it. We only wish to modify zombies that are spawned. Therefore, the first thing that we will add is an <code class="email">if</code> statement, which will check whether the <code class="email">EntityType method</code> is <code class="email">ZOMBIE</code>. This is done by using the following block of code:</p><div class="informalexample"><pre class="programlisting">if (event.getEntityType() == EntityType.ZOMBIE) {
}</pre></div><p class="calibre8">Inside the curly braces, we will change the health of the <code class="email">Entity class</code> to <code class="email">40</code>. We can retrieve the <code class="email">Entity</code> class by calling <code class="email">event.getEntity()</code>. Once we have the <code class="email">Entity class</code>, we have access to<a id="id194" class="calibre1"/> many additional methods. You can view all of these methods in the API documentation, which is available at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html">https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/Entity.html</a>.</p><p class="calibre8">One of the methods is <code class="email">setHealth</code>. Before we can set the health to <code class="email">40</code>, we must set the maximum health, which can have a value of <code class="email">40</code>. An <code class="email">Entity class</code> cannot have a health of <code class="email">40</code> when its maximum health is still <code class="email">20</code>. These two lines of code will complete this plugin. The<a id="id195" class="calibre1"/> code now looks like this:</p><div class="informalexample"><pre class="programlisting">package com.codisimus.mobenhancer;

import org.bukkit.entity.EntityType;
import org.bukkit.event.EventHandler;
import org.bukkit.event.Listener;
import org.bukkit.event.entity.CreatureSpawnEvent;
import org.bukkit.plugin.java.JavaPlugin;

public class MobEnhancer extends JavaPlugin implements Listener {
  @Override
  public void onEnable() {
    //Register all of the EventHandlers within this class
    getServer().getPluginManager().registerEvents(this, this);
  }

  @EventHandler
  public void onMobSpawn(CreatureSpawnEvent event) {
    if (event.getEntityType() == EntityType.ZOMBIE) {
      int health = 40;
      event.getEntity().setMaxHealth(health);
      event.getEntity().setHealth(health);
    }
  }
}</pre></div><p class="calibre8">The first version of the <code class="email">MobEnhancer</code> plugin is complete with this small class. You can test the plugin by installing it on your server. You will notice that zombies will be much more difficult to kill.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip22" class="calibre1"/>Tip</h3><p class="calibre8">Note that we declared a local variable named <code class="email">health</code> of the <code class="email">int</code> type and set its value to <code class="email">40</code>. Alternatively, we could simply write <code class="email">40</code> in the two lines that follow. However, programming the amount of health this way allows us to easily change it in the future. We only have to change the number in one line of code rather than two or more. Also, you may have noticed that the <code class="email">setMaxHealth</code> and <code class="email">setHealth</code> methods accept a variable of the <code class="email">double</code> type. However, an <code class="email">int</code> value may still be passed to the method, as it will be automatically converted to a <code class="email">double</code> value with a value of <code class="email">40</code>.<code class="email">0</code>.</p></div><p class="calibre8">You can add more code to the plugin in order to modify the health of more types of entities. A <a id="id196" class="calibre1"/>list of all the <code class="email">EntityType methods</code> can be found in the Bukkit API documentation under the <code class="email">EntityType</code> class<a id="id197" class="calibre1"/> reference page at <a class="calibre1" href="https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html">https://hub.spigotmc.org/javadocs/spigot/org/bukkit/entity/EntityType.html</a>. However, in the next chapter, we will make this plugin configurable in order to change the health of every type of <code class="email">Entity</code> that spawns.</p></div>
<div class="book" title="Creating more plugins on your own" id="1MBG21-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec51" class="calibre1"/>Creating more plugins on your own</h1></div></div></div><p class="calibre8">Now that you have created <a id="id198" class="calibre1"/>these two plugins, you have a hang of how to properly use event listeners. You now have the required knowledge to create hundreds of unique plugins on your own. All that you need to get started is a cool idea. Why don't you try making one of the plugins that was suggested earlier in this chapter? For more ideas, you know where to look. The Bukkit, Spigot, and Minecraft forums or the API documentation are great for inspiration. For example, looking through the list of events, I saw the <code class="email">ExplosionPrimeEvent</code> class, which is described as "<span class="strong"><strong class="calibre2">Called when an entity has made a decision to explode</strong></span>". This event is called when a creeper makes that hissing noise that every Minecraft player dreads. When this happens, you can send a message to all the nearby players to make it look like the creeper is talking to them. First, you will create an <code class="email">EventHandler method</code> for this event. You will want to return in case the entity is not a creeper. Then, you will want to get the entities that are near the creeper (there is a method for this within the <code class="email">Entity</code> class). For each entity that you get, if it is an instance of a player, send them a message, as follows:</p><p class="calibre8">
<code class="email">&lt;Creeper&gt; That sssure isss a nicccee &lt;ItemInHand&gt; you have there. It would be a ssssshame if anything happened to it.</code>
</p><p class="calibre8">In each message, you will replace <code class="email">&lt;ItemInHand&gt;</code> with the type of item that the player is holding. By this time, I am sure that you have some ideas of your own that you are able to implement as well.</p><p class="calibre8">Another good thing that you should know about listeners is how to unregister them. You may never need to do this, but if you do ever want to stop modifying or canceling an event, then you can use the following code within the <code class="email">Listener</code> class:</p><div class="informalexample"><pre class="programlisting">HandlerList.unregisterAll(this);</pre></div><p class="calibre8">This will unregister the entire class. So, if you wish to only unregister specific <code class="email">EventHandler methods</code>, then you should split them up into separate classes. Unregistering the listeners will not be the way to go for the <code class="email">NoRain</code> plugin, but it may be useful if you add a <code class="email">/mobenhancer off</code> command. Then, a <code class="email">/mobenhancer on</code> command can register the listeners again, which is similar to how we did this in the <code class="email">onEnable</code> method.</p></div>
<div class="book" title="Summary" id="1NA0K1-b66e70deee6e4ed481db4b113e303f23"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec52" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">Both the plugins that we made in this chapter have the entire code within a single class. However, you may choose to separate these into the main plugin class and a listener class. In small plugins like these, it is not necessary. But in larger projects, it will keep your code much cleaner. There will be a few differences, such as having static variables or passing a variable to another class. In the next chapter, we will complete the <code class="email">MobEnhancer</code> plugin by adding configuration as well as a <code class="email">reload</code> command. We will have the <code class="email">Listener</code> and <code class="email">CommandExecutor</code> as a part of the <code class="email">main</code> class. Once the plugin is complete, we will go over the differences for the same plugin as three individual classes.</p></div></body></html>