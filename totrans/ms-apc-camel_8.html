<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Testing"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Testing</h1></div></div></div><p>When we deal with an integration project, testing is vital to ensure that your logic works as expected. This means testing the different routing logic, and managing the errors that can happen during the routing.</p><p>Moreover, an integration project means that we use services or endpoints provided by different teams or third parties. Instead of waiting for the services and endpoints provided by the team, we can begin to implement our project by mocking the dependency services.</p><p>We can distinguish two kinds of tests:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Unit tests are focused<a id="id406" class="indexterm"/> on testing your routing logic. Basically, it tests the behaviors of your routes.</li><li class="listitem" style="list-style-type: disc">Integration tests are more <a id="id407" class="indexterm"/>dedicated to the installation and deployment of your routes in a container. These tests depend on the runtime container that you use to run your Camel routes.</li></ul></div><p>Apache Camel provides the tool to easily implement unit tests—it's called a Camel test kit.</p><p>This chapter will introduce:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The unit test approach and how to use the different modules provided by the test kit.</li><li class="listitem" style="list-style-type: disc">How to bootstrap integration tests in the special case of Apache Karaf and OSGi</li></ul></div><div class="section" title="Unit test approach with the Camel test kit"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Unit test approach with the Camel test kit</h1></div></div></div><p>Implementing a unit test<a id="id408" class="indexterm"/> basically means you bootstrap your routes—you load <code class="literal">CamelContext</code> and routes in the tests, and it is ready to be executed.</p><p>You now define the <a id="id409" class="indexterm"/>endpoints that you want to mock, as follows:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">On the mocked endpoints, you define assertions.</li><li class="listitem">Create and <span class="emphasis"><em>inject</em></span> exchanges at some points of the routes.</li><li class="listitem">Check whether the assertions are verified.</li></ol></div><p>Camel provides <a id="id410" class="indexterm"/>different test kits, depending on the<a id="id411" class="indexterm"/> DSL that you use to write your routes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">camel-test</code> is the core and abstract test kit that you can use if you use the Java DSL.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-test-spring</code> extends <code class="literal">camel-test</code>, providing support for the Spring DSL.</li><li class="listitem" style="list-style-type: disc"><code class="literal">camel-test-blueprint</code> extends <code class="literal">camel-test</code> as well, and provides support for the Blueprint DSL. Additionally, it also provides an OSGi like service support leveraging iPOJO.</li></ul></div><p>All Camel test kits provide:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JUnit extensions: JUnit is the most commonly adopted unit test framework for Java, and is freely available. Instead <a id="id412" class="indexterm"/>of reinventing the wheel, Camel directly provides JUnit extensions. This means that your unit test classes will extend the Camel JUnit extensions, and you will be able to use the JUnit annotations (like <code class="literal">@Test</code> for instance).</li><li class="listitem" style="list-style-type: disc">Mock component: The mock<a id="id413" class="indexterm"/> component is provided directly by <code class="literal">camel-core</code>. The mock component provides a powerful declarative testing mechanism, and can be used <span class="emphasis"><em>on top of</em></span> actual components. The declarative expectations can be created on any mock endpoint, before the test begins.</li><li class="listitem" style="list-style-type: disc">ProducerTemplate: The <code class="literal">ProducerTemplate</code> is<a id="id414" class="indexterm"/> provided by the Camel Test base classes (or the <code class="literal">CamelContext</code>). It's a convenient feature that allows you to easily create exchanges, and set messages, which you send on the route endpoint of your choice.</li></ul></div><div class="section" title="ProducerTemplate"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec78"/>ProducerTemplate</h2></div></div></div><p>
<code class="literal">ProducerTemplate</code> is a template that provides an easy way to create messages in Camel. It allows you to send message instances in an exchange to an endpoint. It supports various communication styles—<code class="literal">InOnly</code>, <code class="literal">InOut</code>, <code class="literal">Sync</code>, <code class="literal">Async</code>, and <code class="literal">Callback</code>. You can get <code class="literal">ProducerTemplate</code> from the <code class="literal">CamelContext</code>:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ProducerTemplate producerTemplate = camelContext.createProducerTemplate();</strong></span>
</pre></div><p>In unit test, as soon as your test class extends to one of the Camel test base classes, you have <code class="literal">producerTemplate</code> ready to be used.</p><p>For instance, the<a id="id415" class="indexterm"/> producer template can create a message, set the body of the <code class="literal">in</code> message and send it to the <code class="literal">direct:input</code> endpoint:</p><div class="informalexample"><pre class="programlisting">producerTemplate.sendBody("direct:input", "Hello World", );</pre></div><p>In addition to the body of the <code class="literal">in</code> message, it's also possible to set a header:</p><div class="informalexample"><pre class="programlisting">producerTemplate.sendBodyAndHeader("direct:input", "Hello World", "myHeader", "headerValue");</pre></div><p>The <code class="literal">sendBody()</code> method also accepts a <code class="literal">MessageExchangePattern</code> argument (if you want to simulate the <code class="literal">InOnly</code> or <code class="literal">InOut</code> exchange).</p><p>When using <code class="literal">InOut</code>, you might want to get the <code class="literal">out</code> message after the exchange execution.</p><p>In that case, you have to use the<a id="id416" class="indexterm"/> <code class="literal">requestBody()</code> method on the <code class="literal">producerTemplate</code> instead of <code class="literal">sendBody()</code> method:</p><div class="informalexample"><pre class="programlisting">String out = producerTemplate.requestBody("jetty:http://0.0.0.0:8888/service", "request", String.class);</pre></div></div><div class="section" title="JUnit extensions"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec79"/>JUnit extensions</h2></div></div></div><p>Camel directly provides classes<a id="id417" class="indexterm"/> that you have to extend in your<a id="id418" class="indexterm"/> tests.</p><div class="section" title="CamelTestSupport"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec17"/>CamelTestSupport</h3></div></div></div><p>
<code class="literal">CamelTestSupport</code> is the class that you have to extend if you use the Java DSL.</p><p>You have to override<a id="id419" class="indexterm"/> the <code class="literal">createRouteBuilder()</code> method. This is where you actually bootstrap the route, by calling the <code class="literal">createRouteBuilder()</code> method defined in your route class.</p><p>You also have to override the <code class="literal">isMockEndpoints()</code> or <code class="literal">isMockEndpointsAndSkip()</code> method. This method returns a regular expression—all endpoint URIs matching this <code class="literal">regex</code> will be mocked by the mock component. The <code class="literal">isMockEndpoints()</code> and <code class="literal">isMockEndpointsAndSkip()</code> methods are the same, but the skip one doesn't send the exchange to the actual endpoint.</p><p>You are now ready to create the methods with the <code class="literal">@Test</code> annotation. These methods are the actual tests.</p><p>Here's a complete <a id="id420" class="indexterm"/>example:</p><div class="informalexample"><pre class="programlisting">public class MyTest extends CamelTestSupport {

  @Override
  protected RouteBuilder createRouteBuilder() throws Exception {
     MyRoute route = new MyRoute();
     return route.createRouteBuilder();
  }

  @Override
  public String isMockEndpointsAndSkip() {
    return "*";
  }

  @Test
  public void myTest() throws Exception {
     ...
  }

}</pre></div></div><div class="section" title="CamelSpringTestSupport"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec18"/>CamelSpringTestSupport</h3></div></div></div><p>
<code class="literal">CamelSpringTestSupport</code> is the class that your test class has to extend if you use the Spring DSL.</p><p>This is exactly the same as the <code class="literal">CamelTestSupport</code> class. The only difference is that, instead of overriding the <code class="literal">createRouteBuilder()</code> method, you have to override the <code class="literal">createApplicationContext()</code> method. The <code class="literal">createApplicationContext()</code> method actually directly loads<a id="id421" class="indexterm"/> your Spring XML file containing your route definition:</p><div class="informalexample"><pre class="programlisting">public class MySpringTest extends CamelSpringTestSupport {

  @Override
  protected AbstractXmlApplicationContext createApplicationContext() throws Exception {
     return new ClassPathXmlApplicationContext("myroute.xml");
  }

  @Override
  public String isMockEndpointsAndSkip() {
    return "*";
  }

  @Test
  public void myTest() throws Exception {
     ...
  }

}</pre></div></div><div class="section" title="CamelBlueprintTestSupport"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec19"/>CamelBlueprintTestSupport</h3></div></div></div><p>
<code class="literal">CamelBlueprintTestSupport</code> is the<a id="id422" class="indexterm"/> class that you have to extend if you use the Blueprint DSL.</p><p>This is very similar to the <code class="literal">CamelSpringTestSupport</code> class, but instead of the <code class="literal">createApplicationContext()</code> method, you have to override the <code class="literal">getBlueprintDescriptor()</code> method:</p><div class="informalexample"><pre class="programlisting">public class MyBlueprintTest extends CamelBlueprintTestSupport {

  @Override
  protected String getBlueprintDescriptor() throws Exception {
     return "OSGI-INF/blueprint/route.xml";
  }

  @Override
  public String isMockEndpointsAndSkip() {
    return "*";
  }

  @Test
  public void myTest() throws Exception {
     ...
  }

}</pre></div><p>You can also override the <code class="literal">addServicesOnStartup()</code> method, if you want to <span class="emphasis"><em>fake</em></span> some OSGi services used in your route blueprint XML.</p></div></div><div class="section" title="The mock component"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec80"/>The mock component</h2></div></div></div><p>The mock component is<a id="id423" class="indexterm"/> provided by <code class="literal">camel-core</code>. It means that you can explicitly create mock endpoints with the <code class="literal">mock:name</code> URI. However, where it really makes sense to<a id="id424" class="indexterm"/> use the mock component is in unit tests—it's a cornerstone there.</p><p>Like a crash test dummy, the mock component is used to simulate real components and fake the actual endpoints.</p><p>Without the mock component, you would have to use the real components and endpoints, which is not always possible in tests. Moreover, when testing, you need to apply assertions to see if the result is as expected—we can use the mock component for that easily.</p><p>The mock component is an answer to the following situations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The real<a id="id425" class="indexterm"/> component or endpoint doesn't exist yet. For instance, you want to call a web service developed by another team. Unfortunately, the web service is not yet ready. In that case, you can fake the web service using the mock component.</li><li class="listitem" style="list-style-type: disc">The real component is not easy or takes time to bootstrap.</li><li class="listitem" style="list-style-type: disc">The real <a id="id426" class="indexterm"/>component is difficult to set up. Some components are difficult to set up, or require other applications that are difficult to set up, for instance, when you use the <code class="literal">camel-hbase</code> component in your route. This component uses an HBase instance running, meaning a running ZooKeeper and a running Hadoop HDFS cluster. It doesn't really make sense to actually use an instance HBase in unit tests (it could in integration tests). In that case, we will mock the HBase endpoint.</li><li class="listitem" style="list-style-type: disc">The real component returns nondeterministic values. For instance, your route calls a web service that never returns the same response for the same request (for instance, containing a timestamp). It's difficult to define assertions on nondeterministic values. In that case, we will mock the web service to always return a sample response.</li><li class="listitem" style="list-style-type: disc">You have to simulate errors. As shown in the previous chapter, it's very important to simulate errors in order to test the error handler, for instance. When we mock an endpoint, it's possible to simulate errors by throwing exceptions in mocked endpoint.</li></ul></div><div class="section" title="Using MockComponent"><div class="titlepage"><div><div><h3 class="title"><a id="ch08lvl3sec20"/>Using MockComponent</h3></div></div></div><p>When you<a id="id427" class="indexterm"/> override the <code class="literal">isMockEndpoints()</code>, or <code class="literal">isMockEndpointsAndSkip()</code> method in your <code class="literal">test</code> class, Camel will automatically <span class="emphasis"><em>replace</em></span> the actual endpoint with a mock endpoint, prefixing the endpoint URI with mock.</p><p>For instance, in your route, you have the file<code class="literal">:/tmp/in</code> endpoint. The <code class="literal">isMockEndpointsAndSkip()</code> method returns <code class="literal">*</code> meaning that all endpoints will be mocked. Camel Test creates the <code class="literal">mock:file:/tmp/in</code> mock endpoint.</p><p>You can retrieve the mock endpoint in your <code class="literal">test()</code> method using the <code class="literal">getMockEndpoint()</code> method:</p><div class="informalexample"><pre class="programlisting">MockEndpoint mockEndpoint = getMockEndpoint("mock:file:/tmp/in");</pre></div><p>You can define the assertions on a mock endpoint:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">expectedMessageCount(int)</code> defines the number of messages expected to be received by the<a id="id428" class="indexterm"/> endpoint. This count is reset and <code class="literal">init</code> at <code class="literal">CamelContext</code> creation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">expectedMinimumMessageCount(int)</code> defines the minimum number of messages expected to be received by the endpoint.</li><li class="listitem" style="list-style-type: disc"><code class="literal">expectedBodiesReceived(...)</code> defines the expected <code class="literal">in</code> message body to be received in this order.</li><li class="listitem" style="list-style-type: disc"><code class="literal">expectedHeaderRecevied(...)</code> defines the expected <code class="literal">in</code> message headers to be received.</li><li class="listitem" style="list-style-type: disc"><code class="literal">expectsAscending(Expression)</code> defines the expectation of the received message order. The order is defined by the given expression.</li><li class="listitem" style="list-style-type: disc"><code class="literal">expectsDescending(Expression)</code> is like <code class="literal">expectsAscending()</code> but in the reverse order.</li><li class="listitem" style="list-style-type: disc"><code class="literal">expectsNoDuplicate(Expression)</code> checks that there are no duplicate messages. The duplication pattern is expressed by the expression.</li></ul></div><p>Once you have defined the<a id="id429" class="indexterm"/> expectations on the mock endpoint, you call the <code class="literal">assertIsSatisfied()</code> method to validate that the expectations are satisfied:</p><div class="informalexample"><pre class="programlisting">MockEndpoint mockEndpoint = getMockEndpoint("mock:file:/tmp/in");
mockEndpoint.expectedMessageCount(2);
// send message with producerTemplate, see later
...
mockEndpoint.assertIsSatisfied();</pre></div><p>By default, the <code class="literal">assertIsSatisfied()</code> method executes the route and waits for 10 s before shutting down the route. The timeout can be changed with the <code class="literal">setResultWaitTime(ms)</code> method. When the assertions are satisfied, Camel stops waiting and moves forward to the <code class="literal">assertIsSatisfied()</code> method call. If a message reaches the endpoint after the <code class="literal">assertIsSatisfied()</code> statement, it won't be considered. Suppose, for instance, you want to verify that no message has been received by the endpoint (with <code class="literal">expectedMessageCount(0))</code>. As, at the start, the assertion is already satisfied, Camel doesn't wait. So, you have to explicitly wait for the assertion wait time using the <code class="literal">setAssertPeriod()</code> method:</p><div class="informalexample"><pre class="programlisting">MockEndpoint mockEndpoint = getMockEndpoint("mock:file:/tmp/in");
mockEndpoint.setAssertPeriod(10000);
mockEndpoint.expectedMessageCount(0);
// send message with producerTemplate
...
mockEndpoint.assertIsSatisfied();</pre></div><p>It's also possible to define the assertions on a specific message. The <code class="literal">message()</code> method allows you to access a specific message received by a mock endpoint:</p><div class="informalexample"><pre class="programlisting">MockEndpoint mockEndpoint = getMockEndpoint("mock:file:/tmp/in");
mockEndpoint.message(0).header("CamelFileName").isEqualTo("myfile");
// send message with producerTemplate
...
mockEndpoint.assertIsSatisfied();</pre></div><p>The mock endpoint stores the received messages in memory. In addition to the messages themselves, it also stores the arrival time of the messages.</p><p>This means that you <a id="id430" class="indexterm"/>can define timing assertions on the messages:</p><div class="informalexample"><pre class="programlisting">mock.message(0).arrives().noLaterThan(2).seconds().beforeNext();
mock.message(1).arrives().noLaterThan(2).seconds().afterPrevious();
mock.message(2).arrives().between(1, 4).seconds().afterPrevious();</pre></div><p>You can also simulate errors on a mock endpoint. It allows you to test the behavior of your route (and especially the error handler) when an error occurs.</p><p>As seen in the previous chapter, an error is actually an exception raised by an endpoint.</p><p>On a mock endpoint, you can use the <code class="literal">whenAnyExchangeReceived()</code> method to call a processor. If the processor throws an exception, we will simulate an error:</p><div class="informalexample"><pre class="programlisting">MockEndpoint mockEndpoint = getMockEndpoint("mock:file:/tmp/in");
mockEndpoint.whenAnyExchangeReceived(new Processor() {
  public void process(Exchange exchange) throws Exception {
    throw new IOException("Full filesystem error simulation for instance");
  }
});
// send message with producerTemplate
...
mockEndpoint.assertIsSatisfied();</pre></div></div></div></div></div>
<div class="section" title="A complete example"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>A complete example</h1></div></div></div><p>We have a bundle with the<a id="id431" class="indexterm"/> following route using the Blueprint DSL:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint &gt;

      &lt;camelContext &gt;
          &lt;route id="test"&gt;
              &lt;from uri="direct:input"/&gt;
              &lt;onException&gt;
                  &lt;exception&gt;java.lang.Exception&lt;/exception&gt;
                  &lt;redeliveryPolicy maximumRedeliveries="2"/&gt;
                  &lt;handled&gt;
                      &lt;constant&gt;true&lt;/constant&gt;
                  &lt;/handled&gt;
                  &lt;to uri="direct:error"/&gt;
              &lt;/onException&gt;
              &lt;choice&gt;
                  &lt;when&gt;
                      &lt;xpath&gt;//country='France'&lt;/xpath&gt;
                      &lt;to uri="direct:france"/&gt;
                  &lt;/when&gt;
                  &lt;when&gt;
                      &lt;xpath&gt;//country='USA'&lt;/xpath&gt;
                      &lt;to uri="direct:usa"/&gt;
                  &lt;/when&gt;
                  &lt;otherwise&gt;
                      &lt;to uri="direct:other"/&gt;
                  &lt;/otherwise&gt;
              &lt;/choice&gt;
          &lt;/route&gt;
      &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre></div><p>As usual, this route Blueprint XML is located in the <code class="literal">src/main/resources/OSGI-INF/blueprint/route.xml</code> of our project.</p><p>The route logic is pretty simple:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We receive XML messages on the <code class="literal">direct:input</code> endpoint</li><li class="listitem">We implement a Content-based Router EIP with the following logic:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the message contains a country element with <code class="literal">France</code> as the value (using the <code class="literal">//country=France xpath</code> expression), we send the message to the <code class="literal">direct:france</code> endpoint.</li><li class="listitem" style="list-style-type: disc">If the<a id="id432" class="indexterm"/> message contains a country element with <code class="literal">USA</code> as the value (using the <code class="literal">//country=USA xpath</code> expression), we send the message to the <code class="literal">direct:usa</code> endpoint.</li><li class="listitem" style="list-style-type: disc">Otherwise, the message is sent to the <code class="literal">direct:other</code> endpoint.</li><li class="listitem" style="list-style-type: disc">We also configure the <code class="literal">DefaultErrorHandler</code> of the route. For all exceptions, we try:<p>to redeliver the message two times</p></li></ul></div></li><li class="listitem">We set the exception handled meaning, so that we don't send back the exception <span class="emphasis"><em>outside</em></span> of the route</li><li class="listitem">We <span class="emphasis"><em>forward</em></span> the <span class="emphasis"><em>faulted</em></span> message to the <code class="literal">direct:error</code> endpoint</li></ol></div><p>The <code class="literal">pom.xml</code> file of <a id="id433" class="indexterm"/>the project defines the dependencies required for the tests, especially the <code class="literal">camel-test-blueprint</code> artifact:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;project   xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;

      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

      &lt;groupId&gt;com.packt.camel&lt;/groupId&gt;
      &lt;artifactId&gt;chapter8a&lt;/artifactId&gt;
      &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
      &lt;packaging&gt;bundle&lt;/packaging&gt;

      &lt;dependencies&gt;
          &lt;dependency&gt;
              &lt;groupId&gt;org.apache.camel&lt;/groupId&gt;
              &lt;artifactId&gt;camel-test-blueprint&lt;/artifactId&gt;
              &lt;version&gt;2.12.4&lt;/version&gt;
              &lt;scope&gt;test&lt;/scope&gt;
          &lt;/dependency&gt;
          &lt;dependency&gt;
              &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
              &lt;artifactId&gt;slf4j-simple&lt;/artifactId&gt;
              &lt;version&gt;1.7.5&lt;/version&gt;
              &lt;scope&gt;test&lt;/scope&gt;
          &lt;/dependency&gt;
      &lt;/dependencies&gt;

      &lt;build&gt;
          &lt;plugins&gt;
              &lt;plugin&gt;
                  &lt;groupId&gt;org.apache.felix&lt;/groupId&gt;
                  &lt;artifactId&gt;maven-bundle-plugin&lt;/artifactId&gt;
                  &lt;version&gt;2.3.7&lt;/version&gt;
                  &lt;extensions&gt;true&lt;/extensions&gt;
                  &lt;configuration&gt;
                      &lt;instructions&gt;
                          &lt;Import-Package&gt;*&lt;/Import-Package&gt;
                      &lt;/instructions&gt;
                  &lt;/configuration&gt;
              &lt;/plugin&gt;
          &lt;/plugins&gt;
      &lt;/build&gt;

&lt;/project&gt;</pre></div><p>It's now time to implement <a id="id434" class="indexterm"/>our unit tests. We create a class at <code class="literal">src/test/java/com/packt/camel/test folder</code>, named <code class="literal">RouteTest.java</code>:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.test;

import org.apache.camel.Exchange;
import org.apache.camel.Processor;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.blueprint.CamelBlueprintTestSupport;
import org.junit.Test;

import java.io.IOException;

public class RouteTest extends CamelBlueprintTestSupport {

      @Override
      protected String getBlueprintDescriptor() {
          return "OSGI-INF/blueprint/route.xml";
      }

      @Override
      public String isMockEndpointsAndSkip() {
          return "((direct:error)|(direct:france)|(direct:usa)|(direct:other))";
      }

      @Test
      public void testRoutingFrance() throws Exception {
          String message = "&lt;company&gt;&lt;country&gt;France&lt;/country&gt;&lt;/company&gt;";

    //define the expectations on the direct:france mocked endpoint
          MockEndpoint franceEndpoint = getMockEndpoint("mock:direct:france");
          franceEndpoint.expectedMessageCount(1);

    //define the expectations on the direct:usa mocked endpoint
          MockEndpoint usaEndpoint = getMockEndpoint("mock:direct:usa");
          usaEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:error mocked endpoint
          MockEndpoint errorEndpoint = getMockEndpoint("mock:direct:error");
          errorEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:other mocked endpoint
          MockEndpoint otherEndpoint = getMockEndpoint("mock:direct:other");
          otherEndpoint.expectedMessageCount(0);

    //sending the message in the direct:input mocked endpoint
          template.sendBody("direct:input", message);

    //validate the expectations
          assertMockEndpointsSatisfied();
      }
      @Test
      public void testRoutingUsa() throws Exception {
          String message = "&lt;company&gt;&lt;country&gt;USA&lt;/country&gt;&lt;/company&gt;";

    //define the expectations on the direct:france mocked endpoint
          MockEndpoint franceEndpoint = getMockEndpoint("mock:direct:france");
          franceEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:usa mocked endpoint
          MockEndpoint usaEndpoint = getMockEndpoint("mock:direct:usa");
          usaEndpoint.expectedMessageCount(1);

    //define the expectations on the direct:error mocked endpoint
          MockEndpoint errorEndpoint = getMockEndpoint("mock:direct:error");
          errorEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:other mocked endpoint
          MockEndpoint otherEndpoint = getMockEndpoint("mock:direct:other");
          otherEndpoint.expectedMessageCount(0);

    //sending the message in the direct:input mocked endpoint
          template.sendBody("direct:input", message);

    //validate the expectations
          assertMockEndpointsSatisfied();
      }

      @Test
      public void testRoutingOther() throws Exception {
          String message = "&lt;company&gt;&lt;country&gt;Spain&lt;/country&gt;&lt;/company&gt;";

    //define the expectations on the direct:france mocked endpoint
          MockEndpoint franceEndpoint = getMockEndpoint("mock:direct:france");
          franceEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:usa mocked endpoint
          MockEndpoint usaEndpoint = getMockEndpoint("mock:direct:usa");
          usaEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:error mocked endpoint
          MockEndpoint errorEndpoint = getMockEndpoint("mock:direct:error");
          errorEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:other mocked endpoint
          MockEndpoint otherEndpoint = getMockEndpoint("mock:direct:other");
          otherEndpoint.expectedMessageCount(1);

    //sending the message in the direct:input mocked endpoint
          template.sendBody("direct:input", message);

    //validate the expectations
          assertMockEndpointsSatisfied();
      }

      @Test
      public void testError() throws Exception {
          String message = "&lt;company&gt;&lt;country&gt;France&lt;/country&gt;&lt;/company&gt;";

    // fake an error on the direct:france mocked endpoint
          MockEndpoint franceEndpoint = getMockEndpoint("mock:direct:france");
          franceEndpoint.whenAnyExchangeReceived(new Processor() {
              public void process(Exchange exchange) throws Exception {
                  throw new IOException("Simulated error");
              }
          });

     //define the expectations on the direct:usa mocked endpoint
          MockEndpoint usaEndpoint = getMockEndpoint("mock:direct:usa");
          usaEndpoint.expectedMessageCount(0);

    //define the expectations on the direct:error mocked endpoint
          MockEndpoint errorEndpoint = getMockEndpoint("mock:direct:error");
          errorEndpoint.expectedMessageCount(1);

    //define the expectations on the direct:other mocked endpoint
          MockEndpoint otherEndpoint = getMockEndpoint("mock:direct:other");
          otherEndpoint.expectedMessageCount(0);

    //sending the message in the direct:input mocked endpoint
          template.sendBody("direct:input", message);

          // validate the expectations
          assertMockEndpointsSatisfied();
      }

}</pre></div><p>This class extends the <code class="literal">CamelBlueprintTestSupport</code> class, as our route is written using the Blueprint DSL. Before<a id="id435" class="indexterm"/> actually implementing the tests, we have to <span class="emphasis"><em>bootstrap</em></span> the test.</p><p>The first step is to load the Blueprint XML. For that, we override the <code class="literal">getBlueprintDescriptor()</code> method. This method just returns the location of the Blueprint XML file.</p><p>The second step is to define the endpoints that we want to mock. So we override the <code class="literal">isMockEndpointsAndSkip()</code> method. This method returns a regular expression for the endpoints URI to match. Camel will mock the corresponding endpoints and won't send the message to the actual endpoints. Here, we want to mock all <span class="emphasis"><em>outbound</em></span> endpoints of the routes—<code class="literal">direct:error</code>, <code class="literal">direct:france</code>, <code class="literal">direct:usa</code>, and <code class="literal">direct:other</code>. We don't want to mock the <code class="literal">direct:input</code> <span class="emphasis"><em>inbound</em></span> endpoint, as we will use the producer template to send an exchange there.</p><p>We are now ready to implement the unit tests.</p><p>The tests are implemented by method annotation with <code class="literal">@Test</code>.</p><p>The first test method is<a id="id436" class="indexterm"/> <code class="literal">testRoutingFrance()</code>. This test:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creates an XML message containing an element country with <code class="literal">France</code> as the value</li><li class="listitem" style="list-style-type: disc">On the mocked <code class="literal">direct:france</code> endpoint, we expect to receive one message, according to the ContentBasedRouter EIP</li><li class="listitem" style="list-style-type: disc">On the mocked <code class="literal">direct:usa</code> endpoint, we expect to receive no message</li><li class="listitem" style="list-style-type: disc">On the mocked <code class="literal">direct:error</code> endpoint, we expect to receive no message</li><li class="listitem" style="list-style-type: disc">On the mocked <code class="literal">direct:other</code> endpoint, we expect to receive no message</li><li class="listitem" style="list-style-type: disc">We use the producer template to send the XML message to the <code class="literal">direct:input</code> endpoint</li><li class="listitem" style="list-style-type: disc">Once the message has been sent, we check if the expectations are satisfied</li></ul></div><p>The second test method is <code class="literal">testRoutingUsa()</code>. This test is basically the same as the <code class="literal">testRoutingFrance()</code> method. However, we want to test the <code class="literal">ContentBasedRouter</code> with an XML message <a id="id437" class="indexterm"/>containing the <code class="literal">&lt;country/&gt;</code> element with the <code class="literal">USA</code> value. We update the expectations on the different mocked endpoints.</p><p>The third test method is <code class="literal">testRoutingOther()</code>. This test is basically the same as the two previous methods. However, we<a id="id438" class="indexterm"/> want to test the <code class="literal">ContentBasedRouter</code> with an XML message containing the <code class="literal">&lt;country/&gt;</code> element with the <code class="literal">Spain</code> value. We update the expectations accordingly.</p><p>We also want to<a id="id439" class="indexterm"/> test our <code class="literal">DefaultErrorHandling</code>. So, we want to simulate an error to see if the error handler reacts as expected.</p><p>To fake an error, we add a processor on the mocked <code class="literal">direct:france</code> endpoint. This processor throws an <code class="literal">IOException</code>. This exception will be caught by the error handler.</p><p>As the error handler <span class="emphasis"><em>forwards</em></span> the message to the <code class="literal">direct:error</code> endpoint, we can define the expectations on the mocked <code class="literal">direct:error</code> to be sure that the endpoint received the <span class="emphasis"><em>failed</em></span> message (forwarded by the error handler).</p><p>To execute our tests, we just run:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mvn clean test</strong></span>

<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-12) is starting</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.management.DefaultManagementStrategy - JMX is disabled</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.InterceptSendToMockEndpointStrategy - Adviced endpoint [direct://error] with mock endpoint [mock:direct:error]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.InterceptSendToMockEndpointStrategy - Adviced endpoint [direct://france] with mock endpoint [mock:direct:france]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.InterceptSendToMockEndpointStrategy - Adviced endpoint [direct://usa] with mock endpoint [mock:direct:usa]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.InterceptSendToMockEndpointStrategy - Adviced endpoint [direct://other] with mock endpoint [mock:direct:other]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - AllowUseOriginalMessage is enabled. If access to the original message is not needed, then its recommended to turn this option off as it may improve performance.</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Route: test started and consuming from: Endpoint[direct://input]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Total 1 routes, of which 1 is started.</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-12) started in 0.015 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting: Endpoint[mock://direct:france] is satisfied</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting: Endpoint[mock://direct:usa] is satisfied</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting: Endpoint[mock://direct:error] is satisfied</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting: Endpoint[mock://direct:other] is satisfied</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - ********************************************************************************</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - Testing done: testRoutingOther(com.packt.camel.test.RouteTest)</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - Took: 0.021 seconds (21 millis)</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - ********************************************************************************</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-12) is shutting down</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.DefaultShutdownStrategy - Starting to graceful shutdown 1 routes (timeout 10 seconds)</strong></span>
<span class="strong"><strong>[Camel (22-camel-12) thread #3 - ShutdownTask] INFO org.apache.camel.impl.DefaultShutdownStrategy - Route: test shutdown complete, was consuming from: Endpoint[direct://input]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.DefaultShutdownStrategy - Graceful shutdown of 1 routes completed in 0 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-12) uptime 0.024 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-12) is shutdown in 0.002 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.aries.blueprint.container.BlueprintExtender - Destroying BlueprintContainer for bundle RouteTest</strong></span>
<span class="strong"><strong>[main] INFO org.apache.aries.blueprint.container.BlueprintExtender - Destroying BlueprintContainer for bundle org.apache.aries.blueprint</strong></span>
<span class="strong"><strong>[main] INFO org.apache.aries.blueprint.container.BlueprintExtender - Destroying BlueprintContainer for bundle org.apache.camel.camel-blueprint</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.osgi.Activator - Camel activator stopping</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.osgi.Activator - Camel activator stopped</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.test.blueprint.CamelBlueprintHelper - Deleting work directory target/bundles/1427661985280</strong></span>
<span class="strong"><strong>Tests run: 4, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 3.025 sec - in com.packt.camel.test.RouteTest</strong></span>

<span class="strong"><strong>Results :</strong></span>

<span class="strong"><strong>Tests run: 4, Failures: 0, Errors: 0, Skipped: 0</strong></span>

<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] BUILD SUCCESS</strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Total time: 4.842 s</strong></span>
<span class="strong"><strong>[INFO] Finished at: 2015-03-29T22:46:25+02:00</strong></span>
<span class="strong"><strong>[INFO] Final Memory: 18M/303M</strong></span>
</pre></div><p>We can see the<a id="id440" class="indexterm"/> different mock endpoints created by Camel in the output messages, (for instance <code class="literal">[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting: Endpoint[mock://direct:other]</code> is satisfied).</p></div>
<div class="section" title="Additional annotations"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Additional annotations</h1></div></div></div><p>The Camel test kit also<a id="id441" class="indexterm"/> provides additional annotations, in order to simplify the code of your tests.</p><p>Instead of using the <code class="literal">getMockEndpoint()</code> method to get the mocked endpoints, you can use the <code class="literal">@EndpointInject</code> annotation:</p><div class="informalexample"><pre class="programlisting">@EndpointInject(uri = "mock:direct:france")
protected MockEndpoint franceEndpoint;</pre></div><p>Now, we can directly use the <code class="literal">franceEndpoint</code> mock endpoint in the test methods:</p><div class="informalexample"><pre class="programlisting">@Test
public void aTest() throws Exception {
  …
  franceEndpoint.expectedBodiesReceived("&lt;foo/&gt;");
  …
  franceEndpoint.assertIsSatisfied();
}</pre></div><p>Similarly, instead of <a id="id442" class="indexterm"/>defining the endpoint URI on the producer template, you can use the <code class="literal">@Producer</code> annotation to define where the producer template sends the message:</p><div class="informalexample"><pre class="programlisting">@Produce(uri = "direct:input");
protected ProducerTemplate template;</pre></div><p>We can now directly use the producer template without specifying the endpoint:</p><div class="informalexample"><pre class="programlisting">@Test
public void aTest() throws Exception {
  …
  template.sendBodyAndHeader("&lt;message/&gt;", "foo", "bar"); 

}</pre></div></div>
<div class="section" title="Mocking OSGi services"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Mocking OSGi services</h1></div></div></div><p>The Camel Blueprint test kit allows<a id="id443" class="indexterm"/> you to mock and prototype OSGi services.</p><p>For that, the kit uses the <code class="literal">PojoSR</code> library.</p><p>For instance, we want to test the following route:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;blueprint &gt;

      &lt;reference id="service" interface="org.apache.camel.Processor"/&gt;

      &lt;camelContext &gt;
          &lt;route id="test"&gt;
              &lt;from uri="direct:input"/&gt;
              &lt;process ref="service"/&gt;
              &lt;to uri="direct:output"/&gt;
          &lt;/route&gt;
      &lt;/camelContext&gt;

&lt;/blueprint&gt;</pre></div><p>If this route is very simple, it uses an OSGi service via the <code class="literal">&lt;reference/&gt;</code> element. In the OSGi container, the reference element is looking for the actual service in the OSGi Service Registry.</p><p>Instead of using a real blueprint container, the Camel Blueprint test kit allows you to register services. For that, we just override the <code class="literal">addServicesOnStartup()</code> method where we add the<a id="id444" class="indexterm"/> bean providing the services used in the route.</p><p>The test class is as follows:</p><div class="informalexample"><pre class="programlisting">package com.packt.camel.test;

import org.apache.camel.Exchange; import org.apache.camel.Processor;
import org.apache.camel.component.mock.MockEndpoint;
import org.apache.camel.test.blueprint.CamelBlueprintTestSupport;
import org.apache.camel.util.KeyValueHolder;
import org.junit.Test;

import java.util.Dictionary;
import java.util.Map;

public class RouteTest extends CamelBlueprintTestSupport {

      @Override
      protected String getBlueprintDescriptor() {
          return "OSGI-INF/blueprint/route.xml";
      }

      @Override
      public String isMockEndpointsAndSkip() {
          return "direct:output";
      }

      @Override
      public void addServicesOnStartup(Map&lt;String, KeyValueHolder&lt;Object, Dictionary&gt;&gt; services) {
          KeyValueHolder serviceHolder = new KeyValueHolder(new Processor() {
             public void process(Exchange exchange) throws Exception {
                exchange.getIn().setBody("DONE", String.class);
             }
          }, null);
          services.put(Processor.class.getName(), serviceHolder);
      }

      @Test
      public void testRoute() throws Exception {
          String message = "BEGIN";

          MockEndpoint franceEndpoint = getMockEndpoint("mock:direct:output");
          franceEndpoint.expectedMessageCount(1);
          franceEndpoint.expectedBodiesReceived("DONE");

          template.sendBody("direct:input", message);

          assertMockEndpointsSatisfied();
      }
}</pre></div><p>We can see<a id="id445" class="indexterm"/> that we define the mocked service directly in the test. As for the previous test, we execute the test with:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mvn clean test</strong></span>

<span class="strong"><strong>[main] INFO org.apache.aries.blueprint.container.BlueprintExtender - No quiesce support is available, so blueprint components will not participate in quiesce operations</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - *********************************************************************</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - Testing: testService(com.packt.camel.test.RouteTest)</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - *********************************************************************</strong></span>
<span class="strong"><strong>[Blueprint Extender: 3] INFO org.apache.aries.blueprint.container.BlueprintContainerImpl - Bundle RouteTest is waiting for namespace handlers [http://camel.apache.org/schema/blueprint]</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - Skipping starting CamelContext as system property skipStartingCamelContext is set to be true.</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-3) is starting</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.management.DefaultManagementStrategy - JMX is disabled</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.InterceptSendToMockEndpointStrategy - Adviced endpoint [direct://output] with mock endpoint [mock:direct:output]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - AllowUseOriginalMessage is enabled. If access to the original message is not needed, then its recommended to turn this option off as it may improve performance.</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - StreamCaching is not in use. If using streams then its recommended to enable stream caching. See more details at http://camel.apache.org/stream-caching.html</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Route: test started and consuming from: Endpoint[direct://input]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Total 1 routes, of which 1 is started.</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-3) started in 0.050 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.component.mock.MockEndpoint - Asserting: Endpoint[mock://direct:output] is satisfied</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - *********************************************************************</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - Testing done: testService(com.packt.camel.test.RouteTest)</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - Took: 0.062 seconds (62 millis)</strong></span>
<span class="strong"><strong>[main] INFO com.packt.camel.test.RouteTest - *********************************************************************</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-3) is shutting down</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.DefaultShutdownStrategy - Starting to graceful shutdown 1 routes (timeout 10 seconds)</strong></span>
<span class="strong"><strong>[Camel (22-camel-3) thread #0 - ShutdownTask] INFO org.apache.camel.impl.DefaultShutdownStrategy - Route: test shutdown complete, was consuming from: Endpoint[direct://input]</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.DefaultShutdownStrategy - Graceful shutdown of 1 routes completed in 0 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-3) uptime 0.070 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.blueprint.BlueprintCamelContext - Apache Camel 2.12.4 (CamelContext: 22-camel-3) is shutdown in 0.007 seconds</strong></span>
<span class="strong"><strong>[main] INFO org.apache.aries.blueprint.container.BlueprintExtender - Destroying BlueprintContainer for bundle RouteTest</strong></span>
<span class="strong"><strong>[main] INFO org.apache.aries.blueprint.container.BlueprintExtender - Destroying BlueprintContainer for bundle org.apache.aries.blueprint</strong></span>
<span class="strong"><strong>[main] INFO org.apache.aries.blueprint.container.BlueprintExtender - Destroying BlueprintContainer for bundle org.apache.camel.camel-blueprint</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.osgi.Activator - Camel activator stopping</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.impl.osgi.Activator - Camel activator stopped</strong></span>
<span class="strong"><strong>[main] INFO org.apache.camel.test.blueprint.CamelBlueprintHelper - Deleting work directory target/bundles/1427662210482</strong></span>
<span class="strong"><strong>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.744 sec - in com.packt.camel.test.RouteTest</strong></span>

<span class="strong"><strong>Results :</strong></span>

<span class="strong"><strong>Tests run: 1, Failures: 0, Errors: 0, Skipped: 0</strong></span>

<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] BUILD SUCCESS</strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
<span class="strong"><strong>[INFO] Total time: 3.573 s</strong></span>
<span class="strong"><strong>[INFO] Finished at: 2015-03-29T22:50:12+02:00</strong></span>
<span class="strong"><strong>[INFO] Final Memory: 18M/303M</strong></span>
<span class="strong"><strong>[INFO] --------------------------------------------------------------</strong></span>
</pre></div><p>As we saw in this chapter, the Camel test kits allow you to easily prototype services and endpoints, and test your routes.</p><p>Tests are really important to guarantee the integration logic implemented, and also to be sure that the <a id="id446" class="indexterm"/>error handler and routing react as you expect.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Summary</h1></div></div></div><p>As we see in this chapter, Camel provides rich features allowing you to easily implement unit tests and integration tests.</p><p>Thanks to that, you can test the integration logic that you want to implement in your routes, and you can also move forward in your implementation, by mocking parts of your integration logic.</p><p>With such tests, you can use test driven implementation, where you start by implementing the test with your expectation, and implement your routes based on these expectations.</p></div></body></html>