["```java\ncase class CounterUpdate(i: Int) \ncase class GCounterState(uid: Int, counter: Int) \n\nclass StateBasedGCounter( \n uid: Int, count: Int, otherCounters: Map[Int, Int]) { \n\n def value: Int = count + otherCounters.values.sum \n\n def update( \n   change: CounterUpdate): (StateBasedGCounter, GCounterState) = \n   (new StateBasedGCounter(uid, count + change.i, otherCounters), \n     GCounterState(uid, count)) \n\n def merge(other: GCounterState): StateBasedGCounter = { \n   val newValue = other.counter max otherCounters.getOrElse(other.uid,0) \n   new StateBasedGCounter(uid, count, otherCounters.+(other.uid -> newValue) ) \n } \n} \n\n```", "```java\nclass OperationBasedCounter(count: Int) { \n\n def value: Int = count \n\n def update(change: CounterUpdate): (OperationBasedCounter, CounterUpdate) \n = \n   new OperationBasedCounter(count + change.i) -> change \n\n def merge(operation: CounterUpdate): OperationBasedCounter = \n   update(operation)._1 \n} \n\n```", "```java\ncase class PNCounterState(incState: GCounterState, decState: GCounterState) \n\nclass StateBasedPNCounter private( \n incCounter: StateBasedGCounter, \n decCounter: StateBasedGCounter) { \n\n def value = incCounter.value - decCounter.value \n\n def update(change: CounterUpdate): (StateBasedPNCounter, PNCounterState) = { \n   val (newIncCounter, newDecCounter, stateUpdate) = \n     change match { \n       case CounterUpdate(c) if c >= 0 => \n         val (iC, iState) = incCounter.update(change) \n         val dState = GCounterState(decCounter.uid, decCounter.value) \n         (iC, decCounter, PNCounterState(iState, dState)) \n       case CounterUpdate(c) if c < 0 => \n         val (dC, dState) = decCounter.update(change) \n         val iState = GCounterState(incCounter.uid, incCounter.value) \n         (incCounter, dC, PNCounterState(iState, dState)) \n     } \n\n   (new StateBasedPNCounter(newIncCounter, newDecCounter), stateUpdate) \n } \n\n def merge(other: PNCounterState): StateBasedPNCounter = \n   new StateBasedPNCounter( \n     incCounter.merge(other.incState), \n     decCounter.merge(other.decState) \n   ) \n} \n\n```", "```java\ncase class AddElement[A](a: A) \ncase class GSetState[A](set: Set[A]) \n\nclass StateBasedGSet[A](val value: Set[A]) { \n\n def contains(a: A): Boolean = value.contains(a) \n\n def update(a: AddElement[A]): (StateBasedGSet[A], GSetState[A]) = { \n   val newSet = new StateBasedGSet(value + a.a) \n   (newSet, GSetState(newSet.value)) \n } \n\n def merge(other: GSetState[A]): StateBasedGSet[A] = { \n   new StateBasedGSet(value ++ other.set) \n } \n\n} \n\n```", "```java\ncase class Bid(value: BigDecimal) extends AnyVal \ncase class Offer(value: BigDecimal) extends AnyVal \ncase class Ticker(value: String) extends AnyVal \ncase class BboUpdated(ticker: Ticker, bid: Bid, offer: Offer) \n\n```", "```java\nval queue = new LinkedBlockingQueue[Message](1000) \nqueue.put(m) \n\n```", "```java\nmaximum total processing latency = queue size * maximum processing time \n\n```", "```java\nqueue size = maximum total processing latency / maximum processing time \n\n```", "```java\nqueue size = 10ms / 0.5ms = 20 \n\n```", "```java\nval queue = new LinkedBlockingQueue[(MessageSentTimestamp, BboUpdated)](20) \n    val eventThread = new Thread(new Runnable { \n      def run(): Unit = while (true) { \n        Option(queue.poll(5, TimeUnit.SECONDS)) match { \n          case Some((ts, e)) => // process event \n          case None => // no event found \n        } \n      } \n    }) \n    eventThread.setDaemon(true) \n    eventThread.start() \n\n```", "```java\nqueue.put((ts, e)) \n\n```", "```java\nqueue.offer((ts, e)) match { \n  case true => // event enqueued \n  case false => // event discarded \n} \n\n```", "```java\nqueue size = maximum total processing latency / maximum processing time = 10ms / 0.1ms = 100 \n\n```", "```java\ndef pipeline(ts: MessageSentTimestamp, e: Event): Unit = { \n    val enriched = enrichEvent(e) \n    journalEvent(enriched) \n    performPreTradeBalanceChecks(enriched) \n    runBusinessLogic(enriched) \n  } \n} \n\n```", "```java\ndef pipeline(ts: MessageSentTimestamp, e: Event): Unit = { \n    if (!hasEventProcessingExpiryExpired(ts)) { \n      val enriched = enrichEvent(e) \n      if (!hasEventProcessingExpiryExpired(ts)) journalEvent(enriched) \n      if (!hasEventProcessingExpiryExpired(ts)) performPreTradeBalanceChecks(enriched) \n      if (!hasEventProcessingExpiryExpired(ts)) runBusinessLogic(enriched) \n    } \n  } \n} \n\n```", "```java\n    val enriched = enrichEvent(bboEvent) \n    journalEvent(enriched) \n    performPreTradeBalanceChecks(enriched) \n    val decision = strategy.makeTradingDecision(enriched) \n    decision.foreach(sendTradingDecision) \n\n```", "```java\ntrait TradingStrategy { \n  def makeTradingDecision(e: BboUpdated): Option[Either[Bid, Offer]] \n} \n\n```", "```java\nval pipeline = for { \n    enriched <- StartWith(enrichEvent) within (8 millis) orElse (e => \n      enrichmentFailure(e.ticker)) \n    _ <- Step(journalEvent(enriched)) within (9 millis) orElse \n      tradeAuthorizationFailure \n    _ <- Step(performPreTradeBalanceChecks(enriched)) within (10 millis) \n      orElse metricRecordingFailure \n    decision <- MakeTradingDecision(enriched) \n  } yield decision \n\n```", "```java\n  def runWithFoldInterpreter( \n    recordProcessingLatency: ProcessingLatencyMs => Unit, \n    strategy: TradingStrategy, \n    ts: MessageSentTimestamp, \n    e: BboUpdated): Unit = { \n    val (_, decision) = pipeline.free.foldRun( \n      PipelineState(ts, strategy, e)) { \n      case (state, StartProcessing(whenActive, whenExpired, limitMs)) => \n        state -> (hasProcessingTimeExpired(state.ts, limitMs) match { \n          case true => whenExpired(e) \n          case false => whenActive(e) \n        }) \n      case (state, Timed(whenActive, whenExpired, limitMs)) => \n        state -> (hasProcessingTimeExpired(state.ts, limitMs) match { \n          case true => whenExpired() \n          case false => whenActive() \n        }) \n      case (state, TradingDecision(runStrategy)) => \n        state -> runStrategy(state.strategy) \n    } \n\n    decision.fold(logFailure, { \n      case Some(order) => \n        sendTradingDecision(order) \n        recordProcessingLatency(ProcessingLatencyMs( \n          System.currentTimeMillis() - ts.value)) \n      case None => \n        recordProcessingLatency(ProcessingLatencyMs( \n          System.currentTimeMillis() - ts.value)) \n    }) \n  } \n\n```", "```java\nsealed trait Thunk[A] \ncase class Timed[A]( \n  whenActive: () => A, \n  whenExpired: () => A, \n  limit: LimitMs) extends Thunk[A] \ncase class StartProcessing[A]( \n  whenActive: BboUpdated => A, \n  whenExpired: BboUpdated => A, \n  limit: LimitMs) extends Thunk[A] \ncase class TradingDecision[A]( \n  makeDecision: TradingStrategy => A) extends Thunk[A] \n\n```", "```java\n  private def thunkToTask(ps: PipelineState): Thunk ~> Task = \n    new (Thunk ~> Task) { \n    def apply[B](t: Thunk[B]): Task[B] = t match { \n      case StartProcessing(whenActive, whenExpired, \n        limitMs) => Task.suspend( \n        hasProcessingTimeExpired(ps.ts, limitMs) match { \n          case true => Task.now(whenExpired(ps.event)) \n          case false => Task.now(whenActive(ps.event)) \n        }) \n      case Timed(whenActive, whenExpired, limitMs) => Task.suspend( \n        hasProcessingTimeExpired(ps.ts, limitMs) match { \n          case true => Task.now(whenExpired()) \n          case false => Task.now(whenActive()) \n        }) \n      case TradingDecision(runStrategy) => \n        Task.fork(Task.now(runStrategy(ps.strategy))) \n    } \n  } \n\n```", "```java\ndef suspend[A](a: => Task[A]): Task[A] \n\n```", "```java\npipeline.free.foldMap(thunkToTask(PipelineState(ts, strategy, event))) \n      .unsafePerformAsync { \n        case -\\/(ex) => logException(ex) \n        case \\/-(\\/-(decision)) => \n          decision.foreach(sendTradingDecision) \n          recordProcessingLatency(ProcessingLatencyMs( \n            System.currentTimeMillis() - ts.value)) \n        case \\/-(-\\/(failure)) => logFailure(failure) \n      } \n\n```"]