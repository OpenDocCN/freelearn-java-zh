<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer108">
			</div>
		</div>
		<div class="Content" id="_idContainer109">
			<h1 id="_idParaDest-282"><a id="_idTextAnchor290"/>14. Recursion</h1>
		</div>
		<div class="Content" id="_idContainer110">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, we will see how using recursion can help you to write effective code. The chapter begins with an initial exercise illustrating one of the simplest mistakes you can make with recursion: forgetting to code a termination condition. The first step, then, is learning how to salvage your program when the Java stack has blown away. From there, you will learn to write recursive methods in order to handle mathematical formulas and other recurrent processing needs. Finally, with these techniques (and those further defined by this chapter), you will practice creating and processing XML files with the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>) API.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor291"/>Introduction</h1>
			<p>Recursion is where a method calls itself, over and over again. Recursion, when used carefully, can be a useful programming technique; but the key is to use it correctly.</p>
			<p>An important point is that recursion is just a programming technique. You can often avoid it, if you want, by writing some form of an iterative loop. However, if the problem you need to solve is truly recursive, the iterative approach will likely be much more complex than the comparatively simpler and more elegant recursion code which corresponds.</p>
			<p>This chapter delves into this handy programming technique.</p>
			<h1 id="_idParaDest-284"><a id="_idTextAnchor292"/>Delving into Recursion</h1>
			<p>Recursion is useful for many mathematical problems, such as when working with cellular automata, Sierpinski triangles, and fractals. In computer graphics, recursion can be used to help generate realistic-looking mountains, plants, and other natural phenomena. Classic problems, such as the Tower of Hanoi, work well with recursion.</p>
			<p>In Java applications, you will often use recursion when traversing tree data structures, including XML and HTML documents.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can refer to <a href="https://packt.live/2JaIre8">https://packt.live/2JaIre8</a> for more information on the Tower of Hanoi problem.</p>
			<p>A simple example of recursion looks like the following:</p>
			<p class="source-code">public int add(int num) {</p>
			<p class="source-code">    return add(num + 1);</p>
			<p class="source-code">}</p>
			<p>In this example, each call to the <strong class="source-inline">add()</strong> method will call itself with a number that is one greater than the one used for the current call.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You always need a termination condition to stop the recursion. This example does not have one.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor293"/>Exercise 1: Using Recursion to Overflow the Stack</h2>
			<p>This example demonstrates what happens when you don't provide a way for a recursive method to stop. Bad things happen to your program. Follow these steps to perform the exercise:</p>
			<ol>
				<li>Select <strong class="source-inline">New</strong> and then select <strong class="source-inline">Project…</strong> from the <strong class="source-inline">File</strong> menu in IntelliJ. </li>
				<li>Select <strong class="source-inline">Gradle</strong> for the type of project. Click on <strong class="source-inline">Next</strong>.</li>
				<li>For <strong class="source-inline">Group Id</strong>, enter <strong class="source-inline">com.packtpub.recursion</strong>.</li>
				<li>For <strong class="source-inline">Artifact Id</strong>, enter <strong class="source-inline">chapter14</strong>.</li>
				<li>For <strong class="source-inline">Version</strong>, enter <strong class="source-inline">1.0</strong>.</li>
				<li>Accept the default on the next pane. Click on <strong class="source-inline">Next</strong>.</li>
				<li>Leave the project name as <strong class="source-inline">chapter14</strong>.</li>
				<li>Click on <strong class="source-inline">Finish</strong>.</li>
				<li>Call up <strong class="source-inline">build.gradle</strong> in the IntelliJ text editor.</li>
				<li>Change <strong class="source-inline">sourceCompatibility</strong> so that it is set to <strong class="source-inline">12</strong> as shown here:<p class="source-code">sourceCompatibility = 12</p></li>
				<li>In the <strong class="source-inline">src/main/java</strong> folder, create a new Java package.</li>
				<li>Enter <strong class="source-inline">com.packtpub.recursion</strong> as the package name.</li>
				<li>Right-click on this package in the <strong class="source-inline">Project</strong> pane and create a new Java class named <strong class="source-inline">RunForever</strong>.</li>
				<li>Enter the recursive method as follows:<p class="source-code">public int add(int num) {</p><p class="source-code">    return add(num + 1);</p><p class="source-code">}</p></li>
				<li>Enter a <strong class="source-inline">main()</strong> method as follows:<p class="source-code">public class RunForever {</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        RunForever runForever = new RunForever();</p><p class="source-code">        System.out.println(runForever.add(1));</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Run this program; you will see it fail with an exception:<p class="source-code">Exception in thread "main" java.lang.StackOverflowError</p><p class="source-code">at com.packtpub.recursion.RunForever.add(RunForever.java:11)</p><p>The full code will look as follows:</p><p class="source-code">package com.packtpub.recursion;</p><p class="source-code">public class RunForever {</p><p class="source-code">    public int add(int num) {</p><p class="source-code">        return add(num + 1);</p><p class="source-code">    }</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        RunForever runForever = new RunForever();</p><p class="source-code">        System.out.println(runForever.add(1));</p><p class="source-code">    }</p><p class="source-code">}</p><p>We can fix this problem by providing a terminating condition to stop the recursion, as shown in the following <strong class="source-inline">RunAndStop.java</strong> file:</p><p class="source-code">package com.packtpub.recursion;</p><p class="source-code">public class RunAndStop {</p><p class="source-code">    public int add(int num) {</p><p class="source-code">        if (num &lt; 100) {</p><p class="source-code">            return add(num + 1);</p><p class="source-code">        }</p><p class="source-code">        return num;</p><p class="source-code">    }</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        RunAndStop runAndStop = new RunAndStop();</p><p class="source-code">        System.out.println( runAndStop.add(1) );</p><p class="source-code">    }</p><p class="source-code">}</p><p>When you run this program, you will see the following output:</p><p class="source-code">100</p></li>
			</ol>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor294"/>Trying Tail Recursion</h2>
			<p>Tail recursion is when the last executable statement of the recursive method is a call to itself. Tail recursion is important because the Java compiler could—but doesn't at this time—jump back to the start of the method. This helps because the compiler wouldn't have to store the stack frame for the method call, making it more efficient and using less memory on the call sta<a id="_idTextAnchor295"/>ck.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor296"/>Exercise 2: Using Recursion to Calculate Factorials</h2>
			<p>Factorials are great examples for demonstrating how recursion works.</p>
			<p>You can calculate the factorial of an integer by multiplying the number with all the positive numbers that are less than itself. For example, the factorial of 4, also written as 4!, is calculated as 4 * 3 * 2 * 1. Carry out the following steps to perform the exercise:</p>
			<ol>
				<li value="1">Right-click on the <strong class="source-inline">com.packtpub.recursion</strong> package name.</li>
				<li>Create a new Java class named <strong class="source-inline">Factorial</strong>.</li>
				<li>Enter the recursive method:<p class="source-code">public static int factorial(int number) {</p><p class="source-code">    if (number == 1) {</p><p class="source-code">        return 1;</p><p class="source-code">    } else {</p><p class="source-code">        return number * factorial(number - 1);</p><p class="source-code">    }</p><p class="source-code">}</p><p>Since a factorial is a number multiplied by all positive numbers less than itself, in each call to the <strong class="source-inline">factorial()</strong> method, it returns the number multiplied by the factorial of the number minus one. If the passed-in number is 1, it returns simply the number 1.</p></li>
				<li>Enter the <strong class="source-inline">main()</strong> method, which launches the factorial calculation:<p class="source-code">public static void main(String[] args) {</p><p class="source-code">    System.out.println( factorial(6) );</p><p class="source-code">}</p><p>This code will calculate the factorial of 6, which is also represented as 6 factorial or 6!.</p></li>
				<li>When you run this program, you will see the following output:<p class="source-code">720</p><p>The full code will look as follows:</p><p class="source-code">package com.packtpub.recursion;</p><p class="source-code">public class Factorial {</p><p class="source-code">    public static int factorial(int number) {</p><p class="source-code">        if (number == 1) {</p><p class="source-code">            return 1;</p><p class="source-code">        } else {</p><p class="source-code">            return number * factorial(number - 1);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    public static void main(String[] args) {</p><p class="source-code">        System.out.println( factorial(6) );</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Factorials and many other mathematical concepts work well with recursion. Another common task that fits with this programming technique is processing a hierarchical document, such as XML or HTML.</p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor297"/>Processing an XML Document</h2>
			<p>XML documents have nodes. Each node may have child nodes; for example, consider the following:</p>
			<p class="source-code-heading">cities.xml</p>
			<p class="source-code">1  &lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;</p>
			<p class="source-code">2  &lt;cities&gt;</p>
			<p class="source-code">3    &lt;city&gt;</p>
			<p class="source-code">4      &lt;name&gt;London&lt;/name&gt;</p>
			<p class="source-code">5      &lt;country&gt;United Kingdom&lt;/country&gt;</p>
			<p class="source-code">6      &lt;summertime-high-temp&gt;20.4 C&lt;/summertime-high-temp&gt;</p>
			<p class="source-code">7      &lt;in-year-2100&gt;</p>
			<p class="source-code">8          &lt;with-moderate-emission-cuts&gt;</p>
			<p class="source-code">9            &lt;name&gt;Paris&lt;/name&gt;</p>
			<p class="source-code">10          &lt;country&gt;France&lt;/country&gt;</p>
			<p class="source-code">11          &lt;summertime-high-temp&gt;22.7 C&lt;/summertime-high-temp&gt;</p>
			<p class="source-code">12        &lt;/with-moderate-emission-cuts&gt;</p>
			<p class="source-code-link"><a href="https://packt.live/2N4X4Rl">https://packt.live/2N4X4Rl</a></p>
			<p>In this XML snippet, the <strong class="source-inline">&lt;cities&gt;</strong> element has one child element, <strong class="source-inline">&lt;city&gt;</strong>. The <strong class="source-inline">&lt;city&gt;</strong> child element, in turn, has four child elements. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">This data comes from <a href="https://packt.live/31yBoSL">https://packt.live/33IrCyR</a> and was used in an exercise in <em class="italic">Chapter 6</em>, <em class="italic">Libraries, Packages, and Modules</em>.</p>
			<p>Now, consider how you would write code to process the above XML data. Java comes with classes to parse the XML file. The only issue is what to do with the XML document once you have parsed it into Java objects. That's where recursion can be useful.</p>
			<p>You could write code to process each <strong class="source-inline">&lt;city&gt;</strong> element, such as the data for <strong class="source-inline">London</strong>. In that element, the code would extract the data from the child elements, such as the name of the city, the name of the country, and the summertime high temperature.</p>
			<p>Note how the two additional cities, <strong class="source-inline">Paris</strong> and <strong class="source-inline">Milan</strong>, are shown. This data could be processed in a similar way to how the <strong class="source-inline">London</strong> data was processed. Once you see the similarity, you may find that recursion proves useful.</p>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor298"/>Exercise 3: Creating an XML File</h2>
			<p>To demonstrate how to parse and then recursively traverse XML documents, we need some XML data:</p>
			<ol>
				<li value="1">Right-click on <strong class="source-inline">src/main/resources</strong> and select <strong class="source-inline">New</strong> and then <strong class="source-inline">File</strong>.</li>
				<li>Enter <strong class="source-inline">cities.xml</strong> as the name of the file.</li>
				<li>Enter the following XML data into the file:</li>
			</ol>
			<p class="source-code-heading">cities.xml</p>
			<p class="source-code">2  &lt;cities&gt;</p>
			<p class="source-code">3    &lt;city&gt;</p>
			<p class="source-code">4      &lt;name&gt;London&lt;/name&gt;</p>
			<p class="source-code">5      &lt;country&gt;United Kingdom&lt;/country&gt;</p>
			<p class="source-code">6      &lt;summertime-high-temp&gt;20.4 C&lt;/summertime-high-temp&gt;</p>
			<p class="source-code">7      &lt;in-year-2100&gt;</p>
			<p class="source-code">8          &lt;with-moderate-emission-cuts&gt;</p>
			<p class="source-code">9            &lt;name&gt;Paris&lt;/name&gt;</p>
			<p class="source-code">10          &lt;country&gt;France&lt;/country&gt;</p>
			<p class="source-code">11          &lt;summertime-high-temp&gt;22.7 C&lt;/summertime-high-temp&gt;</p>
			<p class="source-code">12        &lt;/with-moderate-emission-cuts&gt;</p>
			<p class="source-code-link"><a href="https://packt.live/2N4X4Rl">https://packt.live/2N4X4Rl</a></p>
			<p>Java includes more than one API for processing XML data. With the <strong class="bold">Simple API for XML</strong> (<strong class="bold">SAX</strong>), you can process an XML document one event at a time. Events include starting an element, getting some text from within an element, and ending an element. </p>
			<p>With the <strong class="bold">Document Object Model</strong> (<strong class="bold">DOM</strong>), the API reads in an XML document. From this point your code can traverse the elements in the tree of DOM elements. The API that fits best with recursive processing is the DOM API.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can find more information about the Java XML APIs at <a href="https://packt.live/31yBoSL">https://packt.live/31yBoSL</a> and <a href="https://packt.live/2BvD2tJ">https://packt.live/2BvD2tJ</a>.</p>
			<h2 id="_idParaDest-290"><a id="_idTextAnchor299"/>Introducing the DOM XML API</h2>
			<p>With the DOM API, you can use a <strong class="source-inline">DocumentBuilder</strong> class to parse an XML file into a tree of objects in memory. These objects all implement the <strong class="source-inline">org.w3c.Node</strong> interface. The node interface allows you to extract data from each XML element and then retrieve all the child nodes under a node.</p>
			<p>Regular XML elements, such as <strong class="source-inline">&lt;city&gt;</strong> in our example, implement the <strong class="source-inline">Element</strong> interface, which extends the <strong class="source-inline">Node</strong> interface. Additionally, textual items implement the <strong class="source-inline">Text</strong> interface. And, the overall document is represented by the <strong class="source-inline">Document</strong> interface.</p>
			<p>The entire DOM is hierarchical. For example, consider the following:</p>
			<p class="source-code">&lt;city&gt;</p>
			<p class="source-code">    &lt;name&gt;London&lt;/name&gt;</p>
			<p class="source-code">&lt;/city&gt;</p>
			<p>In this short snippet, <strong class="source-inline">&lt;city&gt;</strong> is an element, and has a child element for <strong class="source-inline">&lt;name&gt;</strong>. The <strong class="source-inline">London</strong> text is a child of the <strong class="source-inline">&lt;name&gt;</strong> element. The <strong class="source-inline">London</strong> text will be held in an object that implements the <strong class="source-inline">Text</strong> interface.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The DOM API needs to load the entire XML document into a hierarchy of nodes. The DOM API would not be appropriate for a large XML document, as you could run out of memory.</p>
			<p>When using the DOM API, the first step is to load an XML file and parse it into the hierarchy of objects.</p>
			<p>To do that, you need a <strong class="source-inline">DocumentBuilder</strong> class:</p>
			<p class="source-code">DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</p>
			<p class="source-code">DocumentBuilder builder = factory.newDocumentBuilder();</p>
			<p>Once you have a <strong class="source-inline">DocumentBuilder</strong> class, you can parse an XML file to get a <strong class="source-inline">Document</strong> interface:</p>
			<p class="source-code">File xmlFile = new File("src/main/resources/cities.xml");</p>
			<p class="source-code">Document document = builder.parse(xmlFile);</p>
			<p>Since a <strong class="source-inline">Document</strong> is a <strong class="source-inline">Node</strong>, you can start processing all the child nodes. Typically, you start with the first child of the <strong class="source-inline">Document</strong> interface (<strong class="source-inline">&lt;cities&gt;</strong> in our earlier example):</p>
			<p class="source-code">Node node = document.getFirstChild();</p>
			<p class="source-code">NodeList children = node.getChildNodes();</p>
			<p class="source-code">for (int i = 0; i &lt; children.getLength(); i++) {</p>
			<p class="source-code">    Node child = children.item(i);</p>
			<p class="source-code">}</p>
			<p>The call to <strong class="source-inline">getFirstChild()</strong> returns the first child of the <strong class="source-inline">document</strong>, which is the top-level XML element. You can then call <strong class="source-inline">getChildNodes()</strong> to retrieve all the immediate child elements. Unfortunately, the <strong class="source-inline">NodeList</strong> object returned is not a <strong class="source-inline">List</strong> and not a <strong class="source-inline">Collection</strong> interface, which makes iterating over the child nodes more difficult.</p>
			<p>You can then use recursion to get the child nodes of any given node, and the children of those children, and so on. For example, look at the following:</p>
			<p class="source-code">if (node.hasChildNodes()) {</p>
			<p class="source-code">    indentation += 2;</p>
			<p class="source-code">    NodeList children = node.getChildNodes();</p>
			<p class="source-code">    for (int i = 0; i &lt; children.getLength(); i++) {</p>
			<p class="source-code">        Node child = children.item(i);</p>
			<p class="source-code">        if (child.getNodeType() == Node.TEXT_NODE) {</p>
			<p class="source-code">            printText(child.getTextContent() );</p>
			<p class="source-code">        } else {            </p>
			<p class="source-code">            traverseNode(child, indentation);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we first check whether a given node has child nodes. If not, we have nothing to do. If there are child nodes, we'll use the same technique shown previously to get each child node.</p>
			<p>Once we have a node, the code checks whether the node is a <strong class="source-inline">Text</strong> node by using the <strong class="source-inline">getNodeType()</strong> method. If the node is a <strong class="source-inline">Text</strong> node, we'll print out the text. If not, we'll make a recursive call with the child node. This will retrieve all the children of the child node.</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor300"/>Exercise 4: Traversing an XML Document</h2>
			<p>In this exercise, we'll write code to traverse the tree of node objects parsed from the <strong class="source-inline">cities.xml</strong> file we created in <em class="italic">Exercise 3</em>, <em class="italic">Creating an XML File</em>. The code will print out the XML elements as text. Carry out the following steps to complete the exercise:</p>
			<ol>
				<li value="1">Edit the <strong class="source-inline">build.gradle</strong> file. Add new dependency for the <strong class="source-inline">Apache Commons Lang</strong> library:<p class="source-code">dependencies {</p><p class="source-code">    testCompile group: 'junit', name: 'junit', version: '4.12'</p><p class="source-code">    // https://mvnrepository.com/artifact/org.apache.commons/commons-lang3</p><p class="source-code">    implementation group: 'org.apache.commons', name: 'commons-lang3', version: '3.8.1'</p><p class="source-code">}</p><p>This library has a few helpful utility methods that we will use when generating the output.</p></li>
				<li>Right-click on the <strong class="source-inline">com.packtpub.recursion</strong> package name.</li>
				<li>Create a new Java class named <strong class="source-inline">XmlTraverser</strong>.</li>
				<li>Enter the following method to load an XML file into the DOM tree:<p class="source-code-heading">XmlTraverser.java</p><p class="source-code">17 public Document loadXml() {</p><p class="source-code">18   Document document = null;</p><p class="source-code">19 </p><p class="source-code">20   DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();</p><p class="source-code">21   try {</p><p class="source-code">22     DocumentBuilder builder = factory.newDocumentBuilder();</p><p class="source-code">23 </p><p class="source-code">24     File xmlFile = new File("src/main/resources/cities.xml");</p><p class="source-code">25     document = builder.parse(xmlFile);</p><p class="source-code">26 </p><p class="source-code">27   } </p><p class="source-code-link"><a href="https://packt.live/33MDhN2">https://packt.live/33MDhN2</a></p><p>Note how this code catches all the possible exceptions from reading in the file and parsing the XML content.</p></li>
				<li>Next, enter in a method to print the <strong class="source-inline">Text</strong> node content:<p class="source-code">public void printText(String text) {</p><p class="source-code">    if (StringUtils.isNotBlank(text)) {</p><p class="source-code">        System.out.print(text);</p><p class="source-code">    }</p><p class="source-code">}</p><p>This method uses the Apache <strong class="source-inline">StringUtils</strong> class to check whether the text is blank or not. You'll find that the DOM API populates a lot of blank <strong class="source-inline">Text</strong> nodes. </p></li>
				<li>To help represent the hierarchical nature of XML documents, enter a utility method for indenting:<p class="source-code">public void indent(int indentation) {</p><p class="source-code">    System.out.print( StringUtils.leftPad("", indentation));</p><p class="source-code">}</p><p>Again, we use the <strong class="source-inline">StringUtils</strong> class to do the tedious work of padding an empty string with a given number of spaces.</p></li>
				<li>Next, we create the main recursive method:<p class="source-code">    public void traverseNode(Node node, int indentation) {</p><p class="source-code">        indent(indentation);</p><p class="source-code">        System.out.print(node.getNodeName() + " ");</p><p class="source-code">        if (node.hasChildNodes()) {</p><p class="source-code">            indentation += 2;</p><p class="source-code">            NodeList children = node.getChildNodes();</p><p class="source-code">            for (int i = 0; i &lt; children.getLength(); i++) {</p><p class="source-code">                Node child = children.item(i);</p><p class="source-code">                if (child.getNodeType() == Node.TEXT_NODE) {</p><p class="source-code">                    printText( child.getTextContent() );</p><p class="source-code">                } else {</p><p class="source-code">                    System.out.println();       // previous line</p><p class="source-code">                    traverseNode(child, indentation);</p><p class="source-code">                }</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p></li>
				<li>This method prints out the name of the input node (which will be the city, country, or something similar). It then checks for child nodes. If the child node is a <strong class="source-inline">Text</strong> node, it prints out the text. Otherwise, this method calls itself recursively to process all the children of the child node.</li>
				<li>To get going, create a short method to start the recursive calls from the first child of the XML document:<p class="source-code">public void traverseDocument(Document document) {</p><p class="source-code">    traverseNode(document.getFirstChild(), 0);</p><p class="source-code">}</p></li>
				<li>Next, we need a <strong class="source-inline">main()</strong> method to load the XML file and traverse the document:<p class="source-code">public static void main(String[] args) {</p><p class="source-code">    XmlTraverser traverser = new XmlTraverser();</p><p class="source-code">    Document document = traverser.loadXml();</p><p class="source-code">    // Traverse XML document.</p><p class="source-code">    traverser.traverseDocument(document);</p><p class="source-code">}</p></li>
				<li>When you run this program, you will see the following output:<p class="source-code">cities </p><p class="source-code">  city </p><p class="source-code">    name London</p><p class="source-code">    country United Kingdom</p><p class="source-code">    summertime-high-temp 20.4 C</p><p class="source-code">    in-year-2100 </p><p class="source-code">      with-moderate-emission-cuts </p><p class="source-code">        name Paris</p><p class="source-code">        country France</p><p class="source-code">        summertime-high-temp 22.7 C</p><p class="source-code">      with-no-emission-cuts </p><p class="source-code">        name Milan</p><p class="source-code">        country Italy</p><p class="source-code">        summertime-high-temp 25.2 C</p><p class="callout-heading">Note</p><p class="callout">The preceding output is truncated. The full source code of this exercise can be found at: <a href="https://packt.live/33VDygZ">https://packt.live/33VDygZ</a>.</p></li>
			</ol>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor301"/>Activity 1: Calculating the Fibonacci Sequence</h2>
			<p>The Fibonacci sequence is a series of numbers where each number is the sum of the previous two numbers. Write a recursive method to generate the first 15 numbers of the Fibonacci sequence. Note that the Fibonacci value for 0 is 0, and the Fibonacci value for 1 is 1.</p>
			<p>The Fibonacci sequence goes 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, and so on.</p>
			<p>So, you can use the following as a guide:</p>
			<p class="source-code">fibonacci(4) = </p>
			<p class="source-code">fibonacci(3) + fibonacci(2) =</p>
			<p class="source-code">{fibonacci(2) + fibonacci(1)} + {fibonacci(1) + fibonacci(0)} =</p>
			<p class="source-code">{fibonacci(1) + fibonacci(0) + fibonacci(1) + fibonacci(0)} + {fibonacci(1) + fibonacci(0)} =</p>
			<p class="source-code">1 + 0 + 1 + 0 + 1 + 0 = 3</p>
			<p>We'll use a recursive method to calculate the Fibonacci value for a given input, and then create a loop to display the sequence. To do so, perform the following steps:</p>
			<ol>
				<li value="1">Create the <strong class="source-inline">fibonacci</strong> method.</li>
				<li>Check if the value passed to the <strong class="source-inline">fibonacci</strong> method is 0, if yes then return 0.</li>
				<li>Also, check if the value passed to the <strong class="source-inline">fibonacci</strong> method is 1, if yes then return 1.</li>
				<li>Else, add the fibonacci values of the previous two numbers. </li>
				<li>In the main method, create a for loop that initializes from 0 to 15 and call the <strong class="source-inline">fibonaci</strong> method. </li>
			</ol>
			<p>When you run your program, you should see an output like the following:</p>
			<p class="source-code">0</p>
			<p class="source-code">1</p>
			<p class="source-code">1</p>
			<p class="source-code">2</p>
			<p class="source-code">3</p>
			<p class="source-code">5</p>
			<p class="source-code">8</p>
			<p class="source-code">13</p>
			<p class="source-code">21</p>
			<p class="source-code">34</p>
			<p class="source-code">55</p>
			<p class="source-code">89</p>
			<p class="source-code">144</p>
			<p class="source-code">233</p>
			<p class="source-code">377</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution for this activity can be found on page 562.</p>
			<h1 id="_idParaDest-293"><a id="_idTextAnchor302"/>Summary</h1>
			<p>Recursion is a handy programming technique that is used for a few complex problems. You'll commonly find recursion in mathematical formulas, as well as when traversing hierarchical data structures such as binary trees or XML documents. With recursion, a Java method or a class calls itself. But do not forget to code a terminating condition, or you'll find your application quickly runs out of memory on the Java call stack. you'll find your application quickly runs out of memory on the Java call stack. </p>
			<p>In the next chapter, you'll learn about predicates and functional programming with Java. </p>
		</div>
	</body></html>