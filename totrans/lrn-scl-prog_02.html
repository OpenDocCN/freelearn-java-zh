<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding Types in Scala</h1>
                </header>
            
            <article>
                
<p class="p1">The strong type system is one of the most important parts of the Scala language. Like a double-edged sword, it helps the compiler to verify and optimize the code on one side, while at the same time guiding developers toward possible correct implementations and preventing them from making programming mistakes on another side. As with any sharp tool, it requires some skill so that it can be used for carving beautiful source code without cutting the user in the process.</p>
<p class="p1">In this chapter, we will improve this skill by recapping and summarizing basic type-related knowledge, taking a look at a new type that was introduced in Scala 2.13, and finally looking at some advanced usages of types.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Different ways to create a type</li>
<li>Different ways to parameterize a type</li>
<li>Kinds of types</li>
<li>Using types to express domain constraints</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>Before we begin, make sure you have the following installed:</p>
<ul>
<li>JDK 1.8+</li>
<li>SBT 1.2+</li>
</ul>
<p>The source code for this chapter is available under our GitHub repository at: <a href="https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02">https://github.com/PacktPublishing/Learn-Scala-Programming/tree/master/Chapter02</a><a href="https://github.com/PacktPublishing/Learn-Scala---Fundamentals-of-Scala-2.13/ch02">.</a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding types</h1>
                </header>
            
            <article>
                
<p>The type of something is a summation of the information the compiler owns about this <em>something</em>. In the most general case, we're talking about the type of a variable; the knowledge of the compiler includes the methods that are available on this variable and the classes that the variable extends. A very convenient feature of Scala is that it tries to use type inference where possible, freeing the developer from the need to define types explicitly.</p>
<p>Let's take a structured look at Scala's type system, starting with a short recap of its basics.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Ways to create a type</h1>
                </header>
            
            <article>
                
<p>There are four ways to define a type in Scala:</p>
<ul>
<li>By using a literal to define a singleton type</li>
<li>By using the type keyword to define an alias for an <span>abstract or concrete type </span></li>
<li>By defining a class, object, or trait to create a concrete type</li>
<li>By defining a method that creates a method type</li>
</ul>
<p>Singleton types were introduced in Scala 2.13, and we'll look at them in detail later in this chapter. For now, let's try to define and refer to some concrete types in Scala REPL:</p>
<pre>scala&gt; class SomeClass<br/>defined class SomeClass<br/>scala&gt; object SomeObject<br/>defined object SomeObject<br/>scala&gt; :type SomeObject<br/>SomeObject.type<br/>scala&gt; :type new SomeClass<br/>SomeClass<br/>scala&gt; trait SomeTrait {<br/>     | def usage(a: SomeClass, b: SomeObject.type): SomeTrait<br/>     | }<br/>defined trait SomeTrait</pre>
<p>The type can be referred before it is fully defined, as shown by the example of <kbd>SomeTrait</kbd>.</p>
<p>When annotating types, traits and classes can be used directly, but the type of an object needs to be referenced by using its <kbd>type</kbd> operator. The <kbd>a.type</kbd> form in Scala describes a <em>singleton type</em>. Depending upon whether <kbd>p</kbd> conforms to <kbd>scala.AnyRef</kbd>, it denotes either a set of values, <kbd>[a, null]</kbd>, or just an <kbd>a</kbd>. As we usually don't use <kbd>null</kbd> in Scala programs, we can say that <kbd>a.type </kbd>denotes a type containing a single element, <kbd>a</kbd>. Normally, it is not used in <em>regular </em>code because it is easier to reference an object directly than to pass it as a parameter, but this style has found its use in some advanced libraries to implement parts of the internal DSL. </p>
<p><span>In Scala 2.13, there is a new marker trait <kbd>Singleton</kbd> that can be applied as an upper bound on a type parameter, which indicates that the singleton type should be inferred for this parameter:</span></p>
<pre>scala&gt; def singleIn[T &lt;: Singleton](t: T): T = t<br/>singleIn: [T &lt;: Singleton](t: T)T<br/><br/>scala&gt; final val t = singleIn(42)<br/>t: 42 = 42</pre>
<p><span>A</span> <em>method type</em> <span>does not denote a value, nor does it appear directly in the program. It is an internal representation of a method definition. It is represented as a sequence of parameter names with respective types and a return type of the method. The method type is important into know about because, if a method name is used as a value, its type is implicitly converted to the corresponding function type. As we defined in the <kbd>usage</kbd> method, the compiler internally created a method type cal</span><span>led </span><kbd>(a: SomeClass, b: SomeObject.type)SomeTrait</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Literal types</h1>
                </header>
            
            <article>
                
<p>Scala 2.13 introduced a special kind of singleton type—the <em>literal type</em>. It denotes a single value of some literal and represents the most precise type of this literal. It is available for all types for which literal syntax is available (for example, <kbd>Boolean</kbd>, <kbd>Char</kbd>, <kbd>String</kbd>, and <kbd>Symbol</kbd>). It is impossible to define a literal type for <kbd>Unit</kbd> (by specification) and for <kbd>Byte</kbd> and <kbd>Short</kbd> (because there is no syntax to define literals of such types). This is how it works in practice:</p>
<pre>scala&gt; def bool2String(b: true) = "ja"<br/>bool2String: (b: true)String<br/>scala&gt; bool2String(true)<br/>res7: String = ja<br/>scala&gt; bool2String(false)<br/> ^<br/> error: type mismatch;<br/> found : Boolean(false)<br/> required: true</pre>
<p>There are two ways to define a variable of a literal type. The first way is by using an explicit type ascription, and the second way is by making it a non-lazy <kbd>final</kbd>:</p>
<pre>scala&gt; val a1: true = true<br/>a1: true = true<br/><br/>scala&gt; bool2String(a1)<br/>res10: String = ja<br/><br/>scala&gt; final val a2 = true<br/>a2: Boolean(true) = true<br/><br/>scala&gt; bool2String(a2)<br/>res11: String = ja<br/><br/>scala&gt; // but<br/><br/>scala&gt; val a3 = true<br/>a3: Boolean = true<br/><br/>scala&gt; bool2String(a3)<br/>                   ^<br/>       error: type mismatch;<br/>        found : a3.type (with underlying type Boolean)<br/>        required: true</pre>
<p>A literal type is erased to the normal type during compilation, and so it is not possible to override methods using literal types:</p>
<pre>scala&gt; object scope {<br/> | def bool2String(b: true) = "ja"<br/> | def bool2String(b: false) = "nein"<br/> | }<br/> def bool2String(b: false) = "nein"<br/> ^<br/>On line 3: error: double definition:<br/> def bool2String(b: true): String at line 2 and<br/> def bool2String(b: false): String at line 3<br/> have same type after erasure: (b: Boolean)String</pre>
<p>In the previous snippet, the compiler prevented us from declaring two methods with the same name, and so took a parameter with a different literal type because of the erasure.</p>
<p>The singleton type forming the <kbd>.type</kbd> operator can be used to specify that a function should return a literal type and not a normal type, as demonstrated by the type of <kbd>t</kbd> inferred by the compiler—<kbd>42</kbd>:</p>
<pre>scala&gt; def singleOut[T](t: T): t.type = t<br/>singleOut: [T](t: T)t.type<br/><br/>scala&gt; final val t = singleOut(42)<br/>t: 42 = 42</pre>
<p>Since Scala 2.13, there is a type class called <span><kbd>scala.ValueOf[T]</kbd> and an operator called <kbd>scala.Predef.valueOf[T]</kbd> that can be used to yield values for singleton types. This is how <kbd>valueOf[T]</kbd> is defined:</span></p>
<pre><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valueOf</span></span><span>[</span><span class="hljs-type">T</span><span>](</span><span class="hljs-keyword">implicit</span><span> vt: </span><span class="hljs-type">ValueOf</span><span>[</span><span class="hljs-type">T</span><span>]): </span><span class="hljs-type">T</span><span> = vt.value</span></pre>
<p>And this is how it can be used:</p>
<pre>scala&gt; final val a = valueOf[42]<br/>a: 42 = 42</pre>
<p>The pattern matching against literal types also works as expected, though the syntax is unusual and probably not very useful, as demonstrated by this first case:</p>
<pre>scala&gt; def int2str(i: Int) = i match {<br/>     | case t: 42 =&gt; "forty-two"<br/>     | case ii =&gt; ii.toString<br/>     | }<br/>int2str: (i: Int)String<br/><br/>scala&gt; int2str(42)<br/>res24: String = forhty-two<br/><br/>scala&gt; int2str(43)<br/>res25: String = 43</pre>
<p>These literal types are probably not very interesting for day-to-day programming, but are very useful for type-level library development.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Compound (intersection) types</h1>
                </header>
            
            <article>
                
<p>A compound type is defined as a combination of zero or more component types with a refinement. If no refinement is provided, an implicit empty one (<kbd>{}</kbd>) is added by the compiler. Depending on the number of components, we can have the following cases:</p>
<ul>
<li>If just a refinement is given, the compound type is equivalent to extending <kbd>AnyRef</kbd></li>
<li>A single type is extended by using the corresponding <kbd>extends</kbd> keyword</li>
<li> Two or more types are combined by interleaving them with the <kbd>with</kbd> keyword</li>
</ul>
<p>In the case of a name clash in combined types and/or refinement, the usual override rules apply. This means that the rightmost type or refinement has the highest priority. This combination also represents an inheritance relation, and it is possible to access members of extended types with the use of the <kbd>super</kbd> keyword.</p>
<p>The compound type is easy to imagine as a layer of wrappers. Because of this, the process of resolving conflicting members in traits is called <strong>trait linearisation</strong>, while the decorator design pattern is called <strong>stackable traits</strong>. The following example demonstrates how layers of traits can access methods defined on subtypes of the compound type to implement a decorated <kbd>toString</kbd> representation:</p>
<pre>scala&gt; trait A { override def toString = "A" }<br/>defined trait A<br/><br/>scala&gt; trait B { override def toString = super.toString + "B" }<br/>defined trait B<br/><br/>scala&gt; trait C { override def toString = super.toString + "C" }<br/>defined trait C<br/><br/>scala&gt; class E extends A with B with C {<br/>     | override def toString: String = super.toString + "D"<br/>     | }<br/>defined class E<br/><br/>scala&gt; new E().toString<br/>res28: String = ABCD</pre>
<p><span>The definition of type contains just a refinement in </span>the case of zero components being extended. This way of defining a type is known as a <strong>structural type</strong>. The use of structural types is generally discouraged in Scala because it can lead to a generation of bytecode that will access structurally defined members using reflection, which is significantly slower. Nevertheless, it is useful to define type lambdas, which we will take a look at near the end of this chapter. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type constraints</h1>
                </header>
            
            <article>
                
<p>Type constraints are rules associated with a type. They define a subset of all types that, for example, a variable can have. A type constraint takes the form of lower bound (subtype relation) or upper bound (supertype <span>relation</span>). It is possible to define multiple constraints for a single type. In this case, a type must satisfy both of them. Constraints are defined using the symbols <kbd>&gt;:</kbd> (lower, unhappy bound) and  <kbd>&lt;:</kbd> (upper, happy bound), and the direction of the sign corresponds to the reversed direction of the arrow on the UML diagram, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/6a801360-cd32-48dc-a797-40bf79b3e084.png" style="width:33.83em;height:25.67em;" width="485" height="368"/></p>
<p>The type constraints are inclusive, which is why type <kbd>B</kbd> represents both the upper and lower bounds. Besides <kbd>B</kbd> in our type hierarchy, only <kbd>A</kbd> obeys the <kbd>LOWER</kbd> type constraint and only <kbd>C </kbd> obeys the <kbd>UPPER</kbd> constraint.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scala's types hierarchy and special types</h1>
                </header>
            
            <article>
                
<div class="page">
<div class="layoutArea">
<p>Type constraints in combination with Scala's type hierarchy give us a few interesting classes that are important to know about. To recap, the type hierarchy is represented in the following diagram:</p>
<p class="CDPAlignCenter CDPAlign"><img src="Images/7f06375d-67c7-4713-af6c-7e00f662fb2b.png" style="width:25.08em;height:25.00em;" width="434" height="432"/></p>
<p><span>In Scala, all types have a maximum upper bound of</span> <strong>Any</strong> <span>and a lower bound of</span> <strong>Nothing</strong><span>.</span></p>
<p class="column"><span><strong>Value Classes</strong> is a Scala way to avoid allocating runtime objects. This works by wrapping JVM's primitive types. Scala already represents numeric types and <kbd>Boolean</kbd> and <kbd>Char</kbd> as</span> <strong>AnyVal</strong>, <span>and it is possible to implement custom value classes by extending</span> <strong>AnyVal</strong> <span>and obeying a few restrictions. An interesting subtype of</span> <strong>AnyVal</strong> <span>is a</span> <strong>Unit</strong> <span>type, which represents a case where something unimportant needs to be returned from a function or a method. It roughly corresponds to the void return type and has a single member, <kbd>()</kbd>.</span></p>
<p><strong>AnyRef</strong> is a representation of any type that is allocated at runtime. In JVM, it is possible to have <kbd>null</kbd> in a place where an object reference is expected; the type of <kbd>null</kbd> is <kbd>Null</kbd>. The <kbd>Null</kbd> type has a single inhabitant, <kbd>null</kbd>, the same way <kbd>Unit</kbd> has a single value of <kbd>()</kbd>.</p>
<p><kbd>Nothing</kbd> is a special subtype of every other type and has no members. Because of this, it is not possible to instantiate members of that type. As a result, it is useful to indicate that the only possibility for a method or function to terminate is to do this abnormally, usually by throwing an exception.</p>
<p>There are two traits that are not represented in the preceding diagram, <kbd>Serializable</kbd> and <kbd>Product</kbd>. The former marker trait is used to tell the JVM that some class should be <span>serializable across platforms, and it just delegates to Java's interface, <kbd>java.io.Serializable</kbd>. </span></p>
<p>The <kbd>Product</kbd> stays for the Cartesian product, which is basically just an ordered set of pairs of named types. In Scala, <kbd>Product</kbd> is extended by tuples and case classes.</p>
<p>The <kbd>Self</kbd> type is another special notion in Scala that's used to define dependencies between traits without declaring an extension relation. This syntax allows you to bring in the scope of the trait members from other traits, as shown in the following code:</p>
<pre><span>trait </span>A { <span>def </span>a: <span>String </span>}<br/><span>trait </span>B { <span>def </span>b: <span>String </span>}<br/><span>trait </span>C { <span>this</span>: A =&gt; <span>// override `this`<br/></span><span>  </span><span>def </span>c = <span>this</span>.a<br/>}<br/><span>trait </span>D { self: A <span>with </span>B =&gt; <span>// any alias is allowed; mixed traits<br/></span><span>  </span><span>def </span>d = <span>this</span>.a + <span>this</span>.b<br/>}</pre></div>
</div>
<p>The last member in our zoo of special types is <kbd>Dynamic</kbd>. This is a marker trait that allows you to use the dynamic invocation of methods (also known as <strong>duck typing</strong>).</p>
<p>It feels a bit inappropriate to go into the details of <kbd>Dynamic</kbd> here because Scala's strength is exactly the opposite—to express knowledge about the system statically using proper types. For curious readers, official documentation on this is available here: <a href="https://www.scala-lang.org/api/current/scala/Dynamic.html">https://www.scala-lang.org/api/current/scala/Dynamic.html</a>. </p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type inference</h1>
                </header>
            
            <article>
                
<p>The <span><span>preceding </span></span>type hierarchy is quite important for understanding how type inference works. Type inference is a mechanism that the compiler uses to guess the type of an expression or a method if the definition of its type is omitted. The same also applies to the type parameters of polymorphic methods or generic classes and sometimes to <span>anonymous function parameter types as well. This inference aims to provide the most specific type possible while obeying all of the existing constraints. The compiler does this by walking the hierarchy tree and finding the <em>least upper bound</em>. Let's look at an example: </span></p>
<pre><span>case class </span>C(); <span>class </span>D(); <span>case class </span>E()<br/><br/><span>def </span>iOrB(i: Int, s: Boolean)(b: Boolean): AnyVal = <span>if </span>(b) i <span>else </span>s<br/><span>def </span>iOrS(i: Int, s: <span>String</span>)(b: Boolean): Any = <span>if </span>(b) i <span>else </span>s<br/><br/><span>def </span>sOrC(c: C, s: <span>String</span>)(b: Boolean): java.io.Serializable = <span>if </span>(b) c <span>else </span>s<br/><span>def </span>cOrD(c: C, d: D)(b: Boolean): AnyRef = <span>if </span>(b) c <span>else </span>d<br/><span>def </span>cOrE(c: C, e: E)(b: Boolean): Product <span>with </span>Serializable = <span>if </span>(b) c <span>else </span>e</pre>
<p>Here, we specified the return types as the compiler infers them. For the first two cases, you can easily follow the hierarchy of Scala types to understand how the compiler did the inference. The last three are a bit more complicated:</p>
<ul>
<li>In <kbd>sOrC</kbd>, the inferred type is <kbd>java.io.Serializable</kbd>. The reason for this is that Scala's <kbd>String</kbd> is just an alias for <kbd>java.lang.String</kbd>, which extends <kbd>java.io.Serializable</kbd>. All case classes in Scala extend <kbd>Product with Serializable</kbd> by default and <kbd>Serializable</kbd> extends <span><kbd>java.io.Serializable</kbd>. Therefore, <kbd>java.io.Serializable</kbd> is the least upper bound in this case.</span></li>
<li>In <kbd>cOrD</kbd>, <kbd>D</kbd> is not a case class, and therefore it does not extend anything but the <kbd>AnyRef</kbd>, which becomes an inferred type.</li>
<li>In <kbd>cOrE</kbd>, both <kbd>C</kbd> and <kbd>E</kbd> are case classes, and so the compiler can infer the most specific type, that is, <kbd>Product with Serializable</kbd>.</li>
</ul>
<p>In fact, the preciseness of the compiler can go quite far, as the following example demonstrates:</p>
<pre><span>trait </span>Foo { <span>def </span>foo: Int }<br/><span>case class </span>F() <span>extends </span>Foo {<span>def </span>foo: Int = <span>0</span>}<br/><span>case class </span>G() <span>extends </span>Foo {<span>def </span>foo: Int = <span>0</span>}<br/><br/><span>def </span>fOrG(f: F, g: G)(b: Boolean): <br/>  Product with Serializable with Foo = <span>if </span>(b) f <span>else </span>g</pre>
<p>Here, we can see that the inferred type of <kbd>fOrG</kbd> is a compound type with three members.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Path-dependent types</h1>
                </header>
            
            <article>
                
<p>Until now, we have avoided talking about paths, mostly because they are not types themselves. However, they can be a part of named types, and thus have an important role in Scala's type system.</p>
<p>A path can have one of the following forms:</p>
<ul>
<li>An empty path, <span>denoted with </span><kbd>ε</kbd>. It cannot be written directly, but implicitly precedes any other path.</li>
<li><kbd>C.this</kbd>, where <kbd>C</kbd> is a reference class. This is the path that is constructed if <kbd>this</kbd> is used inside of a class.</li>
<li><kbd><span>C.super.x</span><span>.</span></kbd><span> or <kbd>C.super[P].</kbd></span><span> refers to the member <kbd>x</kbd> of the superclass or designated parent class, <kbd>P</kbd> of <kbd>C</kbd>. It plays the same role as <kbd>this</kbd> for the class, but refers to the classes that are upper in the hierarchy.</span></li>
<li><kbd>p.x</kbd>, where <kbd>p</kbd> is a path and <kbd>x</kbd> is a stable member of <kbd>p</kbd>. The stable member is an object definition or a value definition for which it is possible for the compiler to tell that it will always be accessible (as opposed to the volatile type where it is not possible, for example, there is an abstract type definition that can be overridden by a subclass).</li>
</ul>
<p>Types within the path can be referred to by two operators, <kbd>#</kbd> (hash) and <kbd>.</kbd> (dot). The former is known as <strong>type projection</strong>, and <kbd>T#m</kbd> refers to the type member <kbd>m</kbd> of the type <kbd>T</kbd>. We can demonstrate the difference between these operators by building a type-safe lock:</p>
<pre><span>case class </span>Lock() {<br/>  <span>final case class </span>Key()<br/>  <span>def </span>open(key: Key): Lock = <span>this<br/></span><span>  def </span>close(key: Key): Lock = <span>this<br/></span><span>  def </span>openWithMaster(key: Lock#Key): Lock = <span>this<br/></span><span>  def </span>makeKey: Key = <span>new </span>Key<br/>  <span>def </span>makeMasterKey: Lock#Key = <span>new </span>Key<br/>}</pre>
<p>Here, we defined a type, <kbd>Lock</kbd>, with a nested type, <kbd>Key</kbd>. The key can be referenced using its path, <kbd>Lock.Key</kbd>, or by using a projection, <kbd>Lock#Key</kbd>. The former denotes a type tied to a specific instance, and the latter denotes a type that is not. The specific types of key are returned by two different constructor methods. The <kbd>makeKey</kbd> return type is a <kbd>Key</kbd> that is a shortcut for <kbd>this.Key</kbd>, which in turn is an alias for <kbd>Lock.this.type#Key</kbd> and represents a <em>path-dependent type</em>. The latter is just a type projection, <kbd>Lock#Key</kbd>. Because the path-dependent type refers to the concrete instance, the compiler will only allow the use of the appropriate type to call the <kbd>open</kbd> and <kbd>close</kbd> methods:</p>
<pre><span>val </span><span>blue</span>: Lock = <span>Lock</span>()<br/><span>val </span><span>red</span>: Lock = <span>Lock</span>()<br/><span>val </span><span>blueKey</span>: <span>blue</span>.Key = <span>blue</span>.makeKey<br/><span>val </span><span>anotherBlueKey</span>: <span>blue</span>.Key = <span>blue</span>.makeKey<br/><span>val </span><span>redKey</span>: <span>red</span>.Key = <span>red</span>.makeKey<br/><br/><span>blue</span>.open(<span>blueKey</span>)<br/><span>blue</span>.open(<span>anotherBlueKey</span>)<br/><span>blue</span>.open(redKey) <span>// compile error<br/></span><span>red</span>.open(blueKey) <span>// compile error<br/></span></pre>
<p>The <kbd>masterKey</kbd> is not path-dependent, and so can be used to call methods on any instance in a typical way:</p>
<pre><span>val </span><span>masterKey</span>: Lock#Key = <span>red</span>.makeMasterKey<br/><br/><span>blue</span>.openWithMaster(<span>masterKey</span>)<br/><span>red</span>.openWithMaster(<span>masterKey</span>)</pre>
<p>These path-dependent types conclude our journey regarding concrete types and can be used to describe values. All of the types we've seen so far (except method types) are named <em>value types</em> to reflect this fact. A named value type is called a <strong>type designator</strong>. All type designators are shorthand for type projections. </p>
<p><span>We will now switch gears and inspect how types can be used to narrate definitions of other types.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Types – all the way down</h1>
                </header>
            
            <article>
                
<p>Up until now, we have only talked about concrete types. Despite being quite simple, they already allow for the expression of a lot of properties of a program on the type level and they have these properties verified at compile time. <span>Scala gives the developer even more freedom by allowing them to use types as parameters while defining methods, classes, or other types. In the next section, we will look at different ways to do this, starting with basic type parameters and type member definition, and continuing with type constraints and variance topics. We'll conclude our discussion with higher kinded types and type lambdas.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type parameters</h1>
                </header>
            
            <article>
                
<p>Type parameters are defined using square brackets <kbd>[]</kbd>. If applied to classes and methods, they must be declared before normal parameters, and the result is known as a <strong>parameterized type</strong>:</p>
<pre><span>case class </span>Wrapper[<span>A</span>](content: <span>A</span>) {<br/>  <span>def </span>unwrap: <span>A </span>= content<br/>}<br/><span>def </span>createWrapper[<span>A</span>](a: <span>A</span>):Wrapper[<span>A</span>] = <span>Wrapper</span>(a)<br/><span>type </span><span>ConcreteWrapper</span>[<span>A</span>] = Wrapper[<span>A</span>]<br/><br/><span>val </span><span>wInt</span>: Wrapper[Int] = <span>createWrapper</span>[Int](<span>10</span>)<br/><span>val </span><span>wLong</span>: <span>ConcreteWrapper</span>[Long] = <span>createWrapper</span>(<span>10L</span>)<br/><span>val </span><span>int</span>: Int = <span>wInt</span>.unwrap<br/><span>val </span><span>long</span>: Long = <span>wLong</span>.unwrap</pre>
<p>The <kbd>Wrapper</kbd> class is parameterized by the <kbd>A</kbd> type. This type parameter is used to refer to the type of content in the <kbd>unwrap</kbd> method. The scope resolution rules apply to the type parameters the same way as they do to the normal parameters, as shown by the <kbd>unwrap</kbd> method definition.</p>
<p>The <kbd>createWrapper</kbd> method definition shows how the type parameter propagates to the implementation side—<kbd>Wrapper(a)</kbd> is parameterized with the <kbd>A</kbd> type by the compiler. </p>
<p>The <kbd>ConcreteWrapper</kbd> type definition shows that type aliases are parameterized in the same way that types are. </p>
<p>We then use our parameterized type to demonstrate that it is possible to provide explicit type parameters on the call side, as well as rely on type inference.</p>
<p>This type inference is in fact quite powerful. The compiler always tries to find the most specific type, as the following example reveals (I've provided the explicit type ascriptions, which reflect the types inferred by the compiler):</p>
<pre><span>case class </span>Abc[<span>A</span>](a: <span>A</span>, b: <span>A</span>, c: <span>A</span>)<br/><span>val </span><span>intA</span>: Abc[Int] = <span>Abc</span>(<span>10</span>, <span>20</span>, <span>30</span>)<br/><span>val </span><span>longA</span>: Abc[Long] = <span>Abc</span>(<span>10L</span>, <span>20L</span>, <span>30L</span>)<br/><span>val </span><span>whatA</span>: Abc[AnyVal] = <span>Abc</span>(<span>10</span>, <span>20</span>, <span>true</span>)<br/><span>val </span><span>whatB</span>: Abc[io.Serializable] = <span>Abc</span>(<span>"10"</span>, <span>"20"</span>, <span>Wrapper</span>(<span>10</span>))<br/><span>val </span><span>whatC</span>: Abc[Any] = <span>Abc</span>(<span>10</span>, <span>"20"</span>, <span>Wrapper</span>(<span>10</span>))</pre>
<p>We discussed Scala's type hierarchy earlier, so it should be obvious how the compiler came up with the types shown in the preceding code snippet.</p>
<p>It is possible to restrict possible definitions of the type parameter by using type constraints, as shown in the following example:</p>
<pre><span>trait </span>Constraints[<span>A </span>&lt;: AnyVal, <span>B </span>&gt;: Null &lt;: AnyRef] {<br/>  <span>def </span>a: <span>A<br/></span><span>  </span><span>def </span>b: <span>B<br/></span>}<br/><br/><span>// compile error - type parameter bounds<br/></span><span>// case class AB(a: String, b: Int) extends Constraints[String, Int]<br/></span><span><br/></span><span>case class </span>AB(a: Int, b: <span>String</span>) <span>extends </span>Constraints[Int, <span>String</span>]</pre>
<p>The compiler will check that the concrete definition conforms to the type parameter bounds.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type members</h1>
                </header>
            
            <article>
                
<p>A <em>type member</em> is similar to the type parameter, but it is defined as a type alias that's a member of an abstract class or trait. It can then be made concrete at the moment the abstract definition itself is made concrete. Let's look at the following few lines of code, which will show you how this works:</p>
<pre><span>trait </span>HolderA {<br/>  <span>type </span><span>A<br/></span><span>  </span><span>def </span>a: <span>A<br/></span>}<br/><span>class </span>A <span>extends </span>HolderA {<br/>  <span>override type </span><span>A </span>= Int<br/>  <span>override def </span>a = <span>10<br/></span>}</pre>
<p>Here, we defined an abstract type member, <kbd>A</kbd>, and overrode it in the concrete implementation by binding it to the <kbd>Int</kbd>.</p>
<p>It is possible to define multiple type members, of course, and define constraints on them, including type members themselves as part of the constraint:</p>
<pre><span>trait </span>HolderBC {<br/>  <span>type </span><span>B<br/></span><span>  </span><span>type </span><span>C </span>&lt;: <span>B<br/></span><span>  </span><span>def </span>b: <span>B<br/></span><span>  </span><span>def </span>c: <span>C<br/></span>}</pre>
<p>Type inference is not applied in this case, so the following code will not compile because the type definition is missing:</p>
<pre><span>class BC extends HolderBC {<br/></span><span>  override def b = "String"<br/></span><span>  override def c = true<br/></span><span>}<br/></span></pre>
<p>These type members can be defined using all language features that can be applied to other type definitions, including multiple type constraints and path-dependent types. In the following example, we demonstrate this by declaring type members in the <kbd>HolderDEF</kbd> and providing the concrete definition in the class <kbd>DEF</kbd>. Incompatible type definitions are noted as such and commented out:</p>
<pre><span>trait </span>HolderDEF {<br/>  <span>type </span><span>D </span>&gt;: Null &lt;: AnyRef<br/>  <span>type </span><span>E </span>&lt;: AnyVal<br/>  <span>type </span><span>F </span>= <span>this</span>.<span>type<br/></span><span>  def </span>d: <span>D<br/></span><span>  </span><span>def </span>e: <span>E<br/></span><span>  </span><span>def </span>f: <span>F<br/></span>}<br/><br/><span>class </span>DEF <span>extends </span>HolderDEF {<br/>  <span>override type </span><span>D </span>= <span>String<br/></span><span>  </span><span>override type </span><span>E </span>= Boolean<br/><br/>  <span>// incompatible type String<br/></span><span>  // override type E = String<br/></span><span>  // override def e = true<br/></span><span><br/></span><span>  </span><span>override def </span>d = <span>""<br/></span><span>  </span><span>override def </span>e = <span>true<br/></span><span><br/>  </span><span>// incompatible type DEF<br/></span><span>  // override def f: DEF = this<br/></span><span><br/>  </span><span>override def </span>f: <span>this</span>.<span>type </span>= <span>this<br/></span>}</pre>
<p>It is also possible to combine type members and type parameters and use them later to further constrain possible definitions of the former:</p>
<pre><span>abstract class </span>HolderGH[<span>G</span>,<span>H</span>] {<br/>  <span>type </span><span>I </span>&lt;: <span>G<br/></span><span>  </span><span>type </span><span>J </span>&gt;: <span>H<br/></span><span>  </span><span>def </span>apply(j: <span>J</span>): <span>I<br/></span>}<br/><span>class </span>GH <span>extends </span>HolderGH[<span>String</span>, Null] {<br/>  <span>override type </span><span>I </span>= Nothing<br/>  <span>override type </span><span>J </span>= <span>String<br/></span><span>  </span><span>override def </span>apply(j: <span>J</span>): <span>I </span>= <span>throw new </span>Exception<br/>}</pre>
<p>Type members and type parameters look very similar in their function—<span>this is done </span>to define abstract type definitions that can be refined later. Given this similarity, a developer can use one or another most of the time. Still, there are a couple of nuances regarding the situations in which you should prefer to use them.</p>
<p>These type parameters are usually more straightforward and easier to get right, so generally, they should be preferred. Type members are the way to go if you run into one of the following cases:</p>
<ul>
<li>If the concrete type definition should remain hidden</li>
<li>If the intended way to provide the concrete definition of the type is via inheritance (overridden in subclasses or mixed-in via traits)</li>
</ul>
<p>There is another simple rule that's easy to memorize—type parameters are used to define the types of parameters of the method and type members to define the result type of this method:</p>
<pre><span>trait </span>Rule[<span>In</span>] {<br/>  <span>type </span><span>Out<br/></span><span>  </span><span>def </span>method(in: <span>In</span>): <span>Out<br/></span>}</pre>
<p>There is also another way to specify boundaries for type parameters and type members in Scala.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generalized type constraints</h1>
                </header>
            
            <article>
                
<p>In the previous two sections, we used type constraints provided by the language to precisely define type members and type parameters. There are also supplementary <em>generalized type constraints</em> defined in the standard library that allow you to define relations between types using type classes. We will look at type classes and implicits in detail in <a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml" target="_blank"/><a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml">Chapter 4</a>, <em>Getting</em> <em>to Know Implicits and Type Classes</em>, but we will give a brief introduction to generalized type constraints here.</p>
<p>The <span><kbd>&lt;:&lt;</kbd> constraint expresses the requirement that the left-side type is a subtype of the right-side type. Basically, having an </span>instance of  <kbd>A &lt;:&lt; B</kbd> is the same as having a definition of <kbd>A &lt;: B</kbd>. But why is it needed, then? Because sometimes the language is not expressive enough. Let's look at an example:</p>
<pre><span>abstract class </span>Wrapper[<span>A</span>] {<br/>  <span>val </span>a: <span>A<br/></span><span>  </span><span>// A in flatten shadows A in the Wrapper<br/></span><span>  // def flatten[B, A &lt;: Wrapper[B]]: Wrapper[B] = a<br/></span><span>  </span><span>def </span>flatten(<span>implicit </span>ev: <span>A </span>&lt;:&lt; Wrapper[B]): Wrapper[B] = a<br/>}</pre>
<p>It is not possible to express the <kbd>A &lt;: Wrapper[B]</kbd> type constraint because the <kbd>A</kbd> in this definition will shadow the <kbd>A</kbd> type constraint in the definition of <kbd>Wrapper[A]</kbd>. The implicit, <kbd>ev</kbd>, solves this problem easily. <kbd>ev</kbd> will be available in scope if the compiler can prove that the subtype relation holds.</p>
<p>Another generalized type constraint available in the Scala standard library is <kbd>=:=</kbd>. So, <kbd>A =:= B</kbd> allows you to require that <kbd>A</kbd> and <kbd>B</kbd> are equal, the same way that <kbd>A &lt;:&lt; B</kbd> allows you to express subtyping relation. Due to restrictions on subclassing, it also witnesses that <span><kbd>A &lt;:&lt; B</kbd>, but not that <kbd>B &lt;:&lt; A</kbd>. We will take a look in detail how this equality relation can be used to express domain constraints at the end of this chapter.</span></p>
<p>The strange syntax of <kbd>A &lt;:&lt; B</kbd> and <kbd>A =:= B</kbd> brings us to the next section, <em>Infix types</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Infix types</h1>
                </header>
            
            <article>
                
<p>In the same way that Scala has infix operators, it has infix types. An infix type, such as <kbd>A <span>Op </span>B</kbd>, is just any type that has exactly two type operands. It is equivalent to the type defined as <kbd>Op[A, B]</kbd>. <kbd>Op</kbd> may be any valid identifier.</p>
<p>The type operators have the same associativity as term operators—they are left associative unless an operator ends in <kbd>:</kbd> (<span>colon), </span>in which case it is right associative. Consecutive infix operators must have the same associativity. Let's look at an example to understand what this means:</p>
<pre><span>type </span><span>Or</span>[<span>A</span>, <span>B</span>]<br/><span>type </span><span>And</span>[<span>A</span>, <span>B</span>]<br/><span>type </span><span>+=</span>[<span>A</span>, <span>B</span>] = <span>Or</span>[<span>A</span>, <span>B</span>]<br/><span>type </span><span>=:</span>[<span>A</span>, <span>B</span>] = <span>And</span>[<span>A</span>, <span>B</span>]<br/><br/><span>type CC = Or[And[A, B], C]<br/></span>type DA = A =: B =: C<br/>type DB = A And B And C<br/><br/><span>// type E = A += B =: C // wrong associativity<br/></span><span>type </span><span>F </span>= (A <span>+= </span>B) <span>=: C</span></pre>
<p>Here, we defined four types, all of which have two type parameters and so can be used as infix types. Then, we define a type called <kbd>CC</kbd>, which expresses some relation between the <kbd>A</kbd>, <kbd>B</kbd>, and <kbd>C</kbd> types. The <kbd>DA</kbd> and <kbd>DB</kbd> type definitions show what the type definition looks like in infix notation. The first attempt to define some type, <kbd>E</kbd>, to be the same as the <kbd>C</kbd> type fails because of the different associativity of the types, <kbd>=+</kbd> and <kbd>=:</kbd>, and we have demonstrated how parentheses can be used to work around this rule.</p>
<p>If used properly, infix types can greatly improve the readability of the code:</p>
<pre><span>type </span><span>|</span>[<span>A</span>, <span>B</span>] = <span>Or</span>[<span>A</span>, <span>B</span>]<br/><span>type  </span>[<span>A</span>, <span>B</span>] = <span>And</span>[<span>A</span>, <span>B</span>]<br/><span>type </span><span>G </span>= A  <span> </span>B <span>| C<br/></span></pre>
<p>Here, we can see how infix types allow you to define type relation in a way that looks similar to Boolean operations.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Variance</h1>
                </header>
            
            <article>
                
<p><em>Variance</em> is another aspect related to parameterized types. To understand why it is needed and how it works, let's have a drink. First, we will define a glass that can be (half) full or empty:</p>
<pre><span>sealed trait </span>Glass[<span>Contents</span>]<br/><span>case class </span>Full[<span>Contents</span>](contents: <span>Contents</span>) <span>extends </span>Glass[<span>Contents</span>]<br/><span>case object </span>Empty <span>extends </span>Glass[Nothing]</pre>
<p>There can only be one empty glass filled with <kbd>Nothing</kbd>, and we model this case with a case object. A full glass can be filled with different contents. <kbd>Nothing</kbd> is a subclass of any class in Scala, so in our case it should be able to substitute any contents. We will now create the contents and we would like to be able to drink it. The implementation is not important in this case:</p>
<pre><span>case class </span>Water(purity: Int)<br/><span>def </span>drink(glass: Glass[Water]): Unit = <span>???<br/></span></pre>
<p>We now are able to drink from the full glass and are unable to do so from an empty one:</p>
<pre><span>drink</span>(<span>Full</span>(<span>Water</span>(<span>100</span>)))<br/><span>drink</span>(Empty) // compile error, wrong type of contents</pre>
<p>But what if instead of drinking, we'd like to define <kbd>drinkAndRefill</kbd>, which should refill an empty glass?</p>
<pre><span>def </span>drinkAndRefill(glass: Glass[Water]): Unit = <span>???<br/></span><span>drinkAndRefill</span>(Empty) // same compile error</pre>
<p>We would like our implementation to accept not only <kbd>Glass[Water]</kbd>, but also <kbd>Glass[Nothing]</kbd>, or more generally any <kbd>Glass[B]</kbd> if <kbd>B &lt;: Water</kbd>. We can change our implementation accordingly:</p>
<pre><span>def </span>drinkAndRefill[<span>B </span>&lt;: Water](glass: Glass[<span>B</span>]): Unit = <span>???</span></pre>
<p class="mce-root">But what if we would like our <kbd>Glass</kbd> to work like this with any method, not only <kbd>drinkAndRefill</kbd>? Then we need to define how the relation between parameterizing types should affect the way the parameterized type works. This is done with variance. Our definition, <kbd>sealed trait Glass[Contents]</kbd>, is called <strong>invariant</strong>, and it means that the relation in the type that parameterizes <kbd>Glass</kbd> does not affect how glasses with different contents are related—they are not related at all. The <em>covariance</em> means that, in regards to the compiler, if type parameters are in a subclass relation, then the main types should be too. It is expressed with a <kbd>+</kbd> (plus) before the type constraint. Therefore, our definition of the glass becomes the following:</p>
<pre><span>sealed trait </span>Glass[<span>+Contents</span>]</pre>
<p>And the rest of the code remains unchanged. Now, if we have contents that are related, we can drink them without facing the same problems we had before:</p>
<pre><span>drink</span>(Empty) // compiles fine</pre>
<p>A typical use of covariance is with different kinds of immutable containers, where it is safe to have a more specific element in the container, like the one that is declared by the type.</p>
<p>It is not safe to do so with mutable containers, though. The compiler will not allow us to do this, but if it would, we might end up passing a container, <kbd>C</kbd>, with some subclass, <kbd>B</kbd>, to the method, expecting a container with superclass <kbd>A</kbd>. This method would then be able to replace the contents of <kbd>C</kbd> with <kbd>A</kbd> (as it is not even supposed to know about the existence of <kbd>B</kbd>), hence making future uses of <kbd>C[B]</kbd> impossible.</p>
<p>Now, let's imagine that our glass is supposed to interact with a drinker. We'll create a <kbd>Drinker</kbd> class for this, and the drinker is supposed to be able to drink the contents of <kbd>Glass</kbd>:</p>
<pre><span>class Drinker[T] { def drink(contents: T): Unit = ??? }<br/><br/>sealed trait </span>Glass[<span>Contents</span>] {<br/>  def contents: Contents<br/>  def knockBack(drinker: Drinker[Contents]): Unit = drinker.drink(contents)<br/>}<br/><span>case class </span>Full[<span>C</span>](contents: <span>C</span>) <span>extends </span>Glass[<span>C</span>]</pre>
<p>Now, let's inspect what happens if we have two different kinds of <kbd>Water</kbd>:</p>
<pre><span>class </span>Water(purity: Int)<br/><span>class </span>PureWater(purity: Int) <span>extends </span>Water(purity) {<br/>  def shine: Unit = ???<br/>}<br/><br/><span>val </span><span>glass </span>= <span>Full</span>(<span>new </span>PureWater(<span>100</span>))<br/><span>glass</span>.knockBack(<span>new </span>Drinker[PureWater])</pre>
<p><kbd>PureWater</kbd> is <kbd>Water</kbd> with some additional properties. We can create a glass full of it and let it fill a drinker. Obviously, if somebody can drink just water, they should be able to drink pure water as well:</p>
<pre><span>glass</span>.knockBack(<span>new </span>Drinker[Water]) // compile error</pre>
<p>To fix this, we need to use <em>contravariance</em>, which is denoted by the <kbd>-</kbd> (minus sign) before the type parameter. We fix our <kbd>Drinker</kbd> like so, and our example starts to compile:</p>
<pre><span>class </span>Drinker[<span>-T</span>] { <span>def </span>drink(contents: <span>T</span>): Unit = <span>??? </span>}<br/>glass.knockBack(new Drinker[Water]) // compiles</pre>
<p>It is important to notice that <span>co- and contravariance do not define the type itself, but only the type parameters. </span>This is very important for functional programming in Scala because it allows defining functions as first-class citizens. We will look at function definition in more detail in the next chapter, but to give you some indication, here is what it is about.</p>
<p>If we want to pass over to the caller a function, that is, <kbd>f(water: Water): Water</kbd>, what kind of substitute would be safe to pass instead? It would not be safe to pass a function that accepts <kbd>PureWater</kbd> because the caller won't be able to call it with such an argument. But it will be safe for the function to accept <kbd>Water</kbd> and any superclass of it that describes contravariance. For the result, it would be unacceptable for our replacement function to return anything higher in the hierarchy than <kbd>f</kbd> because the caller expects the result to be at least as specific as <kbd>f</kbd>. It would be no problem if our substitute was more specific, though. Therefore, we end up with covariance. Hence, we can define <kbd>f</kbd> as <kbd>f[-Parameter,+Result]</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Existential types</h1>
                </header>
            
            <article>
                
<p>Existential types come into play if we stop caring about the specifics of type parameters. Taking our previous example, if we have a method that expects a glass of something, but inside the method, we do not actually care what this something is, then we get the following:</p>
<pre>def drink[T &lt;: Water](g: Glass[T]): Unit = { g.contents; () }</pre>
<p class="mce-root">In this definition, we actually don't need to know what <kbd>T</kbd> is, we just want to make sure that it is some kind of <kbd>Water</kbd>. Scala allows you to have an underscore as a placeholder, in the same way it can be utilized to denote unused variables:</p>
<pre><span>def </span>drink[_ &lt;: Water](g: Glass[_]): Unit = { g.contents; () }</pre>
<p class="mce-root">This is a placeholder syntax for <em>existential type</em>s. As we saw previously, if the upper bound is omitted, <span><kbd>scala.Any</kbd> is assumed. In the case that the lower bound hasn't been defined, the compiler will implicitly add <kbd>scala.Nothing</kbd>.</span></p>
<p>This syntax is just a shorter version of the more powerful syntax <kbd>T forSome { Q }</kbd>, where <kbd>Q</kbd> is a sequence of type declarations, for example:</p>
<pre><span>import </span>scala.language.<span>existentials<br/></span>val glass = Full[T forSome { type T &lt;: Water }](new Water(100))</pre>
<p>Existential types are considered to be an advanced language feature and so need a respective import to be in scope or to be enabled as a compiler option.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Higher kinded types</h1>
                </header>
            
            <article>
                
<p class="mce-root">Our example of the glass has become a bit boring. To make it fascinating again, we'll add another abstraction, a jar. This is how our model will look after that:</p>
<pre>sealed trait Contents<br/>case class Water(purity: Int) extends Contents<br/>case class Whiskey(label: String) extends Contents<br/>sealed trait Container[C &lt;: Contents] { def contents: C }<br/>case class Glass[C&lt;: Contents](contents: C) extends Container[C]<br/>case class Jar[C &lt;: Contents](contents: C) extends Container[C]<br/><br/></pre>
<p>The glass and the jar can both be filled with any contents. For instance, this is how it can be done:</p>
<pre>def fillGlass[C &lt;: Contents](c: C): Glass[C] = Glass(c)<br/>def fillJar[C &lt;: Contents](c: C): Jar[C] = Jar(c)</pre>
<p>As we can see, both methods look identical with respect to the type used to construct the result. The parameterized type that is used to construct types is called a <strong>type constructor</strong>. As a consistent language, Scala allows you to abstract over type constructors in the same way it allows you to abstract over functions via higher order functions (more about this in the next chapter). This abstraction over type constructors is called <strong>higher kinded types</strong>. The syntax requires us to use an underscore to denote the expected type parameter on the definition side. The implementation should then use the type constructor without type constraints.</p>
<p>We can use a type constructor to provide a generic filling functionality. Of course, we can't get rid of the specific knowledge about how to fill our containers, but we can move it to the type level:</p>
<pre><span>sealed trait </span>Filler[<span>CC</span>[_]] {<br/>  <span>def </span>fill[<span>C</span>](c: <span>C</span>): <span>CC</span>[<span>C</span>]<br/>}<br/><span>object </span>GlassFiller <span>extends </span>Filler[Glass] {<br/>  <span>override def </span>fill[<span>C</span>](c: <span>C</span>): Glass[<span>C</span>] = <span>Glass</span>(c)<br/>}<br/><span>object </span>JarFiller <span>extends </span>Filler[Jar] {<br/>  <span>override def </span>fill[<span>C</span>](c: <span>C</span>): Jar[<span>C</span>] = <span>Jar</span>(c)<br/>}</pre>
<p>In the preceding code, we're using the type constructor <kbd>CC[_]</kbd> to denote both <kbd>Glass</kbd> and <kbd>Jar</kbd> in the <kbd>Filler</kbd> trait. We can now use created abstractions to define a generic filling functionality:</p>
<pre><span>def </span>fill[<span>C</span>, <span>G</span>[_]](c: <span>C</span>)(F: Filler[<span>G</span>]): <span>G</span>[<span>C</span>] = F.fill(c)</pre>
<p>The <kbd>G[_]</kbd> <span>type </span>is a type constructor for glass and jar, and <kbd>Filler[G]</kbd> is a higher order type that uses this type constructor to build a full <kbd>G[C]</kbd> for any content, <kbd>C</kbd>. This is how the generic fill method can be used in practice:</p>
<pre><span>val </span><span>fullGlass</span>: Glass[Int] = <span>fill</span>(<span>100</span>)(GlassFiller)<br/><span>val </span><span>fullJar</span>: Jar[Int] = <span>fill</span>(<span>200</span>)(JarFiller)</pre>
<p>This might not look like a huge win over the specific methods for now because we've provided our type constructors explicitly. The real advantage will become obvious the moment we start talking about implicits in <a href="20767c8e-f580-4760-9e64-371c8fc523c6.xhtml" target="_blank">Chapter 4</a>, <em>Getting to know Implicits and Type Classes</em>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Type lambdas</h1>
                </header>
            
            <article>
                
<p>As a next step, let's imagine that we have a generic <kbd>Filler</kbd> that is capable of filling different containers with different kinds of contents, as shown in the following code snippet:</p>
<pre><span>sealed trait </span>Contents<br/><span>case class </span>Water(purity: Int) <span>extends </span>Contents<br/><span>case class </span>Whiskey(label: <span>String</span>) <span>extends </span>Contents<br/><br/><span>sealed trait </span>Container[<span>C</span>] { <span>def </span>contents: <span>C </span>}<br/><span>case class </span>Glass[<span>C</span>](contents: <span>C</span>) <span>extends </span>Container[<span>C</span>]<br/><span>case class </span>Jar[<span>C</span>](contents: <span>C</span>) <span>extends </span>Container[<span>C</span>]<br/><br/><span>sealed trait </span>Filler[<span>C </span>&lt;: Contents, <span>CC </span>&lt;: Container[<span>C</span>]] {<br/>  <span>def </span>fill(c: <span>C</span>): <span>CC<br/></span>}</pre>
<p>What could we do if we had a requirement to provide a method that should only accept one type of container or content? We would need to fix the second type parameter in a similar fashion to how we would partially apply a function if given one of the arguments. A type alias can be used to do this on the type level:</p>
<pre><span>type </span><span>WaterFiller</span>[<span>CC </span>&lt;: Container[Water]] = Filler[Water, <span>CC</span>]<br/><br/><span>def </span>fillWithWater[<span>CC </span>&lt;: Container[Water]](container: <span>CC</span>)(filler: <span>WaterFiller</span>[<span>CC</span>]) = <span>???<br/></span></pre>
<p>But it feels a bit verbose to define a type alias just to be used once in the definition of the function parameter. <strong>Type lambda</strong> is a syntax that allows us to do such partial type application in-place:</p>
<pre><span>def </span>fillWithWater[<span>CC </span>&lt;: Container[Water], <span>F</span>: ({ <span>type </span><span>T</span>[<span>C</span>] = Filler[Water, <span>C</span>] })#<span>T</span>[<span>CC</span>]](container: <span>CC</span>)(filler: <span>F</span>) = <span>???</span></pre>
<p>The type lambda can also be used to define a parameter type directly:</p>
<pre><span>def </span>fillWithWater[<span>CC </span>&lt;: Container[Water]](container: <span>CC</span>)(filler: ({ <span>type </span><span>T</span>[<span>C</span>] = Filler[Water, <span>C</span>] })#<span>T</span>) = <span>???</span></pre>
<p>The internal definition of <kbd>T[C]</kbd> is analogous to the type alias we defined previously. The added part is the type projection, <kbd>()#T[C]</kbd>, that allows us to reference the type we've just defined.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using types to define domain constraints</h1>
                </header>
            
            <article>
                
<p>We've already seen how simple types can be used to express domain constraints, as discussed in the <em>Path-dependent types</em> section. We implemented a lock that guaranteed at compile time that it is only possible to open and close it with the key created for this specific lock. We will conclude our study of type parameters and higher kinded types with two examples.</p>
<p>The first example will demonstrate an application of phantom types to create another version of the lock, which can guarantee the safety of state transitions at compile time without the use of inheritance.</p>
<p>The second example will show how self-recursive types can help to constrain possible subtyping.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Phantom types</h1>
                </header>
            
            <article>
                
<p>The <em>phantom type</em> in Scala is a type that is never instantiated at runtime. Because of this, it is only useful at compile time to express domain constraints similar to (generalized) type constraints. To get a feeling for how this works, let's imagine the following situation—we have an abstraction of <kbd>Lock</kbd>, that has already been implemented in different ways via the use of inheritance:</p>
<pre><span>sealed trait </span>Lock<br/><span>class </span>PadLock <span>extends </span>Lock<br/><span>class </span>CombinationLock <span>extends </span>Lock</pre>
<p>We would like to encode in the type system that only the following state transitions are allowed for any locks:</p>
<ul>
<li>open -&gt; closed</li>
<li>closed -&gt; open</li>
<li>closed -&gt; broken</li>
<li>open -&gt; broken</li>
</ul>
<p>As we already have an existing hierarchy, we cannot easily model these state transitions with inheritance by extending <kbd>Lock</kbd> with <kbd>ClosedLock</kbd>, <kbd>OpenLock</kbd>, and <kbd>BrokenLock</kbd>. Instead, we will use the phantom types <kbd>Open</kbd>, <kbd>Closed</kbd>, and <kbd>Broken</kbd> to model the states (we will define <kbd>Lock</kbd> from scratch later, just to avoid cluttering the example with unnecessary details):</p>
<pre>sealed trait LockState<br/>sealed trait Open extends LockState<br/>sealed trait Closed extends LockState<br/>sealed trait Broken extends LockState</pre>
<p>Now, we can assign this <kbd>State</kbd> to a <kbd>Lock</kbd>:</p>
<pre><span>case class </span>Lock[<span>State </span>&lt;: LockState]()</pre>
<p>And define our state transitioning methods using type constraints:</p>
<pre><span>def break: Lock[Broken] = Lock()<br/>def </span>open[_ &gt;: <span>State </span>&lt;: Closed](): Lock[Open] = <span>Lock</span>()<br/><span>def </span>close[_ &gt;: <span>State </span>&lt;: Open](): Lock[Closed] = <span>Lock</span>()<br/><br/></pre>
<p>We can bring any lock to the broken state so that the <kbd>break</kbd> method does not have any constraints defined on it.</p>
<p>The transition to the <kbd>Open</kbd> state is only available from the <kbd>Closed</kbd> state, and we encode this fact with the existential type (that, nevertheless, should be available for successful compilation), which is a subclass of the current <kbd>State</kbd> of the lock and a superclass of <kbd>Closed</kbd>. The only possibility to satisfy type constraint is for <kbd>State</kbd> to be equal to <kbd>Closed</kbd>. This is done in the same way that it is only possible way to call the <kbd>close</kbd> method and satisfy type constraints by having <kbd>Lock</kbd> in the <kbd>Open</kbd> state. Let's see how the compiler reacts in different cases:</p>
<pre>scala&gt; val openLock = Lock[Open]<br/>openLock: Lock[Open] = Lock()<br/>scala&gt; val closedLock = openLock.close()<br/>closedLock: Lock[Closed] = Lock()<br/>scala&gt; val broken = closedLock.break<br/>broken: Lock[Broken] = Lock()<br/>scala&gt; closedLock.close()<br/> ^<br/> error: inferred type arguments [Closed] do not conform to method close's type parameter bounds [_ &gt;: Closed &lt;: Open]<br/>scala&gt; openLock.open()<br/> ^<br/> error: inferred type arguments [Open] do not conform to method open's type parameter bounds [_ &gt;: Open &lt;: Closed]<br/>scala&gt; broken.open()<br/> ^<br/> error: inferred type arguments [Broken] do not conform to method open's type parameter bounds [_ &gt;: Broken &lt;: Closed]</pre>
<p>The compiler refuses to accept calls that would lead to inappropriate state transitions. </p>
<p>We can also provide an alternative implementation by using generalized type constraints:</p>
<pre><span>def </span>open(<span>implicit </span>ev: <span>State </span>=:= Closed): Lock[Open] = <span>Lock</span>()<br/><span>def </span>close(<span>implicit </span>ev: <span>State </span>=:= Open): Lock[Closed] = <span>Lock</span>()</pre>
<p>It is arguable that the generalized syntax conveys the intention much better as it almost reads as <kbd>State should be equal to Closed</kbd> in the first case or <kbd>State should be equal to Open</kbd> in the second case.</p>
<p>Let's see how the compiler reacts to our new implementation:</p>
<pre>scala&gt; val openLock = Lock[Open]<br/>openLock: Lock[Open] = Lock()<br/><br/>scala&gt; val closedLock = openLock.close<br/>closedLock: Lock[Closed] = Lock()<br/><br/>scala&gt; val lock = closedLock.open<br/>lock: Lock[Open] = Lock()<br/><br/>scala&gt; val broken = closedLock.break<br/>broken: Lock[Broken] = Lock()<br/><br/>scala&gt; closedLock.close<br/>                  ^<br/>       error: Cannot prove that Closed =:= Open.<br/><br/>scala&gt; openLock.open<br/>                ^<br/>       error: Cannot prove that Open =:= Closed.<br/><br/>scala&gt; broken.open<br/>              ^<br/>       error: Cannot prove that Broken =:= Closed.</pre>
<p>Obviously, the error messages are also better for the implementation with generalized type constraints.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Self-recursive types</h1>
                </header>
            
            <article>
                
<p>Let's recall different implementations inheriting from a single trait from the previous example:</p>
<pre><span>sealed trait </span>Lock<br/><span>class </span>PadLock <span>extends </span>Lock<br/><span>class </span>CombinationLock <span>extends </span>Lock</pre>
<p>We will now extend <kbd>Lock</kbd> with an <kbd>open</kbd> method, which should return the same type of <kbd>Lock</kbd> and let our implementations serve as type parameters:</p>
<pre><span>sealed trait </span>Secret[<span>E</span>]<br/>sealed trait Lock[E] { def open(key: Secret[E]): E = ??? }<br/>case class PadLock() extends Lock[PadLock]<br/>case class CombinationLock() extends Lock[CombinationLock]</pre>
<p>The realization is not very interesting for now—the important part is that it returns the same type as the instance it was called on. </p>
<p>Now, with this implementation, there is an issue that we can use it with something that is not a <kbd>Lock</kbd> at all:</p>
<pre><span>case class </span>IntLock() <span>extends </span>Lock[Int]<br/><span>lazy val </span><span>unlocked</span>: Int = <span>IntLock</span>().open(<span>new </span>Secret[Int] {})</pre>
<p>Naturally, we don't want to allow this! We want to constrain our type parameter so that it is a subtype of <kbd>Lock</kbd>:</p>
<pre><span>sealed trait </span>Lock[<span>E </span>&lt;: Lock]</pre>
<p>But unfortunately, this won't compile because the <kbd>Lock</kbd> takes a type parameter that is absent in the preceding definition. We need to provide that type parameter. What should it be? Logically, the same type as we used to parameterize the <kbd>Lock</kbd>—<kbd>E</kbd>:</p>
<pre><span>sealed trait </span>Lock[<span>E </span>&lt;: Lock[<span>E</span>]] {<br/>  <span>def </span>open(key: Secret[<span>E</span>]): <span>E </span>= <span>???<br/></span>}</pre>
<p>The type parameter looks a bit weird because it refers to itself recursively. This way of defining a type is called a <strong>self-recursive type parameter</strong> (or sometimes an F-bounded type polymorphism).</p>
<p>Now, we can only parameterize <kbd>Lock</kbd> by the type, which is itself a <kbd>Lock</kbd>:</p>
<pre>scala&gt; case class IntLock() extends Lock[Int]<br/>                                      ^<br/>       error: illegal inheritance;<br/>        self-type IntLock does not conform to Lock[Int]'s selftype Int<br/>scala&gt; case class PadLock() extends Lock[PadLock]<br/>defined class PadLock</pre>
<p>But unfortunately, we can still mess things up by defining the wrong subtype as a type parameter:</p>
<pre>scala&gt; case class CombinationLock() extends Lock[PadLock]<br/>defined class CombinationLock</pre>
<p>Therefore, we need to define another constraint that will say that the type parameter should refer to the type itself, not just any <kbd>Lock</kbd>. We already know that there is a self-type that can be used for that:</p>
<pre><span>sealed trait </span>Lock[<span>E </span>&lt;: Lock[<span>E</span>]] { self: <span>E  </span>=&gt;<br/>  <span>def </span>open(key: Secret[<span>E</span>]): E = self<span><br/></span>}<br/><br/>scala&gt; case class CombinationLock() extends Lock[PadLock]<br/>                                              ^<br/>       error: illegal inheritance;<br/>        self-type CombinationLock does not conform to Lock[PadLock]'s selftype PadLock<br/>scala&gt; case class CombinationLock() extends Lock[CombinationLock]<br/>defined class CombinationLock<br/>scala&gt; PadLock().open(new Secret[PadLock]{})<br/>res2: PadLock = PadLock()<br/>scala&gt; CombinationLock().open(new Secret[CombinationLock]{})<br/>res3: CombinationLock = CombinationLock()</pre>
<p>Nice! We've just defined a <kbd>Lock</kbd> trait that can only be parameterized with classes that extend this trait and only by the class itself. We've done this by using a combination of the self-recursive type parameter and the self-type.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p class="p1">The type system is one of the key components of the Scala language. It allows the developer to express expectations about the behavior of the program, which can then be checked at compile time. This reduces the number of tests needed to verify the correctness of the solution and the <span>possibility of runtime errors.</span></p>
<p class="p1">Usually, strictly typed languages are associated with verbose code. Normally, this is not the case with Scala because of its powerful type inference mechanism.</p>
<p class="p1">Scala allows you to define very narrow types containing a single value as well as much wider types, even those represented as a combination of other types.</p>
<p class="p1">The type definition can be made more precise by using type constraints, type parameters, and variance.</p>
<p class="p1">We also looked at some examples of how the type system can be used to express domain constraints.</p>
<p class="p1">Needless to say, Scala's ecosystem is much richer than what we have covered here. Some open source libraries offer advanced type constraints that are expressed as refined types, fixpoint types, or tagged types. Other libraries, such as shapeless, provide the possibility for type-level programming, which allows you to express and verify quite complex program logic at compile time.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>Which type constraints can you name?</li>
<li>What implicit type constraints are added to a type if there are no type constraints defined on it by the developer?</li>
<li>Which operators can be used to refer to the nested type of some type?</li>
<li>Which type can be used as an infix type?</li>
<li>Why is the use of structural types discouraged in Scala?</li>
<li>What is expressed via variance?</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p class="book-top-block-info-anl cf"/>
<ul>
<li><span>Mads Hartmann, and Ruslan Shevchenko, </span><em>Professional Scala</em><span>: </span><span>You will learn how to write type-safe code concisely and expressively in an environment that lets you build for the JVM, browser, and more.</span></li>
</ul>
<p> </p>
<ul>
<li><span>Vikash Sharma, </span><em>Learning Scala Programming: </em><span><em>Learn how to write scalable and concurrent programs in Scala</em>, a language that grows with you.</span></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>