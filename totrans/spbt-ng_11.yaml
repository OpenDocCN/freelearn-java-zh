- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building Reactive Forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we have already learned how to structure our Angular
    application at the module and component level, which promotes the maintainability
    of code, especially in enterprise applications. We have organized modules into
    three categories: core modules, shared modules, and feature modules. We have also
    grouped components into two classifications: Smart and Dumb components, which
    separate components that retrieve data and have dependencies from components that
    are for presentation purposes only.'
  prefs: []
  type: TYPE_NORMAL
- en: We have also discussed how to configure and implement Angular Material, which
    is a UI library that provides ready-to-use components and base styling for our
    Angular application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will now start learning how to build forms using reactive
    forms in Angular. We will understand form groups, form controls, and form arrays
    and create validations in our form.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reactive forms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic form controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping form controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `FormBuilder` service to generate controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validating form input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a link to the finished version of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-11](https://github.com/PacktPublishing/Spring-Boot-and-Angular/tree/main/Chapter-11)'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding reactive forms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the advantages of the `@angular/forms` package once we have created our
    Angular application. There are two available ways to build forms. These are **template-driven
    forms** and **reactive forms**; them having their own form extension is advantageous
    to the developers as this does not require installing under packages to create
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we can make sure that every Angular application uses a single
    library for building forms. In this section, we will be focusing more on how to
    implement reactive forms in our application as this is the commonly used method
    in developing forms in Angular applications, but first, let’s discuss a basic
    introduction to the template-driven approach before proceeding to reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: The template-driven approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Template-driven forms, as the name suggests, are forms declared and validated
    on the template (HTML). It uses the `ngForm` directives, which transforms the
    HTML form into a template-driven form and creates a top-level `FormGroup`, and
    the `ngModel` directive makes a `FormControl` for the form elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use template-driven forms, we must import `FormsModule` into the module
    where we want to use the template-driven forms. In the following code example,
    we have imported `FormsModule` into the `app.module.ts` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We must not forget to import `FormsModule` as our application will not recognize
    the `ngForm` and `ngModel` directives.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a template-driven form
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first step in creating template-driven forms is to create an HTML form
    template. Let’s have a look at the following code example for an illustration
    of how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we have created our HTML form template and have
    added three form elements: the email, first name, and last name input, which will
    be our form controls. We have also enclosed the elements with a `<``form>` tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully creating an HTML form template, this form will be automatically
    converted into a template-driven form. It is not required for us to add the `ngForm`
    directive to the `form` tag as Angular finds all form tags in our application
    to convert it into a template-driven form, although we can still use the `ngForm`
    directive to be assigned in a local template variable for us to access the properties
    and method of the `ngForm` directive. We can also use the variable template for
    submitting our forms. Let’s have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can convert our elements into form controls by adding the `ngModel`
    directive to each input; this allows us to track the values, validation status,
    and user interaction of each form element. Let’s have a look at the following
    code example with the added form controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will add an `ngSubmit` event to submit the data of the form component.
    We will add the `ngSubmit` event to the `form` tag and add a method to the component
    class to receive the data. Let’s have a look at the following code example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, once the user has clicked the `onSubmit()` method,
    and it will display the form control values as a JSON object in our console; this
    will now allow us to use the form values in sending data implementing business
    logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully implementing all the steps, we will now have a final template
    for the template-driven form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When to use template-driven forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Template-driven forms are very flexible and easy to implement in Angular applications.
    However, this approach has some limitations and can cause an impact in terms of
    maintainability; some of the best scenarios for using a template-driven approach
    in building forms are set out here:'
  prefs: []
  type: TYPE_NORMAL
- en: It’s easier to use template-driven forms when migrating from AngularJS to Angular2,
    such that both use the `ngModel` directive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template-driven forms are more suitable in simple and small forms that do not
    require complex validations since validation is applied at the template level.
    This could be a disadvantage as it will be hard to maintain validations on larger
    applications at the same time. It has limitations on applying validations to the
    form controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second of the aforementioned scenarios, reactive forms are chosen over
    template-driven forms as complex forms can be handled better with reactive forms,
    especially in implementing validations. Let’s now understand the concept of reactive
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: The reactive approach
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A reactive form is the second approach in building forms in Angular applications;
    this is the most commonly used approach as it is more effective in handling complex
    forms than template-driven forms. Reactive forms are also known as **model-driven
    forms**, in which we define the structure of our forms in the component class
    instead of defining it in the template.
  prefs: []
  type: TYPE_NORMAL
- en: We also define the validations in the class before we bind it in to our HTML
    form, which means that the logic and validation patterns will now be separated
    from the HTML template and will be maintained by the TypeScript side of our component.
  prefs: []
  type: TYPE_NORMAL
- en: Using reactive forms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step for us to use reactive forms is to import `ReactiveFormsModule`;
    this is usually imported into the root module or the shared module of the application.
    `ReactiveFormsModule` contains all directives—such as `formGroup` and `formControlName`—that
    will allow us to implement reactive forms; this is also found under the `@``angular/forms`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully importing `ReactiveFormsModule`, the next step is to create
    our HTML form template and create a model using `FormGroup`, `FormControl`, and
    `FormArray`. These are the three building blocks of reactive forms that we will
    use to bind our form templates and are outlined in more detail here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FormControl`: This represents a single form element inside a form; it stores
    the value of a form element that allows us to retrieve data from each input.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormArray`: This is a collection of form controls that allows us to dynamically
    add and remove controls to accept more values from the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FormGroup`: This is a collection of form controls; it can also contain another
    form group or form arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assuming we have a `HeroesComponent`, we will create a `FormGroup` by writing
    the following code in the class component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we have instantiated a new `FormGroup` and assigned
    it to the `userForm` variable; this is only a form group, and we have not yet
    added form controls to the model. To add a form control, we will place the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the preceding example that we have added three form controls to
    our `FormGroup`; this can now be bound to the HTML form template in our application
    to capture the values and state of form elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now create an HTML form template with `formGroup` and `formControlName`
    directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the example code, we can see that the template is almost the same as the
    template-driven forms. The only difference is that we use `formGroup` and `formControlName`
    directives to bind our form. The `formGroup` directive is used to bind the `userFrom`
    form group in our component class; on the other hand, the `formControlName` directive
    is used to bind the values and the state of the form controls defined in the `userForm`
    form group. Lastly, we are still using the `ngSubmit` event to call a method when
    the **Submit** button in the form is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: We have now successfully created a reactive form in our application, but this
    only covers the basic features and concepts of reactive forms. In the following
    sections of this chapter, we will be discussing the functionalities and capabilities
    of form controls and form groups.
  prefs: []
  type: TYPE_NORMAL
- en: Basic form controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will now discuss more of the concepts of form controls in reactive
    forms. We have already created an example of form controls in the previous section,
    but now, we will discover more about the functions and capabilities of form controls
    in Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Form controls represent a single form element inside a form; they store the
    value of a form element that allows us to retrieve data of each input. This can
    be `input`, `textarea`, or any element that accepts values. When used in Angular,
    form controls can be instantiated by adding `new FormControl('')` code; we can
    see that it takes a single argument that defines the values of the control. These
    values can be `null` as form controls can be reset.
  prefs: []
  type: TYPE_NORMAL
- en: Form controls are like the properties of a JSON object, but compared to JSON,
    each control has its methods that will help us control, modify, and validate the
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s have a look at the different methods and features of form controls.
  prefs: []
  type: TYPE_NORMAL
- en: Form control methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s have a look at the different form control methods and their parameters
    that we can use for modifying controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setValue()`: A method that sets the new value for the control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`value`: The new value assigned to the form control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: An object that defines the configuration of the controls on how
    it will propagate changes and emit events when the value changes. Here are the
    options that we can set in the form control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onlySelf`: When set to `true`, the changes from the control will not affect
    the other controls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emitEvent`: When set to `true` or not supplied, `statusChanges` and `valueChanges`
    observables are emitted when the status and the value of the form control are
    updated.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emitModelToViewChange`: When set to `true` or not supplied, a change from
    the form control will call the `onChange` event to update the view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emitViewToModelChange`: When set to `true` or not supplied, a change from
    the form control will call the `onModelChange` event to update the view.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the code for using the `setValue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`patchValue()`: Patches the value of a control. The parameters of the `patchValue`
    method are the same as the `setValue()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the code for using the `patchValue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`getRawValue()`: Retrieves the value of a form control. This is commonly used
    on disabled form controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the code for using the `getRawValue()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`reset()`: Resets the form control from its default value. It will also mark
    the control as pristine and untouched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`formState`: Defines the initial value and the disabled state of the control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`options`: An object that defines the configuration of the controls on how
    it will propagate changes and emit events when the value changes. We can set the
    following option in the form control:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onlySelf`: When set to `true`, changes from the control will not affect the
    other controls.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the code for using the `reset()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`registerOnChange()`: Registers a listener to emit events once the form control
    value is changed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function`: The method that is called when the value changes, as illustrated
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`registerOnDisabledChange()`: Registers a listener to emit events once the
    `isDisabled` status of the control changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parameters**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`function`: The method that is called when the disabled status changes, as
    illustrated here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have now learned about the different methods we can use in form controls.
    Now, let’s have a look at some examples of different usage of form controls.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing form controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several ways to initialize our form controls. We can set the value,
    the disabled state, and the validators of a specific form control. Let’s have
    a look at the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing a form control with an** **initial value**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we instantiated a form control with a default
    value of `Hero`. We can access the value by accessing the `value` property inherited
    from `AbstractControl`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing a form control with an initial value and the** **disabled state**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we instantiated a form control with an object
    value. This initializes the value and the disabled state of the form control.
    We can access the value by accessing the `status` property inherited from `AbstractControl`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initializing a form control with an initial value and an array of** **built-in
    validators**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We instantiated a form control with an empty string value in the preceding code
    example. With the second parameter of an array of validators, this will return
    an invalid status since there should not be an empty value and should be a valid
    email format.
  prefs: []
  type: TYPE_NORMAL
- en: Resetting form controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use the `reset()` method to reset the value and the disabled state of
    a form control. Let’s have a look at the following code examples of different
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Resetting controls to a** **specific value**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used the `reset()` method with a parameter.
    The parameter allows us to reset the form control to a specific value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resetting controls to an** **initial value**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we used the `reset()` method without a parameter.
    This would reset the form control’s value with its initial value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Resetting controls with a value and a** **disabled state**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used an object parameter in calling the
    `reset()` method, and we have indicated the value and disabled state of the form
    control. In this case, it will disable the control and change the status to `DISABLED`.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In using form controls, we can listen to several events such as changing values
    and status. Let’s have a look at the following code examples on how to listen
    to events of form controls:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening to** **value changes**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have called the `valueChanges` property that
    has an `Observable` type, which we can subscribe to listen to changes to the form
    control value. In this case, once we set the value of the form control, the `valueChanges`
    property will emit the new value.
  prefs: []
  type: TYPE_NORMAL
- en: '**Listening to** **status changes**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have called the `statusChanges` property that
    has an `Observable` type, which we can subscribe to listen to changes to the form
    control status. In this case, once we disable the form control, this will emit
    the new status, which is `DISABLED`.
  prefs: []
  type: TYPE_NORMAL
- en: We have already learned about the features and functionalities of form controls;
    now, we will discuss how to group form controls using form groups and form arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping form controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section will now discuss how to group form controls in our application.
    Forms contain several related controls, which is why it is necessary to group
    them for a better structure. Reactive forms provide two ways to group form controls,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Form group**: Creates a form with a fixed set of form controls. Form groups
    can also contain another set of form groups to handle complex forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Form array**: Creates a form with dynamic form controls. It can add and remove
    form controls and at the same time can contain other form arrays to handle complex
    forms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating form groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Form groups allow us to control the values and status of form controls by groups.
    We can also access a single form control inside a form group using its name. To
    create a form group, let’s follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we have a `HeroComponent`; for example, the first step is to import
    the `FormGroup` and `FormControl` classes from the `@angular/forms` package, like
    so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to create a `FormGroup` instance. In this example, we want
    to create a new form group with `firstName`, `lastName`, and `knownAs` form controls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created a new form group named `heroForm`.
    Simultaneously, we have added three form controls as object parameters included
    in the `heroForm` form.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to bind our form group instance with the form element in our
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used the `formGroup` directive to bind
    our `heroForm` form in our form element. We must also bind each form control with
    the input elements by using the `formControlName` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to get the value of the whole form group. We will use the
    `ngSubmit` event to call a method and will retrieve the form value by accessing
    the `value` property, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have created and bound an example form group, but this is only a simple form
    group and introduces a linear structure of controls. Now, let’s create a form
    group that contains form groups.
  prefs: []
  type: TYPE_NORMAL
- en: Creating nested form groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Form groups can also have another form group instead of having a list of controls.
    Imagine a JSON object that has properties with the value of another JSON object.
    This cannot be handled by a simple linear of form controls, and we must create
    another set of form groups to take this kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s follow the next steps to develop nested form groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the previous form example; in this case, we would want to
    add a new `address` property in our form, but instead of having it as a new instance
    of the form control, we will declare it as a new instance of the form group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have added an `address` property as a new
    form group instance. We have also added new form controls inside the form group—namely,
    `street`, `city`, and `country`. This is now considered a nested form group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to bind the nested form group with our form element in the
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have used the `formGroupName` directive to
    bind our address form group. Remember that this element should be inside the `heroForm`
    form group; we have also used the `formControlName` directive to bind the controls
    under the nested form group. Now, we can also use the `ngSubmit` event again and
    call the `value` property as we did in the previous example to get the value of
    the whole form.
  prefs: []
  type: TYPE_NORMAL
- en: We have created simple and complex forms using form groups. Let’s now discuss
    another way of grouping controls using form arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Creating form arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Form arrays are helpful, especially if we want to add or remove controls in
    our form at runtime. This allows us to have flexible forms in our application
    and at the same time handle a more complex set of objects to process. To create
    a form array, let’s have a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the previous form example; in this case, we would want to
    add a new `powers` property to our form and declare it as a new `FormArray` instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created a new `FormArray` instance inside
    our `heroForm` form group. This accepts an empty array having no form controls
    on initialization. We have also assigned the instance of the form array into a
    variable for us to access the array in our view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create methods that can add and remove an instance of a
    form control in the form array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created two methods that we will use
    for the form array. The `addPower()` method allows us to add a new form control
    instance in the power form array; this gets the instance of the form array by
    name and pushes a new form control instance.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `deletePower()` method gets the instance of the form
    array by name and removes a specific form control using the `removeAt()` method
    and the index of the control to be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to bind the form array instance with the form element in the
    view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE123]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE124]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE125]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have bound the powers to form an array with
    the view using the `formArrayName` directive. We have also used the `ngFor` directive
    to iterate all the controls inside the form array; we would also need to get the
    index of each control to pass it on to our `deletePower()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully creating the form arrays, we will now have a view of the
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Hero form with a form group and form arrays](img/B18159_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Hero form with a form group and form arrays
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully created reactive forms using form groups and form arrays.
    Now, we will use the `FormBuilder` service to simplify the syntax in creating
    forms in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FormBuilder service to generate controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we successfully created reactive forms using form groups,
    form arrays, and form controls. However, as we can see from the syntax, creating
    forms becomes repetitive. We are always instantiating new instances of form controls,
    form arrays, and form groups, and this is not ideal in larger forms. `FormBuilder`
    provides the solution for this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a service that can be injected into our components to generate groups,
    controls, and arrays without instantiating new ones. To create a reactive form
    using `FormBuilder`, we will be following the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be transforming the form in the previous section using `FormBuilder`.
    The first step is to import the `FormBuilder` service into our component from
    `@angular/forms`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to inject the `FormBuilder` service into our component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step is now to create and generate controls using the methods of the
    `FormBuilder` service:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE136]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE137]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE138]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE140]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE141]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE148]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see in the preceding example that our form has the same structure as
    the form we created in the previous section. The major difference is that we are
    using the methods of `FormBuilder` to create forms. We have used the `group()`
    method to generate form groups, the `array()` method to generate a form array,
    and an array with an empty string value to generate a control and set its default
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The output for this code will be the same. `FormBuilder` methods are mainly
    for making our reactive forms clean and readable. Now, we will discuss how to
    add validations to our controls.
  prefs: []
  type: TYPE_NORMAL
- en: Validating form input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now created and simplified our reactive form in the previous section,
    but we want to make our forms accurate in accepting data and at the same time
    create a user-friendly experience for the user to let them know easily what the
    valid values for each control are. Now, we will learn how to add validations to
    our reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: In reactive forms, we are adding validators as parameters directly to the form
    controls in the component class instead of adding them as an attribute in the
    template.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Angular provides several built-in validator functions that we can use directly
    in our forms. Let’s have a look at some of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`static min(min: number)`—Requires the value of the control to be equal to
    or greater than the given number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE153]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE154]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE156]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE157]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`static required(control: AbstractControl<any, any>)`—Controls must not have
    a non-empty value:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE159]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`static requiredTrue(control: AbstractControl<any, any>)`—Controls must have
    a value of `true`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE165]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`static minLength(minLength: number)`—Used for arrays and strings, this requires
    that the length of the value should be equal to or greater than the given number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE167]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`static maxLength(maxLength: number)`—Used for arrays and strings, this requires
    that the length of the value should be equal to or less than the given number:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE171]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Custom validators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other than the built-in validators, we can also create custom validators, which
    is helpful if our forms require more complex verification and checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the following example custom validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code example, we have created a new validator named `checkHasNumberValidator()`.
    The main use of this validator is to invalidate control values that have a number.
    We have retrieved the form control where the validator is assigned, then we have
    tested the value of the control and will return a custom error named `hasNumbers`
    if the regex is `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After successfully creating the custom validator, we can now use it in our
    controls, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example code, we want our first name and last name field to
    be restricted to letters only. In this case, we have used `checkHasNumberValidator`
    as a second parameter for the `firstName` and `lastName` controls.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now proceed to the implementation of reactive forms.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing reactive forms in our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have now successfully learned how to develop reactive forms using `FormBuilder`,
    and at the same time, added validations to our controls. Now, we will implement
    these reactive forms in our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to create our form group instance. Under the `anti-hero/components/anti-hero-form`
    file, we will create our form group using the `FormBuilder` service in the class
    component, and at the same time, we will create our form elements in our HTML
    template. Follow the next steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a form group instance by executing the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE177]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE178]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE179]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE180]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE181]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE182]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE183]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE190]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create an HTML template, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the implemented code in our `component` class, the first thing we did was
    create a form group object. We have added several controls that resemble the properties
    of the anti-hero object. Our goal here is to use the same form for creating and
    updating an anti-hero detail. In this case, we have also added several `Input()`
    bindings and methods to our class to help the form identify which actions are
    currently being done:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selectedId`: This will accept the ID of the anti-hero if the actions are updated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`actionButtonLabel`: This will change depending on the action being done (`Create`
    or `Update`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkAction()`: If `selectedId` has a value, this will change the value of
    `actionButtonLabel` to `"Update"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`patchDataValues()`: This will be used for patching the values of the selected
    anti-hero in the form controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`emitAction()`: Emits the value of the form and the action into the parent
    component.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clear()`: Calls the `reset()` method to clean the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The next step is to use the anti-hero form in our form page component. Under
    the `anti-hero/pages/form` file, we will place the anti-hero form in the HTML
    template, and at the same time, check the current route if it has the ID of the
    selected anti-hero in the parameters. Here are the steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the anti-hero form to the HTML template:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the activated router to capture the ID:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE199]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is now to create a route for our page form component. In the
    `anti-hero-routing.module.ts` file, we will add the following entry to our routes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE202]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE203]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE206]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE208]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE209]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE210]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE211]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE212]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code example, we have created two routes that redirect to `FormComponent`.
    The first route is for the `create` action, which has a `baseURL/anti-heroes/form`
    route, and the second route is for the `update` action, which has a `baseURL/anti-heroes/form/:id`
    route. This means that we are using the same components for our two actions, and
    the `id` parameters act as our indicator of which action is currently being done.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last step is to add navigations to the `list` component. We will add several
    methods that will call navigate methods to redirect us to the form component depending
    on the selected action, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`list.component.html`:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE214]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE215]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE216]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'selectAntiHero(data: {antiHero: AntiHero, action: TableActions}) {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: <! – Please refer to the list.component.ts file in the GitHub repo, Thank you->
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: this.router.navigate(['anti-heroes', 'form',
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: data.antiHero.id]);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'executeCommandBarAction(action: CommandBarActions) {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: switch(action) {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'case CommandBarActions.Create: {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: this.router.navigate(["anti-heroes", "form"]);
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'case CommandBarActions.DeleteAll: {'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: return;
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'default: ""'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'After accomplishing all the steps, we will now have the following form output:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.2 – Form UI \uFEFFfor creating an anti-hero](img/B18159_11_02.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Form UI for creating an anti-hero
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we have reached the end of this chapter; let’s have a recap of the
    valuable things you have learned. You have learned about the concepts and implementation
    of Angular reactive forms, and we have implemented `FormGroup`, `FormBuilder`,
    and `formControlName` directives to bind input values to capture data in our form.
    We have also discussed how to group form controls for binding nested properties
    and create form arrays in our reactive forms. This is primarily useful if some
    objects we want to display have array values.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, we want to accept a list of entries from users. Lastly, we
    have also learned how to implement validations for form controls to handle and
    verify user input, which will be beneficial for the user experience and help avoid
    unexpected errors.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the concepts and implementation of
    state management in Angular applications; we will discuss the idea of the Redux
    pattern and the **NgRx** library in terms of how they can improve the application
    architecture.
  prefs: []
  type: TYPE_NORMAL
