- en: Chapter 2. Creating Step Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Step Definitions file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying duplicate and Ambiguous Step Definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using regular expressions to optimize Step Definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Optional Capture/Noncapture groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming Data Tables to parse the test data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Data Table diffs to compare tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Doc Strings to parse big data as one chunk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining Doc Strings and Scenario Outlines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining String transformations for better conversions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes people who are not that well versed in Cucumber argue that creating
    a Step Definitions file is an overhead as compared to the frameworks that do not
    have Cucumber. But what they don't realize is that Cucumber auto-generates these
    Step Definitions, so it's not an overhead. With the knowledge of the concepts
    covered in this chapter, you will be able to write very effective and efficient
    Step Definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with the basic concepts of Glue Code/Step Definitions
    in detail by covering the different types of Step Definitions, the usage of regular
    expressions, and so on. To come up with optimized and efficient Step Definitions,
    we will also elaborate upon advanced concepts of Doc Strings, Data Table transformations,
    and Capture groups.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first Step Definitions file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's assume you are an automation developer and you have to implement automated
    test cases for a Feature file. The next Step in this direction would be to write
    the Step Definitions for this Feature file. So, how do we write Step Definitions
    in a Cucumber project? Let's see how to do this in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to create Step Definitions is to let Cucumber take care of
    it. The Steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the Feature file used in our previous chapter. Let''s use this Feature
    file to create our first Step Definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you save the Feature file and run (either via Eclipse or via a Terminal),
    Cucumber is going to give errors for the missing Step Definition files along with
    suggestions for Step Definitions. An example of the errors shown in Eclipse is
    seen in the following screenshot:![How to do it…](img/image00125.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Notice the suggestion given by Cucumber (highlighted in the preceding screenshot).
    As per Cucumber, all the Steps are in an **undefined** state as of now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the suggestions given by Cucumber and paste them to a default Step Definition
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember to give the path of the Step Definitions files to the Cucumber Options
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This is how our `LoginSteps.java` class will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the Feature file again and look at the Cucumber output:![How to do
    it…](img/image00126.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now our Scenario state has changed from **undefined** to **pending**. Refer
    to the highlighted area in the preceding screenshot. Cucumber suggests that we
    add the implementation to the pending Steps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will delete the throw statements from our class and replace them with some
    dummy code. You can call the actual automation code (either Selenium functions
    for websites or HTTPClient functions for service-oriented architecture (SOA) automation).
    Here is what our `LoginSteps.java` class looks like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, execute the Feature file again and observe the Cucumber output:![How to
    do it…](img/image00127.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the Cucumber output has changed and the status of our Steps has changed
    from **pending** to **passed**; also, the output of each function called in each
    Step has also been printed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether a Step Definitions was created with the annotations `@Given`, `@When`,
    or `@Then`, a Step Definitions will match any Gherkin Step as long as the regular
    expression matches the main text of the Step. For example, `Given I have 100 in
    my account` and `When I have 100 in my account` will be matched to `@Given("^I
    have (.*?) in my account$")`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let''s understand each Step performed in the previous section in more detail
    to get a better understanding of the concept of Step Definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: Step Definitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Cucumber starts execution, it looks for all classes on the Classpath that
    are in a specified glue package (or descendant).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Step Definitions is a small piece of code with a pattern attached to it. The
    pattern is used to link the Step Definitions to all the matching Steps, and the
    code is what Cucumber will execute when it sees a Gherkin Step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use Cucumber annotations, such as `@Given`, `@When`, and `@Then` to create
    Step Definitions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Step `Given user is on Application landing page`, the text after the
    `Given` keyword (`user is on Application landing page`) is what Cucumber matches
    in the Step Definitions file **(@Given("^user is on Application landing page$"))**.
    And when Cucumber finds a match, it executes the function mentioned within that
    Step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undefined Steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we first executed the Feature file, Cucumber did not find any matching
    Step Definitions, that's why Cucumber gave us **Undefined Steps Error**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cucumber will also give its own Suggestion for getting rid of Undefined Steps.
    All subsequent Steps after Undefined Step in the Scenario are skipped and Scenario
    is marked as Fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pending Steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we use the code suggested by Cucumber in our Step Definition file, and
    we run the Feature file then we get Pending Steps Exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pending Steps Exception is because of following Code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When Cucumber encounters this statement, it understands that these Steps are
    still a work in progress Step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Status of the Scenario is pending, First Step having `PendingException()` will
    be marked as pending and all other Steps in that Scenario are skipped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented Steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we replace the throw command with functional code, the pending exception
    error goes away.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, the status of the Steps will depend on the code being executed in that
    Step.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying Duplicate and Ambiguous Step Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes when we are writing Cucumber Step Definitions files, we get either
    Duplicate Step Definitions errors or Ambiguous Step Definitions errors. Let's
    try and understand the reasons why these errors arise, and how we can remove them
    through this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use the same Feature file from previous recipe. Perform the following
    Steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create one more class in the `StepDefinitions` package, called `DuplicateAmbiguous.java`,
    with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you try to run the Feature file, observe the Cucumber output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cucumber gives us a Duplicate Step Definitions error stating that there are
    two Step Definitions that are an exact match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s change the content of `DuplicateAmbiguous.java` to the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the Feature file and observe the Cucumber output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, Cucumber throws the Ambiguous Steps error and is not able to decide which
    Step Definitions to use, as the two Step Definitions are a partial match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since Cucumber-JVM looks for all classes on the Classpath that are in a specified
    glue package (or descendant), so there are chances that we might have some duplication
    (partial/exact) in Step Definitions. Let''s understand this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Duplicate Steps**: When Cucumber encounters multiple Step Definitions that
    are exactly the same, it throws a Duplicate Step Definitions exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ambiguous Steps**: When Cucumber encounters multiple Step Definitions that
    are a partial match, it throws an Ambiguous Step Definitions exception.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If Cucumber encounters duplicate/Ambiguous Steps, all the other Steps of such
    Scenarios are skipped and those Scenarios are marked as Fail.
  prefs: []
  type: TYPE_NORMAL
- en: Cucumber even specifies the two instances that are causing the error (refer
    to the highlighted code in the Cucumber output shown in Step 4 of this recipe).
  prefs: []
  type: TYPE_NORMAL
- en: In one execution, only the first two occurrences of the erroneous Steps are
    identified; if there are more duplicate occurrences of the same Step, then these
    will be identified in the next execution.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To check that there are no errors or exceptions in the Step Definitions, run
    Feature files with `dryRun = true` and `strict=true` in the Cucumber Options class.
    This will only check the validity of the Step Definitions and will not execute
    the code within them. We will read about these options in detail in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Regular Expressions to optimize Step Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have created Step Definitions with one-to-one relations with Steps.
    But this way of writing Step Definitions can be cumbersome as we write more and
    more Feature files. So, we will write generic Step Definitions that will apply
    to all the Steps that follow a certain pattern, thus bringing down the number
    of Step Definitions required. Let's see how to do this in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's assume we are writing Step Definitions for the following Scenario.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the Feature file, and copy and paste the Cucumber Step Definitions
    suggestions in the `LoginSteps.java` class. This is how `LoginSteps.java` looks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Focus on the Step Definitions mentioned in bold in the preceding code sample.
    We have used regular expressions and enabled a single Step Definitions to match
    various Steps, which matches the wildcard pattern mentioned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cucumber allows us to use regular expressions to empower Step Definitions to
    match multiple Steps. Let''s understand how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capture groups:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you surround part of a regular expression with parentheses, it becomes
    a capture group. In a Cucumber Step Definitions, the text matched within each
    capture group is passed to the code block as an argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example in 2nd Step Definition Capture group is `wrongusername` and it will
    be passed to variable username. Similarly in 3rd Step Definition Capture Group
    is `password` and it will be passed to variable password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For statically typed languages, Cucumber will automatically transforms those
    Strings into the appropriate type. For dynamically typed languages, no transformation
    happens by default, as there is no type information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Cucumber also allows integers to be passed in Capture groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, consider the following Step:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this Step, the Step Definitions will look like this (focus on the highlighted
    code):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Cucumber also allows Lists to be passed in Capture groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, consider the following Step:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Step Definition will look like this, focus on the highlighted code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are some types of regular expressions available in Cucumber:'
  prefs: []
  type: TYPE_NORMAL
- en: '**. Dot** means match any single character.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*** Star**, a repetition modifier, takes a character and tells us how many
    times it can reappear.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**+ Plus**, a repetition modifier, takes a character and tells us that the
    character can be repeated at least once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\d** stands for diGitHub, or [0-9].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\w** stands for a word character, specifically [A-Za-z0-9_].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**\s** stands for a whitespace character, including tab space or line break.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also negate shorthand character classes by capitalizing them; for example,
    `\D` refers to any character except a diGitHub.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using Optional Capture and Noncapture Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have covered how to write Step Definitions for various keywords
    in Feature files. Now let's talk about how we can efficiently use Step Definitions
    for multiple Steps.
  prefs: []
  type: TYPE_NORMAL
- en: Think about a situation where we are testing a positive situation in one Step
    and a negative situation in some other Step—the only difference in both Steps
    is just the word "No", while the remaining sentence is same. Based on the knowledge
    that we have acquired so far, we will write two Step Definitions for these two
    Steps. But is there a better way of doing this? Let's see how we can do this better
    in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, consider the following Scenarios and focus on the highlighted
    text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the following Step Definitions for both Scenarios and focus on the code
    that is highlighted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now run the Scenarios; you will see the following output:![How to do it…](img/image00128.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An Optional Capture group eliminates the duplication of Step Definitions and
    can definitely improve the readability of Feature files. Using optional groups,
    the same Step Definitions can be used for both positive and negative assertions.
    Let''s discuss this in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional Capture group/alternation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of a pipe between parentheses creates an optional group (`Text1|Text
    2`). Here, more than two options can also be grouped. In this example, Steps with
    either `Text1` or `Text2` will be accepted by this Step Definitions, and accordingly,
    `Text1` or `Text2` will be passed as the Capture value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Optional Noncapture group:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The addition of `?:` to the beginning of Optional Capture groups creates optional
    non-Capture groups. Having `?:` will treat the group as optional , but it will
    not be captured. So, you do not need to pass an argument as described earlier
    with optional captured groups.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Transforming Data Tables to parse the test data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered how Data Tables can be used to send large
    sets of data to a single Step. Now let's understand how to handle Data Tables
    in Step Definitions in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume we are writing Step Definitions for the following Scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the Feature file, and copy paste the Cucumber Step Definitions suggestions
    in the `LoginSteps.java` class. These are the additional Steps in `LoginSteps.java`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, Cucumber passed the table as `DataTable` to the Step argument. Focus on
    the suggestion given by Cucumber to convert the table to a List or a List of Lists
    and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, replace the code suggestion given by Cucumber with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have used the `raw()` method of the Cucumber DataTable API to convert
    the Data Table into a List of List of Strings. After that, we have used two `for`
    loops to traverse all the elements of the List of List of Strings. This is how
    the Cucumber output looks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/image00129.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data Tables are passed to the Step Definitions as the last argument. We need
    to import `cucumber.api.DataTable` into Java code. DataTable API's `raw()` method
    is used to convert a Data Table to a List of List of String.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also convert a Data Table to various types of Lists. Let''s see what
    we can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A List of user-defined variables**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s define a custom class called `User`, which has name and email as data
    members. The header row is used to name fields in a generic List type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, its Step Definitions can be like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This Step Definitions will accept a List with objects as users (which is custom
    defined by us) and will print the names of users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**A List of maps**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `User` class defined in the previous Step, the Step Definitions can
    be like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Data Table is converted to the following List of maps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're converting a Data Table into a map, it is usually advisable not to
    have a top row naming the columns in the Gherkin table.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**List of List** **of scalar:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the `User` class defined in the previous Step, the Step Definitions can
    be presented as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Data Table is converted to the following Lists:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implementing data table diffs to compare tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Consider a situation where you need to verify an application response that is
    in the form of Table to another Data Table that we are sending in Feature file.
    This kind of verification is very common when we are testing REST services.
  prefs: []
  type: TYPE_NORMAL
- en: Based on what we have learned so far, we will break the Data Table down in the
    Feature file into a List of Lists, and then we will verify each element of those
    Lists with expected Lists (which we got after breaking the table). Let's understand
    how we can do this in an easier way.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, consider the following Scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now save the Feature file. After adding the following code to suggestions,
    this is how our Step Definitions will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can compare a table argument (the actual result) to another table that we
    provide within the Step Definitions (the expected result).
  prefs: []
  type: TYPE_NORMAL
- en: Both the tables should be in a certain format for it to work properly. Both
    tables should be column-oriented, and the first row of both tables should represent
    the column names. The column names must be unique for each column and they must
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the tables are different, an exception is thrown, and the difference between
    the two tables is reported in the execution report. Its output will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works…](img/image00130.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Rows that differ from what was expected will be printed twice—the first (preceded
    by a "`-`") is what was expected, followed by another (preceded by a "`+`"), which
    is what was actually returned.
  prefs: []
  type: TYPE_NORMAL
- en: Using Doc Strings to parse big data as one chunk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's consider a situation where we have to specify a lot of text in multiple
    lines (not in the shape of a table)—something like a few lines from a blog or
    a book. So, how do we handle this in Step Definitions? This is called passing
    Doc Strings in test Steps. Based on what we have covered until now, we can use
    regular expressions; but this is helpful for the first line only, and the text
    in all the other lines will be missed. In this recipe, let's see how to handle
    this situation.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s consider the following Step in our Feature file for this exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the highlighted text is the Doc String that we will be passing to the
    Step Definitions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Save and run the Feature file, and copy and paste the Cucumber suggestion for
    the missing Step Definitions. After adding the print statements, this is how our
    code will look:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the output of the preceding code:![How to do it…](img/image00131.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When writing Feature files, Doc Strings should be within three adjacent quotes
    `"""` at the beginning and three at the end.
  prefs: []
  type: TYPE_NORMAL
- en: In Step Definitions, you don't have to do anything special for Doc Strings,
    as the text within triple quotes (`"""`) will be passed as the last argument to
    the Step Definitions. In our code, we have also used one regular expression for
    the text `Cucumber Cookbook`, but not for the Doc String as the Doc String was
    passed to the last argument of the Step.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Indentation of the opening """ is unimportant, although common practice is to
    put it two spaces in from the enclosing Step. Each line of the String passed in
    the Doc String will be realigned to the indentation of the opening """.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Doc Strings and Scenario Outlines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now think of a situation where you are passing a Doc String but you have to
    combine that with a Scenario Outline. How does Cucumber behave in such a situation?
  prefs: []
  type: TYPE_NORMAL
- en: Let's think of a situation where we are specifying the requirements for the
    content of an e-mail, but the content is based on the role from which the e-mail
    is sent. So how do we specify such a requirement in a Feature file and how do
    we write the Step Definitions for it? Let's find out in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this recipe, let''s consider this Scenario:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now run the Feature file; copy the Step Definitions suggestion given by Cucumber
    and replace it with the following Step Definitions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you run the Scenario, this is the output for the data substitution of Row
    1:![How to do it…](img/image00132.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And this is the output for the data substitution of Row 2:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it…](img/image00133.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the preceding section, you learned how two basic concepts can be combined
    to come up with a solution for a complex problem. Two concepts that we used here
    are Doc Strings and Scenario Outline. Let''s see how they work:'
  prefs: []
  type: TYPE_NORMAL
- en: If you look closely, the highlighted text which is within `<>` in the `Then`
    Step of the Scenario Outline in Step 1 is the same as the text in the example
    table header row. (The text has been highlighted in Step 1). So, we are telling
    Cucumber that this text is just a placeholder, and during execution, its value
    will come from the example table.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in the preceding recipe, we don't have to do anything special
    for Doc Strings in Step Definitions—they are automatically passed as the last
    argument. So we did not have to do anything special in Step 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in Step 3, you can see in the output of the first execution: the values
    of `<Role>` and `<details>` are replaced with the data from Data Row 1 of the
    example table, and in the second execution, the values are replaced with data
    from Data Row 2 of the example table.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining String transformations for better conversions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Think about a Scenario where you want to convert some Strings in test Steps
    to some specific Strings in your code. For example, the PO has mentioned "29-12-1986"
    in a Step and you want Cucumber to understand this text as a date. Further, in
    some countries this could be in the DD-MM-YYYY format, while in others, it could
    be in the MM-DD-YYYY format. So how do we standardize this conversion? Let's find
    out how we can do this in Cucumber.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the following test Step for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can use the `@Format` String transformer to convert text to date.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Import `java.util.Date` into your Step Definitions file. This is how our Step
    Definitions will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output that appears after running the preceding Step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/image00134.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cucumber-JVM allows converting Strings into various scalar types. A scalar type
    is a type that can be derived from a single String value. Some of Cucumber-JVM's
    built-in scalar types are `numbers`, `enums`, `java.util.Date`, `java.util.Calendar`,
    and so on. Transformation to `java.util.Date` and `java.util.Calendar` will work
    out-of-the-box as long as the String value matches one of the Short, Medium, Full,
    or Long formats defined by `java.util.DateFormat`.
  prefs: []
  type: TYPE_NORMAL
- en: '`29-12-1986` from our example doesn''t match any of those formats, so we have
    to give Cucumber a hint by using `@Format`. We need to specify two things: First
    is the Format and second is the Data Type.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also write custom formatters if the formatting is not available in Cucumber-JVM
    by default. Further, we can even use String transformation for in cases other
    than date transformations.
  prefs: []
  type: TYPE_NORMAL
