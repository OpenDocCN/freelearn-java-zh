- en: Chapter 2. Creating Step Definitions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 创建步骤定义
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating your first Step Definitions file
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建你的第一个步骤定义文件
- en: Identifying duplicate and Ambiguous Step Definitions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别重复和模糊的步骤定义
- en: Using regular expressions to optimize Step Definitions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用正则表达式优化步骤定义
- en: Using Optional Capture/Noncapture groups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用可选捕获/非捕获组
- en: Transforming Data Tables to parse the test data
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据表转换为解析测试数据
- en: Implementing Data Table diffs to compare tables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现数据表差异以比较表格
- en: Using Doc Strings to parse big data as one chunk
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文档字符串将大数据解析为一个块
- en: Combining Doc Strings and Scenario Outlines
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合文档字符串和场景概述
- en: Defining String transformations for better conversions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义字符串转换以实现更好的转换
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Sometimes people who are not that well versed in Cucumber argue that creating
    a Step Definitions file is an overhead as compared to the frameworks that do not
    have Cucumber. But what they don't realize is that Cucumber auto-generates these
    Step Definitions, so it's not an overhead. With the knowledge of the concepts
    covered in this chapter, you will be able to write very effective and efficient
    Step Definitions.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，那些不太熟悉Cucumber的人可能会争论说，与没有Cucumber的框架相比，创建步骤定义文件是一个额外的负担。但他们没有意识到的是，Cucumber会自动生成这些步骤定义，所以它并不是一个负担。通过了解本章中涵盖的概念，你将能够编写非常有效和高效的步骤定义。
- en: In this chapter, we will start with the basic concepts of Glue Code/Step Definitions
    in detail by covering the different types of Step Definitions, the usage of regular
    expressions, and so on. To come up with optimized and efficient Step Definitions,
    we will also elaborate upon advanced concepts of Doc Strings, Data Table transformations,
    and Capture groups.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过涵盖不同类型的步骤定义、正则表达式的使用等详细地介绍粘合代码/步骤定义的基本概念。为了提出优化和高效的步骤定义，我们还将详细阐述文档字符串、数据表转换和捕获组的先进概念。
- en: Creating your first Step Definitions file
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建你的第一个步骤定义文件
- en: Now let's assume you are an automation developer and you have to implement automated
    test cases for a Feature file. The next Step in this direction would be to write
    the Step Definitions for this Feature file. So, how do we write Step Definitions
    in a Cucumber project? Let's see how to do this in this recipe.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你是一名自动化开发者，你必须为特性文件实现自动化测试用例。在这个方向上的下一步将是编写这个特性文件的步骤定义。那么，我们如何在Cucumber项目中编写步骤定义呢？让我们看看这个配方中是如何做到这一点的。
- en: How to do it…
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'The easiest way to create Step Definitions is to let Cucumber take care of
    it. The Steps are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建步骤定义最简单的方法是让Cucumber来处理。步骤如下：
- en: 'Here is the Feature file used in our previous chapter. Let''s use this Feature
    file to create our first Step Definitions:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们在上一章中使用的特性文件。让我们使用这个特性文件来创建我们的第一个步骤定义：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you save the Feature file and run (either via Eclipse or via a Terminal),
    Cucumber is going to give errors for the missing Step Definition files along with
    suggestions for Step Definitions. An example of the errors shown in Eclipse is
    seen in the following screenshot:![How to do it…](img/image00125.jpeg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你保存特性文件并运行（无论是通过Eclipse还是通过终端）时，Cucumber将为缺失的步骤定义文件提供错误以及步骤定义的建议。以下是在Eclipse中显示的错误示例![如何做到这一点…](img/image00125.jpeg)
- en: Notice the suggestion given by Cucumber (highlighted in the preceding screenshot).
    As per Cucumber, all the Steps are in an **undefined** state as of now.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意Cucumber给出的建议（在前面的截图中被突出显示）。根据Cucumber，所有步骤目前都处于**未定义**状态。
- en: Copy the suggestions given by Cucumber and paste them to a default Step Definition
    file.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制Cucumber给出的建议，并将其粘贴到默认的步骤定义文件中。
- en: Note
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to give the path of the Step Definitions files to the Cucumber Options
    class.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得将步骤定义文件的路径提供给Cucumber选项类。
- en: 'This is how our `LoginSteps.java` class will look:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们的`LoginSteps.java`类将看起来：
- en: '[PRE1]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, run the Feature file again and look at the Cucumber output:![How to do
    it…](img/image00126.jpeg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次运行特性文件并查看Cucumber输出：![如何做到这一点…](img/image00126.jpeg)
- en: Now our Scenario state has changed from **undefined** to **pending**. Refer
    to the highlighted area in the preceding screenshot. Cucumber suggests that we
    add the implementation to the pending Steps.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们的场景状态已从**未定义**变为**挂起**。参看前一个截图中被突出显示的区域。Cucumber建议我们为挂起的步骤添加实现。
- en: 'We will delete the throw statements from our class and replace them with some
    dummy code. You can call the actual automation code (either Selenium functions
    for websites or HTTPClient functions for service-oriented architecture (SOA) automation).
    Here is what our `LoginSteps.java` class looks like:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将删除类中的throw语句，并用一些虚拟代码替换它们。您可以调用实际的自动化代码（无论是网站上的Selenium函数还是面向服务的架构（SOA）自动化中的HTTPClient函数）。以下是我们的`LoginSteps.java`类看起来像：
- en: '[PRE2]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, execute the Feature file again and observe the Cucumber output:![How to
    do it…](img/image00127.jpeg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次执行特性文件并观察Cucumber的输出：![如何做…](img/image00127.jpeg)
- en: Now the Cucumber output has changed and the status of our Steps has changed
    from **pending** to **passed**; also, the output of each function called in each
    Step has also been printed.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Cucumber的输出已经改变，我们步骤的状态已从**挂起**变为**通过**；此外，每个步骤中调用的每个函数的输出也已打印出来。
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Whether a Step Definitions was created with the annotations `@Given`, `@When`,
    or `@Then`, a Step Definitions will match any Gherkin Step as long as the regular
    expression matches the main text of the Step. For example, `Given I have 100 in
    my account` and `When I have 100 in my account` will be matched to `@Given("^I
    have (.*?) in my account$")`.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不论是使用`@Given`、`@When`还是`@Then`注解创建的步骤定义，只要正则表达式与步骤的主要文本匹配，步骤定义就会匹配任何Gherkin步骤。例如，`Given
    I have 100 in my account`和`When I have 100 in my account`将会匹配到`@Given("^I have
    (.*?) in my account$")`。
- en: How it works…
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Now let''s understand each Step performed in the previous section in more detail
    to get a better understanding of the concept of Step Definitions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地了解上一节中执行的每个步骤，以更好地理解步骤定义的概念：
- en: Step Definitions
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 步骤定义
- en: When Cucumber starts execution, it looks for all classes on the Classpath that
    are in a specified glue package (or descendant).
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Cucumber开始执行时，它会查找类路径上所有位于指定粘合包（或其子包）中的类。
- en: A Step Definitions is a small piece of code with a pattern attached to it. The
    pattern is used to link the Step Definitions to all the matching Steps, and the
    code is what Cucumber will execute when it sees a Gherkin Step.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 步骤定义是一小段代码，其中附加了一个模式。该模式用于将步骤定义链接到所有匹配的步骤，而代码是Cucumber在看到Gherkin步骤时将执行的内容。
- en: We use Cucumber annotations, such as `@Given`, `@When`, and `@Then` to create
    Step Definitions.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用Cucumber注解，如`@Given`、`@When`和`@Then`来创建步骤定义。
- en: In the Step `Given user is on Application landing page`, the text after the
    `Given` keyword (`user is on Application landing page`) is what Cucumber matches
    in the Step Definitions file **(@Given("^user is on Application landing page$"))**.
    And when Cucumber finds a match, it executes the function mentioned within that
    Step.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在步骤`Given user is on Application landing page`中，`Given`关键字之后的文本（`user is on
    Application landing page`）是Cucumber在步骤定义文件中匹配的内容（**@Given("^user is on Application
    landing page$")**）。当Cucumber找到匹配项时，它将执行该步骤中提到的函数。
- en: Undefined Steps
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未定义步骤
- en: When we first executed the Feature file, Cucumber did not find any matching
    Step Definitions, that's why Cucumber gave us **Undefined Steps Error**.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们首次执行特性文件时，Cucumber没有找到任何匹配的步骤定义，这就是为什么Cucumber给出了**未定义步骤错误**。
- en: Cucumber will also give its own Suggestion for getting rid of Undefined Steps.
    All subsequent Steps after Undefined Step in the Scenario are skipped and Scenario
    is marked as Fail.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cucumber还会给出自己的建议来消除未定义步骤。在场景中未定义步骤之后的后续步骤都将被跳过，场景将被标记为失败。
- en: Pending Steps
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 挂起步骤
- en: When we use the code suggested by Cucumber in our Step Definition file, and
    we run the Feature file then we get Pending Steps Exception.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们在步骤定义文件中使用Cucumber建议的代码，并运行特性文件时，我们会得到挂起步骤异常。
- en: 'Pending Steps Exception is because of following Code:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 挂起步骤异常是因为以下代码：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When Cucumber encounters this statement, it understands that these Steps are
    still a work in progress Step.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Cucumber遇到这个语句时，它理解这些步骤仍然处于进行中。
- en: Status of the Scenario is pending, First Step having `PendingException()` will
    be marked as pending and all other Steps in that Scenario are skipped.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 场景的状态是挂起，第一个有`PendingException()`的步骤将被标记为挂起，该场景中的其他所有步骤都将被跳过。
- en: Implemented Steps
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现步骤
- en: When we replace the throw command with functional code, the pending exception
    error goes away.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们用功能代码替换throw命令时，挂起异常错误就会消失。
- en: Now, the status of the Steps will depend on the code being executed in that
    Step.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，步骤的状态将取决于该步骤中执行的内容。
- en: Identifying Duplicate and Ambiguous Step Definitions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别重复和模糊的步骤定义
- en: Sometimes when we are writing Cucumber Step Definitions files, we get either
    Duplicate Step Definitions errors or Ambiguous Step Definitions errors. Let's
    try and understand the reasons why these errors arise, and how we can remove them
    through this recipe.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候当我们编写Cucumber步骤定义文件时，我们会遇到重复步骤定义错误或模糊步骤定义错误。让我们尝试理解这些错误产生的原因，以及我们如何通过本食谱来消除它们。
- en: How to do it…
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will use the same Feature file from previous recipe. Perform the following
    Steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用之前食谱中相同的特征文件。执行以下步骤：
- en: 'Let''s create one more class in the `StepDefinitions` package, called `DuplicateAmbiguous.java`,
    with the following content:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`StepDefinitions`包中创建另一个名为`DuplicateAmbiguous.java`的类，内容如下：
- en: '[PRE4]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you try to run the Feature file, observe the Cucumber output:'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你尝试运行特征文件时，观察Cucumber输出：
- en: '[PRE5]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Cucumber gives us a Duplicate Step Definitions error stating that there are
    two Step Definitions that are an exact match.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Cucumber显示一个重复步骤定义错误，指出有两个步骤定义是完全匹配的。
- en: 'Let''s change the content of `DuplicateAmbiguous.java` to the following code:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将`DuplicateAmbiguous.java`的内容更改为以下代码：
- en: '[PRE6]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now run the Feature file and observe the Cucumber output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行特征文件并观察Cucumber输出：
- en: '[PRE7]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, Cucumber throws the Ambiguous Steps error and is not able to decide which
    Step Definitions to use, as the two Step Definitions are a partial match.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，Cucumber抛出模糊步骤错误，无法决定使用哪个步骤定义，因为两个步骤定义是部分匹配的。
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Since Cucumber-JVM looks for all classes on the Classpath that are in a specified
    glue package (or descendant), so there are chances that we might have some duplication
    (partial/exact) in Step Definitions. Let''s understand this in more detail:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Cucumber-JVM在指定的粘合包（或其子包）中查找所有类，因此我们可能会在步骤定义中存在一些重复（部分/完全）。让我们更详细地了解这一点：
- en: '**Duplicate Steps**: When Cucumber encounters multiple Step Definitions that
    are exactly the same, it throws a Duplicate Step Definitions exception.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重复步骤**：当Cucumber遇到多个完全相同的步骤定义时，它会抛出重复步骤定义异常。'
- en: '**Ambiguous Steps**: When Cucumber encounters multiple Step Definitions that
    are a partial match, it throws an Ambiguous Step Definitions exception.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模糊步骤**：当Cucumber遇到多个部分匹配的步骤定义时，它会抛出模糊步骤定义异常。'
- en: If Cucumber encounters duplicate/Ambiguous Steps, all the other Steps of such
    Scenarios are skipped and those Scenarios are marked as Fail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Cucumber遇到重复/模糊的步骤，则此类场景的所有其他步骤都将跳过，并且这些场景将被标记为失败。
- en: Cucumber even specifies the two instances that are causing the error (refer
    to the highlighted code in the Cucumber output shown in Step 4 of this recipe).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber甚至指定了导致错误的两个实例（参考本食谱第4步中显示的Cucumber输出中突出显示的代码）。
- en: In one execution, only the first two occurrences of the erroneous Steps are
    identified; if there are more duplicate occurrences of the same Step, then these
    will be identified in the next execution.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次执行中，只有错误步骤的前两个出现被识别；如果有更多相同步骤的重复出现，则将在下一次执行中识别。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To check that there are no errors or exceptions in the Step Definitions, run
    Feature files with `dryRun = true` and `strict=true` in the Cucumber Options class.
    This will only check the validity of the Step Definitions and will not execute
    the code within them. We will read about these options in detail in later chapters.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查步骤定义中没有错误或异常，请在Cucumber选项类中使用`dryRun = true`和`strict=true`运行特征文件。这将仅检查步骤定义的有效性，而不会执行其内的代码。我们将在后面的章节中详细阅读这些选项。
- en: Using Regular Expressions to optimize Step Definitions
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用正则表达式优化步骤定义
- en: Until now, we have created Step Definitions with one-to-one relations with Steps.
    But this way of writing Step Definitions can be cumbersome as we write more and
    more Feature files. So, we will write generic Step Definitions that will apply
    to all the Steps that follow a certain pattern, thus bringing down the number
    of Step Definitions required. Let's see how to do this in this recipe.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已创建了与步骤一对一关系的步骤定义。但随着我们编写越来越多的特征文件，这种方式编写步骤定义可能会变得繁琐。因此，我们将编写通用的步骤定义，这些定义将适用于遵循特定模式的所有后续步骤，从而减少所需的步骤定义数量。让我们看看在本食谱中如何实现这一点。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's assume we are writing Step Definitions for the following Scenario.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们正在编写以下场景的步骤定义。
- en: '[PRE8]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now run the Feature file, and copy and paste the Cucumber Step Definitions
    suggestions in the `LoginSteps.java` class. This is how `LoginSteps.java` looks:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行特性文件，并将Cucumber步骤定义建议复制粘贴到`LoginSteps.java`类中。这就是`LoginSteps.java`的样子：
- en: '[PRE9]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Focus on the Step Definitions mentioned in bold in the preceding code sample.
    We have used regular expressions and enabled a single Step Definitions to match
    various Steps, which matches the wildcard pattern mentioned.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 专注于前面代码示例中提到的粗体步骤定义。我们使用了正则表达式并启用单个步骤定义来匹配多个步骤，这与提到的通配符模式相匹配。
- en: How it works…
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'Cucumber allows us to use regular expressions to empower Step Definitions to
    match multiple Steps. Let''s understand how this works:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber允许我们使用正则表达式来增强步骤定义以匹配多个步骤。让我们了解它是如何工作的：
- en: '**Capture groups:**'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捕获组：**'
- en: When you surround part of a regular expression with parentheses, it becomes
    a capture group. In a Cucumber Step Definitions, the text matched within each
    capture group is passed to the code block as an argument.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您将正则表达式的一部分用括号括起来时，它就变成了一个捕获组。在Cucumber步骤定义中，每个捕获组中匹配的文本被作为参数传递给代码块。
- en: For example in 2nd Step Definition Capture group is `wrongusername` and it will
    be passed to variable username. Similarly in 3rd Step Definition Capture Group
    is `password` and it will be passed to variable password.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在第二个步骤定义中，捕获组是`wrongusername`，它将被传递给变量`username`。同样，在第三个步骤定义中，捕获组是`password`，它将被传递给变量`password`。
- en: For statically typed languages, Cucumber will automatically transforms those
    Strings into the appropriate type. For dynamically typed languages, no transformation
    happens by default, as there is no type information.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于静态类型语言，Cucumber会自动将这些字符串转换为适当类型。对于动态类型语言，默认情况下不会进行转换，因为没有类型信息。
- en: Cucumber also allows integers to be passed in Capture groups.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cucumber还允许将整数传递到捕获组中。
- en: 'For example, consider the following Step:'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，考虑以下步骤：
- en: '[PRE10]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For this Step, the Step Definitions will look like this (focus on the highlighted
    code):'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于这个步骤，步骤定义将看起来像这样（请关注高亮代码）：
- en: '[PRE11]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Cucumber also allows Lists to be passed in Capture groups.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cucumber还允许将列表传递到捕获组中。
- en: 'For example, consider the following Step:'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，考虑以下步骤：
- en: '[PRE12]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Step Definition will look like this, focus on the highlighted code:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 步骤定义将看起来像这样，请关注高亮代码：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The following are some types of regular expressions available in Cucumber:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在Cucumber中可用的正则表达式类型：
- en: '**. Dot** means match any single character.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点号**意味着匹配任何单个字符。'
- en: '*** Star**, a repetition modifier, takes a character and tells us how many
    times it can reappear.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***星号***，一个重复修饰符，告诉我们可以重复多少次。'
- en: '**+ Plus**, a repetition modifier, takes a character and tells us that the
    character can be repeated at least once.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加号**，一个重复修饰符，告诉我们可以至少重复一次。'
- en: '**\d** stands for diGitHub, or [0-9].'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**\d** 代表数字GitHub，或 [0-9]。'
- en: '**\w** stands for a word character, specifically [A-Za-z0-9_].'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**\w** 代表单词字符，具体为 [A-Za-z0-9_]。'
- en: '**\s** stands for a whitespace character, including tab space or line break.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**\s** 代表空白字符，包括制表符或换行符。'
- en: Note
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also negate shorthand character classes by capitalizing them; for example,
    `\D` refers to any character except a diGitHub.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您也可以通过大写来否定简写字符类；例如，`\D` 指的是除了数字GitHub之外的任何字符。
- en: Using Optional Capture and Noncapture Groups
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用可选捕获和非捕获组
- en: Until now, we have covered how to write Step Definitions for various keywords
    in Feature files. Now let's talk about how we can efficiently use Step Definitions
    for multiple Steps.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何在特性文件中为各种关键字编写步骤定义。现在让我们谈谈如何有效地使用步骤定义来处理多个步骤。
- en: Think about a situation where we are testing a positive situation in one Step
    and a negative situation in some other Step—the only difference in both Steps
    is just the word "No", while the remaining sentence is same. Based on the knowledge
    that we have acquired so far, we will write two Step Definitions for these two
    Steps. But is there a better way of doing this? Let's see how we can do this better
    in this recipe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，我们在一个步骤中测试一个积极的情况，而在另一个步骤中测试一个消极的情况——这两个步骤之间的唯一区别只是“No”这个词，而其余句子是相同的。根据我们迄今为止所学的知识，我们将为这两个步骤编写两个步骤定义。但有没有更好的方法来做这件事？让我们看看在这个配方中我们如何做得更好。
- en: How to do it…
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For this recipe, consider the following Scenarios and focus on the highlighted
    text:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个配方，考虑以下场景并关注高亮文本：
- en: '[PRE14]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Use the following Step Definitions for both Scenarios and focus on the code
    that is highlighted:'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下步骤定义来处理两个场景，并关注突出显示的代码：
- en: '[PRE15]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now run the Scenarios; you will see the following output:![How to do it…](img/image00128.jpeg)
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行场景；你会看到以下输出：![如何做…](img/image00128.jpeg)
- en: How it works…
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'An Optional Capture group eliminates the duplication of Step Definitions and
    can definitely improve the readability of Feature files. Using optional groups,
    the same Step Definitions can be used for both positive and negative assertions.
    Let''s discuss this in more detail:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可选捕获组消除了步骤定义的重复，并且肯定可以改善特性文件的可读性。使用可选组，相同的步骤定义可以用于肯定和否定断言。让我们更详细地讨论这个问题：
- en: 'Optional Capture group/alternation:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选捕获组/交替：
- en: The use of a pipe between parentheses creates an optional group (`Text1|Text
    2`). Here, more than two options can also be grouped. In this example, Steps with
    either `Text1` or `Text2` will be accepted by this Step Definitions, and accordingly,
    `Text1` or `Text2` will be passed as the Capture value.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在括号中使用管道创建了一个可选组（`Text1|Text 2`）。在这里，也可以将多个选项分组。在这个例子中，这个步骤定义将接受`Text1`或`Text2`，相应地，`Text1`或`Text2`将被作为捕获值传递。
- en: 'Optional Noncapture group:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选非捕获组：
- en: The addition of `?:` to the beginning of Optional Capture groups creates optional
    non-Capture groups. Having `?:` will treat the group as optional , but it will
    not be captured. So, you do not need to pass an argument as described earlier
    with optional captured groups.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在可选捕获组的开头添加`?:`创建可选非捕获组。有`?:`会将该组视为可选的，但它不会被捕获。因此，你不需要像之前描述的可选捕获组那样传递一个参数。
- en: Transforming Data Tables to parse the test data
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据表转换为解析测试数据
- en: In the previous chapter, we covered how Data Tables can be used to send large
    sets of data to a single Step. Now let's understand how to handle Data Tables
    in Step Definitions in this recipe.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何使用数据表将大量数据发送到单个步骤。现在让我们了解如何在步骤定义中处理数据表。
- en: How to do it…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s assume we are writing Step Definitions for the following Scenario:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们正在编写以下场景的步骤定义：
- en: '[PRE16]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now run the Feature file, and copy paste the Cucumber Step Definitions suggestions
    in the `LoginSteps.java` class. These are the additional Steps in `LoginSteps.java`:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行特性文件，并将Cucumber步骤定义建议复制粘贴到`LoginSteps.java`类中。这些是`LoginSteps.java`中的附加步骤：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, Cucumber passed the table as `DataTable` to the Step argument. Focus on
    the suggestion given by Cucumber to convert the table to a List or a List of Lists
    and so on.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，Cucumber将表格作为`DataTable`传递给步骤参数。关注Cucumber给出的将表格转换为列表或列表的列表的建议。
- en: 'Now, replace the code suggestion given by Cucumber with the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，用以下代码替换Cucumber给出的代码建议：
- en: '[PRE18]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, we have used the `raw()` method of the Cucumber DataTable API to convert
    the Data Table into a List of List of Strings. After that, we have used two `for`
    loops to traverse all the elements of the List of List of Strings. This is how
    the Cucumber output looks:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用了Cucumber DataTable API的`raw()`方法将数据表转换为字符串的列表的列表。之后，我们使用了两个`for`循环来遍历列表的列表的所有元素。这就是Cucumber输出的样子：
- en: '![How to do it…](img/image00129.jpeg)'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/image00129.jpeg)'
- en: How it works…
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Data Tables are passed to the Step Definitions as the last argument. We need
    to import `cucumber.api.DataTable` into Java code. DataTable API's `raw()` method
    is used to convert a Data Table to a List of List of String.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 数据表作为最后一个参数传递给步骤定义。我们需要将`cucumber.api.DataTable`导入Java代码中。DataTable API的`raw()`方法用于将数据表转换为字符串的列表的列表。
- en: 'We can also convert a Data Table to various types of Lists. Let''s see what
    we can do:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将数据表转换为各种类型的列表。让我们看看我们能做什么：
- en: '**A List of user-defined variables**:'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户定义变量的列表**：'
- en: 'Let''s define a custom class called `User`, which has name and email as data
    members. The header row is used to name fields in a generic List type:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们定义一个名为`User`的自定义类，它具有名称和电子邮件作为数据成员。标题行用于在通用列表类型中命名字段：
- en: '[PRE19]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, its Step Definitions can be like this:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，它的步骤定义可以是这样的：
- en: '[PRE20]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This Step Definitions will accept a List with objects as users (which is custom
    defined by us) and will print the names of users.
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些步骤定义将接受一个包含用户对象（这是我们自定义的）的列表，并将打印出用户的名字。
- en: '**A List of maps**:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**映射的列表**：'
- en: 'Using the `User` class defined in the previous Step, the Step Definitions can
    be like this:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用在上一步骤中定义的`User`类，步骤定义可以是这样的：
- en: '[PRE21]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The Data Table is converted to the following List of maps:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据表被转换为以下地图列表：
- en: '[PRE22]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you're converting a Data Table into a map, it is usually advisable not to
    have a top row naming the columns in the Gherkin table.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你将数据表转换为地图，通常建议不要在Gherkin表中有一个顶部行来命名列。
- en: '**List of List** **of scalar:**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标量列表** **列表：**'
- en: 'Using the `User` class defined in the previous Step, the Step Definitions can
    be presented as follows:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用在前面步骤中定义的`User`类，步骤定义可以表示如下：
- en: '[PRE23]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The Data Table is converted to the following Lists:'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据表被转换为以下列表：
- en: '[PRE24]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Implementing data table diffs to compare tables
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现数据表差异以比较表格
- en: Consider a situation where you need to verify an application response that is
    in the form of Table to another Data Table that we are sending in Feature file.
    This kind of verification is very common when we are testing REST services.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一种情况，你需要验证一个以表格形式存在的应用程序响应，这与我们在特征文件中发送的另一个数据表进行比较。当我们测试REST服务时，这种验证非常常见。
- en: Based on what we have learned so far, we will break the Data Table down in the
    Feature file into a List of Lists, and then we will verify each element of those
    Lists with expected Lists (which we got after breaking the table). Let's understand
    how we can do this in an easier way.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们迄今为止所学的内容，我们将特征文件中的数据表分解为列表的列表，然后我们将验证这些列表的每个元素与预期的列表（在分解表后获得）进行验证。让我们了解我们如何以更简单的方式做到这一点。
- en: How to do it…
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'For this recipe, consider the following Scenario:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个食谱，考虑以下场景：
- en: '[PRE25]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now save the Feature file. After adding the following code to suggestions,
    this is how our Step Definitions will look:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存特征文件。在添加以下代码到建议后，我们的步骤定义将看起来像这样：
- en: '[PRE26]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works…
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: We can compare a table argument (the actual result) to another table that we
    provide within the Step Definitions (the expected result).
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将表参数（实际结果）与我们提供的另一个表（预期结果）进行比较。
- en: Both the tables should be in a certain format for it to work properly. Both
    tables should be column-oriented, and the first row of both tables should represent
    the column names. The column names must be unique for each column and they must
    match.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正常工作，两个表都应该以某种格式存在。两个表都应该以列为导向，两个表的第一行应该表示列名。列名必须对每个列是唯一的，并且它们必须匹配。
- en: 'If the tables are different, an exception is thrown, and the difference between
    the two tables is reported in the execution report. Its output will look like
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表不同，将抛出异常，并在执行报告中报告两个表之间的差异。其输出将如下所示：
- en: '![How it works…](img/image00130.jpeg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作…](img/image00130.jpeg)'
- en: Rows that differ from what was expected will be printed twice—the first (preceded
    by a "`-`") is what was expected, followed by another (preceded by a "`+`"), which
    is what was actually returned.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 与预期不同的行将被打印两次——第一个（由一个"`-`"前缀）是预期的，后面跟着另一个（由一个"`+`"前缀），这是实际返回的。
- en: Using Doc Strings to parse big data as one chunk
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用文档字符串将大数据解析为一个块
- en: Now let's consider a situation where we have to specify a lot of text in multiple
    lines (not in the shape of a table)—something like a few lines from a blog or
    a book. So, how do we handle this in Step Definitions? This is called passing
    Doc Strings in test Steps. Based on what we have covered until now, we can use
    regular expressions; but this is helpful for the first line only, and the text
    in all the other lines will be missed. In this recipe, let's see how to handle
    this situation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑一种情况，其中我们需要在多行中指定大量文本（不是表格形状）——类似于博客或书籍的几行。那么，我们在步骤定义中如何处理这种情况？这被称为在测试步骤中传递文档字符串。根据我们迄今为止所涵盖的内容，我们可以使用正则表达式；但这仅对第一行有帮助，而其他所有行的文本都将被忽略。在这个食谱中，让我们看看如何处理这种情况。
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s consider the following Step in our Feature file for this exercise:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们考虑以下用于此练习的特征文件中的步骤：
- en: '[PRE27]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Here, the highlighted text is the Doc String that we will be passing to the
    Step Definitions.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，高亮显示的文本是我们将传递给步骤定义的文档字符串。
- en: 'Save and run the Feature file, and copy and paste the Cucumber suggestion for
    the missing Step Definitions. After adding the print statements, this is how our
    code will look:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并运行特征文件，然后复制并粘贴缺失步骤定义的Cucumber建议。在添加打印语句后，我们的代码将看起来像这样：
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is the output of the preceding code:![How to do it…](img/image00131.jpeg)
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是前面代码的输出：![如何做到这一点…](img/image00131.jpeg)
- en: How it works…
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When writing Feature files, Doc Strings should be within three adjacent quotes
    `"""` at the beginning and three at the end.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写特性文件时，文档字符串应位于开头和结尾的三相邻引号 `"""` 内。
- en: In Step Definitions, you don't have to do anything special for Doc Strings,
    as the text within triple quotes (`"""`) will be passed as the last argument to
    the Step Definitions. In our code, we have also used one regular expression for
    the text `Cucumber Cookbook`, but not for the Doc String as the Doc String was
    passed to the last argument of the Step.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤定义中，你不需要对文档字符串做任何特殊处理，因为三引号内的文本将作为步骤定义的最后一个参数传递。在我们的代码中，我们也使用了一个正则表达式来处理文本
    `Cucumber Cookbook`，但没有对文档字符串进行处理，因为文档字符串已经传递给了步骤的最后一个参数。
- en: Tip
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Indentation of the opening """ is unimportant, although common practice is to
    put it two spaces in from the enclosing Step. Each line of the String passed in
    the Doc String will be realigned to the indentation of the opening """.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 开头 """ 的缩进不重要，尽管常见的做法是将它缩进两个空格从封装步骤。传递给文档字符串的字符串的每一行都将重新对齐到开头 """ 的缩进。
- en: Combining Doc Strings and Scenario Outlines
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合文档字符串和场景概述
- en: Now think of a situation where you are passing a Doc String but you have to
    combine that with a Scenario Outline. How does Cucumber behave in such a situation?
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一个情况，当你传递一个文档字符串时，但你必须将其与场景概述结合起来。在这种情况下，Cucumber 的行为是怎样的？
- en: Let's think of a situation where we are specifying the requirements for the
    content of an e-mail, but the content is based on the role from which the e-mail
    is sent. So how do we specify such a requirement in a Feature file and how do
    we write the Step Definitions for it? Let's find out in this recipe.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个情况，我们正在指定电子邮件内容的规范，但内容基于发送电子邮件的角色。那么我们如何在特性文件中指定这样的要求，以及我们如何为它编写步骤定义？让我们在这个食谱中找出答案。
- en: How to do it…
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'For this recipe, let''s consider this Scenario:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个食谱，让我们考虑这个场景：
- en: '[PRE29]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now run the Feature file; copy the Step Definitions suggestion given by Cucumber
    and replace it with the following Step Definitions:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行特性文件；复制 Cucumber 提供的步骤定义建议，并将其替换为以下步骤定义：
- en: '[PRE30]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When you run the Scenario, this is the output for the data substitution of Row
    1:![How to do it…](img/image00132.jpeg)
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行场景时，这是第 1 行数据替换的输出：![如何做…](img/image00132.jpeg)
- en: 'And this is the output for the data substitution of Row 2:'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是第 2 行数据替换的输出：
- en: '![How to do it…](img/image00133.jpeg)'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做…](img/image00133.jpeg)'
- en: How it works…
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In the preceding section, you learned how two basic concepts can be combined
    to come up with a solution for a complex problem. Two concepts that we used here
    are Doc Strings and Scenario Outline. Let''s see how they work:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你学习了如何将两个基本概念结合起来，以解决复杂问题的解决方案。我们在这里使用的两个概念是文档字符串和场景概述。让我们看看它们是如何工作的：
- en: If you look closely, the highlighted text which is within `<>` in the `Then`
    Step of the Scenario Outline in Step 1 is the same as the text in the example
    table header row. (The text has been highlighted in Step 1). So, we are telling
    Cucumber that this text is just a placeholder, and during execution, its value
    will come from the example table.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细看，在步骤 1 的场景概述的“Then”步骤中用 `<>` 高亮的文本与示例表标题行的文本相同。（文本已在步骤 1 中高亮）。因此，我们正在告诉
    Cucumber，这个文本只是一个占位符，在执行过程中，它的值将来自示例表。
- en: As we have seen in the preceding recipe, we don't have to do anything special
    for Doc Strings in Step Definitions—they are automatically passed as the last
    argument. So we did not have to do anything special in Step 2.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个食谱所示，在步骤定义中我们不需要对文档字符串做任何特殊处理——它们将自动作为最后一个参数传递。因此，在步骤 2 中我们不需要做任何特殊处理。
- en: 'Now in Step 3, you can see in the output of the first execution: the values
    of `<Role>` and `<details>` are replaced with the data from Data Row 1 of the
    example table, and in the second execution, the values are replaced with data
    from Data Row 2 of the example table.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在步骤 3 中，你可以在第一次执行的输出中看到：`<Role>` 和 `<details>` 的值被替换为示例表数据行 1 的数据，在第二次执行中，值被替换为示例表数据行
    2 的数据。
- en: Defining String transformations for better conversions
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义字符串转换以实现更好的转换
- en: Think about a Scenario where you want to convert some Strings in test Steps
    to some specific Strings in your code. For example, the PO has mentioned "29-12-1986"
    in a Step and you want Cucumber to understand this text as a date. Further, in
    some countries this could be in the DD-MM-YYYY format, while in others, it could
    be in the MM-DD-YYYY format. So how do we standardize this conversion? Let's find
    out how we can do this in Cucumber.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你希望在测试步骤中将一些字符串转换为代码中的特定字符串。例如，产品负责人在一个步骤中提到了 "29-12-1986"，而你希望Cucumber将这段文本识别为日期。此外，在一些国家，这可能采用
    DD-MM-YYYY 格式，而在其他国家，它可能采用 MM-DD-YYYY 格式。那么我们如何标准化这种转换呢？让我们看看如何在Cucumber中实现这一点。
- en: Getting ready
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Consider the following test Step for this problem:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下测试步骤来解决这个问题：
- en: '[PRE31]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we can use the `@Format` String transformer to convert text to date.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 `@Format` 字符串转换器将文本转换为日期。
- en: How to do it…
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Import `java.util.Date` into your Step Definitions file. This is how our Step
    Definitions will look:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `java.util.Date` 导入到你的步骤定义文件中。这样我们的步骤定义将看起来像这样：
- en: '[PRE32]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is the output that appears after running the preceding Step:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这是运行前面的步骤后出现的输出：
- en: '![How to do it…](img/image00134.jpeg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![如何做…](img/image00134.jpeg)'
- en: How it works…
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Cucumber-JVM allows converting Strings into various scalar types. A scalar type
    is a type that can be derived from a single String value. Some of Cucumber-JVM's
    built-in scalar types are `numbers`, `enums`, `java.util.Date`, `java.util.Calendar`,
    and so on. Transformation to `java.util.Date` and `java.util.Calendar` will work
    out-of-the-box as long as the String value matches one of the Short, Medium, Full,
    or Long formats defined by `java.util.DateFormat`.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber-JVM允许将字符串转换为各种标量类型。标量类型是从单个字符串值派生出来的类型。Cucumber-JVM的一些内置标量类型包括 `numbers`、`enums`、`java.util.Date`、`java.util.Calendar`
    等。只要字符串值与 `java.util.DateFormat` 定义的 Short、Medium、Full 或 Long 格式之一匹配，转换为 `java.util.Date`
    和 `java.util.Calendar` 将会自动完成。
- en: '`29-12-1986` from our example doesn''t match any of those formats, so we have
    to give Cucumber a hint by using `@Format`. We need to specify two things: First
    is the Format and second is the Data Type.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们示例中的 "29-12-1986" 与这些格式中的任何一个都不匹配，因此我们必须通过使用 `@Format` 给Cucumber一个提示。我们需要指定两件事：首先是格式，其次是数据类型。
- en: We can also write custom formatters if the formatting is not available in Cucumber-JVM
    by default. Further, we can even use String transformation for in cases other
    than date transformations.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Cucumber-JVM默认没有提供格式化，我们也可以编写自定义格式化程序。此外，我们甚至可以使用字符串转换来处理日期转换以外的其他情况。
