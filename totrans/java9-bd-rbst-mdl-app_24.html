<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Sunago - An Android Port</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In the last chapter, we built Sunago, a social media aggregation application. In that chapter, we learned that Sunago is a JavaFX-based application that can pull posts, tweets, photos, and so on from a variety of social media networks and display them in one place. The application certainly provided a number of interesting architectural and technical examples, but the application itself could be more practical--we tend to interact with social networks from mobile devices such as phones and tablets, so a mobile version would be much more useful. In this chapter, then, we'll write an Android port, reusing as much of the code as possible.</p>
<p class="mce-root">Android applications, while built in Java, look quite a bit different than, say, a desktop application. While we can't cover every aspect of Android development, we'll cover enough in this chapter to get you started, including the following:</p>
<ul class="calibre13">
<li class="calibre14">Setting up an Android development environment</li>
<li class="calibre14">Gradle builds</li>
<li class="calibre14">Android views</li>
<li class="calibre14">Android state management</li>
<li class="calibre14">Android services</li>
<li class="calibre14">Application packaging and deployment</li>
</ul>
<p class="mce-root">Like the other chapters, there will be too many small items to call out each of them, but we'll do our best to highlight the new ones as they're introduced.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The first step is to get the Android development environment set up. As with <em class="calibre20">regular</em> Java development, an IDE isn't strictly necessary, but it sure helps, so we'll install Android Studio, which is an IDE based on IntelliJ IDEA. If you already have IDEA installed, you can just install the Android plugin and have everything you need. For our purposes here, though, we'll assume you don't have either installed.</p>
<ol class="calibre18">
<li class="chapter">To download Android Studio, go to <a href="https://developer.android.com/studio/index.html" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://developer.android.com/studio/index.html</span></a>, and download the package appropriate for your operating system. When you start <span class="calibre5">Android Studio</span> for the first time, you should see following screen:</li>
</ol>
<div class="mce-root1"><img class="image-border27" src="Images/bb251238-ca83-4873-92c6-9692d0bbf9d3.png"/></div>
<ol start="2" class="calibre18">
<li class="chapter">Before we start a new project, let's configure the Android SDKs that are available. Click on the <span class="calibre5">Configure</span> menu in the bottom-right corner, then click on <span class="calibre5">SDK Manager</span> to get this screen:</li>
</ol>
<div class="mce-root1"><img class="image-border28" src="Images/18c33ace-5bd0-4b12-8f68-2f5ac6998249.png"/></div>
<p class="calibre26">Which SDKs you select will vary depending on your needs. You may need to support older devices as far back as, say, Android 5.0, or maybe you just want to support the very latest with Android 7.0 or 7.1.1.</p>
<ol start="3" class="calibre18">
<li class="chapter">Once you know what need, select the appropriate SDKs (or do as I've done in the preceding screenshot and select everything from 5.0 and forward), then click on <span class="calibre5">OK</span>. You will need to read and accept the license before continuing.</li>
<li class="chapter">Once you've done that, Android Studio will begin downloading the selected SDKs and any dependencies. This process can take a while, so be patient.</li>
<li class="chapter">When the SDK installation completes, click on the <span class="calibre5">Finish</span> button, which will take you take to the Welcome screen. Click on <span class="calibre5">Start a new Android Studio</span> project to get the following screen:</li>
</ol>
<div class="mce-root1"><img class="image-border29" src="Images/cd5761d5-190d-4fe2-bd36-011efcda44cf.png"/></div>
<ol start="6" class="calibre18">
<li class="chapter">Nothing exciting here--we need to specify the <span class="calibre5">Application name</span>, <span class="calibre5">Company domain</span>, and <span class="calibre5">Project location</span> of our app:</li>
</ol>
<div class="mce-root1"><img class="image-border30" src="Images/229a595d-c0bb-4f38-a568-dd1f24cfc34a.png"/></div>
<ol start="7" class="calibre18">
<li class="chapter">Next, though, we need to specify the form factor for our app. Our options are Phone and Tablet, Wear, TV, Android Auto, and Glass. As seen in this preceding screenshot, all we're interested in for this application is <span class="calibre5">Phone and Tablet</span>.</li>
<li class="chapter">On the next window, we need to select a type for the main <kbd class="calibre16">Activity</kbd> for the application. In an Android application, what we might refer to as a <em class="calibre22">screen</em> (or maybe <em class="calibre22">page</em>, if you're coming from a web application background) is known as an <kbd class="calibre16">Activity</kbd>. Not every <kbd class="calibre16">Activity</kbd> is a screen, though.</li>
</ol>
<p class="calibre26">From the Android developer documentation (<a href="https://developer.android.com/reference/android/app/Activity.html" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">https://developer.android.com/reference/android/app/Activity.html</span></a>), we learn the following:</p>
<div class="mce-root5">[a]n activity is a single, focused thing that the user can do. Almost all activities interact with the user, so the Activity class takes care of creating a window for you...</div>
<p class="calibre26">For our purposes, it's probably acceptable to equate the two, but do so loosely, and always with this caveat in mind. The wizard gives us many options, as seen in this screenshot:</p>
<div class="mce-root1"><img class="image-border31" src="Images/2b059d9a-c5c1-4858-bb20-f2dd347de3e8.png" width="1334" height="879"/></div>
<ol start="9" class="calibre18">
<li class="chapter">As you can see, there are several options: <span class="calibre5">Basic</span>, <span class="calibre5">Empty</span>, <span class="calibre5">Fullscreen</span>, <span class="calibre5">Google AdMobs Ads</span>, <span class="calibre5">Google Maps</span>, <span class="calibre5">Login</span>, and so on. Which to choose depends, again, on what your requirements are for the application. Our bare minimum requirements, in terms of user interface, are that it tells the user the name of the app, shows the list of social media items, and provides a menu for changing the application settings. From the preceding list, then, the <span class="calibre5">Basic Activity</span> is the closest match, so we select that, and click on <span class="calibre5">Next</span>:</li>
</ol>
<div class="mce-root1"><img class="image-border32" src="Images/358b4235-4f1f-4aa9-b4f1-d7aa2177ca1d.png" width="860" height="879"/></div>
<ol start="10" class="calibre18">
<li class="chapter">The defaults in the preceding screen are mostly acceptable (notice that <span class="calibre5">Activity Name</span> was changed), but before we click on <span class="calibre5">Finish</span>, there are a few final words. When building an Android application of any size, you are going to have a lot of layouts, menus, activities, and so on. I have found it helpful to name these artifacts as you see here--the layout for an <kbd class="calibre16">Activity</kbd> is named <kbd class="calibre16">activity_</kbd> plus the <kbd class="calibre16">Activity</kbd> name; menus are <kbd class="calibre16">menu_</kbd> plus the activity name, or, for shared menus, a meaningful summary of its contents. Each artifact type is prefixed by its type. This general pattern will help you quickly navigate to the source file as the number of files grows, as the arrangement of these files is very flat and shallow.</li>
<li class="chapter">
<p class="calibre15">Finally, notice the <span class="calibre7">Use a Fragment</span> checkbox. <em class="calibre20">A Fragment is a piece of an application's user interface or behavior that can be placed in an Activity</em>. It is, effectively, a way for you, as the developer, to decompose the user interface definition into multiple pieces (or Fragments, thus, the name) that can be composed into a whole in an Activity in different ways depending on the current context of the application. For example, a Fragment-based user interface might have two screens for certain operations on a phone, but might combine those into one Activity for the larger screen on a tablet. It's a bit more complicated than that, of course, but I include that brief and incomplete description simply to give some explanation of the checkbox. We will not be using Fragments in our application, so we leave that unchecked, and click on <span class="calibre7">Finish</span>.</p>
</li>
</ol>
<p class="calibre26">After processing for some time, Android Studio now creates a basic application for us. Before we start coding the application, let's run it to see what that process looks like. We can run the app in a few ways--we can click on <span class="calibre7">Run</span> | <span class="calibre7">Run 'app'</span>; click on the green play button in the middle of the toolbar, or press <em class="calibre20">Shift</em> + <em class="calibre20">F10</em>. All three will bring up the same <span class="calibre7">Select Deployment Target</span> window, as follows:</p>
<div class="mce-root1"><img class="image-border33" src="Images/65afc6c3-7424-45da-893a-149e8432bd43.png" width="626" height="514"/></div>
<p class="mce-root">Since we just installed Android Studio, we don't have any emulators created, so we need to do that now. To create the emulators, follow these steps:</p>
<ol class="calibre18">
<li class="chapter">Clicking on the <span class="calibre5">Create New Virtual Device</span> button gets us this screen:</li>
</ol>
<div class="mce-root1"><img class="image-border34" src="Images/991eef13-641b-4b37-9aa2-a42d7e07d228.png"/></div>
<ol start="2" class="calibre18">
<li class="chapter">Let's start with a reasonably modern Android phone--select the <span class="calibre5">Nexus 6</span> profile, and click on <span class="calibre5">Next</span>:</li>
</ol>
<div class="mce-root1"><img class="image-border34" src="Images/ec1aaa2f-95e5-4292-a5a4-58dcdc39098e.png"/></div>
<p class="calibre26">In the preceding screen, your options will vary based on which SDKs you've installed. Which SDK you choose, again, depends on your target audience, application needs, and so on. As enjoyable as it always is to use the latest and greatest, we don't strictly need any APIs from, say, <span class="calibre7">Nougat</span>. Choosing Android 7.x would restrict the availability of Sunago to those on very new phones, and do so for no good reason. We will, then, target <span class="calibre7">Lollipop</span> (<span class="calibre7">Android 5.0</span>), which strikes a good balance between supporting as many users as possible and providing access to newer Android features.</p>
<ol start="3" class="calibre18">
<li class="chapter">Click the <span class="calibre5">Download</span> link if necessary for the <span class="calibre5">x86_64</span> ABI, select that release, click on <span class="calibre5">Next</span>, and then click on <span class="calibre5">Finish</span> on the <span class="calibre5">Verify Configuration</span> screen.</li>
</ol>
<ol start="4" class="calibre18">
<li class="chapter">With an emulator created, we can now select it in the <span class="calibre5">Select Deployment Target</span> screen, and run the application by clicking on <span class="calibre5">OK</span>. If you want to skip the selection screen the next time you run the application, you can check the <span class="calibre5">Use same selection for future launches</span> checkbox before clicking on <span class="calibre5">OK</span>.</li>
</ol>
<p class="calibre26">The first time the application is run, it will take a bit longer, as the application is built and packaged and the emulator started. After a few moments, you should see the following screen:</p>
<div class="mce-root1"><img class="image-border35" src="Images/05f25cda-b28e-407e-9332-7e2d74f8d644.png" width="512" height="859"/></div>
<p class="mce-root">It's nothing special, but it shows that everything is working as expected. Now, we're ready to start the real work in porting Sunago.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Put simply, Android user interfaces are based on Activities, which use layout files to describe the structure of the user interface. There's more to it, of course, but this simple definition should be sufficient for our work on Sunago. Let's start, then, by looking at our <kbd class="calibre16">Activity</kbd>, <kbd class="calibre16">MainActivity</kbd>, which is as follows:</p>
<pre class="calibre21">    public class MainActivity extends AppCompatActivity { 
      @Override 
      protected void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.activity_main); 
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); 
        setSupportActionBar(toolbar); 
 
        FloatingActionButton fab =
            (FloatingActionButton) findViewById(R.id.fab); 
        fab.setOnClickListener(new View.OnClickListener() { 
            @Override 
            public void onClick(View view) { 
                Snackbar.make(view,
                        "Replace with your own action",
                        Snackbar.LENGTH_LONG) 
                    .setAction("Action", null).show(); 
            } 
        }); 
      } 
 
     @Override 
     public boolean onCreateOptionsMenu(Menu menu) { 
        getMenuInflater().inflate(R.menu.menu_main, menu); 
        return true; 
     } 
  
     @Override 
     public boolean onOptionsItemSelected(MenuItem item) { 
        int id = item.getItemId(); 
 
        if (id == R.id.action_settings) { 
            return true; 
        } 
 
        return super.onOptionsItemSelected(item); 
      } 
    } </pre>
<p class="mce-root">This last bit of code is the class exactly as it was generated by Android Studio. It's very basic, but it has most of what you need to create an <kbd class="calibre16">Activity</kbd>. Note that the class extends <kbd class="calibre16">AppCompatActivity</kbd>. While Google has been very active in pushing the Android platform, they have also worked tirelessly to make sure that older devices aren't left behind any sooner than they have to be. To achieve that, Google has backported many new features in "compat" (or compatibility) packages, which means many of the newer APIs will actually run on older versions of Android. The changes, though, since they are in separate packages, won't break any existing functionality--they must be explicitly opted for, which is what we're doing here. While we're not planning on supporting older versions of Android, such as KitKat, it is still suggested that your <kbd class="calibre16">Activity</kbd> classes extend the compatibility classes, like this one, as there is a significant number of features built in to these classes that we would otherwise have to implement ourselves. Let's walk through this class to get a sense of what all is going on in the following steps:</p>
<ol class="calibre18">
<li class="chapter">The first method is <kbd class="calibre16">onCreate()</kbd>, which is an <kbd class="calibre16">Activity</kbd> life cycle method (we'll talk more about Activity life cycle in a moment). When the system creates the <kbd class="calibre16">Activity</kbd> class, this method is called. It is here that we initialize the user interface, setting values, connection controls to data sources, and so on. Note that the method takes a <strong class="calibre3">Bundle</strong>. This is how Android passes in the Activity state so that it may be restored.</li>
</ol>
<p class="calibre26">In the <kbd class="calibre16">setContentView(R.layout.activity_main)</kbd> method, we tell the system what layout we want to use for this <kbd class="calibre16">Activity</kbd>. Once we've set the content <kbd class="calibre16">View</kbd> for <kbd class="calibre16">Activity</kbd>, we can then start acquiring references to various elements. Notice that we first look for the <kbd class="calibre16">Toolbar</kbd> defined in the view, <kbd class="calibre16">findViewById(R.id.toolbar)</kbd>, then we tell Android to use that as our action bar via <kbd class="calibre16">setSupportActionBar()</kbd>. This is an example of a functionality that is implemented for us via the <kbd class="calibre16">compat</kbd> class. If we extended, say, <kbd class="calibre16">Activity</kbd> directly, we would be required to do much more work to make the action bar work. As it is, we call one setter and we're done.</p>
<ol start="2" class="calibre18">
<li class="chapter">Next, we look up another user interface element, the <kbd class="calibre16">FloatingActionButton</kbd>. In the preceding screenshot, this is the button in the lower-right corner with the email icon. We will actually be removing this, but, since Android Studio generated it, we can learn what we can from it before it is removed. Once we have a reference to it, we can attach listeners. In this case, we're adding an <kbd class="calibre16">on Click</kbd> listener by creating an anonymous inner class of type <kbd class="calibre16">View.OnClickListener</kbd>. This works, but we've just spent the last five chapters getting rid of those.</li>
</ol>
<ol start="3" class="calibre18">
<li class="chapter">The Android build system now natively supports using Java 8, so we can modify the <kbd class="calibre16">onClick</kbd> listener registration to look like this:</li>
</ol>
<pre class="calibre21">    fab.setOnClickListener(view -&gt; Snackbar.make(view,
        "Replace with your own action",
            Snackbar.LENGTH_LONG) 
        .setAction("Action", null).show()); </pre>
<p class="calibre26">When the user taps the button, the Snackbar appears. According to the Google documentation, <em class="calibre20">Snackbars provide brief feedback about an operation through a message at the bottom of the screen</em>. And that's exactly what we get--a message telling us to replace the <kbd class="calibre16">onClick</kbd> result with our own action. As stated earlier, though, we don't need the floating button, so we'll remove this method and, later, the view definition from the layout.</p>
<ol start="4" class="calibre18">
<li class="chapter">The next method in the class is <kbd class="calibre16">onCreateOptionsMenu()</kbd>. This method is called when the options menu is first opened to populate the list of items. We use <kbd class="calibre16">MenuInflater</kbd> to inflate the menu definition file, and add what it defined there to <kbd class="calibre16">Menu</kbd> that the system passes in. This method is called only once, though, so if you need a menu that changes, you should override <kbd class="calibre16">onPrepareOptionsMenu(Menu)</kbd>.</li>
<li class="chapter">The final method, <kbd class="calibre16">onOptionsItemSelected()</kbd>, is called when the user taps an options menu item. The specific <kbd class="calibre16">MenuItem</kbd> selected is passed in. We get its ID, and call the method appropriate for the menu item.</li>
</ol>
<p class="calibre26">That's a basic <kbd class="calibre16">Activity</kbd>, but what does a layout look like? Here are the contents of <kbd class="calibre16">activity_main.xml</kbd>:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="utf-8"?&gt; 
     &lt;android.support.design.widget.CoordinatorLayout  
       
       
       
      android:layout_width="match_parent" 
      android:layout_height="match_parent" 
      android:fitsSystemWindows="true" 
      tools:context="com.steeplesoft.sunago.MainActivity"&gt; 
 
      &lt;android.support.design.widget.AppBarLayout 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:theme="@style/AppTheme.AppBarOverlay"&gt; 
 
       &lt;android.support.v7.widget.Toolbar 
            android:id="@+id/toolbar" 
            android:layout_width="match_parent" 
            android:layout_height="?attr/actionBarSize" 
            android:background="?attr/colorPrimary" 
            app:popupTheme="@style/AppTheme.PopupOverlay" /&gt; 
 
      &lt;/android.support.design.widget.AppBarLayout&gt; 
 
      &lt;include layout="@layout/content_main" /&gt; 
 
     &lt;android.support.design.widget.FloatingActionButton 
        android:id="@+id/fab" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_gravity="bottom|end" 
        android:layout_margin="@dimen/fab_margin" 
        app:srcCompat="@android:drawable/ic_dialog_email" /&gt; 
 
     &lt;/android.support.design.widget.CoordinatorLayout&gt; </pre>
<p class="mce-root">That's a fair bit of XML, so let's walk through the major items of interest quickly, as follows:</p>
<ol class="calibre18">
<li class="chapter">The root element is <kbd class="calibre16">CoordinatorLayout</kbd>. Its Java document describes it as a super-powered <kbd class="calibre16">FrameLayout</kbd>. One of its intended purposes is as <em class="calibre22">a top-level application decor or chrome layout</em>, which is exactly what we're using it for here. Layouts such as <kbd class="calibre16">CoordinatorLayout</kbd> are roughly analogous to JavaFX's containers. Different layouts (or <kbd class="calibre16">ViewGroup</kbd>) provide a variety of capabilities such as laying out elements with exact X/Y coordinates (<kbd class="calibre16">AbsoluteLayout</kbd>), in a grid (<kbd class="calibre16">GridLayout</kbd>), relative to each other (<kbd class="calibre16">RelativeLayout</kbd>), and so on.</li>
<li class="chapter">In addition to providing our top-level container, the element defines a number of required XML namespaces. It also sets the height and width for the control. There are three possible values for this field--<kbd class="calibre16">match_parent</kbd> (in earlier versions of the SDK, this was called <kbd class="calibre16">fill_parent</kbd> should you ever come across that), which means that the control should match the value of its parent, <kbd class="calibre16">wrap_content</kbd>, which means the control should be just big enough for its contents; or an exact number.</li>
</ol>
<ol start="3" class="calibre18">
<li class="chapter">The next element is <kbd class="calibre16">AppBarLayout</kbd>, which is a <kbd class="calibre16">ViewGroup</kbd> that implements a number of the material designs app bar concepts. <strong class="calibre3">Material design</strong> is the latest <strong class="calibre3">visual language</strong> being developed and supported by Google. It provides a modern, consistent look and feel across Android apps. Its usage is encouraged by Google, and fortunately, the new <kbd class="calibre16">Activity</kbd> wizard has set us up to use it out of the box. The layout's width is set to <kbd class="calibre16">match_parent</kbd> so that it fills the screen, and the width is set to <kbd class="calibre16">wrap_content</kbd> so that's it's just big enough to show its content, which is a single <kbd class="calibre16">Toolbar</kbd>.</li>
</ol>
<ol start="4" class="calibre18">
<li class="chapter">Skipping the <kbd class="calibre16">include</kbd> element for a moment, the last element in the view is <kbd class="calibre16">FloatingActionButton</kbd>. Our only interest here is noting that the widget exists, should the need for one arise in other projects. As we did in the <kbd class="calibre16">Activity</kbd> class though, we need to remove this widget.</li>
<li class="chapter">Finally, there's the <kbd class="calibre16">include</kbd> element. This does what you would think it should--the specified file is included in the layout definition as if its contents were hard coded into the file. This allows us to keep our layout files small, reuse user interface element definitions (which is especially helpful for complex scenarios), and so on.</li>
</ol>
<p class="calibre26">The included file, <kbd class="calibre16">content_main.xml</kbd>, looks like this:</p>
<pre class="calibre21">        &lt;RelativeLayout
           
           
           
          android:id="@+id/content_main" 
          android:layout_width="match_parent" 
          android:layout_height="match_parent" 
          android:paddingBottom="@dimen/activity_vertical_margin" 
          android:paddingLeft="@dimen/activity_horizontal_margin" 
          android:paddingRight="@dimen/activity_horizontal_margin" 
          android:paddingTop="@dimen/activity_vertical_margin" 
          app:layout_behavior="@string/appbar_scrolling_view_behavior" 
          tools:context="com.steeplesoft.sunago.MainActivity" 
          tools:showIn="@layout/activity_main"&gt; 
 
         &lt;TextView 
            android:layout_width="wrap_content" 
            android:layout_height="wrap_content" 
            android:text="Hello World!" /&gt; 
        &lt;/RelativeLayout&gt; </pre>
<p class="mce-root">This preceding view uses <kbd class="calibre16">RelativeLayout</kbd> to wrap its only child, a <kbd class="calibre16">TextView</kbd>. Note that we can set the padding of a control. This controls how much space is <em class="calibre20">inside</em> the control around its children. Think of it like packing a box--inside the box, you may have a fragile ceramic antique, so you pad the box to protect it. You can also set the margin of a control, which is the space <em class="calibre20">outside</em> the control, akin to the personal space around us we are so often fond of.</p>
<p class="mce-root">The <kbd class="calibre16">TextView</kbd>, though, isn't helpful, so we'll remove that, and add what we really need, which is a <kbd class="calibre16">ListView</kbd>, as follows:</p>
<pre class="calibre21">    &lt;ListView 
      android:id="@+id/listView" 
      android:layout_width="match_parent" 
      android:layout_height="match_parent" 
      android:layout_alignParentTop="true" 
      android:layout_alignParentStart="true"/&gt; </pre>
<p class="mce-root"><kbd class="calibre16">ListView</kbd> is a control that shows items in a vertically scrolling list. In terms of user experience, this works pretty much like the <kbd class="calibre16">ListView</kbd> we looked at in JavaFX. How it works, though, is quite different. To see how, we need to make some adjustments to activity's <kbd class="calibre16">onCreate()</kbd> method as follows:</p>
<pre class="calibre21">    protected void onCreate(Bundle savedInstanceState) { 
       super.onCreate(savedInstanceState); 
       setContentView(R.layout.activity_main); 
 
      if (!isNetworkAvailable()) { 
         showErrorDialog( 
            "A valid internet connection can't be established"); 
      } else { 
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); 
        setSupportActionBar(toolbar); 
        findPlugins(); 
 
        adapter = new SunagoCursorAdapter(this, null, 0); 
        final ListView listView = (ListView)
            findViewById(R.id.listView); 
        listView.setAdapter(adapter); 
        listView.setOnItemClickListener( 
                new AdapterView.OnItemClickListener() { 
            @Override 
            public void onItemClick(AdapterView&lt;?&gt; adapterView,
                    View view, int position, long id) { 
                Cursor c = (Cursor)
                    adapterView.getItemAtPosition(position); 
                String url = c.getString(c.getColumnIndex( 
                    SunagoContentProvider.URL)); 
                Intent intent = new Intent(Intent.ACTION_VIEW,
                    Uri.parse(url)); 
                startActivity(intent); 
            } 
         }); 
 
         getLoaderManager().initLoader(0, null, this); 
       } 
    } </pre>
<p class="mce-root">There are several things going on here, which sets us up nicely for discussing data access in Android. Before we get to that in detail, though, a quick overview is in order:</p>
<ol class="calibre18">
<li class="chapter">We check to make sure that the device has a working network connection via <kbd class="calibre16">isNetworkAvailable()</kbd>, which we'll look at later in this chapter.</li>
<li class="chapter">If the connection is available, we configure the user interface, starting with setting the toolbar.</li>
<li class="chapter">Next, we create an instance of <kbd class="calibre16">SunagoCursorAdapter</kbd>, which we'll discuss in detail later. For now, though, just note that an <kbd class="calibre16">Adapter</kbd> is how the <kbd class="calibre16">ListView</kbd> is connected to the data source, and they can be backed by things as varied as an SQL datasource or an <kbd class="calibre16">Array</kbd>.</li>
<li class="chapter">We pass the adapter to <kbd class="calibre16">ListView</kbd>, thus completing this connection via <kbd class="calibre16">ListView.setAdapter()</kbd>. Much like JavaFX's <kbd class="calibre16">Observable</kbd> model property, we'll be able to use this to update the user interface without direct interaction any time the data changes.</li>
<li class="chapter">Next, we set up an <kbd class="calibre16">onClick</kbd> listener for the items in the list. We'll use this to display the item the user taps (or clicks) on in an external browser. In a nutshell, given the <kbd class="calibre16">position</kbd> parameter, we get the item at that position, a <kbd class="calibre16">Cursor</kbd>, extract the URL of the item, then display the page at that URL using the device's default browser via an <kbd class="calibre16">Intent</kbd> (which we'll discuss in detail later).</li>
<li class="chapter">Finally, completing our data binding, we initialize the <kbd class="calibre16">LoaderManager</kbd> that will handle loading and updating the <kbd class="calibre16">Adapter</kbd> in an asynchronous manner.</li>
</ol>
<p class="mce-root">One last bit of code to look at before diving into data access--<kbd class="calibre16">isNetworkAvailable()</kbd>-- is as follows:</p>
<pre class="calibre21">        public boolean isNetworkAvailable() { 
          boolean connected = false; 
          ConnectivityManager cm = (ConnectivityManager)  
            getSystemService(Context.CONNECTIVITY_SERVICE); 
          for (Network network : cm.getAllNetworks()) { 
            NetworkInfo networkInfo = cm.getNetworkInfo(network); 
            if (networkInfo.isConnected() == true) { 
                connected = true; 
                break; 
            } 
          } 
         return connected; 
        } 
 
        private void showErrorDialog(String message) { 
          AlertDialog alertDialog = new AlertDialog.Builder(this) 
            .create(); 
          alertDialog.setTitle("Error!"); 
          alertDialog.setMessage(message); 
          alertDialog.setIcon(android.R.drawable.alert_dark_frame); 
          alertDialog.setButton(DialogInterface.BUTTON_POSITIVE,<br class="calibre2"/>          "OK", new DialogInterface.OnClickListener() { 
            @Override 
            public void onClick(DialogInterface dialog, int which) { 
              MainActivity.this.finish(); 
            } 
          }); 
 
          alertDialog.show(); 
       } </pre>
<p class="mce-root">In the preceding code, we start by getting a reference to the system service, <kbd class="calibre16">ConnectivityManager</kbd>, then we loop through each <kbd class="calibre16">Network</kbd> known to the system. For each <kbd class="calibre16">Network</kbd>, we get a reference to its <kbd class="calibre16">NetworkInfo</kbd> and call <kbd class="calibre16">isConnected()</kbd>. If we find one connected network, we return true, otherwise, we return false. In the calling code, if our return value is <kbd class="calibre16">false</kbd>, we show an error dialog, the method for which is shown here as well. This is a standard Android dialog. We have, however, added an <kbd class="calibre16">onClick</kbd> listener to the <span class="calibre7">OK</span> button, which closes the application. Using this, we tell the user that a network connection is needed, then close the app when the user taps on <span class="calibre7">OK</span>. It is debatable, of course, if this behavior is desirable, but the process for determining a device's network state is interesting enough, so I've included it here.</p>
<p class="mce-root">Let's turn our attention now to how data access is often done in Android apps--<kbd class="calibre16">CursorAdapters</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Android data access</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With any platform, there are multiple ways to access data, from built-in facilities to homegrown APIs. Android is no different, so while you can write your own way to load data from some arbitrary data source, unless you have very particular requirements, there is often no need, as Android has a system built in--the <kbd class="calibre16">ContentProvider</kbd>.</p>
<p class="mce-root">The Android documentation will tell you that a <em class="calibre20">content provider manages access to a central repository of data</em>, and that it offers a consistent, <em class="calibre20">standard interface to data that also handles inter-process communication and secure data access</em>. If you intend to expose your application's data to external sources (either for read or write), <kbd class="calibre16">ContentProvider</kbd> is a great way to go. However, if you don't intend to expose your data, you are more than welcome to write the needed CRUD methods yourself, manually issuing various SQL statements. In our case, we'll use a <kbd class="calibre16">ContentProvider</kbd>, as we have an interest in allowing third-party developers access to the data.</p>
<p class="mce-root">To create a <kbd class="calibre16">ContentProvider</kbd>, we need to create a new class that extends <kbd class="calibre16">ContentProvider</kbd> as follows:</p>
<pre class="calibre21">    public class SunagoContentProvider extends ContentProvider { </pre>
<p class="mce-root">We also need to register the provider in <kbd class="calibre16">AndroidManfest.xml</kbd>, which we'll do like this:</p>
<pre class="calibre21">    &lt;provider android:name=".data.SunagoContentProvider 
      android:authorities="com.steeplesoft.sunago.SunagoProvider" /&gt; </pre>
<p class="mce-root">Interaction with <kbd class="calibre16">ContentProvider</kbd> is never done directly. The client code will specify the URL of the data to be manipulated, and the Android system will direct the request to the appropriate provider. To make sure our <kbd class="calibre16">ContentProvider</kbd> functions as expected, then, we need to register the provider's authority, which we've already seen in the previous XML. In our provider, we'll create some static fields to help us manage the parts of our authority and the related URLs in a DRY manner.</p>
<pre class="calibre21">    private static final String PROVIDER_NAME =  
     "com.steeplesoft.sunago.SunagoProvider"; 
    private static final String CONTENT_URL =  
     "content://" + PROVIDER_NAME + "/items"; 
    public static final Uri CONTENT_URI = Uri.parse(CONTENT_URL); </pre>
<p class="mce-root">The first two fields in the preceding bit of code are private, as they're not needed outside the class. We define them as separate fields here, though, for clarity's sake. The third field, <kbd class="calibre16">CONTENT_URI</kbd>, is public, as we'll be referencing that field elsewhere in our app. Third-party consumers won't have access to the field, obviously, but will need to know its value, <kbd class="calibre16">content://com.steeplesoft.sunago.SunagoProvider/items</kbd>, which we would document somewhere for add-on developers. The first part of the URL, the protocol field, tells Android that we're looking for a <kbd class="calibre16">ContentProvider</kbd>. The next section is the authority, which uniquely identifies a particular <kbd class="calibre16">ContentProvider</kbd>, and the final field specifies the type of data, or model, that we're interested in. For Sunago, we have a single data type, <kbd class="calibre16">items</kbd>.</p>
<p class="mce-root">Next, we need to specify the URIs we want to support. We only have two--one for the items collection, and one for a particular item. Please, refer to following code snippet:</p>
<pre class="calibre21">    private static final UriMatcher URI_MATCHER =  
      new UriMatcher(UriMatcher.NO_MATCH); 
    private static final int ITEM = 1; 
    private static final int ITEM_ID = 2; 
    static { 
      URI_MATCHER.addURI(PROVIDER_NAME, "items", ITEM); 
      URI_MATCHER.addURI(PROVIDER_NAME, "items/#", ITEM_ID); 
     } </pre>
<p class="mce-root">In the last code, we start by creating a <kbd class="calibre16">UriMatcher</kbd>. Note that we pass <kbd class="calibre16">UriMatcher.NO_MATCH</kbd> to the constructor. It's not immediately clear what this value is for, but this is the value that will be returned if the user passes in a URI that doesn't match any of those registered. Finally, we register each URI with a unique <kbd class="calibre16">int</kbd> identifier.</p>
<p class="mce-root">Next, like many Android classes, we need specify an <kbd class="calibre16">onCreate</kbd> lifecycle hook as follows:</p>
<pre class="calibre21">    public boolean onCreate() { 
      openHelper = new SunagoOpenHelper(getContext(), DBNAME,  
        null, 1); 
      return true; 
    } </pre>
<p class="mce-root"><kbd class="calibre16">SunagoOpenHelper</kbd> is a child of <kbd class="calibre16">SQLiteOpenHelper</kbd>, which manages the creation and/or update of the underlying SQLite database. The class itself is pretty simple, and is given as follows:</p>
<pre class="calibre21">    public class SunagoOpenHelper extends SQLiteOpenHelper { 
      public SunagoOpenHelper(Context context, String name,  
            SQLiteDatabase.CursorFactory factory, int version) { 
          super(context, name, factory, version); 
      } 
 
      @Override 
      public void onCreate(SQLiteDatabase db) { 
        db.execSQL(SQL_CREATE_MAIN); 
      } 
 
      @Override 
      public void onUpgrade(SQLiteDatabase db, int oldVersion,  
        int newVersion) { 
      } 
    } </pre>
<p class="mce-root">I've not shown the table creation DDL, as it's a pretty simple table creation, but this class is all you need to create and maintain your database. If you have multiple tables, you would issue multiple creates in <kbd class="calibre16">onCreate</kbd>. When the application updates, <kbd class="calibre16">onUpgrade()</kbd> is called to allow you to modify the schema if needed.</p>
<p class="mce-root">Back in our <kbd class="calibre16">ContentProvider</kbd>, we need to implement two methods, one to read data, and one to insert (given the nature of the app, we're not interested in deletes or updates right now). For reading data, we override <kbd class="calibre16">query()</kbd> as follows:</p>
<pre class="calibre21">    public Cursor query(Uri uri, String[] projection,  
      String selection, String[] selectionArgs,  
      String sortOrder) { 
        switch (URI_MATCHER.match(uri)) { 
          case 2: 
            selection = selection + "_ID = " +  
              uri.getLastPathSegment(); 
              break; 
        } 
        SQLiteDatabase db = openHelper.getReadableDatabase(); 
        Cursor cursor = db.query("items", projection, selection,  
          selectionArgs, null, null, sortOrder); 
        cursor.setNotificationUri( 
          getContext().getContentResolver(), uri); 
        return cursor; 
    } </pre>
<p class="mce-root">This last code is where our URIs and their <kbd class="calibre16">int</kbd> identifiers come in. Using <kbd class="calibre16">UriMatcher</kbd>, we check the <kbd class="calibre16">Uri</kbd> passed in by the caller. Given that our provider is simple, the only one we need to do anything special for is <kbd class="calibre16">#2</kbd>, which is the query for a specific item. In that case, we extract the ID passed in as the last path segment, and add it to the selection criteria specified by the caller.</p>
<p class="mce-root">Once we have the query configured as requested, we get a readable <kbd class="calibre16">SQLiteDatabase</kbd> from our <kbd class="calibre16">openHelper</kbd>, and query it using the values passed by the caller. This is one of the areas where the <kbd class="calibre16">ContentProvider</kbd> contract comes in handy--we don't need to write any <kbd class="calibre16">SELECT</kbd> statements manually.</p>
<p class="mce-root">Before returning the cursor, we need to do something to it, as follows:</p>
<pre class="calibre21">    cursor.setNotificationUri(getContext().getContentResolver(), uri); </pre>
<p class="mce-root">With this preceding call, we tell the system that we want the cursor notified when the data is updated. Since we're using a <kbd class="calibre16">Loader</kbd>, this will allow us to update the user interface automatically when data is inserted.</p>
<p class="mce-root">For inserting data, we override <kbd class="calibre16">insert()</kbd> as follows:</p>
<pre class="calibre21">    public Uri insert(Uri uri, ContentValues values) { 
      SQLiteDatabase db = openHelper.getWritableDatabase(); 
      long rowID = db.insert("items", "", values); 
 
      if (rowID &gt; 0) { 
        Uri newUri = ContentUris.withAppendedId(CONTENT_URI,  
            rowID); 
        getContext().getContentResolver().notifyChange(newUri,  
            null); 
        return newUri; 
      } 
 
    throw new SQLException("Failed to add a record into " + uri); 
    } </pre>
<p class="mce-root">Using <kbd class="calibre16">openHelper</kbd>, this time, we get a writable instance of the database, on which we call <kbd class="calibre16">insert()</kbd>. The insert method returns the ID of the row just inserted. If we get a non-zero ID, we generate a URI for the row, which we'll eventually return. Before we do so, however, we notify the content resolver of the change in the data, which triggers our auto-reload in the user interface.</p>
<p class="mce-root">We have one more step to finish our data loading code, though. If you look back on <kbd class="calibre16">MainActivity.onCreate()</kbd>, you'll see this line:</p>
<pre class="calibre21">    getLoaderManager().initLoader(0, null, this); </pre>
<p class="mce-root">This last line tells the system that we want to initialize a <kbd class="calibre16">Loader</kbd> and that the <kbd class="calibre16">Loader</kbd> is <kbd class="calibre16">this</kbd> or <kbd class="calibre16">MainActivity</kbd>. In our definition of <kbd class="calibre16">MainActivity</kbd>, we've specified that it implements the <kbd class="calibre16">LoaderManager.LoaderCallbacks&lt;Cursor&gt;</kbd> interface. This requires us to implement a few methods as follows:</p>
<pre class="calibre21">    public Loader&lt;Cursor&gt; onCreateLoader(int i, Bundle bundle) { 
      CursorLoader cl = new CursorLoader(this,  
        SunagoContentProvider.CONTENT_URI,  
        ITEM_PROJECTION, null, null, 
           SunagoContentProvider.TIMESTAMP + " DESC"); 
      return cl; 
    } 
 
    public void onLoadFinished(Loader&lt;Cursor&gt; loader, Cursor cursor) { 
      adapter.swapCursor(cursor); 
    } 
 
    public void onLoaderReset(Loader&lt;Cursor&gt; loader) { 
      adapter.swapCursor(null); 
    } </pre>
<p class="mce-root">In <kbd class="calibre16">onCreateLoader()</kbd>, we specify both what to load and where to load it. We pass in the URI of the <kbd class="calibre16">ContentProvider</kbd> we just created, we specify the fields we're interested in via the <kbd class="calibre16">ITEM_PROJECTION</kbd> variable (which is a <kbd class="calibre16">String[]</kbd>, and not shown here), and, finally, the sort order (which we've specified as the timestamp of the items in descending order so that we get the newest items on top). The method <kbd class="calibre16">onLoadFinished()</kbd> is where the auto-reload happens. Once a new <kbd class="calibre16">Cursor</kbd> is created for the updated data, we swap it in for the <kbd class="calibre16">Cursor</kbd> that <kbd class="calibre16">Adapter</kbd> is currently using. While you can write your own persistence code, this highlights why using the platform facilities, whenever possible, can be a wise choice.</p>
<p class="mce-root">There is one large item left to look at with regard to data handling-- <kbd class="calibre16">SunagoCursorAdapter</kbd>. Looking again at the Android Javadocs, we learn that <em class="calibre20">an</em> <kbd class="calibre16">Adapter</kbd> <em class="calibre20">object acts as a bridge between an</em> <kbd class="calibre16">AdapterView</kbd> <em class="calibre20">and the underlying data for that view</em>, and that <kbd class="calibre16">CursorAdapter</kbd> <em class="calibre20">exposes data from a</em> <kbd class="calibre16">Cursor</kbd> <em class="calibre20">to a</em> <kbd class="calibre16">ListView</kbd> <em class="calibre20">widget</em>. Often--if not in the majority of cases--a particular <kbd class="calibre16">ListView</kbd> will require a custom <kbd class="calibre16">CursorAdapter</kbd> to allow the underlying data to be rendered correctly. Sunago is no exception. To create our <kbd class="calibre16">Adapter</kbd>, then, we create a new class as follows:</p>
<pre class="calibre21">    public class SunagoCursorAdapter extends CursorAdapter { 
      public SunagoCursorAdapter(Context context, Cursor c,  
      int flags) { 
        super(context, c, flags); 
    } </pre>
<p class="mce-root">This is pretty standard fare. The truly interesting parts come in the view creation, which is one of the reasons for being for a <kbd class="calibre16">CursorAdapter</kbd>. When the <kbd class="calibre16">Adapter</kbd> needs to create a new view to hold the data pointed to by the cursor, it calls the following method. This is where we specify what the view should look like with the call to <kbd class="calibre16">LayoutInflater.inflate()</kbd>:</p>
<pre class="calibre21">    public View newView(Context context, Cursor cursor,  
        ViewGroup viewGroup) { 
          View view = LayoutInflater.from(context).inflate( 
          R.layout.social_media_item, viewGroup, false); 
          ViewHolder viewHolder = new ViewHolder(); 
          viewHolder.text = (TextView)<br class="calibre2"/>          view.findViewById(R.id.textView); 
          viewHolder.image = (ImageView) view.findViewById( 
          R.id.imageView); 
 
          WindowManager wm = (WindowManager) Sunago.getAppContext() 
            .getSystemService(Context.WINDOW_SERVICE); 
          Point size = new Point(); 
          wm.getDefaultDisplay().getSize(size); 
          viewHolder.image.getLayoutParams().width =  
            (int) Math.round(size.x * 0.33); 
 
          view.setTag(viewHolder); 
          return view; 
     } </pre>
<p class="mce-root">We'll look at our layout definition in a moment, but first, let's take a look at <kbd class="calibre16">ViewHolder</kbd>:</p>
<pre class="calibre21">    private static class ViewHolder { 
      public TextView text; 
      public ImageView image; 
   } </pre>
<p class="mce-root">Finding views by ID can be an expensive operation, so a very common pattern is this <kbd class="calibre16">ViewHolder</kbd> approach. After the view is inflated, we immediately look up the fields we're interested in, and store those references in a <kbd class="calibre16">ViewHolder</kbd> instance, which is then stored as the tag on the <kbd class="calibre16">View</kbd>. Since views are recycled by the <kbd class="calibre16">ListView</kbd> class (meaning, they're reused as needed as you scroll through the data), this expensive <kbd class="calibre16">findViewById()</kbd> is called once and cached per <kbd class="calibre16">View</kbd> rather than once per item in the underlying data. For large datasets (and complex views), this can be a substantial performance boost.</p>
<p class="mce-root">In this method, we also set the size of the <kbd class="calibre16">ImageView</kbd> class. Android doesn't support setting the width of a view to a percentage via the XML markup (given next), so we do that manually here as we create the <kbd class="calibre16">View</kbd>. We get the <kbd class="calibre16">WindowManager</kbd> system service from which we get the default display's size. We multiply the display's width by 0.33, which will restrict the image, if any, to 1/3 of the display's width, and set the <kbd class="calibre16">ImageView</kbd>'s width to that.</p>
<p class="mce-root">So, what does the view look like for each row?</p>
<pre class="calibre21">    &lt;LinearLayout  
       
       
       
      android:layout_width="match_parent" 
      android:layout_height="match_parent" 
      android:orientation="horizontal"&gt; 
 
      &lt;ImageView 
        android:id="@+id/imageView" 
        android:layout_width="wrap_content" 
        android:layout_height="wrap_content" 
        android:layout_marginEnd="5dip" 
        android:layout_gravity="top" 
        android:adjustViewBounds="true"/&gt; 
 
      &lt;TextView 
        android:layout_width="match_parent" 
        android:layout_height="wrap_content" 
        android:id="@+id/textView" 
        android:scrollHorizontally="false" 
        android:textSize="18sp" /&gt; 
     &lt;/LinearLayout&gt; </pre>
<p class="mce-root">As the <kbd class="calibre16">ViewHolder</kbd> hinted, our view consists of an <kbd class="calibre16">ImageView</kbd> and a <kbd class="calibre16">TextView</kbd>, presented horizontally, thanks to the enclosing <kbd class="calibre16">LinearLayout</kbd>.</p>
<p class="mce-root">While <kbd class="calibre16">CursorAdapter</kbd> calls <kbd class="calibre16">newView()</kbd> to create a <kbd class="calibre16">View</kbd>, it calls <kbd class="calibre16">bindView()</kbd> to--if you can imagine--bind the <kbd class="calibre16">View</kbd> to a specific row in the <kbd class="calibre16">Cursor</kbd>. This is where <kbd class="calibre16">View</kbd> recycling comes into play. The <kbd class="calibre16">Adapter</kbd> has a number of <kbd class="calibre16">View</kbd> instances cached, and passes one to this method as needed. Our method looks like this:</p>
<pre class="calibre21">    public void bindView(View view, Context context, Cursor cursor) { 
      final ViewHolder viewHolder = (ViewHolder) view.getTag(); 
      String image = cursor.getString(INDEX_IMAGE); 
      if (image != null) { 
        new DownloadImageTask(viewHolder.image).execute(image); 
      } else { 
        viewHolder.image.setImageBitmap(null); 
        viewHolder.image.setVisibility(View.GONE); 
      } 
      viewHolder.body.setText(cursor.getString(INDEX_BODY)); 
    } </pre>
<p class="mce-root">We start by getting the <kbd class="calibre16">ViewHolder</kbd> instance. As discussed previously, we'll use the widget references stored here to update the user interface. Next, we pull the image URL from the cursor. It's up to each <kbd class="calibre16">SocialMediaItem</kbd> to decide how this field is populated, but it might be a tweeted image or a photo in an Instagram post. If the item has one, we need to download it so that it can be displayed. Since this requires a network operation, and we're running on the user interface thread, we hand that work off to <kbd class="calibre16">DownloadImageTask</kbd>. If there is no image for this item, we need to set the bitmap for the image to <kbd class="calibre16">null</kbd> (otherwise, the image that was there the last time this view instance was used would be displayed again). That frees up some memory, which is always good, but we also set the <kbd class="calibre16">ImageView</kbd> class' visibility to <kbd class="calibre16">GONE</kbd>, which hides it from the user interface. You might be tempted to use <kbd class="calibre16">INVISIBLE</kbd>, but that only makes it invisible <strong class="calibre8">while preserving its space in the user interface</strong>. The end result of that would be a big blank square, which is not what we want. Finally, we set the text of the <kbd class="calibre16">TextView</kbd> body to the text specified for the item.</p>
<p class="mce-root">The image downloading is handled off-thread by an <kbd class="calibre16">AsyncTask</kbd>, which is as follows:</p>
<pre class="calibre21">    private static class DownloadImageTask extends  
       AsyncTask&lt;String, Void, Bitmap&gt; { 
        private ImageView imageView; 
 
        public DownloadImageTask(ImageView imageView) { 
         this.imageView = imageView; 
        } </pre>
<p class="mce-root">Android will create a background <kbd class="calibre16">Thread</kbd> on which to run this task. The main entry point for our logic is <kbd class="calibre16">doInBackground()</kbd>. Please refer the following snippet:</p>
<pre class="calibre21">    protected Bitmap doInBackground(String... urls) { 
      Bitmap image = null; 
      try (InputStream in = new URL(urls[0]).openStream()) { 
        image = BitmapFactory.decodeStream(in); 
      } catch (java.io.IOException e) { 
         Log.e("Error", e.getMessage()); 
         } 
        return image; 
    } </pre>
<p class="mce-root">This is not the most robust download code imaginable (for example, redirect status codes are happily ignored), but it's certainly usable. Using Java 7's <kbd class="calibre16">try-with-resources</kbd>, we create a <kbd class="calibre16">URL</kbd> instance on which we call <kbd class="calibre16">openStream()</kbd>. Assuming no <kbd class="calibre16">Exception</kbd> is thrown in either of those operations, we call <kbd class="calibre16">BitmapFactory.decodeStream()</kbd> to convert the incoming bytes into a <kbd class="calibre16">Bitmap</kbd>, which is what the method is expected to return.</p>
<p class="mce-root">So, what happens to the <kbd class="calibre16">Bitmap</kbd> once we return it? We process that in <kbd class="calibre16">onPostExecute()</kbd> like this:</p>
<pre class="calibre21">    protected void onPostExecute(Bitmap result) { 
      imageView.setImageBitmap(result); 
      imageView.setVisibility(View.VISIBLE); 
      imageView.getParent().requestLayout(); 
    } </pre>
<p class="mce-root">In this last method, we update <kbd class="calibre16">ImageView</kbd> with our now downloaded <kbd class="calibre16">Bitmap</kbd>, makes it <kbd class="calibre16">VISIBLE</kbd>, then request that the view update itself on the screen.</p>
<p class="mce-root">So far, we've built an app that's capable of displaying <kbd class="calibre16">SocialMediaItem</kbd> instances, but we have nothing for it to show. We'll fix that now with a look at Android Services.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Android services</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For the desktop version of Sunago, we defined an API that would allow third-party developers (or ourselves) to add support for an arbitrary social network to Sunago. That was a great goal for the desktop, and it's a great goal for mobile. Fortunately, Android provides us with a mechanism that can be used to do just that: Services. <em class="calibre20">A Service is an application component representing either an application's desire to perform a longer-running operation while not interacting with the user or to supply functionality for other applications to use</em>. While services were designed for more than extensibility, we can leverage this facility to that end.</p>
<p class="mce-root">While there are a number of ways to implement and interact with services, we are going to bind the services to our <kbd class="calibre16">Activity</kbd> so that their life cycle is tied to that of our <kbd class="calibre16">Activity</kbd>, and we'll send messages to them asynchronously. We'll start by defining our class as follows:</p>
<pre class="calibre21">    public class TwitterService extends IntentService { 
      public TwitterService() { 
        super("TwitterService"); 
      } 
 
     @Override 
      protected void onHandleIntent(Intent intent) { 
    } </pre>
<p class="mce-root">Technically, these are the only methods required to create a service. Clearly, it doesn't do much, but we'll fix that in just a moment. Before we do that, we need to declare our new <kbd class="calibre16">Service</kbd> to Android which is done in <kbd class="calibre16">AndroidManifest.xml</kbd>, as follows:</p>
<pre class="calibre21">    &lt;service android:name=".twitter.TwitterService"  
     android:exported="false"&gt; 
      &lt;intent-filter&gt; 
        &lt;action  
          android:name="com.steeplesoft.sunago.intent.plugin" /&gt; 
        &lt;category  
          android:name="android.intent.category.DEFAULT" /&gt; 
       &lt;/intent-filter&gt; 
    &lt;/service&gt; </pre>
<p class="mce-root">Notice that, in addition to the service declaration, we also specify an <kbd class="calibre16">IntentFilter</kbd> via the <kbd class="calibre16">intent-filter</kbd> element. We'll use that in <kbd class="calibre16">MainActivity</kbd> later to find and bind our services. While we're looking at our service, though, let's look at this side of the binding process. We'll need to implement these two lifecycle methods:</p>
<pre class="calibre21">    public IBinder onBind(Intent intent) { 
      receiver = new TwitterServiceReceiver(); 
      registerReceiver(receiver,  
        new IntentFilter("sunago.service")); 
      return null; 
     } 
 
    public boolean onUnbind(Intent intent) { 
      unregisterReceiver(receiver); 
      return super.onUnbind(intent); 
    } </pre>
<p class="mce-root">These preceding methods are called when the service is bound and unbound, which give us an opportunity to register our receiver, which may lead to the question: What's that? Android provides an <strong class="calibre8">Interprocess Communication</strong> (<strong class="calibre8">IPC</strong>), but it is somewhat limited in that the payload size can not exceed 1 MB. Though our payload is only text, we can (and certainly will, based on my testing) exceed that. Our approach, then, will be to use asynchronous communication, via a receiver, and have the service persist the data via our <kbd class="calibre16">ContentProvider</kbd>.</p>
<p class="mce-root">To create a receiver, we extend <kbd class="calibre16">android.content.BroadcastReceiver</kbd> as follows:</p>
<pre class="calibre21">    private class TwitterServiceReceiver extends BroadcastReceiver { 
      @Override 
      public void onReceive(Context context, Intent intent) { 
        if ("REFRESH".equals(intent.getStringExtra("message"))) { 
            if (SunagoUtil.getPreferences().getBoolean( 
                getString(R.string.twitter_authd), false)) { 
                new TwitterUpdatesAsyncTask().execute(); 
            } 
          } 
       } 
     } </pre>
<p class="mce-root">Our message scheme is very simple--Sunago sends the message <kbd class="calibre16">REFRESH</kbd>, and the service performs its work, which we have wrapped up in <kbd class="calibre16">TwitterUpdatesAsyncTask</kbd>. In <kbd class="calibre16">onBind()</kbd>, we register the receiver with a specific <kbd class="calibre16">IntentFilter</kbd> that specifies the <kbd class="calibre16">Intent</kbd> broadcasts that we're interested in. In <kbd class="calibre16">onUnbind()</kbd>, we unregister our receiver as the service is released.</p>
<p class="mce-root">The rest of our service is in our <kbd class="calibre16">AsyncTask</kbd>, which is given as follows:</p>
<pre class="calibre21">    private class TwitterUpdatesAsyncTask extends  
    AsyncTask&lt;Void, Void, List&lt;ContentValues&gt;&gt; { 
      @Override 
      protected List&lt;ContentValues&gt; doInBackground(Void... voids) { 
        List&lt;ContentValues&gt; values = new ArrayList&lt;&gt;(); 
        for (SocialMediaItem item :  
                TwitterClient.instance().getItems()) { 
            ContentValues cv = new ContentValues(); 
            cv.put(SunagoContentProvider.BODY, item.getBody()); 
            cv.put(SunagoContentProvider.URL, item.getUrl()); 
            cv.put(SunagoContentProvider.IMAGE, item.getImage()); 
            cv.put(SunagoContentProvider.PROVIDER,  
                item.getProvider()); 
            cv.put(SunagoContentProvider.TITLE, item.getTitle()); 
            cv.put(SunagoContentProvider.TIMESTAMP,  
                item.getTimestamp().getTime()); 
            values.add(cv); 
        } 
        return values; 
      } 
 
    @Override 
    protected void onPostExecute(List&lt;ContentValues&gt; values) { 
      Log.i(MainActivity.LOG_TAG, "Inserting " + values.size() +  
        " tweets."); 
      getContentResolver() 
        .bulkInsert(SunagoContentProvider.CONTENT_URI, 
           values.toArray(new ContentValues[0])); 
      } 
    }  </pre>
<p class="mce-root">We need to make sure that the network operation isn't performed on the user interface thread, so we perform the work in <kbd class="calibre16">AsyncTask</kbd>. We don't need any parameters passed into the task, so we set the <kbd class="calibre16">Params</kbd> and <kbd class="calibre16">Progress</kbd> types to <kbd class="calibre16">Void</kbd>. We are, though, interested in the <kbd class="calibre16">Result</kbd> type, which is <kbd class="calibre16">List&lt;ContentValue&gt;</kbd>, which we see reflected in both the type declaration and the return type of <kbd class="calibre16">execute()</kbd>. In <kbd class="calibre16">onPostExecute()</kbd>, we then issue a bulk insert on <kbd class="calibre16">ContentProvider</kbd> to save the data. In this way, we can make the newly-retrieved data available to the application without running afoul the 1 MB limit with <kbd class="calibre16">IBinder</kbd>.</p>
<p class="mce-root">With our service defined, we need now to look at how to find and bind the services. Looking back at <kbd class="calibre16">MainActivity</kbd>, we'll finally look at a method we've already seen mentioned, <kbd class="calibre16">findPlugins()</kbd>:</p>
<pre class="calibre21">    private void findPlugins() { 
     Intent baseIntent = new Intent(PLUGIN_ACTION); 
     baseIntent.setFlags(Intent.FLAG_DEBUG_LOG_RESOLUTION); 
     List&lt;ResolveInfo&gt; list = getPackageManager() 
            .queryIntentServices(baseIntent, 
            PackageManager.GET_RESOLVED_FILTER); 
     for (ResolveInfo rinfo : list) { 
        ServiceInfo sinfo = rinfo.serviceInfo; 
        if (sinfo != null) { 
            plugins.add(new  
                ComponentName(sinfo.packageName, sinfo.name)); 
        } 
      } 
    } </pre>
<p class="mce-root">To find the plugins we're interested in, we create an <kbd class="calibre16">Intent</kbd> with a specific action. In this case, that action is <kbd class="calibre16">com.steeplesoft.sunago.intent.plugin</kbd>, which we've already seen in the service definition in <kbd class="calibre16">AndroidManifest.xml</kbd>. Using this <kbd class="calibre16">Intent</kbd>, we query <kbd class="calibre16">PackageManager</kbd> for all <kbd class="calibre16">IntentServices</kbd> matching Intent. Next, we iterate over the list of <kbd class="calibre16">ResolveInfo</kbd> instances, getting the <kbd class="calibre16">ServiceInfo</kbd> instances, and create and store a <kbd class="calibre16">ComponentName</kbd> representing the plugin.</p>
<p class="mce-root">The actual binding of the services is done in the following <kbd class="calibre16">bindPlugins()</kbd> method, which we call from the <kbd class="calibre16">onStart()</kbd> method to make sure the binding occurs at the appropriate time in activity's lifecycle:</p>
<pre class="calibre21">    private void bindPluginServices() { 
      for (ComponentName plugin : plugins) { 
        Intent intent = new Intent(); 
        intent.setComponent(plugin); 
        PluginServiceConnection conn =  
            new PluginServiceConnection(); 
        pluginServiceConnections.add(conn); 
        bindService(intent, conn, Context.BIND_AUTO_CREATE); 
      } 
    } </pre>
<p class="mce-root">For each plugin found, we create an <kbd class="calibre16">Intent</kbd> using the <kbd class="calibre16">ComponentName</kbd> we created earlier. Each service binding will need a <kbd class="calibre16">ServiceConnection</kbd> object. For that, we created <kbd class="calibre16">PluginServiceConnection</kbd>, which implements the interface. Its methods are empty, so we'll not look at that class here. With our <kbd class="calibre16">ServiceConnection</kbd> instance, we can now bind the service with a call to <kbd class="calibre16">bindService()</kbd>.</p>
<p class="mce-root">Finally, to clean up as the application is closing, we need to unbind our services. From <kbd class="calibre16">onStop()</kbd>, we call this method:</p>
<pre class="calibre21">    private void releasePluginServices() { 
      for (PluginServiceConnection conn :  
            pluginServiceConnections) { 
        unbindService(conn); 
      } 
      pluginServiceConnections.clear(); 
    } </pre>
<p class="mce-root">Here, we simply loop through our <kbd class="calibre16">ServiceConnection</kbd> plugins, passing each to <kbd class="calibre16">unbindService()</kbd>, which will allow Android to garbage collect any services we may have started.</p>
<p class="mce-root">So far, we've defined a service, looked it up, and bound it. But how do we interact with it? We'll go the simple route, and add an option menu item. To do that, we modify <kbd class="calibre16">res/menu/main_menu.xml</kbd> as follows:</p>
<pre class="calibre21">    &lt;menu  
       
      &gt; 
      &lt;item android:id="@+id/action_settings"  
        android:orderInCategory="100"  
        android: 
        app:showAsAction="never" /&gt; 
     &lt;item android:id="@+id/action_refresh"  
        android:orderInCategory="100"  
        android: 
        app:showAsAction="never" /&gt; 
    &lt;/menu&gt; </pre>
<p class="mce-root">To respond to the menu item being selected, we need to revisit <kbd class="calibre16">onOptionsItemSelected()</kbd> here:</p>
<pre class="calibre21">    @Override 
    public boolean onOptionsItemSelected(MenuItem item) { 
      switch (item.getItemId()) { 
        case R.id.action_settings: 
            showPreferencesActivity(); 
            return true; 
        case R.id.action_refresh: 
            sendRefreshMessage(); 
            break; 
       } 
 
     return super.onOptionsItemSelected(item); 
    } </pre>
<p class="mce-root">In the <kbd class="calibre16">switch</kbd> block of the preceding code, we add a <kbd class="calibre16">case</kbd> label for <kbd class="calibre16">R.id.action_refresh</kbd>, which matches the ID of our newly added menu item in which we call the method <kbd class="calibre16">sendRefreshMessage()</kbd>:</p>
<pre class="calibre21">    private void sendRefreshMessage() { 
      sendMessage("REFRESH"); 
    } 
 
    private void sendMessage(String message) { 
      Intent intent = new Intent("sunago.service"); 
      intent.putExtra("message", message); 
      sendBroadcast(intent); 
    } </pre>
<p class="mce-root">The first method is pretty straightforward. In fact, it might not even be necessary, given its simplicity, but it does add semantic clarity to the consuming code, so I think it's a good method to add.</p>
<p class="mce-root">The interesting part, however, is the method <kbd class="calibre16">sendMessage()</kbd>. We start by creating an <kbd class="calibre16">Intent</kbd> that specifies our action, <kbd class="calibre16">sunago.service</kbd>. This is an arbitrary string that we define, and then document for any third-party consumers. This will help our services filter out messages that are of no interest, which is exactly what we did in <kbd class="calibre16">TwitterService.onBind()</kbd> with the call to <kbd class="calibre16">registerReceiver(receiver, new IntentFilter("sunago.service"))</kbd>. We then add the message that our app wants to send (<kbd class="calibre16">REFRESH</kbd>, in this case) as an extra on <kbd class="calibre16">Intent</kbd>, which we then broadcast via <kbd class="calibre16">sendBroadcast()</kbd>. From here, Android will handle delivering the message to our service, which is already running (since we've bound it to our <kbd class="calibre16">Activity</kbd>) and listening (as we registered a <kbd class="calibre16">BroadcastReceiver</kbd>).</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Android tabs and fragments</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We've looked at quite a bit, but there is still a fair bit we haven't seen, such as the implementation for <kbd class="calibre16">TwitterClient</kbd>, as well as any details on the integration of networks, such as Instagram, which we saw in the last chapter. For the most part, <kbd class="calibre16">TwitterClient</kbd> is identical to what we saw in <a href="d1cb41cc-d5b4-4f0d-a4ac-c41889568a76.xhtml" target="_blank" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 21</a>, <em class="calibre20">Sunago - A Social Media Aggregator</em>. The only major difference is in the use of the stream APIs. Some APIs are only available in certain Android versions, specifically, version 24, also known as Nougat. Since we're targeting Lollipop (SDK version 21), we are unable to use them. That aside, the internal logic and API usage are identical. You can see the details in the source repository. Before we finish, though, we need to take a look at the Twitter preferences screen, as there are some interesting items there.</p>
<p class="mce-root">We'll start with a tab layout activity, as follows:</p>
<pre class="calibre21">    public class PreferencesActivity extends AppCompatActivity { 
      private SectionsPagerAdapter sectionsPagerAdapter; 
      private ViewPager viewPager; 
 
      @Override 
      protected void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.activity_preferences); 
 
        setSupportActionBar((Toolbar) findViewById(R.id.toolbar)); 
        sectionsPagerAdapter =  
        new SectionsPagerAdapter(getSupportFragmentManager()); 
 
        viewPager = (ViewPager) findViewById(R.id.container); 
        viewPager.setAdapter(sectionsPagerAdapter); 
 
        TabLayout tabLayout = (TabLayout) findViewById(R.id.tabs); 
        tabLayout.setupWithViewPager(viewPager); 
    } </pre>
<p class="mce-root">For making a tabbed interface, we need two things--<kbd class="calibre16">FragmentPagerAdapter</kbd> and <kbd class="calibre16">ViewPager</kbd>. The <kbd class="calibre16">ViewPager</kbd> is a user-interface element that actually shows the tabs. Think of it as <kbd class="calibre16">ListView</kbd> for tabs. The <kbd class="calibre16">FragmentPagerAdapter</kbd>, then, is like <kbd class="calibre16">CursorAdapter</kbd> for the tabs. Instead of an SQL-backed data source, though, <kbd class="calibre16">FragmentPagerAdapter</kbd> is an adapter that represents pages as Fragments. In this method, we create an instance of our <kbd class="calibre16">SectionsPagerAdapter</kbd>, and set it as the adapter on our <kbd class="calibre16">ViewPager</kbd>. We also associate the <kbd class="calibre16">ViewPager</kbd> element with the <kbd class="calibre16">TabLayout</kbd>.</p>
<p class="mce-root"><kbd class="calibre16">SectionsPagerAdapter</kbd> is a simple class, and is written as follows:</p>
<pre class="calibre21">    public class SectionsPagerAdapter extends FragmentPagerAdapter { 
      public SectionsPagerAdapter(FragmentManager fm) { 
      super(fm); 
    } 
 
    @Override 
    public Fragment getItem(int position) { 
        switch (position) { 
            case 0 : 
                return new TwitterPreferencesFragment(); 
            case 1 : 
                return new InstagramPreferencesFragment(); 
            default: 
                throw new RuntimeException("Invalid position"); 
        } 
     } 
 
     @Override 
     public int getCount() { 
        return 2; 
     } 
 
     @Override 
     public CharSequence getPageTitle(int position) { 
        switch (position) { 
            case 0: 
                return "Twitter"; 
            case 1: 
                return "Instagram"; 
       } 
        return null; 
     } 
    } </pre>
<p class="mce-root">The method <kbd class="calibre16">getCount()</kbd> tells the system how many tabs we support, the title for each tab that is returned by <kbd class="calibre16">getPageTitle()</kbd>, and the <kbd class="calibre16">Fragment</kbd> representing the selected tab is returned from <kbd class="calibre16">getItem()</kbd>. In this example, we create a <kbd class="calibre16">Fragment</kbd> instance as needed. Note, we hint at Instagram support here, but its implementation looks strikingly similar to the Twitter implementation, so we won't go into detail on that here.</p>
<p class="mce-root"><kbd class="calibre16">TwitterPreferencesFragment</kbd> looks as follows:</p>
<pre class="calibre21">    public class TwitterPreferencesFragment extends Fragment { 
      @Override 
       public View onCreateView(LayoutInflater inflater,  
       ViewGroup container, Bundle savedInstanceState) { 
       return inflater.inflate( 
        R.layout.fragment_twitter_preferences,  
        container, false); 
     } 
 
      @Override 
      public void onStart() { 
        super.onStart(); 
        updateUI(); 
      } </pre>
<p class="mce-root">Fragments have a slightly different lifecycle than an <kbd class="calibre16">Activity</kbd>. Here, we inflate the view in <kbd class="calibre16">onCreateView()</kbd>, then we update the user interface with the current state from <kbd class="calibre16">onStart()</kbd>. What does the view look like? That's determined by <kbd class="calibre16">R.layout.fragment_twitter_preferences</kbd>.</p>
<pre class="calibre21">    &lt;LinearLayout  
       
       
      android:layout_width="match_parent" 
      android:layout_height="match_parent" 
      android:paddingBottom="@dimen/activity_vertical_margin" 
      android:paddingLeft="@dimen/activity_horizontal_margin" 
      android:paddingRight="@dimen/activity_horizontal_margin" 
      android:paddingTop="@dimen/activity_vertical_margin" 
      android:orientation="vertical"&gt; 
 
     &lt;Button 
       android:text="Login" 
       android:layout_width="wrap_content" 
       android:layout_height="wrap_content" 
       android:id="@+id/connectButton" /&gt; 
 
     &lt;LinearLayout 
       android:orientation="vertical" 
       android:layout_width="match_parent" 
       android:layout_height="match_parent" 
       android:id="@+id/twitterPrefsLayout"&gt; 
 
     &lt;CheckBox 
       android:text="Include the home timeline" 
       android:layout_width="match_parent" 
       android:layout_height="wrap_content" 
       android:id="@+id/showHomeTimeline" /&gt; 
 
     &lt;TextView 
       android:text="User lists to include" 
       android:layout_width="match_parent" 
       android:layout_height="wrap_content" 
       android:id="@+id/textView2" /&gt; 
 
     &lt;ListView 
       android:layout_width="match_parent" 
       android:layout_height="match_parent" 
       android:id="@+id/userListsListView" /&gt; 
     &lt;/LinearLayout&gt; 
    &lt;/LinearLayout&gt; </pre>
<p class="mce-root">In a nutshell, as you can see in the preceding code, we have a button for logging in and out, and a <kbd class="calibre16">ListView</kbd> for allowing the user to select which Twitter lists from which to load data.</p>
<p class="mce-root">Given the frequent use of the network for interacting with Twitter plus Android's aversion to network access on the user interface thread, the code here gets a little complicated. We can see the start of that in <kbd class="calibre16">updateUI()</kbd>, as follows:</p>
<pre class="calibre21">    private void updateUI() { 
      getActivity().runOnUiThread(new Runnable() { 
        @Override 
        public void run() { 
          final Button button = (Button)  
          getView().findViewById(R.id.connectButton); 
          final View prefsLayout =  
          getView().findViewById(R.id.twitterPrefsLayout); 
          if (!SunagoUtil.getPreferences().getBoolean( 
          getString(R.string.twitter_authd), false)) { 
            prefsLayout.setVisibility(View.GONE); 
            button.setOnClickListener( 
              new View.OnClickListener() { 
            @Override 
            public void onClick(View view) { 
             new TwitterAuthenticateTask().execute(); 
            } 
            }); 
            } else { 
              button.setText(getString(R.string.logout)); 
              button.setOnClickListener( 
              new View.OnClickListener() { 
                @Override 
                public void onClick(View view) { 
                 final SharedPreferences.Editor editor =  
                 SunagoUtil.getPreferences().edit(); 
                 editor.remove(getString( 
                 R.string.twitter_oauth_token)); 
                 editor.remove(getString( 
                 R.string.twitter_oauth_secret)); 
                 editor.putBoolean(getString( 
                 R.string.twitter_authd), false); 
                 editor.commit(); 
                 button.setText(getString(R.string.login)); 
                 button.setOnClickListener( 
                 new LoginClickListener()); 
               } 
              }); 
 
               prefsLayout.setVisibility(View.VISIBLE); 
               populateUserList(); 
              } 
            } 
        });  
      }</pre>
<p class="mce-root">The first thing that should stand out in the last code is that first line. Since we're updating the user interface, we have to make sure this code runs on the user interface thread. To make that happen, we wrap our logic in a <kbd class="calibre16">Runnable</kbd>, and pass that to the method <kbd class="calibre16">runOnUiThread()</kbd>. In <kbd class="calibre16">Runnable</kbd>, we check to see if the user is logged in or not. If not, we set the <kbd class="calibre16">prefsLayout</kbd> section's visibility to <kbd class="calibre16">GONE</kbd>, set the <kbd class="calibre16">Button</kbd>'s text to Login, and set its <kbd class="calibre16">onClick</kbd> listener to a <kbd class="calibre16">View.OnClickListener</kbd> method that executes <kbd class="calibre16">TwitterAuthenticateTask</kbd>.</p>
<p class="mce-root">If the user is not logged in, we do the opposite--make <kbd class="calibre16">prefsLayout</kbd> visible, set the <kbd class="calibre16">Button</kbd> text to Logout, set the <kbd class="calibre16">onClick</kbd> to an anonymous <kbd class="calibre16">View.OnClickListener</kbd> class that removes the authentication-related preferences, and recursively call <kbd class="calibre16">updateUI()</kbd> to make sure the interface is updated to reflect the logout.</p>
<p class="mce-root"><kbd class="calibre16">TwitterAuthenticateTask</kbd> is another <kbd class="calibre16">AsyncTask</kbd> that handles authenticating with Twitter. To authenticate, we have to get a Twitter request token, which requires network access, so this must be done off of the user interface thread, thus, <kbd class="calibre16">AsyncTask</kbd>. Please refer to the following code snippet:</p>
<pre class="calibre21">    private class TwitterAuthenticateTask extends  
        AsyncTask&lt;String, String, RequestToken&gt; { 
      @Override 
      protected void onPostExecute(RequestToken requestToken) { 
        super.onPostExecute(requestToken); 
 
        Intent intent = new Intent(getContext(),  
          WebLoginActivity.class); 
        intent.putExtra("url",  
          requestToken.getAuthenticationURL()); 
        intent.putExtra("queryParam", "oauth_verifier"); 
        startActivityForResult(intent, LOGIN_REQUEST); 
      } 
 
      @Override 
      protected RequestToken doInBackground(String... strings) { 
        try { 
          return TwitterClient.instance().getRequestToken(); 
        } catch (TwitterException e) { 
          throw new RuntimeException(e); 
        } 
      } 
    } </pre>
<p class="mce-root">Once we have the <kbd class="calibre16">RequestToken</kbd>, we show the <kbd class="calibre16">WebLoginActivity</kbd> from which the user will enter the credentials for the service. We'll look at that in the next code.</p>
<p class="mce-root">When that activity returns, we need to check the results and respond appropriately.</p>
<pre class="calibre21">    public void onActivityResult(int requestCode, int resultCode,  
    Intent data) { 
      super.onActivityResult(requestCode, resultCode, data); 
      if (requestCode == LOGIN_REQUEST) { 
        if (resultCode == Activity.RESULT_OK) { 
            new TwitterLoginAsyncTask() 
                .execute(data.getStringExtra("oauth_verifier")); 
        } 
      } 
    } </pre>
<p class="mce-root">When we started <kbd class="calibre16">WebLoginActivity</kbd>, we specified that we wanted to get a result, and we specified an identifier, <kbd class="calibre16">LOGIN_REQUEST</kbd>, which is set to 1, to uniquely identify which <kbd class="calibre16">Activity</kbd> was returning the result. If <kbd class="calibre16">requestCode</kbd> is <kbd class="calibre16">LOGIN_REQUEST</kbd>, and the result code is <kbd class="calibre16">Activity.RESULT_OK</kbd> (see <kbd class="calibre16">WebLoginActivity</kbd> given next), then we have a successful response, and we need to finish the login process, for which we'll use another <kbd class="calibre16">AsyncTask</kbd>.</p>
<pre class="calibre21">    private class TwitterLoginAsyncTask  
    extends AsyncTask&lt;String, String, AccessToken&gt; { 
      @Override 
      protected AccessToken doInBackground(String... codes) { 
        AccessToken accessToken = null; 
        if (codes != null &amp;&amp; codes.length &gt; 0) { 
            String code = codes[0]; 
            TwitterClient twitterClient =  
              TwitterClient.instance(); 
            try { 
              accessToken = twitterClient.getAcccessToken( 
                twitterClient.getRequestToken(), code); 
            } catch (TwitterException e) { 
              e.printStackTrace(); 
            } 
            twitterClient.authenticateUser(accessToken.getToken(),  
              accessToken.getTokenSecret()); 
           } 
 
        return accessToken; 
       } 
 
      @Override 
      protected void onPostExecute(AccessToken accessToken) { 
        if (accessToken != null) { 
          SharedPreferences.Editor preferences =  
            SunagoUtil.getPreferences().edit(); 
          preferences.putString(getString( 
              R.string.twitter_oauth_token),  
            accessToken.getToken()); 
          preferences.putString(getString( 
              R.string.twitter_oauth_secret),  
            accessToken.getTokenSecret()); 
          preferences.putBoolean(getString( 
             R.string.twitter_authd), true); 
            preferences.commit(); 
          updateUI(); 
        } 
      } 
    } </pre>
<p class="mce-root">In <kbd class="calibre16">doInBackground()</kbd>, we perform the network operation. When we have a result, the <kbd class="calibre16">AccessToken</kbd>, we use that to authenticate our <kbd class="calibre16">TwitterClient</kbd> instance, then we return the token. In <kbd class="calibre16">onPostExecute()</kbd>, we save the <kbd class="calibre16">AccessToken</kbd> details to <kbd class="calibre16">SharedPreferences</kbd>. Technically, all of this could have been done in <kbd class="calibre16">doInBackground()</kbd>, but I find it helpful, especially when learning something new, not to cut corners. Once you're comfortable with how all of this works, you are, of course, free to cut corners when and where you feel comfortable doing so.</p>
<p class="mce-root">We have one last piece to look over, <kbd class="calibre16">WebLoginActivity</kbd>. Functionally, it is identical to <kbd class="calibre16">LoginActivity</kbd>--it presents a web view which displays the login page for the given network. When the login succeeds, the needed information is returned to the calling code. This being Android rather than JavaFX, the mechanics are, of course, a little different.</p>
<pre class="calibre21">    public class WebLoginActivity extends AppCompatActivity { 
      @Override 
      protected void onCreate(Bundle savedInstanceState) { 
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.activity_web_view); 
        setTitle("Login"); 
        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar); 
        setSupportActionBar(toolbar); 
        Intent intent = getIntent(); 
        final String url = intent.getStringExtra("url"); 
        final String queryParam =  
            intent.getStringExtra("queryParam"); 
        WebView webView = (WebView)findViewById(R.id.webView); 
        final WebViewClient client =  
            new LoginWebViewClient(queryParam); 
        webView.setWebViewClient(client); 
        webView.loadUrl(url); 
      } </pre>
<p class="mce-root">Most of this preceding code looks very much like the other <kbd class="calibre16">Activity</kbd> classes we've written. We do some basic user interface set up, then, getting a reference to the <kbd class="calibre16">Intent</kbd>, we extract the two parameters of interest--the URL of the login page, and the query parameter that indicates a successful login.</p>
<p class="mce-root">To participate in the page loading life cycle, we extend <kbd class="calibre16">WebViewClient</kbd> (which we then attach to <kbd class="calibre16">WebView</kbd> in <kbd class="calibre16">Activity</kbd>, as seen previously). This is done as follows:</p>
<pre class="calibre21">    private class LoginWebViewClient extends WebViewClient { 
      private String queryParam; 
 
      public LoginWebViewClient(String queryParam) { 
        this.queryParam = queryParam; 
      } 
 
     @Override 
     public void onPageStarted(WebView view, String url,  
            Bitmap favicon) { 
        final Uri uri = Uri.parse(url); 
        final String value = uri.getQueryParameter(queryParam); 
        if (value != null) { 
            Intent resultIntent = new Intent(); 
            for (String name : uri.getQueryParameterNames()) { 
                resultIntent.putExtra(name,  
                    uri.getQueryParameter(name)); 
            } 
            setResult(Activity.RESULT_OK, resultIntent); 
            finish(); 
        } 
        super.onPageStarted(view, url, favicon); 
       } 
   } </pre>
<p class="mce-root">While <kbd class="calibre16">WebViewClient</kbd> offers a myriad of life cycle events, we're only concerned with one right now, <kbd class="calibre16">onPageStarted()</kbd>, which is fired, as expected, when the page starts to load. By hooking in here, we can look at the URL before the related network activity begins. We can examine the desired URL to see if the query parameter of interest is present. If it is, we create a new <kbd class="calibre16">Intent</kbd> to pass data back to the caller, copy all of the query parameters to it, set the <kbd class="calibre16">Activity</kbd> result to <kbd class="calibre16">RESULT_OK</kbd>, and finish the <kbd class="calibre16">Activity</kbd>. If you look back at <kbd class="calibre16">onActivityResult()</kbd>, you should see now from where <kbd class="calibre16">resultCode</kbd> comes.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With that, our application is complete. It's not a perfect application, but it is a complete Android application, which demonstrates a number of features you might need in your own app including <kbd class="calibre16">Activities</kbd>, services, database creation, content providers, messaging, and asynchronous processing. Clearly, there are parts of the application where the error handling could be more robust, or the design generalized a bit more to be more readily reusable. Doing so in this context, however, would obscure the basics of the application too much. Making these changes, then, will make a great exercise for the reader.</p>
<p class="mce-root">In the next chapter, we'll take a look at a completely different type of application. We'll build a small utility to handle what can be a serious problem--too much email. This application will allow us to describe a set of rules that will delete or move emails. It's a simple concept, but it will allow us to work with JSON APIs and the <kbd class="calibre16">JavaMail</kbd> package. You'll learn a bit and end up with a useful little utility as well.</p>


            </article>

            
        </section>
    </div>



  </body></html>