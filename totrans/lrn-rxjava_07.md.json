["```java\nimport io.reactivex.Observable;\n\npublic class Launcher {    \npublic static void main(String[] args) {\n     Observable.range(1,50)\n               .buffer(8)\n               .subscribe(System.out::println);\n   }\n}\n```", "```java\n[1, 2, 3, 4, 5, 6, 7, 8]\n[9, 10, 11, 12, 13, 14, 15, 16]\n[17, 18, 19, 20, 21, 22, 23, 24]\n[25, 26, 27, 28, 29, 30, 31, 32]\n[33, 34, 35, 36, 37, 38, 39, 40]\n[41, 42, 43, 44, 45, 46, 47, 48]\n[49, 50]\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.HashSet;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.range(1,50)\n                  .buffer(8, HashSet::new)\n                  .subscribe(System.out::println);\n    }\n}\n```", "```java\nimport io.reactivex.Observable;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.range(1,10)\n                  .buffer(2, 3)\n                  .subscribe(System.out::println);\n    }\n}\n```", "```java\n[1, 2]\n[4, 5]\n[7, 8]\n[10]\n```", "```java\nimport io.reactivex.Observable;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.range(1,10)\n                  .buffer(3, 1)\n                  .subscribe(System.out::println);\n    }\n}\n```", "```java\n[1, 2, 3]\n[2, 3, 4]\n[3, 4, 5]\n[4, 5, 6]\n[5, 6, 7]\n[6, 7, 8]\n[7, 8, 9]\n[8, 9, 10]\n[9, 10]\n[10]\n```", "```java\nimport io.reactivex.Observable;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.range(1,10)\n                .buffer(2, 1)\n                .filter(c -> c.size() == 2)\n                .subscribe(System.out::println);\n    }\n}\n```", "```java\n[1, 2]\n[2, 3]\n[3, 4]\n[4, 5]\n[5, 6]\n[6, 7]\n[7, 8]\n[8, 9]\n[9, 10]\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.interval(300, TimeUnit.MILLISECONDS)\n                  .map(i -> (i + 1) * 300) // map to elapsed time\n                  .buffer(1, TimeUnit.SECONDS)\n                  .subscribe(System.out::println);\n        sleep(4000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } \n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\n[300, 600, 900]\n[1200, 1500, 1800]\n[2100, 2400, 2700]\n[3000, 3300, 3600, 3900]\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.interval(300, TimeUnit.MILLISECONDS)\n                .map(i -> (i + 1) * 300) // map to elapsed time\n                .buffer(1, TimeUnit.SECONDS, 2)\n                .subscribe(System.out::println);\n        sleep(5000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\n[300, 600]\n[900]\n[1200, 1500]\n[1800]\n[2100, 2400]\n[2700]\n[3000, 3300]\n[3600, 3900]\n[]\n[4200, 4500]\n[4800]\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable<Long> cutOffs =\n                Observable.interval(1, TimeUnit.SECONDS);\n        Observable.interval(300, TimeUnit.MILLISECONDS)\n            .map(i -> (i + 1) * 300) // map to elapsed time\n            .buffer(cutOffs)\n            .subscribe(System.out::println);\n        sleep(5000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\n[300, 600, 900]\n[1200, 1500, 1800]\n[2100, 2400, 2700]\n[3000, 3300, 3600, 3900]\n[4200, 4500, 4800]\n```", "```java\nimport io.reactivex.Observable;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.range(1,50)\n                  .window(8)\n                  .flatMapSingle(obs -> obs.reduce(\"\", (total, next) -> total\n                        + (total.equals(\"\") ? \"\" : \"|\") + next))\n                  .subscribe(System.out::println);\n    }\n}\n```", "```java\n1|2|3|4|5|6|7|8\n9|10|11|12|13|14|15|16\n17|18|19|20|21|22|23|24\n25|26|27|28|29|30|31|32\n33|34|35|36|37|38|39|40\n41|42|43|44|45|46|47|48\n49|50\n```", "```java\nimport io.reactivex.Observable;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.range(1,50)\n                  .window(2, 3)\n                  .flatMapSingle(obs -> obs.reduce(\"\", (total, next) -> total\n                        + (total.equals(\"\") ? \"\" : \"|\") + next))\n                  .subscribe(System.out::println);\n    }\n}\n```", "```java\n1|2\n4|5\n7|8\n10|11\n13|14\n16|17\n19|20\n22|23\n25|26\n28|29\n31|32\n34|35\n37|38\n40|41\n43|44\n46|47\n49|50\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable.interval(300, TimeUnit.MILLISECONDS)\n                  .map(i -> (i + 1) * 300) // map to elapsed time\n                  .window(1, TimeUnit.SECONDS)   \n                  .flatMapSingle(obs -> obs.reduce(\"\", (total, next) -> total\n                        + (total.equals(\"\") ? \"\" : \"|\") + next))\n                  .subscribe(System.out::println);\n        sleep(5000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n       }\n    }\n}\n```", "```java\n300|600|900\n1200|1500|1800\n2100|2400|2700\n3000|3300|3600|3900\n4200|4500|4800\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable<Long> cutOffs =\n                Observable.interval(1, TimeUnit.SECONDS);\n        Observable.interval(300, TimeUnit.MILLISECONDS)\n            .map(i -> (i + 1) * 300) // map to elapsed time\n            .window(cutOffs)\n            .flatMapSingle(obs -> obs.reduce(\"\", (total, next) -> total\n                + (total.equals(\"\") ? \"\" : \"|\") + next))\n            .subscribe(System.out::println);\n        sleep(5000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\n300|600|900\n1200|1500|1800\n2100|2400|2700\n3000|3300|3600|3900\n4200|4500|4800\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable<String> source1 = Observable.interval(100, TimeUnit.MILLISECONDS)\n                .map(i -> (i + 1) * 100) // map to elapsed time\n                .map(i -> \"SOURCE 1: \" + i)\n                .take(10);\n        Observable<String> source2 = Observable.interval(300, TimeUnit.MILLISECONDS)\n                .map(i -> (i + 1) * 300) // map to elapsed time\n                .map(i -> \"SOURCE 2: \" + i)\n                .take(3);\n        Observable<String> source3 = Observable.interval(2000, TimeUnit.MILLISECONDS)\n                .map(i -> (i + 1) * 2000) // map to elapsed time\n                .map(i -> \"SOURCE 3: \" + i)\n                .take(2);\n        Observable.concat(source1, source2, source3)\n                .subscribe(System.out::println);\n        sleep(6000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\nSOURCE 1: 100\nSOURCE 1: 200\nSOURCE 1: 300\nSOURCE 1: 400\nSOURCE 1: 500\nSOURCE 1: 600\nSOURCE 1: 700\nSOURCE 1: 800\nSOURCE 1: 900\nSOURCE 1: 1000\nSOURCE 2: 300\nSOURCE 2: 600\nSOURCE 2: 900\nSOURCE 3: 2000\nSOURCE 3: 4000\n```", "```java\nObservable.concat(source1, source2, source3)\n         .throttleLast(1, TimeUnit.SECONDS)\n         .subscribe(System.out::println);\n```", "```java\nSOURCE 1: 900\nSOURCE 2: 900\nSOURCE 3: 2000\n```", "```java\nObservable.concat(source1, source2, source3)\n         .throttleLast(2, TimeUnit.SECONDS)\n         .subscribe(System.out::println);\n```", "```java\nSOURCE 2: 900\nSOURCE 3: 2000\n```", "```java\nObservable.concat(source1, source2, source3)\n          .throttleLast(500, TimeUnit.MILLISECONDS)\n          .subscribe(System.out::println);\n```", "```java\nSOURCE 1: 400\nSOURCE 1: 900\nSOURCE 2: 300\nSOURCE 2: 900\nSOURCE 3: 2000\n```", "```java\nObservable.concat(source1, source2, source3)\n         .throttleFirst(1, TimeUnit.SECONDS)\n         .subscribe(System.out::println);\n```", "```java\nSOURCE 1: 100\nSOURCE 2: 300\nSOURCE 3: 2000\nSOURCE 3: 4000\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable<String> source1 = Observable.interval(100, TimeUnit.MILLISECONDS)\n                .map(i -> (i + 1) * 100) // map to elapsed time\n                .map(i -> \"SOURCE 1: \" + i)\n                .take(10);\n        Observable<String> source2 = Observable.interval(300, TimeUnit.MILLISECONDS)\n                .map(i -> (i + 1) * 300) // map to elapsed time\n                .map(i -> \"SOURCE 2: \" + i)\n                .take(3);\n        Observable<String> source3 = Observable.interval(2000, TimeUnit.MILLISECONDS)\n                .map(i -> (i + 1) * 2000) // map to elapsed time\n                .map(i -> \"SOURCE 3: \" + i)\n                .take(2);\n        Observable.concat(source1, source2, source3)\n                .throttleWithTimeout(1, TimeUnit.SECONDS)\n                .subscribe(System.out::println);\n        sleep(6000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\nSOURCE 2: 900\nSOURCE 3: 2000\nSOURCE 3: 4000\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n       Observable<String> items = Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\",\n                        \"Zeta\", \"Eta\", \"Theta\", \"Iota\");\n       //delay each String to emulate an intense calculation\n        Observable<String> processStrings = items.concatMap(s ->\n                Observable.just(s)\n                        .delay(randomSleepTime(), TimeUnit.MILLISECONDS)\n        );\n        processStrings.subscribe(System.out::println);\n        //keep application alive for 20 seconds\n        sleep(20000);\n    }\n    public static int randomSleepTime() {\n        //returns random sleep time between 0 to 2000 milliseconds\n        return ThreadLocalRandom.current().nextInt(2000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\nAlpha\nBeta\nGamma\nDelta\nEpsilon\nZeta\nEta\nTheta\nIota\n```", "```java\nimport io.reactivex.Observable;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\npublic class Launcher {\n    public static void main(String[] args) {\n        Observable<String> items = Observable.just(\"Alpha\", \"Beta\", \"Gamma\", \"Delta\", \"Epsilon\",\n                \"Zeta\", \"Eta\", \"Theta\", \"Iota\");\n        //delay each String to emulate an intense calculation\n        Observable<String> processStrings = items.concatMap(s ->\n                Observable.just(s)\n                        .delay(randomSleepTime(), TimeUnit.MILLISECONDS)\n        );\n        //run processStrings every 5 seconds, and kill each previous instance to start next\n        Observable.interval(5, TimeUnit.SECONDS)\n                .switchMap(i ->\n                        processStrings\n                                .doOnDispose(() -> System.out.println(\"Disposing! Starting next\"))\n                ).subscribe(System.out::println);\n        //keep application alive for 20 seconds\n        sleep(20000);\n    }\n    public static int randomSleepTime() {\n        //returns random sleep time between 0 to 2000 milliseconds\n        return ThreadLocalRandom.current().nextInt(2000);\n    }\n    public static void sleep(int millis) {\n        try {\n            Thread.sleep(millis);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```", "```java\nAlpha\nBeta\nGamma\nDelta\nEpsilon\nZeta\nEta\nDisposing! Starting next\nAlpha\nBeta\nGamma\nDelta\nDisposing! Starting next\nAlpha\nBeta\nGamma\nDelta\nDisposing! Starting next\n```", "```java\nimport io.reactivex.Observable;\nimport io.reactivex.rxjavafx.observables.JavaFxObservable;\nimport io.reactivex.rxjavafx.schedulers.JavaFxScheduler;\nimport javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.ToggleButton;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\nimport java.util.concurrent.TimeUnit;\npublic final class JavaFxApp extends Application {\n    @Override\n    public void start(Stage stage) throws Exception {\n        VBox root = new VBox();\n        Label counterLabel = new Label(\"\");\n        ToggleButton startStopButton = new ToggleButton();\n     // Multicast the ToggleButton's true/false selected state\n        Observable<Boolean> selectedStates =\nJavaFxObservable.valuesOf(startStopButton.selectedProperty())\n                        .publish()\n                        .autoConnect(2);\n     // Using switchMap() with ToggleButton's selected state will drive\n     // whether to kick off an Observable.interval(),\n     // or dispose() it by switching to empty Observable\n        selectedStates.switchMap(selected -> {\n                    if (selected)\n                        return Observable.interval(1, TimeUnit.MILLISECONDS);\n                    else\n                        return Observable.empty();\n                }).observeOn(JavaFxScheduler.platform()) // Observe on JavaFX UI thread\n                .map(Object::toString)\n                .subscribe(counterLabel::setText);\n        // Change ToggleButton's text depending on its state\n        selectedStates.subscribe(selected ->\n                startStopButton.setText(selected ? \"STOP\" : \"START\")\n        );\n        root.getChildren().addAll(counterLabel, startStopButton);\n        stage.setScene(new Scene(root));\n        stage.show();\n    }\n}\n```", "```java\nimport io.reactivex.Observable;\nimport io.reactivex.rxjavafx.observables.JavaFxObservable;\nimport io.reactivex.rxjavafx.schedulers.JavaFxScheduler;\nimport javafx.application.Application;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.input.KeyEvent;\nimport javafx.scene.layout.VBox;\nimport javafx.stage.Stage;\nimport java.util.concurrent.TimeUnit;\npublic final class JavaFxApp extends Application {\n    @Override\n    public void start(Stage stage) throws Exception {\n        VBox root = new VBox();\n        root.setMinSize(200, 100);\n        Label typedTextLabel = new Label(\"\");\n        root.getChildren().addAll(typedTextLabel);\n        Scene scene = new Scene(root);\n        // Multicast typed keys\n        Observable<String> typedLetters =\n                JavaFxObservable.eventsOf(scene, KeyEvent.KEY_TYPED)\n                    .map(KeyEvent::getCharacter)\n                    .share();\n        // Signal 300 milliseconds of inactivity\n        Observable<String> restSignal =\n                typedLetters\n                        .throttleWithTimeout(500, TimeUnit.MILLISECONDS)\n                        .startWith(\"\"); //trigger initial\n        // switchMap() each period of inactivity to\n        // an infinite scan() concatenating typed letters\n        restSignal.switchMap(s ->\n                typedLetters.scan(\"\", (rolling, next) -> rolling + next)\n        ).observeOn(JavaFxScheduler.platform())\n         .subscribe(s -> {\n            typedTextLabel.setText(s);\n            System.out.println(s);\n         });\n        stage.setScene(scene);\n        stage.show();\n    }\n}\n```", "```java\nH\nHe\nHel\nHell\nHello\nW\nWo\nWor\nWorl\nWorld\n```"]