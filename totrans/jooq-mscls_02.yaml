- en: '*Chapter 1*: Starting jOOQ and Spring Boot'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：启动jOOQ和Spring Boot'
- en: This chapter is a practical guide to start working with jOOQ (open source and
    free trial commercial) in Spring Boot applications. For convenience, let's assume
    that we have a Spring Boot stub application and plan to implement the persistence
    layer via jOOQ.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是使用jOOQ（开源和免费试用商业版）在Spring Boot应用程序中开始工作的实用指南。为了方便，让我们假设我们有一个Spring Boot占位符应用程序，并计划通过jOOQ实现持久层。
- en: The goal of this chapter is to highlight the fact that setting the environment
    for generating and executing SQL queries via jOOQ in a Spring Boot application
    is a job that can be accomplished almost instantly in any of the Java/Kotlin and
    Maven/Gradle combinations. Besides that, this is a good opportunity to have your
    first taste of the jOOQ DSL-fluent API and to get your first impressions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是强调在Spring Boot应用程序中通过jOOQ生成和执行SQL查询的环境设置几乎可以立即完成。除此之外，这也是体验jOOQ DSL流畅API并形成第一印象的好机会。
- en: 'The topics of this chapter include the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题包括以下内容：
- en: Starting jOOQ and Spring Boot instantly
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即启动jOOQ和Spring Boot
- en: Using the jOOQ query DSL API to generate a valid SQL statement
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用jOOQ查询DSL API生成有效的SQL语句
- en: Executing the generated SQL and mapping the result set to a POJO
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行生成的SQL并将结果集映射到POJO
- en: Let's get started!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter01](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，地址为[https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter01](https://github.com/PacktPublishing/jOOQ-Masterclass/tree/master/Chapter01)。
- en: Starting jOOQ and Spring Boot instantly
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 立即启动jOOQ和Spring Boot
- en: Spring Boot provides support for jOOQ, and this aspect is introduced in the
    Spring Boot official documentation under the *Using jOOQ* section. Having built-in
    support for jOOQ makes our mission easier, since, among other things, Spring Boot
    is capable of dealing with aspects that involve useful default configurations
    and settings.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供了对jOOQ的支持，这一点在Spring Boot官方文档的*使用jOOQ*部分中有所介绍。内置对jOOQ的支持使我们的任务变得更容易，因为Spring
    Boot能够处理涉及有用默认配置和设置的各种方面。
- en: Consider having a Spring Boot stub application that will run against MySQL and
    Oracle, and let's try to add jOOQ to this context. The goal is to use jOOQ as
    a SQL builder for constructing valid SQL statements and as a SQL executor that
    maps the result set to a POJO.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑有一个针对MySQL和Oracle运行的Spring Boot占位符应用程序，让我们尝试将jOOQ添加到这个环境中。目标是使用jOOQ作为SQL构建器来构建有效的SQL语句，并将其作为SQL执行器将结果集映射到POJO。
- en: Adding the jOOQ open source edition
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加jOOQ开源版
- en: Adding the jOOQ open source edition into a Spring Boot application is quite
    straightforward.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 将jOOQ开源版添加到Spring Boot应用程序中相当直接。
- en: Adding the jOOQ open source edition via Maven
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过Maven添加jOOQ开源版
- en: 'From the Maven perspective, adding the jOOQ open source edition into a Spring
    Boot application starts from the `pom.xml` file. The jOOQ open source edition
    dependency is available at Maven Central ([https://mvnrepository.com/artifact/org.jooq/jooq](https://mvnrepository.com/artifact/org.jooq/jooq))
    and can be added like this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从Maven的角度来看，将jOOQ开源版添加到Spring Boot应用程序是从`pom.xml`文件开始的。jOOQ开源版依赖项可在Maven Central（[https://mvnrepository.com/artifact/org.jooq/jooq](https://mvnrepository.com/artifact/org.jooq/jooq)）找到，可以添加如下：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Alternatively, if you prefer a Spring Boot starter, then rely on this one:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您更喜欢Spring Boot启动器，那么请依赖这个：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If you are a fan of Spring Initializr ([https://start.spring.io/](https://start.spring.io/)),
    then just select the jOOQ dependency from the corresponding list of dependencies.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是Spring Initializr（[https://start.spring.io/](https://start.spring.io/)）的粉丝，那么只需从相应的依赖项列表中选择jOOQ依赖项即可。
- en: That's all! Note that `<version>` is optional. If `<version>` is omitted, then
    Spring Boot will properly choose the jOOQ version compatible with the Spring Boot
    version used by the application. Nevertheless, whenever you want to try a different
    jOOQ version, you can simply add `<version>` explicitly. At this point, the jOOQ
    open source edition is ready to be used to start developing the persistence layer
    of an application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！请注意，`<version>`是可选的。如果省略`<version>`，则Spring Boot将正确选择与应用程序使用的Spring Boot版本兼容的jOOQ版本。不过，无论何时您想尝试不同的jOOQ版本，都可以简单地显式添加`<version>`。此时，jOOQ开源版已准备好用于开始开发应用程序的持久层。
- en: Adding the jOOQ open source edition via Gradle
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 Gradle 添加 jOOQ 开源版
- en: 'From the Gradle perspective, adding the jOOQ open source edition into a Spring
    Boot application can be accomplished via a plugin named `gradle-jooq-plugin` ([https://github.com/etiennestuder/gradle-jooq-plugin/](https://github.com/etiennestuder/gradle-jooq-plugin/)).
    This can be added to your `build.gradle`, as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Gradle 的角度来看，将 jOOQ 开源版添加到 Spring Boot 应用程序中可以通过一个名为 `gradle-jooq-plugin`
    的插件来实现 ([https://github.com/etiennestuder/gradle-jooq-plugin/](https://github.com/etiennestuder/gradle-jooq-plugin/))。这可以添加到你的
    `build.gradle` 文件中，如下所示：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, if you rely on Spring Initializr ([https://start.spring.io/](https://start.spring.io/)),
    then just select a Gradle project, add the jOOQ dependency from the corresponding
    list of dependencies, and once the project is generated, add the `gradle-jooq-plugin`
    plugin. As you'll see in the next chapter, using `gradle-jooq-plugin` is quite
    convenient for configuring the jOOQ Code Generator.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你依赖 Spring Initializr ([https://start.spring.io/](https://start.spring.io/))，那么只需选择一个
    Gradle 项目，从相应的依赖列表中添加 jOOQ 依赖项，一旦项目生成，就添加 `gradle-jooq-plugin` 插件。正如你将在下一章中看到的，使用
    `gradle-jooq-plugin` 配置 jOOQ 代码生成器非常方便。
- en: Adding a jOOQ free trial (commercial edition)
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 jOOQ 免费试用版（商业版）
- en: Adding a free trial commercial edition of jOOQ (jOOQ Express, Professional,
    and Enterprise editions) to a Spring Boot project (overall, in any other type
    of project) requires a few preliminary steps. Mainly, these steps are needed because
    the jOOQ free trial commercial distributions are not available on Maven Central,
    so you have to manually download the one that you need from the jOOQ download
    page ([https://www.jooq.org/download/](https://www.jooq.org/download/)). For instance,
    you can choose the most popular one, the jOOQ Professional distribution, which
    comes packaged as a ZIP archive. Once you have unzipped it, you can install it
    locally via the `maven-install` command. You can find these steps exemplified
    in a short movie in the bundled code (*Install_jOOQ_Trial.mp4*).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 将 jOOQ 免费试用版（商业版）添加到 Spring Boot 项目中（总的来说，在任意其他类型的项目中）需要几个初步步骤。主要因为这些步骤是必要的，因为
    jOOQ 免费试用版的商业发行版不在 Maven Central 上，所以你必须手动从 jOOQ 下载页面 ([https://www.jooq.org/download/](https://www.jooq.org/download/))
    下载你需要的版本。例如，你可以选择最受欢迎的版本，即 jOOQ 专业发行版，它被打包成一个 ZIP 归档。一旦解压，你可以通过 `maven-install`
    命令本地安装它。你可以在附带代码中的简短电影中找到这些步骤的示例（*Install_jOOQ_Trial.mp4*）。
- en: 'For Maven applications, we use the jOOQ free trial identified as `org.jooq.trial`
    (for Java 17) or `org.jooq.trial-java-{version}`. When this book was written,
    the `version` placeholder could be 8 or 11, but don''t hesitate to check for the
    latest updates. We prefer the former, so in `pom.xml`, we have the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Maven 应用程序，我们使用标识为 `org.jooq.trial`（针对 Java 17）或 `org.jooq.trial-java-{version}`
    的 jOOQ 免费试用版。当本书编写时，`version` 占位符可以是 8 或 11，但请不要犹豫去检查最新的更新。我们更倾向于前者，因此，在 `pom.xml`
    文件中，我们有以下内容：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For Java/Gradle, you can do it, as shown in the following example, via `gradle-jooq-plugin`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Java/Gradle，你可以像以下示例那样通过 `gradle-jooq-plugin` 来实现：
- en: '[PRE17]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For Kotlin/Gradle, you can do it like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Kotlin/Gradle，你可以这样做：
- en: '[PRE21]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this book, we will use jOOQ open source in applications that involve MySQL
    and PostgreSQL, and jOOQ free trial in applications that involve SQL Server and
    Oracle. These two database vendors are not supported in jOOQ open source.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将使用 jOOQ 开源版在涉及 MySQL 和 PostgreSQL 的应用程序中，以及在涉及 SQL Server 和 Oracle 的应用程序中使用
    jOOQ 免费试用版。这两个数据库供应商不支持 jOOQ 开源版。
- en: 'If you''re interested in adding jOOQ in a Quarkus project then consider this
    resource: [https://github.com/quarkiverse/quarkus-jooq](https://github.com/quarkiverse/quarkus-jooq)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣在 Quarkus 项目中添加 jOOQ，那么可以考虑这个资源：[https://github.com/quarkiverse/quarkus-jooq](https://github.com/quarkiverse/quarkus-jooq)
- en: Injecting DSLContext into Spring Boot repositories
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 DSLContext 注入 Spring Boot 仓库
- en: One of the most important interfaces of jOOQ is `org.jooq.DSLContext`. This
    interface represents the starting point of using jOOQ, and its main goal is to
    configure the behavior of jOOQ when executing queries. The default implementation
    of this interface is named `DefaultDSLContext`. Among the approaches, `DSLContext`
    can be created via an `org.jooq.Configuration` object, directly from a JDBC connection
    (`java.sql.Connection`), a data source (`javax.sql.DataSource`), and a dialect
    needed for translating the Java API query representation, written via jOOQ into
    a database-specific SQL query (`org.jooq.SQLDialect`).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ最重要的接口之一是`org.jooq.DSLContext`。此接口代表使用jOOQ的起点，其主要目标是配置jOOQ在执行查询时的行为。此接口的默认实现名为`DefaultDSLContext`。在多种方法中，`DSLContext`可以通过`org.jooq.Configuration`对象、直接从JDBC连接（`java.sql.Connection`）、数据源（`javax.sql.DataSource`）以及用于将Java
    API查询表示形式转换为特定数据库SQL查询的方言（`org.jooq.SQLDialect`）来创建。
- en: Important Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: For `java.sql.Connection`, jOOQ will give you full control of the connection
    life cycle (for example, you are responsible for closing this connection). On
    the other hand, connections acquired via `javax.sql.DataSource` will be automatically
    closed after query execution by jOOQ. Spring Boot loves data sources, therefore
    the connection management is already handled (acquire and return connection from/to
    the connection pool, transaction begin/commit/rollback, and so on).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`java.sql.Connection`，jOOQ将为您提供对连接生命周期的完全控制（例如，您负责关闭此连接）。另一方面，通过`javax.sql.DataSource`获取的连接将在jOOQ查询执行后自动关闭。Spring
    Boot喜欢数据源，因此连接管理已经处理（从连接池中获取和返回连接，事务开始/提交/回滚等）。
- en: 'All jOOQ objects, including `DSLContext`, are created from `org.jooq.impl.DSL`.
    For creating a `DSLContext`, the `DSL` class exposes a `static` method named `using()`,
    which comes in several flavors. Of these, the most notable are listed next:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的jOOQ对象，包括`DSLContext`，都是从`org.jooq.impl.DSL`创建的。为了创建`DSLContext`，`DSL`类公开了一个名为`using()`的`static`方法，它有多种形式。其中最值得注意的是以下列出的：
- en: '[PRE25]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'For example, connecting to the MySQL `classicmodels` database can be done as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，连接到MySQL的`classicmodels`数据库可以这样做：
- en: '[PRE29]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, you can connect via a data source:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以通过数据源进行连接：
- en: '[PRE38]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'For example, connecting to the MySQL `classicmodels` database via a data source
    can be done as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，通过数据源连接到MySQL的`classicmodels`数据库可以这样做：
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'But Spring Boot is capable of automatically preparing a ready-to-inject `DSLContext`
    based on our database settings. For example, Spring Boot can prepare `DSLContext`
    based on the MySQL database settings specified in `application.properties`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但Spring Boot能够根据我们的数据库设置自动准备一个可注入的`DSLContext`。例如，Spring Boot可以根据在`application.properties`中指定的MySQL数据库设置准备`DSLContext`：
- en: '[PRE48]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Once Spring Boot detects the jOOQ presence, it uses the preceding settings to
    create `org.jooq.Configuration`, which is used to prepare a ready-to-inject `DSLContext`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Spring Boot检测到jOOQ的存在，它将使用前面的设置来创建`org.jooq.Configuration`，该配置用于准备一个可注入的`DSLContext`。
- en: Important Note
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: While `DSLContext` has a high degree of configurability and flexibility, Spring
    Boot performs only the minimum effort to serve a default `DSLContext` that can
    be injected and used immediately. As you'll see in this book (but especially in
    the official jOOQ manual – [https://www.jooq.org/doc/latest/manual/](https://www.jooq.org/doc/latest/manual/)),
    `DSLContext` has tons of configurations and settings that allow taking control
    of almost anything that happens with our SQL statements.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`DSLContext`具有高度的可配置性和灵活性，但Spring Boot仅进行最小努力来提供默认的`DSLContext`，该`DSLContext`可以立即注入和使用。正如您将在本书中看到的那样（但尤其是在官方jOOQ手册中
    – [https://www.jooq.org/doc/latest/manual/](https://www.jooq.org/doc/latest/manual/))，`DSLContext`具有大量配置和设置，允许控制与我们的SQL语句相关的几乎所有操作。
- en: 'The `DSLContext` object provided by Spring Boot can be easily injected into
    our persistence repositories. For instance, the next snippet of code serves such
    a `DSLContext` object directly into `ClassicModelsRepository`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Boot提供的`DSLContext`对象可以轻松注入到我们的持久化仓库中。例如，以下代码片段直接将这样的`DSLContext`对象注入到`ClassicModelsRepository`中：
- en: '[PRE54]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Don't conclude here that the application needs to keep a reference to `DSLContext`.
    That can still be used directly in a local variable, as you saw earlier (which
    means that you can have as many `DSLContext` objects as you want). It only means
    that, in a Spring Boot application, for most common scenarios, it is more convenient
    to simply inject it as shown previously.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在这里得出结论，应用程序需要保留对 `DSLContext` 的引用。它仍然可以直接在局部变量中使用，就像你之前看到的那样（这意味着你可以有任意多的
    `DSLContext` 对象）。这只意味着，在 Spring Boot 应用程序中，对于大多数常见场景，简单地像之前那样注入它会更方便。
- en: Internally, jOOQ can use `java.sql.Statement` or `PreparedStatement`. By default,
    and for very good and strong reasons, jOOQ uses `PreparedStatement`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，jOOQ 可以使用 `java.sql.Statement` 或 `PreparedStatement`。默认情况下，并且出于非常好的原因，jOOQ
    使用 `PreparedStatement`。
- en: Typically, the `DSLContext` object is labeled as `ctx` (used in this book) or
    `dsl`. But, other names such as `dslContext`, `jooq`, and `sql` are also good
    choices. Basically, you name it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`DSLContext` 对象被标记为 `ctx`（本书中使用）或 `dsl`。但 `dslContext`、`jooq` 和 `sql` 等其他名称也是不错的选择。基本上，你可以随意命名。
- en: Okay, so far, so good! At this point, we have access to `DSLContext` provided
    out of the box by Spring Boot, based on our settings from `application.properties`.
    Next, let's see `DSLContext` at work via jOOQ's query DSL API.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，到目前为止，一切顺利！在这个时候，我们可以访问 Spring Boot 提供的 `DSLContext`，这是基于我们在 `application.properties`
    中的设置。接下来，让我们通过 jOOQ 的查询 DSL API 看看 `DSLContext` 的实际应用。
- en: Using the jOOQ query DSL API to generate valid SQL
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 jOOQ 查询 DSL API 生成有效的 SQL
- en: 'Using the jOOQ query DSL API to generate valid SQL is a good start for exploring
    the jOOQ world. Let''s take a simple SQL statement, and let''s express it via
    jOOQ. In other words, let''s use the jOOQ query DSL API to express a given SQL
    string query into the jOOQ object-oriented style. Consider the next SQL `SELECT`
    written in the MySQL dialect:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 jOOQ 查询 DSL API 生成有效的 SQL 是探索 jOOQ 世界的一个良好开端。让我们从一个简单的 SQL 语句开始，并通过 jOOQ
    来表达它。换句话说，让我们使用 jOOQ 查询 DSL API 将给定的 SQL 字符串查询表达为 jOOQ 面向对象的风格。考虑以下用 MySQL 语法编写的
    SQL `SELECT` 语句：
- en: '[PRE62]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'The SQL, ``SELECT * FROM `office` WHERE `territory` = ?``, is written as a
    plain string. This query can be generated by jOOQ if it is written via the DSL
    API, as follows (the value of the `territory` binding variable is supplied by
    the user):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 语句 ``SELECT * FROM `office` WHERE `territory` = ?`` 被写为一个普通的字符串。如果通过 DSL
    API 编写，jOOQ 可以生成此查询，如下所示（`territory` 绑定变量的值由用户提供）：
- en: '[PRE63]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Alternatively, if we want to have the `FROM` clause closer to SQL look, then
    we can write it as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们想让 `FROM` 子句更接近 SQL 的外观，我们可以这样写：
- en: '[PRE65]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Most schemas are case-insensitive, but there are databases such as MySQL and
    PostgreSQL that prefer mostly lowercase, while others such as Oracle prefer mostly
    uppercase. So, writing the preceding query in Oracle style can be done as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数模式都是不区分大小写的，但有一些数据库，如 MySQL 和 PostgreSQL，通常更倾向于小写，而其他数据库，如 Oracle，通常更倾向于大写。因此，按照
    Oracle 风格编写前面的查询可以这样做：
- en: '[PRE68]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Alternatively, you can write it via an explicit call of `from()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过显式调用 `from()` 来编写它：
- en: '[PRE70]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: The jOOQ fluent API is a piece of art that looks like fluent English and, therefore,
    is quite intuitive to read and write.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 流畅 API 是一件艺术品，看起来像流畅的英语，因此阅读和编写起来相当直观。
- en: 'Reading the preceding queries is pure English: *select all offices from the
    OFFICE table where the TERRITORY column is equal to the given value*.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的查询完全是英语：*从 OFFICE 表中选择所有办公室，其中 TERRITORY 列等于给定的值*。
- en: Pretty soon, you'll be amazed at how fast you can write these queries in jOOQ.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，你就会对在 jOOQ 中编写这些查询的速度感到惊讶。
- en: Important Note
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: As you'll see in the next chapter, jOOQ can generate a Java-based schema that
    mirrors the one in the database via a feature named the jOOQ Code Generator. Once
    this feature is enabled, writing these queries becomes even simpler and cleaner
    because there will be no need to reference the database schema explicitly, such
    as the table name or the table columns. Instead, we will reference the Java-based
    schema.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你将在下一章中看到的，jOOQ 可以通过名为 jOOQ 代码生成器的功能生成基于 Java 的模式，该模式与数据库中的模式相对应。一旦启用此功能，编写这些查询将变得更加简单和清晰，因为将不再需要显式引用数据库模式，例如表名或表列。相反，我们将引用基于
    Java 的模式。
- en: And, thanks to the Code Generator feature, jOOQ makes the right choices for
    us upfront almost everywhere. We no longer need to take care of queries' type-safety
    and case-sensitivity, or identifiers' quotation and qualification.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，多亏了代码生成器功能，jOOQ 在几乎所有地方都为我们提前做出了正确的选择。我们不再需要关心查询的类型安全性和大小写敏感性，或者标识符的引号和限定。
- en: The jOOQ Code Generator atomically boosts the jOOQ capabilities and increases
    developer productivity. This is why using the jOOQ Code Generator is the recommended
    way to exploit jOOQ. We will tackle the jOOQ Code Generator in the next chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 代码生成器原子性地提升了 jOOQ 的功能并增加了开发者的生产力。这就是为什么推荐使用 jOOQ 代码生成器来充分利用 jOOQ。我们将在下一章中探讨
    jOOQ 代码生成器。
- en: Next, the jOOQ query (`org.jooq.ResultQuery`) must be executed against the database,
    and the result set will be mapped to a user-defined simple POJO.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，必须对 jOOQ 查询（`org.jooq.ResultQuery`）执行数据库操作，并将结果集映射到用户定义的简单 POJO。
- en: Executing the generated SQL and mapping the result set
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行生成的 SQL 并映射结果集
- en: 'Executing the generated SQL and mapping the result set to a POJO via jOOQ can
    be done via the fetching methods available in the jOOQ API. For instance, the
    next snippet of code relies on the `fetchInto()` flavor:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 jOOQ 的 API 中的获取方法执行生成的 SQL 并将结果集映射到 POJO，可以这样做。例如，下面的代码片段依赖于 `fetchInto()`
    方法：
- en: '[PRE73]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'What happened there?! Where did `ResultQuery` go? Is this black magic? Obviously
    not! It''s just that jOOQ has immediately fetched results after constructing the
    query and mapped them to the `Office` POJO. Yes, the jOOQ''s `fetchInto(Office.class)`
    or `fetch().into(Office.class)` would work just fine out of the box. Mainly, jOOQ
    executes the query and maps the result set to the `Office` POJO by wrapping and
    abstracting the JDBC complexity in a more object-oriented way. If we don''t want
    to immediately fetch the results after constructing the query, then we can use
    the `ResultQuery` object like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 那里发生了什么？！`ResultQuery` 去哪里了？这是黑魔法吗？显然不是！只是 jOOQ 在构建查询后立即获取了结果并将它们映射到了 `Office`
    POJO。是的，jOOQ 的 `fetchInto(Office.class)` 或 `fetch().into(Office.class)` 会正常工作。主要的是，jOOQ
    通过以更面向对象的方式封装和抽象 JDBC 复杂性来执行查询并将结果集映射到 `Office` POJO。如果我们不想在构建查询后立即获取结果，则可以使用
    `ResultQuery` 对象如下：
- en: '[PRE79]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The `Office` POJO is available in the code bundled with this book.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Office` POJO 包含在这本书附带代码中。'
- en: Important Note
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: jOOQ has a comprehensive API for fetching and mapping a result set into collections,
    arrays, maps, and so on. We will detail these aspects later on in [*Chapter 8*](B16833_08.xhtml#_idTextAnchor128),
    *Fetching and Mapping*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ 提供了一个全面的 API，用于将结果集获取和映射到集合、数组、映射等。我们将在后面的[*第 8 章*](B16833_08.xhtml#_idTextAnchor128)“获取和映射”中详细说明这些方面。
- en: The complete application is named *DSLBuildExecuteSQL*. Since this can be used
    as a stub application, you can find it available for Java/Kotlin in combination
    with Maven/Gradle. These applications (along with, in fact, all the applications
    in this book) use Flyway for schema migration. As you'll see later, Flyway and
    jOOQ make a great team.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的应用程序命名为 *DSLBuildExecuteSQL*。由于这可以用作存根应用程序，您可以在 Java/Kotlin 与 Maven/Gradle
    的组合中找到它。这些应用程序（实际上，本书中的所有应用程序）使用 Flyway 进行模式迁移。您将看到，Flyway 和 jOOQ 是一对绝佳的搭档。
- en: So, let's quickly summarize this chapter before moving on to exploit the astonishing
    jOOQ Code Generator feature.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在继续利用令人惊叹的 jOOQ 代码生成器功能之前，让我们快速总结本章内容。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Note that we barely scratched the surface of jOOQ's capabilities by using it
    only for generating and executing a simple SQL statement. Nevertheless, we've
    already highlighted that jOOQ can generate valid SQL against different dialects
    and can execute and map a result set in a straightforward manner.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仅仅通过使用 jOOQ 生成和执行一个简单的 SQL 语句，就几乎触及了 jOOQ 功能的表面。尽管如此，我们已经强调 jOOQ 可以针对不同的方言生成有效的
    SQL，并且可以以直接的方式执行和映射结果集。
- en: In the next chapter, we learn how to trust jOOQ more by increasing its level
    of involvement. jOOQ will generate type-safe queries, POJOs, and DAOs on our behalf.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何通过增加 jOOQ 的参与程度来更加信任 jOOQ。jOOQ 将代表我们生成类型安全的查询、POJO 和 DAO。
