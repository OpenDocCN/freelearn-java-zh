- en: Lambda Leftovers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine the convenience of marking unused parameters in a method or lambda expression
    and not passing any arbitrary values to conform to the syntax. Also, when working
    with lambdas, imagine the ability to declare a lambda parameter name, without
    caring whether the same variable name has been used in the enclosing scope or
    not. This is what **lambda leftovers** (JEP 302) provide in order to enhance lambdas
    and method references. Apart from these enhancements, it will also offer better
    disambiguation of functional expressions in methods (this is marked as optional
    in the **JDK Enhancement Proposal** (**JEP**), as of right now).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Using underscores for unused method parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadowing lambda parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disambiguation of functional expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this chapter will use the features defined in lambda leftovers (JEP
    302), which has yet to be targeted for a JDK release version. To experiment with
    the code, you can clone the relevant repository.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: All of the code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by understanding why would you need to mark unused lambda
    parameters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Marking unused parameters with underscores
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that you are served four food items at a restaurant, but you don't eat
    three of them. If the restaurant has a protocol for customers to mark **ort**
    (which literally means *used*) and non-ort food items, the food from the table
    can be used in a certain manner. For example, the restaurant can mark the non-ort
    items as *good to eat*, and can consider sharing them with the needy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when calling a method or a lambda expression, you might not need
    all of the method parameters. In that case, communicating your intent to the compiler
    (that certain parameters aren't used) is a good idea. This has two benefits—it
    saves the compiler from type-checking the values that are not required, and it
    saves you from passing any arbitrary values to match the code definition and code-calling
    syntax.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: An example of lambda parameters
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example to demonstrate how you can use an `_` (underscore)
    to mark unused lambda parameters. The following code uses the `BiFunction<T, U,
    R>` functional interface which can accept two arguments (`T` and `U`), and returns
    a value of the type `R`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, since the lambda expression assigned to the `BiFunction` functional
    interface uses just one of the method parameters (that is, `age`), JEP 302 proposes
    using the underscore to mark the unused parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code highlights a few use cases to illustrate how you would use
    the same code without the convenience of marking unused lambda parameters (the
    comments state the value that the code is passing to the unused parameter):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A lot of other functional programming languages use a similar notation to mark
    unused parameters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: The journey of getting there
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using an underscore to mark unused parameters required changes in the Java language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Until Java 8, the underscore was used as a valid identifier. The first step
    was to deny permission to use an underscore as a regular identifier. So, Java
    8 issued a compiler warning for the usage of `_` as the name of formal parameters
    in lambdas. This was simple, and had no backward-compatibility issues since lambdas
    were introduced in Java 8\. Moving forward, Java 9 replaced the compiler warning
    message with compilation errors for using underscores as parameter names.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: 'With JEP 302, developers can use `_` to mark an unused method parameter for
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch handlers
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you'll see how (in the future) your lambda parameters will
    be able to shadow the variables with the same name in their enclosing scopes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing of lambda parameters
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java doesn't allow the declaration of variables with the same names in multiple
    scenarios. For instance, you can't define instance and static variables in a class
    with the same name. Similarly, you can't define method parameters and local variables
    with the same names in a method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: However, you can define local variables with the same names as an instance or
    `static` variables in a class. This doesn't mean that you can't access them later.
    To access an instance variable from a method, you can prefix the variable name
    with the `this` keyword.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: These restrictions allow you to access all of the variables within a scope.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: The existing case of lambda parameters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you write a lambda expression, you can define multiple parameters. The
    following are some examples of lambdas that define single or multiple parameters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s use one of the lambdas from the preceding code in stream processing.
    The following example will provide the string values from `List` as output, in
    uppercase:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, so good. But what happens if the preceding code is defined in a method
    (say, `process()`) with a local variable (say, `key` (code on line number `3`))
    that overlaps with the name of the `key`  lambda parameter (defined and used on
    the line number `5`)? See the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At present, the preceding code won't compile, because the `key` variable used
    in the lambda expression for the `map()` method can't overshadow the local `key` variable,
    defined in the `process()` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Why should lambda parameters overshadow enclosing variables?
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write a lambda expression, you (usually) define the parameter names
    as indicators of how the values assigned to them should be processed. They aren't
    meant to reuse the existing values, referred to by variables, in an enclosing
    block.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the preceding code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the lambda expression on line `3` (in bold) defines one
    lambda parameter, `key`, specifying that when a value is passed to it, Java should
    call the `toUpperCase()` method on it and return the resulting value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第`3`行（以粗体显示）的lambda表达式定义了一个lambda参数`key`，指定当传递一个值给它时，Java应该在该值上调用`toUpperCase()`方法并返回结果值。
- en: As is evident from this example, the `key` lambda parameter appears to be unrelated
    to the local `key` variable, defined in the enclosing block. So, the lambda parameters
    should be allowed to overshadow the variables with the same names in the enclosing
    block.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，`key` lambda参数似乎与在封闭块中定义的局部`key`变量无关。因此，lambda参数应该允许覆盖封闭块中具有相同名称的变量。
- en: A few of the known issues
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些已知的问题
- en: As of now, it isn't clear whether a lambda expression will be able to access
    the value of the enclosing variable, which is overshadowed by the lambda parameter;
    and if it can, how?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚不清楚lambda表达式是否能够访问被lambda参数覆盖的封闭变量的值；如果可以，它是如何做到的？
- en: 'For example, let''s modify the preceding code by replacing the call to the
    `toUppercase()` method with a call to the `concat()` method as follows (changes
    are in bold):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们通过将`toUppercase()`方法的调用替换为`concat()`方法的调用来修改前面的代码（变化以粗体显示）：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, imagine that the lambda expression on line `3` needs
    to access the value of the `key` variable defined on line `1`, since it wants
    to pass it to the `concat()` method. As of right now, it hasn't been finalized
    whether this will be allowed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，想象一下第`3`行的lambda表达式需要访问第`1`行定义的`key`变量的值，因为它想要将其传递给`concat()`方法。到目前为止，尚未最终确定这是否会被允许。
- en: If it is allowed, Java will need to devise a way to mark and clearly differentiate
    a lambda parameter from another variable with the same name, in the enclosing
    block. This will be required for code readability—which, as you know, is important.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许这样做，Java将需要找到一种方法来标记并清楚地区分lambda参数和封闭块中具有相同名称的其他变量。这将对于代码可读性是必要的——正如您所知，这是很重要的。
- en: The accessibility of the overshadowed enclosing variable is the main problem
    associated with shadowing of lambda parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 被覆盖的封闭变量的可访问性是与lambda参数覆盖相关的主要问题。
- en: In the next section, we'll look at how Java is trying to resolve overloaded
    method calls, which define functional interfaces as parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Java如何尝试解决重载方法调用，这些调用将函数式接口作为参数。
- en: Disambiguation of functional expressions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数表达式的歧义消除
- en: If you think Java started its journey through type inference with the `var`
    keyword (Java 10), think again. Type inference was introduced with Java 5 and
    has been increasing in coverage ever since.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为Java是通过`var`关键字（Java 10）开始其类型推断之旅的，那么您需要重新考虑。类型推断是在Java 5中引入的，并且从那时起一直在增加覆盖范围。
- en: With Java 8, the resolution of overloaded methods was restructured to allow
    for working with type inference. Before the introduction of lambdas and method
    references, a call to a method was resolved by checking the types of the arguments
    that were passed to it (the return type wasn't considered).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，重载方法的解析被重构，以便允许使用类型推断。在引入lambda表达式和方法引用之前，对方法的调用是通过检查传递给它的参数类型（不考虑返回类型）来解决的。
- en: With Java 8, implicit lambdas and implicit method references couldn't be checked
    for the types of values that they accepted, leading to restricted compiler capabilities,
    to rule out ambiguous calls to overloaded methods. However, explicit lambdas and
    method references could still be checked by their arguments by the compiler. For
    your information, the lambdas that explicitly specify the types of their parameters
    are termed **explicit lambdas**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，隐式lambda和隐式方法引用无法检查它们接受的值的类型，这导致了编译器能力的限制，以排除对重载方法的模糊调用。然而，编译器仍然可以通过其参数检查显式lambda和方法引用。为了您的信息，明确指定其参数类型的lambda被称为**显式lambda**。
- en: Limiting the compiler's ability and relaxing the rules in this way was purposeful.
    It lowered the cost of type-checking for lambdas and avoided brittleness.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 限制编译器的能力和以这种方式放宽规则是有意为之的。这降低了lambda类型检查的成本，并避免了脆弱性。
- en: Although it is an interesting feature, the disambiguation of functional expressions
    is slated as an optional feature in JEP 302, because Oracle needs to assess its
    impact on the compiler implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有趣的功能，但函数表达式的歧义消除被计划为JEP 302中的一个可选功能，因为Oracle需要评估其对编译器实现的影响。
- en: Before diving into the proposed solution, let's look at the existing issues,
    using code examples.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Issues with resolving overloaded methods – passing lambdas
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover the existing issues with resolving overloaded methods when lambdas
    are passed as method parameters. Let''s define two interfaces, `Swimmer` and `Diver`,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following code, the overloaded `evaluate` method accepts the interfaces
    `Swimmer` and `Diver` as method parameters:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s call the overloaded `evaluate()` method in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Revisit the lambda from the preceding code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the preceding lambda expression doesn't specify the type of its input
    parameter, it could be either `String` (the `test()` method and the `Swimmer` interface)
    or `int` (the `dive()` method and the `Diver` interface). Since the call to the
    `evaluate()` method is ambiguous, it doesn't compile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the type of the method parameter to the preceding code, making it
    an explicit lambda:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding call is not ambiguous now; the lambda expression accepts an input
    parameter of the `String` type and returns a `boolean` value, which maps to the
    `evaluate()` method which accepts `Swimmer` as a parameter (the functional `test()`
    method in the `Swimmer` interface accepts a parameter of the `String` type).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if the `Swimmer` interface is modified, changing the
    data type of the `lap` parameter from `String` to `int`. To avoid confusion, all
    of the code will be repeated, with the modifications in bold:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Consider the following code, thinking about which of the lines of code will
    compile:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, the code on both of the line numbers won't compile
    for the same reason—the compiler is unable to determine the call to the overloaded
    `evaluate()` method. Since both of the functional methods (that is, `test()` in
    the `Swimmer` interface and `dive()` in the `Diver` interface) accept one method
    parameter of the `int` type, it isn't feasible for the compiler to determine the
    method call.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you might argue that since the return types of `test()` and
    `dive()` are different, the compiler should be able to infer the correct calls.
    Just to reiterate, the return types of a method don't participate in method overloading.
    Overloaded methods must return in the count or type of their parameters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: The return type of methods doesn't participate in method overloading. Overloaded
    methods must return in the count or type of their parameters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Issues with resolving overloaded methods – passing method references
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can define overloaded methods with different parameter types, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, the following code doesn''t compile:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding line of code, since the compiler is not allowed to examine
    the method reference, the code fails to compile. This is unfortunate since the
    method parameters to the overloaded methods are `Integer` and `String`—no value
    can be compatible with both.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The proposed solution
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The accidental compiler issues involved with overloaded methods that use either
    lambda expressions or method references can be resolved by allowing the compiler
    to consider their return type as `also`. The compiler would then be able to choose
    the right overloaded method and eliminate the unmatched option.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用lambda表达式或方法引用的重载方法，涉及到的意外编译问题可以通过允许编译器将它们的返回类型视为“也”来解决。然后编译器就能够选择正确的重载方法并消除不匹配的选项。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: For Java developers working with lambdas and method references, this chapter
    demonstrates what Java has in the pipeline to help ease problems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用lambda和方法引用的Java开发者，本章展示了Java在管道中有什么可以帮助缓解问题的计划。
- en: Lambda Leftovers (JEP 302) proposes using an underscore for unused parameters
    in lambdas, methods, and catch handlers. It plans to allow developers to define
    lambda parameters that can overshadow variables with the same name in their enclosing
    block. The disambiguation of functional expressions is an important and powerful
    feature. It will allow compilers to consider the return types of lambdas in order
    to determine the right overloaded methods. Since it can affect how the compilers
    work, this feature is marked as optional in this JEP.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda Leftovers (JEP 302) 提出在lambda、方法和catch处理程序中使用下划线来表示未使用的参数。它计划允许开发者定义可以覆盖其封闭块中同名变量的lambda参数。功能表达式的歧义消除是一个重要且强大的功能。它将允许编译器考虑lambda的返回类型，以确定正确的重载方法。由于它可能影响编译器的工作方式，因此这个特性在这个JEP中被标记为可选。
- en: In the next chapter, which is on pattern matching and switch expressions, you'll
    get to know the exciting capabilities that are being added to the Java language.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，关于模式匹配和switch表达式的章节中，你将了解正在添加到Java语言中的令人兴奋的功能。
- en: This chapter didn't include any coding exercises for the reader. The return
    type of methods doesn't participate in method overloading. Overloaded methods
    must return in the count or type of their parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有为读者包含任何编码练习。方法的重载不涉及方法的返回类型。重载的方法必须通过其参数的数量或类型来返回。
