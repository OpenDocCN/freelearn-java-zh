- en: Lambda Leftovers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 剩余
- en: Imagine the convenience of marking unused parameters in a method or lambda expression
    and not passing any arbitrary values to conform to the syntax. Also, when working
    with lambdas, imagine the ability to declare a lambda parameter name, without
    caring whether the same variable name has been used in the enclosing scope or
    not. This is what **lambda leftovers** (JEP 302) provide in order to enhance lambdas
    and method references. Apart from these enhancements, it will also offer better
    disambiguation of functional expressions in methods (this is marked as optional
    in the **JDK Enhancement Proposal** (**JEP**), as of right now).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下在方法或 lambda 表达式中标记未使用参数的便利性，并且不需要传递任何任意值以符合语法。此外，当与 lambda 一起工作时，想象一下声明
    lambda 参数名称的能力，而不必关心在封装作用域中是否已经使用了相同的变量名。这就是 **lambda 剩余**（JEP 302）提供的内容，以增强 lambda
    和方法引用。除了这些增强功能之外，它还将提供更好的方法中函数表达式的去歧义（这在 **JDK 增强提案**（**JEP**）中被标记为可选，截至目前）。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using underscores for unused method parameters
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用下划线标记未使用的方法参数
- en: Shadowing lambda parameters
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏 lambda 参数
- en: Disambiguation of functional expressions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数表达式去歧义
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code in this chapter will use the features defined in lambda leftovers (JEP
    302), which has yet to be targeted for a JDK release version. To experiment with
    the code, you can clone the relevant repository.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码将使用 lambda 剩余（JEP 302）中定义的功能，该功能尚未针对 JDK 发布版本进行目标化。要实验代码，你可以克隆相关的仓库。
- en: All of the code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有代码都可以在 [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features)
    上访问。
- en: Let's get started by understanding why would you need to mark unused lambda
    parameters.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从了解为什么需要标记未使用的 lambda 参数开始。
- en: Marking unused parameters with underscores
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用下划线标记未使用参数
- en: Suppose that you are served four food items at a restaurant, but you don't eat
    three of them. If the restaurant has a protocol for customers to mark **ort**
    (which literally means *used*) and non-ort food items, the food from the table
    can be used in a certain manner. For example, the restaurant can mark the non-ort
    items as *good to eat*, and can consider sharing them with the needy.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在餐厅被提供了四种食物，但你没有吃掉其中的三种。如果餐厅有让顾客标记 **ort**（字面意思是 *已使用*）和非 ort 食物的协议，那么桌上的食物可以以某种方式使用。例如，餐厅可以将非
    ort 项目标记为 *可食用*，并考虑与需要的人分享。
- en: Similarly, when calling a method or a lambda expression, you might not need
    all of the method parameters. In that case, communicating your intent to the compiler
    (that certain parameters aren't used) is a good idea. This has two benefits—it
    saves the compiler from type-checking the values that are not required, and it
    saves you from passing any arbitrary values to match the code definition and code-calling
    syntax.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在调用方法或 lambda 表达式时，你可能不需要所有的方法参数。在这种情况下，向编译器传达你的意图（即某些参数没有被使用）是一个好主意。这有两个好处——它节省了编译器检查不必要值的类型检查，并且它节省了你传递任何任意值以匹配代码定义和代码调用语法的麻烦。
- en: An example of lambda parameters
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: lambda 参数的示例
- en: 'The following is an example to demonstrate how you can use an `_` (underscore)
    to mark unused lambda parameters. The following code uses the `BiFunction<T, U,
    R>` functional interface which can accept two arguments (`T` and `U`), and returns
    a value of the type `R`:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，演示了如何使用下划线 `_` 来标记未使用的 lambda 参数。以下代码使用了可以接受两个参数（`T` 和 `U`）并返回类型为 `R`
    的值的 `BiFunction<T, U, R>` 函数式接口：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding example, since the lambda expression assigned to the `BiFunction` functional
    interface uses just one of the method parameters (that is, `age`), JEP 302 proposes
    using the underscore to mark the unused parameter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，由于分配给 `BiFunction` 函数式接口的 lambda 表达式只使用了其中一个方法参数（即 `age`），JEP 302 建议使用下划线来标记未使用的参数。
- en: 'The following code highlights a few use cases to illustrate how you would use
    the same code without the convenience of marking unused lambda parameters (the
    comments state the value that the code is passing to the unused parameter):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码突出了一些用例，以说明在没有标记未使用的 lambda 参数的便利性下，如何使用相同的代码（注释说明了代码传递给未使用参数的值）：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: A lot of other functional programming languages use a similar notation to mark
    unused parameters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他函数式编程语言使用类似的符号来标记未使用的参数。
- en: The journey of getting there
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到达那里的旅程
- en: Using an underscore to mark unused parameters required changes in the Java language.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下划线标记未使用参数需要对 Java 语言进行更改。
- en: Until Java 8, the underscore was used as a valid identifier. The first step
    was to deny permission to use an underscore as a regular identifier. So, Java
    8 issued a compiler warning for the usage of `_` as the name of formal parameters
    in lambdas. This was simple, and had no backward-compatibility issues since lambdas
    were introduced in Java 8\. Moving forward, Java 9 replaced the compiler warning
    message with compilation errors for using underscores as parameter names.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 Java 8，下划线被用作有效的标识符。第一步是拒绝使用下划线作为常规标识符的权限。因此，Java 8 对使用 `_` 作为 lambda 形参名称的用法发出了编译器警告。这是简单的，并且没有向后兼容性问题，因为
    lambda 在 Java 8 中被引入。继续前进，Java 9 将使用下划线作为参数名称的编译器警告消息替换为编译错误。
- en: 'With JEP 302, developers can use `_` to mark an unused method parameter for
    the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 JEP 302，开发者可以使用 `_` 来标记未使用的方法参数，用于以下情况：
- en: Lambdas
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambdas
- en: Methods
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法
- en: Catch handlers
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获处理器
- en: In the next section, you'll see how (in the future) your lambda parameters will
    be able to shadow the variables with the same name in their enclosing scopes.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将看到（在将来）你的 lambda 参数将能够遮蔽其封闭作用域中具有相同名称的变量。
- en: Shadowing of lambda parameters
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Lambda 参数的遮蔽
- en: Java doesn't allow the declaration of variables with the same names in multiple
    scenarios. For instance, you can't define instance and static variables in a class
    with the same name. Similarly, you can't define method parameters and local variables
    with the same names in a method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java 不允许在多个场景下声明具有相同名称的变量。例如，你无法在具有相同名称的类中定义实例和静态变量。同样，你无法在方法中定义具有相同名称的方法参数和局部变量。
- en: However, you can define local variables with the same names as an instance or
    `static` variables in a class. This doesn't mean that you can't access them later.
    To access an instance variable from a method, you can prefix the variable name
    with the `this` keyword.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以定义与类中的实例或 `static` 变量具有相同名称的局部变量。这并不意味着你以后不能访问它们。要从方法中访问实例变量，你可以在变量名称前加上
    `this` 关键字。
- en: These restrictions allow you to access all of the variables within a scope.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些限制允许你访问作用域内的所有变量。
- en: The existing case of lambda parameters
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现有的 lambda 参数案例
- en: 'When you write a lambda expression, you can define multiple parameters. The
    following are some examples of lambdas that define single or multiple parameters:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 lambda 表达式时，你可以定义多个参数。以下是一些定义单个或多个参数的 lambda 示例：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s use one of the lambdas from the preceding code in stream processing.
    The following example will provide the string values from `List` as output, in
    uppercase:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用前面代码中的一个 lambda 来进行流处理。以下示例将提供 `List` 中的字符串值作为输出，并转换为大写：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So far, so good. But what happens if the preceding code is defined in a method
    (say, `process()`) with a local variable (say, `key` (code on line number `3`))
    that overlaps with the name of the `key`  lambda parameter (defined and used on
    the line number `5`)? See the following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但是，如果前面的代码定义在具有局部变量（例如，`key`（在第 3 行的代码上））的方法（例如，`process()`）中，并且该局部变量与
    `key` lambda 参数（在第 5 行定义和使用）的名称重叠，会发生什么？请看以下代码：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At present, the preceding code won't compile, because the `key` variable used
    in the lambda expression for the `map()` method can't overshadow the local `key` variable,
    defined in the `process()` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，前面的代码无法编译，因为用于 `map()` 方法的 lambda 表达式中的 `key` 变量无法遮蔽在 `process()` 方法中定义的局部
    `key` 变量。
- en: Why should lambda parameters overshadow enclosing variables?
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么 lambda 参数应该遮蔽封闭变量？
- en: When you write a lambda expression, you (usually) define the parameter names
    as indicators of how the values assigned to them should be processed. They aren't
    meant to reuse the existing values, referred to by variables, in an enclosing
    block.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写 lambda 表达式时，你（通常）定义参数名称作为指示如何处理分配给它们的值的指示符。它们不是用来在封闭块中重用由变量引用的现有值的。
- en: 'Let''s revisit the preceding code:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下前面的代码：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, the lambda expression on line `3` (in bold) defines one
    lambda parameter, `key`, specifying that when a value is passed to it, Java should
    call the `toUpperCase()` method on it and return the resulting value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，第`3`行（以粗体显示）的lambda表达式定义了一个lambda参数`key`，指定当传递一个值给它时，Java应该在该值上调用`toUpperCase()`方法并返回结果值。
- en: As is evident from this example, the `key` lambda parameter appears to be unrelated
    to the local `key` variable, defined in the enclosing block. So, the lambda parameters
    should be allowed to overshadow the variables with the same names in the enclosing
    block.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个例子中可以看出，`key` lambda参数似乎与在封闭块中定义的局部`key`变量无关。因此，lambda参数应该允许覆盖封闭块中具有相同名称的变量。
- en: A few of the known issues
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些已知的问题
- en: As of now, it isn't clear whether a lambda expression will be able to access
    the value of the enclosing variable, which is overshadowed by the lambda parameter;
    and if it can, how?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚不清楚lambda表达式是否能够访问被lambda参数覆盖的封闭变量的值；如果可以，它是如何做到的？
- en: 'For example, let''s modify the preceding code by replacing the call to the
    `toUppercase()` method with a call to the `concat()` method as follows (changes
    are in bold):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们通过将`toUppercase()`方法的调用替换为`concat()`方法的调用来修改前面的代码（变化以粗体显示）：
- en: '[PRE6]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, imagine that the lambda expression on line `3` needs
    to access the value of the `key` variable defined on line `1`, since it wants
    to pass it to the `concat()` method. As of right now, it hasn't been finalized
    whether this will be allowed.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，想象一下第`3`行的lambda表达式需要访问第`1`行定义的`key`变量的值，因为它想要将其传递给`concat()`方法。到目前为止，尚未最终确定这是否会被允许。
- en: If it is allowed, Java will need to devise a way to mark and clearly differentiate
    a lambda parameter from another variable with the same name, in the enclosing
    block. This will be required for code readability—which, as you know, is important.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许这样做，Java将需要找到一种方法来标记并清楚地区分lambda参数和封闭块中具有相同名称的其他变量。这将对于代码可读性是必要的——正如您所知，这是很重要的。
- en: The accessibility of the overshadowed enclosing variable is the main problem
    associated with shadowing of lambda parameters.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 被覆盖的封闭变量的可访问性是与lambda参数覆盖相关的主要问题。
- en: In the next section, we'll look at how Java is trying to resolve overloaded
    method calls, which define functional interfaces as parameters.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨Java如何尝试解决重载方法调用，这些调用将函数式接口作为参数。
- en: Disambiguation of functional expressions
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数表达式的歧义消除
- en: If you think Java started its journey through type inference with the `var`
    keyword (Java 10), think again. Type inference was introduced with Java 5 and
    has been increasing in coverage ever since.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为Java是通过`var`关键字（Java 10）开始其类型推断之旅的，那么您需要重新考虑。类型推断是在Java 5中引入的，并且从那时起一直在增加覆盖范围。
- en: With Java 8, the resolution of overloaded methods was restructured to allow
    for working with type inference. Before the introduction of lambdas and method
    references, a call to a method was resolved by checking the types of the arguments
    that were passed to it (the return type wasn't considered).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，重载方法的解析被重构，以便允许使用类型推断。在引入lambda表达式和方法引用之前，对方法的调用是通过检查传递给它的参数类型（不考虑返回类型）来解决的。
- en: With Java 8, implicit lambdas and implicit method references couldn't be checked
    for the types of values that they accepted, leading to restricted compiler capabilities,
    to rule out ambiguous calls to overloaded methods. However, explicit lambdas and
    method references could still be checked by their arguments by the compiler. For
    your information, the lambdas that explicitly specify the types of their parameters
    are termed **explicit lambdas**.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java 8中，隐式lambda和隐式方法引用无法检查它们接受的值的类型，这导致了编译器能力的限制，以排除对重载方法的模糊调用。然而，编译器仍然可以通过其参数检查显式lambda和方法引用。为了您的信息，明确指定其参数类型的lambda被称为**显式lambda**。
- en: Limiting the compiler's ability and relaxing the rules in this way was purposeful.
    It lowered the cost of type-checking for lambdas and avoided brittleness.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 限制编译器的能力和以这种方式放宽规则是有意为之的。这降低了lambda类型检查的成本，并避免了脆弱性。
- en: Although it is an interesting feature, the disambiguation of functional expressions
    is slated as an optional feature in JEP 302, because Oracle needs to assess its
    impact on the compiler implementation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有趣的功能，但函数表达式的歧义消除被计划为JEP 302中的一个可选功能，因为Oracle需要评估其对编译器实现的影响。
- en: Before diving into the proposed solution, let's look at the existing issues,
    using code examples.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入研究提出的解决方案之前，让我们看看现有的问题，使用代码示例。
- en: Issues with resolving overloaded methods – passing lambdas
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决重载方法解析问题——传递 lambda 表达式
- en: 'Let''s cover the existing issues with resolving overloaded methods when lambdas
    are passed as method parameters. Let''s define two interfaces, `Swimmer` and `Diver`,
    as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下当 lambda 表达式作为方法参数传递时解决重载方法解析的现有问题。让我们定义两个接口，`Swimmer` 和 `Diver`，如下所示：
- en: '[PRE7]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the following code, the overloaded `evaluate` method accepts the interfaces
    `Swimmer` and `Diver` as method parameters:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，重载的 `evaluate` 方法接受 `Swimmer` 和 `Diver` 接口作为方法参数：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s call the overloaded `evaluate()` method in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在以下代码中调用重载的 `evaluate()` 方法：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Revisit the lambda from the preceding code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重新审视先前的代码中的 lambda：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the preceding lambda expression doesn't specify the type of its input
    parameter, it could be either `String` (the `test()` method and the `Swimmer` interface)
    or `int` (the `dive()` method and the `Diver` interface). Since the call to the
    `evaluate()` method is ambiguous, it doesn't compile.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于先前的 lambda 表达式没有指定其输入参数的类型，它可以是 `String`（`test()` 方法和 `Swimmer` 接口）或 `int`（`dive()`
    方法和 `Diver` 接口）。由于调用 `evaluate()` 方法的调用是模糊的，所以无法编译。
- en: 'Let''s add the type of the method parameter to the preceding code, making it
    an explicit lambda:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在先前的代码中添加方法参数的类型，使其成为一个显式的 lambda：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding call is not ambiguous now; the lambda expression accepts an input
    parameter of the `String` type and returns a `boolean` value, which maps to the
    `evaluate()` method which accepts `Swimmer` as a parameter (the functional `test()`
    method in the `Swimmer` interface accepts a parameter of the `String` type).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在先前的调用不再模糊不清；lambda 表达式接受一个 `String` 类型的输入参数，并返回一个 `boolean` 值，这映射到接受 `Swimmer`
    作为参数的 `evaluate()` 方法（`Swimmer` 接口中的功能 `test()` 方法接受一个 `String` 类型的参数）。
- en: 'Let''s see what happens if the `Swimmer` interface is modified, changing the
    data type of the `lap` parameter from `String` to `int`. To avoid confusion, all
    of the code will be repeated, with the modifications in bold:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如果将 `Swimmer` 接口修改为将 `lap` 参数的数据类型从 `String` 改为 `int` 会发生什么。为了避免混淆，所有代码将重复，修改的地方用粗体标出：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Consider the following code, thinking about which of the lines of code will
    compile:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，思考哪一行代码可以编译：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding example, the code on both of the line numbers won't compile
    for the same reason—the compiler is unable to determine the call to the overloaded
    `evaluate()` method. Since both of the functional methods (that is, `test()` in
    the `Swimmer` interface and `dive()` in the `Diver` interface) accept one method
    parameter of the `int` type, it isn't feasible for the compiler to determine the
    method call.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，两个行号上的代码都无法编译，原因相同——编译器无法确定对重载的 `evaluate()` 方法的调用。由于两个功能方法（即 `Swimmer`
    接口中的 `test()` 和 `Diver` 接口中的 `dive()`）都接受一个 `int` 类型的单个方法参数，编译器无法确定方法调用。
- en: As a developer, you might argue that since the return types of `test()` and
    `dive()` are different, the compiler should be able to infer the correct calls.
    Just to reiterate, the return types of a method don't participate in method overloading.
    Overloaded methods must return in the count or type of their parameters.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一名开发者，你可能会争辩说，由于 `test()` 和 `dive()` 方法的返回类型不同，编译器应该能够推断出正确的调用。只是为了重申，方法的返回类型不参与方法重载。重载方法必须在参数的数量或类型上返回。
- en: The return type of methods doesn't participate in method overloading. Overloaded
    methods must return in the count or type of their parameters.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的返回类型不参与方法重载。重载方法必须在参数的数量或类型上返回。
- en: Issues with resolving overloaded methods – passing method references
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决重载方法解析问题——传递方法引用
- en: 'You can define overloaded methods with different parameter types, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以定义具有不同参数类型的重载方法，如下所示：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'However, the following code doesn''t compile:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，以下代码无法编译：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the preceding line of code, since the compiler is not allowed to examine
    the method reference, the code fails to compile. This is unfortunate since the
    method parameters to the overloaded methods are `Integer` and `String`—no value
    can be compatible with both.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的代码行中，由于编译器不允许检查方法引用，代码无法编译。这是不幸的，因为重载方法的参数是 `Integer` 和 `String`——没有值可以与两者兼容。
- en: The proposed solution
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提出的解决方案
- en: The accidental compiler issues involved with overloaded methods that use either
    lambda expressions or method references can be resolved by allowing the compiler
    to consider their return type as `also`. The compiler would then be able to choose
    the right overloaded method and eliminate the unmatched option.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用lambda表达式或方法引用的重载方法，涉及到的意外编译问题可以通过允许编译器将它们的返回类型视为“也”来解决。然后编译器就能够选择正确的重载方法并消除不匹配的选项。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: For Java developers working with lambdas and method references, this chapter
    demonstrates what Java has in the pipeline to help ease problems.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用lambda和方法引用的Java开发者，本章展示了Java在管道中有什么可以帮助缓解问题的计划。
- en: Lambda Leftovers (JEP 302) proposes using an underscore for unused parameters
    in lambdas, methods, and catch handlers. It plans to allow developers to define
    lambda parameters that can overshadow variables with the same name in their enclosing
    block. The disambiguation of functional expressions is an important and powerful
    feature. It will allow compilers to consider the return types of lambdas in order
    to determine the right overloaded methods. Since it can affect how the compilers
    work, this feature is marked as optional in this JEP.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda Leftovers (JEP 302) 提出在lambda、方法和catch处理程序中使用下划线来表示未使用的参数。它计划允许开发者定义可以覆盖其封闭块中同名变量的lambda参数。功能表达式的歧义消除是一个重要且强大的功能。它将允许编译器考虑lambda的返回类型，以确定正确的重载方法。由于它可能影响编译器的工作方式，因此这个特性在这个JEP中被标记为可选。
- en: In the next chapter, which is on pattern matching and switch expressions, you'll
    get to know the exciting capabilities that are being added to the Java language.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，关于模式匹配和switch表达式的章节中，你将了解正在添加到Java语言中的令人兴奋的功能。
- en: This chapter didn't include any coding exercises for the reader. The return
    type of methods doesn't participate in method overloading. Overloaded methods
    must return in the count or type of their parameters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有为读者包含任何编码练习。方法的重载不涉及方法的返回类型。重载的方法必须通过其参数的数量或类型来返回。
