- en: Lambda Leftovers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine the convenience of marking unused parameters in a method or lambda expression
    and not passing any arbitrary values to conform to the syntax. Also, when working
    with lambdas, imagine the ability to declare a lambda parameter name, without
    caring whether the same variable name has been used in the enclosing scope or
    not. This is what **lambda leftovers** (JEP 302) provide in order to enhance lambdas
    and method references. Apart from these enhancements, it will also offer better
    disambiguation of functional expressions in methods (this is marked as optional
    in the **JDK Enhancement Proposal** (**JEP**), as of right now).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using underscores for unused method parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadowing lambda parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disambiguation of functional expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code in this chapter will use the features defined in lambda leftovers (JEP
    302), which has yet to be targeted for a JDK release version. To experiment with
    the code, you can clone the relevant repository.
  prefs: []
  type: TYPE_NORMAL
- en: All of the code in this chapter can be accessed at [https://github.com/PacktPublishing/Java-11-and-12-New-Features](https://github.com/PacktPublishing/Java-11-and-12-New-Features).
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started by understanding why would you need to mark unused lambda
    parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Marking unused parameters with underscores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Suppose that you are served four food items at a restaurant, but you don't eat
    three of them. If the restaurant has a protocol for customers to mark **ort**
    (which literally means *used*) and non-ort food items, the food from the table
    can be used in a certain manner. For example, the restaurant can mark the non-ort
    items as *good to eat*, and can consider sharing them with the needy.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when calling a method or a lambda expression, you might not need
    all of the method parameters. In that case, communicating your intent to the compiler
    (that certain parameters aren't used) is a good idea. This has two benefits—it
    saves the compiler from type-checking the values that are not required, and it
    saves you from passing any arbitrary values to match the code definition and code-calling
    syntax.
  prefs: []
  type: TYPE_NORMAL
- en: An example of lambda parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is an example to demonstrate how you can use an `_` (underscore)
    to mark unused lambda parameters. The following code uses the `BiFunction<T, U,
    R>` functional interface which can accept two arguments (`T` and `U`), and returns
    a value of the type `R`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, since the lambda expression assigned to the `BiFunction` functional
    interface uses just one of the method parameters (that is, `age`), JEP 302 proposes
    using the underscore to mark the unused parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code highlights a few use cases to illustrate how you would use
    the same code without the convenience of marking unused lambda parameters (the
    comments state the value that the code is passing to the unused parameter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A lot of other functional programming languages use a similar notation to mark
    unused parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The journey of getting there
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using an underscore to mark unused parameters required changes in the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: Until Java 8, the underscore was used as a valid identifier. The first step
    was to deny permission to use an underscore as a regular identifier. So, Java
    8 issued a compiler warning for the usage of `_` as the name of formal parameters
    in lambdas. This was simple, and had no backward-compatibility issues since lambdas
    were introduced in Java 8\. Moving forward, Java 9 replaced the compiler warning
    message with compilation errors for using underscores as parameter names.
  prefs: []
  type: TYPE_NORMAL
- en: 'With JEP 302, developers can use `_` to mark an unused method parameter for
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Catch handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you'll see how (in the future) your lambda parameters will
    be able to shadow the variables with the same name in their enclosing scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing of lambda parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java doesn't allow the declaration of variables with the same names in multiple
    scenarios. For instance, you can't define instance and static variables in a class
    with the same name. Similarly, you can't define method parameters and local variables
    with the same names in a method.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can define local variables with the same names as an instance or
    `static` variables in a class. This doesn't mean that you can't access them later.
    To access an instance variable from a method, you can prefix the variable name
    with the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: These restrictions allow you to access all of the variables within a scope.
  prefs: []
  type: TYPE_NORMAL
- en: The existing case of lambda parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you write a lambda expression, you can define multiple parameters. The
    following are some examples of lambdas that define single or multiple parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use one of the lambdas from the preceding code in stream processing.
    The following example will provide the string values from `List` as output, in
    uppercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good. But what happens if the preceding code is defined in a method
    (say, `process()`) with a local variable (say, `key` (code on line number `3`))
    that overlaps with the name of the `key`  lambda parameter (defined and used on
    the line number `5`)? See the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At present, the preceding code won't compile, because the `key` variable used
    in the lambda expression for the `map()` method can't overshadow the local `key` variable,
    defined in the `process()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Why should lambda parameters overshadow enclosing variables?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you write a lambda expression, you (usually) define the parameter names
    as indicators of how the values assigned to them should be processed. They aren't
    meant to reuse the existing values, referred to by variables, in an enclosing
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s revisit the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the lambda expression on line `3` (in bold) defines one
    lambda parameter, `key`, specifying that when a value is passed to it, Java should
    call the `toUpperCase()` method on it and return the resulting value.
  prefs: []
  type: TYPE_NORMAL
- en: As is evident from this example, the `key` lambda parameter appears to be unrelated
    to the local `key` variable, defined in the enclosing block. So, the lambda parameters
    should be allowed to overshadow the variables with the same names in the enclosing
    block.
  prefs: []
  type: TYPE_NORMAL
- en: A few of the known issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of now, it isn't clear whether a lambda expression will be able to access
    the value of the enclosing variable, which is overshadowed by the lambda parameter;
    and if it can, how?
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s modify the preceding code by replacing the call to the
    `toUppercase()` method with a call to the `concat()` method as follows (changes
    are in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, imagine that the lambda expression on line `3` needs
    to access the value of the `key` variable defined on line `1`, since it wants
    to pass it to the `concat()` method. As of right now, it hasn't been finalized
    whether this will be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: If it is allowed, Java will need to devise a way to mark and clearly differentiate
    a lambda parameter from another variable with the same name, in the enclosing
    block. This will be required for code readability—which, as you know, is important.
  prefs: []
  type: TYPE_NORMAL
- en: The accessibility of the overshadowed enclosing variable is the main problem
    associated with shadowing of lambda parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll look at how Java is trying to resolve overloaded
    method calls, which define functional interfaces as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Disambiguation of functional expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you think Java started its journey through type inference with the `var`
    keyword (Java 10), think again. Type inference was introduced with Java 5 and
    has been increasing in coverage ever since.
  prefs: []
  type: TYPE_NORMAL
- en: With Java 8, the resolution of overloaded methods was restructured to allow
    for working with type inference. Before the introduction of lambdas and method
    references, a call to a method was resolved by checking the types of the arguments
    that were passed to it (the return type wasn't considered).
  prefs: []
  type: TYPE_NORMAL
- en: With Java 8, implicit lambdas and implicit method references couldn't be checked
    for the types of values that they accepted, leading to restricted compiler capabilities,
    to rule out ambiguous calls to overloaded methods. However, explicit lambdas and
    method references could still be checked by their arguments by the compiler. For
    your information, the lambdas that explicitly specify the types of their parameters
    are termed **explicit lambdas**.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the compiler's ability and relaxing the rules in this way was purposeful.
    It lowered the cost of type-checking for lambdas and avoided brittleness.
  prefs: []
  type: TYPE_NORMAL
- en: Although it is an interesting feature, the disambiguation of functional expressions
    is slated as an optional feature in JEP 302, because Oracle needs to assess its
    impact on the compiler implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Before diving into the proposed solution, let's look at the existing issues,
    using code examples.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with resolving overloaded methods – passing lambdas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover the existing issues with resolving overloaded methods when lambdas
    are passed as method parameters. Let''s define two interfaces, `Swimmer` and `Diver`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following code, the overloaded `evaluate` method accepts the interfaces
    `Swimmer` and `Diver` as method parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s call the overloaded `evaluate()` method in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Revisit the lambda from the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since the preceding lambda expression doesn't specify the type of its input
    parameter, it could be either `String` (the `test()` method and the `Swimmer` interface)
    or `int` (the `dive()` method and the `Diver` interface). Since the call to the
    `evaluate()` method is ambiguous, it doesn't compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the type of the method parameter to the preceding code, making it
    an explicit lambda:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding call is not ambiguous now; the lambda expression accepts an input
    parameter of the `String` type and returns a `boolean` value, which maps to the
    `evaluate()` method which accepts `Swimmer` as a parameter (the functional `test()`
    method in the `Swimmer` interface accepts a parameter of the `String` type).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens if the `Swimmer` interface is modified, changing the
    data type of the `lap` parameter from `String` to `int`. To avoid confusion, all
    of the code will be repeated, with the modifications in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the following code, thinking about which of the lines of code will
    compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the code on both of the line numbers won't compile
    for the same reason—the compiler is unable to determine the call to the overloaded
    `evaluate()` method. Since both of the functional methods (that is, `test()` in
    the `Swimmer` interface and `dive()` in the `Diver` interface) accept one method
    parameter of the `int` type, it isn't feasible for the compiler to determine the
    method call.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you might argue that since the return types of `test()` and
    `dive()` are different, the compiler should be able to infer the correct calls.
    Just to reiterate, the return types of a method don't participate in method overloading.
    Overloaded methods must return in the count or type of their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The return type of methods doesn't participate in method overloading. Overloaded
    methods must return in the count or type of their parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Issues with resolving overloaded methods – passing method references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can define overloaded methods with different parameter types, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the following code doesn''t compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding line of code, since the compiler is not allowed to examine
    the method reference, the code fails to compile. This is unfortunate since the
    method parameters to the overloaded methods are `Integer` and `String`—no value
    can be compatible with both.
  prefs: []
  type: TYPE_NORMAL
- en: The proposed solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The accidental compiler issues involved with overloaded methods that use either
    lambda expressions or method references can be resolved by allowing the compiler
    to consider their return type as `also`. The compiler would then be able to choose
    the right overloaded method and eliminate the unmatched option.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For Java developers working with lambdas and method references, this chapter
    demonstrates what Java has in the pipeline to help ease problems.
  prefs: []
  type: TYPE_NORMAL
- en: Lambda Leftovers (JEP 302) proposes using an underscore for unused parameters
    in lambdas, methods, and catch handlers. It plans to allow developers to define
    lambda parameters that can overshadow variables with the same name in their enclosing
    block. The disambiguation of functional expressions is an important and powerful
    feature. It will allow compilers to consider the return types of lambdas in order
    to determine the right overloaded methods. Since it can affect how the compilers
    work, this feature is marked as optional in this JEP.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which is on pattern matching and switch expressions, you'll
    get to know the exciting capabilities that are being added to the Java language.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter didn't include any coding exercises for the reader. The return
    type of methods doesn't participate in method overloading. Overloaded methods
    must return in the count or type of their parameters.
  prefs: []
  type: TYPE_NORMAL
