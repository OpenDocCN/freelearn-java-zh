<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Duplicate File Finder</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Any system that's been running for a while starts to suffer from hard drive clutter. This is especially true, for example, with large music and photo collections. Except for the most fastidious files getting copied and moved, we end up with a copy here and a copy there. The question is, though, which of these are duplicates and which are not? In this chapter, we'll build a file-walking utility that will scan a set of directories looking for duplicate files. We'll be able to specify whether the duplicates should be deleted, <strong class="calibre8">quarantined</strong>, or simply reported.</p>
<p class="mce-root">In this chapter, we will cover the following topics:</p>
<ul class="calibre13">
<li class="calibre14">The Java Platform Module System</li>
<li class="calibre14">The Java NIO (New I/O) File APIs</li>
<li class="calibre14">File hashing</li>
<li class="calibre14"><strong class="calibre3">Java Persistence API</strong> (<strong class="calibre3">JPA</strong>)</li>
<li class="calibre14">The new Java Date/Time API</li>
<li class="calibre14">Writing command-line utilities</li>
<li class="calibre14">More JavaFX</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Getting started</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">This application, while conceptually fairly simple, is a bit more complex than what we looked at in the last chapter, in that we will have both, a command line and a graphical interface. The experienced programmer is likely to immediately see the need to share the code between these two interfaces, as <strong class="calibre8">DRY</strong> (<strong class="calibre8">Don't Repeat Yourself</strong>) is one of the many hallmarks of a well-designed system. To facilitate this sharing of code, then, we will want to introduce a third module, which provides a library that can be consumed by the other two projects. We will call these modules <kbd class="calibre16">lib</kbd>, <kbd class="calibre16">cli</kbd>, and <kbd class="calibre16">gui</kbd>. Our first step in setting up the project is to create the various Maven POM files to describe the project's structure. The parent POM will look something like this:</p>
<pre class="calibre21">    &lt;?xml version="1.0" encoding="UTF-8"?&gt; 
    &lt;project  
        
      xsi:schemaLocation="http://maven.apache.org/POM/4.0.0  
      http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; 
      &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; 
 
     &lt;groupId&gt;com.steeplesoft.dupefind&lt;/groupId&gt; 
     &lt;artifactId&gt;dupefind-master&lt;/artifactId&gt; 
     &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 
     &lt;packaging&gt;pom&lt;/packaging&gt; 
 
     &lt;modules&gt; 
       &lt;module&gt;lib&lt;/module&gt; 
       &lt;module&gt;cli&lt;/module&gt; 
       &lt;module&gt;gui&lt;/module&gt; 
     &lt;/modules&gt; 
 
     &lt;name&gt;Duplicate Finder - Master&lt;/name&gt; 
    &lt;/project&gt; </pre>
<p class="mce-root">This is a fairly typical POM file. We will start by identifying the project's parent that lets us inherit a number of settings, dependencies, and so on, and avoid having to repeat them in this project. Next, we will define the Maven coordinates for the project. Note that we don't define a version for this project, allowing the parent's version to cascade down. This will allow us to increase the version as needed in one place, and update all of the subprojects implicitly.</p>
<p class="mce-root">The last interesting part of this POM, for those who haven't seen a multi-module project before, is the <kbd class="calibre16">modules</kbd> section. The only thing to note here, for those who are new to this, is that each <kbd class="calibre16">module</kbd> element refers to a directory name, which is a direct child of the current directory, and should be declared in the order in which they are needed. In our case, the CLI and GUI both depend on the library, so <kbd class="calibre16">lib</kbd> goes first. Next, we'll need to create the POM files for each module. Each of these are typical POMs of type jar, so there's no need to include them here. There will be varying dependencies in each, but we'll cover those as the need arises.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the library</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The foundational piece of this project is the library which both the CLI and the GUI will consume, so it makes sense to start here. When designing the library--its inputs, outputs, and general behavior--it helps to understand what exactly do we want this system to do, so let's take some time to discuss the functional requirements.</p>
<p class="mce-root">As stated in the introduction, we'd like to be able to search for duplicate files in an arbitrary number of directories. We'd also like to be able to restrict the search and comparison to only certain files. If we don't specify a pattern to match, then we want to check every file.</p>
<p class="mce-root">The most important part is how to identify a match. There are, of course, a myriad of ways in which this can be done, but the approach we will use is as follows:</p>
<ul class="calibre13">
<li class="calibre14">Identify files that have the same filename. Think of those situations where you might have downloaded images from your camera to your computer for safekeeping, then, later, perhaps you forgot that you had already downloaded the images, so you copied them again somewhere else. Obviously, you only want one copy, but is the file, for example, <kbd class="calibre16">IMG_9615.JPG</kbd>, in the temp directory the same as the one in your picture backup directory? By identifying files with matching names, we can test them to be sure.</li>
<li class="calibre14">Identify files that have the same size. The likelihood of a match here is smaller, but there is still a chance. For example, some photo management software, when importing images from a device, if it finds a file with the same name, will modify the filename of the second file and store both, rather than stopping the import and requiring immediate user intervention. This can result in a large number of files such as <kbd class="calibre16">IMG_9615.JPG</kbd> and <kbd class="calibre16">IMG_9615-1.JPG</kbd>. This check will help identify these situations.</li>
<li class="calibre14">For each match above, to determine whether the files are actually a match, we'll generate a hash based on the file contents. If more than one file generates the same hash, the likelihood of those files being identical is extremely high. These files we will flag as potential duplicates.</li>
</ul>
<p class="mce-root">It's a pretty simple algorithm and should be pretty effective, but we do have a problem, albeit one that's likely not immediately apparent. If you have a large number of files, especially a set with a large number of potential duplicates, processing all of these files could be a very lengthy process, which we would like to mitigate as much as possible, which leads us to some non-functional requirements:</p>
<ul class="calibre13">
<li class="calibre14">The program should process files in a concurrent manner so as to minimize, as much as possible, the amount of time it takes to process a large file set</li>
<li class="calibre14">This concurrency should be bounded so that the system is not overwhelmed by processing the request</li>
<li class="calibre14">Given the potential for a large amount of data, the system must be designed in such a way so as to avoid using up all available RAM and causing system instability</li>
</ul>
<p class="mce-root">With that fairly modest list of functional and non-functional requirements, we should be ready to begin. Like the last application, let's start by defining our module. In <kbd class="calibre16">src/main/java</kbd>, we will create this <kbd class="calibre16">module-info.java</kbd>:</p>
<pre class="calibre21">    module com.steeplesoft.dupefind.lib { 
      exports com.steeplesoft.dupefind.lib; 
    } </pre>
<p class="mce-root">Initially, the compiler--and the IDE--will complain that the <kbd class="calibre16">com.steeplesoft.dupefind.lib</kbd> package does not exist and won't compile the project. That's fine for now, as we'll be creating that package now.</p>
<p class="mce-root">The use of the word <strong class="calibre8">concurrency</strong> in the functional requirements, most likely, immediately brings to mind the idea of threads. We introduced the idea of threads in <a href="bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 18</a>, <em class="calibre20">Managing Java Processes</em>, so if you are not familiar with them, review that section in the previous chapter.</p>
<p class="mce-root">Our use of threading in this project is different from that in the last, in that we will have a body of work that needs to be done, and, once it's finished, we want the threads to exit. We also need to wait for these threads to finish their work so that we can analyze it. In the <kbd class="calibre16">java.util.concurrent</kbd> package, the JDK provides several options to accomplish this.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Concurrent Java with a Future interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">One of the more common and popular APIs is the <kbd class="calibre16">Future&lt;V&gt;</kbd> interface. <kbd class="calibre16">Future</kbd> is a means to encapsulate an asynchronous calculation. Typically, the <kbd class="calibre16">Future</kbd> instance is returned by <kbd class="calibre16">ExecutorService</kbd>, which we'll discuss later. The calling code, once it has the reference to <kbd class="calibre16">Future</kbd>, can continue to work on other tasks while <kbd class="calibre16">Future</kbd> runs in the background in another thread. When the caller is ready for the results of <kbd class="calibre16">Future</kbd>, it calls <kbd class="calibre16">Future.get()</kbd>. If <kbd class="calibre16">Future</kbd> has finished its work, the call returns immediately with the results. If, however, <kbd class="calibre16">Future</kbd> is still working, calls to <kbd class="calibre16">get()</kbd> will block until <kbd class="calibre16">Future</kbd> completes.</p>
<p class="mce-root">For our uses, though, <kbd class="calibre16">Future</kbd> isn't the most appropriate choice. Looking over the non-functional requirements, we see the desire to avoid crashing the system by exhausting the available memory explicitly listed out. As we'll see later, the way this will be implemented is by storing the data in a lightweight on-disk database, and we will implement that--again, as we'll see later-by storing the file information as it is retrieved rather than by gathering the data, then saving it in a post-process method. Given that, our <kbd class="calibre16">Future</kbd> won't be returning anything. While there is a way to make that work (defining <kbd class="calibre16">Future</kbd> as <kbd class="calibre16">Future&lt;?&gt;</kbd> and returning <kbd class="calibre16">null</kbd>), it's not the most natural approach.</p>
<p class="mce-root">Perhaps the most appropriate approach is <kbd class="calibre16">ExecutorService</kbd>, which is <kbd class="calibre16">Executor</kbd> that provides additional functionality, such as the ability to create a <kbd class="calibre16">Future</kbd>, as discussed earlier, and manage termination of the queue. What, then, is <kbd class="calibre16">Executor</kbd>? <kbd class="calibre16">Executor</kbd> is a mechanism to execute <kbd class="calibre16">Runnable</kbd> that is more robust than simply calling <kbd class="calibre16">new Thread(runnable).start()</kbd>. The interface itself is very basic, consisting only of the <kbd class="calibre16">execute(Runnable)</kbd> method, so its value is not immediately apparent just from looking at the Javadoc. If, however, you look at <kbd class="calibre16">ExecutorService</kbd>, which is the interface that all <kbd class="calibre16">Executor</kbd> provided by the JDK implement, as well as the various <kbd class="calibre16">Executor</kbd> implementations, their value easily becomes more apparent. Let's take a quick survey now.</p>
<p class="mce-root">Looking at the <kbd class="calibre16">Executors</kbd> class, we can see five different types of <kbd class="calibre16">Executor</kbd> implementations: a cached thread pool, a fixed-size thread pool, a scheduled thread pool, a single thread executor, and a work-stealing thread pool. With the single thread <kbd class="calibre16">Executor</kbd> being the only exception, each of these can be instantiated directly (<kbd class="calibre16">ThreadPoolExecutor</kbd>, <kbd class="calibre16">ScheduledThreadPoolExecutor</kbd>, and <kbd class="calibre16">ForkJoinPool</kbd>), but users are urged by the JDK authors to use the convenience methods on the <kbd class="calibre16">Executors</kbd> class. That said, what are each of these options and why might you choose one?</p>
<ul class="calibre13">
<li class="calibre14"><kbd class="calibre16">Executors.newCachedThreadPool()</kbd>: This returns <kbd class="calibre16">Executor</kbd> that provides a pool of cached threads. As tasks come in, <kbd class="calibre16">Executor</kbd> will attempt to find an unused thread to execute the task with. If one cannot be found, a new <kbd class="calibre16">Thread</kbd> is created and the work begins. When a task is complete, <kbd class="calibre16">Thread</kbd> is returned to the pool to await reuse. After approximately 60 seconds, unused threads are destroyed and removed from the pool, which prevents resources from being allocated and never released. Care must be taken with this <kbd class="calibre16">Executor</kbd>, though, as the thread pool is unbounded, which means that under heavy use, the system could be overwhelmed by active threads.</li>
<li class="calibre14"><kbd class="calibre16">Executors.newFixedThreadPool(int nThreads)</kbd>: This method returns an <kbd class="calibre16">Executor</kbd> similar to the one previously mentioned, with the exception that the thread pool is bounded to at most <kbd class="calibre16">nThreads</kbd>.</li>
<li class="calibre14"><kbd class="calibre16">Executors.newScheduledThreadPool(int corePoolSize)</kbd>: This <kbd class="calibre16">Executor</kbd> is able to schedule tasks to run after an optional initial delay and then periodically, based on the delay and <kbd class="calibre16">TimeUnit</kbd> value. See, for example, the <kbd class="calibre16">schedule(Runnable command, long delay, TimeUnit unit)</kbd> method.</li>
<li class="calibre14"><kbd class="calibre16">Executors.newSingleThreadExecutor()</kbd>: This method will return an <kbd class="calibre16">Executor</kbd> that will use a single thread to execute the tasks submitted to it. Tasks are guaranteed to be executed in the order in which they were submitted.</li>
<li class="calibre14"><kbd class="calibre16">Executors.newWorkStealingExecutor()</kbd>: This method will return a so-called <strong class="calibre3">work stealing</strong> <kbd class="calibre16">Executor</kbd>, which is of type <kbd class="calibre16">ForkJoinPool</kbd>. The tasks submitted to this <kbd class="calibre16">Executor</kbd> are written in such a way as to be able to divide up the work to additional worker threads until the size of the work is under a user-defined threshold.</li>
</ul>
<p class="mce-root">Given our non-functional requirements, the fixed-size <kbd class="calibre16">ThreadPoolExecutor</kbd> seems to be the most appropriate. One configuration option we'll need to support, though, is the option to force the generation of hashes for every file found. Based on the preceding algorithm, only files that have duplicate names or sizes will be hashed. However, users may want a more thorough analysis of their file specification and would like to force a hash on every file. We'll implement this using the work-stealing (or fork/join) pool.</p>
<p class="mce-root">With our threading approach selected, let's take a look at the entry point for the library, a class we'll call <kbd class="calibre16">FileFinder</kbd>. Since this is our entry point, it will need to know where we want to search and what we want to search for. That will give us the instance variables, <kbd class="calibre16">sourcePaths</kbd> and <kbd class="calibre16">patterns</kbd>:</p>
<pre class="calibre21">    private final Set&lt;Path&gt; sourcePaths = new HashSet&lt;&gt;(); 
    private final Set&lt;String&gt; patterns = new HashSet&lt;&gt;(); </pre>
<p class="mce-root">We're declaring the variables as <kbd class="calibre16">private</kbd>, as that is a good object-oriented practice. We're also declaring them <kbd class="calibre16">final</kbd>, to help avoid subtle bugs where these variables are assigned new values, resulting in the unexpected loss of data. Generally speaking, I find it to be a good practice to mark variables as <kbd class="calibre16">final</kbd> by default to prevent such subtle bugs. In the case of instance variables in a class like this, a variable can only be declared <kbd class="calibre16">final</kbd> if it is either immediately assigned a value, as we are doing here, or if it is given a value in the class' constructors.</p>
<p class="mce-root">We also want to define our <kbd class="calibre16">ExecutorService</kbd> now:</p>
<pre class="calibre21">    private final ExecutorService es = 
      Executors.newFixedThreadPool(5); </pre>
<p class="mce-root">We have somewhat arbitrarily chosen to limit our thread pool to five threads, as it seems to be a fair balance between providing a sufficient number of worker threads for heavy requests, while not allocating a large number of threads that may not be used in most cases. In our case, it is probably a minor issue overblown, but it's certainly something to keep in mind.</p>
<p class="mce-root">Next, we need to provide a means to store any duplicates found. Consider the following lines of code as an example:</p>
<pre class="calibre21">    private final Map&lt;String, List&lt;FileInfo&gt;&gt; duplicates =  
      new HashMap&lt;&gt;(); </pre>
<p class="mce-root">We'll see more details later, but, for now, all that we need to note is that this is a <kbd class="calibre16">Map</kbd> of <kbd class="calibre16">List&lt;FileInfo&gt;</kbd> objects, keyed by the file hash.</p>
<p class="mce-root">The final variable to make note of is something that might be a bit unexpected--an <kbd class="calibre16">EntityManagerFactory</kbd>. You might be asking yourself, what is that? The <kbd class="calibre16">EntityManagerFactory</kbd> is an interface to interact with a persistence unit as defined by the <strong class="calibre8">Java Persistence API</strong> (<strong class="calibre8">JPA</strong>), which is part of the Java Enterprise Edition Specification. Fortunately, though, the specification was written in such a way to mandate that it be usable in a <strong class="calibre8">Standard Edition</strong> (<strong class="calibre8">SE</strong>) context like ours.</p>
<p class="mce-root">So, what are we doing with such an API? If you'll look back at the non-functional requirements, we've specified that we want to make sure that the search for duplicate files doesn't exhaust the available memory on the system. For very large searches, it is quite possible that the list of files and their hashes can grow to a problematic size. Couple that with the memory it will take to generate the hashes, which we'll discuss later, and we can very likely run into out-of-memory situations. We will, therefore, be using JPA to save our search information in a simple, light database (SQLite) that will allow us to save our data to the disk. It will also allow us to query and filter the results more efficiently than iterating over in-memory structures repeatedly.</p>
<p class="mce-root">Before we can make use of those APIs, we need to update our module descriptor to let the system know that we now require the persistence modules. Consider the following code snippet as an example:</p>
<pre class="calibre21">    module dupefind.lib { 
      exports com.steeplesoft.dupefind.lib; 
      requires java.logging; 
      requires javax.persistence; 
    } </pre>
<p class="mce-root">We've declared to the system that we require both <kbd class="calibre16">javax.persistence</kbd> and <kbd class="calibre16">java.logging</kbd>, which we'll be using later. As we discussed in <a href="bb776cea-d943-45d8-9854-1d8ff86dc46a.xhtml" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2">Chapter 18</a>, <em class="calibre20">Managing Processes in Java</em>, if any of these modules are not present, the JVM instance will fail to start.</p>
<p class="mce-root">Perhaps the more important part of the module definition is the <kbd class="calibre16">exports</kbd> clause. With this line (there can be 0 or more of them), we're telling the system that we are exporting all of the types in the specified package. This line will allow our CLI module, which we'll get into later, to use the classes (as well as interfaces, enums, and so on, if we were to add any) in that module. If a type's package does not <kbd class="calibre16">export</kbd>, consuming modules will be unable to see the type, which we'll also demonstrate later.</p>
<p class="mce-root">With that understanding, let's take a look at our constructor:</p>
<pre class="calibre21">    public FileFinder() { 
      Map&lt;String, String&gt; props = new HashMap&lt;&gt;(); 
      props.put("javax.persistence.jdbc.url",  
       "jdbc:sqlite:" +  
       System.getProperty("user.home") +  
       File.separator +  
       ".dupfinder.db"); 
      factory = Persistence.createEntityManagerFactory 
       ("dupefinder", props); 
      purgeExistingFileInfo(); 
    } </pre>
<p class="mce-root">To configure the persistence unit, JPA typically uses a <kbd class="calibre16">persistence.xml</kbd> file. In our case, though, we'd like a bit more control over where the database file is stored. As you can see in the preceding code, we are constructing the JDBC URL using the <kbd class="calibre16">user.home</kbd> environment variable. We then store that in a <kbd class="calibre16">Map</kbd> using the JPA-defined key to specify the URL. This <kbd class="calibre16">Map</kbd> is then passed to the <kbd class="calibre16">createEntityManagerFactory</kbd> method, which overrides anything set in <kbd class="calibre16">persistence.xml</kbd>. This allows us to put the database in the home directory appropriate for the user's operating system.</p>
<p class="mce-root">With our class constructed and configured, it's time to take a look at how we'll find duplicate files:</p>
<pre class="calibre21">    public void find() { 
      List&lt;PathMatcher&gt; matchers = patterns.stream() 
       .map(s -&gt; !s.startsWith("**") ? "**/" + s : s) 
       .map(p -&gt; FileSystems.getDefault() 
       .getPathMatcher("glob:" + p)) 
       .collect(Collectors.toList()); </pre>
<p class="mce-root">Our first step is to create a list of the <kbd class="calibre16">PathMatcher</kbd> instances based on the patterns specified by the user. A <kbd class="calibre16">PathMatcher</kbd> instance is a functional interface that is implemented by objects that attempt to match files and paths. Our instances are retrieved from the <kbd class="calibre16">FileSystems</kbd> class.</p>
<p class="mce-root">When requesting <kbd class="calibre16">PathMatcher</kbd>, we have to specify the globbing pattern. As can be seen in the first call to <kbd class="calibre16">map()</kbd>, we have to make an adjustment to what the user specified. Typically, a pattern mask is specified simply as something like <kbd class="calibre16">*.jpg</kbd>. However, a pattern mask like this won't work in a way that the user expects, in that it will only look in the current directory and not walk down into any subdirectories. To do that, the pattern must be prefixed with <kbd class="calibre16">**/</kbd>, which we do in the call to <kbd class="calibre16">map()</kbd>. With our adjusted pattern, we request the <kbd class="calibre16">PathMatcher</kbd> instance from the system's default <kbd class="calibre16">FileSystem</kbd>. Note that we specify the matcher pattern as <kbd class="calibre16">"glob:" + p</kbd> because we need to indicate that we are, indeed, specifying a <kbd class="calibre16">glob</kbd> file.</p>
<p class="mce-root">With our matchers prepared, we're ready to start the search. We do that with this code:</p>
<pre class="calibre21">    sourcePaths.stream() 
     .map(p -&gt; new FindFileTask(p)) 
     .forEach(fft -&gt; es.execute(fft)); </pre>
<p class="mce-root">Using the <kbd class="calibre16">Stream</kbd> API, we map each source path to a lambda that creates an instance of <kbd class="calibre16">FindFileTask</kbd>, providing it the source path it will search. Each of these <kbd class="calibre16">FileFindTask</kbd> instances will then be passed to our <kbd class="calibre16">ExecutorService</kbd> via the <kbd class="calibre16">execute()</kbd> method.</p>
<p class="mce-root">The <kbd class="calibre16">FileFindTask</kbd> method is the workhorse for this part of the process. It is a <kbd class="calibre16">Runnable</kbd> as we'll be submitting this to the <kbd class="calibre16">ExecutorService</kbd>, but it is also a <kbd class="calibre16">FileVisitor&lt;Path&gt;</kbd> as it will be used in walking the file tree, which we do from the <kbd class="calibre16">run()</kbd> method:</p>
<pre class="calibre21">    @Override 
    public void run() { 
      final EntityTransaction transaction = em.getTransaction(); 
      try { 
        transaction.begin(); 
        Files.walkFileTree(startDir, this); 
        transaction.commit(); 
      } catch (IOException ex) { 
        transaction.rollback(); 
      } 
    } </pre>
<p class="mce-root">Since we will be inserting data into the database via JPA, we'll need to start a transaction as our first step. Since this is an application-managed <kbd class="calibre16">EntityManager</kbd>, we have to manage the transaction manually. We acquire a reference to the <kbd class="calibre16">EntityTransaction</kbd> instance outside the <kbd class="calibre16">try/catch</kbd> block to simplify referencing it. Inside the <kbd class="calibre16">try</kbd> block, we start the transaction, start the file walking via <kbd class="calibre16">Files.walkFileTree()</kbd>, then commit the transaction if the process succeeds. If it fails--if an <kbd class="calibre16">Exception</kbd> was thrown--we roll back the transaction.</p>
<p class="mce-root">The <kbd class="calibre16">FileVisitor</kbd> API requires a number of methods, most of which are not too terribly interesting, but we'll show them for clarity's sake:</p>
<pre class="calibre21">    @Override 
    public FileVisitResult preVisitDirectory(final Path dir,  
    final BasicFileAttributes attrs) throws IOException { 
      return Files.isReadable(dir) ?  
       FileVisitResult.CONTINUE : FileVisitResult.SKIP_SUBTREE; 
    } </pre>
<p class="mce-root">Here, we tell the system that if the directory is readable, then we continue with walking down that directory. Otherwise, we skip it:</p>
<pre class="calibre21">    @Override 
    public FileVisitResult visitFileFailed(final Path file,  
     final IOException exc) throws IOException { 
       return FileVisitResult.SKIP_SUBTREE; 
    } </pre>
<p class="mce-root">The API requires this method to be implemented, but we're not very interested in file read failures, so we simply return a skip result:</p>
<pre class="calibre21">    @Override 
    public FileVisitResult postVisitDirectory(final Path dir,  
     final IOException exc) throws IOException { 
       return FileVisitResult.CONTINUE; 
    } </pre>
<p class="mce-root">Much like the preceding method, this method is required, but we're not interested in this particular event, so we signal the system to continue:</p>
<pre class="calibre21">    @Override 
    public FileVisitResult visitFile(final Path file, final<br class="calibre2"/>     BasicFileAttributes attrs) throws IOException { 
       if (Files.isReadable(file) &amp;&amp; isMatch(file)) { 
         addFile(file); 
       } 
       return FileVisitResult.CONTINUE; 
    } </pre>
<p class="mce-root">Now we've come to a method we're interested in. We will check to make sure that the file is readable, then check to see if it's a match. If it is, we add the file. Regardless, we continue walking the tree. How do we test if the file's a match? Consider the following code snippet as an example:</p>
<pre class="calibre21">    private boolean isMatch(final Path file) { 
      return matchers.isEmpty() ? true :  
       matchers.stream().anyMatch((m) -&gt; m.matches(file)); 
    } </pre>
<p class="mce-root">We iterate over the list of <kbd class="calibre16">PathMatcher</kbd> instances we passed in to the class earlier. If the <kbd class="calibre16">List</kbd> is empty, which means the user didn't specify any patterns, the method's result will always be <kbd class="calibre16">true</kbd>. However, if there are items in the <kbd class="calibre16">List</kbd>, we use the <kbd class="calibre16">anyMatch()</kbd> method on the <kbd class="calibre16">List</kbd>, passing a lambda that checks the <kbd class="calibre16">Path</kbd> against the <kbd class="calibre16">PathMatcher</kbd> instance.</p>
<p class="mce-root">Adding the file is very straightforward:</p>
<pre class="calibre21">    private void addFile(Path file) throws IOException { 
      FileInfo info = new FileInfo(); 
      info.setFileName(file.getFileName().toString()); 
      info.setPath(file.toRealPath().toString()); 
      info.setSize(file.toFile().length()); 
      em.persist(info); 
    } </pre>
<p class="mce-root">We create a <kbd class="calibre16">FileInfo</kbd> instance, set the properties, then persist it to the database via <kbd class="calibre16">em.persist()</kbd>.</p>
<p class="mce-root">With our tasks defined and submitted to <kbd class="calibre16">ExecutorService</kbd>, we need to sit back and wait. We do that with the following two method calls:</p>
<pre class="calibre21">    es.shutdown(); 
    es.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS); </pre>
<p class="mce-root">The first step is to ask <kbd class="calibre16">ExecutorService</kbd> to shut down. The <kbd class="calibre16">shutdown()</kbd> method will return immediately, but it will instruct <kbd class="calibre16">ExecutorService</kbd> to refuse any new tasks, as well as shut down its threads as soon as they are idle. Without this step, the threads will continue to run indefinitely. Next, we will wait for the service to shut down. We specify the maximum wait time to make sure we give our tasks time to complete. Once this method returns, we're ready to process the results, which is done in the following <kbd class="calibre16">postProcessFiles()</kbd> method:</p>
<pre class="calibre21">    private void postProcessFiles() { 
      EntityManager em = factory.createEntityManager(); 
      List&lt;FileInfo&gt; files = getDuplicates(em, "fileName"); </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Modern database access with JPA</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's stop here for a moment. Remember our discussion of the <strong class="calibre8">Java Persistence API</strong> (<strong class="calibre8">JPA</strong>) and database? Here is where we see that coming in. With the JPA, interactions with the database are done via the <kbd class="calibre16">EntityManager</kbd> interface, which we retrieve from the cleverly named <kbd class="calibre16">EntityManagerFactory</kbd>. It is important to note that the <kbd class="calibre16">EntityManager</kbd> instances are not thread-safe, so they should not be shared between threads. That's why we didn't create one in the constructor and pass it around. This is, of course, a local variable, so we need not worry about that too much until, and if, we decide to pass it as a parameter to another method, which we are doing here. As we will see in a moment, everything happens in the same thread, so we will not have to worry about thread-safety issues as the code stands now.</p>
<p class="mce-root">With our <kbd class="calibre16">EntityManager</kbd>, we call the <kbd class="calibre16">getDuplicates()</kbd> method and pass the manager and field name, <kbd class="calibre16">fileName</kbd>. This is what that method looks like:</p>
<pre class="calibre21">    private List&lt;FileInfo&gt; getDuplicates(EntityManager em,  
     String fieldName) { 
       List&lt;FileInfo&gt; files = em.createQuery( 
         DUPLICATE_SQL.replace("%FIELD%", fieldName), 
          FileInfo.class).getResultList(); 
       return files; 
    } </pre>
<p class="mce-root">This is a fairly straightforward use of the Java Persistence API--we're creating a query and telling it that we want, and getting a <kbd class="calibre16">List</kbd> of <kbd class="calibre16">FileInfo</kbd> references back. The <kbd class="calibre16">createQuery()</kbd> method creates a <kbd class="calibre16">TypedQuery</kbd> object, on which we will call <kbd class="calibre16">getResultList()</kbd> to retrieve the results, which gives us <kbd class="calibre16">List&lt;FileInfo&gt;</kbd>.</p>
<p class="mce-root">Before we go any further, we need to have a short primer on the Java Persistence API. JPA is what is known as an <strong class="calibre8">object-relational mapping</strong> (<strong class="calibre8">ORM</strong>) tool. It provides an object-oriented, type-safe, and database-independent way of storing data in, typically, a relational database. The specification/library allows application authors to define their data models using concrete Java classes, then persist and/or read them with little thought about the mechanics specific to the database currently being used. (The developer isn't completely shielded from database concerns--and it's arguable as to whether or not he or she should be--but those concerns are greatly lessened as they are abstracted away behind the JPA interfaces). The process of acquiring a connection, creating the SQL, issuing it to the server, processing results, and more are all handled by the library, allowing a greater focus on the business of the application rather than the plumbing. It also allows a high degree of portability between databases, so applications (or libraries) can be easily moved from one system to another with minimal change (usually restricted to configuration changes).</p>
<p class="mce-root">At the heart of JPA is <kbd class="calibre16">Entity</kbd>, the business object (or domain model, if you prefer) that models the data for the application. This is expressed in the Java code as a <strong class="calibre8">plain old Java object</strong> (<strong class="calibre8">POJO</strong>), which is marked up with a variety of annotations. A complete discussion of all of those annotations (or the API as a whole) is outside the scope of this book, but we'll use enough of them to get you started.</p>
<p class="mce-root">With that basic explanation given, let's take a look at our one and only entity--the <kbd class="calibre16">FileInfo</kbd> class:</p>
<pre class="calibre21">    @Entity 
    public class FileInfo implements Serializable { 
      @GeneratedValue 
      @Id 
      private int id; 
      private String fileName; 
      private String path; 
      private long size; 
      private String hash; 
    } </pre>
<p class="mce-root">This class has five properties. The only one that needs special attention is <kbd class="calibre16">id</kbd>. This property holds the primary key value for each row, so we annotate it with <kbd class="calibre16">@Id</kbd>. We also annotate this field with <kbd class="calibre16">@GeneratedValue</kbd> to indicate that we have a simple primary key for which we'd like the system to generate a value. This annotation has two properties: <kbd class="calibre16">strategy</kbd> and <kbd class="calibre16">generator</kbd>. The default value for strategy is <kbd class="calibre16">GenerationType.AUTO</kbd>, which we happily accept here. Other options include <kbd class="calibre16">IDENTITY</kbd>, <kbd class="calibre16">SEQUENCE</kbd>, and <kbd class="calibre16">TABLE</kbd>. In more complex uses, you may want to specify a strategy explicitly, which allows you to fine-tune how the key is generated (for example, the starting number, the allocation size, the name of the sequence or table, and so on). By choosing <kbd class="calibre16">AUTO</kbd>, we're telling JPA to choose the appropriate generation strategy for our target database. If you specify a strategy other than <kbd class="calibre16">AUTO</kbd>, you will also need to specify the details for the generator, using <kbd class="calibre16">@SequenceGenerator</kbd> for <kbd class="calibre16">SEQUENCE</kbd> and <kbd class="calibre16">@TableGenerator</kbd> for <kbd class="calibre16">TABLE</kbd>. You will also need to give the ID of the generator to the <kbd class="calibre16">@GeneratedValue</kbd> annotation using the generator attribute. We're using the default, so we need not specify a value for this attribute.</p>
<p class="mce-root">The next four fields are the pieces of data we have identified that we need to capture. Note that if we do not need to specify anything special about the mapping of these fields to the database columns, no annotations are necessary. However, if we would like to change the defaults, we can apply the <kbd class="calibre16">@Column</kbd> annotation and set the appropriate attribute, which can be one or more of <kbd class="calibre16">columnDefinition</kbd> (used to help generate the DDL for the column), <kbd class="calibre16">insertable</kbd>, <kbd class="calibre16">length</kbd>, <kbd class="calibre16">name</kbd>, <kbd class="calibre16">nullable</kbd>, <kbd class="calibre16">precision</kbd>, <kbd class="calibre16">scale</kbd>, <kbd class="calibre16">table</kbd>, <kbd class="calibre16">unique</kbd>, and <kbd class="calibre16">updatable</kbd>. Again, we're happy with the defaults.</p>
<p class="mce-root">JPA also requires each property to have a getter and a setter; the specification seems to be worded oddly, which has led to some ambiguity as to whether or not this is a hard requirement, and different JPA implementations handle this differently, but it's certainly safer to provide both as a matter of practice. If you need a read-only property, you can experiment with either no setter, or simply a no-op method. We haven't shown the getters and setters here, as there is nothing interesting about them. We have also omitted the IDE-generated <kbd class="calibre16">equals()</kbd> and <kbd class="calibre16">hashCode()</kbd> methods.</p>
<p class="mce-root">To help demonstrate the module system, we've put our entity in a <kbd class="calibre16">com.steeplesoft.dupefind.lib.model</kbd> subpackage. We'll tip our hand a bit and go ahead and announce that this class will be used by both our CLI and GUI modules, so we'll need to update our module definition as follows:</p>
<pre class="calibre21">    module dupefind.lib { 
      exports com.steeplesoft.dupefind.lib; 
      exports com.steeplesoft.dupefind.lib.model; 
      requires java.logging; 
      requires javax.persistence; 
    } </pre>
<p class="mce-root">That's all there is to our entity, so let's turn our attention back to our application logic. The <kbd class="calibre16">createQuery()</kbd> call deserves a bit of discussion. Typically, when using JPA, queries are written in what is called <strong class="calibre8">JPAQL</strong> (<strong class="calibre8">Java Persistence API Query Language</strong>). It looks very much like SQL, but has a more object-oriented feel to it. For example, if we wanted to query for every <kbd class="calibre16">FileInfo</kbd> record in the database, we would do so with this query:</p>
<pre class="calibre21"><strong class="calibre3">    SELECT f FROM FileInfo f</strong> </pre>
<p class="mce-root">I have put the keywords in all caps, with variable names in lower and the entity name in camel case. This is mostly a matter of style, but while most identifiers are case-insensitive, JPA does require that the case on the entity name matches that of the Java class it represents. You must also specify an alias, or identification variable, for the entity, which we simply call <kbd class="calibre16">f</kbd>.</p>
<p class="mce-root">To get a specific <kbd class="calibre16">FileInfo</kbd> record, you can specify a <kbd class="calibre16">WHERE</kbd> clause as follows:</p>
<pre class="calibre21"><strong class="calibre3">    SELECT f from FileInfo f WHERE f.fileName = :name</strong> </pre>
<p class="mce-root">With this query, we can filter the query just as SQL does, and, just like SQL, we specify a positional parameter. The parameter can either be a name, like we've done here, or simply a <kbd class="calibre16">?</kbd>. If you use a name, you set the parameter value on the query using that name. If you use the question mark, you must set the parameter using its index in the query. For small queries, this is usually fine, but for larger, more complex queries, I would suggest using names so that you don't have to manage index values, as that's almost guaranteed to cause a bug at some point. Setting the parameter can look something like this:</p>
<pre class="calibre21"><strong class="calibre3">    Query query = em.createQuery( 
      "SELECT f from FileInfo f WHERE f.fileName = :name"); 
    query.setParameter("name", "test3.txt"); 
    query.getResultList().stream() //...</strong> </pre>
<p class="mce-root">With that said, let's take a look at our query:</p>
<pre class="calibre21"><strong class="calibre3">    SELECT f  
    FROM FileInfo f,  
      (SELECT s.%FIELD%  
        FROM FileInfo s  
        GROUP BY s.%FIELD%  
        HAVING (COUNT(s.%FIELD%) &gt; 1)) g 
    WHERE f.%FIELD% = g.%FIELD%  
    AND f.%FIELD% IS NOT NULL  
    ORDER BY f.fileName, f.path</strong> </pre>
<p class="mce-root">This query is moderately complicated, so let's break it down and see what's going on. First, in our <kbd class="calibre16">SELECT</kbd> query, we will specify only <kbd class="calibre16">f</kbd>, which is the identification variable of the entity for which we are querying. Next, we are selecting from a regular table and a temporary table, which is defined by the subselect in the <kbd class="calibre16">FROM</kbd> clause. Why are we doing it this way? We need to identify all of the rows that have a duplicate value (<kbd class="calibre16">fileName</kbd>, <kbd class="calibre16">size</kbd>, or <kbd class="calibre16">hash</kbd>). To do that, we use a <kbd class="calibre16">HAVING</kbd> clause with the <kbd class="calibre16">COUNT</kbd> aggregation function, <kbd class="calibre16">HAVING (COUNT(fieldName &gt; 1))</kbd> which says, in effect, give me all of the rows where this field occurs more than one time. The <kbd class="calibre16">HAVING</kbd> clause requires a <kbd class="calibre16">GROUP BY</kbd> clause, and once that's done, all of the rows with duplicate values are aggregated down to a single row. Once we have that list of rows, we will then join the real (or physical) table to those results to filter our physical table. Finally, we filter out the null fields in the <kbd class="calibre16">WHERE</kbd> clause, then order by <kbd class="calibre16">fileName</kbd> and <kbd class="calibre16">path</kbd> so that we don't have to do that in our Java code, which is likely to be less efficient than it would be if done by the database--a system designed for such operations.</p>
<p class="mce-root">You should also note the <kbd class="calibre16">%FIELD%</kbd> attribute in the SQL. We'll run the same query for multiple fields, so we've written the query once, and placed a marker in the text that we will replace with the desired field, which is sort of a <em class="calibre20">poor man's</em> template. There are, of course, a variety of ways to do this (and you may have one you find superior), but this is simple and easy to use, so it's perfectly acceptable in this environment.</p>
<p class="mce-root">We should also note that it is, generally speaking, a very bad idea to either concatenate SQL with values or do string replacements like we're doing, but our scenario is a bit different. If we were accepting user input and inserting that into the SQL this way, then we would certainly have a target for an SQL injection attack. In our use here, though, we aren't taking input from users, so this approach should be perfectly safe. In terms of database performance, this shouldn't have any adverse effects either. While we will require three different hard parses (one for each field by which we will filter), this is no different than if we were hardcoding the queries in our source file. Both of those issues, as well as many more, are always good to consider as you write your queries (and why I said the developer is mostly shielded from database concerns).</p>
<p class="mce-root">All of that gets us through the first step, which is identifying all of the files that have the same name. We now need to identify the files that have the same size, which can be done using the following piece of code:</p>
<pre class="calibre21">    List&lt;FileInfo&gt; files = getDuplicates(em, "fileName"); 
    files.addAll(getDuplicates(em, "size")); </pre>
<p class="mce-root">In our call to find duplicate filenames, we declared a local variable, <kbd class="calibre16">files</kbd>, to store those results. In finding files with duplicate sizes, we call the same <kbd class="calibre16">getDuplicates()</kbd> method, but with the correct field name, and simply add that to <kbd class="calibre16">files</kbd> via the <kbd class="calibre16">List.addAll()</kbd> method.</p>
<p class="mce-root">We now have a complete list of all of the possible duplicates, so we need to generate the hashes for each of these to see if they are truly duplicates. We will do that with this loop:</p>
<pre class="calibre21">    em.getTransaction().begin(); 
    files.forEach(f -&gt; calculateHash(f)); 
    em.getTransaction().commit(); </pre>
<p class="mce-root">In a nutshell, we start a transaction (since we'll be inserting data into the database), then loop over each possible duplicate via <kbd class="calibre16">List.forEach()</kbd> and a lambda that calls <kbd class="calibre16">calculateHash(f)</kbd>, and then pass the <kbd class="calibre16">FileInfo</kbd> instance. Once the loop terminates, we commit the transaction to save our changes.</p>
<p class="mce-root">What does <kbd class="calibre16">calculateHash()</kbd> do? Let's a take a look:</p>
<pre class="calibre21">    private void calculateHash(FileInfo file) { 
      try { 
        MessageDigest messageDigest =  
          MessageDigest.getInstance("SHA3-256"); 
        messageDigest.update(Files.readAllBytes( 
          Paths.get(file.getPath()))); 
        ByteArrayInputStream inputStream =  
          new ByteArrayInputStream(messageDigest.digest()); 
        String hash = IntStream.generate(inputStream::read) 
         .limit(inputStream.available()) 
         .mapToObj(i -&gt; Integer.toHexString(i)) 
         .map(s -&gt; ("00" + s).substring(s.length())) 
         .collect(Collectors.joining()); 
        file.setHash(hash); 
      } catch (NoSuchAlgorithmException | IOException ex) { 
        throw new RuntimeException(ex); 
      } 
    }  </pre>
<p class="mce-root">This simple method encapsulates the work required to read the contents of a file and generate a hash. It requests an instance of <kbd class="calibre16">MessageDigest</kbd> using the <kbd class="calibre16">SHA3-256</kbd> hash, which is one of the four new hashes supported by Java 9 (the other three being <kbd class="calibre16">SHA3-224</kbd>, <kbd class="calibre16">SHA3-384</kbd>, and <kbd class="calibre16">SHA3-512</kbd>). Many developers' first thought is to reach for MD-5 or SHA-1, but those are no longer considered reliable. Using the new SHA-3 should guarantee we avoid any false positives.</p>
<p class="mce-root">The rest of the method is pretty interesting in terms of how it does its work. First, it reads all of the bytes of the specified file and passes them to <kbd class="calibre16">MessageDigest.update()</kbd>, which updates the internal state of the <kbd class="calibre16">MessageDigest</kbd> object to give us the hash we want. Next, we create a <kbd class="calibre16">ByteArrayInputStream</kbd> that wraps the results of <kbd class="calibre16">messageDigest.digest()</kbd>.</p>
<p class="mce-root">With our hash ready, we generate a string based on those bytes. We will do that by generating a stream via the <kbd class="calibre16">IntStream.generate()</kbd> method using the <kbd class="calibre16">InputStream</kbd> we just created as a source. We will limit the stream generation to the bytes available in the <kbd class="calibre16">inputStream</kbd>. For each byte, we will convert it to a string via <kbd class="calibre16">Integer.toHexString()</kbd>; then pad it with zero to two spaces, which prevents, for example, the single-digit hex characters <kbd class="calibre16">E</kbd> and <kbd class="calibre16">F</kbd> from being interpreted as <kbd class="calibre16">EF</kbd>; then collect them all into a string using <kbd class="calibre16">Collections.joining()</kbd>. Finally, we take that string value and update the <kbd class="calibre16">FileInfo</kbd> object.</p>
<p class="mce-root">The eagle-eyed might notice something interesting: we call <kbd class="calibre16">FileInfo.setHash()</kbd> to change the value of the object, but we never tell the system to persist those changes. This is because our <kbd class="calibre16">FileInfo</kbd> instance is a managed instance, meaning that we got it from JPA, which is keeping an eye on it, so to speak. Since we retrieved it via JPA, when we make any changes to its state, JPA knows it needs to persist those changes. When we call <kbd class="calibre16">em.getTransaction().commit()</kbd> in the calling method, JPA automatically saves those changes to the database.</p>
<div class="packt_tip">There's a catch to this automatic persistence: if you retrieve an object via JPA, then pass it across some sort of barrier that serializes the object, for example, across a remote EJB interface, then the JPA entity is said to be "detached". To reattach it to the persistence context, you will need to call <kbd class="calibre39">entityManager. merge()</kbd>, after which this behavior will resume. There is no need to call <kbd class="calibre39">entityManager.flush()</kbd> unless you have some need to synchronize the in-memory state of the persistence context with the underlying database.</div>
<p class="mce-root">Once we've calculated the hashes for the potential duplicates (at this point, given that they have duplicate SHA-3 hashes, they are almost certainly actual duplicates), we're ready to gather and report them:</p>
<pre class="calibre21">    getDuplicates(em, "hash").forEach(f -&gt; coalesceDuplicates(f)); 
    em.close(); </pre>
<p class="mce-root">We call the same <kbd class="calibre16">getDuplicates()</kbd> method to find duplicate hashes, and pass each record to the <kbd class="calibre16">coalesceDuplicates()</kbd> method, which will group these in a manner appropriate to report upstream to our CLI or GUI layers, or, perhaps, to any other program consuming this functionality:</p>
<pre class="calibre21">    private void coalesceDuplicates(FileInfo f) { 
      String name = f.getFileName(); 
      List&lt;FileInfo&gt; dupes = duplicates.get(name); 
      if (dupes == null) { 
        dupes = new ArrayList&lt;&gt;(); 
        duplicates.put(name, dupes); 
      } 
      dupes.add(f); 
    } </pre>
<p class="mce-root">This simple method follows what is likely a very familiar pattern:</p>
<ol class="calibre18">
<li class="chapter">Get a <kbd class="calibre16">List</kbd> from a <kbd class="calibre16">Map</kbd> based on the key, the filename.</li>
<li class="chapter">If the map doesn't exist, create it and add it to the map.</li>
<li class="chapter">Add the <kbd class="calibre16">FileInfo</kbd> object to the list.</li>
</ol>
<p class="mce-root">This completes the duplicate file detection. Back in <kbd class="calibre16">find()</kbd>, we will call <kbd class="calibre16">factory.close()</kbd> to be a good JPA citizen, then return to the calling code. With that, we're ready to build our CLI.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the command-line interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The primary means to interact with our new library will be the command-line interface we will now develop. Unfortunately, the Java SDK has nothing built in to help make sophisticated command-line utilities. If you've been using Java for any time, you've seen the following method signature:</p>
<pre class="calibre21">    public static void main(String[] args) </pre>
<p class="mce-root">Clearly, there is <em class="calibre20">a</em> mechanism to process command-line arguments. The <kbd class="calibre16">public static void main</kbd> method is passed string arrays that represent arguments provided by the user on the command line, but that's about as far as it goes. To parse the options, the developer is required to iterate over the array, analyzing each entry. It might look something like this:</p>
<pre class="calibre21">    int i = 0; 
    while (i &lt; args.length) { 
      if ("--source".equals(args[i])) { 
         System.out.println("--source = " + args[++i]); 
      } else if ("--target".equals(args[i])) { 
         System.out.println("--target = " + args[++i]); 
      } else if ("--force".equals(args[i])) { 
        System.out.println("--force set to true"); 
      } 
      i++; 
    } </pre>
<p class="mce-root">This is an effective solution, if very naive and error-prone. It assumes that whatever follows <kbd class="calibre16">--source</kbd> and <kbd class="calibre16">--target</kbd> is that argument's value. If the user types <kbd class="calibre16">--source --target /foo</kbd>, then our processor breaks. Clearly, something better is needed. Fortunately, we have options.</p>
<p class="mce-root">If you were to search for Java command-line libraries, you'll find an abundance of them (at least 10 at last count). Our space (and time) is limited here, so we obviously can't discuss all of them, so I'll mention the first three that I'm familiar with: Apache Commons CLI, Airline, and Crest. Each of these has some fairly significant differences from its competitors.</p>
<p class="mce-root">Commons CLI takes a more procedural approach; the list of available options, its name, description, whether or not it has arguments, and so forth, are all defined using Java method calls. Once the list of <kbd class="calibre16">Options</kbd> has been created, the command-line arguments are then manually parsed. The preceding example could be rewritten as follows:</p>
<pre class="calibre21">    public static void main(String[] args) throws ParseException { 
      Options options = new Options(); 
      options.addOption("s", "source", true, "The source"); 
      options.addOption("t", "target", true, "The target"); 
      options.addOption("f", "force", false, "Force"); 
      CommandLineParser parser = new DefaultParser(); 
      CommandLine cmd = parser.parse(options, args); 
      if (cmd.hasOption("source")) { 
        System.out.println("--source = " +  
          cmd.getOptionValue("source")); 
      } 
      if (cmd.hasOption("target")) { 
        System.out.println("--target = " +  
          cmd.getOptionValue("target")); 
      } 
      if (cmd.hasOption("force")) { 
         System.out.println("--force set to true"); 
      } 
    } </pre>
<p class="mce-root">It's certainly more verbose, but it's also clearly, I think, more robust. We can specify long and short names for the option (<kbd class="calibre16">--source</kbd> versus <kbd class="calibre16">-s</kbd>), we can give it a description, and, best of all, we get built-in validation that an option has its required value. As much of an improvement as this is, I've learned from experience that the procedural approach here gets tedious in practice. Let's take a look at our next candidate to see how it fares.</p>
<p class="mce-root">Airline is a command-line library originally written as part of the airlift organization on GitHub. After languishing for some time, it was forked by Rob Vesse and given a new life (<a href="http://rvesse.github.io/airline" class="pcalibre pcalibre3 pcalibre1 calibre12 pcalibre2"><span class="calibre5">http://rvesse.github.io/airline</span></a>). Airline's approach to command-line definition is more class-based--to define a command utility, you declare a new class, and mark it up appropriately with a number of annotations. Let's implement our preceding simple command line with Airline:</p>
<pre class="calibre21">    @Command(name = "copy", description = "Copy a file") 
    public class CopyCommand { 
      @Option(name = {"-s", "--source"}, description = "The source") 
      private String source; 
      @Option(name = {"-t", "--target"}, description = "The target") 
      private String target; 
      @Option(name = {"-f", "--force"}, description = "Force") 
      private boolean force = false; 
      public static void main(String[] args) { 
        SingleCommand&lt;CopyCommand&gt; parser =  
          SingleCommand.singleCommand(CopyCommand.class); 
        CopyCommand cmd = parser.parse(args); 
        cmd.run(); 
      } 
 
      private void run() { 
        System.out.println("--source = " + source); 
        System.out.println("--target = " + target); 
        if (force) { 
          System.out.println("--force set to true"); 
        } 
      } 
    } </pre>
<p class="mce-root">The options handling continues to grow in terms of code size, but we're also gaining more and more clarity as to what options are supported, and what they each mean. Our command is clearly defined via <kbd class="calibre16">@Command</kbd> on the class declaration. The possible options are delineated as <kbd class="calibre16">@Option</kbd>--annotated instance variables, and the business logic in <kbd class="calibre16">run()</kbd> is completely devoid of command-line parsing code. By the time this method is called, all the data has been extracted and we're ready to do our work. That looks very nice, but let's see what our last contender has to offer.</p>
<p class="mce-root">Crest is a library from Tomitribe, the company behind TomEE, the "all-Apache Java EE Web Profile certified stack" based on the venerable Tomcat Servlet container. Crest's approach to command definition is method based, where you define a method per command. It also uses annotations, and offers Bean Validation out of the box, as well as optional command discovery. Reimplementing our simple command, then, may look like this:</p>
<pre class="calibre21">    public class Commands { 
      @Command 
      public void copy(@Option("source") String source, 
        @Option("target") String target, 
        @Option("force") @Default("false") boolean force) { 
          System.out.println("--source = " + source); 
          System.out.println("--target = " + target); 
          if (force) { 
            System.out.println("--force set to true"); 
          } 
       } 
    } </pre>
<p class="mce-root">That seems to be the best of both worlds: it's nice and concise, and will still keep the actual logic of the command free from any CLI-parsing concerns, unless you're bothered by the annotations on the method. Although the actual logic-implementing code is free from such concerns. While Airline and Crest both offer things the other does not, Crest wins for me, so that's what we'll use to implement our command-line interface.</p>
<p class="mce-root">With a library chosen, then, let's take a look at what our CLI might look like. Most importantly, we need to be able to specify the path (or paths) we want to search. Likely, most files in those paths will have the same extension, but that certainly won't always be the case, so we want to allow the user to specify only the file patterns to match (for example, <kbd class="calibre16">.jpg</kbd>). Some users might also be curious about how long it takes to run the scan, so let's throw in a switch to turn on that output. And finally, let's add a switch to make the process a bit more verbose.</p>
<p class="mce-root">With our functional requirements set, let's start writing our command. Crest is method-based in its command declarations, but we'll still need a class to put our method in. If this CLI were more complicated (or, for example, if you were writing a CLI for an application server), you could easily put several CLI commands in the same class, or group similar commands in several different classes. How you structure them is completely your concern, as Crest is happy with whatever you choose.</p>
<p class="mce-root">We'll start with our CLI interface declaration as follows:</p>
<pre class="calibre21">    public class DupeFinderCommands { 
      @Command 
      public void findDupes( 
        @Option("pattern") List&lt;String&gt; patterns, 
        @Option("path") List&lt;String&gt; paths, 
        @Option("verbose") @Default("false") boolean verbose, 
        @Option("show-timings")  
        @Default("false") boolean showTimings) { </pre>
<p class="mce-root">Before we can discuss the preceding code, we need to declare our Java module:</p>
<pre class="calibre21">    module dupefind.cli { 
      requires tomitribe.crest; 
      requires tomitribe.crest.api; 
    } </pre>
<p class="mce-root">We've defined a new module, which is named similarly to our library's module name. We also declared that we <kbd class="calibre16">require</kbd> two Crest modules.</p>
<p class="mce-root">Back to our source code, we have the four parameters that we discussed in our functional requirements. Note that <kbd class="calibre16">patterns</kbd> and <kbd class="calibre16">paths</kbd> are defined as <kbd class="calibre16">List&lt;String&gt;</kbd>. When Crest is parsing the command line, if it finds multiple instances of one of these (for example, <kbd class="calibre16">--path=/path/one--path=/path/two</kbd>), it will collect all of these values and store them as a <kbd class="calibre16">List</kbd> for you. Also, note that <kbd class="calibre16">verbose</kbd> and <kbd class="calibre16">showTimings</kbd> are defined as <kbd class="calibre16">boolean</kbd>, so we see a nice example of the type coercion that Crest will do on our behalf. We also have default values for both of these, so we're sure to have sane, predictable values when our method executes.</p>
<p class="mce-root">The business logic of the method is pretty straightforward. We will handle the verbose flag upfront, printing a summary of the operation requested as follows:</p>
<pre class="calibre21">    if (verbose) { 
      System.out.println("Scanning for duplicate files."); 
      System.out.println("Search paths:"); 
      paths.forEach(p -&gt; System.out.println("t" + p)); 
      System.out.println("Search patterns:"); 
      patterns.forEach(p -&gt; System.out.println("t" + p)); 
      System.out.println(); 
    } </pre>
<p class="mce-root">Then we will perform the actual work. Thanks to the work we did building the library, all of the logic for the duplicate search is hidden away behind our API:</p>
<pre class="calibre21">    final Instant startTime = Instant.now(); 
    FileFinder ff = new FileFinder(); 
    patterns.forEach(p -&gt; ff.addPattern(p)); 
    paths.forEach(p -&gt; ff.addPath(p)); 
     
    ff.find(); 
 
    System.out.println("The following duplicates have been found:"); 
    final AtomicInteger group = new AtomicInteger(1); 
    ff.getDuplicates().forEach((name, list) -&gt; { 
      System.out.printf("Group #%d:%n", group.getAndIncrement()); 
      list.forEach(fileInfo -&gt; System.out.println("t"  
        + fileInfo.getPath())); 
    }); 
    final Instant endTime = Instant.now(); </pre>
<p class="mce-root">This code won't compile at first, as we've not told the system we need it. We can do that now:</p>
<pre class="calibre21">    module dupefind.cli { 
      requires dupefind.lib; 
      requires tomitribe.crest; 
      requires tomitribe.crest.api; 
    } </pre>
<p class="mce-root">We can now import the <kbd class="calibre16">FileFinder</kbd> class. First, to demonstrate that the modules are, in fact, doing what they're supposed to do, let's try to import something that wasn't exported: <kbd class="calibre16">FindFileTask</kbd>. Let's create a simple class:</p>
<pre class="calibre21">    import com.steeplesoft.dupefind.lib.model.FileInfo; 
    import com.steeplesoft.dupefind.lib.util.FindFileTask; 
    public class VisibilityTest { 
      public static void main(String[] args) { 
        FileInfo fi; 
        FindFileTask fft; 
      } 
    } </pre>
<p class="mce-root">If we try to compile this, Maven/javac will complain loudly with an error message like this:</p>
<pre class="calibre21"><strong class="calibre3">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.6.1:compile (default-compile) on project cli: Compilation failure: Compilation failure:
[ERROR] /C:/Users/jason/src/steeplesoft/DupeFinder/cli/src/main/java/com/</strong><br class="calibre2"/><strong class="calibre3">steeplesoft/dupefind/cli/VisibilityTest.java:[9,54] </strong><br class="calibre2"/><strong class="calibre3">com.steeplesoft.dupefind.lib.util.FindFileTask is not visible because </strong><br class="calibre2"/><strong class="calibre3">package com.steeplesoft.dupefind.lib.util is not visible 
[ERROR] /C:/Users/jason/src/steeplesoft/DupeFinder/cli/src/main/java/com/</strong><br class="calibre2"/><strong class="calibre3">steeplesoft/dupefind/cli/VisibilityTest.java:[13,9] cannot find symbol 
[ERROR] symbol:   class FindFileTask 
[ERROR] location: class com.steeplesoft.dupefind.cli.VisibilityTest</strong> </pre>
<p class="mce-root">We have successfully hidden our utility classes while exposing our public API. It may take some time for this practice to become widespread, but it should work wonders in preventing the crystallization of private APIs as pseudo-public.</p>
<p class="mce-root">Back on task, we create an instance of our <kbd class="calibre16">FileFinder</kbd> class, use <kbd class="calibre16">String.forEach</kbd> to pass our <kbd class="calibre16">paths</kbd> and <kbd class="calibre16">patterns</kbd> to the finder, then start the work with a call to <kbd class="calibre16">find()</kbd>. The work itself is threaded, but we've exposed a synchronous API, so our call here will block until the work has been completed. Once it returns, we start printing details to the screen. Since <kbd class="calibre16">FindFiles.getDuplicates()</kbd> returns <kbd class="calibre16">Map&lt;String, List&lt;FileInfo&gt;&gt;</kbd>, we call <kbd class="calibre16">forEach()</kbd> on the <kbd class="calibre16">Map</kbd> to iterate over each key, then we call <kbd class="calibre16">forEach()</kbd> on the <kbd class="calibre16">List</kbd> to print information about each file. We also use an <kbd class="calibre16">AtomicInteger</kbd> as the index, as the variable must be final or effectively final, so we just use a <kbd class="calibre16">final</kbd> instance of <kbd class="calibre16">AtomicInteger</kbd>. <kbd class="calibre16">BigInteger</kbd> may come to mind to more experienced developers, but it's immutable, so that makes it a poor choice for our use here.</p>
<p class="mce-root">The output of running the command will look something like this:</p>
<pre class="calibre21"><strong class="calibre3">The following duplicates have been found: 
Group #1: 
     C:somepathtestset1file5.txt 
     C:somepathtestset2file5.txt 
Group #2: 
     C:somepathtestset1file11.txt 
     C:somepathtestset1file11-1.txt 
     C:somepathtestset2file11.txt</strong> </pre>
<p class="mce-root">Next, we handle <kbd class="calibre16">showTimings</kbd>. I didn't call it out in the preceding code, though I will now, but we get an <kbd class="calibre16">Instant</kbd> instance (from the Java 8 date/time library in <kbd class="calibre16">java.time</kbd>) before and after processing. Only when <kbd class="calibre16">showTimings</kbd> is true do we actually do anything with them. The code that does that looks like this:</p>
<pre class="calibre21">    if (showTimings) { 
      Duration duration = Duration.between(startTime, endTime); 
      long hours = duration.toHours(); 
      long minutes = duration.minusHours(hours).toMinutes(); 
      long seconds = duration.minusHours(hours) 
         .minusMinutes(minutes).toMillis() / 1000; 
      System.out.println(String.format( 
        "%nThe scan took %d hours, %d minutes, and %d seconds.%n",  
         hours, minutes, seconds)); 
    } </pre>
<p class="mce-root">With our two <kbd class="calibre16">Instant</kbd>, we get a <kbd class="calibre16">Duration</kbd>, then start calculating hours, minutes, and seconds. Hopefully, this never runs more than an hour, but it can't hurt to be ready for it. And that's all there is to the CLI, in terms of code. Crest did the heavy lifting for our command-line parameter parsing, leaving us with a straightforward and clean implementation of our logic.</p>
<p class="mce-root">There's one last thing we need to add, and that's the CLI help. It would be very helpful for the end user to be able to find out how to use our command. Fortunately, Crest has support built in to provide that information. To add the help information, we need to create a file called <kbd class="calibre16">OptionDescriptions.properties</kbd> in the same package as our command class (remember that since we're using Maven, this file should be under <kbd class="calibre16">src/main/resource</kbd>), as follows:</p>
<pre class="calibre21"><strong class="calibre3">    path = Adds a path to be searched. Can be specified multiple times. 
    pattern = Adds a pattern to match against the file names (e.g.,<br class="calibre2"/>    "*.png").<br class="calibre2"/>    Can be specified multiple times. 
    show-timings= Show how long the scan took 
    verbose = Show summary of duplicate scan configuration</strong> </pre>
<p class="mce-root">Doing so will produce an output like this:</p>
<pre class="calibre21"><strong class="calibre3">    $ java -jar cli-1.0-SNAPSHOT.jar help findDupes 
    Usage: findDupes [options] 
    Options: 
      --path=&lt;String[]&gt;    Adds a path to be searched. Can be<br class="calibre2"/>                            specified multiple times. 
      --pattern=&lt;String[]&gt; Adds a pattern to match against<br class="calibre2"/>                            the file names<br class="calibre2"/>                           (e.g., "*.png"). Can be specified<br class="calibre2"/>                             multiple times. 
      --show-timings       Show how long the scan took 
      --verbose            Show summary of duplicate scan configuration</strong> </pre>
<p class="mce-root">You can be as verbose as you need to be without making your source code an unreadable mess.</p>
<p class="mce-root">With that, our CLI is feature-complete. Before we move on, we need to take a look at some build concerns for our CLI and see how Crest fits in. Obviously, we need to tell Maven where to find our Crest dependency, which is shown in the following piece of code:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;org.tomitribe&lt;/groupId&gt; 
      &lt;artifactId&gt;tomitribe-crest&lt;/artifactId&gt; 
      &lt;version&gt;${crest.version}&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">We also need to tell it where to find our duplicate finder library as follows:</p>
<pre class="calibre21">    &lt;dependency&gt; 
      &lt;groupId&gt;${project.groupId}&lt;/groupId&gt; 
      &lt;artifactId&gt;lib&lt;/artifactId&gt; 
      &lt;version&gt;${project.version}&lt;/version&gt; 
    &lt;/dependency&gt; </pre>
<p class="mce-root">Note <kbd class="calibre16">groupId</kbd> and <kbd class="calibre16">version</kbd>: since our CLI and library modules are part of the same parent multi-module build, we set <kbd class="calibre16">groupId</kbd> and <kbd class="calibre16">version</kbd> to that of the parent module, allowing us to manage that from a single location, which makes changing groups or bumping versions much simpler.</p>
<p class="mce-root">The more interesting part is the <kbd class="calibre16">build</kbd> section of our POM. First, let's start with <kbd class="calibre16">maven-compiler-plugin</kbd>. While we are targeting Java 9, <kbd class="calibre16">crest-maven-plugin</kbd>, which we'll look at in a moment, does not currently seem to like the classes generated for Java 9, so we instruct the compiler plugin to emit Java 1.8 bytecode:</p>
<pre class="calibre21">    &lt;plugin&gt; 
      &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; 
      &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; 
      &lt;configuration&gt; 
         &lt;source&gt;1.8&lt;/source&gt; 
         &lt;target&gt;1.8&lt;/target&gt; 
      &lt;/configuration&gt; 
    &lt;/plugin&gt; </pre>
<p class="mce-root">Next, we need to set up <kbd class="calibre16">crest-maven-plugin</kbd>. To expose our command classes to Crest, we have two options: we can use runtime scanning for the classes, or we can have Crest scan for commands at build time. In order to make this utility as small as possible, as well as reducing the startup time as much as possible, we will opt for the latter approach, so we will need to add another plugin to the build, as follows:</p>
<pre class="calibre21">    &lt;plugin&gt; 
      &lt;groupId&gt;org.tomitribe&lt;/groupId&gt; 
      &lt;artifactId&gt;crest-maven-plugin&lt;/artifactId&gt; 
      &lt;version&gt;${crest.version}&lt;/version&gt; 
      &lt;executions&gt; 
         &lt;execution&gt; 
            &lt;goals&gt; 
              &lt;goal&gt;descriptor&lt;/goal&gt; 
            &lt;/goals&gt; 
         &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt; </pre>
<p class="mce-root">When this plugin runs, it will generate a file called <kbd class="calibre16">crest-commands.txt</kbd> that Crest will process to find classes when it starts. It may not save much time here, but it's definitely something to keep in mind for larger projects.</p>
<p class="mce-root">Finally, we don't want the user to have to worry about setting up the classpath (or module path!) each time, so we'll introduce the Maven Shade plugin, which will create a single, fat jar with all of our dependencies, transitive and otherwise:</p>
<pre class="calibre21">    &lt;plugin&gt; 
      &lt;artifactId&gt;maven-shade-plugin&lt;/artifactId&gt; 
      &lt;version&gt;2.1&lt;/version&gt; 
      &lt;executions&gt; 
         &lt;execution&gt; 
             &lt;phase&gt;package&lt;/phase&gt; 
             &lt;goals&gt; 
                &lt;goal&gt;shade&lt;/goal&gt; 
              &lt;/goals&gt; 
              &lt;configuration&gt; 
                 &lt;transformers&gt; 
                   &lt;transformer implementation= <br class="calibre2"/>                     "org.apache.maven.plugins.shade.resource<br class="calibre2"/>                      .ManifestResourceTransformer"&gt; 
                     &lt;mainClass&gt; 
                       org.tomitribe.crest.Main 
                     &lt;/mainClass&gt; 
                   &lt;/transformer&gt; 
                 &lt;/transformers&gt; 
              &lt;/configuration&gt; 
         &lt;/execution&gt; 
      &lt;/executions&gt; 
    &lt;/plugin&gt; </pre>
<p class="mce-root">After the build, we can then run a search with the following command:</p>
<pre class="calibre21"><strong class="calibre3">    java -jar targetcli-1.0-SNAPSHOT.jar findDupes 
      --path=../test/set1 --path=../test/set2 -pattern=*.txt</strong> </pre>
<p class="mce-root">Clearly, it can still be improved, so we would want to ship that, say, with script wrappers (shell, batch, and so on), but the number of jars is cut down from 18 or so to 1, so that's a big improvement.</p>
<p class="mce-root">With our CLI done, let's make a simple GUI that consumes our library as well.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Building the graphical user interface</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">For our GUI, we'd like to expose the same type of functionality as the command line, but, obviously, with a nice graphical interface. For this, we'll again reach for JavaFX. We'll give the user a means to select, using a chooser dialog, the directories to be searched, and a field by which to add the search patterns. Once the duplicates have been identified, we will display them in a list for the user to peruse. All of the duplicate groups will be listed and, when clicked, the files in that group will be displayed in another list. The user can right-click on the list and choose to either view the file (or files) or delete it (or them). When we are finished, the application will look like this:</p>
<div class="mce-root1"><img class="image-border16" src="Images/22589176-b54f-485f-9c1e-0b21ce2a8896.png"/></div>
<p class="mce-root">Let's start by creating our project. In NetBeans, go to <span class="calibre7">File</span> | <span class="calibre7">New Project</span> and select <span class="calibre7">Maven</span> | <span class="calibre7">JavaFX Application</span>. You can name it whatever you'd like, but we've used the name <kbd class="calibre16">Duplicate Finder - GUI</kbd>, <kbd class="calibre16">groupId</kbd> as <kbd class="calibre16">com.steeplesoft.dupefind</kbd>, and <kbd class="calibre16">artifactId</kbd> as <kbd class="calibre16">gui</kbd>.</p>
<p class="mce-root">Once you have your project, you should have two classes, <kbd class="calibre16">Main</kbd> and <kbd class="calibre16">FXMLController</kbd>, as well as the <kbd class="calibre16">fxml/Scene.fxml</kbd> resource. This may sound repetitive, but before we go any further, we need to set up our Java module as follows:</p>
<pre class="calibre21">    module dupefind.gui { 
      requires dupefind.lib; 
      requires java.logging; 
      requires javafx.controls; 
      requires javafx.fxml; 
      requires java.desktop; 
    } </pre>
<p class="mce-root">Then, to create the interface we saw, we will use <kbd class="calibre16">BorderPane</kbd>, to which we'll add <kbd class="calibre16">MenuBar</kbd> to the <kbd class="calibre16">top</kbd> section, as follows:</p>
<pre class="calibre21">    &lt;top&gt; 
      &lt;MenuBar BorderPane.alignment="CENTER"&gt; 
        &lt;menus&gt; 
          &lt;Menu mnemonicParsing="false"  
            onAction="#closeApplication" text="File"&gt; 
            &lt;items&gt; 
              &lt;MenuItem mnemonicParsing="false" text="Close" /&gt; 
            &lt;/items&gt; 
          &lt;/Menu&gt; 
          &lt;Menu mnemonicParsing="false" text="Help"&gt; 
            &lt;items&gt; 
              &lt;MenuItem mnemonicParsing="false"  
                onAction="#showAbout" text="About" /&gt; 
            &lt;/items&gt; 
          &lt;/Menu&gt; 
        &lt;/menus&gt; 
      &lt;/MenuBar&gt; 
    &lt;/top&gt; </pre>
<p class="mce-root">When you add <kbd class="calibre16">MenuBar</kbd> with Scene Builder, it automatically adds several sample <kbd class="calibre16">Menu</kbd> entries for you. We've removed the unwanted entries, and tied the remaining to Java methods in the controller class. Specifically, the <kbd class="calibre16">Close</kbd> menu will call <kbd class="calibre16">closeApplication()</kbd> and <kbd class="calibre16">About</kbd> will call <kbd class="calibre16">showAbout()</kbd>. This looks just like the menu markup seen previously in the book, so there's not much to talk about.</p>
<p class="mce-root">The rest of the layout is a bit more complex. In the <kbd class="calibre16">left</kbd> section, we have a number of controls stacked vertically. JavaFX has a built-in container that makes that easy to do: <kbd class="calibre16">VBox</kbd>. We'll get to its contents in a moment, but its usage looks like this:</p>
<pre class="calibre21">    &lt;VBox BorderPane.alignment="TOP_CENTER"&gt; 
      &lt;children&gt; 
         &lt;HBox... /&gt; 
         &lt;Separator ... /&gt; 
         &lt;Label .../&gt; 
         &lt;ListView ... /&gt; 
         &lt;HBox ... /&gt; 
         &lt;Label ... /&gt; 
         &lt;ListView... /&gt; 
         &lt;HBox ... /&gt; 
      &lt;/children&gt; 
      &lt;padding&gt; 
         &lt;Insets bottom="10.0" left="10.0" right="10.0" <br class="calibre2"/>           top="10.0" /&gt; 
      &lt;/padding&gt; 
    &lt;/VBox&gt; </pre>
<p class="mce-root">That's not valid FXML, so don't try to copy and paste that. I've omitted the details of the children for clarity. As you can see, <kbd class="calibre16">VBox</kbd> has a number of children, each of which will be stacked vertically, but, as we can see from the preceding screenshot, there are some we want to be lined up horizontally. To achieve that, we nest an <kbd class="calibre16">HBox</kbd> instance where needed. Its markup looks just like <kbd class="calibre16">VBox</kbd>.</p>
<p class="mce-root">There's not much of interest in this part of the FXML, but there are a couple of things to note. We want certain parts of the user interface to shrink and grow as the window is resized, namely <kbd class="calibre16">ListView</kbd>. By default, each component's various height and width properties--minimum, maximum, and preferred--will use the computed size, which means, roughly, that they'll be as big as they need to be to render themselves, and, in most cases, that's fine. In our situation, we want the two <kbd class="calibre16">ListView</kbd> instances to grow as much as possible inside their respective containers, which, in this case, is <kbd class="calibre16">VBox</kbd> we discussed earlier. To make that happen, we need to modify our two <kbd class="calibre16">ListView</kbd> instances like this:</p>
<pre class="calibre21">    &lt;ListView fx:id="searchPatternsListView" VBox.vgrow="ALWAYS" /&gt; 
    ... 
    &lt;ListView fx:id="sourceDirsListView" VBox.vgrow="ALWAYS" /&gt; </pre>
<p class="mce-root">With both the <kbd class="calibre16">ListView</kbd> instances set to <kbd class="calibre16">ALWAYS</kbd> grow, they will compete with each other for the available space, and end up sharing it. The available space, of course, is dependent on the height of the <kbd class="calibre16">VBox</kbd> instance, as well as the computed height of the other components in the container. With that property set, we can increase or decrease the size of the window, and watch the two <kbd class="calibre16">ListView</kbd> instances grow and shrink, while everything else remains the same.</p>
<p class="mce-root">For the rest of the user interface, we'll apply the same tactic to arrange components, but, this time, we'll start with an <kbd class="calibre16">HBox</kbd> instance, and divide that up as necessary. We have two <kbd class="calibre16">ListView</kbd> instances that we also want to fill all the available space with, so we mark those up in the same way we did the last two. Each <kbd class="calibre16">ListView</kbd> instance also has a <kbd class="calibre16">Label</kbd>, so we wrap each <kbd class="calibre16">Label</kbd>/<kbd class="calibre16">ListView</kbd> pair in a <kbd class="calibre16">VBox</kbd> instance to get our vertical distribution. In pseudo-FXML, this would look like this:</p>
<pre class="calibre21">    &lt;HBox&gt; 
      &lt;children&gt; 
         &lt;Separator orientation="VERTICAL"/&gt; 
         &lt;VBox HBox.hgrow="ALWAYS"&gt; 
           &lt;children&gt; 
             &lt;VBox VBox.vgrow="ALWAYS"&gt; 
                &lt;children&gt; 
                  &lt;Label ... /&gt; 
                  &lt;ListView ... VBox.vgrow="ALWAYS" /&gt; 
                &lt;/children&gt; 
             &lt;/VBox&gt; 
           &lt;/children&gt; 
         &lt;/VBox&gt; 
         &lt;VBox HBox.hgrow="ALWAYS"&gt; 
           &lt;children&gt; 
             &lt;Label ... /&gt; 
             &lt;ListView ... VBox.vgrow="ALWAYS" /&gt; 
           &lt;/children&gt; 
         &lt;/VBox&gt; 
      &lt;/children&gt; 
    &lt;/HBox&gt; </pre>
<p class="mce-root">There is one item of interest in this part of the user interface, and that is the context menu we discussed earlier. To add a context to a control, you nest a <kbd class="calibre16">contextMenu</kbd> element in the target control's FXML like this:</p>
<pre class="calibre21">    &lt;ListView fx:id="matchingFilesListView" VBox.vgrow="ALWAYS"&gt; 
      &lt;contextMenu&gt; 
        &lt;ContextMenu&gt; 
          &lt;items&gt; 
            &lt;MenuItem onAction="#openFiles" text="Open File(s)..." /&gt; 
            &lt;MenuItem onAction="#deleteSelectedFiles"  
              text="Delete File(s)..." /&gt; 
           &lt;/items&gt; 
         &lt;/ContextMenu&gt; 
      &lt;/contextMenu&gt; 
    &lt;/ListView&gt; </pre>
<p class="mce-root">We've defined a content menu with two <kbd class="calibre16">MenuItem</kbd>: <kbd class="calibre16">"Open File(s)..."</kbd> and <kbd class="calibre16">"Deleted File(s)..."</kbd>. We've also specified the action for the two <kbd class="calibre16">MenuItem</kbd> using the <kbd class="calibre16">onAction</kbd> attribute. We'll look at these following methods.</p>
<p class="mce-root">This marks the end of our user interface definition, so now we turn our attention to the Java code, in which we will finish preparing the user interface for use, as well as implement our application's logic.</p>
<p class="mce-root">While we didn't show the FXML that accomplishes this, our FXML file is tied to our controller class: <kbd class="calibre16">FXMLController</kbd>. This class can be called anything, of course, but we've opted to use the name generated by the IDE. In a larger application, more care will need to be given in the naming of this class. To allow the injection of our user interface components into our code, we need to declare instance variables on our class, and mark them up with the <kbd class="calibre16">@FXML</kbd> annotation. Some examples include the following:</p>
<pre class="calibre21">    @FXML 
    private ListView&lt;String&gt; dupeFileGroupListView; 
    @FXML 
    private ListView&lt;FileInfo&gt; matchingFilesListView; 
    @FXML 
    private Button addPattern; 
    @FXML 
    private Button removePattern; </pre>
<p class="mce-root">There are several others, but this should be sufficient to demonstrate the concept. Note that rather than declaring a plain <kbd class="calibre16">ListView</kbd>, we've parameterized our instances as <kbd class="calibre16">ListView&lt;String&gt;</kbd> and <kbd class="calibre16">ListView&lt;FileInfo&gt;</kbd>. We know this is what we're putting into the control, so specifying that the type parameter gets us a measure of type safety at compile time, but also allows us to avoid having to cast the contents every time we interact with them.</p>
<p class="mce-root">Next, we need to set up the collections that will hold the search paths and patterns that the user will enter. We'll use the <kbd class="calibre16">ObservableList</kbd> instances for that. Remember that with an <kbd class="calibre16">ObservableList</kbd> instance, the container can automatically rerender itself as needed when the <kbd class="calibre16">Observable</kbd> instance is updated:</p>
<pre class="calibre21">    final private ObservableList&lt;String&gt; paths =  
      FXCollections.observableArrayList(); 
    final private ObservableList&lt;String&gt; patterns =  
      FXCollections.observableArrayList(); </pre>
<p class="mce-root">In the <kbd class="calibre16">initialize()</kbd> method, we can start tying things together. Consider the following code snippet as an example:</p>
<pre class="calibre21">    public void initialize(URL url, ResourceBundle rb) { 
      searchPatternsListView.setItems(patterns); 
      sourceDirsListView.setItems(paths); </pre>
<p class="mce-root">Here, we associate our <kbd class="calibre16">ListView</kbd> instances with our <kbd class="calibre16">ObservableList</kbd> instances. Now, at any point that these lists are updated, the user interface will immediately reflect the change.</p>
<p class="mce-root">Next, we need to configure the duplicate file group <kbd class="calibre16">ListView</kbd>. The data coming back from our library is a <kbd class="calibre16">Map</kbd> of a <kbd class="calibre16">List&lt;FileInfo&gt;</kbd> object, keyed by the duplicate hashes. Clearly, we don't want to show the user a list of hashes, so, like the CLI, we want to denote each group of files with a more friendly label. To do that, we need to create a <kbd class="calibre16">CellFactory</kbd>, which will, in turn, create a <kbd class="calibre16">ListCell</kbd> that is responsible for rendering the cell. We will do that as follows:</p>
<pre class="calibre21">    dupeFileGroupListView.setCellFactory( 
      (ListView&lt;String&gt; p) -&gt; new ListCell&lt;String&gt;() { 
        @Override 
        public void updateItem(String string, boolean empty) { 
          super.updateItem(string, empty); 
          final int index = p.getItems().indexOf(string); 
          if (index &gt; -1) { 
            setText("Group #" + (index + 1)); 
          } else { 
            setText(null); 
          } 
       } 
    }); </pre>
<p class="mce-root">While lambdas can be great, in that they tend to make code more concise, they can also obscure some details. In a non-lambda code, the lambda above might look like this:</p>
<pre class="calibre21">    dupeFileGroupListView.setCellFactory(new  
      Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt;() { 
        @Override 
        public ListCell&lt;String&gt; call(ListView&lt;String&gt; p) { 
          return new ListCell&lt;String&gt;() { 
            @Override 
            protected void updateItem(String t, boolean bln) { 
             super.updateItem(string, empty); 
              final int index = p.getItems().indexOf(string); 
              if (index &gt; -1) { 
                setText("Group #" + (index + 1)); 
              } else { 
                setText(null); 
              } 
            } 
          }; 
        } 
    }); </pre>
<p class="mce-root">You certainly get more detail, but it's also much harder to read. The main point in including both here is twofold: to show why lambdas are often so much better, and to show the actual types involved, which helps the lambdas make sense. With that understanding of the lambdas under our belts, what is the method doing?</p>
<p class="mce-root">First, we call <kbd class="calibre16">super.updateItem()</kbd>, as that's simply good practice. Next, we find the index of the string being rendered. The API gives us the string (since it's a <kbd class="calibre16">ListView&lt;String&gt;</kbd>), so we find its index in our <kbd class="calibre16">ObservableList&lt;String&gt;</kbd>. If it's found, we set the text of the cell to <kbd class="calibre16">Group #</kbd> plus the index plus one (since indexes in Java are typically zero-based). If the string isn't found (<kbd class="calibre16">ListView</kbd> is rendering an empty cell), we set the text to null to ensure that the field is blank.</p>
<p class="mce-root">Next, we need to perform a similar procedure on <kbd class="calibre16">matchingFilesListView</kbd>:</p>
<pre class="calibre21">    matchingFilesListView.getSelectionModel() 
      .setSelectionMode(SelectionMode.MULTIPLE); 
    matchingFilesListView.setCellFactory( 
      (ListView&lt;FileInfo&gt; p) -&gt; new ListCell&lt;FileInfo&gt;() { 
        @Override 
        protected void updateItem(FileInfo fileInfo, boolean bln) { 
          super.updateItem(fileInfo, bln); 
          if (fileInfo != null) { 
             setText(fileInfo.getPath()); 
          } else { 
             setText(null); 
          } 
        } 
    }); </pre>
<p class="mce-root">This is almost identical, but with a couple of exceptions. First, we're setting the selection mode of <kbd class="calibre16">ListView</kbd> to <kbd class="calibre16">MULTIPLE</kbd>. This will allow the user to control-click on items of interest, or shift-click on a range of rows. Next, we set up <kbd class="calibre16">CellFactory</kbd> in an identical fashion. Note that since the <kbd class="calibre16">ListView</kbd> instance's parameterized type is <kbd class="calibre16">FileInfo</kbd>, the types in the method signature of <kbd class="calibre16">ListCell.updateItem()</kbd> are different.</p>
<p class="mce-root">We have one last user interface setup step. If you look back at the screenshot, you will notice that the <span class="calibre7">Find Duplicates</span> button is the same width as <kbd class="calibre16">ListView</kbd>, unlike the other buttons, which are just wide enough to render their content. We do that by binding the width of the <kbd class="calibre16">Button</kbd> element to that of its container, which is an <kbd class="calibre16">HBox</kbd> instance:</p>
<pre class="calibre21">    findFiles.prefWidthProperty().bind(findBox.widthProperty()); </pre>
<p class="mce-root">We are getting the preferred width property, which is a <kbd class="calibre16">DoubleProperty</kbd>, and binding that to the width property (also a <kbd class="calibre16">DoubleProperty</kbd>) of <kbd class="calibre16">findBox</kbd>, the control's container. <kbd class="calibre16">DoubleProperty</kbd> is an <kbd class="calibre16">Observable</kbd> instance, just as <kbd class="calibre16">ObservableListView</kbd> is, so we're telling the <kbd class="calibre16">findFiles</kbd> control to observe its container's width property, and set its own value accordingly when the other changes. This lets us set the property, after a fashion, and then forget about it. Unless we want to break the binding between these two properties, we never again have to think about it, and we certainly don't need to manually watch one property to update the author. The framework does that for us.</p>
<p class="mce-root">Now, how about those buttons? How do we make them do something? We do that by setting the <kbd class="calibre16">onAction</kbd> property of the <kbd class="calibre16">Button</kbd> element to a method in our controller: <kbd class="calibre16">#someMethod</kbd> translates to <kbd class="calibre16">Controller.someMethod(ActionEvent event)</kbd>. We can handle this in one of at least two ways: we can create a separate handler method for each button, or, as we've done here, we can create one, then delegate to another method as appropriate; either is fine<span class="calibre7">:</span></p>
<pre class="calibre21">    @FXML 
    private void handleButtonAction(ActionEvent event) { 
      if (event.getSource() instanceof Button) { 
        Button button = (Button) event.getSource(); 
        if (button.equals(addPattern)) { 
          addPattern(); 
        } else if (button.equals(removePattern)) { 
        // ... </pre>
<p class="mce-root">We have to make sure we're actually getting a <kbd class="calibre16">Button</kbd> element, then we cast it and compare it to the instances that were injected. The actual handlers for each button are as follows:</p>
<pre class="calibre21">    private void addPattern() { 
      TextInputDialog dialog = new TextInputDialog("*.*"); 
      dialog.setTitle("Add a pattern"); 
      dialog.setHeaderText(null); 
      dialog.setContentText("Enter the pattern you wish to add:"); 

      dialog.showAndWait() 
      .filter(n -&gt; n != null &amp;&amp; !n.trim().isEmpty()) 
      .ifPresent(name -&gt; patterns.add(name)); 
    } </pre>
<p class="mce-root">To add a pattern, we create a <kbd class="calibre16">TextInputDialog</kbd> instance with the appropriate text, then call <kbd class="calibre16">showAndWait()</kbd>. The beauty of this method in JavaFX 8 is that it returns <kbd class="calibre16">Optional&lt;String&gt;</kbd>. If the user enters text in the dialog, and if the user clicks on OK, the <kbd class="calibre16">Optional</kbd> will have content. We identify that with the call to <kbd class="calibre16">ifPresent()</kbd>, passing it a lambda that adds the new pattern to <kbd class="calibre16">ObservableList&lt;String&gt;</kbd>, which automatically updates the user interface. If the user doesn't click on <span class="calibre7">OK</span>, the <kbd class="calibre16">Optional</kbd> will be empty. If the user didn't enter any text (or entered a bunch of spaces), the call to <kbd class="calibre16">filter()</kbd> will prevent the lambda from ever running.</p>
<p class="mce-root">Removing an item is similar, though we get to hide some of the details in a utility method, since we have two needs for the functionality. We make sure something is selected, then show a confirmation dialog, removing the pattern from the <kbd class="calibre16">ObservableList&lt;String&gt;</kbd> if the user clicks on <span class="calibre7">OK</span>:</p>
<pre class="calibre21">    private void removePattern() { 
      if (searchPatternsListView.getSelectionModel() 
      .getSelectedIndex() &gt; -1) { 
        showConfirmationDialog( 
          "Are you sure you want to remove this pattern?", 
          (() -&gt; patterns.remove(searchPatternsListView 
          .getSelectionModel().getSelectedItem()))); 
      } 
    } </pre>
<p class="mce-root">Let's take a look at the <kbd class="calibre16">showConfirmationDialog</kbd> method:</p>
<pre class="calibre21">    protected void showConfirmationDialog(String message, 
     Runnable action) { 
      Alert alert = new Alert(Alert.AlertType.CONFIRMATION); 
      alert.setTitle("Confirmation"); 
      alert.setHeaderText(null); 
      alert.setContentText(message); 
      alert.showAndWait() 
      .filter(b -&gt; b == ButtonType.OK) 
      .ifPresent(b -&gt; action.run()); 
    } </pre>
<p class="mce-root">Again, this is much like the dialogs earlier, and should be self-explanatory. The interesting part here is the use of a lambda as a method parameter that makes this, by the way, a higher order function--meaning it takes in a function as a parameter, returns a function as its result, or both. We pass in <kbd class="calibre16">Runnable</kbd>, as we want a lambda that takes in nothing and returns nothing, and <kbd class="calibre16">Runnable</kbd> is a <kbd class="calibre16">FunctionalInterface</kbd> that matches that description. After we show the dialog and get the user's response, we will filter for only responses where the button clicked on was <kbd class="calibre16">OK</kbd>, and, if present, we execute <kbd class="calibre16">Runnable</kbd> via <kbd class="calibre16">action.run()</kbd>. We have to specify <kbd class="calibre16">b -&gt; action.run()</kbd> as <kbd class="calibre16">ifPresent()</kbd> takes a <kbd class="calibre16">Consumer&lt;? super ButtonType&gt;</kbd>, so we create one and ignore the value passed in, allowing us to shield our calling code from that detail.</p>
<p class="mce-root">Adding a path requires a <kbd class="calibre16">DirectoryChooser</kbd> instance:</p>
<pre class="calibre21">    private void addPath() { 
        DirectoryChooser dc = new DirectoryChooser(); 
        dc.setTitle("Add Search Path"); 
        dc.setInitialDirectory(new File(lastDir)); 
        File dir = dc.showDialog(null); 
        if (dir != null) { 
            try { 
                lastDir = dir.getParent(); 
                paths.add(dir.getCanonicalPath()); 
            } catch (IOException ex) { 
                Logger.getLogger(FXMLController.class.getName()).log(<br class="calibre2"/>                  Level.SEVERE, null, ex); 
            } 
        } 
    } </pre>
<p class="mce-root">When creating the <kbd class="calibre16">DirectoryChooser</kbd> instance, we set the initial directory to the last directory used as a convenience for the user. When the application starts, this defaults to the user's home directory, but once a directory is successfully chosen, we set <kbd class="calibre16">lastDir</kbd> to the added directory's parent, allowing the user to start where he or she left off should there be a need to enter multiple paths. <kbd class="calibre16">DirectoryChooser.showDialog()</kbd> returns a file, so we get its canonical path and store that in paths, which, again, causes our user interface to be updated automatically.</p>
<p class="mce-root">Removing a path looks very similar to removing a pattern, as you can see in the following code snippet:</p>
<pre class="calibre21">    private void removePath() { 
      showConfirmationDialog( 
        "Are you sure you want to remove this path?", 
        (() -&gt; paths.remove(sourceDirsListView.getSelectionModel() 
        .getSelectedItem()))); 
    } </pre>
<p class="mce-root">Same basic code, just a different lambda. Aren't lambdas just the coolest?</p>
<p class="mce-root">The handler for the <kbd class="calibre16">findFiles()</kbd> button is a bit different, but looks a lot like our CLI code, as you can see here:</p>
<pre class="calibre21">    private void findFiles() { 
       FileFinder ff = new FileFinder(); 
       patterns.forEach(p -&gt; ff.addPattern(p)); 
       paths.forEach(p -&gt; ff.addPath(p)); 
 
       ff.find(); 
       dupes = ff.getDuplicates(); 
       ObservableList&lt;String&gt; groups =  
         FXCollections.observableArrayList(dupes.keySet()); 
 
       dupeFileGroupListView.setItems(groups); 
    } </pre>
<p class="mce-root">We create our <kbd class="calibre16">FileFinder</kbd> instance, set the paths and patterns using streams and lambdas, then start the search process. When it completes, we get the list duplicate file information via <kbd class="calibre16">getDuplicates()</kbd>, then create a new <kbd class="calibre16">ObservableList&lt;String&gt;</kbd> instance using the keys of the map, which we then set on <kbd class="calibre16">dupeFileGroupListView</kbd>.</p>
<p class="mce-root">Now we need to add the logic to handle mouse clicks on the group list, so we will set the <kbd class="calibre16">onMouseClicked</kbd> property on <kbd class="calibre16">ListView</kbd> in the FXML file to <kbd class="calibre16">#dupeGroupClicked</kbd>, as you can see in the following code block:</p>
<pre class="calibre21">    @FXML 
    public void dupeGroupClicked(MouseEvent event) { 
      int index = dupeFileGroupListView.getSelectionModel() 
       .getSelectedIndex(); 
      if (index &gt; -1) { 
        String hash = dupeFileGroupListView.getSelectionModel() 
        .getSelectedItem(); 
        matchingFilesListView.getItems().clear(); 
        matchingFilesListView.getItems().addAll(dupes.get(hash)); 
      } 
    } </pre>
<p class="mce-root">When the control is clicked on, we get the index and make sure it is non-negative, so as to ensure that the user actually clicked on something. We then get the hash of the group by getting the selected item from <kbd class="calibre16">ListView</kbd>. Remember that while <kbd class="calibre16">ListView</kbd> may show something like <kbd class="calibre16">Group #2</kbd>, the actual content of that row is the hash. We just used a custom <kbd class="calibre16">CellFactory</kbd> to give it a prettier label. With the hash, we clear the list of items in <kbd class="calibre16">matchingFilesListView</kbd>, then get the control's <kbd class="calibre16">ObservableList</kbd> and add all of the <kbd class="calibre16">FileInfo</kbd> objects in the <kbd class="calibre16">List</kbd> keyed by the hash. And, again, we get an automatic user interface update, thanks to the power of <kbd class="calibre16">Observable</kbd>.</p>
<p class="mce-root">We also want the user to be able to navigate the list of duplicate groups using the keyboard to update the matching file list. We do that by setting the <kbd class="calibre16">onKeyPressed</kbd> attribute on our <kbd class="calibre16">ListView</kbd> to point to this rather simple method:</p>
<pre class="calibre21">    @FXML 
    public void keyPressed(KeyEvent event) { 
      dupeGroupClicked(null); 
    } </pre>
<p class="mce-root">It just so happens that we're not too terribly interested in the actual <kbd class="calibre16">Event</kbd> in either of these methods (they're never actually used), so we can naively delegate to the mouse-click method discussed earlier.</p>
<p class="mce-root">There are two more minor pieces of functionality we need to implement: viewing the matching files and deleting matching files.</p>
<p class="mce-root">We've already created the context menu and menu entries, so all we need to do is implement the handler methods as follows:</p>
<pre class="calibre21">    @FXML 
    public void openFiles(ActionEvent event) { 
      matchingFilesListView.getSelectionModel().getSelectedItems() 
      .forEach(f -&gt; { 
        try { 
          Desktop.getDesktop().open(new File(f.getPath())); 
        } catch (IOException ex) { 
          // ... 
        } 
      }); 
    } </pre>
<p class="mce-root">The matching file list allows multiple selections, so we need to get <kbd class="calibre16">List&lt;FileInfo&gt;</kbd> from the selection model instead of the single object we've already seen. We then call <kbd class="calibre16">forEach()</kbd> to process the entry. We want to open the file in whatever application the user has configured in the operating system to handle that file type. To do this, we use an AWT class introduced in Java 6: <kbd class="calibre16">Desktop</kbd>. We get the instance via <kbd class="calibre16">getDesktop()</kbd>, then call <kbd class="calibre16">open()</kbd>, passing it <kbd class="calibre16">File</kbd> that points to our <kbd class="calibre16">FileInfo</kbd> target.</p>
<p class="mce-root">Deleting a file is similar:</p>
<pre class="calibre21">    @FXML 
    public void deleteSelectedFiles(ActionEvent event) { 
      final ObservableList&lt;FileInfo&gt; selectedFiles =  
        matchingFilesListView.getSelectionModel() 
        .getSelectedItems(); 
      if (selectedFiles.size() &gt; 0) { 
        showConfirmationDialog( 
          "Are you sure you want to delete the selected files", 
           () -&gt; selectedFiles.forEach(f -&gt; { 
            if (Desktop.getDesktop() 
            .moveToTrash(new File(f.getPath()))) {                         
              matchingFilesListView.getItems() 
              .remove(f); 
              dupes.get(dupeFileGroupListView 
               .getSelectionModel() 
               .getSelectedItem()).remove(f); 
            } 
        })); 
      } 
    } </pre>
<p class="mce-root">Similarly to open files, we get all of the selected files. If there's at least one, we confirm the user's intent via <kbd class="calibre16">showConfirmationDialog()</kbd>, and pass in a lambda that handles the deleting. We do the actual file deletion using the <kbd class="calibre16">Desktop</kbd> class again to move the file to the trash can provided by the filesystem to provide the user with a safe delete option. If the file is successfully deleted, we remove its entry from <kbd class="calibre16">ObservableList</kbd>, as well as our cache duplicate file <kbd class="calibre16">Map</kbd>, so that it isn't shown should the user click on this file group again.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">With that, our application is done. So, what have we covered? From the project description, this seemed like a pretty simple application, but as we started breaking down the requirements and delving into the implementation, we ended up covering a lot of territory--a scenario that is not at all uncommon. We built another multi-module Maven project. We introduced Java concurrency, including basic <kbd class="calibre16">Thread</kbd> management and <kbd class="calibre16">ExecutorService</kbd> usage, as well as the Java Persistence API, showing basic <kbd class="calibre16">@Entity</kbd> definition, <kbd class="calibre16">EntityManagerFactory/EntityManager</kbd> usage, and JPAQL query authoring. We discussed creating file hashes using the <kbd class="calibre16">MessageDigest</kbd> classes, and demonstrated the new file I/O APIs, including the directory tree walking APIs. We also built a more complex user interface in JavaFX using nested containers, "linked" <kbd class="calibre16">ListView</kbd> instances, and bound properties.</p>
<p class="mce-root">That's quite a bit for such a "simple" project. Our next project will also be relatively simple, as we build a command-line date calculator that will allow us to explore the <kbd class="calibre16">java.time</kbd> package and see some of what this new date/time API offers.</p>


            </article>

            
        </section>
    </div>



  </body></html>