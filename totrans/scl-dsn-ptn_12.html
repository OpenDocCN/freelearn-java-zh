<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Real-Life Applications</h1>
                </header>
            
            <article>
                
<p class="mce-root">We have come a long way in the world of design patterns in Scala. We saw some classical <em>Gang of Four</em> design patterns from the point of view of Scala, as well as features that are applicable specifically to this programming language. By now, you should have enough knowledge in order to build high-quality, extendible, efficient, and elegant applications. Everything we have covered until now, if taken into consideration, should have a really positive impact on any application you will create.</p>
<p>Many of the things you saw in this book we wrote from scratch. This is really helpful in terms of understanding a given concept, but it takes time, and in real-world applications, using a library that gives us some functionalities is usually preferred. There are a number of different libraries available that are accessible through a simple Google search and address just about anything you can think of. Apart from the fact that this could save a lot of time, it also means that we integrate into our code thoroughly tested components that are trusted by many others. This, of course, depends on the library we are trying to incorporate, but as long as it brings something useful to the community, it will most likely be reliable. Having said all that, our main focus of this chapter will include the following:</p>
<ul>
<li>The Scalaz library</li>
<li>Writing a complete application</li>
<li>Summarizing what we have learned so far</li>
</ul>
<p>There are a lot of libraries for Scala out there and some might consider other libraries to be much more important to the language than Scalaz is. There are alternatives as well, which have spun up due to various reasons. We will, however, focus on Scalaz here, as it is generally used when someone wants to implement concepts such as monoids, functors, and monads in their application. And these concepts are really important in functional programming, as we saw earlier. We will also write a complete application that uses some of the techniques and design patterns we became familiar with in the previous chapters. This chapter will give some insights into how applications should be structured and how to understand our requirements and then build the solutions for them properly. Finally, we will summarize everything we have learned here.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reasons to use libraries</h1>
                </header>
            
            <article>
                
<p>Writing software applications will inevitably bring developers to the point where they will have to implement something that already exists. Reinventing the wheel is generally a bad idea unless we have some extremely specific and strict requirements that no library in the world satisfies, or if there is good reason not to include a specific dependency in our project.</p>
<p>People write libraries to deal with all kinds of problems in software. In a community such as the open source community, libraries are shared and everyone can use or contribute to them. This brings a lot of benefits, and the main benefit is that code becomes more mature, better tested, and more reliable. However, sometimes this also makes things harder—many people will create the same library and it becomes difficult to understand which one is the most suitable.</p>
<p>Despite the fact that there could be multiple implementations of the same library, using one is the way to go when we write enterprise applications. Filtering out the bad ones from the good ones is easy nowadays—if a library is good, many people will use it. If it's bad, people will avoid it. If there are multiple good ones, developers will have to spend some time investigating which one is the most suitable for their use case.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The Scalaz library</h1>
                </header>
            
            <article>
                
<p>Scala is a functional programming language and, as such, it supports design patterns based on concepts such as monoids, monads, and others. We already saw these in <a href="1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml" target="_blank">Chapter 10</a>, <em>Functional Design Patterns - the Deep Theory</em>, and we know the rules they follow and the structure they have. We wrote everything ourselves, but a library already exists that does this for us—Scalaz (<a href="https://github.com/scalaz/scalaz">https://github.com/scalaz/scalaz</a>). This library is used when we need purely functional data structures.</p>
<div class="packt_tip">Another library that has a similar popularity to Scalaz in the community is Cats (<a href="https://github.com/typelevel/cats">https://github.com/typelevel/cats</a>). They should both be able to help developers achieve the same functional programming concepts. In most cases, the choice between the two is based on personal preference, local community culture or company policies.</div>
<p>We have already encountered Scalaz in the previous chapter when we talked about lenses. In the following subsections, we will look at the library from the point of view of monoids, functors, and monads.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monoids in Scalaz</h1>
                </header>
            
            <article>
                
<p>One of the concepts we looked at in <a href="1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml" target="_blank">Chapter 10</a>, <em>Functional Design Patterns - the Deep Theory</em>, was monoids. We defined a trait and some rules for them and then showed examples of how to use them and what they are good for. In these examples, we defined monoids for integer addition and multiplication as well as string concatenation. Scalaz already has a <kbd>Monoid</kbd> trait that we can use to write our own monoids. Also, this trait has a few monoids that we have defined before already implemented:</p>
<pre><span>import </span>scalaz.Monoid<br/><br/><span>package object </span>monoids {<br/>  <br/>  <span>// Int addition and int multiplication exist already,<br/></span><span>  // so we will show them in an example.<br/></span><span>  </span><span>val </span><span>stringConcatenation </span>= <span>new </span>Monoid[<span>String</span>] {<br/>    <span>override def </span><span>zero</span>: <span>String </span>= <span>""<br/></span><span><br/></span><span>    </span><span>override def </span><span>append</span>(f1: <span>String</span><span>, </span>f2: =&gt; <span>String</span>): <span>String </span>= f1 + f2<br/>  }<br/>}</pre>
<p>In the preceding code, we just showed how you can implement a custom monoid.</p>
<div class="packt_tip">The <kbd>stringConcatenation</kbd> monoid is defined in a package object. This means that it will be available to any code in the same package without the need to import anything. We take advantage of this in some of the following examples.</div>
<p>There also exists a string concatenation monoid, but here we just showed how you can opt for implementing the custom monoid if it doesn't exist. It is quite similar to what we had earlier. The difference is only in the name for the operation method (<kbd>append</kbd>) and its signature. However, this is just a minor difference.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using monoids</h1>
                </header>
            
            <article>
                
<p>Using Scalaz monoids is pretty straightforward. Here is an example program:</p>
<pre><span>import </span>scalaz._<br/><span>import </span>Scalaz._<br/><br/><span>object </span>MonoidsExample {<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>val </span>numbers = <span>List</span>(<span>1</span><span>, </span><span>2</span><span>, </span><span>3</span><span>, </span><span>4</span><span>, </span><span>5</span><span>, </span><span>6</span>)<br/>    System.<span>out</span>.println(<span>s"The sum is: </span><span>$</span>{numbers.foldMap(<span>identity</span>)}<span>"</span>)<br/>    System.<span>out</span>.println(<span>s"The product (6!) is:<br/>     </span><span>$</span>{numbers.foldMap(Tags.<span>Multiplication</span>.apply)}<span>"</span>)<br/>    <span>val </span>strings = <span>List</span>(<span>"This is</span><span>\n</span><span>"</span><span>, </span><span>"a list of</span><span>\n</span><span>"</span><span>, </span><span>"strings!"</span>)<br/>    System.<span>out</span>.println(strings.foldMap(<span>identity</span>)(<span>stringConcatenation</span>))<br/>  }<br/>}</pre>
<p>The imports in our code make sure that we can call <kbd>foldMap</kbd> on our list of numbers. If we run this example, we will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/6df0dd37-2053-4937-aaca-79153cf7100f.png" style="width:42.92em;height:8.75em;" width="713" height="145"/></div>
<p>Looking at the output and the code, you can see that for integer addition and multiplication, we have used the built-in monoids of Scalaz. The <kbd>sum</kbd> monoid takes precedence and is actually passed to <kbd>foldMap</kbd> implicitly. For the multiplication to work, we have to pass <kbd>Tags.Multiplication.apply</kbd> in order to make things work as expected. We have explicitly passed our string concatenation monoid to make the last statement work correctly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing monoids</h1>
                </header>
            
            <article>
                
<p>We know that monoids have to satisfy some specific laws. Our examples are simple enough to see that the laws are actually in place, but sometimes it might not be that obvious. In Scalaz, you can actually test your monoids:</p>
<pre><span>import </span>org.scalacheck.Arbitrary<br/><span>import </span>org.scalatest.prop.Checkers<br/><span>import </span>org.scalatest.{FlatSpec<span>, </span>Matchers}<br/><br/><span>import </span>scalaz._<br/><br/><span>import </span>scalaz.scalacheck.ScalazProperties._<br/><br/><span>class </span>MonoidsTest <span>extends </span>FlatSpec <span>with </span>Matchers <span>with </span>Checkers {<br/><br/>  <span>implicit def </span><span>arbString</span>(<span>implicit </span>ev: Arbitrary[<span>String</span>]):<br/>   Arbitrary[<span>String</span>] =<br/>    Arbitrary { ev.arbitrary.map(<span>identity</span>) }<br/>  <br/>  <span>"stringConcatenation monoid" </span>should <span>"satisfy the identity rule." </span>in {<br/>    monoid.<span>laws</span>[<span>String</span>](<span>stringConcatenation</span><span>, </span>Equal.<span>equalA</span>[<span>String</span>]<span>,<br/>    </span>arbString).check()<br/>  }<br/>}</pre>
<p>In order to be able to compile and run the preceding example, we will need to have the following dependencies added to our <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.scalcheck&lt;/groupId&gt;<br/>    &lt;artifactId&gt;scalacheck_2.12&lt;/artifactId&gt;<br/>    &lt;version&gt;${scalacheck.version}&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.scalaz&lt;/groupId&gt;<br/>    &lt;artifactId&gt;scalaz-scalacheck-binding_2.12&lt;/artifactId&gt;<br/>    &lt;version&gt;${scalaz.version}&lt;/version&gt;<br/>    &lt;scope&gt;test&lt;/scope&gt;<br/>&lt;/dependency&gt;</pre>
<p>The equivalent <kbd>build.sbt</kbd> file will need to have the following dependencies added:</p>
<pre><span>"org.scalacheck" </span>%% <span>"scalacheck" </span>% scalacheckVersion % <span>"test"</span><span>,<br/></span><span>"org.scalaz" </span>%% <span>"scalaz-scalacheck-binding" </span>% scalazVersion % <span>"test"</span><span>,</span></pre>
<p>The preceding code sections are just fragments of the code examples coming with this book. These dependencies add bindings to ScalaCheck (<a href="https://www.scalacheck.org/">https://www.scalacheck.org/</a>)—a property-based testing framework. The preceding code will test our custom monoid for all the laws and fail if it doesn't satisfy them. Writing tests for our custom classes will require us to have an <kbd>Arbitrary</kbd> implementation as well as have our monoid implicitly available in the test scope.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Monads in Scalaz</h1>
                </header>
            
            <article>
                
<p>In <a href="1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml" target="_blank">Chapter 10</a>, <em>Functional Design Patterns - the Deep Theory</em>, we also looked at monads. If you remember, we had to define a functor trait first and then extend it in the monad trait. Similar to monoids, monads also follow some specific rules that have to be in place.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Using monads</h1>
                </header>
            
            <article>
                
<p>Scalaz defines quite a lot of different methods that can be applied directly to any monad we have. There are multiple examples that show lists and options. The library also has a <kbd>Monad</kbd> trait that can be extended. It is similar to the <kbd>Monoid</kbd> trait.</p>
<p>We don't want to dig into list examples that show how to use monads, though. To make things interesting, let's look at the <kbd>IO</kbd> monad in Scalaz that can be used to perform I/O in a monadic way. What this basically means is that we can describe and compose those actions without actually performing them. This will lead to better code reuse as well. Let's see an example:</p>
<pre><span>import </span>java.io.{PrintWriter<span>, </span>File}<br/><br/><span>import </span>scala.io.Source<br/><br/><span>package object </span>monads {<br/>  <span>def </span><span>readFile</span>(path: <span>String</span>) = {<br/>    System.<span>out</span>.println(<span>s"Reading file </span><span>$</span>{path}<span>"</span>)<br/>    Source.<span>fromFile</span>(path).getLines()<br/>  }<br/><br/>  <span>def </span><span>writeFile</span>(path: <span>String</span><span>, </span>lines: <span>Iterator</span>[<span>String</span>]) = {<br/>      System.<span>out</span>.println(<span>s"Writing file </span><span>$</span>{path}<span>"</span>)<br/>      <span>val </span>file = <span>new </span>File(path)<br/>      <span>printToFile</span>(file) { p =&gt; lines.foreach(p.println) }<br/>    }<br/><br/>  <span>private def </span><span>printToFile</span>(file: File)(writeOp: PrintWriter =&gt; <span>Unit</span>): <span>Unit </span>= {<br/>    <span>val </span>writer = <span>new </span>PrintWriter(file)<br/>    <span>try </span>{<br/>      writeOp(writer)<br/>    } <span>finally </span>{<br/>      writer.close()<br/>    }<br/>  }<br/>}</pre>
<p>First of all, we defined some methods in a package object that can manipulate files. There is absolutely nothing special about them. They seem pretty similar to what we did in <a href="1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml" target="_blank">Chapter 10</a>, <em>Functional Design Patterns - the Deep Theory</em>, when we showed our custom <kbd>IO</kbd> monad. In the <kbd>readFile</kbd> and the <kbd>writeFile</kbd>, we added prints to help in debugging and show exactly what is going on. This will be really useful later.</p>
<p>We will make our application read a tab-separated file of data of people, parse it, and write it either to a file or the console. The example file will have the following content:</p>
<pre>Ivan   26<br/>Maria   26<br/>John   25</pre>
<p>Of course, we have a model that will reflect this file and it will be as simple as this:</p>
<pre><span>case class </span>Person(name: <span>String</span><span>, </span>age: <span>Int</span>)<br/><br/><span>object </span>Person {<br/>  <span>def </span><span>fromArray</span>(arr: Array[<span>String</span>]): Option[Person] =<br/>    arr <span>match </span>{<br/>      <span>case </span><span>Array</span>(name<span>, </span>age) =&gt; <span>Some</span>(<span>Person</span>(name<span>, </span>age.toInt))<br/>      <span>case </span>_ =&gt; None<br/>    }<br/>}</pre>
<p>Together with the model, we've shown its companion object. It has one method that returns an optional <kbd>Person</kbd> object given an array of strings.</p>
<p>Now it's time to see our application and explain what is going on:</p>
<pre><span>import </span>com.ivan.nikolov.monads.model.Person<br/><br/><span>import </span>scalaz._<br/><span>import </span>effect._<br/><span>import </span>Scalaz._<br/><span>import </span>IO._<br/><br/><span>object </span>IOMonadExample {<br/><br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    args <span>match </span>{<br/>      <span>case </span><span>Array</span>(inputFile<span>, </span>isWriteToFile) =&gt;<br/>        <span>val </span>people = {<br/>          <span>for </span>{<br/>            line &lt;- <span>readFile</span>(inputFile)<br/>            person &lt;- Person.<span>fromArray</span>(line.split(<span>"</span><span>\t</span><span>"</span>))<br/>          } <span>yield </span>person<br/>        }.pure[IO]<br/><br/>        System.<span>out</span>.println(<span>"Still haven't done any IO!"</span>)<br/>        System.<span>out</span>.println(<span>"About to do some..."</span>)<br/>        <span>if </span>(isWriteToFile.toBoolean) {<br/>          <span>val </span>writePeople = <span>for </span>{<br/>            _ &lt;- <span>putStrLn</span>(<span>"Read people successfully.<br/>             Where to write them down?"</span>)<br/>            outputFile &lt;- <span>readLn<br/></span><span>            </span>p &lt;- people<br/>            _ &lt;- <span>writeFile</span>(outputFile<span>, </span>p.map(_.toString)).pure[IO]<br/>          } <span>yield </span>()<br/>          System.<span>out</span>.println(<span>"Writing to file using toString."</span>)<br/>          writePeople.unsafePerformIO <br/>        } <span>else </span>{<br/>          System.<span>out</span>.println(<span>s"Just got the following people:<br/>           </span><span>$</span>{people.unsafePerformIO.toList}<span>"</span>)<br/>        }<br/>      <span>case </span>_ =&gt;<br/>        System.<span>err</span>.println(<span>"Please provide input file and true/false<br/>         whether to write to file."</span>)<br/>        System.<span>exit</span>(-<span>1</span>)<br/>    }<br/>  }<br/>}</pre>
<p>Let's now see what exactly is going on in the previous listing. The actual code is in the first pattern matching case. The rest is some validation to run a console application and the parameters passed to it.</p>
<p>The first thing to pay attention to is the calls to <kbd>.pure[IO]</kbd>, which is there for the <kbd>people</kbd> variable and when we write to the file. This method takes the value given to it and lifts it into a monad. Another important thing is that the value passed to the method is lazily evaluated. In our example, the monad is the <kbd>IO</kbd> monad.</p>
<p>Secondly, we can see some references to the <kbd>putStrLn</kbd> and <kbd>readLn</kbd> methods. Their names should be enough to explain what they do. They come from the <kbd>scalaz.effect.IO</kbd> object, that we have imported into our application. And this import requires another dependency in our <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.scalaz&lt;/groupId&gt;<br/>    &lt;artifactId&gt;scalaz-effect_2.12&lt;/artifactId&gt;<br/>    &lt;version&gt;${scalaz.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>The equivalent dependency in the <kbd>build.sbt</kbd> file will be the following:</p>
<pre><span>"org.scalaz" </span>%% <span>"scalaz-effect" </span>% scalazVersion</pre>
<p>The <kbd>putStrLn</kbd> and <kbd>readLn</kbd> methods also return an instance of the <kbd>IO</kbd> monad and they are just helpers.</p>
<p>Now, because our application is monadic and we use the <kbd>IO</kbd> monad, nothing will happen unless we do something about it. To trigger the actual actions, we must call <kbd>unsafePerformIO</kbd> on an <kbd>IO</kbd> instance. We've added some <kbd>print</kbd> statements that will prove that the code works as we expected it to.</p>
<p>Since we have two branches for our application, we will make two runs here. One that prints and another one that writes to a file. The example outputs are in the following screenshots:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/01468d76-d143-47db-a3c8-efa72c9a068d.png" style="width:39.58em;height:8.08em;" width="712" height="145"/></div>
<p>The preceding screenshot shows the run that prints to the console. We can see that the reading from the file log comes after the initial logs from our application, even though we called the method earlier. This proves that indeed the <kbd>.pure[IO]</kbd> call lifts our function without evaluating it.</p>
<p>Similarly to the previous output, the following output shows that nothing happens until the very last moment when we write the output filename and hit <em>Enter</em>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/24765bef-4f21-4e81-9cc8-1c0e845c7ddc.png" style="width:42.58em;height:10.92em;" width="713" height="183"/></div>
<p>Our example shows that the <kbd>IO</kbd> monad helps us to build a computation and execute it at the very last moment. Here, we've decided to surround it with a for comprehension and call <kbd>pure[IO]</kbd> on it so that we can actually use the read and write methods without monads if we want to. In other cases, you can make sure to return an <kbd>IO</kbd> monad from the read and write methods and then define mapping methods, which also return the <kbd>IO</kbd> monads and use them inside the for comprehensions. This would look like something similar to this:</p>
<pre><span>val </span>people = <span>for </span>{<br/>  lines &lt;- readFile(inputFile).pure[IO]<br/>  p &lt;- lines.map(i =&gt; <span>Person</span>(<span>"a"</span><span>, </span><span>1</span>)).pure[IO]<br/>} <span>yield </span>p</pre>
<p>This version actually looks more monadical. We have enclosed smaller entities in the <kbd>IO</kbd> monad that we have combined and probably there will be more examples available online that follow this approach. This version actually also leaves the <kbd>read</kbd> method intact. The only thing in this case is that the for comprehension behaves differently than usual.</p>
<p>Which approach is used will probably depend on personal preferences and what someone wants to achieve.</p>
<p>The preceding example is similar to what we did in <a href="1d40b2c6-51b8-4239-8466-df690a18d28d.xhtml" target="_blank">Chapter 10</a>, <em>Functional Design Patterns - the Deep Theory</em>, with our custom I/O monad. Here, however, we can see that there is much less extra code than before.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing monads</h1>
                </header>
            
            <article>
                
<p>Scalaz provides facilities to test monads as well. The tests look no different than what we saw for monoids, but here we simply have to use <kbd>monad.laws</kbd> instead.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The possibilities of Scalaz</h1>
                </header>
            
            <article>
                
<p>We only looked at a handful of concepts covered by the Scalaz library. It contains much more than just that. You can think of Scalaz as an addition to Scala that makes it even more functional. It provides various type classes, data types, pimp my library instances for standard collections, out-of-the-box functionality for various standard types, and so on. The purposes also vary—from writing purely functional applications to making your code more readable. Scalaz is so vast that we can write a separate book about it.</p>
<p>It seems that people find it difficult to use Scalaz at first and only later do they get to know the possibilities it provides. We would like to encourage you to become familiar with the documentation and everything the library provides. There are also various blog posts for all levels of difficulty, which can be a real eye-opener for the first time user of Scalaz.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing a complete application</h1>
                </header>
            
            <article>
                
<p>So far in the book, we've seen a lot of examples. Some of them were quite complete, while others were meant to demonstrate only a specific part of what we were looking at. In real applications, it is most likely that you will have to combine multiple design patterns that we went through. In order to do so properly, it is important that the requirements are well understood. In the following subsections, we will provide the application specifications and then we will go step by step through actually writing the application. The amount of code we write will be a lot, so we will focus on the more important parts of our application and we might skip others.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application specifications</h1>
                </header>
            
            <article>
                
<p>Before doing anything, we must always have some specifications. Sometimes, these specifications are not entirely clear and it is our responsibility to make sure everything is detailed enough for us to understand and achieve them. However, in an actual software engineering process, it will likely be the case that we start doing something when the requirements are not 100% clear and things change halfway through the project. It could be frustrating at times, but that is life and we have to deal with it. It also makes things interesting and dynamic and makes developers think of even more possibilities and problems that could arise when users use a given application. Some developers might refuse to even start working on an application that is not completely defined. They might have a valid point and this depends on how critical the tasks are, but generally, this kind of attitude doesn't take projects far.</p>
<p>Luckily, here we can come up with our own tasks, so everything will be well defined and we will not change requirements halfway through. So let's do this and get our hands dirty.</p>
<div class="packt_infobox">Create a scheduler application that can run console commands or SQL queries against a database. The user should be able to schedule any command or query using configuration files, and they should be able to choose a granularity—hourly or daily, at a specific time.</div>
<p>So far, we have only given a top-level explanation of what we want to achieve. As we said earlier, some people might even refuse to go further until they have a complete definition with every single detail mentioned. This is a valid point; however, it is interesting to get your head around different use cases, edge cases, and possible improvements. It is the job of product managers to actually come up with all these specifications; but here, we are not learning how to be one. We are learning how to write nice code. So let's take what we have and try to come up with something usable, efficient, testable, and extendable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Implementation</h1>
                </header>
            
            <article>
                
<p>Let's start writing some code. No! This is wrong. Before we even start to write, we should answer all our questions and be clear with where we are going. Some people like drawing diagrams, others like writing things down, and so on. Everyone has their own techniques. Let's try and come up with a diagram first. It will show the top-level components that we will use, how they communicate with each other, and so on. A visual representation of our application will be extremely valuable to see any issues early and will also help us to implement the application easily:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="Images/77f52399-4b26-4b67-a36b-2c8025c9f360.png" style="width:55.00em;height:42.33em;" width="1411" height="1087"/></div>
<p>The preceding diagram shows our future application from a really high level. It is, however, enough to identify a few core components:</p>
<ul>
<li>The main application</li>
<li>The scheduler</li>
<li>The router</li>
<li>The workers</li>
</ul>
<p>By looking at the connections between the components, we can also see what dependencies they will have and what functionalities they will support.</p>
<p>Now that we have this diagram and a view of what we should eventually end up with, we can start thinking of how to structure the application.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The libraries to use</h1>
                </header>
            
            <article>
                
<p>You can always take the approach of implementing everything from scratch on your own. This, however, would slow you down and would require some deep domain knowledge in a lot of other parallel disciplines. We have always encouraged the use of libraries in the examples in this book, and this is the case here too.</p>
<p>Looking at the preceding diagram, we can see that we will need to do the following operations:</p>
<ul>
<li>Read an application configuration</li>
<li>Read scheduler configuration files</li>
<li>Schedule tasks</li>
<li>Exchange messages</li>
<li>Access a database</li>
<li>Execute console commands</li>
</ul>
<p>Sometimes, while coming up with which libraries to use, it requires testing of the different alternatives and seeing which one is useful for our purposes. We won't be doing this here, and we will just use the libraries we have already seen or know about.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading the application configuration</h1>
                </header>
            
            <article>
                
<p>To read the application configuration files, we have decided to use Typesafe config: <a href="https://github.com/typesafehub/config">https://github.com/typesafehub/config</a>. It is a mature and well-maintained library, supports various configuration formats, and is quite easy to use. We have included it in our <kbd>pom.xml</kbd> file using the following statement:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.typesafe&lt;/groupId&gt;<br/>    &lt;artifactId&gt;config&lt;/artifactId&gt;<br/>    &lt;version&gt;${typesafe.config.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>The same dependency is added to <kbd>build.sbt</kbd> using the following line:</p>
<pre><span>"com.typesafe" </span>% <span>"config" </span>% typesafeConfigVersion</pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Reading the scheduler configuration</h1>
                </header>
            
            <article>
                
<p>Our application will be reading configuration files for schedulers. There are different formats we can force our users to use. We've decided our format of choice to be JSON. It is easy to write our models based on it and we have already used libraries to parse the JSON format in the previous chapters of this book. We will be using json4s: <a href="https://github.com/json4s/json4s">https://github.com/json4s/json4s</a>. We have included it using the following lines in our <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.json4s&lt;/groupId&gt;<br/>    &lt;artifactId&gt;json4s-native_2.12&lt;/artifactId&gt;<br/>    &lt;version&gt;${json4s.version}&lt;/version&gt;<br/>&lt;/dependency&gt;<br/>&lt;dependency&gt;<br/>    &lt;groupId&gt;org.json4s&lt;/groupId&gt;<br/>    &lt;artifactId&gt;json4s-jackson_2.12&lt;/artifactId&gt;<br/>    &lt;version&gt;${json4s.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>The same dependencies if you decide to use <kbd>build.sbt</kbd> will be added as follows:</p>
<pre><span>"org.json4s" </span>%% <span>"json4s-native" </span>% json4sVersion<span>,<br/></span><span>"org.json4s" </span>%% <span>"json4s-jackson" </span>% json4sVersion<span>,</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Scheduling tasks</h1>
                </header>
            
            <article>
                
<p>There are various scheduling libraries and programs. Some are more mature, others less. In this application, we decided to use Akka: <a href="https://akka.io/">https://akka.io/</a>. First of all, it is a good library to be familiar with. Secondly, we have already talked about it in the earlier chapters of this book. Using Akka can be useful to you to see how to write applications using reactive programming. Akka can be included in our project by adding the following lines to our <kbd>pom.xml</kbd> file:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.typesafe.akka&lt;/groupId&gt;<br/>    &lt;artifactId&gt;akka-actor_2.12&lt;/artifactId&gt;<br/>    &lt;version&gt;${akka.version}&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>The same dependency, but in your <kbd>build.sbt</kbd> file, will look like this:</p>
<pre><span>"com.typesafe.akka" </span>%% <span>"akka-actor" </span>% akkaVersion</pre>
<p>Akka uses messages to send tasks to workers, and we will see how this entire procedure is handled elegantly.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Accessing a database</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we already saw how to write the code to access databases. Here, we will be using the H2 database engine again, as it doesn't require you to do anything extra in order to execute the example. The related <kbd>pom.xml</kbd> entry is as follows:</p>
<pre>&lt;dependency&gt;<br/>    &lt;groupId&gt;com.h2database&lt;/groupId&gt;<br/>    &lt;artifactId&gt;h2&lt;/artifactId&gt;<br/>    &lt;version&gt;1.4.197&lt;/version&gt;<br/>&lt;/dependency&gt;</pre>
<p>For <kbd>sbt</kbd>, the <kbd>build.sbt</kbd> file will need to have the following:</p>
<pre><span>"com.h2database" </span>% <span>"h2" </span>% <span>"1.4.197"</span></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Executing console commands</h1>
                </header>
            
            <article>
                
<p>To execute console commands, we will be using the built-in functionalities of Scala. We will also use some extra dependencies that we have used in the other projects as well—a logging library (slf4j) and test dependencies—ScalaTest and Mockito.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing some code</h1>
                </header>
            
            <article>
                
<p>Now that we know what we will be doing and what libraries we will be relying on, it's time to write some code. It is logical to start with things that don't have other internal dependencies.</p>
<p>One of these things is the application configuration. It is something that doesn't depend on anything, but many things depend on it. We decided to use the <kbd>.conf</kbd> files because they are simple, hierarchical, and similar to JSON. An example configuration file looks like the following code:</p>
<pre> job-scheduler {<br/>  config-path="/etc/scheduler/conf.d"<br/>  config-extension="json"<br/>  workers=4<br/>  db {<br/>    connection-string="jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"<br/>    username=""<br/>    password=""<br/>  }<br/>}</pre>
<p>The options are clear and anyone can easily provide a new config that suits their needs.</p>
<div class="packt_tip"><span class="packt_screen">Coming up with our configuration options</span><br/>
<br/>
Of course, we didn't come up with this file straight away. It evolved as we kept adding functionalities to our application. Start small and don't try to think about everything at once.</div>
<p>With this expected format, we can now write a component:</p>
<pre><span>package com.ivan.nikolov.scheduler.config.app<br/><br/>import </span>com.typesafe.config.ConfigFactory<br/><br/><span>trait </span>AppConfigComponent {<br/>  <span>val </span>appConfigService: AppConfigService<br/><br/>  <span>class </span>AppConfigService() {<br/>    <span>//-Dconfig.resource=production.conf for overriding<br/></span><strong>    private val conf = ConfigFactory.load()</strong><br/>    <span>private val </span><span>appConf </span>= <span>conf</span>.getConfig(<span>"job-scheduler"</span>)<br/>    <span>private val </span><span>db </span>= <span>appConf</span>.getConfig(<span>"db"</span>)<br/>    <span>val </span><span>configPath </span>= <span>appConf</span>.getString(<span>"config-path"</span>)<br/>    <span>val </span><span>configExtension </span>= <span>appConf</span>.getString(<span>"config-extension"</span>)<br/>    <span>val </span><span>workers </span>= <span>appConf</span>.getInt(<span>"workers"</span>)<br/>    <span>val </span><span>dbConnectionString </span>= <span>db</span>.getString(<span>"connection-string"</span>)<br/>    <span>val </span><span>dbUsername </span>= <span>db</span>.getString(<span>"username"</span>)<br/>    <span>val </span><span>dbPassword </span>= <span>db</span>.getString(<span>"password"</span>)<br/>  }<br/>}</pre>
<p>The highlighted line in the preceding code shows how easy it is to read our configuration file. It gets the <kbd>application.conf</kbd> from our <kbd>resources</kbd> folder. The user can easily override it by passing a <kbd>-Dconfig.resource=path.conf</kbd> when starting our application.</p>
<p>Our configuration file specifies a number of properties. Two of them are <kbd>config-path</kbd> and <kbd>config-extension</kbd>. We have basically taken the decision to provide a folder and an extension, and our program will read all the files with the given extension and use them as job configuration files. We have written a component that supports reading from a folder and returns all the files with the given extension:</p>
<pre><span>package com.ivan.nikolov.scheduler.io<br/><br/>import </span>java.io.File<br/><br/><span>trait </span>IOServiceComponent {<br/>  <span>val </span>ioService: IOService<br/><br/>  <span>class </span>IOService {<br/>    <span>def </span><span>getAllFilesWithExtension</span>(basePath: <span>String</span><span>, </span>extension: <span>String</span>):<br/>    <span>List</span>[<span>String</span>] = {<br/>      <span>val </span>dir = <span>new </span>File(basePath)<br/>      <span>if </span>(dir.exists() &amp;&amp; dir.isDirectory) {<br/>        dir.listFiles()<br/>          .filter(f =&gt; f.isFile &amp;&amp;<br/>           f.getPath.toLowerCase.endsWith(<span>s".</span><span>$</span>{extension}<span>"</span>))<br/>          .map {<br/>            <span>case </span>f =&gt; f.getAbsolutePath<br/>          }.toList<br/>      } <span>else </span>{<br/>        <span>List</span>.<span>empty<br/></span><span>      </span>}<br/>    }<br/>  }<br/><br/>}</pre>
<p>This component doesn't do anything special. We haven't used monads or anything fancy for the I/O here because we actually want to eagerly evaluate things in this case.</p>
<p>Now that we know how to find all the job configuration files, we need to read them and parse them. We said that they will be JSON files and this means that we will have to define a model. Let's first see an example of a job configuration and then define the model:</p>
<pre>{<br/>  "name": "Ping Command",<br/>  "command": "ping google.com -c 10",<br/>  "frequency": "Hourly",<br/>  "type": "Console",<br/>  "time_options": {<br/>    "hours": 21,<br/>    "minutes": 10<br/>  }<br/>}</pre>
<p>It is quite easy to start with a file that has everything we need and then define the models, rather than the other way around. According to the preceding code, we can define the following model for our job configuration:</p>
<pre><span>case class </span>JobConfig(name: <span>String</span><span>, </span>command: <span>String</span><span>, </span>jobType: JobType<span>, </span>frequency: JobFrequency<span>, </span>timeOptions: TimeOptions)</pre>
<p>The <kbd>JobType</kbd> and <kbd>JobFrequency</kbd> will be defined as ADTs. When we use json4s, some special care needs to be taken while serializing and deserializing these types, so we have defined some extra <kbd>CustomSerializer</kbd> implementations along with them:</p>
<pre><span>import </span>org.json4s.CustomSerializer<br/><span>import </span>org.json4s.JsonAST.{JNull<span>, </span>JString}<br/><br/><span>sealed trait </span>JobType<br/><span>case object </span>Console <span>extends </span>JobType<br/><span>case object </span>Sql <span>extends </span>JobType<br/><br/><span>object </span>JobTypeSerializer <span>extends </span>CustomSerializer[JobType](format =&gt; (<br/>  {<br/>    <span>case </span><span>JString</span>(jobType) =&gt; jobType <span>match </span>{<br/>      <span>case </span><span>"Console" </span>=&gt; Console<br/>      <span>case </span><span>"Sql" </span>=&gt; Sql<br/>    }<br/>    <span>case </span>JNull =&gt; <span>null<br/></span><span>  </span>}<span>,<br/></span><span>  </span>{<br/>    <span>case </span>jobType: JobType =&gt; <br/><span>     JString</span>(jobType.getClass.getSimpleName.replace(<span>"$"</span><span>, </span><span>""</span>))<br/>  }<br/>))</pre>
<p>The <kbd>JobFrequency</kbd> is quite similar to the preceding code:</p>
<pre><span>import </span>org.json4s.CustomSerializer<br/><span>import </span>org.json4s.JsonAST.{JNull<span>, </span>JString}<br/><br/><span>sealed trait </span>JobFrequency<br/><span>case object </span>Daily <span>extends </span>JobFrequency<br/><span>case object </span>Hourly <span>extends </span>JobFrequency<br/><br/><span>case object </span>JobFrequencySerializer <span>extends </span>CustomSerializer[JobFrequency](format =&gt; (<br/>  {<br/>    <span>case </span><span>JString</span>(frequency) =&gt; frequency <span>match </span>{<br/>      <span>case </span><span>"Daily" </span>=&gt; Daily<br/>      <span>case </span><span>"Hourly" </span>=&gt; Hourly<br/>    }<br/>    <span>case </span>JNull =&gt; <span>null<br/></span><span>  </span>}<span>,<br/></span><span>  </span>{<br/>    <span>case </span>frequency: JobFrequency =&gt;<br/>     <span>JString</span>(frequency.getClass.getSimpleName.replace(<span>"$"</span><span>, </span><span>""</span>))<br/>  }<br/>))</pre>
<p>Our <kbd>JobConfig</kbd> class needs one more model to be defined, and it is shown as follows:</p>
<pre><span>import </span>java.time.LocalDateTime<br/><span>import </span>java.time.temporal.ChronoUnit<br/><span>import </span>java.util.concurrent.TimeUnit<br/><br/><span>import </span>scala.concurrent.duration.{Duration<span>, </span>FiniteDuration}<span><br/><br/></span><span>case class </span>TimeOptions(hours: <span>Int, </span>minutes: <span>Int</span>) {<br/>  <span>if </span>(hours &lt; <span>0 </span>|| hours &gt; <span>23</span>) {<br/>    <span>throw new </span>IllegalArgumentException(<span>"Hours must be between 0 and 23:<br/>     " </span>+ hours)<br/>  } <span>else if </span>(minutes &lt; <span>0 </span>|| minutes &gt; <span>59</span>) {<br/>    <span>throw new </span>IllegalArgumentException(<span>"Minutes must be between 0 and<br/>     59: " </span>+ minutes)<br/>  }<br/><br/>  <span>def </span><span>getInitialDelay</span>(now: LocalDateTime<span>, </span>frequency: JobFrequency):<br/>  FiniteDuration = {<br/>    <span>val </span>firstRun = now.withHour(hours).withMinute(minutes)<br/>    <span>val </span>isBefore = firstRun.isBefore(now)<br/>    <span>val </span>actualFirstRun = frequency <span>match </span>{<br/>      <span>case </span>Hourly =&gt;<br/>        <span>var </span>tmp = firstRun<br/>        <span>Iterator</span>.<span>continually</span>({<br/>          tmp = tmp.plusHours(<span>1</span>)<span>; </span>tmp<br/>        })<br/>          .takeWhile(d =&gt; d.isBefore(now))<br/>          .toList.lastOption.getOrElse(<br/>          <span>if </span>(isBefore)<br/>            firstRun<br/>          <span>else<br/></span><span>            </span>firstRun.minusHours(<span>1</span>)<br/>        ).plusHours(<span>1</span>)<br/>      <span>case </span>Daily =&gt;<br/>        <span>var </span>tmp = firstRun<br/>        <span>Iterator</span>.<span>continually</span>({<br/>          tmp = tmp.plusDays(<span>1</span>)<span>; </span>tmp<br/>        })<br/>          .takeWhile(d =&gt; d.isBefore(now))<br/>          .toList.lastOption<br/>          .getOrElse(<br/>            <span>if </span>(isBefore)<br/>              firstRun<br/>            <span>else<br/></span><span>              </span>firstRun.minusDays(<span>1</span>)<br/>          ).plusDays(<span>1</span>)<br/>    }<br/>    <span>val </span>secondsUntilRun = now.until(actualFirstRun<span>, </span>ChronoUnit.<span>SECONDS</span>)<br/>    Duration.<span>create</span>(secondsUntilRun<span>, </span>TimeUnit.<span>SECONDS</span>)<br/>  }<br/>}</pre>
<p>The <kbd>TimeOptions</kbd> class has some validation during creation and a <kbd>getInitialDelay</kbd> method. The purpose of this method is to get the initial delay while scheduling a task, depending on its options.</p>
<p>After we have defined our models for the job configuration, we can write a service that reads and parses the configurations:</p>
<pre><span>import </span>java.io.File<br/><span>import </span>com.ivan.nikolov.scheduler.config.app.AppConfigComponent<br/><span>import </span>com.ivan.nikolov.scheduler.config.job.{JobTypeSerializer<span>, </span>JobFrequencySerializer<span>, </span>JobConfig}<br/><span>import </span>com.ivan.nikolov.scheduler.io.IOServiceComponent<br/><span>import </span>com.typesafe.scalalogging.LazyLogging<br/><span>import </span>org.json4s._<br/><span>import </span>org.json4s.jackson.JsonMethods._<br/><br/><span>trait </span>JobConfigReaderServiceComponent {<br/>  <span>this</span>: AppConfigComponent <span>with </span>IOServiceComponent =&gt;<br/><br/>  <span>val </span>jobConfigReaderService: JobConfigReaderService<br/><br/>  <span>class </span>JobConfigReaderService() <span>extends </span>LazyLogging {<br/><br/>    <strong>private val customSerializers = List(</strong><br/><strong>      JobFrequencySerializer,<br/>      JobTypeSerializer</strong><br/><strong>    )</strong><br/><br/><strong>    implicit val formats = DefaultFormats ++ customSerializers +<br/>     JobConfig.jobConfigFieldSerializer</strong><br/><br/>    <span>def </span><span>readJobConfigs</span>(): <span>List</span>[JobConfig] =<br/>      ioService.getAllFilesWithExtension(<br/>        appConfigService.<span>configPath</span><span>,<br/></span><span>        </span>appConfigService.<span>configExtension<br/></span><span>      </span>).flatMap {<br/>        <span>case </span>path =&gt; <span>try </span>{<br/>          <span>val </span>config = parse(<span>FileInput</span>(<span>new </span>File(path))).extract[JobConfig]<br/>          <span>Some</span>(config)<br/>        } <span>catch </span>{<br/>          <span>case </span>ex: <span>Throwable </span>=&gt;<br/>            <span>logger</span>.error(<span>"Error reading config: {}"</span><span>, </span>path<span>, </span>ex)<br/>            None<br/>        }<br/>      }<br/>  }<br/>}</pre>
<p>It depends on the two components we already showed in the preceding code. There is nothing special about this component, except the highlighted part. The first statement takes the custom serializers we have for the frequency and job type. The second statement adds them to the default formats so that json4s knows how to handle them. If you observe carefully, you will notice the <kbd>JobConfig.jobConfigFieldSerializer</kbd> call as well. Let's see what it looks like:</p>
<pre><span>import </span>org.json4s.FieldSerializer<br/><span>import </span>org.json4s.JsonAST.JField<br/><br/><span>case class </span>JobConfig(name: <span>String</span><span>, </span>command: <span>String</span><span>, </span>jobType: JobType<span>, </span>frequency: JobFrequency<span>, </span>timeOptions: TimeOptions)<br/><br/><span>object </span>JobConfig {<br/>  <span>val </span><span>jobConfigFieldSerializer </span>= <span>FieldSerializer</span>[JobConfig](<br/>    {<br/>      <span>case </span>(<span>"timeOptions"</span><span>, </span>x) =&gt; <span>Some</span>(<span>"time_options"</span><span>, </span>x)<br/>      <span>case </span>(<span>"jobType"</span><span>, </span>x) =&gt; <span>Some</span>(<span>"type"</span><span>, </span>x)<br/>    }<span>,<br/></span><span>    </span>{<br/>      <span>case </span><span>JField</span>(<span>"time_options"</span><span>, </span>x) =&gt; <span>JField</span>(<span>"timeOptions"</span><span>, </span>x)<br/>      <span>case </span><span>JField</span>(<span>"type"</span><span>, </span>x) =&gt; <span>JField</span>(<span>"jobType"</span><span>, </span>x)<br/>    }<br/>  )<br/>  <br/>}</pre>
<p>We need it because the Scala field names that we have used are different from what is in our JSON files, and json4s needs to know how to translate them.</p>
<p>Now that we have all the required mechanisms to read the job configurations, we can go deeper and see how they will be used to execute our jobs. We already said that we will be implementing our scheduler and workers using Akka. One thing about Akka is that it communicates using messages. We had to come up with some messages that our application will need:</p>
<pre><span>sealed trait </span>SchedulerMessage<br/><span>case class </span>Work(name: <span>String</span><span>, </span>command: <span>String</span><span>, </span>jobType: JobType)<br/><span>case class </span>Done(name: <span>String</span><span>, </span>command: <span>String</span><span>, </span>jobType: JobType<span>, </span>success: <span>Boolean</span>)<br/><span>case class </span>Schedule(configs: <span>List</span>[JobConfig])</pre>
<p>These messages are quite descriptive, so let's not waste time on them. Let's go straight to the point and see what our scheduler will look like:</p>
<pre><span>class </span>Master(numWorkers: <span>Int, </span>actorFactory: ActorFactory) <span>extends </span>Actor <span>with </span>LazyLogging {<br/>  <span>val </span><span>cancelables </span>= ListBuffer[Cancellable]()<br/>  <br/>  <strong>val router = context.actorOf(</strong><br/><strong>    Props(actorFactory.createWorkerActor()).withRouter(<br/>    RoundRobinPool(numWorkers)), "scheduler-master-worker-router"<br/>  )</strong><br/>  <br/>  <strong>override def receive: Receive = {</strong><br/>    <span>case </span><span>Done</span>(name<span>, </span>command<span>, </span>jobType<span>, </span>success) =&gt;<br/>      <span>if </span>(success) {<br/>        <span>logger</span>.info(<span>"Successfully completed {} ({})."</span><span>, </span>name<span>, </span>command)<br/>      } <span>else </span>{<br/>        <span>logger</span>.error(<span>"Failure! Command {} ({}) returned a non-zero<br/>         result code."</span><span>, </span>name<span>, </span>command)<br/>      }<br/>    <span>case </span><span>Schedule</span>(configs) =&gt; <br/>      configs.foreach {<br/>        <span>case </span>config =&gt;<br/>          <span>val </span>cancellable = <span>this</span>.<span>context</span>.system.scheduler.schedule(<br/>            config.timeOptions.getInitialDelay(LocalDateTime.<span>now</span>()<span>,<br/>             </span>config.frequency)<span>,<br/></span><span>            </span>config.frequency <span>match </span>{<br/>              <span>case </span>Hourly =&gt; Duration.<span>create</span>(<span>1</span><span>, </span>TimeUnit.<span>HOURS</span>)<br/>              <span>case </span>Daily =&gt; Duration.<span>create</span>(<span>1</span><span>, </span>TimeUnit.<span>DAYS</span>)<br/>            }<span>,<br/></span><span>            </span><span>router</span><span>,<br/></span><span>            </span><span>Work</span>(config.name<span>, </span>config.command<span>, </span>config.jobType)<br/>          )<br/>          cancellable +: <span>cancelables<br/></span><span>          logger</span>.info(<span>"Scheduled: {}"</span><span>, </span>config)<br/>      }<br/>  }<br/>  <br/>  <span>override def </span><span>postStop</span>(): <span>Unit </span>= {<br/>    <span>cancelables</span>.foreach(_.cancel())<br/>  }<br/>}</pre>
<p class="mce-root">We have called our scheduler <kbd>Master</kbd>, as it is the master actor in the actor system we will implement. We have skipped the imports in favor of saving some space. There are two places that deserve more attention in this actor—the <kbd>receive</kbd> method and the <kbd>router</kbd>. The former is essentially how actors work—the developer implements this method, which is simply a partially defined function, and if a message that we know about is received, it is handled. Our master actor can schedule a list of jobs by creating work items and sending them to the router. The router, on the other hand, is just a round-robin pool of workers, so every task we schedule will go to a different worker.</p>
<p>All workers will be running the same code, as follows:</p>
<pre><span>import </span>sys.process._<br/><br/><span>class </span>Worker(daoService: DaoService) <span>extends </span>Actor <span>with </span>LazyLogging {<br/>  <br/>  <span>private def </span><span>doWork</span>(work: Work): <span>Unit </span>= {<br/>    work.jobType <span>match </span>{<br/>      <span>case </span>Console =&gt;<br/>        <span>val </span>result = work.command.! <span>// note - the ! are different methods<br/></span><span>        </span><strong>sender ! Done(work.name, work.command, work.jobType, result == 0)</strong><br/>      <span>case </span>Sql =&gt;<br/>        <span>val </span>connection = daoService.getConnection()<br/>        <span>try </span>{<br/>          <span>val </span>statement = connection.prepareStatement(work.command)<br/>          <span>val </span>result: <span>List</span>[<span>String</span>] = daoService.executeSelect(statement) {<br/>            <span>case </span>rs =&gt;<br/>              <span>val </span>metadata = rs.getMetaData<br/>              <span>val </span>numColumns = metadata.getColumnCount<br/>              daoService.readResultSet(rs) {<br/>                <span>case </span>row =&gt;<br/>                  (<span>1 </span>to numColumns).map {<br/>                    <span>case </span>i =&gt;<br/>                      row.getObject(i)<br/>                  }.mkString(<span>"</span><span>\t</span><span>"</span>)<br/>              }<br/>          }<br/>          <span>logger</span>.info(<span>"Sql query results: "</span>)<br/>          result.foreach(r =&gt; <span>logger</span>.info(r))<br/>          sender ! <span>Done</span>(work.name<span>, </span>work.command<span>, </span>work.jobType<span>, </span><span>true</span>)<br/>        } <span>finally </span>{<br/>          connection.close()<br/>        }<br/>    }<br/>  }<br/>  <br/>  <span>override def </span><span>receive</span>: <span>Receive </span>= {<br/>    <span>case </span>w @ <span>Work</span>(name<span>, </span>command<span>, </span>jobType) =&gt; doWork(w)<br/>  }<br/>}</pre>
<p>They can only accept one message type (<kbd>Work</kbd>) and process it accordingly. For example, to run console tasks, we have used the built-in Scala functionality. Then the highlighted line makes sure a message is sent back to the sender (<kbd>Master</kbd> in our case) and, as you can see, it will handle it.</p>
<p>We have already seen a bunch of components that look a lot like how you would implement dependency injection using Scala—the cake design pattern. However, the general pattern that is followed with our actors isn't the way the cake design pattern is set up. That's why we've created a factory—<kbd>ActorFactory</kbd><span>,</span>which can inject objects into our actors:</p>
<pre><span>package </span>com.ivan.nikolov.scheduler.actors<br/><br/><span>import </span>com.ivan.nikolov.scheduler.config.app.AppConfigComponent<br/><span>import </span>com.ivan.nikolov.scheduler.dao.DaoServiceComponent<br/><br/><span>trait </span>ActorFactory {<br/>  <span>def </span><span>createMasterActor</span>(): Master<br/>  <span>def </span><span>createWorkerActor</span>(): Worker<br/>}<br/><br/><span>trait </span>ActorFactoryComponent {<br/>  <span>this</span>: AppConfigComponent<br/>    <span>with </span>DaoServiceComponent =&gt;<br/>  <br/>  <span>val </span>actorFactory: ActorFactory<br/>  <br/>  <span>class </span>ActorFactoryImpl <span>extends </span>ActorFactory {<br/>    <span>override def </span><span>createMasterActor</span>(): Master =<br/>     <span>new </span>Master(appConfigService.<span>workers</span><span>, </span><span>this</span>)<br/><br/>    <span>override def </span><span>createWorkerActor</span>(): Worker = <span>new </span>Worker(daoService)<br/>  } <br/>}</pre>
<p>You can see how the preceding factory is passed (using the <kbd>this</kbd> reference) and used in the <kbd>Master</kbd> actor for creating <kbd>Worker</kbd> instances.</p>
<p>We have already seen everything we need in order to run console jobs with our scheduler. Now we have to implement things in order to support database access. We will skip the database code here, as it is pretty much the same as the one we saw in <a href="e1484517-e8e3-4083-8617-04a17922b9f4.xhtml" target="_blank">Chapter 11</a>, <em>Applying What We Have Learned</em>, it is based on the cake design pattern. We have only skipped some convenience methods that we don't need here. However, the database our scheduler can query still has the same schema:</p>
<pre>CREATE TABLE people(<br/>  id INT PRIMARY KEY,<br/>  name VARCHAR(255) NOT NULL,<br/>  age INT NOT NULL<br/>);<br/><br/>CREATE TABLE classes(<br/>  id INT PRIMARY KEY,<br/>  name VARCHAR(255) NOT NULL,<br/>);<br/><br/>CREATE TABLE people_classes(<br/>  person_id INT NOT NULL,<br/>  class_id INT NOT NULL,<br/>  PRIMARY KEY(person_id, class_id),<br/>  FOREIGN KEY(person_id) REFERENCES people(id) ON DELETE CASCADE ON UPDATE CASCADE,<br/>  FOREIGN KEY(class_id) REFERENCES classes(id) ON DELETE CASCADE ON UPDATE CASCADE<br/>);</pre>
<p>We have also added some extra database statements to aid us in unit testing but they are minor, and not putting them here will not affect anything.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Wiring it all up</h1>
                </header>
            
            <article>
                
<p>It seems like we already have all the components our application will be using. Now we just need to wire things together and fire it up. We are using the cake design pattern for dependency injection; so, as you have already seen, we can create one component registry with everything we need:</p>
<pre><span>package </span>com.ivan.nikolov.scheduler.registry<br/><br/><span>import </span>com.ivan.nikolov.scheduler.actors.{ActorFactory<span>, </span>ActorFactoryComponent}<br/><span>import </span>com.ivan.nikolov.scheduler.config.app.AppConfigComponent<br/><span>import </span>com.ivan.nikolov.scheduler.dao._<br/><span>import </span>com.ivan.nikolov.scheduler.io.IOServiceComponent<br/><span>import </span>com.ivan.nikolov.scheduler.services.JobConfigReaderServiceComponent<br/><br/><span>object </span>ComponentRegistry <span>extends </span>AppConfigComponent <br/>  <span>with </span>IOServiceComponent <br/>  <span>with </span>JobConfigReaderServiceComponent<br/>  <span>with </span>DatabaseServiceComponent<br/>  <span>with </span>MigrationComponent<br/>  <span>with </span>DaoServiceComponent<br/>  <span>with </span>ActorFactoryComponent {<br/><br/>  <span>override val </span><span>appConfigService</span>: ComponentRegistry.AppConfigService = <span>new </span>AppConfigService<br/>  <span>override val </span><span>ioService</span>: ComponentRegistry.IOService = <span>new </span>IOService<br/>  <span>override val </span><span>jobConfigReaderService</span>: ComponentRegistry.JobConfigReaderService = <span>new </span>JobConfigReaderService<br/>  <span>override val </span><span>databaseService</span>: DatabaseService = <span>new </span>H2DatabaseService<br/>  <span>override val </span><span>migrationService</span>: ComponentRegistry.MigrationService = <span>new </span>MigrationService<br/>  <span>override val </span><span>daoService</span>: DaoService = <span>new </span>DaoServiceImpl<br/>  <span>override val </span><span>actorFactory</span>: ActorFactory = <span>new </span>ActorFactoryImpl<br/>}</pre>
<p>Now that we have a component registry, we can use it and write the main application class:</p>
<pre><span>package </span>com.ivan.nikolov.scheduler<br/><br/><span>import </span>akka.actor.{Props<span>, </span>ActorSystem}<br/><span>import </span>com.ivan.nikolov.scheduler.actors.messages.Schedule<br/><span>import </span>com.typesafe.scalalogging.LazyLogging<br/><br/><span>import </span>scala.concurrent.Await<br/><span>import </span>scala.concurrent.duration.Duration<br/><br/><span>object </span>Scheduler <span>extends </span>LazyLogging {<br/>  <span>import </span>com.ivan.nikolov.scheduler.registry.ComponentRegistry._<br/>  <span>def </span><span>main</span>(args: Array[<span>String</span>]): <span>Unit </span>= {<br/>    <span>logger</span>.info(<span>"Running migrations before doing anything else."</span>)<br/>    <span>migrationService</span>.runMigrations()<br/>    <span>logger</span>.info(<span>"Migrations done!"</span>)<br/>    <br/>    <span>val </span>system = <span>ActorSystem</span>(<span>"scheduler"</span>)<br/>    <br/>    <span>val </span>master = system.actorOf(<br/>      <span>Props</span>(<span>actorFactory</span>.createMasterActor())<span>,<br/></span><span>      </span><span>"scheduler-master"<br/></span><span>    </span>)<br/>    <br/>    sys.<span>addShutdownHook</span>({<br/>      <span>logger</span>.info(<span>"Awaiting actor system termination."</span>)<br/>      <span>// not great...<br/></span><span>      </span>Await.<span>result</span>(system.terminate()<span>, </span>Duration.<span>Inf</span>)<br/>      <span>logger</span>.info(<span>"Actor system terminated. Bye!"</span>)<br/>    })<br/>    <br/>    <strong>master ! Schedule(jobConfigReaderService.readJobConfigs())</strong><br/>    <span>logger</span>.info(<span>"Started! Use CTRL+C to exit."</span>)<br/>  }<br/>}</pre>
<p>Our application has some very simple Akka wiring up and then everything is triggered when we execute the highlighted line. We send a <kbd>Schedule</kbd> message to the master with all the job configurations and then it will schedule them to run periodically according to their definitions.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The end result</h1>
                </header>
            
            <article>
                
<p>After all this code is written, we will end up with the following tree in our IDE:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/bd2cb2a1-6bcf-4b8c-8dae-24c0a5f5f9cd.png" style="width:25.42em;height:35.17em;" width="452" height="625"/></div>
<p>You can see that our code also contains unit tests. We will spend some time on them in the next subsection.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Testing our application</h1>
                </header>
            
            <article>
                
<p>Testing is a really important part of every application. Using TDD is really good, as we can write and test our applications simultaneously instead of coming back to something that is already done. We used this approach while writing the application, but separated the code and the tests in favor of explaining things better and not mixing them up.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Unit testing</h1>
                </header>
            
            <article>
                
<p>As you have already seen earlier, testing applications that rely on the cake design pattern is simple. We have defined the following test environment:</p>
<pre><span>package </span>com.ivan.nikolov.scheduler<br/><br/><span>import </span>com.ivan.nikolov.scheduler.actors.{ActorFactory<span>, </span>ActorFactoryComponent}<br/><span>import </span>com.ivan.nikolov.scheduler.config.app.AppConfigComponent<br/><span>import </span>com.ivan.nikolov.scheduler.dao._<br/><span>import </span>com.ivan.nikolov.scheduler.io.IOServiceComponent<br/><span>import </span>com.ivan.nikolov.scheduler.services.JobConfigReaderServiceComponent<br/><span>import </span>org.mockito.Mockito._<br/><span>import </span>org.scalatest.mockito.MockitoSugar<br/><br/><span>trait </span>TestEnvironment <br/>  <span>extends </span>AppConfigComponent<br/>  <span>with </span>IOServiceComponent<br/>  <span>with </span>JobConfigReaderServiceComponent<br/>  <span>with </span>DatabaseServiceComponent<br/>  <span>with </span>MigrationComponent<br/>  <span>with </span>DaoServiceComponent<br/>  <span>with </span>ActorFactoryComponent<br/>  <span>with </span>MockitoSugar {<br/><br/>  <span>// use the test configuration file.<br/></span><span>  </span><span>override val </span><span>appConfigService</span>: AppConfigService = <span>spy</span>(<span>new </span>AppConfigService)<br/>  <span>// override the path here to use the test resources.<br/></span><span>  </span><span>when</span>(<span>appConfigService</span>.<span>configPath</span>).thenReturn(<span>this</span>.getClass.getResource(<span>"/"</span>).getPath)<br/>  <br/>  <span>override val </span><span>ioService</span>: IOService = mock[IOService]<br/>  <span>override val </span><span>jobConfigReaderService</span>: JobConfigReaderService = mock[JobConfigReaderService]<br/>  <span>override val </span><span>databaseService</span>: DatabaseService = mock[DatabaseService]<br/>  <span>override val </span><span>migrationService</span>: MigrationService = mock[MigrationService]<br/>  <span>override val </span><span>daoService</span>: DaoService = mock[DaoService]<br/>  <span>override val </span><span>actorFactory</span>: ActorFactory = mock[ActorFactory]<br/>}</pre>
<p>When we do testing, we use an actual application configuration file instead of working with mocks and can use any file inside our test resources folder. We have written quite extensive tests for the <kbd>TimeOptions</kbd> class, more specifically the part that calculates the initial delay. There are tests to read job configuration files as well as database access tests. They can all be seen in the projects provided with this book.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Application testing</h1>
                </header>
            
            <article>
                
<p>No doubt, the part that everyone wanted to see the most is where we actually give our application an actual spin. However, because it is a scheduler, we first need to prepare some configurations. We will use the following application configuration file:</p>
<pre><span>job-scheduler </span>{<br/>  <span>config-path</span>=<span>"/etc/scheduler/conf.d"<br/></span><span>  </span><span>config-extension</span>=<span>"json"<br/></span><span>  </span><span>workers</span>=<span>4<br/></span><span>  </span><span>db </span>{<br/>    <span>connection-string</span>=<span>"jdbc:h2:mem:test;DB_CLOSE_DELAY=-1"<br/></span><span>    </span><span>username</span>=<span>""<br/></span><span>    </span><span>password</span>=<span>""<br/></span><span>  </span>}<br/>}</pre>
<p>We will name our file <kbd>production.conf</kbd> and we will put it in <kbd>/etc/scheduler/conf.d</kbd>. Now we need to create some actual job configurations. We will have to put them where the <kbd>config-path</kbd> property is pointing to:</p>
<pre>// ping.json<br/>{<br/>  "name": "Ping Command",<br/>  "command": "ping google.com -c 10",<br/>  "frequency": "Hourly",<br/>  "type": "Console",<br/>  "time_options": {<br/>    "hours": 21,<br/>    "minutes": 10<br/>  }<br/>}<br/>// ping1.json<br/>{<br/>  "name": "Ping1 Command",<br/>  "command": "ping facebook.com -c 10",<br/>  "frequency": "Hourly",<br/>  "type": "Console",<br/>  "time_options": {<br/>    "hours": 21,<br/>    "minutes": 15<br/>  }<br/>}<br/>// query.json<br/>{<br/>  "name": "See all people",<br/>  "command": "SELECT * FROM people",<br/>  "frequency": "Hourly",<br/>  "type": "Sql",<br/>  "time_options": {<br/>    "hours": 21,<br/>    "minutes": 5<br/>  }<br/>}</pre>
<p>The last job should have no issues running on any operating system. You may need to change the commands in the first two jobs if you are using Windows, for example. Also, time options might need to be changed, depending on when the application is being run and if you don't want to wait for hours before you see proof that it actually works.</p>
<p>If we run our application now with these configurations, we will get the following output:</p>
<div class="CDPAlignCenter CDPAlign"><img src="Images/a8b4e47a-f607-405e-9723-4ac53004c274.png" style="width:33.42em;height:44.75em;" width="713" height="956"/></div>
<p>We can leave the application and it will keep executing the tasks we had every one hour or day, depending on how the tasks are scheduled. Of course, we could add more meaningful jobs, allocate more workers, change other configurations, and so on.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">The future of our application</h1>
                </header>
            
            <article>
                
<p>We have used a number of techniques and concepts that we have learned throughout this book—dependency injection, factory design pattern, ADTs, and the Akka library, which can be used to implement the observer design pattern. This was a complete application that was designed to be testable and extendible.</p>
<p>We can easily add more granularity to the execution schedule of the jobs, the different types of tasks, and also have tasks trigger each other, different routing mechanisms, and so on. We showed that we have learned about a great number of useful concepts in this book, and now we can put everything to use in order to create great programs.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>Here, we are at the end of our journey through the Scala design patterns. As you already know, design patterns exist in order to cope with a certain limitation of a language. They also help us to structure our code in a way that makes it easy to change, use, test, and maintain. Scala is an extremely rich language, and we focused on some of its features that make it capable of achieving things that other languages might not be able to do without any extra effort and knowledge.</p>
<p>We looked at the different <em>Gang of Four</em> design patterns from the point of view of Scala—creational, structural, and behavioral design patterns. We saw that some of them are not even applicable in functional languages and that others can be approached differently. We also saw that some design patterns still remain valid and knowing them is really important for any developer.</p>
<p>We can't talk about Scala without dealing with concepts such as monoids and monads. At first, they could be pretty scary and abstract and manage to put people off. So, we spent some time with them and showed their value. They can be used to write powerful applications in a purely functional way. They can be used to abstract and reuse functionality. By minimizing the dry theory and focusing on understandable examples, we hopefully made them much more approachable and usable for those of you who don't have a deep mathematical background.</p>
<p>Using the rich features of Scala opens up another large group of design patterns. We spent some time on design patterns that are possible just because of the way Scala works and the different features it provides.</p>
<p>Throughout the book, we have tried to provide meaningful examples that can be used as a reference to find specific patterns and applications of the techniques we learned here. In this last chapter, we even implemented a complete application. On many occasions, we have tried to showcase how different design patterns can be combined. Of course, in some cases, the concepts could be pretty complicated by themselves, so we simplified the examples.</p>
<p>We've given some advice about when to use certain design patterns and when to avoid them. These points should be extremely helpful to you in terms of what details to focus on.</p>
<p>The use of libraries has been encouraged throughout the book. Especially in the last few chapters, you have been exposed to quite a large number of interesting libraries that can be easily added to your arsenal. We have hopefully also sparked an interest and a habit to always do checks before trying something <em>new</em>.</p>
<p>Finally, all the examples found in this book can also be found online at <a href="https://github.com/nikolovivan/scala-design-patterns-v2">https://github.com/nikolovivan/scala-design-patterns</a>.</p>


            </article>

            
        </section>
    </div>



  </body></html>