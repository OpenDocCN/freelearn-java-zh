- en: Abstract and Self Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Designing and writing high-quality code in software engineering is important
    in order to have applications that are easy to extend and maintain. This activity
    requires the domain to be well-known, correctly understood by a developer, and
    the requirements for the application to be well-defined. If any of these are absent,
    then writing good programs becomes quite challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, engineers model the *world* using some abstractions. This helps with
    code extendibility and maintainability and removes duplication, which in many
    cases could be a reason for bugs. Good code, generally, will consist of multiple
    small components, that depend on and interact with each other. There are different
    approaches that help to achieve abstraction and interaction. We will look into
    the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The topics that we will cover here will be really useful when we start looking
    into some of the concrete design patterns. Learning about them will also help
    to understand the design patterns that rely on them. Moreover, the concepts covered
    in this chapter are useful just by themselves for writing good code.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most common ways to parameterize classes is by using values. This
    is quite simple, and it is achieved by passing different values for the constructor
    parameters of a class. In the following example, we can pass different values
    for the `name` parameter of the `Person` class, and this is how we create different
    instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can create different instances and distinguish them, but this is
    neither interesting nor rocket science. Going further, we will focus on some more
    interesting parameterizations that will help us improve our code.
  prefs: []
  type: TYPE_NORMAL
- en: Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generics are another way of parameterizing classes. They are useful when we
    write a functionality whose application is the same throughout various types,
    and we can simply defer choosing a concrete type until later. One example every
    developer should be familiar with is collection classes. `List`, for example,
    can store any type of data, and we can have lists of integers, doubles, strings,
    custom classes, and so on. Still, the list implementation is always the same.
  prefs: []
  type: TYPE_NORMAL
- en: We can also parameterize methods. For example, if we want to implement addition,
    it will not change between different numerical data types. Hence, we can use generics
    and just write our method once instead of overloading and trying to accommodate
    every single type in the world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is a bit more involved and it defines a method called `sum`,
    which can be used with all numeric types. This is actually a representation of
    **ad hoc polymorphism**, which we will talk about later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how to parameterize a class to contain any kind of
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet shows some example uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of this program will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to parameterize classes is by using abstract types. Generics have
    their counterparts in other languages such as Java. Unlike them, however, abstract
    types do not exist in Java. Let''s see how our preceding `Container` example will
    translate into one with abstract types, rather than generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use the trait in a class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'After we''ve done this, we can have the same example as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We could, of course, use it in a similar way to the generic example by creating
    an instance of the trait and specifying the parameters there. This means that
    generics and abstract types really give us the possibility of achieving the same
    thing in two different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Generics versus abstract types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, why are there both generics and abstract types in Scala? Are there any differences,
    and when should one be used over the other? We will try to give answers to these
    questions here.
  prefs: []
  type: TYPE_NORMAL
- en: Generics and abstract types can be interchangeable. We might have to do some
    extra work, but in the end, we could get what the abstract types provide using
    generics. Which one is chosen depends on different factors, some of which are
    personal preferences, such as whether someone is aiming for readability or a different
    kind of usage of the classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at an example and try to get an idea of when and how generics
    and abstract types are used. In this current example, we will talk about printers.
    Everyone knows that there are different types—paper printers, 3D printers, and so
    on. Each of these uses different materials to print with, for example toner, ink,
    or plastic, and they are used to print on different types of media such as paper
    or actually in the surrounding environment. We can represent something like this
    using an abstract type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to call the `print` method, we need to have different media, types
    of data, and materials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now make two concrete printer implementations, a laser and a 3D printer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we actually gave some specifications about the kind
    of data, media, and materials that these printers can be used with. This way,
    we can''t ask our 3D printer to use toner to print something or our laser printer
    to print in the air. This is how we will use our printers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is really readable, and it allows us to specify concrete
    classes easily. It makes things easier to model. It is interesting to see how
    the preceding code would translate to generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The trait is easily represented, and readability and logical correctness are
    not compromised here. However, we must represent concrete classes in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes quite long, and a developer could easily make a mistake. The following
    snippet shows how to create instances and use the classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we must specify the types every time we create instances.
    Imagine if we have more than three generic types, some of which could be based
    on generics as well, for example collections. This could quickly get quite tedious
    and make the code look harder than it actually is.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, using generics allows us to reuse `GenericPrinter` without
    explicitly subclassing it multiple times for each different printer representation.
    There is, however, the risk of making logical mistakes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If used as follows, there is a danger of making a mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Usage advice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous examples show a relatively simple comparison between the use of
    generics and abstract types. Both are useful concepts; however, it is important
    to be aware of what exactly is being done in order to use the right one for the
    situation. Here are some tips that could help in making the right decision.
  prefs: []
  type: TYPE_NORMAL
- en: '**Use generics:**'
  prefs: []
  type: TYPE_NORMAL
- en: If you need just type instantiation; a good example is the standard collection
    classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are creating a family of types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use abstract types:**'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to allow people to mix in types using traits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need better readability in scenarios where both could be interchangeable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to hide the type definition from the client code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is something every developer who has done some object-oriented
    programming knows about.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism helps us to write generic code that can be reused and applied to
    a variety of types.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to know that there are different types of polymorphism out there,
    and we will be looking at them in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Subtype polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the polymorphism every developer knows about, and it''s related to
    overriding methods in concrete class implementations. Consider the following simple
    hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s have a shopping basket of items and call `pack` for each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, here we can use the abstract type and just call the `pack`
    method without thinking about what exactly it is. Polymorphism will take care
    of printing the correct value. Our output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Subtype polymorphism is expressed using inheritance with the `extends` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Parametric polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parametric polymorphism in functional programming is what we showed in the previous
    section about generics. Generics are parametric polymorphism, and as we already
    saw, they allow us to define methods or data structures over any type, or a subset
    of a given type. Concrete types can then be specified at a later stage.
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ad hoc polymorphism is similar to parametric polymorphism; however, in this
    case, the type of arguments is important, as the concrete implementation will
    depend on it. It is resolved at compile time, unlike subtype polymorphism, which
    is done during runtime. This is somewhat similar to function overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw an example of it earlier in this chapter, where we created the `Adder`
    trait that can sum different types. Let''s have another one but a bit more refined
    and step by step, and we will hopefully understand how things work. Our goal is
    to have a `sum` method that can add many different kinds of types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will create a Scala object that uses this `sum` method and exposes
    it to the outside world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'What we saw in the preceding code is some syntactic sugar in Scala, and `implicitly`
    says that there exists an implicit conversion from the `T` type to `Adder[T]`.
    We can now write the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to compile and run this, we will run into trouble and get the following
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This indicates that our code does not know how to implicitly convert integers
    or strings to `Adder[Int]` or `Adder[String]`. What we have to do is define these
    conversions as well as tell our program what the `sum` method will do. Our `Adder`
    object will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run our application now, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you remember from the example at the beginning of the chapter, we were
    not able to use the `sum` method on strings. As you can see here, we can provide
    different implementations, and using it with anything is not a problem as long
    as we have defined a way to convert a type to `Adder`.
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc polymorphism allows us to extend our code without modifying the base
    classes. This is very useful if we are using external libraries, or if we simply
    are not able to change the original code for some reason. It is really powerful
    and is evaluated in compile time, which makes sure that our program will work
    as expected. Moreover, it allows us to provide function definitions for types
    that we have no access to (`Int` and `String`, in our case).
  prefs: []
  type: TYPE_NORMAL
- en: Adding functions for multiple types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we look back at the beginning of this chapter, where we made `Adder` work
    with numeric types, we will see that our last implementation of `Adder` would
    require us to define an operation separately for each different numeric type.
    Is there a way to achieve what we showed in the beginning of the chapter here
    as well? Yes, there is, and this is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We just defined another implicit conversion, and it will take care of the right
    things for us. Now, we can also write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Ad hoc polymorphism is expressed using implicits to mixin behavior. It is the
    main building block for the **type class design pattern**, which we will look
    into later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Self types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features of good code is the separation of concerns. Developers should
    aim to make classes and their methods responsible for one and only one thing.
    This helps in testing, maintaining, and simply understanding code better. Remember—*simple
    is always better*.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is inevitable that when writing real software, we will need instances
    of some classes within other ones in order to achieve certain functionalities.
    In other words, once our building blocks are nicely separated, they would have
    dependencies in order to perform their functionality. What we are talking about
    here really boils down to dependency injection. Self types provide a way to handle
    these dependencies in an elegant way. In this section, we will see how to use
    them and what they are good for.
  prefs: []
  type: TYPE_NORMAL
- en: Using self types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Self types allow us to easily separate code in our applications, and then require
    it from other places. Everything gets clearer with an example, so let''s have
    a look at one. Let''s assume that we want to be able to persist information into
    a database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `persist` method will do some transformations on the data and then insert
    it in our database. Of course, our code is well-written, so the database implementations
    are separated. We have the following for our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a base trait and then some concrete database implementations. So, how
    do we pass our database to `Persister`? It should be able to call the `save` method
    defined in the database. Our possibilities include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend `Database` in `Persister`. This would, however, also make `Persister`
    an instance of `Database`, and we don't want this. We will show why later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have a variable for `Database` in `Persister` and use it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use self types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We are trying to see how self types work here, so let''s use this approach.
    Our `Persister` interface will change to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have access to the methods in `Database` and can call the `save` method
    inside `Persister`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Naming the self type** In the preceding code, we included our self type using
    the statement—`this: Database[T] =>`. This allows us to access the methods of
    our included types directly as if they were methods of the trait that includes
    them. Another way of doing the same here is by writing `self: Database[T] =>`
    instead. There are many examples out there that use the latter approach, which
    is useful to avoid confusion if we need to refer to `this` in some nested trait
    or class definitions. Calling the methods of the injected dependencies using this
    approach, however, would require the developer to use `self.` in order to gain
    access to the required methods.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The self type requires any class that mixes `Persister` in, to also mix `Database`
    in. Otherwise, our compilation will fail. Let''s create classes to persist to
    memory and database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use them in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the output of our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: What self types do is different from inheritance. They require the presence
    of some code, and thus allow us to split a functionality nicely. This can make
    a huge difference in maintaining, refactoring, and understanding a program.
  prefs: []
  type: TYPE_NORMAL
- en: Requiring multiple components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In real applications, we might require more than one component using a self
    type. Let''s show this in our example with a `History` trait that could potentially
    keep track of changes to roll back at some point. Ours will just do printing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use this in our `Persister` trait, and it will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `with` keyword, we can add as many requirements as we like. However,
    if we just leave our code changes there, it will not compile. The reason for this
    is that we must now mix `History` in every class that uses `Persister`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. If we now run our code, we will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Conflicting components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the preceding example, we had a requirement for the `History` trait, which
    has an `add()` method. What would happen if the methods in different components
    have the same signatures and they clash? Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this in our `Persister` trait:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we will change all the classes that mix `Persister` in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to compile our application, we will see that it results in a failure
    with the following messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Luckily, the error messages also contain information that tells us how we can
    fix the problem. This is absolutely the same case that we saw earlier while using
    traits, and we can provide the following fix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the example, we will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Self types and the cake design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we saw in our preceding examples was a pure example of dependency injection.
    We required one component to be available in another one through self types.
  prefs: []
  type: TYPE_NORMAL
- en: Self types are often used for dependency injection. They are the main part of
    the **cake design pattern**, which we will become familiar with later in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: The cake design pattern relies completely on self types. It encourages engineers
    to write small and simple components, which declare and use their dependencies.
    After all the components in an application are programmed, they can be instantiated
    inside a common component registry and made available to the actual application.
    One of the nice advantages of the cake design pattern is that it actually checks
    during compile time whether all the dependencies would be satisfied. We will dedicate
    a complete section on the cake design pattern later in this book, where we will
    provide more details about how the pattern can actually be wired up, what advantages
    and drawbacks it has, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Self types versus inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we said that we don't want to use inheritance in order
    to get access to the `Database` methods. Why is that? If we had made `Persister`
    extend `Database`, this would mean that it would become a database itself (*is-a*
    relationship). However, this is not correct. It uses a database in order to achieve
    its functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inheritance exposes a subclass to the implementation details of its parent.
    This, however, is not always desired. According to the authors of *Design Patterns:
    Elements of Reusable Object-Oriented Software*, developers should favor object
    composition over class inheritance.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance leaking functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we use inheritance, we would also leak functionality to subclasses that
    we do not want. Let''s look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This could be a real-life scenario. Because this is how inheritance works,
    we would get access to `dropDatabase` in `UserService`. This is something we do
    not want, and we can fix it using self types. The DB trait stays the same. Everything
    else changes to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As the comments in the code show, in this last version of the code, we do not
    have access to the `DB` trait methods. We can only call the methods of the type
    we require, and this is exactly what we wanted to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we familiarized ourselves with some concepts that help us to
    write better, more generic, and extendible software. We focused on abstract types,
    polymorphism, and self types in Scala.
  prefs: []
  type: TYPE_NORMAL
- en: We looked into the differences between generics and abstract type values in
    classes, along with some examples and usage advice. Then, we introduced the different
    types of polymorphism—subtype, parametric, and ad hoc. Finally, we went through
    self types in Scala and how to use them. We showed that self types provide a good
    way to encapsulate functionality and write modular code.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will look into the importance of separating the
    responsibilities of software components. We will also go through aspect-oriented
    programming.
  prefs: []
  type: TYPE_NORMAL
