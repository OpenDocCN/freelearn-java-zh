- en: Abstract and Self Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象和自类型
- en: Designing and writing high-quality code in software engineering is important
    in order to have applications that are easy to extend and maintain. This activity
    requires the domain to be well-known, correctly understood by a developer, and
    the requirements for the application to be well-defined. If any of these are absent,
    then writing good programs becomes quite challenging.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件工程中设计和编写高质量的代码对于拥有易于扩展和维护的应用程序非常重要。这项活动要求领域知识要被开发者充分了解，并且应用程序的要求要明确定义。如果其中任何一个条件不满足，编写好的程序就会变得相当具有挑战性。
- en: 'Often, engineers model the *world* using some abstractions. This helps with
    code extendibility and maintainability and removes duplication, which in many
    cases could be a reason for bugs. Good code, generally, will consist of multiple
    small components, that depend on and interact with each other. There are different
    approaches that help to achieve abstraction and interaction. We will look into
    the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，工程师会使用一些抽象来模拟 *世界*。这有助于代码的可扩展性和可维护性，并消除了重复，这在许多情况下可能是错误的原因。好的代码通常由多个小型组件组成，这些组件相互依赖并相互作用。有几种不同的方法可以帮助实现抽象和交互。我们将在本章中探讨以下主题：
- en: Abstract types
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类型
- en: Polymorphism
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多态
- en: Self types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自类型
- en: The topics that we will cover here will be really useful when we start looking
    into some of the concrete design patterns. Learning about them will also help
    to understand the design patterns that rely on them. Moreover, the concepts covered
    in this chapter are useful just by themselves for writing good code.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里将要讨论的主题，当我们开始研究一些具体的设计模式时，将会非常有用。了解它们也将帮助我们理解依赖于它们的设计模式。此外，本章中涵盖的概念本身对于编写好的代码就很有用。
- en: Abstract types
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类型
- en: 'One of the most common ways to parameterize classes is by using values. This
    is quite simple, and it is achieved by passing different values for the constructor
    parameters of a class. In the following example, we can pass different values
    for the `name` parameter of the `Person` class, and this is how we create different
    instances:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用值来参数化类是最常见的方法之一。这很简单，通过为类的构造函数参数传递不同的值来实现。在下面的示例中，我们可以为 `Person` 类的 `name`
    参数传递不同的值，这就是我们创建不同实例的方式：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This way, we can create different instances and distinguish them, but this is
    neither interesting nor rocket science. Going further, we will focus on some more
    interesting parameterizations that will help us improve our code.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们可以创建不同的实例并将它们区分开来，但这既不有趣也不需要火箭科学。进一步来说，我们将关注一些更有趣的参数化方法，这将帮助我们改进我们的代码。
- en: Generics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: Generics are another way of parameterizing classes. They are useful when we
    write a functionality whose application is the same throughout various types,
    and we can simply defer choosing a concrete type until later. One example every
    developer should be familiar with is collection classes. `List`, for example,
    can store any type of data, and we can have lists of integers, doubles, strings,
    custom classes, and so on. Still, the list implementation is always the same.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型是另一种参数化类的方法。当我们要编写一个在多种类型中应用相同功能的功能时，它们非常有用，并且我们可以简单地推迟选择具体类型直到以后。每个开发者都应该熟悉的一个例子是集合类。例如，`List`
    可以存储任何类型的数据，我们可以有整数列表、双精度浮点数列表、字符串列表、自定义类列表等等。然而，列表实现始终是相同的。
- en: We can also parameterize methods. For example, if we want to implement addition,
    it will not change between different numerical data types. Hence, we can use generics
    and just write our method once instead of overloading and trying to accommodate
    every single type in the world.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以参数化方法。例如，如果我们想实现加法，它不会在不同数值数据类型之间改变。因此，我们可以使用泛型，只需编写一次方法，而不是重载并试图适应世界上每一个类型。
- en: 'Let''s look at some examples:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些例子：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code is a bit more involved and it defines a method called `sum`,
    which can be used with all numeric types. This is actually a representation of
    **ad hoc polymorphism**, which we will talk about later in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段代码稍微复杂一些，它定义了一个名为 `sum` 的方法，这个方法可以用于所有数值类型。这实际上是对 **ad hoc polymorphism**
    的一个表示，我们将在本章后面讨论这个概念。
- en: 'The following code shows how to parameterize a class to contain any kind of
    data:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何参数化一个类以包含任何类型的数据：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following snippet shows some example uses:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了几个示例用法：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output of this program will be as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出将如下所示：
- en: '[PRE4]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Abstract types
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类型
- en: 'Another way to parameterize classes is by using abstract types. Generics have
    their counterparts in other languages such as Java. Unlike them, however, abstract
    types do not exist in Java. Let''s see how our preceding `Container` example will
    translate into one with abstract types, rather than generics:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种通过抽象类型参数化类的方法。泛型在其他语言（如Java）中也有对应物。然而，与它们不同，Java中没有抽象类型。让我们看看前面的`Container`示例如何通过抽象类型而不是泛型来转换：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will use the trait in a class, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在类中使用这个特性，如下所示：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'After we''ve done this, we can have the same example as before:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成这些之后，我们可以有与之前相同的例子：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The expected output is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 预期的输出如下：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We could, of course, use it in a similar way to the generic example by creating
    an instance of the trait and specifying the parameters there. This means that
    generics and abstract types really give us the possibility of achieving the same
    thing in two different ways.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以通过创建特例的实例并指定参数的方式，以类似的方式使用它，就像通用示例那样。这意味着泛型和抽象类型实际上给了我们两种不同的方式来实现相同的事情。
- en: Generics versus abstract types
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型与抽象类型比较
- en: So, why are there both generics and abstract types in Scala? Are there any differences,
    and when should one be used over the other? We will try to give answers to these
    questions here.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么Scala中既有泛型又有抽象类型？它们之间有什么区别，何时应该使用一个而不是另一个？我们将在这里尝试回答这些问题。
- en: Generics and abstract types can be interchangeable. We might have to do some
    extra work, but in the end, we could get what the abstract types provide using
    generics. Which one is chosen depends on different factors, some of which are
    personal preferences, such as whether someone is aiming for readability or a different
    kind of usage of the classes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型和抽象类型可以互换。我们可能需要做一些额外的工作，但最终，我们可以使用泛型得到抽象类型提供的东西。选择哪一个取决于不同的因素，其中一些是个人偏好，例如是否有人追求可读性或类的不同使用方式。
- en: 'Let''s have a look at an example and try to get an idea of when and how generics
    and abstract types are used. In this current example, we will talk about printers.
    Everyone knows that there are different types—paper printers, 3D printers, and so
    on. Each of these uses different materials to print with, for example toner, ink,
    or plastic, and they are used to print on different types of media such as paper
    or actually in the surrounding environment. We can represent something like this
    using an abstract type:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，并尝试了解泛型和抽象类型何时以及如何被使用。在这个当前例子中，我们将讨论打印机。每个人都知道有不同类型——纸张打印机、3D打印机等等。这些打印机各自使用不同的材料进行打印，例如碳粉、墨水或塑料，并且它们被用于打印在不同的媒体上，如纸张，或者在周围环境中。我们可以使用抽象类型来表示类似的东西：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In order to call the `print` method, we need to have different media, types
    of data, and materials:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用`print`方法，我们需要有不同的媒体、数据类型和材料：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s now make two concrete printer implementations, a laser and a 3D printer:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来制作两个具体的打印机实现，一个激光打印机和3D打印机：
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding code, we actually gave some specifications about the kind
    of data, media, and materials that these printers can be used with. This way,
    we can''t ask our 3D printer to use toner to print something or our laser printer
    to print in the air. This is how we will use our printers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们实际上给出了一些关于这些打印机可以使用的类型、媒体和材料的规范。这样，我们就不能要求我们的3D打印机使用碳粉打印东西，或者我们的激光打印机在空中打印。这就是我们将如何使用我们的打印机：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding code is really readable, and it allows us to specify concrete
    classes easily. It makes things easier to model. It is interesting to see how
    the preceding code would translate to generics:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码非常易于阅读，并且使我们能够轻松指定具体类。它使建模变得更容易。有趣的是看到前面的代码如何转换为泛型：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The trait is easily represented, and readability and logical correctness are
    not compromised here. However, we must represent concrete classes in this way:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 特性很容易表示，可读性和逻辑正确性在这里都没有受到影响。然而，我们必须以这种方式表示具体类：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This becomes quite long, and a developer could easily make a mistake. The following
    snippet shows how to create instances and use the classes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这会变得相当长，开发者很容易出错。以下片段显示了如何创建实例和使用这些类：
- en: '[PRE15]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we can see that we must specify the types every time we create instances.
    Imagine if we have more than three generic types, some of which could be based
    on generics as well, for example collections. This could quickly get quite tedious
    and make the code look harder than it actually is.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到，每次创建实例时都必须指定类型。想象一下，如果我们有超过三个泛型类型，其中一些可能基于泛型，例如集合。这可能会很快变得相当繁琐，并使代码看起来比实际更复杂。
- en: 'On the other hand, using generics allows us to reuse `GenericPrinter` without
    explicitly subclassing it multiple times for each different printer representation.
    There is, however, the risk of making logical mistakes:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，使用泛型允许我们重用`GenericPrinter`，而无需为每个不同的打印机表示显式地多次子类化它。然而，存在犯逻辑错误的风险：
- en: '[PRE16]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If used as follows, there is a danger of making a mistake:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果按照以下方式使用，可能会出错：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Usage advice
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用建议
- en: The previous examples show a relatively simple comparison between the use of
    generics and abstract types. Both are useful concepts; however, it is important
    to be aware of what exactly is being done in order to use the right one for the
    situation. Here are some tips that could help in making the right decision.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子展示了泛型和抽象类型使用之间的相对简单比较。这两个都是有用的概念；然而，了解确切正在做什么对于使用正确的一个来应对情况非常重要。以下是一些可以帮助做出正确决定的提示。
- en: '**Use generics:**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用泛型：**'
- en: If you need just type instantiation; a good example is the standard collection
    classes
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只需要类型实例化；一个很好的例子是标准集合类
- en: If you are creating a family of types
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在创建一系列类型
- en: '**Use abstract types:**'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用抽象类型：**'
- en: If you want to allow people to mix in types using traits
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望允许人们使用特性混合类型
- en: If you need better readability in scenarios where both could be interchangeable
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要在两种类型可以互换的场景中提高可读性
- en: If you want to hide the type definition from the client code
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你希望从客户端代码中隐藏类型定义
- en: Polymorphism
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多态
- en: Polymorphism is something every developer who has done some object-oriented
    programming knows about.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是每个进行过一些面向对象编程的开发商都知道的东西。
- en: Polymorphism helps us to write generic code that can be reused and applied to
    a variety of types.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 多态帮助我们编写通用的代码，这些代码可以重用并应用于各种类型。
- en: It is important to know that there are different types of polymorphism out there,
    and we will be looking at them in this section.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 了解存在不同类型的多态很重要，我们将在本节中探讨它们。
- en: Subtype polymorphism
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子类型多态
- en: 'This is the polymorphism every developer knows about, and it''s related to
    overriding methods in concrete class implementations. Consider the following simple
    hierarchy:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是每个开发商都知道的多态，它与在具体类实现中重写方法相关。考虑以下简单的层次结构：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, let''s have a shopping basket of items and call `pack` for each of them:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们有一个包含物品的购物篮，并对每个物品调用`pack`：
- en: '[PRE19]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As you can see, here we can use the abstract type and just call the `pack`
    method without thinking about what exactly it is. Polymorphism will take care
    of printing the correct value. Our output will be as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这里我们可以使用抽象类型，只需调用`pack`方法，而不必考虑它确切是什么。多态将负责打印正确的值。我们的输出将如下所示：
- en: '[PRE20]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Subtype polymorphism is expressed using inheritance with the `extends` keyword.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 子类型多态使用`extends`关键字通过继承来表示。
- en: Parametric polymorphism
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数多态
- en: Parametric polymorphism in functional programming is what we showed in the previous
    section about generics. Generics are parametric polymorphism, and as we already
    saw, they allow us to define methods or data structures over any type, or a subset
    of a given type. Concrete types can then be specified at a later stage.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的参数多态是我们之前关于泛型的章节中展示的内容。泛型是参数多态，正如我们之前所看到的，它们允许我们在任何类型或给定类型的子集上定义方法或数据结构。然后可以在稍后的阶段指定具体类型。
- en: Ad hoc polymorphism
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时多态
- en: Ad hoc polymorphism is similar to parametric polymorphism; however, in this
    case, the type of arguments is important, as the concrete implementation will
    depend on it. It is resolved at compile time, unlike subtype polymorphism, which
    is done during runtime. This is somewhat similar to function overloading.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 临时多态与参数多态相似；然而，在这种情况下，参数的类型很重要，因为具体的实现将依赖于它。它是在编译时解决的，与在运行时进行的子类型多态不同。这有点类似于函数重载。
- en: 'We saw an example of it earlier in this chapter, where we created the `Adder`
    trait that can sum different types. Let''s have another one but a bit more refined
    and step by step, and we will hopefully understand how things work. Our goal is
    to have a `sum` method that can add many different kinds of types:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章前面看到了一个例子，其中我们创建了可以求和不同类型的`Adder`特质。让我们再举一个例子，但更加精细，一步一步来，我们希望理解事物是如何工作的。我们的目标是拥有一个可以添加许多不同类型的`sum`方法：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we will create a Scala object that uses this `sum` method and exposes
    it to the outside world:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个Scala对象，它使用这个`sum`方法并将其暴露给外界：
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'What we saw in the preceding code is some syntactic sugar in Scala, and `implicitly`
    says that there exists an implicit conversion from the `T` type to `Adder[T]`.
    We can now write the following program:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到的是Scala中的一些语法糖，`implicitly`表示存在从`T`类型到`Adder[T]`的隐式转换。我们现在可以编写以下程序：
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we try to compile and run this, we will run into trouble and get the following
    errors:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译并运行这个程序，我们将遇到麻烦并得到以下错误：
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This indicates that our code does not know how to implicitly convert integers
    or strings to `Adder[Int]` or `Adder[String]`. What we have to do is define these
    conversions as well as tell our program what the `sum` method will do. Our `Adder`
    object will look like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们的代码不知道如何隐式地将整数或字符串转换为`Adder[Int]`或`Adder[String]`。我们必须做的是定义这些转换，并告诉我们的程序`sum`方法将做什么。我们的`Adder`对象将如下所示：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we compile and run our application now, we will get the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在编译并运行我们的应用程序，我们将得到以下输出：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Also, if you remember from the example at the beginning of the chapter, we were
    not able to use the `sum` method on strings. As you can see here, we can provide
    different implementations, and using it with anything is not a problem as long
    as we have defined a way to convert a type to `Adder`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你记得本章开头的例子，我们无法在字符串上使用`sum`方法。正如你所看到的，我们可以提供不同的实现，只要我们定义了一种将类型转换为`Adder`的方法，使用它就不会有问题。
- en: Ad hoc polymorphism allows us to extend our code without modifying the base
    classes. This is very useful if we are using external libraries, or if we simply
    are not able to change the original code for some reason. It is really powerful
    and is evaluated in compile time, which makes sure that our program will work
    as expected. Moreover, it allows us to provide function definitions for types
    that we have no access to (`Int` and `String`, in our case).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 特设多态性允许我们在不修改基类的情况下扩展我们的代码。如果我们正在使用外部库，或者由于某种原因我们无法更改原始代码，这将非常有用。这非常强大，并且在编译时进行评估，确保我们的程序按预期工作。此外，它还允许我们为无法访问的类型（在我们的例子中是`Int`和`String`）提供函数定义。
- en: Adding functions for multiple types
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多种类型添加函数
- en: 'If we look back at the beginning of this chapter, where we made `Adder` work
    with numeric types, we will see that our last implementation of `Adder` would
    require us to define an operation separately for each different numeric type.
    Is there a way to achieve what we showed in the beginning of the chapter here
    as well? Yes, there is, and this is done as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾本章开头，我们让`Adder`与数值类型一起工作的地方，我们会看到我们的最后一个`Adder`实现将需要我们为每种不同的数值类型分别定义一个操作。有没有办法在这里实现本章开头展示的内容呢？是的，有，做法如下：
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We just defined another implicit conversion, and it will take care of the right
    things for us. Now, we can also write the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了另一个隐式转换，它将为我们处理正确的事情。现在，我们也可以编写以下代码：
- en: '[PRE28]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Ad hoc polymorphism is expressed using implicits to mixin behavior. It is the
    main building block for the **type class design pattern**, which we will look
    into later in this book.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 特设多态性使用隐式表达式来混入行为。它是**类型类设计模式**的主要构建块，我们将在本书的后面部分探讨。
- en: Self types
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自类型
- en: One of the features of good code is the separation of concerns. Developers should
    aim to make classes and their methods responsible for one and only one thing.
    This helps in testing, maintaining, and simply understanding code better. Remember—*simple
    is always better*.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀代码的一个特点是关注点的分离。开发者应该努力使类及其方法只负责一件事情。这有助于测试、维护和更好地理解代码。记住——*简单总是更好*。
- en: However, it is inevitable that when writing real software, we will need instances
    of some classes within other ones in order to achieve certain functionalities.
    In other words, once our building blocks are nicely separated, they would have
    dependencies in order to perform their functionality. What we are talking about
    here really boils down to dependency injection. Self types provide a way to handle
    these dependencies in an elegant way. In this section, we will see how to use
    them and what they are good for.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在编写真实软件时，我们需要某些类的实例在其他类中，以便实现某些功能。换句话说，一旦我们的构建块被很好地分离，它们将具有依赖关系以执行其功能。我们在这里谈论的实际上归结为依赖注入。自定义类型提供了一种优雅地处理这些依赖关系的方法。在本节中，我们将看到如何使用它们以及它们有什么好处。
- en: Using self types
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义类型
- en: 'Self types allow us to easily separate code in our applications, and then require
    it from other places. Everything gets clearer with an example, so let''s have
    a look at one. Let''s assume that we want to be able to persist information into
    a database:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型允许我们轻松地将代码在我们的应用程序中分离，然后从其他地方调用它。一切都会通过例子变得更加清晰，所以让我们看看一个例子。假设我们想要能够将信息持久化到数据库中：
- en: '[PRE29]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `persist` method will do some transformations on the data and then insert
    it in our database. Of course, our code is well-written, so the database implementations
    are separated. We have the following for our database:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`persist`方法将对数据进行一些转换，然后将其插入我们的数据库中。当然，我们的代码写得很好，所以数据库实现是分开的。对于我们的数据库，我们有以下内容：'
- en: '[PRE30]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We have a base trait and then some concrete database implementations. So, how
    do we pass our database to `Persister`? It should be able to call the `save` method
    defined in the database. Our possibilities include the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个基特质和一些具体的数据库实现。那么，我们如何将数据库传递给`Persister`呢？它应该能够调用数据库中定义的`save`方法。我们的可能性包括以下内容：
- en: Extend `Database` in `Persister`. This would, however, also make `Persister`
    an instance of `Database`, and we don't want this. We will show why later.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Persister`中扩展`Database`。然而，这将使`Persister`也成为`Database`的一个实例，我们不想这样。我们将在稍后展示原因。
- en: Have a variable for `Database` in `Persister` and use it.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Persister`中有一个`Database`变量的变量并使用它。
- en: Use self types.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义类型。
- en: 'We are trying to see how self types work here, so let''s use this approach.
    Our `Persister` interface will change to the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里试图了解自定义类型是如何工作的，所以让我们使用这种方法。我们的`Persister`接口将变为以下内容：
- en: '[PRE31]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, we have access to the methods in `Database` and can call the `save` method
    inside `Persister`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以访问`Database`中的方法，并在`Persister`内部调用`save`方法。
- en: '**Naming the self type** In the preceding code, we included our self type using
    the statement—`this: Database[T] =>`. This allows us to access the methods of
    our included types directly as if they were methods of the trait that includes
    them. Another way of doing the same here is by writing `self: Database[T] =>`
    instead. There are many examples out there that use the latter approach, which
    is useful to avoid confusion if we need to refer to `this` in some nested trait
    or class definitions. Calling the methods of the injected dependencies using this
    approach, however, would require the developer to use `self.` in order to gain
    access to the required methods.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**命名自定义类型** 在前面的代码中，我们使用以下语句包含了我们的自定义类型——`this: Database[T] =>`。这允许我们直接访问包含它们的特质的成员方法，就像它们是特质的成员方法一样。在这里做同样的事情的另一种方式是写`self:
    Database[T] =>`。有很多例子使用后者方法，这在需要在一些嵌套特质或类定义中引用`this`时可以避免混淆。然而，使用这种方法调用注入依赖项的方法时，开发人员需要使用`self.`来访问所需的方法。'
- en: 'The self type requires any class that mixes `Persister` in, to also mix `Database`
    in. Otherwise, our compilation will fail. Let''s create classes to persist to
    memory and database:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型要求任何将`Persister`混合进来的类也混合`Database`。否则，我们的编译将失败。让我们创建一些将数据持久化到内存和数据库的类：
- en: '[PRE32]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, we can use them in our application:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以在我们的应用程序中使用它们：
- en: '[PRE33]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here is the output of our program:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们程序的输出：
- en: '[PRE34]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: What self types do is different from inheritance. They require the presence
    of some code, and thus allow us to split a functionality nicely. This can make
    a huge difference in maintaining, refactoring, and understanding a program.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义类型所做的是与继承不同的。它们需要一些代码的存在，因此允许我们很好地分割功能。这可以在维护、重构和理解程序方面产生巨大的差异。
- en: Requiring multiple components
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 需要多个组件
- en: 'In real applications, we might require more than one component using a self
    type. Let''s show this in our example with a `History` trait that could potentially
    keep track of changes to roll back at some point. Ours will just do printing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用程序中，我们可能需要使用多个使用自身类型的组件。让我们通过一个`History`特性来展示这个例子，该特性可能会在某个时刻跟踪更改以进行回滚。我们的例子只是打印：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We need to use this in our `Persister` trait, and it will look like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的`Persister`特性中使用这个功能，它看起来是这样的：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Using the `with` keyword, we can add as many requirements as we like. However,
    if we just leave our code changes there, it will not compile. The reason for this
    is that we must now mix `History` in every class that uses `Persister`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`with`关键字，我们可以添加我们想要的任何要求。然而，如果我们只是留下我们的代码更改，它将无法编译。原因是现在我们必须在每个使用`Persister`的类中混合`History`：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'That''s it. If we now run our code, we will see this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。如果我们现在运行我们的代码，我们会看到这个：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Conflicting components
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 冲突的组件
- en: 'In the preceding example, we had a requirement for the `History` trait, which
    has an `add()` method. What would happen if the methods in different components
    have the same signatures and they clash? Let''s try this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有一个对`History`特性的要求，它有一个`add()`方法。如果不同组件中的方法具有相同的签名并且它们发生冲突，会发生什么？让我们尝试这样做：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We can now use this in our `Persister` trait:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在我们的`Persister`特性中使用这个功能：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Of course, we will change all the classes that mix `Persister` in:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将更改所有混合`Persister`的类：
- en: '[PRE41]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we try to compile our application, we will see that it results in a failure
    with the following messages:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试编译我们的应用程序，我们会看到它导致以下错误消息：
- en: '[PRE42]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Luckily, the error messages also contain information that tells us how we can
    fix the problem. This is absolutely the same case that we saw earlier while using
    traits, and we can provide the following fix:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，错误消息还包含信息，告诉我们如何修复问题。这与我们之前使用特性时看到的情况完全相同，我们可以提供以下修复方案：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'After running the example, we will see the following output:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 运行示例后，我们将看到以下输出：
- en: '[PRE44]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Self types and the cake design pattern
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自身类型和蛋糕设计模式
- en: What we saw in our preceding examples was a pure example of dependency injection.
    We required one component to be available in another one through self types.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们前面的例子中，我们看到的是一个纯粹的依赖注入示例。我们要求一个组件通过自身类型在另一个组件中可用。
- en: Self types are often used for dependency injection. They are the main part of
    the **cake design pattern**, which we will become familiar with later in this
    book.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 自身类型通常用于依赖注入。它们是**蛋糕设计模式**的主要部分，我们将在本书的后面部分熟悉它。
- en: The cake design pattern relies completely on self types. It encourages engineers
    to write small and simple components, which declare and use their dependencies.
    After all the components in an application are programmed, they can be instantiated
    inside a common component registry and made available to the actual application.
    One of the nice advantages of the cake design pattern is that it actually checks
    during compile time whether all the dependencies would be satisfied. We will dedicate
    a complete section on the cake design pattern later in this book, where we will
    provide more details about how the pattern can actually be wired up, what advantages
    and drawbacks it has, and so on.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 蛋糕设计模式完全依赖于自身类型。它鼓励工程师编写小型且简单的组件，这些组件声明并使用它们的依赖项。在应用程序中的所有组件都被编程之后，它们可以在一个公共组件注册表中实例化，并使它们对实际应用程序可用。蛋糕设计模式的一个很好的优点是，它实际上在编译时检查所有依赖项是否都能得到满足。我们将在本书的后面部分专门用一整节来介绍蛋糕设计模式，我们将提供更多关于如何实际连接模式、它有哪些优点和缺点等详细信息。
- en: Self types versus inheritance
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自身类型与继承
- en: In the previous section, we said that we don't want to use inheritance in order
    to get access to the `Database` methods. Why is that? If we had made `Persister`
    extend `Database`, this would mean that it would become a database itself (*is-a*
    relationship). However, this is not correct. It uses a database in order to achieve
    its functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们说我们不想使用继承来访问`Database`方法。为什么是这样？如果我们让`Persister`扩展`Database`，这意味着它将成为一个数据库本身（*is-a*关系）。然而，这是不正确的。它使用数据库来实现其功能。
- en: 'Inheritance exposes a subclass to the implementation details of its parent.
    This, however, is not always desired. According to the authors of *Design Patterns:
    Elements of Reusable Object-Oriented Software*, developers should favor object
    composition over class inheritance.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 继承将子类暴露于其父类的实现细节。然而，这并不总是我们所希望的。根据《设计模式：可复用面向对象软件元素》的作者，开发者应该优先选择对象组合而非类继承。
- en: Inheritance leaking functionality
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承泄露功能
- en: 'If we use inheritance, we would also leak functionality to subclasses that
    we do not want. Let''s look at the following code:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用继承，我们也会泄露我们不希望子类拥有的功能。让我们看看以下代码：
- en: '[PRE45]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'This could be a real-life scenario. Because this is how inheritance works,
    we would get access to `dropDatabase` in `UserService`. This is something we do
    not want, and we can fix it using self types. The DB trait stays the same. Everything
    else changes to the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个现实生活中的场景。因为这就是继承的工作方式，我们会在`UserService`中获得对`dropDatabase`的访问权限。这是我们不想看到的事情，我们可以通过使用自身类型来修复它。DB特质保持不变。其他所有内容都变为以下内容：
- en: '[PRE46]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: As the comments in the code show, in this last version of the code, we do not
    have access to the `DB` trait methods. We can only call the methods of the type
    we require, and this is exactly what we wanted to achieve.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如代码注释所示，在这最后一个版本的代码中，我们无法访问`DB`特质的函数。我们只能调用所需类型的函数，这正是我们想要实现的目标。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we familiarized ourselves with some concepts that help us to
    write better, more generic, and extendible software. We focused on abstract types,
    polymorphism, and self types in Scala.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们熟悉了一些有助于我们编写更好、更通用和可扩展的软件的概念。我们专注于Scala中的抽象类型、多态和自身类型。
- en: We looked into the differences between generics and abstract type values in
    classes, along with some examples and usage advice. Then, we introduced the different
    types of polymorphism—subtype, parametric, and ad hoc. Finally, we went through
    self types in Scala and how to use them. We showed that self types provide a good
    way to encapsulate functionality and write modular code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了类中泛型和抽象类型值的区别，并附带了一些示例和用法建议。然后，我们介绍了不同类型的多态——子类型、参数化和特定。最后，我们探讨了Scala中的自身类型及其使用方法。我们展示了自身类型提供了一种封装功能并编写模块化代码的好方法。
- en: In the following chapter, we will look into the importance of separating the
    responsibilities of software components. We will also go through aspect-oriented
    programming.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨分离软件组件责任的重要性。我们还将介绍面向方面编程。
