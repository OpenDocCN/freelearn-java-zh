- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes, Objects, and Enums
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148), we learned about methods
    in Java. After understanding why methods are useful, we learned that there are
    two parts to methods – the method definition and the method call. We saw that
    the method definition is the code that’s executed when the method is invoked via
    the method call. We discussed how method signatures enable method overloading.
    We also learned how `varargs` helps us call a method with zero or more arguments.
    Finally, we discussed Java’s call by value mechanism, where arguments that are
    passed to a method are copied in memory. Depending on the type of argument passed,
    primitive or reference, will have implications as to the effect of the changes
    made in the called method to those arguments passed from the caller method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19793_07.xhtml#_idTextAnchor148) concluded the Java fundamentals
    section of this book. The topics in that section are common across many programming
    languages, including non-**object-oriented programming** (**OOP**) languages such
    as C. [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168) starts the OOP section of
    this book.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover classes, objects, records and enums. Classes
    and objects are unique to OOP languages (such as Java); in other words, non-OOP
    languages (such as C) do not support them. Though closely related, understanding
    the difference between a class and an object is important. We will discuss the
    relationship between the class and objects of the class. To access an object,
    we must use a reference. Separating the reference from the object will prove very
    useful going forward. Instance versus class members will be discussed, as well
    as when to use either/both. This chapter will also explain the `'this'` reference
    and how it relates to the object responsible for the instance method currently
    executing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: We will also explain the access modifiers in Java. These access modifiers enable
    one of the key cornerstones in OOP, namely encapsulation. Though basic encapsulation
    can be easily achieved, properly encapsulating your class requires extra care.
    This will be covered in the Advanced encapsulation section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the object life cycle, with regard to what is happening in memory
    as your program executes, is crucial to avoiding many subtle errors. This topic
    will be explained with the aid of diagrams.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Toward the end of the chapter, given our understanding (and separation!) of
    references from the objects they refer to, we will discuss the `instanceof` keyword.
    Lastly, we will cover a variation of classes, namely `enums`, whereby the number
    of object instances is restricted.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the differences between classes and objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Contrasting instance with class members
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the `'``this'` reference
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying access modifiers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving encapsulation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mastering advanced encapsulation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into the object life cycle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining the `instanceof` keyword
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`instanceof`关键字
- en: Understanding enums
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解枚举
- en: Appreciating records
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏记录
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8)。
- en: Understanding the differences between classes and objects
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类和对象之间的区别
- en: 'As classes and objects are integral to OOP, it is vital to understand their
    differences. We will discuss the relationship between a class and its objects
    in this section. As creating objects requires the use of the `new` keyword, this
    will also be covered. Understanding constructors and what they do will also be
    examined. All of these topics are linked: objects are the in-memory representation
    of the class (template); to create an object, a constructor is used and to call
    the constructor, we use the `new` keyword. Let’s examine these in turn.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类和对象对于面向对象编程至关重要，理解它们之间的区别是至关重要的。在本节中，我们将讨论类与其对象之间的关系。由于创建对象需要使用`new`关键字，这也会被涵盖。我们还将探讨构造函数及其作用。所有这些主题都是相互关联的：对象是类的内存表示（模板）；要创建对象，使用构造函数，要调用构造函数，我们使用`new`关键字。让我们逐一检查这些内容。
- en: Classes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A class is so integral in Java that you cannot write any program without defining
    one! A class is a blueprint or template for your object. It is similar to a plan
    of a house – using a house plan, you can discuss the house all you want; however,
    you cannot go into the kitchen and make a cup of tea/coffee. The house plan is
    abstract in that regard and so is the class. The class defines fields (properties)
    and methods which operate on those fields. The fields are your data and the methods
    enable manipulation of that data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，类是如此重要，以至于你无法编写任何不定义类的程序！类是你对象的蓝图或模板。它类似于房屋的设计图——使用房屋设计图，你可以讨论房屋的所有内容；然而，你不能走进厨房泡上一杯茶/咖啡。在这一点上，房屋设计图是抽象的，类也是如此。类定义了字段（属性）和操作这些字段的方法。字段是你的数据，方法使你可以操作这些数据。
- en: Objects
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: An object is your in-memory representation of your class. If the class is your
    house plan, then the object is your built house. Now, you can go into the kitchen
    and make that cup of tea/coffee. As with houses and house plans, you can create
    many objects based on the class. These objects are known as object *instances*,
    emphasizing that each object is its own unique instance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是你对类的内存表示。如果类是你的房屋设计图，那么对象就是你的建成房屋。现在，你可以走进厨房，泡上一杯茶/咖啡。就像房屋和房屋设计图一样，你可以基于类创建许多对象。这些对象被称为对象*实例*，强调每个对象都是其独特的实例。
- en: In summary, the class is the template and the object is the in-memory representation
    of the class. You need an object (instance) if you want to execute its (instance)
    methods. So, how do we create an object? We use the `new` keyword.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，类是模板，对象是类的内存表示。如果你想执行其（实例）方法，你需要一个对象（实例）。那么，我们如何创建对象呢？我们使用`new`关键字。
- en: Getting familiar with the new keyword
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉`new`关键字
- en: 'The `new` keyword in Java enables us to create objects. The object is created
    on the heap, a special area of memory reserved for objects. A reference (similar
    to a pointer) to the object is returned. This reference enables us to manipulate
    the object; for example, to execute the instance methods. Let’s examine the code
    example shown in *Figure 8**.1*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的`new`关键字使我们能够创建对象。对象在堆上创建，堆是内存中为对象保留的特殊区域。返回对象的引用（类似于指针）。这个引用使我们能够操作对象；例如，执行实例方法。让我们来检查*图8**.1*中显示的代码示例：
- en: '![Figure 8.1 – Creating an object](img/B19793_08_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 创建对象](img/B19793_08_1.jpg)'
- en: Figure 8.1 – Creating an object
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 创建对象
- en: In the preceding figure, line 3 defines a `Person` class. It contains nothing
    at the moment; we will expand it as we progress. Line 6 is important – we are
    creating a `Person` object using the `new` keyword. Apart from the `new` keyword,
    line 6 is very similar to any method call. The `p` reference (on the stack) is
    initialized to refer to an object of type `Person` (on the heap). `Person` reference
    named `p` is referring to a `Person` object; however, going forward, that will
    rarely be the case. When “constructing” objects using the `new` keyword, the method
    that’s invoked is a special method known called a *constructor*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第3行定义了一个`Person`类。目前它没有任何内容；随着我们的进展，我们将对其进行扩展。第6行很重要——我们正在使用`new`关键字创建一个`Person`对象。除了`new`关键字外，第6行与任何方法调用非常相似。`p`引用（在栈上）被初始化为指向堆上的`Person`类型对象。名为`p`的`Person`引用正指向一个`Person`对象；然而，在前进的过程中，这种情况很少见。当使用`new`关键字“构造”对象时，被调用的方法是一个特殊的方法，称为*构造函数*。
- en: Constructors
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'A constructor is a special method that’s invoked by the `new` keyword. It has
    two distinct properties that differentiate it from other methods: it has the same
    name as the class and defines no return type, not even `void`. (Java returns the
    reference to the object in the background).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个特殊的方法，它由`new`关键字调用。它有两个独特的属性，使其与其他方法区分开来：它具有与类相同的名称，并且不定义任何返回类型，甚至不是`void`。（Java在后台返回对象的引用）。
- en: Every class contains a constructor, even if you do not code one yourself. If
    you do not code a constructor for your class, Java will synthesize (or define)
    a “default constructor” for you. The default constructor will have the same properties
    as regular constructors; namely, the same name as the class and no return type.
    However, the default constructor will not define any parameters; it will have
    the same access modifier as the class and will contain only one line of code,
    which is `super();`. We will discuss access modifiers later in this chapter and
    `super()` in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都包含一个构造函数，即使你没有自己编写。如果你没有为你的类编写构造函数，Java会为你自动生成（或定义）一个“默认构造函数”。默认构造函数将具有与常规构造函数相同的属性；即，与类相同的名称且没有返回类型。然而，默认构造函数不会定义任何参数；它将具有与类相同的访问修饰符，并且只包含一行代码，即`super();`。我们将在本章后面讨论访问修饰符，并在[*第9章*](B19793_09.xhtml#_idTextAnchor205)中讨论`super()`。
- en: Note that if you insert even one constructor, the default constructor is not
    synthesized. It’s as if the compiler says, “Okay, you have a constructor(s), you
    know what you are doing, so I won’t get involved.”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你插入了一个构造函数，默认构造函数就不会被自动生成。这就像编译器说：“好吧，你已经有了构造函数（们），你知道你在做什么，所以我不介入。”
- en: 'Now that we know when default constructors are synthesized by the compiler,
    we can see that default constructors are required for both `Person` and `PersonExample`
    in *Figure 8**.1*. *Figure 8**.2* represents the code *after* the compiler has
    inserted the default constructors:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道默认构造函数何时由编译器生成，我们就可以看到在*图8**.1*中`Person`和`PersonExample`都需要默认构造函数。*图8**.2*表示编译器插入默认构造函数后的代码：
- en: '![Figure 8.2 – Default constructors inserted](img/B19793_08_2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 插入的默认构造函数](img/B19793_08_2.jpg)'
- en: Figure 8.2 – Default constructors inserted
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 插入的默认构造函数
- en: The red rectangles in the preceding figure represent the default constructors
    inserted by the compiler. This happened to both classes because neither class
    defined any constructor at all and every class requires a constructor. The default
    constructors, in addition to having the same name as the class and not returning
    anything (not even `void`), define no parameters (lines 4 and 9) and simply call
    `super();`. As stated in the previous callout, `super()` will be discussed when
    we discuss Inheritance in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中的红色矩形表示编译器插入的默认构造函数。这发生在两个类上，因为两个类都没有定义任何构造函数，而每个类都需要一个构造函数。除了具有与类相同的名称且不返回任何内容（甚至不是`void`）之外，默认构造函数不定义任何参数（第4行和第9行），并且简单地调用`super();`。正如前一个提示中所述，`super()`将在我们讨论[*第9章*](B19793_09.xhtml#_idTextAnchor205)中的继承时进行讨论。
- en: We will discuss access modifiers in detail later but note that the access for
    the default constructors match the access for their respective classes. For example,
    `PersonExample` is a `public` class and so is its constructor (lines 8 and 9 respectively).
    The `Person` class mentions no *explicit* access modifier at all and neither does
    its constructor (lines 3 and 4 respectively).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面详细讨论访问修饰符，但请注意，默认构造函数的访问权限与它们各自类的访问权限相匹配。例如，`PersonExample` 是一个 `public`
    类，因此它的构造函数也是 `public`（分别在第8和第9行）。`Person` 类没有提及任何 *显式* 访问修饰符，其构造函数也是如此（分别在第3和第4行）。
- en: Now, you can see why `new Person();` on line 13 does not generate a compiler
    error. To be clear, there is no compiler error on line 13 because the compiler
    inserted the default constructor for the `Person` class (lines 4 to 6) and thus
    `new Person()` was able to locate the constructor and therefore compile.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到为什么第13行的 `new Person();` 不会生成编译器错误。为了清楚起见，第13行没有编译器错误，因为编译器插入了 `Person`
    类的默认构造函数（第4至6行），因此 `new Person()` 能够找到构造函数并因此编译。
- en: The default constructor for `PersonExample` (lines 9 to 11) has no material
    effect in this program. The JVM starts every program in the `main` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonExample` 的默认构造函数（第9至11行）在这个程序中没有实质性的影响。JVM 在每个程序的 `main` 方法中启动程序。'
- en: We will now move on to discuss instance members versus class members. Note that
    local variables (in a method) are neither.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向讨论实例成员与类成员的区别。请注意，局部变量（在方法中）也不是。
- en: Contrasting instance with class members
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对比实例成员与类成员
- en: 'An object can be more correctly termed an object *instance*. This is where
    *instance* members (methods/data) get their names: every object gets a copy of
    an instance member. Class members, however, are different in that there is only
    one copy per class, regardless of the number of object instances created. We’ll
    discuss both of these topics now.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象更准确地可以称为对象 *实例*。这就是 *实例* 成员（方法/数据）获得名称的地方：每个对象都会获得一个实例成员的副本。然而，类成员是不同的，因为每个类只有一个副本，无论创建了多少对象实例。我们现在将讨论这两个主题。
- en: Instance members (methods/data)
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例成员（方法/数据）
- en: 'This is more easily explained by presenting a code example first. *Figure 8**.3*
    presents a class with instance members:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点通过先展示一个代码示例更容易解释。*图8.3* 展示了一个具有实例成员的类：
- en: '![Figure 8.3 – A class with instance members](img/B19793_08_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 具有实例成员的类](img/B19793_08_3.jpg)'
- en: Figure 8.3 – A class with instance members
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 具有实例成员的类
- en: When you create an object using `new`, you are creating an object *instance*.
    Each instance gets a copy of the instance members (variables and methods). Regarding
    instance variables, we need to define where instance variables are declared and
    their resultant scope. An instance variable is defined within the class but outside
    every method coded in the class. Thus, the scope of an instance variable is the
    class itself; meaning, every instance method in the class can access the instance
    variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `new` 创建一个对象时，你正在创建一个对象 *实例*。每个实例都获得实例成员（变量和方法）的副本。关于实例变量，我们需要定义实例变量在哪里声明以及它们的范围。实例变量是在类内部定义的，但不在类中编写的每个方法之外。因此，实例变量的范围是类本身；这意味着，类中的每个实例方法都可以访问实例变量。
- en: 'Now let us discuss the code example. In the preceding figure, the `Person`
    class defines both instance variables and instance methods. As the instance variables
    are declared outside every method, they have the scope of the class. The fact
    that the instance variables are marked `private` and the instance methods are
    marked `public` will be explained later in this chapter. The constructor is as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论代码示例。在前面的图中，`Person` 类定义了实例变量和实例方法。由于实例变量是在每个方法外部声明的，因此它们的范围是类级别的。实例变量被标记为
    `private` 以及实例方法被标记为 `public` 的原因将在本章后面解释。构造函数如下：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This constructor enables us to pass in a `String` and initialize the instance
    variable based on that `String`. For example, when we instantiate an object as
    follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数使我们能够传入一个 `String` 并根据该 `String` 初始化实例变量。例如，当我们按照以下方式实例化一个对象时：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: we are passing `"Maaike"` into the constructor, so the `name` instance variable
    in the object referred to by `p1` refers to `"Maaike"`. The constructor is also
    keeping a count of the number of objects that are created by incrementing `count`
    each time the constructor is invoked. Note that no default `Person` constructor
    was inserted by the compiler in this example as a constructor was already coded
    in the class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`"Maaike"`传递给构造函数，因此`p1`引用的对象中的`name`实例变量引用了`"Maaike"`。构造函数还通过每次调用构造函数时增加`count`来记录创建的对象数量。请注意，在这个例子中，编译器没有插入默认的`Person`构造函数，因为类中已经编写了构造函数。
- en: 'We also invoke the `getName()` instance method using the `p1` and `p2` references
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`p1`和`p2`引用调用了`getName()`实例方法，如下所示：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This syntax of `refName.instanceMethod()` is known as *dot notation*. As per
    the comments in the code, `"Maaike"` and `"Sean"` are output to the screen (in
    that order). *Figure 8**.4* shows the in-memory representation of the code after
    we have created both objects, referenced by `p1` and `p2` respectively:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`refName.instanceMethod()`的语法称为*点表示法*。根据代码中的注释，`"Maaike"`和`"Sean"`将按顺序输出到屏幕上。（*图8**.4*）显示了在创建了两个对象，分别由`p1`和`p2`引用后，代码在内存中的表示：
- en: '![Figure 8.4 – In-memory representation of Figure 8.3 (start of line 27)](img/B19793_08_4.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 图8.3的内存表示（行27开始）](img/B19793_08_4.jpg)'
- en: Figure 8.4 – In-memory representation of Figure 8.3 (start of line 27)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 图8.3的内存表示（行27开始）
- en: As the preceding figure shows, we have two references on the stack, namely `p1`
    and `p2`. `p1` refers to the first `Person` object on the heap – that is, the
    object that was created on line 23\. The instance variable values of `p1` (its
    “state”) are `"Maaike"` and `1` for `name` and `count`, respectively. As strings
    are objects, `name` is a reference to another object, a `String` object, which
    has a value of `"Maaike"`. Similarly, the `p2` reference refers to the object
    that was created on line 24\. As can be seen from the diagram, the instance variable
    values of `p2` are `"Sean"` and `1` for `name` and `count`, respectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有堆栈上的两个引用，即`p1`和`p2`。`p1`引用堆上的第一个`Person`对象——即第23行创建的对象。`p1`的实例变量值（其“状态”）是`name`的`"Maaike"`和`count`的`1`。由于字符串是对象，`name`是一个引用另一个对象的引用，即一个值为`"Maaike"`的`String`对象。同样，`p2`引用指向第24行创建的对象。从图中可以看出，`p2`的实例变量值是`name`的`"Sean"`和`count`的`1`。
- en: Note that each `Person` object *instance* on the heap has a copy of the *instance*
    variables. That is why they are called instance variables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，堆上的每个`Person`对象*实例*都有一个*实例*变量的副本。这就是为什么它们被称为实例变量。
- en: 'Lines 27 and 28 change the values of the `name` instance variables to `"Maaike
    van Putten"` and `"Sean Kennedy"` for `p1` and `p2`, respectively. *Figure 8**.5*
    shows these changes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第27和28行将`name`实例变量的值分别更改为`"Maaike van Putten"`和`"Sean Kennedy"`，对应于`p1`和`p2`。(*图8**.5*)显示了这些更改：
- en: '![Figure 8.5 – In-memory representation of Figure 8.3 (start of line 29)](img/B19793_08_5.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 图8.3的内存表示（行29开始）](img/B19793_08_5.jpg)'
- en: Figure 8.5 – In-memory representation of Figure 8.3 (start of line 29)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 图8.3的内存表示（行29开始）
- en: 'This figure shows that the two `String` objects have been changed: `p1`’s instance
    variable `name` refers to `"Maaike van Putten"` and `p2`’s instance variable `name`
    refers to `"Sean Kennedy"`. Consequently, lines 29 to 30 output `"Maaike van Putten"`
    and `"Sean` `Kennedy"`, respectively.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示，两个`String`对象已被更改：`p1`的实例变量`name`引用了`"Maaike van Putten"`，而`p2`的实例变量`name`引用了`"Sean
    Kennedy"`。因此，第29到30行分别输出了`"Maaike van Putten"`和`"Sean Kennedy"`。
- en: String immutability
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不可变性
- en: Strings are immutable objects. This means that `String` objects, once created,
    cannot be changed. Ever. It may look like they have changed, as in the effect
    is created of a change, but a completely new object has been created and the original
    is left untouched. We will revisit `String` immutability in greater detail in
    [*Chapter 12*](B19793_12.xhtml#_idTextAnchor293).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变对象。这意味着一旦创建了`String`对象，就不能更改。永远不能。虽然看起来它们已经改变了，因为产生了变化的效果，但实际上已经创建了一个全新的对象，而原始对象保持未变。我们将在[*第12章*](B19793_12.xhtml#_idTextAnchor293)中更详细地回顾`String`不可变性。
- en: So, the original `String` objects, `"Sean"` and `"Maaike"`, are still on the
    heap taking up space. They are of no use because, as we have no references to
    them, we have no way to get to them. Remember, the `name` instance variables for
    both `p1` and `p2` refer to the newly created `String` objects containing `"Maaike
    van Putten"` and `"Sean` `Kennedy"`, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原始的`String`对象，`"Sean"`和`"Maaike"`，仍然在堆上占用空间。它们没有用处，因为我们没有对这些对象的引用，所以我们无法访问它们。记住，`p1`和`p2`的`name`实例变量分别引用了新创建的包含`"Maaike
    van Putten"`和`"Sean Kennedy"`的`String`对象。
- en: So, what happens to these no-longer-used objects? They are “garbage collected.”
    We will discuss this soon but for now, just know that the JVM runs a process called
    a garbage collector in the background to tidy up (reclaim) all the objects that
    can no longer be reached. We have no control over when this process runs but the
    fact that there is a garbage collector saves us from having to tidy up after ourselves
    (whereas in other OOP languages such as C++, you have to!).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些不再使用的对象会怎样呢？它们会被“垃圾回收”。我们很快就会讨论这个问题，但首先，只需知道JVM在后台运行一个名为垃圾回收器的进程来整理（回收）所有无法访问的对象。我们无法控制这个进程何时运行，但有一个垃圾回收器可以让我们免于自己清理（而与其他OOP语言如C++不同，你必须这样做！）。
- en: The code in *Figure 8**.3* has an issue – `count` is 1 and it should be 2\.
    Instance variables that are integers are initialized to `0` by default. In each
    of the constructor calls, we increment `count` from `0` to `1`. We would like
    the first constructor call to increment `count` from `0` to `1` and the second
    constructor call to increment `count` from `1` to `2`. This is where class members
    come in.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.3* 中的代码存在问题 – `count` 的值为1，而它应该是2。实例变量默认初始化为`0`。在每次构造函数调用中，我们将`count`从`0`增加到`1`。我们希望第一次构造函数调用将`count`从`0`增加到`1`，而第二次构造函数调用将`count`从`1`增加到`2`。这就是类成员发挥作用的地方。'
- en: Class members (methods/data)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类成员（方法/数据）
- en: To mark a field and/or method as a class member, as opposed to an instance member,
    you can insert the `static` keyword into the declaration of the member. Class
    members are shared by all instances of the class. This means that you do not have
    to create an object instance to access the `static` members of the class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字段和/或方法标记为类成员，而不是实例成员，可以在成员的声明中插入`static`关键字。类成员由类的所有实例共享。这意味着你不需要创建对象实例来访问类的`static`成员。
- en: The syntax for accessing a `static` member is different from accessing an instance
    member. Rather than use the reference, the class name is used, as in `className.staticMember`.
    This emphasizes the class nature of the member being accessed. For example, the
    JVM starts the program in *Figure 8**.3* with `PersonExample.main()`. This is
    how the JVM starts every program as it saves on constructing an object and its
    resulting memory footprint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`static`成员的语法与访问实例成员的语法不同。而不是使用引用，使用类名，如`className.staticMember`。这强调了被访问成员的类性质。例如，JVM使用`PersonExample.main()`在*图8.3*中启动程序。这就是JVM以节省构建对象及其内存占用为代价启动每个程序的方式。
- en: 'Let’s get back to our problem with `count` (which is 1 instead of 2). *Figure
    8**.6* represents the changes that must be made to fix this issue:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`count`问题（它的值应该是2而不是1）。*图8.6*表示必须进行的更改以解决这个问题：
- en: '![Figure 8.6 – Making “count” static](img/B19793_08_6.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 使“count”静态化](img/B19793_08_6.jpg)'
- en: Figure 8.6 – Making “count” static
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 使“count”静态化
- en: Contrasting the code in *Figure 8**.6* with the code in *Figure 8**.3*, we can
    see that `count` is declared `static` (line 5). Thus, there is only one copy of
    *count*, which is shared across all instances of `Person`. Thus, `p1` and `p2`
    are looking at the same *count*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将*图8.6*中的代码与*图8.3*中的代码进行对比，我们可以看到`count`被声明为`static`（第5行）。因此，只有一个`count`的副本，它在所有`Person`实例之间共享。因此，`p1`和`p2`正在查看相同的`count`。
- en: In the constructor (line 9), while not necessary, we use the correct syntax
    to emphasize the `static` nature of `count`. Similarly, as `getCount` (line 17)
    is simply returning a `static` member, we marked it as `static`. In addition,
    we used the `Person.count` static syntax (line 18). Lastly, line 25 accesses the
    `static` method using the correct syntax, `Person.getCount`, to retrieve the `private`
    class variable, `count`. We can see that it outputs `2`, which is correct. Comparing
    the other differences in code, some of the extra code in `main` (*Figure 8**.3*)
    has been removed to help us focus on what we are discussing here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数（第 9 行）中，虽然不是必需的，但我们使用正确的语法来强调 `count` 的 `static` 特性。同样，由于 `getCount`（第
    17 行）只是返回一个 `static` 成员，我们将其标记为 `static`。此外，我们使用了 `Person.count` 静态语法（第 18 行）。最后，第
    25 行使用正确的语法 `Person.getCount` 访问了 `private` 类变量 `count`。我们可以看到它输出了 `2`，这是正确的。比较代码中的其他差异，`main`（*图
    8**.3*）中的一些额外代码已被删除，以帮助我们关注这里讨论的内容。
- en: Instance to static but not vice versa
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实例到静态，但反之则不行
- en: If you are in an instance method, you can access a `static` member but not vice
    versa. We will discuss the reason why when we explain the `this` reference. This
    means that, in *Figure 8**.6*, you could use the `p1` reference to access the
    `getCount` method (line 25). As such, `p1.getCount()` is valid but this is a *poor*
    programming practice as it conveys the impression that `getCount` is an instance
    method when it is a `static` method - use `Person.getCount()` as per the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个实例方法中，您可以访问一个 `static` 成员，但反之则不行。当我们解释 `this` 引用时，我们将讨论为什么。这意味着，在 *图 8**.6*
    中，您可以使用 `p1` 引用来访问 `getCount` 方法（第 25 行）。因此，`p1.getCount()` 是有效的，但这是一种 *较差* 的编程实践，因为它给人一种
    `getCount` 是实例方法的印象，而实际上它是一个 `static` 方法 - 按照代码使用 `Person.getCount()`。
- en: '*Figure 8**.7* shows the in-memory representation of the code in *Figure 8**.6*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8**.7* 显示了 *图 8**.6* 代码的内存表示：'
- en: '![Figure 8.7 – In-memory representation of the code in Figure 8.6](img/B19793_08_7.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 图 8.6 代码的内存表示](img/B19793_08_7.jpg)'
- en: Figure 8.7 – In-memory representation of the code in Figure 8.6
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 图 8.6 代码的内存表示
- en: As can be seen in the bottom-right corner of the preceding figure, the `static`/`class`
    members of the `Person` class are stored separately from the instances themselves.
    There is now only one copy of `count` and it is shared between `p1` and `p2`.
    Thus, the `count` value of `2` is correct.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个图例的右下角所示，`Person` 类的 `static`/`class` 成员与实例本身存储在分开的地方。现在只有一个 `count` 的副本，它被
    `p1` 和 `p2` 共享。因此，`count` 的值为 `2` 是正确的。
- en: Default values for class and instance variables
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类和实例变量的默认值
- en: Instance variables are initialized to default values every time a class is `new`’ed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个新类时，实例变量都会初始化为默认值。
- en: Class variables are initialized to default values the very first time a class
    is loaded. This could occur when using `new` or when referring to a class member
    (using the class syntax).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量在类首次加载时初始化为默认值。这可能在使用 `new` 或引用类成员（使用类语法）时发生。
- en: 'The default values for class and instance variables are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类和实例变量的默认值如下：
- en: '| **Type** | **Default value** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **默认值** |'
- en: '| `byte, short,` and `int` | `0` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `byte, short,` 和 `int` | `0` |'
- en: '| `long` | `0L` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `0L` |'
- en: '| `float` | `0.0f` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `0.0f` |'
- en: '| `double` | `0.0d` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `0.0d` |'
- en: '| `char` | ‘`\u0000`’ (Unicode zero) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `char` | ‘`\u0000`’ (Unicode 零) |'
- en: '| `String` (or any reference to an object) | `null` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `String` (或任何对象的引用) | `null` |'
- en: '| `boolean` | `false` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `false` |'
- en: Table 8.1 – Default values for class and instance variables
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – 类和实例变量的默认值
- en: In a previous callout, we highlighted that you can access class members from
    an instance method but not vice versa. Let’s delve into that now.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的提示中，我们强调了您可以从实例方法中访问类成员，但反之则不行。现在让我们深入探讨这一点。
- en: Exploring the “this” reference
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索“this”引用
- en: When you call an instance method, the compiler secretly passes into the method
    a copy of the object reference that invoked the method. This reference is available
    to the instance method as the `this` reference.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用一个实例方法时，编译器会秘密地将调用该方法的对象引用的副本传递到方法中。这个引用作为 `this` 引用对实例方法可用。
- en: Class methods do not get a `this` reference. This is why, if you are in a `static`
    method (context) and you try to access an instance member directly (without an
    object reference), you will get a compiler error. In effect, every instance member
    requires an object reference when accessing it. This makes sense because instance
    members are instance-specific and therefore, you need an instance (reference)
    to say, *“I want to access this particular instance/object as opposed to that*
    *particular one.”*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法不会获得 `this` 引用。这就是为什么如果你在一个 `static` 方法（上下文）中尝试直接访问实例成员（没有对象引用），你会得到编译器错误。实际上，每个实例成员在访问时都需要一个对象引用。这很有意义，因为实例成员是实例特定的，因此你需要一个实例（引用）来说明，“我想访问这个特定的实例/对象，而不是那个特定的对象。”
- en: 'Let’s refactor the code in *Figure 8**.3* so that the `Person` class uses the
    `this` reference explicitly. In addition, all references to the incorrectly working
    `count` instance variable have been removed so that we can focus on the `this`
    reference. *Figure 8**.8* includes the refactored `Person` class (the `PersonExample`
    class remains untouched):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构 *图 8.3* 中的代码，以便 `Person` 类显式地使用 `this` 引用。此外，所有对不正确工作的 `count` 实例变量的引用都已删除，以便我们可以专注于
    `this` 引用。*图 8.8* 包含重构后的 `Person` 类（`PersonExample` 类保持不变）：
- en: '![Figure 8.8 – Using the “this” reference](img/B19793_08_8.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 使用“this”引用](img/B19793_08_8.jpg)'
- en: Figure 8.8 – Using the “this” reference
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 使用“this”引用
- en: 'In the preceding figure, lines 7, 11, and 15 are commented out and replaced
    by lines 8, 12, and 16, respectively. Let’s contrast both the commented-out line
    7 and the new line 8 more closely:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第 7、11 和 15 行被注释掉，分别替换为第 8、12 和 16 行。让我们更仔细地对比一下被注释掉的 7 行和新的 8 行：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Firstly, assume line 7 is uncommented. How does line 7 reconcile its variables?
    Initially, the compiler checks the current scope (the constructor block of code)
    and reconciles `aName` as a parameter to the constructor. However, the compiler
    still has not reconciled `name`, so it checks the next outer scope, the class
    scope, where the instance/class variables are defined. Here, it finds an instance
    variable called `name`, and therefore line 7 compiles.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设第 7 行被取消注释。第 7 行是如何协调其变量的？最初，编译器检查当前作用域（代码的构造块），并将 `aName` 协调为构造函数的参数。然而，编译器还没有协调
    `name`，因此它检查下一个外部作用域，即类作用域，其中定义了实例/类变量。在这里，它找到一个名为 `name` 的实例变量，因此第 7 行可以编译。
- en: Line 8 operates somewhat differently. Yes, it reconciles `aName` similarly but
    now, it comes across `this.name` (as opposed to `name`). Upon seeing *this*, the
    compiler immediately checks the instance variables that have been declared. It
    finds an instance variable called `name`, and therefore line 8 compiles. Lines
    7 and 8 are, in effect, the same.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 行的操作有些不同。是的，它以类似的方式协调 `aName`，但现在，它遇到了 `this.name`（而不是 `name`）。看到 *this*
    后，编译器立即检查已声明的实例变量。它找到一个名为 `name` 的实例变量，因此第 8 行可以编译。第 7 行和第 8 行实际上是相同的。
- en: Line 16 is the same as line 8 as we used the same parameter identifier, `aName`.
    Line 12 is simply returning the `name` instance variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 行与第 8 行相同，因为我们使用了相同的参数标识符，`aName`。第 12 行只是简单地返回 `name` 实例变量。
- en: So, that covers how to use `this` in a class, but how do we associate the instance
    with `this`?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这涵盖了如何在类中使用 `this`，但我们是怎样将实例与 `this` 关联起来的呢？
- en: Associating an instance with the “this” reference
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实例与“this”引用关联
- en: 'Thankfully, the compiler does this automatically. As stated previously, the
    `this` reference is only passed (in secret) to instance methods and it refers
    to the instance that is invoking the method at that time. For example, when executing
    `p1.getName()`, the `this` reference in `getName` refers to `p1`, whereas when
    executing `p2.getName()`, the `this` reference in `getName` refers to `p2`. Thus,
    the `this` reference varies, depending on the instance that invokes the method.
    *Figure 8**.9* represents the dynamic nature of the `this` reference in action:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编译器会自动完成这项工作。正如之前所述，`this` 引用仅（秘密地）传递给实例方法，并且它指向当时调用该方法的实例。例如，当执行 `p1.getName()`
    时，`getName` 中的 `this` 引用指向 `p1`，而当执行 `p2.getName()` 时，`getName` 中的 `this` 引用指向
    `p2`。因此，`this` 引用会根据调用方法的实例而变化。*图 8.9* 表示了 `this` 引用动态特性的实际应用：
- en: '![Figure 8.9 – The dynamic nature of the “this” reference](img/B19793_08_9.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – “this”引用的动态特性](img/B19793_08_9.jpg)'
- en: Figure 8.9 – The dynamic nature of the “this” reference
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – “this”引用的动态特性
- en: This figure represents the in-memory representation of the code in *Figure 8**.8*
    as we execute line 12 from the method call on line 24\. As `getName` on line 24
    is invoked on `p2` – in other words, `p2.getName();` – the `this` reference inside
    `getName` refers to the same object that `p2` is referring to. This is represented
    by the solid line from the `this` reference referring to the same object that
    `p2` is referring to.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: The dashed line represents what the `this` reference was referring to on line
    12, from the method call on line 23, namely `p1`. Thus, the `this` reference is
    dynamically referring to the instances referred to by `p1` or `p2`, depending
    on which invoked the instance method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the code in *Figure 8**.8*, the `this` reference was not needed.
    Let’s examine a situation where the `this` reference is needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Shadowing or hiding an instance variable
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Shadowing an instance variable occurs when a variable has the same identifier
    as the instance variable. *Figure 8**.10* presents code where this occurs so that
    we can observe the issue it creates:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Shadowing an instance variable](img/B19793_08_10.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Shadowing an instance variable
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the constructor has a logical issue; in other words,
    the code compiles but the code is not working as expected. Line 7 is the issue.
    Remember that, if a variable is not qualified with `this`, the current scope is
    checked to see if the variable is declared there. On line 6, we have declared
    a constructor parameter that uses the `name` identifier, which is the same identifier
    as the instance variable on line 4\. Thus, line 7 is essentially assigning the
    local variable to itself and the instance variable remains untouched. As the instance
    variable is a `String` type, its default value is `null`. As a result, `null`
    is output on line 19 instead of `"Maaike"`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'To fix this issue, we have two options. The first option is to use a different
    identifier for the constructor parameter and use that new identifier. This is
    what `setName` does (lines 12-13): a method parameter called `aName` is used that
    does not shadow the `name` instance identifier. The second option is to use the
    `this` reference to specify that the variable being initialized is an instance
    variable. *Figure 8**.11* shows this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Using “this” to fix the shadowing issue](img/B19793_08_11.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Using “this” to fix the shadowing issue
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, line 7 is important: `this.name` refers to the `name` instance
    variable, while `name`, on its own, refers to the method parameter. Thus, shadowing
    has been removed and line 19 now outputs `"Maaike"` as expected.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that only non-static (instance) methods receive the `this` reference.
    Let’s examine how this issue can affect us and how to resolve it. *Figure 8**.12*
    presents code where we are in a `static` context (method) and are trying to directly
    access an instance variable:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Accessing instance variables from a “static” context](img/B19793_08_12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Accessing instance variables from a “static” context
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have an instance variable called `x` (line 4), an
    instance method called `m` (line 5), and a `static` method called `main` (lines
    6 –19). As we know, `static` methods such as `main`, do not get the `this` reference
    automatically (as they are class methods as opposed to instance methods).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: There are compiler errors on lines 9, 10, 11, and 12\. When you access an instance
    member directly, as on lines 9 and 11, the compiler inserts `this` before the
    member. In other words, by the time the compiler is finished with lines 9 and
    11, internally, they look the same as lines 10 and 12\. Consequently, as `main`
    does not have a `this` reference, the compiler complains about lines 9, 10, 11
    and 12.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Lines 15-18 encapsulate how to resolve this issue. When you’re in a `static`
    context and you want to access an instance member (variable or method), you need
    to create an object instance to refer to the instance member. Therefore, on line
    15, we create an (object) instance of the class containing the instance member,
    namely `PersonExample`, and store the reference in an identifier, `pe`. Now that
    we have an instance, we can access the instance members, which we do on lines
    16, 17 and 18\. Line 16 successfully changes `x` from (its default value of) 0
    to 999\. This is what is output on line 18\. Line 17 shows that access to `m`
    is not an issue either. Note that you must comment out lines 9-12 before the code
    will compile and run.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Throughout these examples, we have used the `private` and `public` access modifiers.
    Let’s discuss these in more detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Applying access modifiers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the cornerstones of OOP is the principle of *encapsulation* (data abstraction).
    Encapsulation can be achieved using access modifiers. Before we discuss encapsulation,
    we must understand the access modifiers themselves.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Access modifiers determine where a class, field, or method is visible and therefore
    available for use. The level you are annotating at, determines the available access
    modifiers:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '`public` or package-private (no keyword)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private`, package-private, `protected`, and `public`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss these in turn.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: private
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A member marked as `private` is accessible within its own class only. In other
    words, the block scope of the class defines the boundary. When in a class (scope),
    you cannot access the `private` members of another class, even if you have an
    object reference to the class containing the `private` member.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Package-private
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no special keyword for `package-private`. If a type (class, interface,
    record, or enum) has no access modifier then `package-private` is applied. Types
    that are `package-private` are only visible within the same package. Recall that
    a package is simply a named group of related types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: The `Person` class (line 3) in *Figure 8**.11* is a `package-private` class,
    meaning `Person` cannot be imported into another package. In addition, the `Person`
    constructor (line 6) is package-private, meaning that you cannot create an object
    of the `Person` type from within a different package.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'At a **member** level, there are a few exceptions to the preceding text that
    you need to be aware of when you omit the access modifier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Class/record members are, as above, `package-private` by default.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interface members are `public` by default.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enum constants (members) are `public` `static` and `final` by default. Enum
    constructors are `private` by default. We will discuss enums later in the chapter.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default package
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: The default package is also known as the package with no name or the unnamed
    package. Types that have no explicit package statement at the top of the file
    are put into this package. This is the package where the `Person` and `PersonExample`
    classes from *Figure 8**.11* are placed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: The implications of this are that, given the package has no name, if we are
    in a different (named) package, we have no way of importing `Person` and `PersonExample`.
    The fact that `PersonExample` is `public` (line 16) makes no difference. Therefore,
    only other types in the same (default) package can access them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: protected
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A member marked as `protected` means that it’s visible within its own package
    (as with package-private) but also visible to subclasses outside of the package.
    We will discuss subclasses and `protected` in more detail when we cover inheritance
    in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: public
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A type or member marked as `public` is visible everywhere. Thus, no boundaries
    apply.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 8.2* summarizes the access modifiers and their visibility:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.2 – Access modifiers and their visibility](img/B19793_08_Table_02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
- en: Table 8.2 – Access modifiers and their visibility
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine *Table 8.2* horizontally. Only the class has access to members
    marked as `private`. If a class or member has no access modifier (package-private),
    then that class or member is only visible within the class and the package. If
    the member is marked as `protected`, then the member is visible to the class,
    package, and subclasses of that class, regardless of the package. Finally, if
    a class or member is marked as `public`, then the class or member is visible everywhere.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'To further help explain *Table 8.2*, let’s diagram an example suite of classes
    and their associated packages and draw up another visibility table specifically
    for it. *Figure 8**.13* shows this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Sample example access modifiers diagram](img/B19793_08_13.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Sample example access modifiers diagram
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, the `Dog` class is in bold and underlined because the following
    table, *Table 8.3*, represents the visibility of *its* members. For example, when
    reading the `private` row, assume that we have marked a member in `Dog` as `private`
    and are determining its visibility in the other classes. Let’s examine *Table
    8.3*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 8.3 – Visibility when modifiers are applied to a Dog member](img/B19793_08_Table_03.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
- en: Table 8.3 – Visibility when modifiers are applied to a Dog member
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if a `Dog` member is `private`, only `Dog` can see it. If the `Dog` member
    is package-private, only `Dog` and `Cat` can see it. If the `Dog` member is `protected`,
    `Dog` and `Cat` can see it. Lastly, if the `Dog` member is `public`, every class
    can see it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: (*) We will complete this table when revisiting `protected` in the inheritance
    chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: How do access levels affect you?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Access levels will affect you in two ways. Firstly, you could be using an external
    class (from the Java API, for example) and want to know if you can use that class
    and/or its members in your code. Secondly, when writing a class, you will want
    to decide the access level each class and member will have. A good rule of thumb
    is to keep your members as `private` as possible to avoid misuse. Additionally,
    avoid `public` fields unless they are constants. We will discuss this further
    when we discuss encapsulation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at these access modifiers in code. In particular, we will focus on
    the package and learn how to create one and how access is affected by its boundary.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: packages
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that the fully qualified type name includes the package name. *A package
    defines a namespace*. For example, in *Figure 8**.13*, the `Dog` class in the
    `ch8.animals` package is fully qualified as `ch8.animals.Dog`. Therefore, a `Dog`
    class in a package named `kennel` would have a qualified name of `kennel.Dog`;
    which is completely different to `ch8.animals.Dog`. Thus, Java can distinguish
    between the two `Dog` types and no name collisions occur. As we shall see, the
    package structure is also used as a directory structure for your java files. Oracle
    gives very good guidelines (see [https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html))
    on how to name your packages so that your types do not conflict with someone else’s.
    Package names are written in all lowercase letters to differentiate them from
    type names. Following that, companies should use reverse internet domain names
    to begin their package names. For example, if you work at a company called `somecompany.com`
    and you are creating a package called `somepackage`, then the full package name
    should be `com.somecompany.somepackage`. Within a company, naming can then follow
    company conventions, such as including the region: `com.somecompany.region.somepackage`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine the packages from *Figure 8**.13*. We will start with `ch8.animals`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – The “ch8.animals” package from Figure 8.13](img/B19793_08_14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – The “ch8.animals” package from Figure 8.13
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, note that, for simplicity, we have grouped the two classes
    in the package into one Java file. This file is called `Dog.java` (as the `public`
    class is `Dog`). The first line is important: `package ch8.animals` states that
    the types (classes and so forth), that are defined here, go into this package.
    In addition, the file Dog.java will be put into a folder on the hard disk named
    `ch8\animals`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 4 defines a `private` instance variable called `dogName`.
    This is accessible within the class only (as per lines 6 and 9) but not outside
    the class (as per line 18).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Line 5 defines a `protected` instance variable called `age` which we can access
    from another class within the package (line 19). Line 12 defines a package-private
    method called `pkgPrivate()` and line 20 shows that we can access it from another
    class in the same package. Note also that the `Cat` class and its constructor
    are both package-private (lines 14 and 15, respectively).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.15* shows the other package, `ch8.farm`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – The “ch8.farm” package from Figure 8.13](img/B19793_08_15.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – The “ch8.farm” package from Figure 8.13
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Again, note that line 1 states the package name – this is the `ch8.farm` package.
    The filename is `Pig.java` (as the `public` class is `Pig`) and the file will
    be put into a folder on the hard disk named `ch\farm`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Note the use of the fully qualified names when importing (lines 3 and 4). As
    we want access to the `Dog` class which resides in a separate package, we must
    import it. There is no issue importing `Dog` since it is `public`. However, we
    are unable to import `Cat` as `Cat` is package-private (and we are in a different
    package).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 8 demonstrates that `Pig` can create a `Dog` object. Note that there are
    two access points here: the `Dog` class is `public` (so we can `import` it); and
    the `Dog` constructor is also `public` (so we can create an instance of `Dog`
    from code in a different package). This is why the access modifiers for the class
    and constructors should match. Line 9 shows that, when we are in a different package,
    we do not have access to package-private members from another package.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand access modifiers, we are in a position to discuss encapsulation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As previously stated, encapsulation is a key concept in OOP. The principle here
    is that you protect the data in your class and ensure that the data can only be
    manipulated (retrieved and/or changed) via your code. In other words, you have
    control over how external classes interact with your internal state (data). So,
    how do we do this?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Achieving encapsulation
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basic encapsulation is very easy to achieve. You simply mark your data as `private`
    and manipulate the data via `public` methods. Thus, external classes cannot access
    the data directly (as it is `private`); these external classes must go through
    your `public` methods to retrieve or change the data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'These `public` methods make up the class’s "interface"; in other words, how
    you interact with the class. This “interface” (group of `public` methods) is very
    different from and not to be confused with the `interface` language construct
    ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249)). *Figure 8**.16* presents a
    code example to help us further develop this topic:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Basic encapsulation in action](img/B19793_08_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 8.16 – Basic encapsulation in action
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the `Adult` class has two `private` instance variables,
    namely `name` and `age` (lines 4 and 5, respectively). Thus, these instance variables
    only have access within the `Adult` block of code. Note that even having an `Adult`
    object reference cannot bypass this access rule – the compiler error on (the commented
    out) line 29 demonstrates this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: public class name and filename relationship
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: In Java, the name of the `public` class must match the filename. In *Figure
    8**.16*, the `public` class is `BasicEncapsulation`. This means that the filename
    must be named `BasicEncapsulation.java`, which it is. This rule implies that you
    cannot have two `public` classes in the same file – that is why the `Adult` class
    is not `public`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: What if we were in a different package and we wanted to create an `Adult` object,
    as defined in *Figure 8**.16*? This is an issue because `Adult` is package-private
    (line 3). To fix this issue, we need to make the `Adult` class `public` so that
    we can `import` it when in a different package. This means that we need to move
    the `Adult` class into a separate file, named `Adult.java`. In addition, both
    `Adult` and its constructor would need to be `public`. Why? Well, when we’re in
    a different package, the class being `public` enables us to `import` the class
    and the constructor being `public` enables us to create objects of the `Adult`
    type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: The `Adult` constructor (line 7) has no access modifier and is therefore package-private.
    Thus, only classes within the same package can invoke this constructor. In other
    words, only classes in the `ch8` package (line 1) can create `Adult` objects.
    As `BasicEncapsulation` is also in `ch8`, the object creation on line 26 is fine.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the `Adult` class (lines 11-20) provides the getter/setter method
    pairs for manipulating the object state (the instance variables). These getter/setter
    methods are also known as accessor/mutator methods, respectively. There is usually
    a pair for each instance variable and they follow this format (note that this
    is just an example):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After creating the `Adult` object on line 26 in *Figure 8**.16*, we output the
    object state using the `public` accessor methods, `getName` and `getAge` (lines
    27-28). As these accessor methods are `public`, these methods are available to
    any class in any package. Given that `'John'` and `20` are output, we know our
    object was created correctly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that we are the developers of the `Adult` class and require an
    adult to be 18 years or older. In addition, we will assume that the developer
    of the `BasicEncapsulation` class is unknown to us. Line 29 demonstrates that
    as our `Adult` data is `private`, it is protected from direct external corruption.
    This is exactly what encapsulation provides; it is its raison d’être!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 30 demonstrates that the object’s state can still be corrupted. However,
    the corruption that’s done via the set/mutator method on line 30 is very different
    from the direct corruption on line 29\. As the author of the `Adult` class, we
    can control and therefore fix the corruption error in our `set` methods. The issue
    with our `set` (mutator) method is replicated in the constructor. *Figure 8**.17*
    addresses this (internal) corruption issue in both the constructor and mutator
    methods:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Ensuring “age” is at least 18](img/B19793_08_17.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: Figure 8.17 – Ensuring “age” is at least 18
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: As `BasicEncapsulation` remains unchanged, it is not included in the preceding
    figure. Note that a new `isAgeOk` method has been introduced (lines 27-29). This
    method takes in an `int` parameter `age` and checks to see if it is `>= 18`. If
    so, the method returns `true`; otherwise, it returns `false`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: The `isAgeOk` method is invoked from the `setAge` mutator method (line 21).
    As the constructor calls `setAge` (line 8), it also avails of the age check logic.
    If an invalid age is passed into the constructor or `setAge`, an error value of
    –1 is set. Note that there are better ways to do this, but for now this is fine.
    When we run the program now, since the `age` value that is being passed into `setAge`
    is -99 (`john.setAge(-99)`), the instance variable `age` is set to the error value
    of –1.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: That covers basic encapsulation. We will now discuss a particular issue with
    basic encapsulation and how advanced encapsulation resolves it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Mastering advanced encapsulation
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The simple maxim of “private data, public methods” (where the `public` methods
    manipulate the data) goes a long way to ensuring proper encapsulation of your
    data. However, you are not completely safe just yet. In this section, we will
    review Java’s call by value principle, which is used when passing arguments to
    and returning values from methods. We will examine how this can present a subtle
    issue. Lastly, we will examine how to protect your code from encountering this
    issue in the first place.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Call By value revisited
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148), we discussed how, when passing
    arguments to methods, Java’s *call by value* mechanism creates *copies* of those
    arguments. We saw the need to be aware that when the argument is a reference,
    such as to an array, the called method can now manipulate the array object that
    the caller method is looking at.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when a method is *returning* something, call by value applies again.
    In other words, a copy is made of what you are returning. Depending on what the
    copy is of, this can result in encapsulation being broken or not. If you are returning
    `private` primitive data, then there is no issue – a copy of the primitive is
    returned and the client can do whatever it likes to the copy; your `private` primitive
    data is safe. As you may recall from [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148),
    copying primitives is like photocopying a sheet of paper. The photocopied sheet
    can be written on without it affecting the original copy.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: The issue
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The issue arises if your `private` data is a reference (to an object). If the
    client receives a copy of the reference, then the client can manipulate your `private`
    object! From [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148), you may recall that
    copying a reference is like copying a remote control to a TV. The new remote can
    change the channels on the same TV. *Figure 8**.18* presents code that breaks
    encapsulation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.18 – Code that breaks encapsulation](img/B19793_08_18.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
- en: Figure 8.18 – Code that breaks encapsulation
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the `Seniors` class has two `private` instance variables
    (lines 6-7), namely `ages` and `num`. The constructor (lines 9-13) initializes
    the instance variables. We have a public `getNum` accessor method, which returns
    the `private` instance variable, `num` (line 14). Note that we have put this method
    on one line in the interest of space.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: We have another accessor method called `getAges` (lines 15-17) that returns
    a `private` array called `ages`. *Line 16 is the problem* as it breaks encapsulation.
    We will explain why when we discuss the code in `main`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'In `main`, the first thing we do is create an instance of `Seniors` (line 21).
    This is so we can access the instance methods defined in `Seniors`. The rest of
    `main` is divided into two sections: one section (lines 23-27) demonstrates that
    returning `private` primitive data is fine; the other section (lines 30-37) demonstrates
    that simply returning `private` *references* breaks encapsulation.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine the first section. Line 23 initializes the local variable, `num`,
    based on the return value from `seniors.getNum()`. As the `private` `Seniors`
    instance variable, `num`, was initialized to `2` in the `Seniors` constructor
    (line 10), the (completely separate) local variable, `num`, is initialized to
    `2`. We output this fact on line 24\. We then change the local `num` variable’s
    value to `-100` (line 25). The question now is, when we changed the local variable
    `num`, was the `private` `Seniors` instance variable, `num`, changed also? To
    find out, we can simply retrieve `num` again using the `public` accessor method,
    `getNum` (line 26). Line 27 outputs `2`, proving that the `private` primitive,
    `num`, was safe from changes made in `main`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: The second section is where things get interesting. Line 30 initializes a local
    variable called `copyAges` based on the return value from the `public` accessor
    method, `seniors.getAges()`. As `getAges` simply returns (a copy of) the `private`
    `ages` reference, we now have two references referring to the one array object.
    These references are the `private` instance variable, `ages`, and the local variable,
    `copyAges`. Line 31 outputs the values of `copyAges`, which are `30` and `40`
    for the indices `0` and `1`, respectively. These are the same values that the
    `private` `ages` array was initialized to in the `Seniors` constructor (lines
    11-12).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on lines 34-35, we change the values of the `copyAges` array: index `0`
    is set to `-9` and index `1` is set to `-19`. As with the first section, we are
    now wondering, did changing the local array have any effect on the `private` instance
    array in `Seniors`? The answer is yes! To prove this, we can retrieve the `private`
    array again using `getAges` (line 36) and output its values (line 37). The output
    values of `-9` and `-19` demonstrate that the client, `AdvancedEncapsulation`,
    was able to manipulate (change) the so-called `private` data of `Seniors`. Therefore,
    `Seniors` is not encapsulated after all.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.19* shows the situation in memory, shedding light on why `Seniors`
    is not encapsulated:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.19 – In-memory representation of Figure 8.18 (at line 37)](img/B19793_08_19.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Figure 8.19 – In-memory representation of Figure 8.18 (at line 37)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the local variable, `num`, is on the stack. It is a
    copy of the `private` `Seniors` `num` instance variable, and its different values
    as we progress through `main` are reflected in strikethrough font. Line 25 (*Figure
    8**.18*) changes the local variable to `-100`. As can be seen, this change does
    not affect the `private` instance variable, `num`, in `Seniors`, which remains
    `2`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: The issue is with the reference to the `private` array object, `ages`. Because
    `getAges` (line 15) simply returns the reference, a copy of that reference is
    stored in the local variable, `copyAges` (line 30). As the local reference, `copyAges`,
    and the `private` reference, `ages`, now refer to the same object, the copy reference
    can change the `private` array object. That is why the array object has values
    of `-9` and `-19` for indices `0` and `1`, respectively. The `copyAges2` reference
    is just there to prove that point.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: The solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know the issue, fixing it is quite straightforward. The key is
    to, when returning a reference, ensure that you simply do not return the `private`
    reference (as call by value will return a copy of that reference). The solution
    is to *make a copy of the object you wish to return and return a reference to
    the new object*. Thus, the external class (client) can manipulate this new object
    without affecting your private internal object. *Figure 8**.20* is the properly
    encapsulated, refactored version of *Figure 8**.18*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Properly encapsulated code](img/B19793_08_20.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Figure 8.20 – Properly encapsulated code
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, we have replaced the accessor method, `getAges`, with
    a new version (lines 15-18). This new version is properly encapsulated. On line
    16, instead of simply returning the (reference to the) array instance variable,
    we are copying the array, `ages`, into a new array, namely `newArr`. We achieve
    this using the `Arrays.copyOf` method. We return a (copy of the) reference to
    the new array object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on line 24, when we initialize `copyAges`, it is referring to the copy
    array that was created on line 16\. That reference, `newArr`, has gone out of
    scope (since we returned from `getAges`) but the new array object is still on
    the heap, with `copyAges` referring to it. The important point here is that on
    line 25, we have two distinct array references: the `ages` instance and the local
    `copyAges`. These references now refer to two *different* objects.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'Line 25 outputs the details of the copy array; `30` for index `0` and `40`
    for index `1`. This is as expected. Lines 26 and 27 change the contents of the
    copy array indices, `0` and `1`, to `-9` and `-19`, respectively. Now, we need
    to check something: when we changed the contents of the `copyAges` array, were
    the contents of the `private` internal `Seniors` array’s `ages` changed? To check,
    on line 28, we can initialize a `copyAges2` array with the (copy of the) contents
    of the `private` array, `ages`. When we output the details of `copyAges2` on line
    29, we get `30` and `40`, thereby proving that the `private` internal array, `ages`,
    was *not* changed when we changed the local `copyAges` array (lines 26-27). Now,
    `Seniors` is properly encapsulated.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.21* show this situation in memory as we execute line 29:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – In-memory representation of Figure 8.20](img/B19793_08_21.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Figure 8.21 – In-memory representation of Figure 8.20
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, just after the `Seniors` object is constructed (line
    22), we have a `seniors` reference on the stack referring to a `Seniors` object
    on the heap. The `Seniors` object contains a `num` primitive set to 2 (line 10)
    and an `ages` array reference referring to the array object (lines 11-12).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: When we call `getAges` (line 24), the copy array, `newArr`, is created (line
    16) and although not shown here, the new array initially contains the values of
    `30` and `40` (indices `0` and `1`, respectively), as per line 25\. When `newArr`
    is returned from `getAges` (line 17), the (copy of the) reference is assigned
    to `copyAges` (line 24). As shown in the preceding diagram, the `copyAges` local
    variable and the `ages` instance variable refer to two different array objects.
    This is what we want. *Any changes made using* `copyAges` *will not affect the
    private* *array* `ages`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: This is what the changes on lines 26-27 demonstrate. The changes that were made
    using the `copyAges` reference are reflected in the diagram. To prove that the
    changes on lines 26-27 did not affect the `private` array, `ages`, we call `getAges`
    again. A new array, representing a copy of the `private` array, is again created
    (line 16) and the (copy of) the new array reference is returned and assigned to
    the local reference, `copyAges2`. When we output the new array’s contents on line
    29, we get `30` and `40`, demonstrating that the `private` array is unaffected
    by changes to the local array (lines 26-27).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand call by value and advanced encapsulation, we are in an
    excellent position to discuss the object life cycle.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Delving into the object life cycle
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To understand Java, it is extremely helpful to have an appreciation of what
    is happening in the background, in memory. This section will help cement what
    is happening on the stack and the heap when we call methods, declare local/instance
    variables, and so forth.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Local variables are kept on the stack (for fast access), whereas instance variables
    and objects live on the heap (a large area of memory). As we know, we use the
    `new` keyword to create a Java object. The `new` keyword allocates space on the
    heap for the object and returns the reference to the object. What happens if the
    object is no longer accessible? For example, the reference may have gone out of
    scope. How do we reclaim that memory? This is where garbage collection comes into
    play.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, garbage collection reclaims memory taken up by objects
    that are no longer being used; as in the objects have no references pointing to
    them. This garbage collection process is a JVM process that runs in the background.
    The JVM may decide during an idle time to run garbage collection and then it may
    not. Simply put, we have no control over when garbage collection runs. Even if
    we invoke `System.gc()`, this is but a suggestion to the JVM to run garbage collection
    – the JVM is free to ignore this suggestion. The major advantage of garbage collection
    is that we do not have to do the tidy-up ourselves; whereas in languages such
    as C++, we do.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'For further detail on Java Memory Management please see our previous book:
    [https://www.amazon.com/Java-Memory-Management-comprehensive-collection/     dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+     management+maaike%2Caps%2C148&sr=8-1](https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Object life cycle example
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A sample program will help at this point. *Figure 8**.22* presents a program
    to suit our purposes:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.22 – Sample program to explain an object’s life cycle](img/B19793_08_22.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
- en: Figure 8.22 – Sample program to explain an object’s life cycle
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: 'As this (simple and very contrived) program executes, three methods are pushed
    onto the stack, namely `main`, `tagAnimal`, and `setCountry`. *Figure 8**.23*
    represents the in-memory representation when we are just about to exit the `setCountry`
    method (line 19):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – In-memory representation of code in Figure 8.22](img/B19793_08_23.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
- en: Figure 8.23 – In-memory representation of code in Figure 8.22
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at this in more detail.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: The main method
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As can be seen from the previous two figures, line 9 creates the `Cow` object
    on the heap, and the local reference, `cow1`, on the stack in the frame for `main`,
    refers to it. The instance variables in the `Cow` object on the heap, namely `tag`
    and `country`, will be `null` at this point.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Line 10 assigns the value in `cow1` to another local reference in `main`, namely
    `cow2`. Now, at line 11, we have a frame for `main` on the stack with two local
    reference variables, namely `cow1` and `cow2`, both referring to the one `Cow`
    object on the heap.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Line 11 uses the `cow2` reference to execute the instance method, `tagAnimal`.
    Thus, when inside the `tagAnimal` method (during this invocation), the `this`
    reference will be referring to whatever `cow2` is referring to (which is the `Cow`
    object on the heap). In addition, the `cow1` reference is passed as an argument
    to the `tagAnimal` method. This is not necessary as `tagAnimal` already has a
    reference to the `Cow` object (using `this`) but this program is just for example
    purposes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: The tagAnimal method
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As with any method invocation, a stack frame for `tagAnimal` is pushed on the
    stack. As per call by value rules, `tagAnimal` (line 13) aliases the method parameter
    `cow` for `cow1` from line 11 (the method call). Thus, the `cow` reference in
    `tagAnimal` and the `cow1` reference in `main` are pointing at the same `Cow`
    object, which was created on line 9.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: 'As we know, the `this` reference refers to the object instance responsible
    for the method call – in this case, `cow2` (line 11). Therefore, the reference
    to `tag` on line 14 (which is `this.tag` in effect) is referring to the `tag`
    instance variable that can be accessed via `cow2`. As a result, line 14 creates
    a new `Tag` object on the heap and stores its reference in the `tag` instance
    variable of the `Cow` object, overwriting its previous default value of `null`.
    Note that at this point, given the contrived nature of this example, the `Cow`
    object is referred to by three different references: `cow1` and `cow2` in `main`;
    and `cow` in `tagAnimal`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 specifies a `String` literal of `"France"`. As `String` literals are
    objects, a `String` object is created on the heap. Using the `cow` reference,
    the `setCountry` method is called, passing down the `String` literal, `"France"`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: The setCountry method
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A stack frame for `setCountry` is pushed onto the stack. The `setCountry` declaration
    aliases the method parameter `country` to refer to the `String` literal, “`France"`,
    which is passed down in the method call (line 15). Line 18 initializes the `country`
    instance variable to the argument passed down, namely `"France"`. Line 18 explicitly
    uses the `this` reference because the parameter name and instance variable have
    the same identifier, `country`. The *this* reference refers to whatever `cow`
    is referring to, which is the `Cow` object on the heap. This is because the `setCountry`
    method call (line 15) was executed on the reference `cow`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know how methods are pushed onto the stack, let’s examine the memory
    as we return from these method calls – in other words, as we pop the stack. *Figure
    8**.24* represents memory after we have exited the `setCountry` method but before
    we exit the `tagAnimal` method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.24 – In-memory representation after the “setCountry” method completes](img/B19793_08_24.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: Figure 8.24 – In-memory representation after the “setCountry” method completes
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from the preceding figure, the `setCountry` frame has been popped
    from the stack. However, the `String` object, `"France"`, remains on the heap
    because the `country` instance variable from the `Cow` instance object still refers
    to it. Only objects that have no references pointing to them are eligible for
    garbage collection.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8**.25* represents the in-memory representation just after `tagAnimal`
    finishes but before `main` completes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.25 – In-memory representation after the ‘tagAnimal” method completes](img/B19793_08_25.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: Figure 8.25 – In-memory representation after the ‘tagAnimal” method completes
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: There is very little change in this figure from the previous figure, except
    that the stack frame for `tagAnimal` has been popped. The `Cow` object on the
    heap cannot be garbage collected because both the references, `cow1` and `cow2`,
    in `main` refer to it. In addition, because the `Cow` object cannot be removed,
    neither can the `Tag` or `String` objects. This is because the `Cow` instance
    variables, `tag` and `country`, refer to them. This figure represents the situation
    in memory until `main` exits, at which point everything can be reclaimed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our discussion on an object’s life cycle. We will now move on
    and discuss the `instanceof` keyword.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Explaining the instanceof keyword
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `instanceof` keyword enables us to determine the object type that a reference
    is referring to. That is why it is so critical to separate the reference from
    the object. The reference’s type and the object’s type are often very different.
    In fact, in most cases, they are different. We will discuss `instanceof` in greater
    detail when we cover inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205))
    but also when we discuss interfaces ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249)).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for the moment, we will keep it simple – where the reference type and object
    type are the same. *Figure 8**.26* presents one such code example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.26 – Basic “instanceof” example](img/B19793_08_26.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
- en: Figure 8.26 – Basic “instanceof” example
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 7 creates a `Dog` object referred to by a `Dog` reference
    named `dog`. Line 8 creates a `Cat` object referred to by a `Cat` reference named
    `cat`. Line 9 checks if the object at the end of the `dog` reference is “an instance
    of” `Dog`. It is, so line 10 executes. Similarly, line 12 checks to see if the
    object referred to by `cat` is of the `Cat` type. It is, so line 13 executes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Line 15 is commented out as it generates a compiler error. As `Cat` and `Dog`
    are completely unrelated classes (lines 3-4), the compiler knows that there is
    no way a `Cat` reference, namely `cat`, can refer to a `Dog` object. Conversely,
    a `Dog` reference, such as `dog`, cannot refer to a `Cat` object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'We will come back to `instanceof` later in this chapter. For now, let us move
    on to our next topic, which is closely related to classes: namely, enumerations.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Understanding enums
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Enumerations**, or **enums** for short, are a special type of class. Whereas
    with a class, you can have as many instances (of the class) as you wish; with
    enums, the instances are predefined and therefore restricted. Enums are very useful
    for situations where a finite set of values apply – for example, days of the week,
    seasons of the year, and directions.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: This ensures *type-safety* because, with the help of the compiler, only the
    instances defined are allowed. It is always better to find an issue at compile
    time than runtime. For example, if you had a method that defined a `String` parameter,
    namely `direction`, then someone could invoke the method with *"WESTT"* (note
    the incorrect spelling). The compiler would not catch this error as it is a valid
    `String`, so the error would manifest at runtime. If, however, the method parameter
    were an enum instead, the compiler would catch it. We will see this shortly.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of enums: simple and complex. We will discuss them now.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Simple enums
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple enum is named as such because it is, well, simple. This is in the
    sense that when you look at the enum, there is very little code present. *Figure
    8**.27* presents code using a simple enum:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.27 – A simple enum](img/B19793_08_27.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
- en: Figure 8.27 – A simple enum
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the `Water` enum is defined (lines 3-5). The values
    of an enum are expressed in capital letters (similar to constants). It is not
    mandatory to do this but it is common practice. What this enum is saying is that
    we have an `enum` named `Water` and there are only two instances allowed, namely
    `STILL` and `SPARKLING`. In effect, `STILL` and `SPARKLING` are references to
    the only object instances allowed. The semicolon at the end of line 4 is optional
    for simple enums. The corresponding semicolon for complex enums is mandatory.
    The enum values are given ordinal values starting at `0`. So, for `Water`, `STILL`
    has an ordinal value of `0` and `SPARKLING` has an ordinal value of `1`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: As stated previously, enums are a special type of class. However, there are
    some differences. One is that `enum` constructors are `private` by default. This
    includes the default constructor generated by the compiler (as in *Figure 8**.27*
    for `Water`). Contrast this with the default constructor of a class, which has
    the same access as the class itself. Thus, you cannot instantiate an enum as you
    would a normal object. This is why line 8 will not compile – the default `enum`
    constructor generated by the compiler is `private` and therefore inaccessible
    to external types.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: So, if we cannot `new` an `enum`, how do we create an `enum` instance? In other
    words, where are the constructor calls? *The declaration of the enum values,*
    `STILL` *and* `SPARKLING`*, (line 4) are the constructor calls!* As they are within
    the class, they have access to the `private` constructor. These enum values are
    initialized only once – that is, when the enum is first used.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: So, to create an enum (object), use the relevant `enum` value. This is done
    on line 11, where we now have a reference, `stillWater`, referring to the `STILL`
    instance. Contrast line 11 with line 9 (which does not compile). Attempting to
    use any other value such as `EXTRA_SPARKLING` will not compile. This is the type
    safety we discussed previously. Only two instances of `Water` are allowed, `STILL`
    and `SPARKLING`, and the compiler enforces this rule.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Lines 12 and 13 demonstrate that only one instance of `Water.STILL` is created.
    As the equivalence operator and the `equals` method both return `true`, there
    can be only one instance.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Inherited methods
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Although inheritance will be discussed in detail in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205),
    we need to dip into the topic to understand enums. Every class in Java implicitly
    inherits from a class called `Object`. This means that there are methods in `Object`
    that you get by default. This is how Java ensures every class has certain important
    methods. You can accept the version from `Object` or replace it (known as *overriding*
    the method).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: One of these methods that’s inherited from `Object` is `equals`. The version
    in `Object` compares the references to see if they are equal and returns `true`
    or `false` depending on that comparison. Essentially, this is the same as using
    `==` to compare the references.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Enums implicitly inherit from the `Enum` class (and `Enum` inherits from `Object`,
    so there is no escaping `Object`!). Thus, enums have access to methods such as
    `valueOf`, `values`, `ordinal`, and `name`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: The `switch` statement (lines 14-20) switches on the `Water` reference, namely
    `stillWater` (line 14). The `case` label is the unqualified `enum` value (`STILL`,
    line 15). Line 18 shows that the qualified `enum` value is incorrect. Line 19
    (and line 21) demonstrate that even though `enum` values have ordinal values,
    enums are types and not integers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Several interesting methods in the `Enum` type are available to us due to inheritance.
    Let’s start with `valueOf(String)`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: The valueOf(String) method
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is an implicitly declared method, which, when given one of the enum constant
    names, returns that enum instance (line 22). Thus, this method provides a quick
    and easy way to create an enum instance, once you know the constant name.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Let’s examine how we can iterate over all the enum instances using the `values()`
    method.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: The values() method
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is another implicit method. On line 25, we use an enhanced `for` loop to
    iterate over the enums in the order they are declared on line 4, namely `STILL`
    followed by `SPARKLING`. Once we have an enum instantiated, we can use other methods
    to get details of that particular enum.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how the `ordinal()` method provides the ordinal number for the enum.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The ordinal() method
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ordinal()` method (line 28) returns the ordinal value of this enum. The
    initial `enum` constant is given an ordinal value of 0; therefore, `ordinal()`
    for `STILL` returns 0, and `ordinal()` for `SPARKLING` returns 1.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: To determine an enum’s name, we can use the `name()` method.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: The name() method
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `name()` method (line 28) returns the name of this `enum`, exactly as declared
    in the enum (line 4). For example, `name()` for `STILL` returns `"STILL"` and
    `name()` for `SPARKLING` returns `"SPARKLING"`. Note that rather than use the
    `name` method, the better option would be to override the `toString()` method
    as you can customize the `String` that’s displayed (to the user) to be more user-friendly.
    We will do a lot of this in inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have examined simple enums, let’s move on and discuss complex enums.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Complex enums
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As stated earlier, enums are a special type of class where the instances are
    finite. As simple enums are so straightforward, it can be a little harder to see
    the class/enum relationship. With complex enums, identifying the relationship
    between an enum and a class is much easier.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex enums have instance variables, constructors, and methods, so they are
    quite similar to classes. *Figure 8**.28* presents a complex enum for discussion:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.28 – A complex enum](img/B19793_08_28.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: Figure 8.28 – A complex enum
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we declare the `WorkDay` enum (lines 3-25). This `enum` encapsulates
    that we work 9 to 5, Monday to Friday at the office and 10 to 1 on Saturday from
    home. Presumably, we try to rest on Sunday!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: The `enum` constants are declared from lines 5-13\. There is a `private` instance
    variable called `hoursOfWork` (line 15), which is initialized by the constructor
    (lines 16-18). Note that the constructor is `private` by default. The accessor
    method, `getHoursOfWork` (lines 19-21), is how external classes gain access to
    the `private` instance variable, `hoursOfWork`. The other accessor method, `getWorkLocation`
    (lines 22-24), assumes that we work from the office every day (a pre-pandemic
    assumption for sure!). The `SATURDAY` constant (lines 10-13) merits discussion
    and we will come to that shortly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine line 5 closely: this is *a constructor call* to the constructor
    that’s declared (lines 16-18). In other words, the `hoursOfWork` instance variable
    is set to `"9-5"` for `MONDAY`. The other constants – `TUESDAY`, `WEDNESDAY`,
    `THURSDAY`, and `FRIDAY` (lines 6-9) – are initialized similarly.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: What about `SATURDAY`? Since we haven’t covered inheritance yet, this may be
    a little tricky. What we are saying is that for Saturday, we only work from home.
    To do this, we have to replace (“override”) the default `getWorkLocation` method
    (lines 22-24). The default `getWorkLocation` method returns `"Office"` but our
    custom `getWorkLocation` (line 12) returns `"Home"` for `SATURDAY`. The `SATURDAY`
    constant defines a “constant specific class body,” which starts with the curly
    brace on line 10 and ends with the curly brace on line 13.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Note that the semicolon on line 13 *is* required at the end of the complex enum
    constants, regardless of whether they declare a constant specific class body or
    not. That particular semicolon (line 13) tells the compiler, “We have now finished
    defining the `enum` constants, so you can expect instance variables or constructors
    or methods from here on.”
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined our `enum`, let’s use it. Line 28 instantiates `MONDAY`,
    resulting in the enum constant (line 5) executing the constructor (lines 16-18),
    thereby initializing `hoursOfWork` for the `MONDAY` instance to `"9-5"`. Line
    29 proves this fact by outputting `"9-5"`. Line 30 calls the (default) version
    of `getWorkLocation` (lines 22-24), thereby outputting `"Office"` to the screen.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: Line 31 instantiates `SATURDAY` and outputs `"10-1"` for `hoursOfWork` as that
    is what is passed into the constructor from line 10\. Line 32 invokes the constant-specific
    version of `getWorkLocation` for `SATURDAY`, which outputs `"Home"` to the screen.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on enumerations. Let us now discuss a very useful
    feature, namely records.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Appreciating records
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Records are a special type of class, and are considered “data carriers”. They
    help us avoid typing in copious amounts of boilerplate code. Records are specified
    using a record declaration where you list the *components* of the record. Implicitly
    generated in the background are a canonical constructor; `toString`, `equals`,
    and `hashCode` methods and `public` accessor methods for each of the components
    specified. The accessor methods take on the same names as the components themselves
    (as opposed to the more traditional `get` methods). Records are best explained
    by contrasting them to regular classes. *Figure 8**.29* presents a normal class
    with a lot of boilerplate code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.29 - A class with a lot of boilerplate code](img/B19793_08_29.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
- en: Figure 8.29 - A class with a lot of boilerplate code
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The `Person` class in the preceding figure is customized somewhat to map to
    a record more easily. For example, the class itself is `final` (line 5) and the
    instance variables, namely `name` and `age` (lines 6-7), are also `final`. The
    fact that the instance variables are *blank final*’s (declared as `final` but
    not initialized at declaration time) means that the instance variables must be
    initialized in the constructor. This is what the constructor does (lines 10-11).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: There are two accessor methods for retrieving the instance variables, namely
    `name` (lines 13-15) and `age` (lines 16-18). Note that the method names are deliberately
    not preceded by `get`, in other words, `getName` and `getAge`. This is because,
    records use the components identifiers for both naming the instance variables
    *and* the accessor methods.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this class also has custom versions of `equals`, `hashCode`, and
    `toString`, lines 20-26, 28-30 and 32-36 respectively. Each of these methods is
    overriding an inherited version by providing a specific, custom version. This
    topic of overriding is discussed in detail in Inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
    The job of `toString` is to return a string containing the instance variables
    values (the component values). The `equals` method ensures that two records are
    considered equal if they are of the same type and contain equal component values.
    The `hashCode` method ensures that equal objects return the same hashcode value
    (more on this in [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us examine the equivalent record in *Figure 8**.30*:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.30 - Equivalent record of class from Figure 8.29](img/B19793_08_30.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
- en: Figure 8.30 - Equivalent record of class from Figure 8.29
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes – just one line of code! As you can see, this saves us from a lot of boilerplate
    code. In fact, *Figures 8.29* and *8.30* are equivalent (by the time the compiler
    is finished). The two parameters are called components and the preceding one liner
    leads to the following code being generated in the background:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: A `final class` named after the record (`Person` in this example).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`private final` instance variables, one for each component, named after the
    components.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A canonical constructor for initializing the components (instance variables).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessor methods, one for each component, named after the components.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom `toString`, `equals` and `hashCode` methods.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Records are customizable. In other words, we can override (replace) all the
    default versions if we so wish. *Figure 8**.31* presents such a situation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.31 - canonical and compact constructors](img/B19793_08_31.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
- en: Figure 8.31 - canonical and compact constructors
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are customizing the canonical constructor (lines 7-13) as
    we want to validate the `age` component of the person – if they are younger than
    18, that is an error and we generate custom error values. Note again that there
    are better ways to handle error values but for now, this is fine. Otherwise, the
    components are initialized to the values passed in.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: However, this canonical constructor can be written in an even more concise fashion.
    The compact constructor (lines 15-19) is replacing the canonical constructor.
    Compact constructors are a variation of the canonical constructor and are specific
    to records. Note that there is not even a pair of round brackets on line 15 –
    the components can be inferred from the component list (line 5). Also, there is
    no need to initialize the components as per lines 11-12; again, the compiler can
    do this for us.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Lines 23-26 demonstrate how to use the record `Person` that we have declared.
    Line 23 declares a `Person` instance referred to by `p1`. Line 24 calls the implicit
    `toString` provided by the `Record` class (which every record inherits from).
    Lines 25-26 invokes the two accessor methods; note their names are `name()` and
    `age()` respectively. The output is in comments on the right of each line (lines
    24-26).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: As records are so closely related to classes, it is no surprise that records
    can be used with the `instanceof` keyword. This is what we will examine in record
    patterns.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Record patterns
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over the years, the `instanceof` keyword has evolved past the simple `instanceof`-and-cast
    idiom to support both type patterns and record patterns. Let us first discuss
    what a “type pattern” is and “pattern matching”.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Type patterns and pattern matching
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Java 16, `instanceof` was extended to take a type pattern and perform pattern
    matching. Prior to Java 16 the following code was commonplace:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is checking to see if the `Object` reference `obj` is referring to
    a `String` object and if so, to (safely) cast the reference to a `String` so we
    can access the `String` methods. Remember, the methods you can access are based
    on the reference type. However, if the object at the end of the reference is a
    `String` object then we can safely cast the reference to a `String` and thus access
    the `String` methods using the new `String` reference. We will discuss this in
    more detail in Inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'As of Java 16, we can write the previous code segment more concisely and safely:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are two changes to note. The first one is the use of a type pattern `String
    s` as part of the `instanceof`. Pattern matching occurs at runtime whereby `instanceof`
    checks the type against the provided type pattern and if there is a match, performs
    the cast for us as well. The second change is that, as `instanceof` performs the
    cast on our behalf, we no longer need to do the cast ourselves. This leads to
    a more declarative style (where you state what you want rather than how to get
    what you want).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'This leads on nicely to record patterns which were introduced in Java 21\.
    Prior to record patterns, the following code was required (assuming the `Person`
    record from *Figure 8**.30*):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using record patterns, the previous code can be expressed more concisely:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this code, `Person(String sName, Integer nAge)` is a record pattern. A record
    pattern consists of a type, a component pattern list (which may be empty) and
    an optional identifier. A record pattern does two things for us: firstly, it checks
    to see if the object passes the `instanceof` test and secondly, disaggregates
    the record instance into its components. So, in our example, assuming `obj` is
    referring to a `Person` object, then the local variable `sName` will be initialized
    to the return value of the `name()` accessor method and the local variable `nAge`
    will be initialized to the return value from the `age()` accessor method. We deliberately
    used different identifiers for our local variables to highlight the fact that
    they do not have to match the component identifiers used in *Figure 8**.30*. Note
    however that the order of the types must match; in other words, the record pattern
    must specify a `String` variable followed by an `Integer` variable, as that is
    the order of the component list in *Figure 8**.30*.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on records and indeed concludes [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
    Now, let’s put that knowledge into practice to reinforce the concepts we’ve learned.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Classes, objects, and enums are great for enhancing our Mesozoic Eden software.
    In these exercises, you will be creating classes to represent different entities
    in our park and using enums to define fixed sets of constants:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: We have many types of dinosaurs in our park, each with unique characteristics.
    Define a class called `Dinosaur` with properties such as name, age, and species.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our park’s heart and soul lie in its employees. Create a class called `Employee`
    that encapsulates properties such as name, job title, and years of experience.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With these classes in place, create some instances of `Dinosaur` and `Employee`
    and practice manipulating these objects. It’s hard for me to provide more details
    for this exercise, but for example, you could create a new class called `App`.
    Then, in this class, you could create a few instances of `Dinosaur` and `Employee`.
    If you want to go wild, you can add a method that takes `Dinosaur` as an argument
    and then prints the information (such as its name, age, and so on) of this dinosaur.
    Of course, you could do the same thing for `Employee`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The “park” itself can be thought of as an object with its own properties and
    behavior. Design a `Park` class that contains methods for opening and closing
    the park, adding or removing dinosaurs, and so on. You can also consider giving
    it an array of employees and an array of dinosaurs.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The food we serve to our dinosaurs varies greatly. Define a class for `Food`
    with properties such as name, nutritional value, and cost.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you know, safety is our main priority. For obvious safety reasons, our dinosaurs
    are housed in different enclosures. Create an `Enclosure` class that contains
    an array of `Dinosaur` objects.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add more clarity, let’s define an enumeration for dinosaur types, such as
    herbivore, carnivore, and omnivore.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A park visit isn’t complete without a ticket. Create a `Ticket` class with properties
    such as price, visitor’s name, and visit date.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Mesozoic Eden park manager
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, you’ll be creating a fully interactive console application
    known as Mesozoic Eden park manager. This application allows the park manager
    to oversee and manage the various aspects of the dinosaur park. The park manager
    can use this application to efficiently manage multiple dinosaurs, park employees,
    and park tickets. Some of the key features of this system should be as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create, edit, or remove dinosaur profiles, park employee profiles,
    and park tickets.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A real-time tracking system that monitors the location and status of the dinosaurs
    within the park.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A fundamental roster system to organize and manage park employee schedules.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A robust ticketing system to manage guest admissions and ensure the park maintains
    optimal capacity.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system should also handle special scenarios such as emergencies or VIP guest
    visits.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This might sound like a lot. So, here’s a step-by-step guide to achieve this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` classes. Also, add a class called `Guest`. Each class
    should include more properties and methods.'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dinosaur`, `Guest`, and `Employee` objects.'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Scanner` class. This interface should provide the park manager with a variety
    of options to manage the park.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enhance menu creation**: The menu should now include options to manage multiple
    dinosaurs, employees, and tickets. Each option should correspond to a particular
    function in the program.'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handle actions**: Each menu item should trigger a function. For example,
    selecting the **Manage Dinosaurs** option could trigger a function to add, remove,
    or edit dinosaur profiles.'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exit the program**: Provide an option for the user to exit the program.'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a starting code snippet:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The commented-out method calls are placeholders for methods you need to implement
    according to your data structures and functionality.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our discussion by differentiating objects and classes.
    Classes are similar to a plan of a house, whereas an object is the (built) house
    itself. We create an object using the `new` keyword and manipulate the object
    using its reference. Differentiating the reference from the object is very important
    going forward. A useful analogy is that the reference is like a remote control
    and the object is the TV.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Constructors are special methods that are used when constructing an object.
    The constructor is a method that has the same name as the class but with no return
    type. There is always a constructor present – if you don’t provide one, the compiler
    intervenes and inserts the default constructor. The constructor is typically used
    to initialize the instance variables.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Every object gets a copy of the instance members (variables and methods). Class
    members are marked as `static`, and are shared by all instances. When accessing
    an instance member, we use the reference but when accessing a class member, we
    use the class name. Dot notation applies to both syntaxes.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The `this` reference is a special reference available to us in instance methods.
    It refers to the object instance responsible for the method call. Consequently,
    it is dynamic since its value depends on the reference used to invoke the method.
    It is not available to class (`static`) methods.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers apply at both the top (class/interface/record) level, and the
    member level. At the top level, `public` or package-private access applies. Package-private
    is achieved by not specifying any keyword at all and ensures that the top-level
    construct is visible within the same package only. If the top-level construct
    is `public`, then it is available everywhere; there are no restrictions.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Members (variables/methods) can, in addition to `public` and package-private
    (with the same semantics), be `private` and `protected`. `private` means that
    the member is visible within the class only. `protected` is similar to package-private
    except that subclasses, regardless of package, can access the member.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is one of the cornerstones of OOP. It means that a class can hide
    its data from external misuse; this is often called “data hiding.” In Java, it
    is achieved by marking data as `private` and providing `public` accessor/mutator
    (get/set) methods to manipulate the data. The important concept here is that external
    code has to access `private` data via your `public` methods. Thus, by using conditional
    logic in your `public` methods, you can prevent your data from being corrupted.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: However, the principle of “private data, public methods” only goes so far. When
    returning a reference to a `private` object, Java’s call by value mechanism returns
    a copy of that reference. Thus, the `private` object is now *directly* accessible
    via external code. Advanced encapsulation combats this by copying the `private`
    object and returning the reference to the copy object. Thus, your `private` object
    is still private and safe from external interference.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Understanding an object’s life cycle is extremely beneficial. Local variables
    live on the stack, whereas objects and instance variables reside on the heap.
    When an object no longer has any references referring to it, it is eligible for
    garbage collection. Garbage collection is an automatic process run by the JVM,
    at a time of the JVM’s choosing. When the garbage collector runs, objects eligible
    for garbage collection are removed and the heap space is reclaimed.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The `instanceof` keyword enables us to determine the object type that a reference
    is referring to. This will be very useful going forward.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations (enums) are closely related to classes in that enums are simply
    classes, where the number of instances are finite and specified. They are very
    useful for ensuring type safety, whereby the compiler flags an error as opposed
    to discovering the error at runtime.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'Enums are categorized into two separate types: simple and complex. Simple enums
    just specify the constant values; the compiler synthesizes the default constructor.
    All enum constructors are `private` by default. Thus, external classes cannot
    `new` them – the constants that are defined are, in fact, the constructor calls.
    Complex enums look very similar to classes as they have instance variables, (explicit)
    constructors, and methods.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Records are useful when you have classes with a lot of boilerplate code. The
    components of the record are specified in the record declaration. The compiler,
    in the background, generates the instance variables, canonical constructor, accessor
    methods, `toString`, `equals`, and `hashCode` methods. Records are `final`, as
    are the instance variables (components). A compact constructor is a more concise
    variation of the canonical constructor.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: 'That completes our discussion of classes, objects, and enums. We will now move
    onto another important OOP chapter: inheritance.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
