- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Classes, Objects, and Enums
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类、对象和枚举
- en: In [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148), we learned about methods
    in Java. After understanding why methods are useful, we learned that there are
    two parts to methods – the method definition and the method call. We saw that
    the method definition is the code that’s executed when the method is invoked via
    the method call. We discussed how method signatures enable method overloading.
    We also learned how `varargs` helps us call a method with zero or more arguments.
    Finally, we discussed Java’s call by value mechanism, where arguments that are
    passed to a method are copied in memory. Depending on the type of argument passed,
    primitive or reference, will have implications as to the effect of the changes
    made in the called method to those arguments passed from the caller method.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B19793_07.xhtml#_idTextAnchor148)中，我们学习了Java中的方法。在理解了方法为什么有用之后，我们了解到方法有两个部分——方法定义和方法调用。我们看到，方法定义是在通过方法调用调用方法时执行的代码。我们讨论了方法签名如何实现方法重载。我们还学习了`varargs`如何帮助我们用零个或多个参数调用方法。最后，我们讨论了Java的按值调用机制，其中传递给方法的参数在内存中被复制。根据传递的参数类型，原始类型或引用类型，将影响调用方法对调用方法传递的参数所做的更改的效果。
- en: '[*Chapter 7*](B19793_07.xhtml#_idTextAnchor148) concluded the Java fundamentals
    section of this book. The topics in that section are common across many programming
    languages, including non-**object-oriented programming** (**OOP**) languages such
    as C. [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168) starts the OOP section of
    this book.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第7章*](B19793_07.xhtml#_idTextAnchor148)总结了本书的Java基础知识部分。该部分的内容在许多编程语言中都是通用的，包括非面向对象编程（OOP）语言，如C。[*第8章*](B19793_08.xhtml#_idTextAnchor168)开始介绍本书的OOP部分。'
- en: In this chapter, we will cover classes, objects, records and enums. Classes
    and objects are unique to OOP languages (such as Java); in other words, non-OOP
    languages (such as C) do not support them. Though closely related, understanding
    the difference between a class and an object is important. We will discuss the
    relationship between the class and objects of the class. To access an object,
    we must use a reference. Separating the reference from the object will prove very
    useful going forward. Instance versus class members will be discussed, as well
    as when to use either/both. This chapter will also explain the `'this'` reference
    and how it relates to the object responsible for the instance method currently
    executing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖类、对象、记录和枚举。类和对象是面向对象编程语言（如Java）独有的；换句话说，非OOP语言（如C）不支持它们。尽管它们密切相关，理解类和对象之间的区别很重要。我们将讨论类与类对象之间的关系。要访问对象，我们必须使用引用。将引用与对象分离将在以后证明非常有用。将实例成员与类成员进行讨论，以及何时使用任一或两者。本章还将解释`'this'`引用及其与当前执行实例方法的对象之间的关系。
- en: We will also explain the access modifiers in Java. These access modifiers enable
    one of the key cornerstones in OOP, namely encapsulation. Though basic encapsulation
    can be easily achieved, properly encapsulating your class requires extra care.
    This will be covered in the Advanced encapsulation section.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将解释Java中的访问修饰符。这些访问修饰符是实现面向对象编程（OOP）的关键基石之一，即封装。尽管基本的封装可以轻易实现，但正确封装你的类需要额外的注意。这将在高级封装部分进行说明。
- en: Understanding the object life cycle, with regard to what is happening in memory
    as your program executes, is crucial to avoiding many subtle errors. This topic
    will be explained with the aid of diagrams.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 理解对象生命周期，考虑到程序执行时内存中的情况，对于避免许多细微的错误至关重要。这个主题将通过图表进行解释。
- en: Toward the end of the chapter, given our understanding (and separation!) of
    references from the objects they refer to, we will discuss the `instanceof` keyword.
    Lastly, we will cover a variation of classes, namely `enums`, whereby the number
    of object instances is restricted.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的末尾，鉴于我们对引用（以及它们所引用的对象的分离）的理解，我们将讨论`instanceof`关键字。最后，我们将介绍类的一种变体，即`枚举`，其中对象实例的数量受到限制。
- en: 'This chapter covers the following main topics:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Understanding the differences between classes and objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解类和对象之间的区别
- en: Contrasting instance with class members
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对比实例与类成员
- en: Exploring the `'``this'` reference
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索`'this'`引用
- en: Applying access modifiers
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用访问修饰符
- en: Achieving encapsulation
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现封装
- en: Mastering advanced encapsulation
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 掌握高级封装
- en: Delving into the object life cycle
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深入探讨对象生命周期
- en: Explaining the `instanceof` keyword
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释`instanceof`关键字
- en: Understanding enums
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解枚举
- en: Appreciating records
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 欣赏记录
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在GitHub上找到，链接为[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch8)。
- en: Understanding the differences between classes and objects
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解类和对象之间的区别
- en: 'As classes and objects are integral to OOP, it is vital to understand their
    differences. We will discuss the relationship between a class and its objects
    in this section. As creating objects requires the use of the `new` keyword, this
    will also be covered. Understanding constructors and what they do will also be
    examined. All of these topics are linked: objects are the in-memory representation
    of the class (template); to create an object, a constructor is used and to call
    the constructor, we use the `new` keyword. Let’s examine these in turn.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类和对象对于面向对象编程至关重要，理解它们之间的区别是至关重要的。在本节中，我们将讨论类与其对象之间的关系。由于创建对象需要使用`new`关键字，这也会被涵盖。我们还将探讨构造函数及其作用。所有这些主题都是相互关联的：对象是类的内存表示（模板）；要创建对象，使用构造函数，要调用构造函数，我们使用`new`关键字。让我们逐一检查这些内容。
- en: Classes
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类
- en: A class is so integral in Java that you cannot write any program without defining
    one! A class is a blueprint or template for your object. It is similar to a plan
    of a house – using a house plan, you can discuss the house all you want; however,
    you cannot go into the kitchen and make a cup of tea/coffee. The house plan is
    abstract in that regard and so is the class. The class defines fields (properties)
    and methods which operate on those fields. The fields are your data and the methods
    enable manipulation of that data.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，类是如此重要，以至于你无法编写任何不定义类的程序！类是你对象的蓝图或模板。它类似于房屋的设计图——使用房屋设计图，你可以讨论房屋的所有内容；然而，你不能走进厨房泡上一杯茶/咖啡。在这一点上，房屋设计图是抽象的，类也是如此。类定义了字段（属性）和操作这些字段的方法。字段是你的数据，方法使你可以操作这些数据。
- en: Objects
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象
- en: An object is your in-memory representation of your class. If the class is your
    house plan, then the object is your built house. Now, you can go into the kitchen
    and make that cup of tea/coffee. As with houses and house plans, you can create
    many objects based on the class. These objects are known as object *instances*,
    emphasizing that each object is its own unique instance.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是你对类的内存表示。如果类是你的房屋设计图，那么对象就是你的建成房屋。现在，你可以走进厨房，泡上一杯茶/咖啡。就像房屋和房屋设计图一样，你可以基于类创建许多对象。这些对象被称为对象*实例*，强调每个对象都是其独特的实例。
- en: In summary, the class is the template and the object is the in-memory representation
    of the class. You need an object (instance) if you want to execute its (instance)
    methods. So, how do we create an object? We use the `new` keyword.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，类是模板，对象是类的内存表示。如果你想执行其（实例）方法，你需要一个对象（实例）。那么，我们如何创建对象呢？我们使用`new`关键字。
- en: Getting familiar with the new keyword
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 熟悉`new`关键字
- en: 'The `new` keyword in Java enables us to create objects. The object is created
    on the heap, a special area of memory reserved for objects. A reference (similar
    to a pointer) to the object is returned. This reference enables us to manipulate
    the object; for example, to execute the instance methods. Let’s examine the code
    example shown in *Figure 8**.1*:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的`new`关键字使我们能够创建对象。对象在堆上创建，堆是内存中为对象保留的特殊区域。返回对象的引用（类似于指针）。这个引用使我们能够操作对象；例如，执行实例方法。让我们来检查*图8**.1*中显示的代码示例：
- en: '![Figure 8.1 – Creating an object](img/B19793_08_1.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图8.1 – 创建对象](img/B19793_08_1.jpg)'
- en: Figure 8.1 – Creating an object
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 创建对象
- en: In the preceding figure, line 3 defines a `Person` class. It contains nothing
    at the moment; we will expand it as we progress. Line 6 is important – we are
    creating a `Person` object using the `new` keyword. Apart from the `new` keyword,
    line 6 is very similar to any method call. The `p` reference (on the stack) is
    initialized to refer to an object of type `Person` (on the heap). `Person` reference
    named `p` is referring to a `Person` object; however, going forward, that will
    rarely be the case. When “constructing” objects using the `new` keyword, the method
    that’s invoked is a special method known called a *constructor*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第3行定义了一个`Person`类。目前它没有任何内容；随着我们的进展，我们将对其进行扩展。第6行很重要——我们正在使用`new`关键字创建一个`Person`对象。除了`new`关键字外，第6行与任何方法调用非常相似。`p`引用（在栈上）被初始化为指向堆上的`Person`类型对象。名为`p`的`Person`引用正指向一个`Person`对象；然而，在前进的过程中，这种情况很少见。当使用`new`关键字“构造”对象时，被调用的方法是一个特殊的方法，称为*构造函数*。
- en: Constructors
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数
- en: 'A constructor is a special method that’s invoked by the `new` keyword. It has
    two distinct properties that differentiate it from other methods: it has the same
    name as the class and defines no return type, not even `void`. (Java returns the
    reference to the object in the background).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数是一个特殊的方法，它由`new`关键字调用。它有两个独特的属性，使其与其他方法区分开来：它具有与类相同的名称，并且不定义任何返回类型，甚至不是`void`。（Java在后台返回对象的引用）。
- en: Every class contains a constructor, even if you do not code one yourself. If
    you do not code a constructor for your class, Java will synthesize (or define)
    a “default constructor” for you. The default constructor will have the same properties
    as regular constructors; namely, the same name as the class and no return type.
    However, the default constructor will not define any parameters; it will have
    the same access modifier as the class and will contain only one line of code,
    which is `super();`. We will discuss access modifiers later in this chapter and
    `super()` in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 每个类都包含一个构造函数，即使你没有自己编写。如果你没有为你的类编写构造函数，Java会为你自动生成（或定义）一个“默认构造函数”。默认构造函数将具有与常规构造函数相同的属性；即，与类相同的名称且没有返回类型。然而，默认构造函数不会定义任何参数；它将具有与类相同的访问修饰符，并且只包含一行代码，即`super();`。我们将在本章后面讨论访问修饰符，并在[*第9章*](B19793_09.xhtml#_idTextAnchor205)中讨论`super()`。
- en: Note that if you insert even one constructor, the default constructor is not
    synthesized. It’s as if the compiler says, “Okay, you have a constructor(s), you
    know what you are doing, so I won’t get involved.”
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果你插入了一个构造函数，默认构造函数就不会被自动生成。这就像编译器说：“好吧，你已经有了构造函数（们），你知道你在做什么，所以我不介入。”
- en: 'Now that we know when default constructors are synthesized by the compiler,
    we can see that default constructors are required for both `Person` and `PersonExample`
    in *Figure 8**.1*. *Figure 8**.2* represents the code *after* the compiler has
    inserted the default constructors:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道默认构造函数何时由编译器生成，我们就可以看到在*图8**.1*中`Person`和`PersonExample`都需要默认构造函数。*图8**.2*表示编译器插入默认构造函数后的代码：
- en: '![Figure 8.2 – Default constructors inserted](img/B19793_08_2.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 插入的默认构造函数](img/B19793_08_2.jpg)'
- en: Figure 8.2 – Default constructors inserted
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 插入的默认构造函数
- en: The red rectangles in the preceding figure represent the default constructors
    inserted by the compiler. This happened to both classes because neither class
    defined any constructor at all and every class requires a constructor. The default
    constructors, in addition to having the same name as the class and not returning
    anything (not even `void`), define no parameters (lines 4 and 9) and simply call
    `super();`. As stated in the previous callout, `super()` will be discussed when
    we discuss Inheritance in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 前面图中的红色矩形表示编译器插入的默认构造函数。这发生在两个类上，因为两个类都没有定义任何构造函数，而每个类都需要一个构造函数。除了具有与类相同的名称且不返回任何内容（甚至不是`void`）之外，默认构造函数不定义任何参数（第4行和第9行），并且简单地调用`super();`。正如前一个提示中所述，`super()`将在我们讨论[*第9章*](B19793_09.xhtml#_idTextAnchor205)中的继承时进行讨论。
- en: We will discuss access modifiers in detail later but note that the access for
    the default constructors match the access for their respective classes. For example,
    `PersonExample` is a `public` class and so is its constructor (lines 8 and 9 respectively).
    The `Person` class mentions no *explicit* access modifier at all and neither does
    its constructor (lines 3 and 4 respectively).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面详细讨论访问修饰符，但请注意，默认构造函数的访问权限与它们各自类的访问权限相匹配。例如，`PersonExample` 是一个 `public`
    类，因此它的构造函数也是 `public`（分别在第8和第9行）。`Person` 类没有提及任何 *显式* 访问修饰符，其构造函数也是如此（分别在第3和第4行）。
- en: Now, you can see why `new Person();` on line 13 does not generate a compiler
    error. To be clear, there is no compiler error on line 13 because the compiler
    inserted the default constructor for the `Person` class (lines 4 to 6) and thus
    `new Person()` was able to locate the constructor and therefore compile.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到为什么第13行的 `new Person();` 不会生成编译器错误。为了清楚起见，第13行没有编译器错误，因为编译器插入了 `Person`
    类的默认构造函数（第4至6行），因此 `new Person()` 能够找到构造函数并因此编译。
- en: The default constructor for `PersonExample` (lines 9 to 11) has no material
    effect in this program. The JVM starts every program in the `main` method.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`PersonExample` 的默认构造函数（第9至11行）在这个程序中没有实质性的影响。JVM 在每个程序的 `main` 方法中启动程序。'
- en: We will now move on to discuss instance members versus class members. Note that
    local variables (in a method) are neither.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将转向讨论实例成员与类成员的区别。请注意，局部变量（在方法中）也不是。
- en: Contrasting instance with class members
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对比实例成员与类成员
- en: 'An object can be more correctly termed an object *instance*. This is where
    *instance* members (methods/data) get their names: every object gets a copy of
    an instance member. Class members, however, are different in that there is only
    one copy per class, regardless of the number of object instances created. We’ll
    discuss both of these topics now.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对象更准确地可以称为对象 *实例*。这就是 *实例* 成员（方法/数据）获得名称的地方：每个对象都会获得一个实例成员的副本。然而，类成员是不同的，因为每个类只有一个副本，无论创建了多少对象实例。我们现在将讨论这两个主题。
- en: Instance members (methods/data)
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例成员（方法/数据）
- en: 'This is more easily explained by presenting a code example first. *Figure 8**.3*
    presents a class with instance members:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点通过先展示一个代码示例更容易解释。*图8.3* 展示了一个具有实例成员的类：
- en: '![Figure 8.3 – A class with instance members](img/B19793_08_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图8.3 – 具有实例成员的类](img/B19793_08_3.jpg)'
- en: Figure 8.3 – A class with instance members
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 具有实例成员的类
- en: When you create an object using `new`, you are creating an object *instance*.
    Each instance gets a copy of the instance members (variables and methods). Regarding
    instance variables, we need to define where instance variables are declared and
    their resultant scope. An instance variable is defined within the class but outside
    every method coded in the class. Thus, the scope of an instance variable is the
    class itself; meaning, every instance method in the class can access the instance
    variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `new` 创建一个对象时，你正在创建一个对象 *实例*。每个实例都获得实例成员（变量和方法）的副本。关于实例变量，我们需要定义实例变量在哪里声明以及它们的范围。实例变量是在类内部定义的，但不在类中编写的每个方法之外。因此，实例变量的范围是类本身；这意味着，类中的每个实例方法都可以访问实例变量。
- en: 'Now let us discuss the code example. In the preceding figure, the `Person`
    class defines both instance variables and instance methods. As the instance variables
    are declared outside every method, they have the scope of the class. The fact
    that the instance variables are marked `private` and the instance methods are
    marked `public` will be explained later in this chapter. The constructor is as
    follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论代码示例。在前面的图中，`Person` 类定义了实例变量和实例方法。由于实例变量是在每个方法外部声明的，因此它们的范围是类级别的。实例变量被标记为
    `private` 以及实例方法被标记为 `public` 的原因将在本章后面解释。构造函数如下：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This constructor enables us to pass in a `String` and initialize the instance
    variable based on that `String`. For example, when we instantiate an object as
    follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数使我们能够传入一个 `String` 并根据该 `String` 初始化实例变量。例如，当我们按照以下方式实例化一个对象时：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: we are passing `"Maaike"` into the constructor, so the `name` instance variable
    in the object referred to by `p1` refers to `"Maaike"`. The constructor is also
    keeping a count of the number of objects that are created by incrementing `count`
    each time the constructor is invoked. Note that no default `Person` constructor
    was inserted by the compiler in this example as a constructor was already coded
    in the class.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`"Maaike"`传递给构造函数，因此`p1`引用的对象中的`name`实例变量引用了`"Maaike"`。构造函数还通过每次调用构造函数时增加`count`来记录创建的对象数量。请注意，在这个例子中，编译器没有插入默认的`Person`构造函数，因为类中已经编写了构造函数。
- en: 'We also invoke the `getName()` instance method using the `p1` and `p2` references
    as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用`p1`和`p2`引用调用了`getName()`实例方法，如下所示：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This syntax of `refName.instanceMethod()` is known as *dot notation*. As per
    the comments in the code, `"Maaike"` and `"Sean"` are output to the screen (in
    that order). *Figure 8**.4* shows the in-memory representation of the code after
    we have created both objects, referenced by `p1` and `p2` respectively:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种`refName.instanceMethod()`的语法称为*点表示法*。根据代码中的注释，`"Maaike"`和`"Sean"`将按顺序输出到屏幕上。（*图8**.4*）显示了在创建了两个对象，分别由`p1`和`p2`引用后，代码在内存中的表示：
- en: '![Figure 8.4 – In-memory representation of Figure 8.3 (start of line 27)](img/B19793_08_4.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图8.4 – 图8.3的内存表示（行27开始）](img/B19793_08_4.jpg)'
- en: Figure 8.4 – In-memory representation of Figure 8.3 (start of line 27)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 图8.3的内存表示（行27开始）
- en: As the preceding figure shows, we have two references on the stack, namely `p1`
    and `p2`. `p1` refers to the first `Person` object on the heap – that is, the
    object that was created on line 23\. The instance variable values of `p1` (its
    “state”) are `"Maaike"` and `1` for `name` and `count`, respectively. As strings
    are objects, `name` is a reference to another object, a `String` object, which
    has a value of `"Maaike"`. Similarly, the `p2` reference refers to the object
    that was created on line 24\. As can be seen from the diagram, the instance variable
    values of `p2` are `"Sean"` and `1` for `name` and `count`, respectively.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们有堆栈上的两个引用，即`p1`和`p2`。`p1`引用堆上的第一个`Person`对象——即第23行创建的对象。`p1`的实例变量值（其“状态”）是`name`的`"Maaike"`和`count`的`1`。由于字符串是对象，`name`是一个引用另一个对象的引用，即一个值为`"Maaike"`的`String`对象。同样，`p2`引用指向第24行创建的对象。从图中可以看出，`p2`的实例变量值是`name`的`"Sean"`和`count`的`1`。
- en: Note that each `Person` object *instance* on the heap has a copy of the *instance*
    variables. That is why they are called instance variables.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，堆上的每个`Person`对象*实例*都有一个*实例*变量的副本。这就是为什么它们被称为实例变量。
- en: 'Lines 27 and 28 change the values of the `name` instance variables to `"Maaike
    van Putten"` and `"Sean Kennedy"` for `p1` and `p2`, respectively. *Figure 8**.5*
    shows these changes:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第27和28行将`name`实例变量的值分别更改为`"Maaike van Putten"`和`"Sean Kennedy"`，对应于`p1`和`p2`。(*图8**.5*)显示了这些更改：
- en: '![Figure 8.5 – In-memory representation of Figure 8.3 (start of line 29)](img/B19793_08_5.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – 图8.3的内存表示（行29开始）](img/B19793_08_5.jpg)'
- en: Figure 8.5 – In-memory representation of Figure 8.3 (start of line 29)
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 图8.3的内存表示（行29开始）
- en: 'This figure shows that the two `String` objects have been changed: `p1`’s instance
    variable `name` refers to `"Maaike van Putten"` and `p2`’s instance variable `name`
    refers to `"Sean Kennedy"`. Consequently, lines 29 to 30 output `"Maaike van Putten"`
    and `"Sean` `Kennedy"`, respectively.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示，两个`String`对象已被更改：`p1`的实例变量`name`引用了`"Maaike van Putten"`，而`p2`的实例变量`name`引用了`"Sean
    Kennedy"`。因此，第29到30行分别输出了`"Maaike van Putten"`和`"Sean Kennedy"`。
- en: String immutability
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串不可变性
- en: Strings are immutable objects. This means that `String` objects, once created,
    cannot be changed. Ever. It may look like they have changed, as in the effect
    is created of a change, but a completely new object has been created and the original
    is left untouched. We will revisit `String` immutability in greater detail in
    [*Chapter 12*](B19793_12.xhtml#_idTextAnchor293).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是不可变对象。这意味着一旦创建了`String`对象，就不能更改。永远不能。虽然看起来它们已经改变了，因为产生了变化的效果，但实际上已经创建了一个全新的对象，而原始对象保持未变。我们将在[*第12章*](B19793_12.xhtml#_idTextAnchor293)中更详细地回顾`String`不可变性。
- en: So, the original `String` objects, `"Sean"` and `"Maaike"`, are still on the
    heap taking up space. They are of no use because, as we have no references to
    them, we have no way to get to them. Remember, the `name` instance variables for
    both `p1` and `p2` refer to the newly created `String` objects containing `"Maaike
    van Putten"` and `"Sean` `Kennedy"`, respectively.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原始的`String`对象，`"Sean"`和`"Maaike"`，仍然在堆上占用空间。它们没有用处，因为我们没有对这些对象的引用，所以我们无法访问它们。记住，`p1`和`p2`的`name`实例变量分别引用了新创建的包含`"Maaike
    van Putten"`和`"Sean Kennedy"`的`String`对象。
- en: So, what happens to these no-longer-used objects? They are “garbage collected.”
    We will discuss this soon but for now, just know that the JVM runs a process called
    a garbage collector in the background to tidy up (reclaim) all the objects that
    can no longer be reached. We have no control over when this process runs but the
    fact that there is a garbage collector saves us from having to tidy up after ourselves
    (whereas in other OOP languages such as C++, you have to!).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些不再使用的对象会怎样呢？它们会被“垃圾回收”。我们很快就会讨论这个问题，但首先，只需知道JVM在后台运行一个名为垃圾回收器的进程来整理（回收）所有无法访问的对象。我们无法控制这个进程何时运行，但有一个垃圾回收器可以让我们免于自己清理（而与其他OOP语言如C++不同，你必须这样做！）。
- en: The code in *Figure 8**.3* has an issue – `count` is 1 and it should be 2\.
    Instance variables that are integers are initialized to `0` by default. In each
    of the constructor calls, we increment `count` from `0` to `1`. We would like
    the first constructor call to increment `count` from `0` to `1` and the second
    constructor call to increment `count` from `1` to `2`. This is where class members
    come in.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8.3* 中的代码存在问题 – `count` 的值为1，而它应该是2。实例变量默认初始化为`0`。在每次构造函数调用中，我们将`count`从`0`增加到`1`。我们希望第一次构造函数调用将`count`从`0`增加到`1`，而第二次构造函数调用将`count`从`1`增加到`2`。这就是类成员发挥作用的地方。'
- en: Class members (methods/data)
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类成员（方法/数据）
- en: To mark a field and/or method as a class member, as opposed to an instance member,
    you can insert the `static` keyword into the declaration of the member. Class
    members are shared by all instances of the class. This means that you do not have
    to create an object instance to access the `static` members of the class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要将字段和/或方法标记为类成员，而不是实例成员，可以在成员的声明中插入`static`关键字。类成员由类的所有实例共享。这意味着你不需要创建对象实例来访问类的`static`成员。
- en: The syntax for accessing a `static` member is different from accessing an instance
    member. Rather than use the reference, the class name is used, as in `className.staticMember`.
    This emphasizes the class nature of the member being accessed. For example, the
    JVM starts the program in *Figure 8**.3* with `PersonExample.main()`. This is
    how the JVM starts every program as it saves on constructing an object and its
    resulting memory footprint.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 访问`static`成员的语法与访问实例成员的语法不同。而不是使用引用，使用类名，如`className.staticMember`。这强调了被访问成员的类性质。例如，JVM使用`PersonExample.main()`在*图8.3*中启动程序。这就是JVM以节省构建对象及其内存占用为代价启动每个程序的方式。
- en: 'Let’s get back to our problem with `count` (which is 1 instead of 2). *Figure
    8**.6* represents the changes that must be made to fix this issue:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的`count`问题（它的值应该是2而不是1）。*图8.6*表示必须进行的更改以解决这个问题：
- en: '![Figure 8.6 – Making “count” static](img/B19793_08_6.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6 – 使“count”静态化](img/B19793_08_6.jpg)'
- en: Figure 8.6 – Making “count” static
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 使“count”静态化
- en: Contrasting the code in *Figure 8**.6* with the code in *Figure 8**.3*, we can
    see that `count` is declared `static` (line 5). Thus, there is only one copy of
    *count*, which is shared across all instances of `Person`. Thus, `p1` and `p2`
    are looking at the same *count*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 将*图8.6*中的代码与*图8.3*中的代码进行对比，我们可以看到`count`被声明为`static`（第5行）。因此，只有一个`count`的副本，它在所有`Person`实例之间共享。因此，`p1`和`p2`正在查看相同的`count`。
- en: In the constructor (line 9), while not necessary, we use the correct syntax
    to emphasize the `static` nature of `count`. Similarly, as `getCount` (line 17)
    is simply returning a `static` member, we marked it as `static`. In addition,
    we used the `Person.count` static syntax (line 18). Lastly, line 25 accesses the
    `static` method using the correct syntax, `Person.getCount`, to retrieve the `private`
    class variable, `count`. We can see that it outputs `2`, which is correct. Comparing
    the other differences in code, some of the extra code in `main` (*Figure 8**.3*)
    has been removed to help us focus on what we are discussing here.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数（第 9 行）中，虽然不是必需的，但我们使用正确的语法来强调 `count` 的 `static` 特性。同样，由于 `getCount`（第
    17 行）只是返回一个 `static` 成员，我们将其标记为 `static`。此外，我们使用了 `Person.count` 静态语法（第 18 行）。最后，第
    25 行使用正确的语法 `Person.getCount` 访问了 `private` 类变量 `count`。我们可以看到它输出了 `2`，这是正确的。比较代码中的其他差异，`main`（*图
    8**.3*）中的一些额外代码已被删除，以帮助我们关注这里讨论的内容。
- en: Instance to static but not vice versa
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 实例到静态，但反之则不行
- en: If you are in an instance method, you can access a `static` member but not vice
    versa. We will discuss the reason why when we explain the `this` reference. This
    means that, in *Figure 8**.6*, you could use the `p1` reference to access the
    `getCount` method (line 25). As such, `p1.getCount()` is valid but this is a *poor*
    programming practice as it conveys the impression that `getCount` is an instance
    method when it is a `static` method - use `Person.getCount()` as per the code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在一个实例方法中，您可以访问一个 `static` 成员，但反之则不行。当我们解释 `this` 引用时，我们将讨论为什么。这意味着，在 *图 8**.6*
    中，您可以使用 `p1` 引用来访问 `getCount` 方法（第 25 行）。因此，`p1.getCount()` 是有效的，但这是一种 *较差* 的编程实践，因为它给人一种
    `getCount` 是实例方法的印象，而实际上它是一个 `static` 方法 - 按照代码使用 `Person.getCount()`。
- en: '*Figure 8**.7* shows the in-memory representation of the code in *Figure 8**.6*:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8**.7* 显示了 *图 8**.6* 代码的内存表示：'
- en: '![Figure 8.7 – In-memory representation of the code in Figure 8.6](img/B19793_08_7.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 图 8.6 代码的内存表示](img/B19793_08_7.jpg)'
- en: Figure 8.7 – In-memory representation of the code in Figure 8.6
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 图 8.6 代码的内存表示
- en: As can be seen in the bottom-right corner of the preceding figure, the `static`/`class`
    members of the `Person` class are stored separately from the instances themselves.
    There is now only one copy of `count` and it is shared between `p1` and `p2`.
    Thus, the `count` value of `2` is correct.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个图例的右下角所示，`Person` 类的 `static`/`class` 成员与实例本身存储在分开的地方。现在只有一个 `count` 的副本，它被
    `p1` 和 `p2` 共享。因此，`count` 的值为 `2` 是正确的。
- en: Default values for class and instance variables
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 类和实例变量的默认值
- en: Instance variables are initialized to default values every time a class is `new`’ed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个新类时，实例变量都会初始化为默认值。
- en: Class variables are initialized to default values the very first time a class
    is loaded. This could occur when using `new` or when referring to a class member
    (using the class syntax).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 类变量在类首次加载时初始化为默认值。这可能在使用 `new` 或引用类成员（使用类语法）时发生。
- en: 'The default values for class and instance variables are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 类和实例变量的默认值如下：
- en: '| **Type** | **Default value** |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| **类型** | **默认值** |'
- en: '| `byte, short,` and `int` | `0` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `byte, short,` 和 `int` | `0` |'
- en: '| `long` | `0L` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `0L` |'
- en: '| `float` | `0.0f` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `0.0f` |'
- en: '| `double` | `0.0d` |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `0.0d` |'
- en: '| `char` | ‘`\u0000`’ (Unicode zero) |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `char` | ‘`\u0000`’ (Unicode 零) |'
- en: '| `String` (or any reference to an object) | `null` |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `String` (或任何对象的引用) | `null` |'
- en: '| `boolean` | `false` |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `boolean` | `false` |'
- en: Table 8.1 – Default values for class and instance variables
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.1 – 类和实例变量的默认值
- en: In a previous callout, we highlighted that you can access class members from
    an instance method but not vice versa. Let’s delve into that now.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的提示中，我们强调了您可以从实例方法中访问类成员，但反之则不行。现在让我们深入探讨这一点。
- en: Exploring the “this” reference
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索“this”引用
- en: When you call an instance method, the compiler secretly passes into the method
    a copy of the object reference that invoked the method. This reference is available
    to the instance method as the `this` reference.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当您调用一个实例方法时，编译器会秘密地将调用该方法的对象引用的副本传递到方法中。这个引用作为 `this` 引用对实例方法可用。
- en: Class methods do not get a `this` reference. This is why, if you are in a `static`
    method (context) and you try to access an instance member directly (without an
    object reference), you will get a compiler error. In effect, every instance member
    requires an object reference when accessing it. This makes sense because instance
    members are instance-specific and therefore, you need an instance (reference)
    to say, *“I want to access this particular instance/object as opposed to that*
    *particular one.”*
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法不会获得 `this` 引用。这就是为什么如果你在一个 `static` 方法（上下文）中尝试直接访问实例成员（没有对象引用），你会得到编译器错误。实际上，每个实例成员在访问时都需要一个对象引用。这很有意义，因为实例成员是实例特定的，因此你需要一个实例（引用）来说明，“我想访问这个特定的实例/对象，而不是那个特定的对象。”
- en: 'Let’s refactor the code in *Figure 8**.3* so that the `Person` class uses the
    `this` reference explicitly. In addition, all references to the incorrectly working
    `count` instance variable have been removed so that we can focus on the `this`
    reference. *Figure 8**.8* includes the refactored `Person` class (the `PersonExample`
    class remains untouched):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重构 *图 8.3* 中的代码，以便 `Person` 类显式地使用 `this` 引用。此外，所有对不正确工作的 `count` 实例变量的引用都已删除，以便我们可以专注于
    `this` 引用。*图 8.8* 包含重构后的 `Person` 类（`PersonExample` 类保持不变）：
- en: '![Figure 8.8 – Using the “this” reference](img/B19793_08_8.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 使用“this”引用](img/B19793_08_8.jpg)'
- en: Figure 8.8 – Using the “this” reference
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 使用“this”引用
- en: 'In the preceding figure, lines 7, 11, and 15 are commented out and replaced
    by lines 8, 12, and 16, respectively. Let’s contrast both the commented-out line
    7 and the new line 8 more closely:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，第 7、11 和 15 行被注释掉，分别替换为第 8、12 和 16 行。让我们更仔细地对比一下被注释掉的 7 行和新的 8 行：
- en: '[PRE3]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Firstly, assume line 7 is uncommented. How does line 7 reconcile its variables?
    Initially, the compiler checks the current scope (the constructor block of code)
    and reconciles `aName` as a parameter to the constructor. However, the compiler
    still has not reconciled `name`, so it checks the next outer scope, the class
    scope, where the instance/class variables are defined. Here, it finds an instance
    variable called `name`, and therefore line 7 compiles.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设第 7 行被取消注释。第 7 行是如何协调其变量的？最初，编译器检查当前作用域（代码的构造块），并将 `aName` 协调为构造函数的参数。然而，编译器还没有协调
    `name`，因此它检查下一个外部作用域，即类作用域，其中定义了实例/类变量。在这里，它找到一个名为 `name` 的实例变量，因此第 7 行可以编译。
- en: Line 8 operates somewhat differently. Yes, it reconciles `aName` similarly but
    now, it comes across `this.name` (as opposed to `name`). Upon seeing *this*, the
    compiler immediately checks the instance variables that have been declared. It
    finds an instance variable called `name`, and therefore line 8 compiles. Lines
    7 and 8 are, in effect, the same.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 第 8 行的操作有些不同。是的，它以类似的方式协调 `aName`，但现在，它遇到了 `this.name`（而不是 `name`）。看到 *this*
    后，编译器立即检查已声明的实例变量。它找到一个名为 `name` 的实例变量，因此第 8 行可以编译。第 7 行和第 8 行实际上是相同的。
- en: Line 16 is the same as line 8 as we used the same parameter identifier, `aName`.
    Line 12 is simply returning the `name` instance variable.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 第 16 行与第 8 行相同，因为我们使用了相同的参数标识符，`aName`。第 12 行只是简单地返回 `name` 实例变量。
- en: So, that covers how to use `this` in a class, but how do we associate the instance
    with `this`?
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这涵盖了如何在类中使用 `this`，但我们是怎样将实例与 `this` 关联起来的呢？
- en: Associating an instance with the “this” reference
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将实例与“this”引用关联
- en: 'Thankfully, the compiler does this automatically. As stated previously, the
    `this` reference is only passed (in secret) to instance methods and it refers
    to the instance that is invoking the method at that time. For example, when executing
    `p1.getName()`, the `this` reference in `getName` refers to `p1`, whereas when
    executing `p2.getName()`, the `this` reference in `getName` refers to `p2`. Thus,
    the `this` reference varies, depending on the instance that invokes the method.
    *Figure 8**.9* represents the dynamic nature of the `this` reference in action:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，编译器会自动完成这项工作。正如之前所述，`this` 引用仅（秘密地）传递给实例方法，并且它指向当时调用该方法的实例。例如，当执行 `p1.getName()`
    时，`getName` 中的 `this` 引用指向 `p1`，而当执行 `p2.getName()` 时，`getName` 中的 `this` 引用指向
    `p2`。因此，`this` 引用会根据调用方法的实例而变化。*图 8.9* 表示了 `this` 引用动态特性的实际应用：
- en: '![Figure 8.9 – The dynamic nature of the “this” reference](img/B19793_08_9.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – “this”引用的动态特性](img/B19793_08_9.jpg)'
- en: Figure 8.9 – The dynamic nature of the “this” reference
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – “this”引用的动态特性
- en: This figure represents the in-memory representation of the code in *Figure 8**.8*
    as we execute line 12 from the method call on line 24\. As `getName` on line 24
    is invoked on `p2` – in other words, `p2.getName();` – the `this` reference inside
    `getName` refers to the same object that `p2` is referring to. This is represented
    by the solid line from the `this` reference referring to the same object that
    `p2` is referring to.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表示我们在执行第 24 行方法调用时，从 *图 8**.8* 中的代码执行第 12 行时的内存表示。当第 24 行的 `getName` 在 `p2`
    上被调用——换句话说，`p2.getName();`——`getName` 中的 `this` 引用指向与 `p2` 指向相同的对象。这由从 `this`
    引用指向与 `p2` 指向相同对象的实线表示。
- en: The dashed line represents what the `this` reference was referring to on line
    12, from the method call on line 23, namely `p1`. Thus, the `this` reference is
    dynamically referring to the instances referred to by `p1` or `p2`, depending
    on which invoked the instance method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 虚线表示第 12 行方法调用中 `this` 引用所指向的内容，即 `p1`。因此，`this` 引用是动态地指向由 `p1` 或 `p2` 引用的实例。
- en: As we saw in the code in *Figure 8**.8*, the `this` reference was not needed.
    Let’s examine a situation where the `this` reference is needed.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *图 8**.8* 中的代码所看到的，`this` 引用是不必要的。让我们考察一个需要 `this` 引用的情况。
- en: Shadowing or hiding an instance variable
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 阴影或隐藏实例变量
- en: 'Shadowing an instance variable occurs when a variable has the same identifier
    as the instance variable. *Figure 8**.10* presents code where this occurs so that
    we can observe the issue it creates:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个变量与实例变量具有相同的标识符时，就会发生实例变量的阴影。*图 8**.10* 展示了这种情况的代码，以便我们可以观察它造成的问题：
- en: '![Figure 8.10 – Shadowing an instance variable](img/B19793_08_10.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 实例变量的阴影](img/B19793_08_10.jpg)'
- en: Figure 8.10 – Shadowing an instance variable
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 实例变量的阴影
- en: In the preceding figure, the constructor has a logical issue; in other words,
    the code compiles but the code is not working as expected. Line 7 is the issue.
    Remember that, if a variable is not qualified with `this`, the current scope is
    checked to see if the variable is declared there. On line 6, we have declared
    a constructor parameter that uses the `name` identifier, which is the same identifier
    as the instance variable on line 4\. Thus, line 7 is essentially assigning the
    local variable to itself and the instance variable remains untouched. As the instance
    variable is a `String` type, its default value is `null`. As a result, `null`
    is output on line 19 instead of `"Maaike"`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，构造函数存在逻辑问题；换句话说，代码可以编译，但代码没有按预期工作。第 7 行是问题所在。记住，如果一个变量没有用 `this` 限定，则检查当前作用域以查看是否在该作用域中声明了该变量。在第
    6 行，我们声明了一个使用 `name` 标识符的构造函数参数，它与第 4 行的实例变量具有相同的标识符。因此，第 7 行实际上是将局部变量赋值给自己，而实例变量保持未更改。由于实例变量是
    `String` 类型，其默认值是 `null`。因此，第 19 行输出的是 `null` 而不是 `"Maaike"`。
- en: 'To fix this issue, we have two options. The first option is to use a different
    identifier for the constructor parameter and use that new identifier. This is
    what `setName` does (lines 12-13): a method parameter called `aName` is used that
    does not shadow the `name` instance identifier. The second option is to use the
    `this` reference to specify that the variable being initialized is an instance
    variable. *Figure 8**.11* shows this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们有两种选择。第一种选择是为构造函数参数使用不同的标识符，并使用这个新标识符。这就是 `setName` 所做的（第 12-13 行）：使用一个不与
    `name` 实例标识符阴影的方法参数 `aName`。第二种选择是使用 `this` 引用来指定正在初始化的变量是实例变量。*图 8**.11* 展示了这一点：
- en: '![Figure 8.11 – Using “this” to fix the shadowing issue](img/B19793_08_11.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 使用 “this” 解决阴影问题](img/B19793_08_11.jpg)'
- en: Figure 8.11 – Using “this” to fix the shadowing issue
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 使用 “this” 解决阴影问题
- en: 'In this figure, line 7 is important: `this.name` refers to the `name` instance
    variable, while `name`, on its own, refers to the method parameter. Thus, shadowing
    has been removed and line 19 now outputs `"Maaike"` as expected.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，第 7 行很重要：`this.name` 指向 `name` 实例变量，而 `name` 单独使用时，则指向方法参数。因此，阴影已被消除，第
    19 行现在输出预期的 `"Maaike"`。
- en: 'We know that only non-static (instance) methods receive the `this` reference.
    Let’s examine how this issue can affect us and how to resolve it. *Figure 8**.12*
    presents code where we are in a `static` context (method) and are trying to directly
    access an instance variable:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道只有非静态（实例）方法接收 `this` 引用。让我们考察这个问题如何影响我们以及如何解决它。*图 8**.12* 展示了在 `static`
    上下文（方法）中，我们尝试直接访问实例变量的代码：
- en: '![Figure 8.12 – Accessing instance variables from a “static” context](img/B19793_08_12.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12 – 从“静态”上下文访问实例变量](img/B19793_08_12.jpg)'
- en: Figure 8.12 – Accessing instance variables from a “static” context
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 从“静态”上下文访问实例变量
- en: In the preceding figure, we have an instance variable called `x` (line 4), an
    instance method called `m` (line 5), and a `static` method called `main` (lines
    6 –19). As we know, `static` methods such as `main`, do not get the `this` reference
    automatically (as they are class methods as opposed to instance methods).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们有一个名为`x`的实例变量（第4行），一个名为`m`的实例方法（第5行），以及一个名为`main`的`static`方法（第6-19行）。正如我们所知，`static`方法如`main`不会自动获得`this`引用（因为它们是类方法而不是实例方法）。
- en: There are compiler errors on lines 9, 10, 11, and 12\. When you access an instance
    member directly, as on lines 9 and 11, the compiler inserts `this` before the
    member. In other words, by the time the compiler is finished with lines 9 and
    11, internally, they look the same as lines 10 and 12\. Consequently, as `main`
    does not have a `this` reference, the compiler complains about lines 9, 10, 11
    and 12.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 第9、10、11和12行存在编译错误。当你直接访问实例成员时，如第9和11行，编译器会在成员前插入`this`。换句话说，当编译器完成第9和11行时，从内部来看，它们看起来与第10和12行相同。因此，由于`main`没有`this`引用，编译器会对第9、10、11和12行提出抱怨。
- en: Lines 15-18 encapsulate how to resolve this issue. When you’re in a `static`
    context and you want to access an instance member (variable or method), you need
    to create an object instance to refer to the instance member. Therefore, on line
    15, we create an (object) instance of the class containing the instance member,
    namely `PersonExample`, and store the reference in an identifier, `pe`. Now that
    we have an instance, we can access the instance members, which we do on lines
    16, 17 and 18\. Line 16 successfully changes `x` from (its default value of) 0
    to 999\. This is what is output on line 18\. Line 17 shows that access to `m`
    is not an issue either. Note that you must comment out lines 9-12 before the code
    will compile and run.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 第15-18行封装了解决这个问题的方法。当你处于`static`上下文并且想要访问实例成员（变量或方法）时，你需要创建一个对象实例来引用实例成员。因此，在第15行，我们创建了一个包含实例成员的类（对象）的实例，即`PersonExample`，并将引用存储在一个标识符`pe`中。现在我们有了实例，我们可以访问实例成员，我们在第16、17和18行这样做。第16行成功将`x`从（其默认值）0更改为999。这是第18行输出的内容。第17行显示访问`m`也没有问题。请注意，在代码编译和运行之前，你必须注释掉第9-12行。
- en: Throughout these examples, we have used the `private` and `public` access modifiers.
    Let’s discuss these in more detail.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，我们使用了`private`和`public`访问修饰符。让我们更详细地讨论这些内容。
- en: Applying access modifiers
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用访问修饰符
- en: One of the cornerstones of OOP is the principle of *encapsulation* (data abstraction).
    Encapsulation can be achieved using access modifiers. Before we discuss encapsulation,
    we must understand the access modifiers themselves.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）的一个基石是*封装*（数据抽象）原则。封装可以通过访问修饰符来实现。在我们讨论封装之前，我们必须理解访问修饰符本身。
- en: 'Access modifiers determine where a class, field, or method is visible and therefore
    available for use. The level you are annotating at, determines the available access
    modifiers:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 访问修饰符决定了类、字段或方法的可见性和可用性。你正在注解的级别决定了可用的访问修饰符：
- en: '`public` or package-private (no keyword)'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public`或包私有（无关键字）'
- en: '`private`, package-private, `protected`, and `public`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`、包私有、`protected`和`public`'
- en: Let’s discuss these in turn.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次讨论这些内容。
- en: private
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: private
- en: A member marked as `private` is accessible within its own class only. In other
    words, the block scope of the class defines the boundary. When in a class (scope),
    you cannot access the `private` members of another class, even if you have an
    object reference to the class containing the `private` member.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为`private`的成员只能在它自己的类中访问。换句话说，类的块作用域定义了边界。当在一个类（作用域）中时，你不能访问另一个类的`private`成员，即使你有指向包含`private`成员的类的对象引用。
- en: Package-private
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包私有
- en: There is no special keyword for `package-private`. If a type (class, interface,
    record, or enum) has no access modifier then `package-private` is applied. Types
    that are `package-private` are only visible within the same package. Recall that
    a package is simply a named group of related types.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`package-private`没有特殊的关键字。如果一个类型（类、接口、记录或枚举）没有访问修饰符，则应用`package-private`。`package-private`的类型仅在同一包内可见。回想一下，包只是一个相关类型的命名组。
- en: The `Person` class (line 3) in *Figure 8**.11* is a `package-private` class,
    meaning `Person` cannot be imported into another package. In addition, the `Person`
    constructor (line 6) is package-private, meaning that you cannot create an object
    of the `Person` type from within a different package.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.11中的`Person`类（第3行）是一个`包私有`类，这意味着`Person`不能被导入到另一个包中。此外，`Person`构造函数（第6行）是包私有的，这意味着你无法从不同的包中创建`Person`类型的对象。'
- en: 'At a **member** level, there are a few exceptions to the preceding text that
    you need to be aware of when you omit the access modifier:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在成员级别，有一些例外情况需要你在省略访问修饰符时注意：
- en: Class/record members are, as above, `package-private` by default.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类/记录成员默认是`包私有`。
- en: Interface members are `public` by default.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口成员默认是`public`。
- en: Enum constants (members) are `public` `static` and `final` by default. Enum
    constructors are `private` by default. We will discuss enums later in the chapter.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举常量（成员）默认是`public` `static`和`final`。枚举构造函数默认是`private`。我们将在本章后面讨论枚举。
- en: The default package
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 默认包
- en: The default package is also known as the package with no name or the unnamed
    package. Types that have no explicit package statement at the top of the file
    are put into this package. This is the package where the `Person` and `PersonExample`
    classes from *Figure 8**.11* are placed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 默认包也被称为无名称包或未命名的包。在文件顶部没有显式包声明的类型会被放入这个包中。这就是放置了*图8**.11中的`Person`和`PersonExample`类的包。
- en: The implications of this are that, given the package has no name, if we are
    in a different (named) package, we have no way of importing `Person` and `PersonExample`.
    The fact that `PersonExample` is `public` (line 16) makes no difference. Therefore,
    only other types in the same (default) package can access them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的含义是，由于包没有名称，如果我们处于不同的（命名）包中，我们就无法导入`Person`和`PersonExample`。`PersonExample`是`public`（第16行）的事实并没有区别。因此，只有同一（默认）包中的其他类型可以访问它们。
- en: protected
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: protected
- en: A member marked as `protected` means that it’s visible within its own package
    (as with package-private) but also visible to subclasses outside of the package.
    We will discuss subclasses and `protected` in more detail when we cover inheritance
    in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为`protected`的成员意味着它在自己的包内可见（与包私有类似），但也可以被包外部的子类访问。当我们讨论继承时，我们将在[*第9章*](B19793_09.xhtml#_idTextAnchor205)中更详细地讨论子类和`protected`。
- en: public
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: public
- en: A type or member marked as `public` is visible everywhere. Thus, no boundaries
    apply.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为`public`的类型或成员在所有地方都是可见的。因此，没有边界限制。
- en: '*Table 8.2* summarizes the access modifiers and their visibility:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*表8.2*总结了访问修饰符及其可见性：'
- en: '![Table 8.2 – Access modifiers and their visibility](img/B19793_08_Table_02.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![表8.2 – 访问修饰符及其可见性](img/B19793_08_Table_02.jpg)'
- en: Table 8.2 – Access modifiers and their visibility
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 表8.2 – 访问修饰符及其可见性
- en: Let’s examine *Table 8.2* horizontally. Only the class has access to members
    marked as `private`. If a class or member has no access modifier (package-private),
    then that class or member is only visible within the class and the package. If
    the member is marked as `protected`, then the member is visible to the class,
    package, and subclasses of that class, regardless of the package. Finally, if
    a class or member is marked as `public`, then the class or member is visible everywhere.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们水平地检查*表8.2*。只有类可以访问标记为`private`的成员。如果一个类或成员没有访问修饰符（包私有），那么这个类或成员只能在类和包内部可见。如果成员被标记为`protected`，那么这个成员对类、包以及该类的子类都是可见的，无论包如何。最后，如果一个类或成员被标记为`public`，那么这个类或成员在所有地方都是可见的。
- en: 'To further help explain *Table 8.2*, let’s diagram an example suite of classes
    and their associated packages and draw up another visibility table specifically
    for it. *Figure 8**.13* shows this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步解释*表8.2*，让我们绘制一个示例类集及其相关包的图，并为其制作另一个专门的可见性表。*图8**.13展示了这一点：
- en: '![Figure 8.13 – Sample example access modifiers diagram](img/B19793_08_13.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13 – 示例访问修饰符图](img/B19793_08_13.jpg)'
- en: Figure 8.13 – Sample example access modifiers diagram
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13 – 示例访问修饰符图
- en: 'In this figure, the `Dog` class is in bold and underlined because the following
    table, *Table 8.3*, represents the visibility of *its* members. For example, when
    reading the `private` row, assume that we have marked a member in `Dog` as `private`
    and are determining its visibility in the other classes. Let’s examine *Table
    8.3*:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`Dog` 类被加粗并下划线，因为下面的表格，*表 8.3*，代表了其成员的可见性。例如，当阅读 `private` 行时，假设我们在 `Dog`
    中标记了一个成员为 `private`，并正在确定它在其他类中的可见性。让我们来查看 *表 8.3*：
- en: '![Table 8.3 – Visibility when modifiers are applied to a Dog member](img/B19793_08_Table_03.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![表 8.3 – 当应用于 Dog 成员时修饰符的可见性](img/B19793_08_Table_03.jpg)'
- en: Table 8.3 – Visibility when modifiers are applied to a Dog member
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 表 8.3 – 当应用于 Dog 成员时修饰符的可见性
- en: Thus, if a `Dog` member is `private`, only `Dog` can see it. If the `Dog` member
    is package-private, only `Dog` and `Cat` can see it. If the `Dog` member is `protected`,
    `Dog` and `Cat` can see it. Lastly, if the `Dog` member is `public`, every class
    can see it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果一个 `Dog` 成员是 `private`，只有 `Dog` 可以看到它。如果 `Dog` 成员是包私有，只有 `Dog` 和 `Cat`
    可以看到它。如果 `Dog` 成员是 `protected`，`Dog` 和 `Cat` 可以看到它。最后，如果一个 `Dog` 成员是 `public`，每个类都可以看到它。
- en: (*) We will complete this table when revisiting `protected` in the inheritance
    chapter.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: (*) 我们将在继承章节回顾 `protected` 时完成这个表格。
- en: How do access levels affect you?
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 访问级别如何影响你？
- en: Access levels will affect you in two ways. Firstly, you could be using an external
    class (from the Java API, for example) and want to know if you can use that class
    and/or its members in your code. Secondly, when writing a class, you will want
    to decide the access level each class and member will have. A good rule of thumb
    is to keep your members as `private` as possible to avoid misuse. Additionally,
    avoid `public` fields unless they are constants. We will discuss this further
    when we discuss encapsulation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 访问级别将以两种方式影响你。首先，你可能会使用一个外部类（例如 Java API 中的类）并想知道你是否可以在你的代码中使用该类及其成员。其次，当编写一个类时，你将想要决定每个类和成员的访问级别。一个很好的经验法则是尽可能地将成员保持为
    `private` 以避免误用。此外，除非它们是常量，否则请避免使用 `public` 字段。我们将在讨论封装时进一步讨论这一点。
- en: Let’s look at these access modifiers in code. In particular, we will focus on
    the package and learn how to create one and how access is affected by its boundary.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这些访问修饰符在代码中的应用。特别是，我们将关注包，并学习如何创建一个包以及边界如何影响访问。
- en: packages
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包
- en: 'Recall that the fully qualified type name includes the package name. *A package
    defines a namespace*. For example, in *Figure 8**.13*, the `Dog` class in the
    `ch8.animals` package is fully qualified as `ch8.animals.Dog`. Therefore, a `Dog`
    class in a package named `kennel` would have a qualified name of `kennel.Dog`;
    which is completely different to `ch8.animals.Dog`. Thus, Java can distinguish
    between the two `Dog` types and no name collisions occur. As we shall see, the
    package structure is also used as a directory structure for your java files. Oracle
    gives very good guidelines (see [https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html))
    on how to name your packages so that your types do not conflict with someone else’s.
    Package names are written in all lowercase letters to differentiate them from
    type names. Following that, companies should use reverse internet domain names
    to begin their package names. For example, if you work at a company called `somecompany.com`
    and you are creating a package called `somepackage`, then the full package name
    should be `com.somecompany.somepackage`. Within a company, naming can then follow
    company conventions, such as including the region: `com.somecompany.region.somepackage`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，完全限定类型名称包括包名。*包定义了一个命名空间*。例如，在 *图 8**.13* 中，`ch8.animals` 包中的 `Dog` 类完全限定为
    `ch8.animals.Dog`。因此，一个名为 `kennel` 的包中的 `Dog` 类将有完全限定的名称 `kennel.Dog`；这与 `ch8.animals.Dog`
    完全不同。因此，Java 可以区分这两种 `Dog` 类型，并且不会发生名称冲突。正如我们将看到的，包结构也被用作你的 java 文件的目录结构。Oracle
    提供了非常好的指南（见 [https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html](https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html)），说明如何命名你的包，以便你的类型不会与其他人的冲突。包名全部使用小写字母书写，以区分类型名称。随后，公司应使用反向互联网域名来开始它们的包名。例如，如果你在名为
    `somecompany.com` 的公司工作，并且你正在创建一个名为 `somepackage` 的包，那么完整的包名应该是 `com.somecompany.somepackage`。在公司内部，命名可以遵循公司惯例，例如包括地区：`com.somecompany.region.somepackage`。
- en: 'Let’s examine the packages from *Figure 8**.13*. We will start with `ch8.animals`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查 *图 8**.13* 中的包。我们将从 `ch8.animals` 开始：
- en: '![Figure 8.14 – The “ch8.animals” package from Figure 8.13](img/B19793_08_14.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14 – 图8.13中的“ch8.animals”包](img/B19793_08_14.jpg)'
- en: Figure 8.14 – The “ch8.animals” package from Figure 8.13
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 图8.13中的“ch8.animals”包
- en: 'In this figure, note that, for simplicity, we have grouped the two classes
    in the package into one Java file. This file is called `Dog.java` (as the `public`
    class is `Dog`). The first line is important: `package ch8.animals` states that
    the types (classes and so forth), that are defined here, go into this package.
    In addition, the file Dog.java will be put into a folder on the hard disk named
    `ch8\animals`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，为了简单起见，我们将包中的两个类组合到一个Java文件中。这个文件叫做`Dog.java`（因为`public`类是`Dog`）。第一行很重要：`package
    ch8.animals`表示在这里定义的类型（类等）将放入这个包中。此外，Dog.java文件将被放入硬盘上名为`ch8\animals`的文件夹中。
- en: In this figure, line 4 defines a `private` instance variable called `dogName`.
    This is accessible within the class only (as per lines 6 and 9) but not outside
    the class (as per line 18).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第4行定义了一个名为`dogName`的`private`实例变量。这个变量只能在类内部访问（如第6行和第9行所示），但不能在类外部访问（如第18行所示）。
- en: Line 5 defines a `protected` instance variable called `age` which we can access
    from another class within the package (line 19). Line 12 defines a package-private
    method called `pkgPrivate()` and line 20 shows that we can access it from another
    class in the same package. Note also that the `Cat` class and its constructor
    are both package-private (lines 14 and 15, respectively).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行定义了一个名为`age`的`protected`实例变量，我们可以在包内的另一个类中访问它（第19行）。第12行定义了一个名为`pkgPrivate()`的包私有方法，第20行显示我们可以从同一包内的另一个类中访问它。注意，`Cat`类及其构造函数都是包私有（分别在第14行和第15行）。
- en: '*Figure 8**.15* shows the other package, `ch8.farm`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.15*显示了另一个包，`ch8.farm`：'
- en: '![Figure 8.15 – The “ch8.farm” package from Figure 8.13](img/B19793_08_15.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图8.15 – 图8.13中的“ch8.farm”包](img/B19793_08_15.jpg)'
- en: Figure 8.15 – The “ch8.farm” package from Figure 8.13
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 图8.13中的“ch8.farm”包
- en: Again, note that line 1 states the package name – this is the `ch8.farm` package.
    The filename is `Pig.java` (as the `public` class is `Pig`) and the file will
    be put into a folder on the hard disk named `ch\farm`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，第1行声明了包名——这是`ch8.farm`包。文件名为`Pig.java`（因为`public`类是`Pig`），文件将被放入硬盘上名为`ch\farm`的文件夹中。
- en: Note the use of the fully qualified names when importing (lines 3 and 4). As
    we want access to the `Dog` class which resides in a separate package, we must
    import it. There is no issue importing `Dog` since it is `public`. However, we
    are unable to import `Cat` as `Cat` is package-private (and we are in a different
    package).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意导入时使用完全限定名（第3行和第4行）。因为我们想访问位于单独包中的`Dog`类，我们必须导入它。导入`Dog`没有问题，因为它是`public`的。然而，我们无法导入`Cat`，因为`Cat`是包私有（而且我们处于不同的包中）。
- en: 'Line 8 demonstrates that `Pig` can create a `Dog` object. Note that there are
    two access points here: the `Dog` class is `public` (so we can `import` it); and
    the `Dog` constructor is also `public` (so we can create an instance of `Dog`
    from code in a different package). This is why the access modifiers for the class
    and constructors should match. Line 9 shows that, when we are in a different package,
    we do not have access to package-private members from another package.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行演示了`Pig`可以创建一个`Dog`对象。注意这里有两个访问点：`Dog`类是`public`的（因此我们可以`import`它）；`Dog`构造函数也是`public`的（因此我们可以从不同包中的代码创建`Dog`的实例）。这就是为什么类和构造函数的访问修饰符应该匹配。第9行显示，当我们处于不同的包中时，我们没有权限访问来自另一个包的包私有成员。
- en: Now that we understand access modifiers, we are in a position to discuss encapsulation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了访问修饰符，我们可以讨论封装。
- en: Encapsulation
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 封装
- en: As previously stated, encapsulation is a key concept in OOP. The principle here
    is that you protect the data in your class and ensure that the data can only be
    manipulated (retrieved and/or changed) via your code. In other words, you have
    control over how external classes interact with your internal state (data). So,
    how do we do this?
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，封装是面向对象编程中的一个关键概念。这里的原理是保护你类中的数据，并确保数据只能通过你的代码进行操作（检索和/或更改）。换句话说，你控制外部类如何与你的内部状态（数据）交互。那么，我们如何做到这一点呢？
- en: Achieving encapsulation
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现封装
- en: Basic encapsulation is very easy to achieve. You simply mark your data as `private`
    and manipulate the data via `public` methods. Thus, external classes cannot access
    the data directly (as it is `private`); these external classes must go through
    your `public` methods to retrieve or change the data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 基本封装很容易实现。你只需将你的数据标记为 `private`，并通过 `public` 方法来操作数据。因此，外部类不能直接访问数据（因为它被标记为
    `private`）；这些外部类必须通过你的 `public` 方法来检索或更改数据。
- en: 'These `public` methods make up the class’s "interface"; in other words, how
    you interact with the class. This “interface” (group of `public` methods) is very
    different from and not to be confused with the `interface` language construct
    ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249)). *Figure 8**.16* presents a
    code example to help us further develop this topic:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `public` 方法构成了类的“接口”；换句话说，你如何与类交互。这个“接口”（一组 `public` 方法）与语言构造 `interface`（[第10章](B19793_10.xhtml#_idTextAnchor249)）非常不同，不应混淆。*图8.16*
    展示了一个代码示例，以帮助我们进一步探讨这个主题：
- en: '![Figure 8.16 – Basic encapsulation in action](img/B19793_08_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图8.16 – 基本封装的实际应用](img/B19793_08_16.jpg)'
- en: Figure 8.16 – Basic encapsulation in action
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 基本封装的实际应用
- en: In the preceding figure, the `Adult` class has two `private` instance variables,
    namely `name` and `age` (lines 4 and 5, respectively). Thus, these instance variables
    only have access within the `Adult` block of code. Note that even having an `Adult`
    object reference cannot bypass this access rule – the compiler error on (the commented
    out) line 29 demonstrates this.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`Adult` 类有两个 `private` 实例变量，分别是 `name` 和 `age`（分别在第4行和第5行）。因此，这些实例变量只能在
    `Adult` 代码块内部访问。请注意，即使有一个 `Adult` 对象引用也无法绕过这个访问规则——第29行（注释掉的）上的编译错误证明了这一点。
- en: public class name and filename relationship
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 公共类名与文件名的关系
- en: In Java, the name of the `public` class must match the filename. In *Figure
    8**.16*, the `public` class is `BasicEncapsulation`. This means that the filename
    must be named `BasicEncapsulation.java`, which it is. This rule implies that you
    cannot have two `public` classes in the same file – that is why the `Adult` class
    is not `public`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，`public` 类的名称必须与文件名匹配。在 *图8.16* 中，`public` 类是 `BasicEncapsulation`。这意味着文件名必须是
    `BasicEncapsulation.java`，它确实是这样的。这个规则意味着你不能在同一个文件中有两个 `public` 类——这就是为什么 `Adult`
    类不是 `public` 的。
- en: What if we were in a different package and we wanted to create an `Adult` object,
    as defined in *Figure 8**.16*? This is an issue because `Adult` is package-private
    (line 3). To fix this issue, we need to make the `Adult` class `public` so that
    we can `import` it when in a different package. This means that we need to move
    the `Adult` class into a separate file, named `Adult.java`. In addition, both
    `Adult` and its constructor would need to be `public`. Why? Well, when we’re in
    a different package, the class being `public` enables us to `import` the class
    and the constructor being `public` enables us to create objects of the `Adult`
    type.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们处于不同的包中，并且想要创建一个如图 *8.16* 所示的 `Adult` 对象，会发生什么？这是一个问题，因为 `Adult` 是包私有的（第3行）。为了解决这个问题，我们需要将
    `Adult` 类设为 `public`，这样我们就可以在不同的包中 `import` 它。这意味着我们需要将 `Adult` 类移动到一个单独的文件中，命名为
    `Adult.java`。此外，`Adult` 及其构造函数都需要是 `public` 的。为什么？因为我们处于不同的包中时，类是 `public` 的使我们能够
    `import` 类，构造函数是 `public` 的使我们能够创建 `Adult` 类型的对象。
- en: The `Adult` constructor (line 7) has no access modifier and is therefore package-private.
    Thus, only classes within the same package can invoke this constructor. In other
    words, only classes in the `ch8` package (line 1) can create `Adult` objects.
    As `BasicEncapsulation` is also in `ch8`, the object creation on line 26 is fine.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adult` 构造函数（第7行）没有访问修饰符，因此是包私有的。因此，只有同一包内的类可以调用这个构造函数。换句话说，只有 `ch8` 包（第1行）中的类可以创建
    `Adult` 对象。由于 `BasicEncapsulation` 也在 `ch8` 包中，所以第26行的对象创建是正确的。'
- en: 'The rest of the `Adult` class (lines 11-20) provides the getter/setter method
    pairs for manipulating the object state (the instance variables). These getter/setter
    methods are also known as accessor/mutator methods, respectively. There is usually
    a pair for each instance variable and they follow this format (note that this
    is just an example):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`Adult` 类的其余部分（第11-20行）提供了用于操作对象状态（实例变量）的 getter/setter 方法对。这些 getter/setter
    方法也分别被称为访问器/修改器方法。通常每个实例变量都有一个对应的方法对，它们遵循以下格式（注意这只是一个示例）：'
- en: '[PRE4]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After creating the `Adult` object on line 26 in *Figure 8**.16*, we output the
    object state using the `public` accessor methods, `getName` and `getAge` (lines
    27-28). As these accessor methods are `public`, these methods are available to
    any class in any package. Given that `'John'` and `20` are output, we know our
    object was created correctly.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图8.16*的第26行创建`Adult`对象后，我们使用`public`访问器方法`getName`和`getAge`（第27-28行）输出对象状态。由于这些访问器方法是`public`的，这些方法对任何包中的任何类都是可用的。鉴于输出了`'John'`和`20`，我们知道我们的对象被正确创建。
- en: Let’s assume that we are the developers of the `Adult` class and require an
    adult to be 18 years or older. In addition, we will assume that the developer
    of the `BasicEncapsulation` class is unknown to us. Line 29 demonstrates that
    as our `Adult` data is `private`, it is protected from direct external corruption.
    This is exactly what encapsulation provides; it is its raison d’être!
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们是`Adult`类的开发者，并要求成年人的年龄必须是18岁或以上。此外，我们还将假设我们不知道`BasicEncapsulation`类的开发者。第29行展示了，由于我们的`Adult`数据是`private`的，它被保护免受直接外部破坏。这正是封装提供的东西；这正是它的存在理由！
- en: 'Line 30 demonstrates that the object’s state can still be corrupted. However,
    the corruption that’s done via the set/mutator method on line 30 is very different
    from the direct corruption on line 29\. As the author of the `Adult` class, we
    can control and therefore fix the corruption error in our `set` methods. The issue
    with our `set` (mutator) method is replicated in the constructor. *Figure 8**.17*
    addresses this (internal) corruption issue in both the constructor and mutator
    methods:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第30行展示了对象的状态仍然可能被破坏。然而，第30行通过set/mutator方法进行的破坏与第29行的直接破坏非常不同。作为`Adult`类的作者，我们可以控制和因此修复`set`（mutator）方法中的破坏错误。我们`set`（mutator）方法的问题在构造函数中也被复制。*图8.17*在构造函数和mutator方法中解决了这个（内部）破坏问题：
- en: '![Figure 8.17 – Ensuring “age” is at least 18](img/B19793_08_17.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![图8.17 – 确保年龄至少为18岁](img/B19793_08_17.jpg)'
- en: Figure 8.17 – Ensuring “age” is at least 18
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 确保年龄至少为18岁
- en: As `BasicEncapsulation` remains unchanged, it is not included in the preceding
    figure. Note that a new `isAgeOk` method has been introduced (lines 27-29). This
    method takes in an `int` parameter `age` and checks to see if it is `>= 18`. If
    so, the method returns `true`; otherwise, it returns `false`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BasicEncapsulation`保持不变，它不包括在先前的图中。请注意，已经引入了一个新的`isAgeOk`方法（第27-29行）。该方法接受一个`int`参数`age`并检查它是否`>=
    18`。如果是这样，该方法返回`true`；否则，它返回`false`。
- en: The `isAgeOk` method is invoked from the `setAge` mutator method (line 21).
    As the constructor calls `setAge` (line 8), it also avails of the age check logic.
    If an invalid age is passed into the constructor or `setAge`, an error value of
    –1 is set. Note that there are better ways to do this, but for now this is fine.
    When we run the program now, since the `age` value that is being passed into `setAge`
    is -99 (`john.setAge(-99)`), the instance variable `age` is set to the error value
    of –1.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`isAgeOk`方法是从`setAge`mutator方法（第21行）调用的。由于构造函数调用`setAge`（第8行），它也利用了年龄检查逻辑。如果将无效的年龄传递给构造函数或`setAge`，则设置错误值为-1。请注意，有更好的方法来做这件事，但现在这样是可以的。当我们现在运行程序时，由于传递给`setAge`的`age`值是-99（`john.setAge(-99)`），实例变量`age`被设置为错误值-1。'
- en: That covers basic encapsulation. We will now discuss a particular issue with
    basic encapsulation and how advanced encapsulation resolves it.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了基本的封装。我们现在将讨论基本封装的一个特定问题以及如何通过高级封装来解决它。
- en: Mastering advanced encapsulation
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 掌握高级封装
- en: The simple maxim of “private data, public methods” (where the `public` methods
    manipulate the data) goes a long way to ensuring proper encapsulation of your
    data. However, you are not completely safe just yet. In this section, we will
    review Java’s call by value principle, which is used when passing arguments to
    and returning values from methods. We will examine how this can present a subtle
    issue. Lastly, we will examine how to protect your code from encountering this
    issue in the first place.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: “私有数据，公共方法”的简单原则（其中`public`方法操作数据）在确保数据适当封装方面走得很远。然而，你仍然不完全安全。在本节中，我们将回顾Java的传值原则，该原则用于向方法传递参数和从方法返回值。我们将检查这可能会带来一个微妙的问题。最后，我们将检查如何保护你的代码，防止遇到这个问题。
- en: Call By value revisited
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传值调用再探讨
- en: In [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148), we discussed how, when passing
    arguments to methods, Java’s *call by value* mechanism creates *copies* of those
    arguments. We saw the need to be aware that when the argument is a reference,
    such as to an array, the called method can now manipulate the array object that
    the caller method is looking at.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第7章*](B19793_07.xhtml#_idTextAnchor148)，我们讨论了当向方法传递参数时，Java的*按值调用*机制会创建那些参数的*副本*。我们看到了意识到当参数是一个引用时，例如数组，被调用方法现在可以操作调用方法正在查看的数组对象的必要性。
- en: Similarly, when a method is *returning* something, call by value applies again.
    In other words, a copy is made of what you are returning. Depending on what the
    copy is of, this can result in encapsulation being broken or not. If you are returning
    `private` primitive data, then there is no issue – a copy of the primitive is
    returned and the client can do whatever it likes to the copy; your `private` primitive
    data is safe. As you may recall from [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148),
    copying primitives is like photocopying a sheet of paper. The photocopied sheet
    can be written on without it affecting the original copy.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当一个方法正在*返回*某些内容时，按值调用再次适用。换句话说，你返回的内容会创建一个副本。根据副本的内容，这可能会导致封装被破坏或不被破坏。如果你返回的是`private`原始数据，那么就没有问题——原始数据会返回一个副本，客户端可以对副本做任何它想做的事情；你的`private`原始数据是安全的。你可能还记得，从[*第7章*](B19793_07.xhtml#_idTextAnchor148)，复制原始数据就像复印一张纸。复印的纸张可以被写上内容，而不会影响原始副本。
- en: The issue
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'The issue arises if your `private` data is a reference (to an object). If the
    client receives a copy of the reference, then the client can manipulate your `private`
    object! From [*Chapter 7*](B19793_07.xhtml#_idTextAnchor148), you may recall that
    copying a reference is like copying a remote control to a TV. The new remote can
    change the channels on the same TV. *Figure 8**.18* presents code that breaks
    encapsulation:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的`private`数据是一个引用（到一个对象），问题就会出现。如果客户端收到这个引用的副本，那么客户端就可以操作你的`private`对象！从[*第7章*](B19793_07.xhtml#_idTextAnchor148)，你可能还记得，复制一个引用就像复制电视的遥控器一样。新的遥控器可以改变同一台电视的频道。*图8**.18*展示了破坏封装的代码：
- en: '![Figure 8.18 – Code that breaks encapsulation](img/B19793_08_18.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图8.18 – 破坏封装的代码](img/B19793_08_18.jpg)'
- en: Figure 8.18 – Code that breaks encapsulation
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18 – 破坏封装的代码
- en: In the preceding figure, the `Seniors` class has two `private` instance variables
    (lines 6-7), namely `ages` and `num`. The constructor (lines 9-13) initializes
    the instance variables. We have a public `getNum` accessor method, which returns
    the `private` instance variable, `num` (line 14). Note that we have put this method
    on one line in the interest of space.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，`Seniors`类有两个`private`实例变量（第6-7行），即`ages`和`num`。构造函数（第9-13行）初始化实例变量。我们有一个公共的`getNum`访问器方法，它返回`private`实例变量`num`（第14行）。请注意，我们为了节省空间，把这个方法放在了一行。
- en: We have another accessor method called `getAges` (lines 15-17) that returns
    a `private` array called `ages`. *Line 16 is the problem* as it breaks encapsulation.
    We will explain why when we discuss the code in `main`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个名为`getAges`的访问器方法（第15-17行），它返回一个名为`ages`的`private`数组。*第16行是问题所在*，因为它破坏了封装。当我们讨论`main`中的代码时，我们将解释原因。
- en: 'In `main`, the first thing we do is create an instance of `Seniors` (line 21).
    This is so we can access the instance methods defined in `Seniors`. The rest of
    `main` is divided into two sections: one section (lines 23-27) demonstrates that
    returning `private` primitive data is fine; the other section (lines 30-37) demonstrates
    that simply returning `private` *references* breaks encapsulation.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`中，我们首先做的事情是创建一个`Seniors`的实例（第21行）。这样我们就可以访问`Seniors`中定义的实例方法。`main`的其余部分分为两部分：一部分（第23-27行）演示了返回`private`原始数据是可行的；另一部分（第30-37行）演示了仅仅返回`private`*引用*会破坏封装。
- en: Let’s examine the first section. Line 23 initializes the local variable, `num`,
    based on the return value from `seniors.getNum()`. As the `private` `Seniors`
    instance variable, `num`, was initialized to `2` in the `Seniors` constructor
    (line 10), the (completely separate) local variable, `num`, is initialized to
    `2`. We output this fact on line 24\. We then change the local `num` variable’s
    value to `-100` (line 25). The question now is, when we changed the local variable
    `num`, was the `private` `Seniors` instance variable, `num`, changed also? To
    find out, we can simply retrieve `num` again using the `public` accessor method,
    `getNum` (line 26). Line 27 outputs `2`, proving that the `private` primitive,
    `num`, was safe from changes made in `main`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查第一部分。第23行根据`seniors.getNum()`的返回值初始化局部变量`num`。由于`private`的`Seniors`实例变量`num`在`Seniors`构造函数（第10行）中被初始化为`2`，因此（完全独立的）局部变量`num`也被初始化为`2`。我们在第24行输出了这一事实。然后我们将局部`num`变量的值更改为`-100`（第25行）。现在的问题是，当我们更改局部变量`num`时，`private`的`Seniors`实例变量`num`是否也被更改？为了找出答案，我们可以简单地使用公共访问器方法`getNum`（第26行）再次检索`num`。第27行输出`2`，证明`private`原始数据`num`在`main`中做出的更改是安全的。
- en: The second section is where things get interesting. Line 30 initializes a local
    variable called `copyAges` based on the return value from the `public` accessor
    method, `seniors.getAges()`. As `getAges` simply returns (a copy of) the `private`
    `ages` reference, we now have two references referring to the one array object.
    These references are the `private` instance variable, `ages`, and the local variable,
    `copyAges`. Line 31 outputs the values of `copyAges`, which are `30` and `40`
    for the indices `0` and `1`, respectively. These are the same values that the
    `private` `ages` array was initialized to in the `Seniors` constructor (lines
    11-12).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分是事情变得有趣的地方。第30行根据`public`访问器方法`seniors.getAges()`的返回值初始化局部变量`copyAges`。由于`getAges`只是返回（一个副本的）`private`的`ages`引用，我们现在有两个引用指向同一个数组对象。这些引用是`private`实例变量`ages`和局部变量`copyAges`。第31行输出了`copyAges`的值，对于索引`0`和`1`分别是`30`和`40`。这些是`private`的`ages`数组在`Seniors`构造函数（第11-12行）中初始化时的相同值。
- en: 'Now, on lines 34-35, we change the values of the `copyAges` array: index `0`
    is set to `-9` and index `1` is set to `-19`. As with the first section, we are
    now wondering, did changing the local array have any effect on the `private` instance
    array in `Seniors`? The answer is yes! To prove this, we can retrieve the `private`
    array again using `getAges` (line 36) and output its values (line 37). The output
    values of `-9` and `-19` demonstrate that the client, `AdvancedEncapsulation`,
    was able to manipulate (change) the so-called `private` data of `Seniors`. Therefore,
    `Seniors` is not encapsulated after all.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在第34-35行，我们更改了`copyAges`数组中的值：索引`0`被设置为`-9`，索引`1`被设置为`-19`。与第一部分一样，我们现在想知道，更改局部数组是否对`Seniors`中的`private`实例数组有任何影响？答案是肯定的！为了证明这一点，我们可以再次使用`getAges`（第36行）检索`private`数组并输出其值（第37行）。输出值`-9`和`-19`表明客户端`AdvancedEncapsulation`能够操作（更改）所谓的`Seniors`的`private`数据。因此，`Seniors`最终并没有实现封装。
- en: '*Figure 8**.19* shows the situation in memory, shedding light on why `Seniors`
    is not encapsulated:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.19*展示了内存中的情况，揭示了为什么`Seniors`没有实现封装：'
- en: '![Figure 8.19 – In-memory representation of Figure 8.18 (at line 37)](img/B19793_08_19.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19 – 图8.18（第37行）的内存表示](img/B19793_08_19.jpg)'
- en: Figure 8.19 – In-memory representation of Figure 8.18 (at line 37)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 图8.18（第37行）的内存表示
- en: In the preceding figure, the local variable, `num`, is on the stack. It is a
    copy of the `private` `Seniors` `num` instance variable, and its different values
    as we progress through `main` are reflected in strikethrough font. Line 25 (*Figure
    8**.18*) changes the local variable to `-100`. As can be seen, this change does
    not affect the `private` instance variable, `num`, in `Seniors`, which remains
    `2`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，局部变量`num`位于栈上。它是`private`的`Seniors`实例变量`num`的一个副本，并且随着我们通过`main`的进展，其不同的值以删除线字体反映出来。第25行（*图8**.18*）将局部变量更改为`-100`。如所见，这种更改不会影响`Seniors`中的`private`实例变量`num`，它仍然为`2`。
- en: The issue is with the reference to the `private` array object, `ages`. Because
    `getAges` (line 15) simply returns the reference, a copy of that reference is
    stored in the local variable, `copyAges` (line 30). As the local reference, `copyAges`,
    and the `private` reference, `ages`, now refer to the same object, the copy reference
    can change the `private` array object. That is why the array object has values
    of `-9` and `-19` for indices `0` and `1`, respectively. The `copyAges2` reference
    is just there to prove that point.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在 `private` 数组对象 `ages` 的引用上。因为 `getAges`（第 15 行）只是返回引用，所以这个引用的副本被存储在局部变量
    `copyAges`（第 30 行）。由于局部引用 `copyAges` 和 `private` 引用 `ages` 现在指向同一个对象，副本引用可以更改
    `private` 数组对象。这就是为什么数组对象在索引 `0` 和 `1` 分别有 `-9` 和 `-19` 的值。`copyAges2` 引用只是用来证明这一点。
- en: The solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Now that we know the issue, fixing it is quite straightforward. The key is
    to, when returning a reference, ensure that you simply do not return the `private`
    reference (as call by value will return a copy of that reference). The solution
    is to *make a copy of the object you wish to return and return a reference to
    the new object*. Thus, the external class (client) can manipulate this new object
    without affecting your private internal object. *Figure 8**.20* is the properly
    encapsulated, refactored version of *Figure 8**.18*:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了问题，修复它就相当直接了。关键是，在返回引用时，确保你简单地不要返回 `private` 引用（因为按值调用将返回该引用的副本）。解决方案是
    *复制你希望返回的对象，并返回对新对象的引用*。这样，外部类（客户端）就可以操作这个新对象，而不会影响你的私有内部对象。*图 8.20* 是正确封装、重构后的
    *图 8.18* 版本：
- en: '![Figure 8.20 – Properly encapsulated code](img/B19793_08_20.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.20 – 正确封装的代码](img/B19793_08_20.jpg)'
- en: Figure 8.20 – Properly encapsulated code
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.20 – 正确封装的代码
- en: In the preceding figure, we have replaced the accessor method, `getAges`, with
    a new version (lines 15-18). This new version is properly encapsulated. On line
    16, instead of simply returning the (reference to the) array instance variable,
    we are copying the array, `ages`, into a new array, namely `newArr`. We achieve
    this using the `Arrays.copyOf` method. We return a (copy of the) reference to
    the new array object.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，我们用一个新的版本（第 15-18 行）替换了访问器方法 `getAges`。这个新版本是正确封装的。在第 16 行，我们不是简单地返回数组实例变量（或其引用），而是将数组
    `ages` 复制到一个新的数组，即 `newArr`。我们使用 `Arrays.copyOf` 方法实现这一点。我们返回新数组对象的（副本）引用。
- en: 'Now, on line 24, when we initialize `copyAges`, it is referring to the copy
    array that was created on line 16\. That reference, `newArr`, has gone out of
    scope (since we returned from `getAges`) but the new array object is still on
    the heap, with `copyAges` referring to it. The important point here is that on
    line 25, we have two distinct array references: the `ages` instance and the local
    `copyAges`. These references now refer to two *different* objects.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在第 24 行，当我们初始化 `copyAges` 时，它指的是在第 16 行创建的副本数组。这个引用 `newArr` 已经超出作用域（因为我们从
    `getAges` 返回），但新的数组对象仍然在堆上，`copyAges` 指向它。这里的重要点是，在第 25 行，我们有两个不同的数组引用：`ages`
    实例和局部 `copyAges`。这些引用现在指向两个 *不同* 的对象。
- en: 'Line 25 outputs the details of the copy array; `30` for index `0` and `40`
    for index `1`. This is as expected. Lines 26 and 27 change the contents of the
    copy array indices, `0` and `1`, to `-9` and `-19`, respectively. Now, we need
    to check something: when we changed the contents of the `copyAges` array, were
    the contents of the `private` internal `Seniors` array’s `ages` changed? To check,
    on line 28, we can initialize a `copyAges2` array with the (copy of the) contents
    of the `private` array, `ages`. When we output the details of `copyAges2` on line
    29, we get `30` and `40`, thereby proving that the `private` internal array, `ages`,
    was *not* changed when we changed the local `copyAges` array (lines 26-27). Now,
    `Seniors` is properly encapsulated.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 第 25 行输出了副本数组的详细信息；索引 `0` 为 `30`，索引 `1` 为 `40`。这是预期的。第 26 和 27 行将副本数组索引 `0`
    和 `1` 的内容分别更改为 `-9` 和 `-19`。现在，我们需要检查一下：当我们更改 `copyAges` 数组的内容时，`private` 内部 `Seniors`
    数组的 `ages` 内容是否也改变了？为了检查，在第 28 行，我们可以使用 `private` 数组 `ages` 的（副本）内容初始化一个 `copyAges2`
    数组。当我们输出第 29 行的 `copyAges2` 的详细信息时，我们得到 `30` 和 `40`，从而证明当我们更改局部 `copyAges` 数组（第
    26-27 行）时，`private` 内部数组 `ages` 并没有改变。现在，`Seniors` 已经被正确封装。
- en: '*Figure 8**.21* show this situation in memory as we execute line 29:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 8.21* 展示了在执行第 29 行时内存中的这种情况：'
- en: '![Figure 8.21 – In-memory representation of Figure 8.20](img/B19793_08_21.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.21 – 图 8.20 的内存表示](img/B19793_08_21.jpg)'
- en: Figure 8.21 – In-memory representation of Figure 8.20
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 图8.20的内存表示
- en: In the preceding figure, just after the `Seniors` object is constructed (line
    22), we have a `seniors` reference on the stack referring to a `Seniors` object
    on the heap. The `Seniors` object contains a `num` primitive set to 2 (line 10)
    and an `ages` array reference referring to the array object (lines 11-12).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，就在`Seniors`对象构建之后（第22行），堆栈上有一个`seniors`引用，指向堆上的`Seniors`对象。`Seniors`对象包含一个设置为2的`num`原始值（第10行）和一个指向数组对象的`ages`数组引用（第11-12行）。
- en: When we call `getAges` (line 24), the copy array, `newArr`, is created (line
    16) and although not shown here, the new array initially contains the values of
    `30` and `40` (indices `0` and `1`, respectively), as per line 25\. When `newArr`
    is returned from `getAges` (line 17), the (copy of the) reference is assigned
    to `copyAges` (line 24). As shown in the preceding diagram, the `copyAges` local
    variable and the `ages` instance variable refer to two different array objects.
    This is what we want. *Any changes made using* `copyAges` *will not affect the
    private* *array* `ages`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`getAges`（第24行）时，复制数组`newArr`被创建（第16行），尽管这里没有显示，但新数组最初包含`30`和`40`的值（分别对应索引`0`和`1`），如第25行所示。当`newArr`从`getAges`返回（第17行）时，（副本的）引用被分配给`copyAges`（第24行）。如前图所示，`copyAges`局部变量和`ages`实例变量指向两个不同的数组对象。这正是我们想要的。*使用*
    `copyAges` *所做的任何更改都不会影响私有数组* `ages`。
- en: This is what the changes on lines 26-27 demonstrate. The changes that were made
    using the `copyAges` reference are reflected in the diagram. To prove that the
    changes on lines 26-27 did not affect the `private` array, `ages`, we call `getAges`
    again. A new array, representing a copy of the `private` array, is again created
    (line 16) and the (copy of) the new array reference is returned and assigned to
    the local reference, `copyAges2`. When we output the new array’s contents on line
    29, we get `30` and `40`, demonstrating that the `private` array is unaffected
    by changes to the local array (lines 26-27).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是第26-27行所做的更改所展示的内容。使用`copyAges`引用所做的更改反映在图中。为了证明第26-27行的更改没有影响`private`数组`ages`，我们再次调用`getAges`。一个新的数组，代表`private`数组的副本，再次被创建（第16行），并且（副本的）新数组引用被返回并分配给局部引用`copyAges2`。当我们输出第29行的新数组内容时，我们得到`30`和`40`，这表明`private`数组没有受到局部数组（第26-27行）更改的影响。
- en: Now that we understand call by value and advanced encapsulation, we are in an
    excellent position to discuss the object life cycle.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了按值传递和高级封装，我们处于一个很好的位置来讨论对象生命周期。
- en: Delving into the object life cycle
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入了解对象生命周期
- en: To understand Java, it is extremely helpful to have an appreciation of what
    is happening in the background, in memory. This section will help cement what
    is happening on the stack and the heap when we call methods, declare local/instance
    variables, and so forth.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Java，了解后台在内存中发生的事情非常有帮助。本节将帮助我们巩固在调用方法、声明局部/实例变量等时堆栈和堆上发生的事情。
- en: Local variables are kept on the stack (for fast access), whereas instance variables
    and objects live on the heap (a large area of memory). As we know, we use the
    `new` keyword to create a Java object. The `new` keyword allocates space on the
    heap for the object and returns the reference to the object. What happens if the
    object is no longer accessible? For example, the reference may have gone out of
    scope. How do we reclaim that memory? This is where garbage collection comes into
    play.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 局部变量保存在堆栈上（以便快速访问），而实例变量和对象则存在于堆上（一大块内存区域）。正如我们所知，我们使用`new`关键字来创建Java对象。`new`关键字在堆上为对象分配空间，并返回对象的引用。如果对象不再可访问会发生什么？例如，引用可能已经超出作用域。我们如何回收那块内存？这就是垃圾回收发挥作用的地方。
- en: Garbage collection
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: As mentioned previously, garbage collection reclaims memory taken up by objects
    that are no longer being used; as in the objects have no references pointing to
    them. This garbage collection process is a JVM process that runs in the background.
    The JVM may decide during an idle time to run garbage collection and then it may
    not. Simply put, we have no control over when garbage collection runs. Even if
    we invoke `System.gc()`, this is but a suggestion to the JVM to run garbage collection
    – the JVM is free to ignore this suggestion. The major advantage of garbage collection
    is that we do not have to do the tidy-up ourselves; whereas in languages such
    as C++, we do.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，垃圾回收会回收不再被使用的对象占用的内存；也就是说，没有引用指向这些对象。这个垃圾回收过程是JVM在后台运行的一个进程。JVM可能会在空闲时决定运行垃圾回收，也可能不会。简单来说，我们无法控制垃圾回收何时运行。即使我们调用了`System.gc()`，这也只是向JVM提出运行垃圾回收的建议——JVM可以自由地忽略这个建议。垃圾回收的主要优势是我们不需要自己进行清理；而在像C++这样的语言中，我们必须这样做。
- en: 'For further detail on Java Memory Management please see our previous book:
    [https://www.amazon.com/Java-Memory-Management-comprehensive-collection/     dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+     management+maaike%2Caps%2C148&sr=8-1](https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '想要了解更多关于Java内存管理的细节，请参阅我们之前出版的书籍：[https://www.amazon.com/Java-Memory-Management-comprehensive-collection/     dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+management+maaike&qid=1699112145&sprefix=java+memory+     management+maaike%2Caps%2C148&sr=8-1](https://www.amazon.com/Java-Memory-Management-comprehensive-collection/dp/1801812853/ref=sr_1_1?crid=3QUEBKJP46CN7&keywords=java+memory+
    management+maaike&qid=1699112145&sprefix=java+memory+management+maaike%2Caps%2C148&sr=8-1).'
- en: Object life cycle example
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象生命周期示例
- en: 'A sample program will help at this point. *Figure 8**.22* presents a program
    to suit our purposes:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，一个示例程序会有所帮助。*图8**.22* 展示了一个符合我们目的的程序：
- en: '![Figure 8.22 – Sample program to explain an object’s life cycle](img/B19793_08_22.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图8.22 – 解释对象生命周期的示例程序](img/B19793_08_22.jpg)'
- en: Figure 8.22 – Sample program to explain an object’s life cycle
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 解释对象生命周期的示例程序
- en: 'As this (simple and very contrived) program executes, three methods are pushed
    onto the stack, namely `main`, `tagAnimal`, and `setCountry`. *Figure 8**.23*
    represents the in-memory representation when we are just about to exit the `setCountry`
    method (line 19):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个（简单且非常人为的）程序执行时，有三个方法被推入栈中，分别是`main`、`tagAnimal`和`setCountry`。*图8**.23* 表示我们即将退出`setCountry`方法（第19行）时的内存表示：
- en: '![Figure 8.23 – In-memory representation of code in Figure 8.22](img/B19793_08_23.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图8.23 – 图8.22中代码的内存表示](img/B19793_08_23.jpg)'
- en: Figure 8.23 – In-memory representation of code in Figure 8.22
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.23 – 图8.22中代码的内存表示
- en: Let’s look at this in more detail.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个例子。
- en: The main method
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 主方法
- en: As can be seen from the previous two figures, line 9 creates the `Cow` object
    on the heap, and the local reference, `cow1`, on the stack in the frame for `main`,
    refers to it. The instance variables in the `Cow` object on the heap, namely `tag`
    and `country`, will be `null` at this point.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如前两个图所示，第9行在堆上创建了`Cow`对象，在`main`帧的栈上的局部引用`cow1`指向它。此时，堆上的`Cow`对象的实例变量，即`tag`和`country`，将是`null`。
- en: Line 10 assigns the value in `cow1` to another local reference in `main`, namely
    `cow2`. Now, at line 11, we have a frame for `main` on the stack with two local
    reference variables, namely `cow1` and `cow2`, both referring to the one `Cow`
    object on the heap.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 第10行将`cow1`中的值赋给`main`中的另一个局部引用，即`cow2`。现在，在第11行，我们在栈上有一个`main`的帧，包含两个局部引用变量，即`cow1`和`cow2`，它们都指向堆上的一个`Cow`对象。
- en: Line 11 uses the `cow2` reference to execute the instance method, `tagAnimal`.
    Thus, when inside the `tagAnimal` method (during this invocation), the `this`
    reference will be referring to whatever `cow2` is referring to (which is the `Cow`
    object on the heap). In addition, the `cow1` reference is passed as an argument
    to the `tagAnimal` method. This is not necessary as `tagAnimal` already has a
    reference to the `Cow` object (using `this`) but this program is just for example
    purposes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第11行使用`cow2`引用来执行实例方法`tagAnimal`。因此，当在`tagAnimal`方法内部（这次调用期间），`this`引用将指向`cow2`所指向的内容（即堆上的`Cow`对象）。此外，`cow1`引用被作为参数传递给`tagAnimal`方法。这并不是必要的，因为`tagAnimal`已经有一个指向`Cow`对象的引用（使用`this`），但这个程序只是为了示例目的。
- en: The tagAnimal method
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`tagAnimal` 方法'
- en: As with any method invocation, a stack frame for `tagAnimal` is pushed on the
    stack. As per call by value rules, `tagAnimal` (line 13) aliases the method parameter
    `cow` for `cow1` from line 11 (the method call). Thus, the `cow` reference in
    `tagAnimal` and the `cow1` reference in `main` are pointing at the same `Cow`
    object, which was created on line 9.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何方法调用一样，`tagAnimal` 的栈帧被压入栈中。根据按值调用规则，`tagAnimal`（第13行）将方法参数 `cow` 别名为来自第11行的
    `cow1`。因此，`tagAnimal` 中的 `cow` 引用和 `main` 中的 `cow1` 引用指向同一个 `Cow` 对象，该对象是在第9行创建的。
- en: 'As we know, the `this` reference refers to the object instance responsible
    for the method call – in this case, `cow2` (line 11). Therefore, the reference
    to `tag` on line 14 (which is `this.tag` in effect) is referring to the `tag`
    instance variable that can be accessed via `cow2`. As a result, line 14 creates
    a new `Tag` object on the heap and stores its reference in the `tag` instance
    variable of the `Cow` object, overwriting its previous default value of `null`.
    Note that at this point, given the contrived nature of this example, the `Cow`
    object is referred to by three different references: `cow1` and `cow2` in `main`;
    and `cow` in `tagAnimal`.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，`this` 引用指向负责方法调用的对象实例——在这种情况下，`cow2`（第11行）。因此，第14行的 `tag` 引用（实际上是 `this.tag`）是指向可以通过
    `cow2` 访问的 `tag` 实例变量。因此，第14行在堆上创建了一个新的 `Tag` 对象，并将其引用存储在 `Cow` 对象的 `tag` 实例变量中，覆盖了其先前的默认值
    `null`。请注意，鉴于这个例子是人为设计的，`Cow` 对象通过三个不同的引用被引用：`main` 中的 `cow1` 和 `cow2`；以及 `tagAnimal`
    中的 `cow`。
- en: Line 15 specifies a `String` literal of `"France"`. As `String` literals are
    objects, a `String` object is created on the heap. Using the `cow` reference,
    the `setCountry` method is called, passing down the `String` literal, `"France"`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 第15行指定了一个 `"France"` 的 `String` 文字。由于 `String` 文字是对象，因此在堆上创建了一个 `String` 对象。使用
    `cow` 引用，调用 `setCountry` 方法，传递 `String` 文字 `"France"`。
- en: The setCountry method
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`setCountry` 方法'
- en: A stack frame for `setCountry` is pushed onto the stack. The `setCountry` declaration
    aliases the method parameter `country` to refer to the `String` literal, “`France"`,
    which is passed down in the method call (line 15). Line 18 initializes the `country`
    instance variable to the argument passed down, namely `"France"`. Line 18 explicitly
    uses the `this` reference because the parameter name and instance variable have
    the same identifier, `country`. The *this* reference refers to whatever `cow`
    is referring to, which is the `Cow` object on the heap. This is because the `setCountry`
    method call (line 15) was executed on the reference `cow`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`setCountry` 的栈帧被压入栈中。`setCountry` 声明将方法参数 `country` 别名为引用 `String` 文字 `"France"`，它在方法调用中传递下来（第15行）。第18行将
    `country` 实例变量初始化为传递下来的参数，即 `"France"`。第18行明确使用了 `this` 引用，因为参数名和实例变量具有相同的标识符
    `country`。`this` 引用指向 `cow` 所指向的内容，即堆上的 `Cow` 对象。这是因为 `setCountry` 方法调用（第15行）是在
    `cow` 引用上执行的。'
- en: 'Now that we know how methods are pushed onto the stack, let’s examine the memory
    as we return from these method calls – in other words, as we pop the stack. *Figure
    8**.24* represents memory after we have exited the `setCountry` method but before
    we exit the `tagAnimal` method:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了方法是如何压入栈中的，那么让我们在从这些方法调用返回时检查内存——换句话说，当我们弹出栈时。*图8**.24* 表示在退出 `setCountry`
    方法但退出 `tagAnimal` 方法之前内存中的表示：
- en: '![Figure 8.24 – In-memory representation after the “setCountry” method completes](img/B19793_08_24.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![图8.24 – “setCountry”方法完成后内存中的表示](img/B19793_08_24.jpg)'
- en: Figure 8.24 – In-memory representation after the “setCountry” method completes
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.24 – “setCountry”方法完成后内存中的表示
- en: As can be seen from the preceding figure, the `setCountry` frame has been popped
    from the stack. However, the `String` object, `"France"`, remains on the heap
    because the `country` instance variable from the `Cow` instance object still refers
    to it. Only objects that have no references pointing to them are eligible for
    garbage collection.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`setCountry` 帧已从栈中弹出。然而，`String` 对象 `"France"` 仍然位于堆上，因为 `Cow` 实例对象中的
    `country` 实例变量仍然指向它。只有没有任何引用指向它们的对象才有资格进行垃圾回收。
- en: '*Figure 8**.25* represents the in-memory representation just after `tagAnimal`
    finishes but before `main` completes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '*图8**.25* 表示在 `tagAnimal` 方法完成但 `main` 方法完成之前内存中的表示：'
- en: '![Figure 8.25 – In-memory representation after the ‘tagAnimal” method completes](img/B19793_08_25.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
  zh: '![图8.25 – “tagAnimal”方法完成后内存中的表示](img/B19793_08_25.jpg)'
- en: Figure 8.25 – In-memory representation after the ‘tagAnimal” method completes
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25 – “tagAnimal”方法完成后内存表示
- en: There is very little change in this figure from the previous figure, except
    that the stack frame for `tagAnimal` has been popped. The `Cow` object on the
    heap cannot be garbage collected because both the references, `cow1` and `cow2`,
    in `main` refer to it. In addition, because the `Cow` object cannot be removed,
    neither can the `Tag` or `String` objects. This is because the `Cow` instance
    variables, `tag` and `country`, refer to them. This figure represents the situation
    in memory until `main` exits, at which point everything can be reclaimed.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个图相比，这个图几乎没有变化，只是 `tagAnimal` 的栈帧已经被弹出。堆上的 `Cow` 对象不能被垃圾回收，因为 `main` 中的两个引用
    `cow1` 和 `cow2` 都指向它。此外，由于 `Cow` 对象不能被移除，`Tag` 或 `String` 对象也不能被移除。这是因为 `Cow`
    实例变量 `tag` 和 `country` 指向它们。这个图表示了内存中的情况，直到 `main` 退出，此时可以回收一切。
- en: That concludes our discussion on an object’s life cycle. We will now move on
    and discuss the `instanceof` keyword.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对对象生命周期的讨论。现在，我们将继续讨论 `instanceof` 关键字。
- en: Explaining the instanceof keyword
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释 instanceof 关键字
- en: The `instanceof` keyword enables us to determine the object type that a reference
    is referring to. That is why it is so critical to separate the reference from
    the object. The reference’s type and the object’s type are often very different.
    In fact, in most cases, they are different. We will discuss `instanceof` in greater
    detail when we cover inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205))
    but also when we discuss interfaces ([*Chapter 10*](B19793_10.xhtml#_idTextAnchor249)).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`instanceof` 关键字使我们能够确定引用所引用的对象类型。这就是为什么将引用与对象分开是如此关键的原因。引用的类型和对象类型通常非常不同。事实上，在大多数情况下，它们是不同的。当我们讨论继承（[*第
    9 章*](B19793_09.xhtml#_idTextAnchor205)）以及接口（[*第 10 章*](B19793_10.xhtml#_idTextAnchor249)）时，我们将更详细地讨论
    `instanceof`。'
- en: 'So, for the moment, we will keep it simple – where the reference type and object
    type are the same. *Figure 8**.26* presents one such code example:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，目前我们将保持简单 – 当引用类型和对象类型相同时。*图 8.26* 展示了一个这样的代码示例：
- en: '![Figure 8.26 – Basic “instanceof” example](img/B19793_08_26.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.26 – 基本的“instanceof”示例](img/B19793_08_26.jpg)'
- en: Figure 8.26 – Basic “instanceof” example
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26 – 基本的“instanceof”示例
- en: In this figure, line 7 creates a `Dog` object referred to by a `Dog` reference
    named `dog`. Line 8 creates a `Cat` object referred to by a `Cat` reference named
    `cat`. Line 9 checks if the object at the end of the `dog` reference is “an instance
    of” `Dog`. It is, so line 10 executes. Similarly, line 12 checks to see if the
    object referred to by `cat` is of the `Cat` type. It is, so line 13 executes.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第 7 行创建了一个名为 `dog` 的 `Dog` 引用，它引用了一个 `Dog` 对象。第 8 行创建了一个名为 `cat` 的 `Cat`
    引用，它引用了一个 `Cat` 对象。第 9 行检查 `dog` 引用末尾的对象是否是 `Dog` 的“实例”。它是，所以第 10 行执行。同样，第 12
    行检查 `cat` 引用所引用的对象是否是 `Cat` 类型。它是，所以第 13 行执行。
- en: Line 15 is commented out as it generates a compiler error. As `Cat` and `Dog`
    are completely unrelated classes (lines 3-4), the compiler knows that there is
    no way a `Cat` reference, namely `cat`, can refer to a `Dog` object. Conversely,
    a `Dog` reference, such as `dog`, cannot refer to a `Cat` object.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 第 15 行被注释掉了，因为它会生成编译器错误。由于 `Cat` 和 `Dog` 是完全不相关的类（第 3-4 行），编译器知道没有一种方法可以让 `Cat`
    引用，即 `cat`，引用 `Dog` 对象。相反，`Dog` 引用，如 `dog`，也不能引用 `Cat` 对象。
- en: 'We will come back to `instanceof` later in this chapter. For now, let us move
    on to our next topic, which is closely related to classes: namely, enumerations.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面讨论 `instanceof`。现在，让我们继续讨论下一个主题，它与类密切相关：即枚举。
- en: Understanding enums
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解枚举
- en: '**Enumerations**, or **enums** for short, are a special type of class. Whereas
    with a class, you can have as many instances (of the class) as you wish; with
    enums, the instances are predefined and therefore restricted. Enums are very useful
    for situations where a finite set of values apply – for example, days of the week,
    seasons of the year, and directions.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**枚举**，或简称为 **enum**，是一种特殊类型的类。在类中，你可以有任意多的实例（类的实例）；而在枚举中，实例是预定义的，因此受到限制。枚举在适用于有限值集的情况下非常有用
    – 例如，一周中的日子、一年的季节和方向。'
- en: This ensures *type-safety* because, with the help of the compiler, only the
    instances defined are allowed. It is always better to find an issue at compile
    time than runtime. For example, if you had a method that defined a `String` parameter,
    namely `direction`, then someone could invoke the method with *"WESTT"* (note
    the incorrect spelling). The compiler would not catch this error as it is a valid
    `String`, so the error would manifest at runtime. If, however, the method parameter
    were an enum instead, the compiler would catch it. We will see this shortly.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了*类型安全*，因为有了编译器的帮助，只允许定义的实例。在编译时发现问题总是比在运行时更好。例如，如果你有一个定义了`String`参数的方法，即`direction`，那么有人可以用`"WESTT"`（注意拼写错误）调用该方法。编译器不会捕获这个错误，因为它是一个有效的`String`，所以错误会在运行时显现。然而，如果方法参数是一个枚举，编译器就会捕获它。我们很快就会看到这一点。
- en: 'There are two types of enums: simple and complex. We will discuss them now.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举有两种类型：简单和复杂。我们现在来讨论它们。
- en: Simple enums
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单枚举
- en: 'A simple enum is named as such because it is, well, simple. This is in the
    sense that when you look at the enum, there is very little code present. *Figure
    8**.27* presents code using a simple enum:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的枚举之所以被命名为“简单”，是因为它确实很简单。从某种意义上说，当你查看枚举时，代码很少。*图8.27*展示了使用简单枚举的代码：
- en: '![Figure 8.27 – A simple enum](img/B19793_08_27.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![图8.27 – 简单枚举](img/B19793_08_27.jpg)'
- en: Figure 8.27 – A simple enum
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.27 – 简单枚举
- en: In the preceding figure, the `Water` enum is defined (lines 3-5). The values
    of an enum are expressed in capital letters (similar to constants). It is not
    mandatory to do this but it is common practice. What this enum is saying is that
    we have an `enum` named `Water` and there are only two instances allowed, namely
    `STILL` and `SPARKLING`. In effect, `STILL` and `SPARKLING` are references to
    the only object instances allowed. The semicolon at the end of line 4 is optional
    for simple enums. The corresponding semicolon for complex enums is mandatory.
    The enum values are given ordinal values starting at `0`. So, for `Water`, `STILL`
    has an ordinal value of `0` and `SPARKLING` has an ordinal value of `1`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，定义了`Water`枚举（第3-5行）。枚举的值用大写字母表示（类似于常量）。这不是强制性的，但这是常见的做法。这个枚举所表达的意思是我们有一个名为`Water`的枚举，只允许有两个实例，即`STILL`和`SPARKLING`。实际上，`STILL`和`SPARKLING`是对唯一允许的对象实例的引用。第4行末尾的分号对于简单枚举是可选的。对于复杂枚举，相应的分号是强制性的。枚举值从`0`开始给出序号值。因此，对于`Water`，`STILL`的序号值为`0`，而`SPARKLING`的序号值为`1`。
- en: As stated previously, enums are a special type of class. However, there are
    some differences. One is that `enum` constructors are `private` by default. This
    includes the default constructor generated by the compiler (as in *Figure 8**.27*
    for `Water`). Contrast this with the default constructor of a class, which has
    the same access as the class itself. Thus, you cannot instantiate an enum as you
    would a normal object. This is why line 8 will not compile – the default `enum`
    constructor generated by the compiler is `private` and therefore inaccessible
    to external types.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，枚举是一种特殊类型的类。然而，也有一些区别。其中之一是枚举构造函数默认是`private`的。这包括编译器生成的默认构造函数（如*图8.27*中的`Water`）。与类的默认构造函数相比，它具有与类相同的访问权限。因此，你不能像普通对象那样实例化枚举。这就是为什么第8行不会编译——编译器生成的默认枚举构造函数是`private`的，因此对外部类型不可访问。
- en: So, if we cannot `new` an `enum`, how do we create an `enum` instance? In other
    words, where are the constructor calls? *The declaration of the enum values,*
    `STILL` *and* `SPARKLING`*, (line 4) are the constructor calls!* As they are within
    the class, they have access to the `private` constructor. These enum values are
    initialized only once – that is, when the enum is first used.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们不能使用`new`创建枚举实例，我们该如何创建枚举实例呢？换句话说，构造函数调用在哪里？*枚举值的声明，即* `STILL` *和* `SPARKLING`
    *，(第4行)就是构造函数调用！* 因为它们在类内部，所以它们可以访问`private`构造函数。这些枚举值只初始化一次——也就是说，当枚举首次使用时。
- en: So, to create an enum (object), use the relevant `enum` value. This is done
    on line 11, where we now have a reference, `stillWater`, referring to the `STILL`
    instance. Contrast line 11 with line 9 (which does not compile). Attempting to
    use any other value such as `EXTRA_SPARKLING` will not compile. This is the type
    safety we discussed previously. Only two instances of `Water` are allowed, `STILL`
    and `SPARKLING`, and the compiler enforces this rule.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要创建枚举（对象），请使用相关的枚举值。这是在第 11 行完成的，我们现在有一个引用 `stillWater`，它引用了 `STILL` 实例。将第
    11 行与第 9 行（无法编译）进行对比。尝试使用任何其他值，如 `EXTRA_SPARKLING`，将无法编译。这就是我们之前讨论的类型安全。只允许两个
    `Water` 实例，`STILL` 和 `SPARKLING`，编译器强制执行此规则。
- en: Lines 12 and 13 demonstrate that only one instance of `Water.STILL` is created.
    As the equivalence operator and the `equals` method both return `true`, there
    can be only one instance.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12 行和第 13 行演示了只创建了一个 `Water.STILL` 的实例。由于等价运算符和 `equals` 方法都返回 `true`，因此只能有一个实例。
- en: Inherited methods
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的方法
- en: Although inheritance will be discussed in detail in [*Chapter 9*](B19793_09.xhtml#_idTextAnchor205),
    we need to dip into the topic to understand enums. Every class in Java implicitly
    inherits from a class called `Object`. This means that there are methods in `Object`
    that you get by default. This is how Java ensures every class has certain important
    methods. You can accept the version from `Object` or replace it (known as *overriding*
    the method).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然继承将在第 9 章[*](B19793_09.xhtml#_idTextAnchor205)中详细讨论，但我们需要深入了解这个主题以理解枚举。Java
    中的每个类都隐式继承自一个名为 `Object` 的类。这意味着你可以默认获得 `Object` 中的方法。这就是 Java 确保每个类都有某些重要方法的方式。你可以接受来自
    `Object` 的版本或替换它（称为 *重写* 方法）。
- en: One of these methods that’s inherited from `Object` is `equals`. The version
    in `Object` compares the references to see if they are equal and returns `true`
    or `false` depending on that comparison. Essentially, this is the same as using
    `==` to compare the references.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `Object` 继承来的这些方法之一是 `equals`。`Object` 中的版本比较引用以查看它们是否相等，并根据该比较返回 `true` 或
    `false`。本质上，这与使用 `==` 来比较引用相同。
- en: Enums implicitly inherit from the `Enum` class (and `Enum` inherits from `Object`,
    so there is no escaping `Object`!). Thus, enums have access to methods such as
    `valueOf`, `values`, `ordinal`, and `name`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举隐式继承自 `Enum` 类（`Enum` 继承自 `Object`，因此无法避免 `Object`！）。因此，枚举可以访问 `valueOf`、`values`、`ordinal`
    和 `name` 等方法。
- en: The `switch` statement (lines 14-20) switches on the `Water` reference, namely
    `stillWater` (line 14). The `case` label is the unqualified `enum` value (`STILL`,
    line 15). Line 18 shows that the qualified `enum` value is incorrect. Line 19
    (and line 21) demonstrate that even though `enum` values have ordinal values,
    enums are types and not integers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch` 语句（第 14-20 行）根据 `Water` 引用切换，即 `stillWater`（第 14 行）。`case` 标签是不带限定符的枚举值（`STILL`，第
    15 行）。第 18 行显示带限定符的枚举值是不正确的。第 19 行（和第 21 行）演示了即使枚举值有序号，枚举也是类型而不是整数。'
- en: Several interesting methods in the `Enum` type are available to us due to inheritance.
    Let’s start with `valueOf(String)`.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 由于继承，`Enum` 类型中存在一些有趣的方法可供我们使用。让我们从 `valueOf(String)` 开始。
- en: The valueOf(String) method
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`valueOf(String)` 方法'
- en: This is an implicitly declared method, which, when given one of the enum constant
    names, returns that enum instance (line 22). Thus, this method provides a quick
    and easy way to create an enum instance, once you know the constant name.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个隐式声明的方法，当给定一个枚举常量名称时，返回该枚举实例（第 22 行）。因此，此方法提供了一种快速简单的方法来创建枚举实例，一旦你知道常量名称。
- en: Let’s examine how we can iterate over all the enum instances using the `values()`
    method.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `values()` 方法遍历所有枚举实例。
- en: The values() method
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`values()` 方法'
- en: This is another implicit method. On line 25, we use an enhanced `for` loop to
    iterate over the enums in the order they are declared on line 4, namely `STILL`
    followed by `SPARKLING`. Once we have an enum instantiated, we can use other methods
    to get details of that particular enum.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种隐式方法。在第 25 行，我们使用增强型 `for` 循环按枚举声明的顺序遍历枚举，即第 4 行声明的 `STILL` 后跟 `SPARKLING`。一旦我们实例化了一个枚举，我们就可以使用其他方法来获取该特定枚举的详细信息。
- en: Let’s see how the `ordinal()` method provides the ordinal number for the enum.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `ordinal()` 方法是如何为枚举提供序号的。
- en: The ordinal() method
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ordinal()` 方法'
- en: The `ordinal()` method (line 28) returns the ordinal value of this enum. The
    initial `enum` constant is given an ordinal value of 0; therefore, `ordinal()`
    for `STILL` returns 0, and `ordinal()` for `SPARKLING` returns 1.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`ordinal()` 方法（第28行）返回此枚举的序数值。初始枚举常量被赋予序数值0；因此，`STILL` 的 `ordinal()` 返回0，而
    `SPARKLING` 的 `ordinal()` 返回1。'
- en: To determine an enum’s name, we can use the `name()` method.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定枚举的名称，我们可以使用 `name()` 方法。
- en: The name() method
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`name()` 方法'
- en: The `name()` method (line 28) returns the name of this `enum`, exactly as declared
    in the enum (line 4). For example, `name()` for `STILL` returns `"STILL"` and
    `name()` for `SPARKLING` returns `"SPARKLING"`. Note that rather than use the
    `name` method, the better option would be to override the `toString()` method
    as you can customize the `String` that’s displayed (to the user) to be more user-friendly.
    We will do a lot of this in inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`name()` 方法（第28行）返回此枚举的名称，与在枚举中声明的完全一致（第4行）。例如，`STILL` 的 `name()` 返回 `"STILL"`，而
    `SPARKLING` 的 `name()` 返回 `"SPARKLING"`。请注意，与其使用 `name` 方法，更好的选择是重写 `toString()`
    方法，因为你可以自定义显示（给用户）的 `String`，使其更友好。我们将在继承中做很多这样的操作（[*第9章*](B19793_09.xhtml#_idTextAnchor205)）。'
- en: Now that we have examined simple enums, let’s move on and discuss complex enums.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经检查了简单的枚举，让我们继续讨论复杂枚举。
- en: Complex enums
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂枚举
- en: As stated earlier, enums are a special type of class where the instances are
    finite. As simple enums are so straightforward, it can be a little harder to see
    the class/enum relationship. With complex enums, identifying the relationship
    between an enum and a class is much easier.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，枚举是一种特殊的类类型，其中实例是有限的。由于简单枚举非常直接，因此很难看到类/枚举之间的关系。对于复杂枚举，确定枚举与类之间的关系要容易得多。
- en: 'Complex enums have instance variables, constructors, and methods, so they are
    quite similar to classes. *Figure 8**.28* presents a complex enum for discussion:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂枚举具有实例变量、构造函数和方法，因此它们与类非常相似。*图8**.28* 展示了一个用于讨论的复杂枚举：
- en: '![Figure 8.28 – A complex enum](img/B19793_08_28.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![图8.28 – 一个复杂枚举](img/B19793_08_28.jpg)'
- en: Figure 8.28 – A complex enum
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.28 – 一个复杂枚举
- en: In this figure, we declare the `WorkDay` enum (lines 3-25). This `enum` encapsulates
    that we work 9 to 5, Monday to Friday at the office and 10 to 1 on Saturday from
    home. Presumably, we try to rest on Sunday!
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在此图中，我们声明了 `WorkDay` 枚举（第3-25行）。这个 `enum` 封装了我们在办公室从周一到周五9点到5点工作，周六在家从10点到1点工作的情况。假设我们在周日休息！
- en: The `enum` constants are declared from lines 5-13\. There is a `private` instance
    variable called `hoursOfWork` (line 15), which is initialized by the constructor
    (lines 16-18). Note that the constructor is `private` by default. The accessor
    method, `getHoursOfWork` (lines 19-21), is how external classes gain access to
    the `private` instance variable, `hoursOfWork`. The other accessor method, `getWorkLocation`
    (lines 22-24), assumes that we work from the office every day (a pre-pandemic
    assumption for sure!). The `SATURDAY` constant (lines 10-13) merits discussion
    and we will come to that shortly.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举常量从第5-13行声明。有一个名为 `hoursOfWork` 的 `private` 实例变量（第15行），它由构造函数（第16-18行）初始化。请注意，构造函数默认是
    `private` 的。访问器方法 `getHoursOfWork`（第19-21行）是外部类获取对 `private` 实例变量 `hoursOfWork`
    访问的方式。另一个访问器方法 `getWorkLocation`（第22-24行）假设我们每天都在办公室工作（当然，这是大流行前的假设！）。`SATURDAY`
    常量（第10-13行）值得讨论，我们很快就会谈到这一点。
- en: 'Let’s examine line 5 closely: this is *a constructor call* to the constructor
    that’s declared (lines 16-18). In other words, the `hoursOfWork` instance variable
    is set to `"9-5"` for `MONDAY`. The other constants – `TUESDAY`, `WEDNESDAY`,
    `THURSDAY`, and `FRIDAY` (lines 6-9) – are initialized similarly.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们仔细检查第5行：这是一个对已声明（第16-18行）的构造函数的调用。换句话说，`hoursOfWork` 实例变量被设置为 `"9-5"` 用于
    `MONDAY`。其他常量 – `TUESDAY`、`WEDNESDAY`、`THURSDAY` 和 `FRIDAY`（第6-9行） – 以类似方式初始化。
- en: What about `SATURDAY`? Since we haven’t covered inheritance yet, this may be
    a little tricky. What we are saying is that for Saturday, we only work from home.
    To do this, we have to replace (“override”) the default `getWorkLocation` method
    (lines 22-24). The default `getWorkLocation` method returns `"Office"` but our
    custom `getWorkLocation` (line 12) returns `"Home"` for `SATURDAY`. The `SATURDAY`
    constant defines a “constant specific class body,” which starts with the curly
    brace on line 10 and ends with the curly brace on line 13.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`SATURDAY`呢？由于我们还没有介绍继承，这可能会有些棘手。我们说的是，对于周六，我们只在家工作。要做到这一点，我们必须替换（覆盖）默认的`getWorkLocation`方法（第22-24行）。默认的`getWorkLocation`方法返回`"Office"`，但我们的自定义`getWorkLocation`（第12行）对于`SATURDAY`返回`"Home"`。`SATURDAY`常量定义了一个“特定于常量的类体”，它从第10行的花括号开始，到第13行的花括号结束。
- en: Note that the semicolon on line 13 *is* required at the end of the complex enum
    constants, regardless of whether they declare a constant specific class body or
    not. That particular semicolon (line 13) tells the compiler, “We have now finished
    defining the `enum` constants, so you can expect instance variables or constructors
    or methods from here on.”
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第13行的分号*是*在复杂枚举常量末尾必需的，无论它们是否声明特定于常量的类体。那个特定的分号（第13行）告诉编译器，“我们现在已经完成了枚举常量的定义，所以你可以从现在开始期望实例变量或构造函数或方法。”
- en: Now that we have defined our `enum`, let’s use it. Line 28 instantiates `MONDAY`,
    resulting in the enum constant (line 5) executing the constructor (lines 16-18),
    thereby initializing `hoursOfWork` for the `MONDAY` instance to `"9-5"`. Line
    29 proves this fact by outputting `"9-5"`. Line 30 calls the (default) version
    of `getWorkLocation` (lines 22-24), thereby outputting `"Office"` to the screen.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了我们的`enum`，让我们来使用它。第28行实例化`MONDAY`，导致枚举常量（第5行）执行构造函数（第16-18行），从而初始化`MONDAY`实例的`hoursOfWork`为`"9-5"`。第29行通过输出`"9-5"`来证明这一点。第30行调用（默认）版本的`getWorkLocation`（第22-24行），从而将`"Office"`输出到屏幕。
- en: Line 31 instantiates `SATURDAY` and outputs `"10-1"` for `hoursOfWork` as that
    is what is passed into the constructor from line 10\. Line 32 invokes the constant-specific
    version of `getWorkLocation` for `SATURDAY`, which outputs `"Home"` to the screen.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 第31行实例化`SATURDAY`，并将`hoursOfWork`输出为`"10-1"`，因为这是从第10行传递到构造函数的内容。第32行调用`SATURDAY`的特定版本`getWorkLocation`，将`"Home"`输出到屏幕。
- en: That completes our discussion on enumerations. Let us now discuss a very useful
    feature, namely records.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对枚举的讨论。现在让我们讨论一个非常有用的特性，即记录。
- en: Appreciating records
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 欣赏记录
- en: 'Records are a special type of class, and are considered “data carriers”. They
    help us avoid typing in copious amounts of boilerplate code. Records are specified
    using a record declaration where you list the *components* of the record. Implicitly
    generated in the background are a canonical constructor; `toString`, `equals`,
    and `hashCode` methods and `public` accessor methods for each of the components
    specified. The accessor methods take on the same names as the components themselves
    (as opposed to the more traditional `get` methods). Records are best explained
    by contrasting them to regular classes. *Figure 8**.29* presents a normal class
    with a lot of boilerplate code:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是一种特殊的类，被认为是“数据载体”。它们帮助我们避免输入大量的模板代码。记录通过记录声明来指定，其中列出记录的*组件*。在后台隐式生成的是规范构造函数；`toString`、`equals`和`hashCode`方法以及为每个指定的组件生成`public`访问器方法。访问器方法采用与组件相同的名称（与更传统的`get`方法相反）。记录最好通过与常规类进行对比来解释。*图8**.29*展示了一个带有大量模板代码的正常类：
- en: '![Figure 8.29 - A class with a lot of boilerplate code](img/B19793_08_29.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![图8.29 - 一个有很多模板代码的类](img/B19793_08_29.jpg)'
- en: Figure 8.29 - A class with a lot of boilerplate code
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.29 - 一个有很多模板代码的类
- en: The `Person` class in the preceding figure is customized somewhat to map to
    a record more easily. For example, the class itself is `final` (line 5) and the
    instance variables, namely `name` and `age` (lines 6-7), are also `final`. The
    fact that the instance variables are *blank final*’s (declared as `final` but
    not initialized at declaration time) means that the instance variables must be
    initialized in the constructor. This is what the constructor does (lines 10-11).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个图中的`Person`类进行了一些定制，以便更容易地映射到一个记录。例如，类本身是`final`（第5行），实例变量，即`name`和`age`（第6-7行），也是`final`。实例变量是`blank
    final`（声明为`final`但不在声明时初始化）的事实意味着实例变量必须在构造函数中初始化。这正是构造函数所做的事情（第10-11行）。
- en: There are two accessor methods for retrieving the instance variables, namely
    `name` (lines 13-15) and `age` (lines 16-18). Note that the method names are deliberately
    not preceded by `get`, in other words, `getName` and `getAge`. This is because,
    records use the components identifiers for both naming the instance variables
    *and* the accessor methods.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个访问器方法用于检索实例变量，即`name`（第13-15行）和`age`（第16-18行）。请注意，方法名前面没有`get`，换句话说，不是`getName`和`getAge`。这是因为记录使用组件标识符来命名实例变量和访问器方法。
- en: In addition, this class also has custom versions of `equals`, `hashCode`, and
    `toString`, lines 20-26, 28-30 and 32-36 respectively. Each of these methods is
    overriding an inherited version by providing a specific, custom version. This
    topic of overriding is discussed in detail in Inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
    The job of `toString` is to return a string containing the instance variables
    values (the component values). The `equals` method ensures that two records are
    considered equal if they are of the same type and contain equal component values.
    The `hashCode` method ensures that equal objects return the same hashcode value
    (more on this in [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317)).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个类还有自定义的`equals`、`hashCode`和`toString`版本，分别位于第20-26行、第28-30行和第32-36行。这些方法中的每一个都是通过提供特定的自定义版本来覆盖继承的版本。覆盖这个主题在继承部分有详细的讨论（见[*第9章*](B19793_09.xhtml#_idTextAnchor205)）。`toString`方法的作用是返回包含实例变量值（组件值）的字符串。`equals`方法确保如果两个记录类型相同且包含相等的组件值，则它们被认为是相等的。`hashCode`方法确保相等的对象返回相同的哈希码值（关于这一点，请参阅[*第13章*](B19793_13.xhtml#_idTextAnchor317)）。
- en: 'Now let us examine the equivalent record in *Figure 8**.30*:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查*图8**.30*中的等价记录：
- en: '![Figure 8.30 - Equivalent record of class from Figure 8.29](img/B19793_08_30.jpg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![图8.30 - 类8.29的等价记录](img/B19793_08_30.jpg)'
- en: Figure 8.30 - Equivalent record of class from Figure 8.29
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.30 - 类8.29的等价记录
- en: 'Yes – just one line of code! As you can see, this saves us from a lot of boilerplate
    code. In fact, *Figures 8.29* and *8.30* are equivalent (by the time the compiler
    is finished). The two parameters are called components and the preceding one liner
    leads to the following code being generated in the background:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 是的——只需要一行代码！正如你所见，这使我们免去了很多样板代码。实际上，*图8.29*和*图8.30*是等价的（编译器完成时）。这两个参数被称为组件，前面的单行代码导致在后台生成以下代码：
- en: A `final class` named after the record (`Person` in this example).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以记录命名的`final class`（在这个例子中是`Person`）。
- en: '`private final` instance variables, one for each component, named after the
    components.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private final`实例变量，每个组件一个，以组件命名。'
- en: A canonical constructor for initializing the components (instance variables).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于初始化组件（实例变量）的规范构造函数。
- en: Accessor methods, one for each component, named after the components.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问器方法，每个组件一个，以组件命名。
- en: Custom `toString`, `equals` and `hashCode` methods.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义的`toString`、`equals`和`hashCode`方法。
- en: Records are customizable. In other words, we can override (replace) all the
    default versions if we so wish. *Figure 8**.31* presents such a situation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是可定制的。换句话说，如果我们愿意，我们可以覆盖（替换）所有默认版本。*图8**.31*展示了这种情况。
- en: '![Figure 8.31 - canonical and compact constructors](img/B19793_08_31.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图8.31 - 规范和紧凑构造函数](img/B19793_08_31.jpg)'
- en: Figure 8.31 - canonical and compact constructors
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.31 - 规范和紧凑构造函数
- en: In this figure, we are customizing the canonical constructor (lines 7-13) as
    we want to validate the `age` component of the person – if they are younger than
    18, that is an error and we generate custom error values. Note again that there
    are better ways to handle error values but for now, this is fine. Otherwise, the
    components are initialized to the values passed in.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们正在自定义规范构造函数（第7-13行），因为我们想验证人的`age`组件——如果他们小于18岁，那将是一个错误，我们将生成自定义错误值。再次注意，有更好的方法来处理错误值，但到目前为止，这已经足够了。否则，组件初始化为传入的值。
- en: However, this canonical constructor can be written in an even more concise fashion.
    The compact constructor (lines 15-19) is replacing the canonical constructor.
    Compact constructors are a variation of the canonical constructor and are specific
    to records. Note that there is not even a pair of round brackets on line 15 –
    the components can be inferred from the component list (line 5). Also, there is
    no need to initialize the components as per lines 11-12; again, the compiler can
    do this for us.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个规范构造函数可以以更简洁的方式编写。紧凑构造函数（第 15-19 行）正在替换规范构造函数。紧凑构造函数是规范构造函数的一种变体，并且是特定于记录的。注意，第
    15 行甚至没有一对圆括号——组件可以从组件列表（第 5 行）推断出来。此外，没有必要根据第 11-12 行初始化组件；编译器可以为我们完成这项工作。
- en: Lines 23-26 demonstrate how to use the record `Person` that we have declared.
    Line 23 declares a `Person` instance referred to by `p1`. Line 24 calls the implicit
    `toString` provided by the `Record` class (which every record inherits from).
    Lines 25-26 invokes the two accessor methods; note their names are `name()` and
    `age()` respectively. The output is in comments on the right of each line (lines
    24-26).
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 第 23-26 行演示了如何使用我们声明的记录 `Person`。第 23 行声明了一个名为 `p1` 的 `Person` 实例。第 24 行调用了
    `Record` 类提供的隐式 `toString` 方法（每个记录都从该类继承）。第 25-26 行调用了两个访问器方法；注意它们的名称分别是 `name()`
    和 `age()`。输出在每行的右侧注释中（第 24-26 行）。
- en: As records are so closely related to classes, it is no surprise that records
    can be used with the `instanceof` keyword. This is what we will examine in record
    patterns.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 由于记录与类密切相关，记录可以用 `instanceof` 关键字使用，这并不奇怪。这就是我们将要检查的记录模式。
- en: Record patterns
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录模式
- en: Over the years, the `instanceof` keyword has evolved past the simple `instanceof`-and-cast
    idiom to support both type patterns and record patterns. Let us first discuss
    what a “type pattern” is and “pattern matching”.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几年里，`instanceof` 关键字已经从简单的 `instanceof`-and-cast 习语发展到支持类型模式和记录模式。让我们首先讨论一下“类型模式”和“模式匹配”是什么。
- en: Type patterns and pattern matching
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型模式和模式匹配
- en: 'In Java 16, `instanceof` was extended to take a type pattern and perform pattern
    matching. Prior to Java 16 the following code was commonplace:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 16 中，`instanceof` 被扩展为接受类型模式并执行模式匹配。在 Java 16 之前，以下代码很常见：
- en: '[PRE5]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This code is checking to see if the `Object` reference `obj` is referring to
    a `String` object and if so, to (safely) cast the reference to a `String` so we
    can access the `String` methods. Remember, the methods you can access are based
    on the reference type. However, if the object at the end of the reference is a
    `String` object then we can safely cast the reference to a `String` and thus access
    the `String` methods using the new `String` reference. We will discuss this in
    more detail in Inheritance ([*Chapter 9*](B19793_09.xhtml#_idTextAnchor205)).
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码检查 `Object` 引用 `obj` 是否指向一个 `String` 对象，如果是，则（安全地）将引用转换为 `String`，这样我们就可以访问
    `String` 方法。记住，你可以访问的方法基于引用类型。然而，如果引用末尾的对象是一个 `String` 对象，那么我们可以安全地将引用转换为 `String`，从而使用新的
    `String` 引用访问 `String` 方法。我们将在继承部分（[*第 9 章*](B19793_09.xhtml#_idTextAnchor205)）中更详细地讨论这一点。
- en: 'As of Java 16, we can write the previous code segment more concisely and safely:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Java 16，我们可以更简洁、更安全地编写之前的代码段：
- en: '[PRE6]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There are two changes to note. The first one is the use of a type pattern `String
    s` as part of the `instanceof`. Pattern matching occurs at runtime whereby `instanceof`
    checks the type against the provided type pattern and if there is a match, performs
    the cast for us as well. The second change is that, as `instanceof` performs the
    cast on our behalf, we no longer need to do the cast ourselves. This leads to
    a more declarative style (where you state what you want rather than how to get
    what you want).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有两个变化需要注意。第一个变化是使用类型模式 `String s` 作为 `instanceof` 的一部分。模式匹配在运行时发生，其中 `instanceof`
    将类型与提供的类型模式进行比较，如果匹配，则为我们执行类型转换。第二个变化是，由于 `instanceof` 代表我们执行类型转换，我们不再需要自己进行转换。这导致了一种更声明性的风格（你只需说明你想要什么，而不是如何得到你想要的东西）。
- en: 'This leads on nicely to record patterns which were introduced in Java 21\.
    Prior to record patterns, the following code was required (assuming the `Person`
    record from *Figure 8**.30*):'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这很自然地引出了 Java 21 中引入的记录模式。在记录模式之前，需要以下代码（假设使用 *图 8**.30* 中的 `Person` 记录）：
- en: '[PRE7]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Using record patterns, the previous code can be expressed more concisely:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 使用记录模式，之前的代码可以更简洁地表达：
- en: '[PRE8]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this code, `Person(String sName, Integer nAge)` is a record pattern. A record
    pattern consists of a type, a component pattern list (which may be empty) and
    an optional identifier. A record pattern does two things for us: firstly, it checks
    to see if the object passes the `instanceof` test and secondly, disaggregates
    the record instance into its components. So, in our example, assuming `obj` is
    referring to a `Person` object, then the local variable `sName` will be initialized
    to the return value of the `name()` accessor method and the local variable `nAge`
    will be initialized to the return value from the `age()` accessor method. We deliberately
    used different identifiers for our local variables to highlight the fact that
    they do not have to match the component identifiers used in *Figure 8**.30*. Note
    however that the order of the types must match; in other words, the record pattern
    must specify a `String` variable followed by an `Integer` variable, as that is
    the order of the component list in *Figure 8**.30*.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`Person(String sName, Integer nAge)` 是一个记录模式。记录模式由一个类型、一个组件模式列表（可能为空）和一个可选的标识符组成。记录模式为我们做了两件事：首先，检查对象是否通过
    `instanceof` 测试；其次，将记录实例分解为其组件。所以，在我们的例子中，假设 `obj` 指的是一个 `Person` 对象，那么局部变量 `sName`
    将初始化为 `name()` 访问器方法的返回值，局部变量 `nAge` 将初始化为 `age()` 访问器方法的返回值。我们故意使用不同的标识符来强调它们不必与
    *图 8**.30* 中使用的组件标识符匹配。然而，需要注意的是，类型的顺序必须匹配；换句话说，记录模式必须指定一个 `String` 变量，然后是一个 `Integer`
    变量，正如 *图 8**.30* 中组件列表的顺序。
- en: That completes our discussion on records and indeed concludes [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
    Now, let’s put that knowledge into practice to reinforce the concepts we’ve learned.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就完成了对记录的讨论，并且确实结束了 [*第 8 章*](B19793_08.xhtml#_idTextAnchor168)。现在，让我们将所学知识付诸实践，以巩固我们学到的概念。
- en: Exercises
  id: totrans-367
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'Classes, objects, and enums are great for enhancing our Mesozoic Eden software.
    In these exercises, you will be creating classes to represent different entities
    in our park and using enums to define fixed sets of constants:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 类、对象和枚举非常适合增强我们的中生代伊甸园软件。在这些练习中，你将创建类来表示公园中的不同实体，并使用枚举来定义一组固定的常量：
- en: We have many types of dinosaurs in our park, each with unique characteristics.
    Define a class called `Dinosaur` with properties such as name, age, and species.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们公园里有很多种类的恐龙，每种恐龙都有其独特的特征。定义一个名为 `Dinosaur` 的类，具有诸如名称、年龄和物种等属性。
- en: Our park’s heart and soul lie in its employees. Create a class called `Employee`
    that encapsulates properties such as name, job title, and years of experience.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们公园的灵魂和核心在于其员工。创建一个名为 `Employee` 的类，用于封装诸如名称、职位和经验年数等属性。
- en: With these classes in place, create some instances of `Dinosaur` and `Employee`
    and practice manipulating these objects. It’s hard for me to provide more details
    for this exercise, but for example, you could create a new class called `App`.
    Then, in this class, you could create a few instances of `Dinosaur` and `Employee`.
    If you want to go wild, you can add a method that takes `Dinosaur` as an argument
    and then prints the information (such as its name, age, and so on) of this dinosaur.
    Of course, you could do the same thing for `Employee`.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在有了这些类之后，创建一些 `Dinosaur` 和 `Employee` 的实例，并练习操作这些对象。我很难为这个练习提供更多细节，但例如，你可以创建一个新的类
    `App`。然后，在这个类中，你可以创建一些 `Dinosaur` 和 `Employee` 的实例。如果你想发挥创意，你可以添加一个接受 `Dinosaur`
    作为参数的方法，然后打印出这个恐龙的信息（如它的名称、年龄等）。当然，你也可以为 `Employee` 做同样的事情。
- en: The “park” itself can be thought of as an object with its own properties and
    behavior. Design a `Park` class that contains methods for opening and closing
    the park, adding or removing dinosaurs, and so on. You can also consider giving
    it an array of employees and an array of dinosaurs.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: “公园”本身可以被视为一个具有自身属性和行为的对象。设计一个 `Park` 类，其中包含打开和关闭公园、添加或删除恐龙等方法。你也可以考虑给它一个员工数组和一个恐龙数组。
- en: The food we serve to our dinosaurs varies greatly. Define a class for `Food`
    with properties such as name, nutritional value, and cost.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们提供给恐龙的食物种类繁多。定义一个 `Food` 类，具有诸如名称、营养价值和成本等属性。
- en: As you know, safety is our main priority. For obvious safety reasons, our dinosaurs
    are housed in different enclosures. Create an `Enclosure` class that contains
    an array of `Dinosaur` objects.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所知，安全是我们的首要任务。出于明显的安全原因，我们的恐龙被安置在不同的围栏中。创建一个 `Enclosure` 类，其中包含一个 `Dinosaur`
    对象数组。
- en: To add more clarity, let’s define an enumeration for dinosaur types, such as
    herbivore, carnivore, and omnivore.
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A park visit isn’t complete without a ticket. Create a `Ticket` class with properties
    such as price, visitor’s name, and visit date.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – Mesozoic Eden park manager
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this project, you’ll be creating a fully interactive console application
    known as Mesozoic Eden park manager. This application allows the park manager
    to oversee and manage the various aspects of the dinosaur park. The park manager
    can use this application to efficiently manage multiple dinosaurs, park employees,
    and park tickets. Some of the key features of this system should be as follows:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: The ability to create, edit, or remove dinosaur profiles, park employee profiles,
    and park tickets.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A real-time tracking system that monitors the location and status of the dinosaurs
    within the park.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A fundamental roster system to organize and manage park employee schedules.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A robust ticketing system to manage guest admissions and ensure the park maintains
    optimal capacity.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The system should also handle special scenarios such as emergencies or VIP guest
    visits.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This might sound like a lot. So, here’s a step-by-step guide to achieve this:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: '`Dinosaur` and `Employee` classes. Also, add a class called `Guest`. Each class
    should include more properties and methods.'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Dinosaur`, `Guest`, and `Employee` objects.'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Scanner` class. This interface should provide the park manager with a variety
    of options to manage the park.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Enhance menu creation**: The menu should now include options to manage multiple
    dinosaurs, employees, and tickets. Each option should correspond to a particular
    function in the program.'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handle actions**: Each menu item should trigger a function. For example,
    selecting the **Manage Dinosaurs** option could trigger a function to add, remove,
    or edit dinosaur profiles.'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Exit the program**: Provide an option for the user to exit the program.'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is a starting code snippet:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The commented-out method calls are placeholders for methods you need to implement
    according to your data structures and functionality.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started our discussion by differentiating objects and classes.
    Classes are similar to a plan of a house, whereas an object is the (built) house
    itself. We create an object using the `new` keyword and manipulate the object
    using its reference. Differentiating the reference from the object is very important
    going forward. A useful analogy is that the reference is like a remote control
    and the object is the TV.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Constructors are special methods that are used when constructing an object.
    The constructor is a method that has the same name as the class but with no return
    type. There is always a constructor present – if you don’t provide one, the compiler
    intervenes and inserts the default constructor. The constructor is typically used
    to initialize the instance variables.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Every object gets a copy of the instance members (variables and methods). Class
    members are marked as `static`, and are shared by all instances. When accessing
    an instance member, we use the reference but when accessing a class member, we
    use the class name. Dot notation applies to both syntaxes.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: The `this` reference is a special reference available to us in instance methods.
    It refers to the object instance responsible for the method call. Consequently,
    it is dynamic since its value depends on the reference used to invoke the method.
    It is not available to class (`static`) methods.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers apply at both the top (class/interface/record) level, and the
    member level. At the top level, `public` or package-private access applies. Package-private
    is achieved by not specifying any keyword at all and ensures that the top-level
    construct is visible within the same package only. If the top-level construct
    is `public`, then it is available everywhere; there are no restrictions.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Members (variables/methods) can, in addition to `public` and package-private
    (with the same semantics), be `private` and `protected`. `private` means that
    the member is visible within the class only. `protected` is similar to package-private
    except that subclasses, regardless of package, can access the member.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation is one of the cornerstones of OOP. It means that a class can hide
    its data from external misuse; this is often called “data hiding.” In Java, it
    is achieved by marking data as `private` and providing `public` accessor/mutator
    (get/set) methods to manipulate the data. The important concept here is that external
    code has to access `private` data via your `public` methods. Thus, by using conditional
    logic in your `public` methods, you can prevent your data from being corrupted.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: However, the principle of “private data, public methods” only goes so far. When
    returning a reference to a `private` object, Java’s call by value mechanism returns
    a copy of that reference. Thus, the `private` object is now *directly* accessible
    via external code. Advanced encapsulation combats this by copying the `private`
    object and returning the reference to the copy object. Thus, your `private` object
    is still private and safe from external interference.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Understanding an object’s life cycle is extremely beneficial. Local variables
    live on the stack, whereas objects and instance variables reside on the heap.
    When an object no longer has any references referring to it, it is eligible for
    garbage collection. Garbage collection is an automatic process run by the JVM,
    at a time of the JVM’s choosing. When the garbage collector runs, objects eligible
    for garbage collection are removed and the heap space is reclaimed.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: The `instanceof` keyword enables us to determine the object type that a reference
    is referring to. This will be very useful going forward.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations (enums) are closely related to classes in that enums are simply
    classes, where the number of instances are finite and specified. They are very
    useful for ensuring type safety, whereby the compiler flags an error as opposed
    to discovering the error at runtime.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举（enums）与类紧密相关，因为枚举实际上就是类，其实例数量是有限且已指定的。它们在确保类型安全方面非常有用，编译器会标记错误而不是在运行时发现错误。
- en: 'Enums are categorized into two separate types: simple and complex. Simple enums
    just specify the constant values; the compiler synthesizes the default constructor.
    All enum constructors are `private` by default. Thus, external classes cannot
    `new` them – the constants that are defined are, in fact, the constructor calls.
    Complex enums look very similar to classes as they have instance variables, (explicit)
    constructors, and methods.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举分为两种类型：简单和复杂。简单枚举仅指定常量值；编译器会自动生成默认构造函数。所有枚举构造函数默认为`private`。因此，外部类不能`new`它们——实际上定义的常量是构造函数的调用。复杂枚举看起来与类非常相似，因为它们有实例变量、（显式）构造函数和方法。
- en: Records are useful when you have classes with a lot of boilerplate code. The
    components of the record are specified in the record declaration. The compiler,
    in the background, generates the instance variables, canonical constructor, accessor
    methods, `toString`, `equals`, and `hashCode` methods. Records are `final`, as
    are the instance variables (components). A compact constructor is a more concise
    variation of the canonical constructor.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有大量样板代码的类时，记录（Records）非常有用。记录的组件在记录声明中指定。编译器在后台生成实例变量、规范构造函数、访问器方法、`toString`、`equals`和`hashCode`方法。记录是`final`的，实例变量（组件）也是如此。紧凑构造函数是规范构造函数的一种更简洁的变体。
- en: 'That completes our discussion of classes, objects, and enums. We will now move
    onto another important OOP chapter: inheritance.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对类、对象和枚举的讨论。我们现在将转向另一个重要的面向对象编程（OOP）章节：继承。
