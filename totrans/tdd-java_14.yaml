- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving the Database Layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will implement a database adapter for one of our ports in
    the domain model, represented by the `WordRepository` interface. This will allow
    our domain model to fetch words to guess from a real database, in this case, using
    the popular open source database **Postgres**. We will test-drive both the database
    setup and the code that accesses the database. To help us do that, we will use
    a test framework that is designed to simplify writing database integration tests,
    called **DBRider**.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, we will have written an integration test against
    a running database, implemented the `fetchesWordByNumber()` method from the `WordRepository`
    interface, and used the **JDBI** database access library to help us. We will create
    a database user with permissions on a table storing words to guess. We will create
    that table, then write a SQL query that JDBI will use to retrieve the word we
    are looking for. We will use a named parameter SQL query to avoid some application
    security issues caused by SQL injections.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database integration test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the word repository adapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final code for this chapter can be found at [https://github.com/PacktPublishing/Test-Driven-Development-with-Java/tree/main/chapter14](B18384_14.xhtml#_idTextAnchor302).
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Postgres database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will be using the Postgres database in this chapter, which needs installation.
    To install Postgres, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to the following web page: [https://www.postgresql.org/download/](B18384_14.xhtml#_idTextAnchor301).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation instructions for your operating system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code has been tested with version 14.5\. It is expected to work on all versions.
  prefs: []
  type: TYPE_NORMAL
- en: With the setup completed, let’s get started implementing our database code.
    In the next section, we will use the DBRider framework to create a database integration
    test.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database integration test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will create the skeleton of a database integration test
    using a test framework called DBRider. We will use this test to drive out the
    creation of a database table and database user. We will be working towards implementing
    the `WordRepository` interface, which will access words stored in a Postgres database.
  prefs: []
  type: TYPE_NORMAL
- en: Previously, we created a domain model for our Wordz application, using hexagonal
    architecture to guide us. Instead of accessing a database directly, our domain
    model uses an abstraction, known as a `WordRepository` interface, which represents
    stored words for guessing.
  prefs: []
  type: TYPE_NORMAL
- en: Ports must always be implemented by adapters in hexagonal architecture. An adapter
    for the `WordRepository` interface will be a class that implements the interface,
    containing all the code needed to access the real database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test-drive this adapter code, we will write an integration test, using a
    library that supports testing databases. The library is called DBRider, and is
    one of the dependencies listed in the project’s `gradle.build` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: DBRider has an accompanying library called **rider-junit5**, which integrates
    with **JUnit5**. With this new test tooling, we can start to write our test. The
    first thing to do is set up the test so that it uses DBRider to connect to our
    Postgres database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a database test with DBRider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we test-drive any application code, we will need a test that is connected
    to our Postgres database, running locally. We start in the usual way, by writing
    a JUnit5 test class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new test class file in the `/test/` directory in the new `com.wordz.adapters.db`
    package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Integration test](img/Figure_14.01_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Integration test
  prefs: []
  type: TYPE_NORMAL
- en: The IDE will generate the empty test class for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the `@DBRider` and `@DBUnit` annotations to the test class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parameters in the `@DBUnit` annotation mitigate some odd interactions between
    Postgres and the DBRider test framework to do with case sensitivity on table and
    column names.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to test that a word can be fetched. Add an empty test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test. It will fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.2 – DBRider cannot connect to the database](img/Figure_14.02_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – DBRider cannot connect to the database
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step to fixing this is to follow the DBRider documentation and add
    code that will be used by the DBRider framework. We add a `connectionHolder` field
    and a `javax.sqlDataSource` field to support that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dataSource` is the standard **JDBC** way of creating a connection to our
    Postgres database. We run the test. It fails with a different error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – dataSource is null](img/Figure_14.03_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – dataSource is null
  prefs: []
  type: TYPE_NORMAL
- en: 'We correct this by adding a `@BeforeEach` method to set up `dataSource`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This specifies we want a user called `ciuser` with the password `cipassword`
    to connect to a database called `wordzdb`, running on `localhost` at the default
    port for Postgres (`5432`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test and see it fail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.4 – User does not exist](img/Figure_14.04_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – User does not exist
  prefs: []
  type: TYPE_NORMAL
- en: The error is caused because we do not have a `ciuser` user known to our Postgres
    database yet. Let’s create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a `psql` terminal and create the user:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Database not found](img/Figure_14.05_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Database not found
  prefs: []
  type: TYPE_NORMAL
- en: It fails because the DBRider framework is looking to connect our new `ciuser`
    user to the `wordzdb` database. This database does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `psql` terminal, create the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Test passes](img/Figure_14.06_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Test passes
  prefs: []
  type: TYPE_NORMAL
- en: The `fetchesWord()` test now passes. We recall that the test method itself is
    empty, but this means we have enough database set up to proceed with test-driving
    production code. We will return to database setup soon enough, but we will allow
    our test-driving to guide us. The next job is to add the missing Arrange, Act,
    and Assert code to the `fetchesWord()` test.
  prefs: []
  type: TYPE_NORMAL
- en: Driving out the production code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our goal is to test-drive code to fetch a word from the database. We want that
    code to be in a class that implements the `WordRepository` interface, which we
    defined in the domain model. We will want to design enough of our database schema
    to support this. By starting to add code to the *Assert* step, we can drive out
    an implementation quickly. This is a useful technique – writing the test by starting
    with the assert, so that we start with the desired outcome. We can then work backward
    to include everything necessary for delivering it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Assert step to our `fetchesWord()` test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to check that we can fetch the word `ARISE` from the database. This
    test fails. We need to create a class to contain the necessary code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want our new adapter class to implement the `WordRepository` interface,
    so we drive this out in the Arrange step of our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now let the IDE wizard do most of the work in creating our new adapter class.
    Let’s call it `WordRepositoryPostgres`, which links the two facts that the class
    implements the `WordRepository` interface and is also implementing access to a
    Postgres database. We use the `com.wordz.adapters.db`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.7 – New Class wizard](img/Figure_14.07_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – New Class wizard
  prefs: []
  type: TYPE_NORMAL
- en: 'This results in an empty skeleton for the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The IDE will auto-generate method stubs for the interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Returning to our test, we can add the act line, which will call the `fetchWordByNumber()`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A word of explanation about the mysterious constant `27` passed in to the `fetchWordByNumber()`
    method. This is an *arbitrary* number used to identify a particular word. Its
    only hard requirement is that it must line up with the word number given in the
    stub test data, which we will see a little later in a JSON file. The actual value
    of `27` is of no significance beyond lining up with the word number of the stub
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass `dataSource` in to the `WordRepositoryPostgres` constructor so that our
    class has a way to access the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This drives out a change to the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The last bit of setup to do in our test is to populate the database with the
    word `ARISE`. We do this using a JSON file that the DBRider framework will apply
    to our database on test startup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `"word_number": 27` code here corresponds to the value used in the test
    code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This file must be saved in a specific location so that DBRider can find it.
    We call the file `wordTable.json` and save it in the test directory, in `/resources/adapters/data`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Location of wordTable.json](img/Figure_14.08_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – Location of wordTable.json
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in setting up our failing test is to link the test data `wordTable.json`
    file to our `fetchesWord()` test method. We do this using the DBRider `@``DataSet`
    annotation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The test now fails and is in a position where we can make it pass by writing
    the database access code. In the next section, we will use the popular library
    JDBI to implement database access in an adapter class for our `WordRepository`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the WordRepository adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will use the popular database library JDBI to implement
    the `fetchWordByNumber()` method of `interface WordRepository` and make our failing
    integration test pass.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architectures were covered in [*Chapter 9*](B18384_09.xhtml#_idTextAnchor179),
    *Hexagonal Architecture – Decoupling External Systems*. An external system like
    a database is accessed through a port in the domain model. The code that is specific
    to that external system is contained in an adapter. Our failing test enables us
    to write the database access code to fetch a word to guess.
  prefs: []
  type: TYPE_NORMAL
- en: A little bit of database design thinking needs to be done before we begin writing
    code. For the task at hand, it is enough to note that we will store all available
    words to guess in a database table named `word`. This table will have two columns.
    There will be a primary key named `word_number` and a five-letter word in a column
    named `word`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test-drive this out:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the test to reveal that the `word` table does not exist:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Table not found](img/Figure_14.09_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Table not found
  prefs: []
  type: TYPE_NORMAL
- en: 'Correct this by creating a `word` table in the database. We use the `psql`
    console to run the SQL `create` `table` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test again. The error changes to show our `ciuser` user has insufficient
    permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Insufficient permissions](img/Figure_14.10_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Insufficient permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'We correct this by running the SQL `grant` command in the `psql` console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test again. The error changes to show us that the `word` has not been
    read from the database table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Word not found](img/Figure_14.11_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – Word not found
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having set up the database side of things, we can move on to adding the code
    that will access the database. The first step is to add the database library we
    will use. It is JDBI, and to use it, we must add the `jdbi3-core` dependency to
    our `gradle.build` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code itself is as described in the JDBI documentation, found here: [https://jdbi.org/#_queries](B18384_14.xhtml#_idTextAnchor300).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to access the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `jdbi` object in the constructor of our class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives us access to the JDBI library. We have arranged it so that JDBI will
    access whatever `DataSource` we pass into our constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the JDBI code to send a SQL query to the database and fetch the word
    corresponding to the `wordNumber` we provide as a method parameter. First, we
    add the SQL query we will use:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `jdbi` access code can be added to the `fetchWordByNumber()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the test again:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Test passing](img/Figure_14.12_B18384.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – Test passing
  prefs: []
  type: TYPE_NORMAL
- en: Our integration test now passes. The adapter class has read the word from the
    database and returned it.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing GameRepository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The same process is used to test-drive the `highestWordNumber()` method and
    to create adapters for the other database access code implementing the `GameRepository`
    interface. The final code for these can be seen on GitHub with comments to explore
    some of the issues in database testing, such as how to avoid test failures caused
    by stored data.
  prefs: []
  type: TYPE_NORMAL
- en: There is a manual step needed to test-drive the implementation code for the
    `GameRepository` interface. We must create a `game` table.
  prefs: []
  type: TYPE_NORMAL
- en: 'In psql, type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have created an integration test for our database. We used
    that to test-drive the implementation of a database user, the database table,
    and the code needed to access our data. This code implemented the adapter for
    one of our ports in our hexagonal architecture. Along the way, we used some new
    tools. The DBRider database test framework simplified our test code. The JDBI
    database access library simplified our data access code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and final chapter, [*Chapter 15*](B18384_15.xhtml#_idTextAnchor306),
    *Driving the Web Layer*, we will add an HTTP interface to our application, turning
    it into a complete microservice. We will integrate all the components together,
    then play our first game of Wordz using the HTTP test tool Postman.
  prefs: []
  type: TYPE_NORMAL
- en: Questions and answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Should we automate the manual steps of creating the database?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Yes. This is an important part of DevOps, where we developers are responsible
    for getting the code into production and keeping it running there. The key technique
    is **Infrastructure as Code** (**IaC**), which means automating manual steps as
    code that we check in to the main repository.
  prefs: []
  type: TYPE_NORMAL
- en: What tools can help with automating database creation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Popular tools are **Flyway** and **Liquibase**. Both allow us to write scripts
    that are run at application startup and will migrate the database schema from
    one version to the next. They assist in migrating data across schema changes where
    that is required. These are outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: What tools can help with installing the database?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access to a running database server is part of platform engineering. For cloud-native
    designs that run on Amazon Web Service, Microsoft Azure, or Google Cloud Platform,
    use configuration scripting for that platform. One popular approach is to use
    Hashicorp’s **Terraform**, which aims to be a cross-provider universal scripting
    language for cloud configuration. This is outside of the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: How often should we run the integration tests?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before every check-in to the repository. While unit tests are fast to run and
    should be run all the time, integration tests by nature are slower to execute.
    It is reasonable to run only unit tests while working on domain code. We must
    always ensure we haven’t broken anything unexpectedly. This is where running integration
    tests comes in. These reveal whether we have accidentally changed something that
    affects the adapter layer code, or whether something has changed regarding database
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Documentation for DBRider: [https://github.com/database-rider/database-rider](B18384_14.xhtml#_idTextAnchor299)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JDBI documentation: [https://jdbi.org/#_introduction_to_jdbi_3](B18384_14.xhtml#_idTextAnchor298)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flyway is a library that allows us to store the SQL commands to create and
    modify our database schema as source code. This allows us to automate database
    changes: [https://flywaydb.org/](B18384_14.xhtml#_idTextAnchor297)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As our application design grows, our database schema will need to change. This
    website and the accompanying books describe ways to do this while managing risk:
    [https://databaserefactoring.com/](B18384_14.xhtml#_idTextAnchor296)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Hosting a Postgres database on Amazon Web Services using their RDS service:
    [https://aws.amazon.com/rds](B18384_14.xhtml#_idTextAnchor295)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
