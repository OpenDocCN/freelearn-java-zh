<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Configuring Enterprise Services"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Configuring Enterprise Services</h1></div></div></div><p>This chapter covers <a id="id276" class="indexterm"/>the configuration of the Java Enterprise services that ship with the application server. Many of the services are configured within their own subsystem. These subsystems can be added or removed depending on whether or not the service is required in your application. We will look at the most common ones in the following order:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Connecting to a database</li><li class="listitem" style="list-style-type: disc">Configuring the Enterprise JavaBeans container</li><li class="listitem" style="list-style-type: disc">Configuring the messaging service</li><li class="listitem" style="list-style-type: disc">Configuring the transaction service</li><li class="listitem" style="list-style-type: disc">Configuring concurrency</li></ul></div><div class="section" title="Connecting to a database"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec15"/>Connecting to a database</h1></div></div></div><p>To <a id="id277" class="indexterm"/>allow your application to connect <a id="id278" class="indexterm"/>to a database, you will need to configure your server by adding a datasource. Upon server startup, each datasource is prepopulated with a pool of database connections. Applications acquire a database connection from the pool by doing a <code class="literal">JNDI</code> lookup and then calling <code class="literal">getConnection()</code>. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">Connection result = null;
try {
    Context initialContext = new InitialContext();
    DataSource datasource = (DataSource)initialContext.lookup("java:/MySqlDS");
    <span class="strong"><strong>result = datasource.getConnection();</strong></span>
} catch (Exception ex) {
    log("Cannot get connection: " + ex);}</pre></div><p>After the connection has been used, you should always call <code class="literal">connection.close()</code> as soon as possible. This frees the connection and allows it to be returned to the connection pool—ready for other applications or processes to use.</p><p>Releases prior <a id="id279" class="indexterm"/>to JBoss AS 7 required a datasource configuration file (<code class="literal">ds.xml</code>) to be deployed with the application. Ever since the release of JBoss AS 7, this approach has no longer been mandatory due to the modular nature of the application server.</p><p>Out of the box, the application server ships with the H2 open source database engine (<a class="ulink" href="http://www.h2database.com">http://www.h2database.com</a>), which, because of its small footprint and browser-based console, is ideal for testing purposes.</p><p>However, a real-world application requires an industry-standard database, such as the Oracle database or MySQL. In the following section, we will show you how to configure a datasource for the MySQL database.</p><p>Any database configuration requires a two step procedure, which is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Installing the JDBC driver</li><li class="listitem" style="list-style-type: disc">Adding the datasource to your configuration</li></ul></div><p>Let's look at each section in detail.</p><div class="section" title="Installing the JDBC driver"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Installing the JDBC driver</h2></div></div></div><p>In WildFly's modular server architecture, you have a couple of ways to install your JDBC driver. You can install it either as a module or as a deployment unit.</p><p>The first and recommended approach is to install the driver as a module. In the <span class="emphasis"><em>Installing the driver as a deployment unit</em></span> section, we will look at a faster approach to installing the driver. However, it does have various limitations, which we will cover shortly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Please see the source code for this chapter for the complete module example.</p></div></div><p>The first step to install a new module is to create the directory structure under the modules folder. The actual path for the module is <code class="literal">JBOSS_HOME/modules/&lt;module&gt;/main</code>.</p><p>The <code class="literal">main</code> folder is where all the key module components are installed, namely, the driver and the <code class="literal">module.xml</code> file. So, next, we need to add the following units:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">JBOSS_HOME/modules/com/mysql/main/mysql-connector-java-5.1.30-bin.jar</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">JBOSS_HOME/modules/com/mysql/main/module.xml</code></li></ul></div><p>The MySQL JDBC driver used in this example, also known as Connector/J, can be downloaded for free from the MySQL site (<a class="ulink" href="http://dev.mysql.com/downloads/connector/j/">http://dev.mysql.com/downloads/connector/j/</a>). At the time of writing, the latest version is 5.1.30.</p><p>The last thing to do is to create the <code class="literal">module.xml</code> file. This file contains the actual module definition. It is important to make sure that the module name (<code class="literal">com.mysql</code>) corresponds to the <code class="literal">module</code> attribute defined in the your datasource.</p><p>You must also state the path to the JDBC driver resource and finally add the module dependencies, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;module  name="com.mysql"&gt; &lt;resources&gt;
        &lt;resource-root path="mysql-connector-java-5.1.30-bin.jar"/&gt;
    &lt;/resources&gt;
    &lt;dependencies&gt;
        &lt;module name="javax.api"/&gt;
        &lt;module name="javax.transaction.api"/&gt;
    &lt;/dependencies&gt;
&lt;/module&gt;</pre></div><p>Here is a diagram showing the final directory structure of this new module:</p><div class="mediaobject"><img src="graphics/6232OS_03_01.jpg" alt="Installing the JDBC driver"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>You will notice that there is a directory structure already within the <code class="literal">modules</code> folder. All the system libraries are housed inside the <code class="literal">system/layers/base</code> directory. Your custom modules should be placed directly inside the <code class="literal">modules</code> folder and not with the system modules.</p></div></div></div><div class="section" title="Adding a local datasource"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Adding a local datasource</h2></div></div></div><p>Once the JDBC driver is installed, you need to configure the datasource within the application server's configuration file. In WildFly, you can configure two kinds of datasources, <span class="strong"><strong>local</strong></span> <span class="strong"><strong>datasources</strong></span> and <span class="strong"><strong>xa-datasources</strong></span>, which are distinguishable by the element name in the configuration file.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>A local datasource does not support two-phase commits using a <code class="literal">java.sql.Driver</code>. On the other hand, an xa-datasource supports two-phase commits using a <code class="literal">javax.sql.XADataSource</code>.</p></div></div><p>Adding a datasource definition can be completed by adding the datasource definition within the server configuration file or by using the management interfaces. The management interfaces are the recommended way, as they will accurately update the configuration for you, which means that you do not need to worry about getting the correct syntax.</p><p>In this chapter, we are going to add the datasource by modifying the server configuration file directly. Although this is not the recommended approach, it will allow you to get used to the syntax and layout of the file. In <a class="link" href="ch07.html" title="Chapter 7. Using the Management Interfaces">Chapter 7</a>, <span class="emphasis"><em>Using the Management Interfaces</em></span>, we will show you how to add a datasource using the management tools.</p><p>Here is a sample MySQL datasource configuration that you can copy into your datasources subsystem section within the <code class="literal">standalone.xml</code> configuration file:</p><div class="informalexample"><pre class="programlisting">&lt;datasources&gt;
  &lt;datasource jndi-name="java:/MySqlDS" pool-name="MySqlDS_Pool" enabled="true" jta="true" use-java-context="true" use-ccm="true"&gt;
    &lt;connection-url&gt;
      jdbc:mysql://localhost:3306/MyDB
    &lt;/connection-url&gt;
    &lt;driver&gt;mysql&lt;/driver&gt;
    &lt;pool /&gt;
    &lt;security&gt;
      &lt;user-name&gt;jboss&lt;/user-name&gt;
      &lt;password&gt;jboss&lt;/password&gt;
    &lt;/security&gt;
    &lt;statement/&gt;
    &lt;timeout&gt;
      &lt;idle-timeout-minutes&gt;0&lt;/idle-timeout-minutes&gt;
      &lt;query-timeout&gt;600&lt;/query-timeout&gt;
    &lt;/timeout&gt;
  &lt;/datasource&gt;
  &lt;drivers&gt;
    &lt;driver name="mysql" module="com.mysql"/&gt;
  &lt;/drivers&gt;
&lt;/datasources&gt;</pre></div><p>As you can see, the configuration file uses the same XML schema definition from the earlier <code class="literal">-*.ds.xml</code> file, so it will not be difficult to migrate to WildFly from previous releases.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>In WildFly, it's mandatory that the datasource is bound into the <code class="literal">java:/</code> or <code class="literal">java:jboss/</code> JNDI namespace.</p></div></div><p>Let's take a look at the various elements of this file:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">connection-url</code>: This element is used to define the connection path to the database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">driver</code>: This element is used to define the JDBC driver class.</li><li class="listitem" style="list-style-type: disc"><code class="literal">pool</code>: This element is used to define the JDBC connection pool properties. In this case, we are going to leave the default values.</li><li class="listitem" style="list-style-type: disc"><code class="literal">security</code>: This element is used to configure the connection credentials.</li><li class="listitem" style="list-style-type: disc"><code class="literal">statement</code>: This element is added just as a placeholder for statement-caching options.</li><li class="listitem" style="list-style-type: disc"><code class="literal">timeout</code>: This element is optional and contains a set of other elements, such as <code class="literal">query-timeout</code>, which is a static configuration of the maximum seconds before a query times out. Also the included <code class="literal">idle-timeout-minutes</code> element indicates the maximum time a connection may be idle before being closed; setting it to <code class="literal">0</code> disables it, and the default is <code class="literal">15</code> minutes.</li></ul></div><div class="section" title="Configuring the connection pool"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec18"/>Configuring the connection pool</h3></div></div></div><p>One key aspect of the datasource configuration is the <code class="literal">pool</code> element. You can use connection pooling without modifying any of the existing WildFly configurations, as, without modification, WildFly will choose to use default settings. If you want to customize the pooling configuration, for example, change the pool size or change the types of connections that are pooled, you will need to learn how to modify the configuration file.</p><p>Here's an example of pool configuration, which can be added to your datasource configuration:</p><div class="informalexample"><pre class="programlisting">&lt;pool&gt;
    &lt;min-pool-size&gt;5&lt;/min-pool-size&gt;
    &lt;max-pool-size&gt;10&lt;/max-pool-size&gt;
    &lt;prefill&gt;true&lt;/prefill&gt;
    &lt;use-strict-min&gt;true&lt;/use-strict-min&gt;
    &lt;flush-strategy&gt;FailingConnectionOnly&lt;/flush-strategy&gt;
&lt;/pool&gt;</pre></div><p>The attributes included in the <code class="literal">pool</code> configuration are actually borrowed from earlier releases, so we include them here for your reference:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Attribute</p>
</th><th style="text-align: left" valign="bottom">
<p>Meaning</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">initial-pool-size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This means the initial number of connections a pool should hold (default is <code class="literal">0</code> (zero)).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">min-pool-size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the minimum number of connections in the pool (default is <code class="literal">0</code> (zero)).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">max-pool-size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the maximum number of connections in the pool (default is <code class="literal">20</code>).</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">prefill</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This attempts to prefill the connection pool to the minimum number of connections.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">use-strict-min</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This determines whether idle connections below <code class="literal">min-pool-size</code> should be closed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">allow-multiple-users</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This determines whether multiple users can access the datasource through the <code class="literal">getConnection</code> method. This has been changed slightly in WildFly. In WildFly, the line <code class="literal">&lt;allow-multiple-users&gt;true&lt;/allow-multiple-users&gt;</code> is required. In JBoss AS 7, the empty element <code class="literal">&lt;allow-multiple-users/&gt;</code> was used.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">capacity</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This specifies the capacity policies for the pool—either <code class="literal">incrementer</code> or <code class="literal">decrementer</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">connection-listener</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Here, you can specify <code class="literal">org.jboss.jca.adapters.jdbc.spi.listener.ConnectionListener</code> that allows you to listen for connection callbacks, such as activation and passivation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">flush-strategy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This specifies how the pool should be flushed in the event of an error (default is <code class="literal">FailingConnectionsOnly</code>).</p>
</td></tr></tbody></table></div></div><div class="section" title="Configuring the statement cache"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec19"/>Configuring the statement cache</h3></div></div></div><p>For each connection within a connection pool, the WildFly server is able to create a statement cache. When a prepared statement or callable statement is used, WildFly will cache the statement so that it can be reused. In order to activate the statement cache, you have to specify a value greater than <code class="literal">0</code> within the <code class="literal">prepared-statement-cache-size</code> element. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;statement&gt;
    &lt;track-statements&gt;true&lt;/track-statements&gt;
    &lt;prepared-statement-cache-size&gt;10&lt;/prepared-statement-cache-size&gt;
    &lt;share-prepared-statements/&gt;
&lt;/statement&gt;</pre></div><p>Notice that we have also set <code class="literal">track-statements</code> to <code class="literal">true</code>. This will enable automatic closing of <code class="literal">statements</code> and <code class="literal">ResultSets</code>. This is important if you want to use prepared statement caching and/or don't want to prevent cursor leaks.</p><p>The last element, <code class="literal">share-prepared-statements</code>, can only be used when the prepared statement cache is enabled. This property determines whether two requests in the same transaction should return the same statement (default is <code class="literal">false</code>).</p></div><div class="section" title="Adding an xa-datasource"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec20"/>Adding an xa-datasource</h3></div></div></div><p>Adding an <code class="literal">xa-datasource</code> requires some modification to the datasource configuration. The <code class="literal">xa-datasource</code> is configured within its own element, that is, within the datasource. You will also need to specify the <code class="literal">xa-datasource</code> class within the <code class="literal">driver</code> element.</p><p>In the following code, we will add a configuration for our MySQL JDBC driver, which will be used to set up an <code class="literal">xa-datasource</code>:</p><div class="informalexample"><pre class="programlisting">&lt;datasources&gt;
  &lt;xa-datasource jndi-name="java:/XAMySqlDS" pool-name="MySqlDS_Pool" enabled="true" use-java-context="true" use-ccm="true"&gt;
    &lt;xa-datasource-property name="URL"&gt;
      jdbc:mysql://localhost:3306/MyDB
    &lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="User"&gt;jboss
    &lt;/xa-datasource-property&gt;
    &lt;xa-datasource-property name="Password"&gt;jboss
    &lt;/xa-datasource-property&gt;
    &lt;driver&gt;mysql-xa&lt;/driver&gt;
  &lt;/xa-datasource&gt;
  &lt;drivers&gt;
    &lt;driver name="mysql-xa" module="com.mysql"&gt;
      &lt;xa-datasource-class&gt;
        com.mysql.jdbc.jdbc2.optional.MysqlXADataSource
      &lt;/xa-datasource-class&gt;
    &lt;/driver&gt;
  &lt;/drivers&gt;
&lt;/datasources&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>
<span class="strong"><strong>Datasource versus xa-datasource</strong></span>
</p><p>You should use an xa-datasource in cases where a single transaction spans multiple datasources, for example, if a method consumes a <span class="strong"><strong>Java Message Service</strong></span> (<span class="strong"><strong>JMS</strong></span>) and updates a <span class="strong"><strong>Java Persistence API</strong></span> (<span class="strong"><strong>JPA</strong></span>) entity.</p></div></div></div></div><div class="section" title="Installing the driver as a deployment unit"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec40"/>Installing the driver as a deployment unit</h2></div></div></div><p>In the WildFly application server, every library is a module. Thus, simply deploying the JDBC driver to the application server will trigger its installation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>If the JDBC driver consists of more than a single JAR file, you will not be able to install the driver as a deployment unit. In this case, you will have to install the driver as a core module.</p></div></div><p>So, to install the database driver as a deployment unit, simply copy the <code class="literal">mysql-connector-java-5.1.30-bin.jar</code> driver into the <code class="literal">JBOSS_HOME/standalone/deployments</code> folder of your installation, as shown in the following image:</p><div class="mediaobject"><img src="graphics/6232OS_03_02.jpg" alt="Installing the driver as a deployment unit"/></div><p>Once you have deployed your JDBC driver, you still need to add the datasource to your server configuration file. The simplest way to do this is to paste the following datasource definition into the configuration file, as follows:</p><div class="informalexample"><pre class="programlisting">&lt;datasource jndi-name="java:/MySqlDS" pool-name="MySqlDS_Pool"  
  enabled="true" jta="true" use-java-context="true" use-ccm="true"&gt;
  &lt;connection-url&gt;
    jdbc:mysql://localhost:3306/MyDB
  &lt;/connection-url&gt;
  &lt;driver&gt;mysql-connector-java-5.1.130-bin.jar&lt;/driver&gt;
  &lt;pool /&gt;
  &lt;security&gt;
    &lt;user-name&gt;jboss&lt;/user-name&gt;
    &lt;password&gt;jboss&lt;/password&gt;
  &lt;/security&gt;
&lt;/datasource&gt;</pre></div><p>Alternatively, you can use the <span class="strong"><strong>command-line interface</strong></span> (<span class="strong"><strong>CLI</strong></span>) or the web administration console to achieve the same result, as shown later in <a class="link" href="ch07.html" title="Chapter 7. Using the Management Interfaces">Chapter 7</a>, <span class="emphasis"><em>Using the Management Interfaces</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>
<span class="strong"><strong>What about domain deployment?</strong></span>
</p><p>In this chapter, we are discussing the configuration of standalone servers. The services can also be configured in the domain servers. Domain servers, however, don't have a specified folder scanned for deployment. Rather, the management interfaces are used to inject resources into the domain. <a class="link" href="ch05.html" title="Chapter 5. Configuring a WildFly Domain">Chapter 5</a>, <span class="emphasis"><em>Configuring a WildFly Domain</em></span>, will detail all the steps to deploy a module when using a domain server.</p></div></div><div class="section" title="Choosing the right driver deployment strategy"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec21"/>Choosing the right driver deployment strategy</h3></div></div></div><p>At this point, you might wonder about a best practice for deploying the JDBC driver. Installing the driver as a deployment unit is a handy shortcut; however, it can limit its usage. Firstly, it requires a JDBC 4-compliant driver.</p><p>Deploying a non-JDBC-4-compliant driver is possible, but it requires a simple patching procedure. To do this, create a <code class="literal">META-INF/services</code> structure containing the <code class="literal">java.sql.Driver</code> file. The content of the file will be the driver name. For example, let's suppose you have to patch a MySQL driver—the content will be <code class="literal">com.mysql.jdbc.Driver</code>.</p><p>Once you have created your structure, you can package your JDBC driver with any zipping utility or the <code class="literal">.jar</code> command, <code class="literal">jar -uf &lt;your -jdbc-driver.jar&gt; META-INF/services/java.sql.Driver</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The most current JDBC drivers are compliant with JDBC 4 although, curiously, not all are recognized as such by the application server. The following table describes some of the most used drivers and their JDBC compliance:</p></div></div><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Database</p>
</th><th style="text-align: left" valign="bottom">
<p>Driver</p>
</th><th style="text-align: left" valign="bottom">
<p>JDBC 4 compliant</p>
</th><th style="text-align: left" valign="bottom">
<p>Contains java.sql.Driver</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>MySQL</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">mysql-connector-java-5.1.30-bin.jar</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes, though not recognized as compliant by WildFly</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>PostgreSQL</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">postgresql-9.3-1101.jdbc4.jar</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes, though not recognized as compliant by WildFly</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Oracle</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ojdbc6.jar</code>/<code class="literal">ojdbc5.jar</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td><td style="text-align: left" valign="top">
<p>Yes</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Oracle</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ojdbc4.jar</code>
</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td><td style="text-align: left" valign="top">
<p>No</p>
</td></tr></tbody></table></div><p>As you can see, the most notable exception to the list of drivers is the older Oracle <code class="literal">ojdbc4.jar</code>, which is not compliant with JDBC 4 and does not contain the driver information in <code class="literal">META-INF/services/java.sql.Driver</code>.</p><p>The second issue with driver deployment is related to the specific case of xa-datasources. Installing the driver as deployment means that the application server by itself cannot deduce the information about the <code class="literal">xa-datasource</code> class used in the driver. Since this information is not contained inside <code class="literal">META-INF/services</code>, you are forced to specify information about the <code class="literal">xa-datasource</code> class for each xa-datasource you are going to create.</p><p>When you install a driver as a module, the <code class="literal">xa-datasource</code> class information can be shared for all the installed datasources.</p><div class="informalexample"><pre class="programlisting">&lt;driver name="mysql-xa" module="com.mysql"&gt;
  &lt;xa-datasource-class&gt;
    com.mysql.jdbc.jdbc2.optional.MysqlXADataSource
  &lt;/xa-datasource-class&gt;
&lt;/driver&gt;</pre></div><p>So, if you are not too limited by these issues, installing the driver as a deployment is a handy shortcut that can be used in your development environment. For a production environment, it is recommended that you install the driver as a static module.</p></div></div><div class="section" title="Configuring a datasource programmatically"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Configuring a datasource programmatically</h2></div></div></div><p>After installing your driver, you may want to limit the amount of application configuration in the server file. This can be done by configuring your datasource programmatically This option requires zero modification to your configuration file, which means greater application portability. The support to configure a datasource programmatically is one of the cool features of Java EE that can be achieved by using the <code class="literal">@DataSourceDefinition</code> annotation, as follows:</p><div class="informalexample"><pre class="programlisting">@DataSourceDefinition(name = "java:/OracleDS",
  className = " oracle.jdbc.OracleDriver",
  portNumber = 1521,
  serverName = "192.168.1.1",
  databaseName = "OracleSID",
  user = "scott",
  password = "tiger",
  properties = {"createDatabase=create"})
@Singleton
public class DataSourceEJB {
  @Resource(lookup = "java:/OracleDS")
  private DataSource ds;
}</pre></div><p>In this example, we defined a datasource for an Oracle database. It's important to note that, when configuring a datasource programmatically, you will actually bypass JCA, which proxies requests between the client and the connection pool.</p><p>The obvious advantage of this approach is that you can move your application from one application server to another without the need for reconfiguring its datasources. On the other hand, by modifying the datasource within the configuration file, you will be able to utilize the full benefits of the application server, many of which are required for enterprise applications.</p></div></div></div>
<div class="section" title="Configuring the Enterprise JavaBeans container"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Configuring the Enterprise JavaBeans container</h1></div></div></div><p>The <a id="id280" class="indexterm"/>
<span class="strong"><strong>Enterprise</strong></span> <span class="strong"><strong>JavaBeans</strong></span> (<span class="strong"><strong>EJB</strong></span>) container<a id="id281" class="indexterm"/> is a fundamental part of the Java Enterprise architecture. The <a id="id282" class="indexterm"/>EJB container provides the environment used to host and manage the EJB components deployed in the container. The container is responsible for providing a standard set of services, including caching, concurrency, persistence, security, transaction management, and locking services.</p><p>The container also provides distributed access and lookup functions for hosted components, and it intercepts all method invocations on hosted components to enforce declarative security and transaction contexts. Take a look at the following figure:</p><div class="mediaobject"><img src="graphics/6232OS_03_03.jpg" alt="Configuring the Enterprise JavaBeans container"/></div><p>As depicted in this image, you <a id="id283" class="indexterm"/>will be able to deploy the full set of EJB components within WildFly:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stateless session bean (SLSB)</strong></span>: SLSBs<a id="id284" class="indexterm"/> are objects whose <a id="id285" class="indexterm"/>instances have no conversational state. This means that all bean instances are equivalent when they are not servicing a client.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Stateful session bean (SFSB)</strong></span>: SFSBs<a id="id286" class="indexterm"/> support <a id="id287" class="indexterm"/>conversational services with tightly coupled clients. A stateful session bean accomplishes a task for a particular client. It maintains the state for the duration of a client session. After session completion, the state is not retained.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Message-driven bean (MDB)</strong></span>: MDBs <a id="id288" class="indexterm"/>are a kind of <a id="id289" class="indexterm"/>enterprise beans that are able to asynchronously process messages sent by any JMS producer.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Singleton EJB</strong></span>: This is <a id="id290" class="indexterm"/>essentially similar to a <a id="id291" class="indexterm"/>stateless session bean; however, it uses a single instance to serve the client requests. Thus, you are guaranteed to use the same instance across invocations. Singletons can use a set of events with a richer life cycle and a stricter locking policy to control concurrent access to the instance. In the next chapter, which is about web applications, we will illustrate a Java EE 7 application that makes use of a Singleton EJB to hold some cached data.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>No-interface EJB</strong></span>: This is just <a id="id292" class="indexterm"/>another view of the standard session bean, except that local clients do not require a separate interface, that is, all public methods of the bean class are automatically<a id="id293" class="indexterm"/> exposed to the caller. Interfaces should only be used in EJB 3.x if you have multiple implementations.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Asynchronous EJB</strong></span>: These are <a id="id294" class="indexterm"/>able to <a id="id295" class="indexterm"/>process client requests asynchronously just like MDBs, except that they expose a typed interface and follow a more complex approach to processing client requests, which are composed of:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <a id="id296" class="indexterm"/><code class="literal">fire-and-forget</code> asynchronous void methods, which are invoked by the client</li><li class="listitem" style="list-style-type: disc">The <code class="literal">retrieve-result-later</code> asynchronous methods<a id="id297" class="indexterm"/> having a <code class="literal">Future&lt;?&gt;</code> return type</li></ul></div></li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>EJB components that don't keep conversational states (SLSB and MDB) can be optionally configured to emit timed notifications. See the <span class="emphasis"><em>Configuring the timer service</em></span> section for more information about it.</p></div></div><div class="section" title="Configuring the EJB components"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Configuring the EJB components</h2></div></div></div><p>Now that we<a id="id298" class="indexterm"/> have briefly outlined the basic types of EJB, we will look at the specific details of the application server configuration. This comprises the following components:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The SLSB configuration</li><li class="listitem" style="list-style-type: disc">The SFSB configuration</li><li class="listitem" style="list-style-type: disc">The MDB configuration</li><li class="listitem" style="list-style-type: disc">The Timer service configuration</li></ul></div><p>Let's see them all in detail.</p><div class="section" title="Configuring the stateless session beans"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec22"/>Configuring the stateless session beans</h3></div></div></div><p>EJBs are <a id="id299" class="indexterm"/>configured within the <code class="literal">ejb3.2.0</code> subsystem. By default, no<a id="id300" class="indexterm"/> stateless session bean instances exist in WildFly at startup time. As individual beans are invoked, the EJB container initializes new SLSB instances.</p><p>These instances are then kept in a pool that will be used to service future EJB method calls. The <a id="id301" class="indexterm"/>EJB remains active for the duration of the client's method call. After the method call is complete, the EJB instance is returned to the pool. Because the EJB container unbinds stateless session beans from clients after each method call, the actual bean class instance that a client uses can be different from invocation to invocation. Have a look at the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_03_04.jpg" alt="Configuring the stateless session beans"/></div><p>If all instances of an EJB class are active and the pool's maximum pool size has been reached, new <a id="id302" class="indexterm"/>clients requesting the EJB class will be blocked until an active EJB completes a method call. Depending on how you have configured your stateless pool, an acquisition timeout can be triggered if you are not able to acquire an instance from the pool within a maximum time.</p><p>You can either configure your <a id="id303" class="indexterm"/>session pool through your main configuration file or programmatically. Let's look at both approaches, starting with the main configuration file.</p><p>In order to configure your pool, you can operate on two parameters: the maximum size of the pool (<code class="literal">max-pool-size</code>) and the instance acquisition timeout (<code class="literal">instance-acquisition-timeout</code>). Let's see an example:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
 &lt;session-bean&gt;
  &lt;stateless&gt;
   &lt;bean-instance-pool-ref pool-name="slsb-strict-max-pool"/&gt;
  &lt;/stateless&gt;
  ...
 &lt;/session-bean&gt;
  ...
 &lt;pools&gt;
  &lt;bean-instance-pools&gt;
   <span class="strong"><strong>&lt;strict-max-pool name="slsb-strict-max-pool" max-pool-size="25" instance-acquisition-timeout="5" instance-acquisition-timeout-unit="MINUTES"/&gt;</strong></span>
  &lt;/bean-instance-pools&gt;
 &lt;/pools&gt;
  ...
&lt;/subsystem&gt;</pre></div><p>In this example, we have configured the SLSB pool with a <span class="emphasis"><em>strict</em></span> upper limit of <code class="literal">25</code> elements. The <a id="id304" class="indexterm"/>strict maximum pool is the only available pool instance implementation; it allows a fixed number of concurrent requests to run<a id="id305" class="indexterm"/> at one time. If there are more requests running than the pool's strict maximum size, those requests will get blocked until an instance becomes available. Within the pool configuration, we have also set an <code class="literal">instance-acquisition-timeout</code> value of <code class="literal">5</code> minutes, which will come into play if your requests are larger than the pool size.</p><p>You can configure as many pools as you like. The pool used by the EJB container is indicated by the attribute <code class="literal">pool-name</code> on the <code class="literal">bean-instance-pool-ref</code> element. For example, here we have added one more pool configuration, <code class="literal">largepool</code>, and set it as the EJB container's pool implementation. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
  &lt;session-bean&gt;
    &lt;stateless&gt;
      <span class="strong"><strong>&lt;bean-instance-pool-ref pool-name="large-pool"/&gt;</strong></span>
    &lt;/stateless&gt;
  &lt;/session-bean&gt;
  &lt;pools&gt;
    &lt;bean-instance-pools&gt;
      <span class="strong"><strong>&lt;strict-max-pool name="large-pool" max-pool-size="100" </strong></span>
<span class="strong"><strong>instance-acquisition-timeout="5" </strong></span>
<span class="strong"><strong>instance-acquisition-timeout-unit="MINUTES"/&gt;</strong></span>
    &lt;strict-max-pool name="slsb-strict-max-pool" max-pool-size="25" instance-acquisition-timeout="5" instance-acquisition-timeout-unit="MINUTES"/&gt;
    &lt;/bean-instance-pools&gt;
  &lt;/pools&gt;
&lt;/subsystem&gt;</pre></div><div class="section" title="Using CLI to configure the stateless pool size"><div class="titlepage"><div><div><h4 class="title"><a id="ch03lvl4sec01"/>Using CLI to configure the stateless pool size</h4></div></div></div><p>We have <a id="id306" class="indexterm"/>detailed the steps necessary to configure the SLSB pool size through the main configuration file. However, the suggested best practice is to use CLI to alter the server model.</p><p>Here's how you can add a new pool named <code class="literal">large-pool</code> to your EJB 3 subsystem:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/subsystem=ejb3/strict-max-bean-instance-pool=large-pool:add(max-pool-size=100)</strong></span>
</pre></div><p>Now, you can <a id="id307" class="indexterm"/>set this pool as the default to be used by the EJB container, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/subsystem=ejb3:write-attribute(name=default-slsb-instance-pool, value=large-pool)</strong></span>
</pre></div><p>Finally, you can, at any time, change the pool size property by operating on the <code class="literal">max-pool-size</code> attribute, as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>/subsystem=ejb3/strict-max-bean-instance-pool=large-pool:write-attribute(name="max-pool-size",value=50)</strong></span>
</pre></div></div></div><div class="section" title="Configuring the stateful session beans"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec23"/>Configuring the stateful session beans</h3></div></div></div><p>SFSBs<a id="id308" class="indexterm"/> are bound to a particular client. The application <a id="id309" class="indexterm"/>server uses a cache to store active EJB instances in memory so that they can be quickly retrieved for future client requests. The cache contains EJBs that are currently in use by a client and instances that were recently in use. Take a look at the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_03_05.jpg" alt="Configuring the stateful session beans"/></div><p>Having EJBs in memory is a costly operation, so you should move them out of memory as soon as possible by either passivating them or removing them.</p><p>
<span class="strong"><strong>Passivation</strong></span><a id="id310" class="indexterm"/> is a process by which the EJB container ensures that idle SFSB instances are freed from the cache by having their state saved to disk.</p><p>Removing a bean from the cache, on the other hand, is a process that can be triggered programmatically for <a id="id311" class="indexterm"/>the EJB container. To remove the EJB programmatically, add the <code class="literal">@javax.ejb.Remove</code> annotation to your method. When this method is invoked, the EJB will be removed. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">@Remove
public void remove() {}</pre></div><p>The following example shows a section of the <code class="literal">ejb3:2.0</code> subsystem, which shows the configuration of a SFSB along with its cache and passivation store configuration. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
  &lt;session-bean&gt;
<span class="strong"><strong>    &lt;stateful default-access-timeout="5000" cache-ref="distributable" passivation-disabled-cache-ref="simple"/&gt;</strong></span>
  &lt;/session-bean&gt;
  ...
  &lt;caches&gt;
<span class="strong"><strong>    &lt;cache name="simple"/&gt;</strong></span>
<span class="strong"><strong>    &lt;cache name="distributable" passivation-store-ref="infinispan" aliases="passivating clustered"/&gt;</strong></span>
  &lt;/caches&gt;
  &lt;passivation-stores&gt;
<span class="strong"><strong>    &lt;passivation-store name="infinispan" cache-container="ejb" max-size="10000"/&gt;</strong></span>
  &lt;/passivation-stores&gt;
  ...
&lt;/subsystem&gt;</pre></div><p>As you can <a id="id312" class="indexterm"/>see, the stateful bean element references a cache definition (named <code class="literal">distributable</code>), which in turn is connected to a passivation store (named <code class="literal">infinispan</code>). Notice the optional <code class="literal">max-size</code> attribute that limits the amount of SFSBs that can be contained in the cache. You can also see that the clustered cache uses infinispan's <code class="literal">passivation-store</code> (see <a class="link" href="ch08.html" title="Chapter 8. Clustering">Chapter 8</a>, <span class="emphasis"><em>Clustering</em></span>, for more information about the infinispan cache).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>In WildFly, the <code class="literal">file-passivation-store</code> and <code class="literal">cluster-passivation-store</code> elements have been deprecated in favor of <code class="literal">passivation-store</code>. Both deprecated elements will be removed completely in future releases.</p></div></div></div><div class="section" title="Configuring the message-driven beans"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec24"/>Configuring the message-driven beans</h3></div></div></div><p>
<span class="strong"><strong>Message-driven</strong></span> <span class="strong"><strong>beans</strong></span> (<span class="strong"><strong>MDBs</strong></span>) are <a id="id313" class="indexterm"/>stateless, server-side, transaction-aware<a id="id314" class="indexterm"/> components that are used to process asynchronous JMS messages.</p><p>One of the most important aspects of MDBs is that they can consume and process messages concurrently.</p><p>This capability <a id="id315" class="indexterm"/>provides a significant advantage over traditional JMS clients, which must be custom-built to manage resources, transactions, and security in a multithreaded environment.</p><p>Just as the session beans have well-defined life cycles, so does an MDB. The MDB instance's life cycle is pretty much the same as the stateless bean. An MDB <a id="id316" class="indexterm"/>has two states: <span class="strong"><strong>Does not Exist</strong></span> and <a id="id317" class="indexterm"/>
<span class="strong"><strong>Method ready Pool</strong></span>. Take a look at the following figure:</p><div class="mediaobject"><img src="graphics/6232OS_03_06.jpg" alt="Configuring the message-driven beans"/></div><p>When a message <a id="id318" class="indexterm"/>is received, the EJB container checks whether any MDB instance is available in the pool. If a bean is available, WildFly uses that instance. After an MDB instance's <code class="literal">onMessage()</code> method returns, the request is complete, and the instance is placed back in the pool. This results in the best response time, as the request is served without waiting for a new instance to be created.</p><p>If no bean instances are available, the container checks whether there is room for more MDBs in the pool by comparing the MDB's <code class="literal">MaxSize</code> attribute with the pool size.</p><p>If <code class="literal">MaxSize</code> still has not been reached, a new MDB is initialized. The creation sequence, as pointed out in the preceding diagram, is the same as that of the stateless bean. Failure to create a new instance, on the other hand, will imply that the request will be blocked until an active MDB completes. If the request cannot acquire an instance from the pool within the time defined in <code class="literal">instance-acquisition-timeout</code>, an exception is thrown.</p><p>The configuration of the MDB pool is exactly the same as for the SLSB, so we will just include it here <a id="id319" class="indexterm"/>without further explanation:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
  &lt;mdb&gt;
    &lt;resource-adapter-ref resource-adapter-name="hornetq-ra"/&gt;
    &lt;bean-instance-pool-ref pool-name="mdb-strict-max-pool"/&gt;
  &lt;/mdb&gt;
  &lt;pools&gt;
    &lt;bean-instance-pools&gt;
      &lt;strict-max-pool name="mdb-strict-max-pool" max-pool-size="20" instance-acquisition-timeout="5" instance-acquisition-timeout-unit="MINUTES"/&gt;
    &lt;/bean-instance-pools&gt;
  &lt;/pools&gt;
&lt;/subsystem&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>To learn more about the <a id="id320" class="indexterm"/>various types of enterprise beans, you can refer to the Java EE 7 tutorial at <a class="ulink" href="http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm">http://docs.oracle.com/javaee/7/tutorial/doc/ejb-intro002.htm</a>.</p></div></div></div><div class="section" title="Configuring the timer service"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec25"/>Configuring the timer service</h3></div></div></div><p>The EJB 3 timer <a id="id321" class="indexterm"/>service provides a way to allow methods to be invoked at specific times or time intervals. This is useful should your application business process need periodic notifications.</p><p>The EJB timer service<a id="id322" class="indexterm"/> can be used in any type of EJB 3, except for stateful session beans. Using the timer services is as simple as annotating a method with <a id="id323" class="indexterm"/>
<code class="literal">@javax.ejb.Timeout</code>. This method will then be triggered by the container when the time interval expires.</p><p>The following example shows you how to implement a very simple timer, which will be started by invoking the<a id="id324" class="indexterm"/> <code class="literal">scheduleTimer(long milliseconds)</code> method. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">import java.time.LocalDate;
import java.time.temporal.ChronoUnit;
import javax.annotation.Resource;
import javax.ejb.*;

@LocalBean
@Stateless
public class TimerSampleBean {

    @Resource
    private SessionContext ctx;

    public void scheduleTimer(long milliseconds) {
        LocalDate date = LocalDate.now().plus(milliseconds, ChronoUnit.MILLIS);
        ctx.getTimerService().createTimer(date.toEpochDay(), "Hello World");
    }

    @Timeout
    public void timeoutHandler(Timer timer) {
        System.out.println("* Received Timer event: " + timer.getInfo());
        timer.cancel();
    }
}</pre></div><p>As far as<a id="id325" class="indexterm"/> configuration is concerned, you can store planned executions within the filesystem or in a database. To save them in the filesystem, you <a id="id326" class="indexterm"/>need to reference the <code class="literal">default-data-store</code> attribute from the <code class="literal">file-data-store</code> attribute (both called <code class="literal">file-store</code> in this example). The number of threads reserved for the timer service can be configured with the <code class="literal">thread-pool-name</code> attribute, which needs to reference a <code class="literal">thread-pool</code> element. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
    <span class="strong"><strong>&lt;timer-service default-data-store="file-store" thread-pool-name="default"&gt;</strong></span>
        <span class="strong"><strong>&lt;data-stores&gt;</strong></span>
            <span class="strong"><strong>&lt;file-data-store name="file-store" path="timer-service-data" relative-to="jboss.server.data.dir"/&gt;</strong></span>
        <span class="strong"><strong>&lt;/data-stores&gt;</strong></span>
    <span class="strong"><strong>&lt;/timer-service&gt;</strong></span>
    &lt;thread-pools&gt;
        &lt;thread-pool name="default"&gt;
            &lt;max-threads count="10"/&gt;
            &lt;keepalive-time time="100" unit="milliseconds"/&gt;
        &lt;/thread-pool&gt;
    &lt;/thread-pools&gt;
&lt;/subsystem&gt;</pre></div></div></div><div class="section" title="Configuring the messaging system"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Configuring the messaging system</h2></div></div></div><p>Message-oriented <a id="id327" class="indexterm"/>middleware has always been<a id="id328" class="indexterm"/> an integral part of the application server. Messaging systems allow you to loosely couple heterogeneous systems together while typically providing reliability, transactions, and many other features.</p><p>Messaging is <a id="id329" class="indexterm"/>not part of the Java EE web profile, so you will not find a configuration for the messaging subsystem in the <code class="literal">standalone.xml</code> file. However, the messaging subsystem is included in the configuration file named <code class="literal">standalone-full.xml</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>Messaging systems normally support two main styles of asynchronous messaging: <span class="strong"><strong>Queues</strong></span><a id="id330" class="indexterm"/> (point-to-point messaging) and <span class="strong"><strong>Topics</strong></span><a id="id331" class="indexterm"/> (publish/subscribe messaging).</p></div></div><p>In the<a id="id332" class="indexterm"/> point-to-point model, a sender posts messages to a particular queue, and a receiver reads messages from the queue. Here, the sender knows the destination of the message and posts the message directly to the receiver's queue.</p><p>The <a id="id333" class="indexterm"/>publish/subscribe model <a id="id334" class="indexterm"/>supports the publishing of messages to a particular message topic. Subscribers may register interest in receiving messages on a particular message topic. In this model, neither the publisher nor the subscriber know about each other.</p><p>The following table shows<a id="id335" class="indexterm"/> the characteristics<a id="id336" class="indexterm"/> of the two different models:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Point-to-point messaging</p>
</th><th style="text-align: left" valign="bottom">
<p>Publish/Subscribe</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Only one consumer gets the message.</p>
</td><td style="text-align: left" valign="top">
<p>Multiple consumers (or none) will receive the message.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>The producer does not need to run at the time the consumer consumes the message, nor does the consumer need to run at the time the message is sent.</p>
</td><td rowspan="2" style="text-align: left" valign="top">
<p>The publisher has to create a message topic for clients to subscribe. The subscriber has to remain continuously active to receive messages unless he has established a durable subscription. In that case, messages published while the subscriber is not connected will be redistributed whenever he reconnects.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Every message successfully processed is acknowledged by the consumer.</p>
</td></tr></tbody></table></div><p>JBoss AS has used different JMS implementations across its releases. Since the release of Version 6.0, the default JMS provider is <a id="id337" class="indexterm"/>HornetQ (<a class="ulink" href="http://www.jboss.org/hornetq">http://www.jboss.org/hornetq</a>), which provides a multi-protocol, embeddable, high-performance, clustered, asynchronous messaging system.</p><p>At its core, HornetQ is designed simply as a set of <a id="id338" class="indexterm"/>
<span class="strong"><strong>Plain</strong></span> <span class="strong"><strong>Old</strong></span> <span class="strong"><strong>Java</strong></span> <span class="strong"><strong>Objects</strong></span> (<span class="strong"><strong>POJOs</strong></span>). It has only one JAR dependency, the Netty library, which leverages the Java <span class="strong"><strong>Non-blocking</strong></span> <span class="strong"><strong>Input/Output</strong></span> (<span class="strong"><strong>NIO</strong></span>) API <a id="id339" class="indexterm"/>to build high-performance network applications.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>Because of its easily adaptable architecture, HornetQ can be embedded in your own project or instantiated in any dependency injection framework, such as Spring or Google Guice.</p></div></div><p>In this book, we will cover the scenario where HornetQ is embedded into a WildFly subsystem as a module. The following diagram shows how the HornetQ server<a id="id340" class="indexterm"/> fits in the overall picture:</p><div class="mediaobject"><img src="graphics/6232OS_03_07.jpg" alt="Configuring the messaging system"/></div><p>As you can see, a key <a id="id341" class="indexterm"/>part of the HornetQ integration is the <span class="strong"><strong>JCA</strong></span> <span class="strong"><strong>Adaptor</strong></span> that handles the communication between the application server and the HornetQ server.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip13"/>Tip</h3><p>
<span class="strong"><strong>Why can't you simply connect your resources to the HornetQ server?</strong></span>
</p><p>This is theoretically possible; however, it violates Java EE specifications and will result in the loss of functionalities provided by the application server's JCA layer, such as connection pooling and automatic transaction enlistment. These functionalities are desirable when using messaging, say, from inside an EJB. For a description of JCA thread-pooling configuration, refer to the <span class="emphasis"><em>The bounded-queue thread pool</em></span> section in <a class="link" href="ch02.html" title="Chapter 2. Configuring the Core WildFly Subsystems">Chapter 2</a>, <span class="emphasis"><em>Configuring the Core WildFly Subsystems</em></span>.</p></div></div><div class="section" title="Configuring the transport"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec26"/>Configuring the transport</h3></div></div></div><p>Configuring<a id="id342" class="indexterm"/> the transport of a JMS message is a key part of the messaging system tuning. Out of the box, HornetQ uses Netty as its high-performance, low-level network library. Netty is a NIO client-server framework, which enables quick and easy development of network applications, such as <span class="strong"><strong>protocol</strong></span> <span class="strong"><strong>servers</strong></span> <a id="id343" class="indexterm"/>and <a id="id344" class="indexterm"/>
<span class="strong"><strong>clients</strong></span>. It greatly simplifies and streamlines network programming, such as those of the TCP and UDP socket servers.</p><p>One of the most important concepts in HornetQ transport is the definition of acceptors and connectors.</p><p>An <span class="strong"><strong>acceptor</strong></span><a id="id345" class="indexterm"/> defines which type of connection is accepted by the HornetQ server. On the other hand, a <span class="strong"><strong>connector</strong></span><a id="id346" class="indexterm"/> defines how to connect to a HornetQ server. The connector is used by a HornetQ client.</p><p>HornetQ defines three types of acceptors and connectors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>inVM</strong></span>: This <a id="id347" class="indexterm"/>type can <a id="id348" class="indexterm"/>be used when both the HornetQ client and the server run in the same virtual machine (inVM stands for intra virtual machine)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Netty</strong></span>: This <a id="id349" class="indexterm"/>type <a id="id350" class="indexterm"/>defines a way for remote connections to be made over TCP (uses the Netty project to handle the I/O)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>http</strong></span>: This<a id="id351" class="indexterm"/> type is <a id="id352" class="indexterm"/>the default configuration in WildFly and defines a way for remote connections to be made to HornetQ over HTTP (it uses Undertow to upgrade from the HTTP protocol to the HornetQ protocol)</li></ul></div><p>To communicate, a HornetQ client must use a connector compatible with the server's acceptor. A compatible client-server communication requires that it is carried out using the same type of acceptor/connector shown by the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_03_08.jpg" alt="Configuring the transport"/></div><p>We can see that it's not possible to connect an InVM client connector to a Netty server acceptor. On the <a id="id353" class="indexterm"/>other hand, it's possible to connect a HTTP client connector to a HTTP server acceptor provided they are configured to run on the same host and port.</p><p>WildFly 8 comes with a preconfigured acceptor/connector pair that is part of the WildFly messaging subsystem, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">&lt;connectors&gt;
    &lt;http-connector name="http-connector" socket-binding="http"&gt;
        &lt;param key="http-upgrade-endpoint" value="http-acceptor"/&gt;
    &lt;/http-connector&gt;
    &lt;http-connector name="http-connector-throughput" socket-binding="http"&gt;
        &lt;param key="http-upgrade-endpoint" value="http-acceptor-throughput"/&gt;
        &lt;param key="batch-delay" value="50"/&gt;
    &lt;/http-connector&gt;
    &lt;in-vm-connector name="in-vm" server-id="0"/&gt;
&lt;/connectors&gt;
&lt;acceptors&gt;
    &lt;http-acceptor name="http-acceptor" http-listener="default"/&gt;
    &lt;http-acceptor name="http-acceptor-throughput" http-listener="default"&gt;
        &lt;param key="batch-delay" value="50"/&gt;
        &lt;param key="direct-deliver" value="false"/&gt;
    &lt;/http-acceptor&gt;
    &lt;in-vm-acceptor name="in-vm" server-id="0"/&gt;
&lt;/acceptors&gt;</pre></div><p>As you can see, besides <a id="id354" class="indexterm"/>the <code class="literal">in-vm</code> acceptor/connector pair, each section defines two kinds of acceptors/connectors, one of which relies on the default configuration, <code class="literal">http-connector</code>, and the other one (<code class="literal">http-acceptor-throughput</code>) is specialized for higher messaging throughputs.</p><p>You can further tune HTTP transport when you have a more complete knowledge of the parameters that can be added to the acceptor/connector section. Here's a comprehensive list of all parameters and their meanings:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">use-nio</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If <a id="id355" class="indexterm"/>this is <code class="literal">true</code>, then Java non-blocking I/O will be used. If set to <code class="literal">false</code>, then the old blocking Java I/O will be used. The default value is <code class="literal">true</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">host</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id356" class="indexterm"/>specifies the host name or IP address to connect to (when configuring a connector) or to listen on (when configuring an acceptor). The default value for this property is <code class="literal">localhost</code>. Multiple hosts or IP addresses can be specified by separating them with commas.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">port</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id357" class="indexterm"/>specifies the port to connect to (when configuring a connector) or to listen on (when configuring an acceptor). The default value for this property is <code class="literal">5445</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">tcp-no-delay</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If<a id="id358" class="indexterm"/> this is <code class="literal">true</code>, then Nagle's algorithm will be disabled. The default value for this property is <code class="literal">true</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">tcp-send-buffer-size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id359" class="indexterm"/>parameter determines the size of the TCP send buffer in bytes. The default value for this property is <code class="literal">32768</code> bytes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">tcp-receive-buffer-size</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id360" class="indexterm"/>parameter determines the size of the TCP receive buffer in bytes. The default value for this property is <code class="literal">32768</code> bytes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">batch-delay</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id361" class="indexterm"/> parameter lets you configure HornetQ so that messages are batched up to be written for a maximum of batch-delay milliseconds before sending them for  transport. This can increase overall throughput for very small messages. The default value for this property is <code class="literal">0</code> ms.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">direct-deliver</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id362" class="indexterm"/> parameter lets you configure whether message delivery is done using the same thread as the one that carried the message. Setting this to <code class="literal">true</code> (default) reduces the thread context switch's latency at the expense of message throughput. If your goal is a higher throughput, set this parameter to <code class="literal">false</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">nio-remoting-threads</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When <a id="id363" class="indexterm"/>using NIO, HornetQ will, by default, use a number of threads equal to three times the number of core processors required to process incoming packets. If you want to override this value, you can set the number of threads by specifying this parameter. The default value for this parameter is <code class="literal">-1</code>, which means use the value derived from <code class="literal">Runtime.getRuntime().availableProcessors() * 3</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">http-client-idle-time</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id364" class="indexterm"/> determines how long a client can be idle before sending an empty HTTP request to keep the connection alive.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">http-client-idle-scan-period</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id365" class="indexterm"/>determines how often we can scan for idle clients, in milliseconds</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">http-response-time</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id366" class="indexterm"/> determines how long the server can wait before sending an empty HTTP response to keep the connection alive.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">http-server-scan-period</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id367" class="indexterm"/> determines how often we can scan for clients needing responses, in milliseconds.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">http-requires-session-id</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If <code class="literal">true</code>, the <a id="id368" class="indexterm"/>client will wait after the first call to receive a session ID.</p>
</td></tr></tbody></table></div><p>One frequent source of confusion among HornetQ users is why connectors are included in the <a id="id369" class="indexterm"/>server configuration if the server is in charge of accepting connections and delivering messages. There are two main reasons for this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sometimes the server acts as a client itself when it connects to another server, for example, when one server is bridged to another or when a server takes part in a cluster. In these cases, the server needs to know how to connect to other servers. That's defined by connectors.</li><li class="listitem" style="list-style-type: disc">If you're using JMS and the server-side JMS services to instantiate JMS <code class="literal">ConnectionFactory</code> instances and bind them in JNDI then, when creating the <code class="literal">HornetQConnectionFactory</code>, it needs to know what server that connection factory will create connections to.</li></ul></div></div><div class="section" title="Configuring connection factories"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec27"/>Configuring connection factories</h3></div></div></div><p>A JMS <code class="literal">ConnectionFactory</code> objec<a id="id370" class="indexterm"/>t is used by the client to make connections to the server. The <a id="id371" class="indexterm"/>definition of <code class="literal">connection-factory</code> instances is included in the default server configuration. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;connection-factory name="InVmConnectionFactory"&gt;
    &lt;connectors&gt;
        &lt;connector-ref connector-name="in-vm"/&gt;
    &lt;/connectors&gt;
    &lt;entries&gt;
        &lt;entry name="java:/ConnectionFactory"/&gt;
    &lt;/entries&gt;
&lt;/connection-factory&gt;
&lt;connection-factory name="RemoteConnectionFactory"&gt;
    &lt;connectors&gt;
        &lt;connector-ref connector-name="http-connector"/&gt;
    &lt;/connectors&gt;
    &lt;entries&gt;
        &lt;entry name="java:jboss/exported/jms/RemoteConnectionFactory"/&gt;
    &lt;/entries&gt;
&lt;/connection-factory&gt;</pre></div><p>You can find<a id="id372" class="indexterm"/> two connection factory definitions, which are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">InVmConnectionFactory</code>: This <a id="id373" class="indexterm"/>connection factory is bound under <code class="literal">java:/ConnectionFactory</code> and is used when the server and the client are running in the same JVM (and hence in the same WildFly server)</li><li class="listitem" style="list-style-type: disc"><code class="literal">RemoteConnectionFactory</code>: This <a id="id374" class="indexterm"/>connection factory, as the name implies, can be used when JMS connections are provided by a remote server. By default, this uses <code class="literal">http-connector</code> and is bound by the JNDI name, <code class="literal">java:jboss/exported/jms/RemoteConnectionFactory</code>.</li></ul></div></div><div class="section" title="Configuring JMS destinations"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec28"/>Configuring JMS destinations</h3></div></div></div><p>Along <a id="id375" class="indexterm"/>with the definition of connection factories in the JMS subsystem, you can find the JMS destinations (queues and topics), which are part of the server distribution. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;jms-destinations&gt;
    &lt;jms-queue name="ExpiryQueue"&gt;
        &lt;entry name="java:/jms/queue/ExpiryQueue"/&gt;
    &lt;/jms-queue&gt;
    &lt;jms-queue name="DLQ"&gt;
        &lt;entry name="java:/jms/queue/DLQ"/&gt;
    &lt;/jms-queue&gt;
&lt;/jms-destinations&gt;</pre></div><p>The <code class="literal">name</code> attribute of a queue defines the name of the queue. At the JMS level, the actual name of the queue follows a naming convention, so it will be <code class="literal">jms.queue.ExpiryQueue</code>.</p><p>The<a id="id376" class="indexterm"/> <code class="literal">entry</code> element <a id="id377" class="indexterm"/>configures the name that will be used to bind the queue to JNDI. This is a mandatory element, and the queue can contain many of these to bind the same queue to different names.</p><p>So, for example, here's how you would configure a <code class="literal">MessageDrivenBean</code> component to consume messages from the <code class="literal">ExpiryQueue</code>:</p><div class="informalexample"><pre class="programlisting">@MessageDriven(name = "MessageMDBSample", activationConfig = {
  @ActivationConfigProperty(propertyName = "destinationType", propertyValue = "javax.jms.Queue"),
  @ActivationConfigProperty(propertyName = "destination", propertyValue = "java:/jms/queue/ExpiryQueue"),
  @ActivationConfigProperty(propertyName = "acknowledgeMode", propertyValue = "Auto-acknowledge") })

public class SampleMDBean implements MessageListener {
  @Resource
  private MessageDrivenContext context;
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip14"/>Tip</h3><p>
<span class="strong"><strong>Why is it useful to know the actual destination name?</strong></span>
</p><p>Apparently, it seems not important at all to know the server's destination name (in the example, <code class="literal">jms.queue.ExpiryQueue</code>). Rather, we would be concerned about the JNDI entry where the destination is bound. However, the actual destination name plays an important role if you want to define some properties across a set of destinations. See the next section, <span class="emphasis"><em>Customizing destinations with an address</em></span>, for more information.</p></div></div><p>Queues and topic definitions can optionally include some non-mandatory elements, such as <code class="literal">selector</code> and <code class="literal">durable</code>:</p><div class="informalexample"><pre class="programlisting">&lt;jms-queue name="selectorQueue"&gt;
     &lt;entry name="/queue/selectorQueue"/&gt;
     &lt;selector&gt;name='john'&lt;/selector&gt;
     &lt;durable&gt;true&lt;/durable&gt;
&lt;/jms-queue&gt;</pre></div><p>The <code class="literal">selector</code> element<a id="id378" class="indexterm"/> defines what JMS message selector the predefined queue will have. Only messages that match the selector will be added to the queue. This is an optional element with a default value of <code class="literal">null</code> when omitted.</p><p>The <code class="literal">durable</code> element<a id="id379" class="indexterm"/> specifies whether or not the queue will be persisted. This again is optional and defaults to <code class="literal">true</code> if omitted.</p></div><div class="section" title="Customizing destinations with an address"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec29"/>Customizing destinations with an address</h3></div></div></div><p>If you want to <a id="id380" class="indexterm"/>provide some custom settings for JMS destinations, you can use the <a id="id381" class="indexterm"/>
<code class="literal">address-setting</code> block, which can be applied both to a single destination and to a set of destinations. The default configuration applies a set of minimal attributes to all destinations. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;address-settings&gt;
  &lt;!--default for catch all--&gt;
  &lt;address-setting match="#"&gt;
    &lt;dead-letter-address&gt;jms.queue.DLQ&lt;/dead-letter-address&gt;
    &lt;expiry-address&gt;jms.queue.ExpiryQueue&lt;/expiry-address&gt;
    &lt;redelivery-delay&gt;0&lt;/redelivery-delay&gt;
    &lt;max-size-bytes&gt;10485760&lt;/max-size-bytes&gt;
    &lt;message-counter-history-day-limit&gt;10&lt;/message-counter-history-day-limit&gt;
    &lt;address-full-policy&gt;BLOCK&lt;/address-full-policy&gt;
  &lt;/address-setting&gt;
&lt;/address-settings&gt;</pre></div><p>Here is a brief description of the address settings.</p><p>The address setting's <code class="literal">match</code> attribute defines a filter for the destinations. When using the wildcard, <code class="literal">#</code>, the properties will be valid across all destinations. For example:</p><div class="informalexample"><pre class="programlisting">&lt;address-setting match="jms.queue.#"&gt;</pre></div><p>Here, the settings would apply to all queues defined in the <code class="literal">destination</code> section:</p><div class="informalexample"><pre class="programlisting">&lt;address-setting match="jms.queue.ExpiryQueue "&gt;</pre></div><p>The settings would apply to the queue named <code class="literal">jms.queue.ExpiryQueue</code>.</p><p>A short description of the destination's properties is as follows:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dead-letter-address</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id382" class="indexterm"/>specifies the destination for messages that could not be delivered.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">expiry-address</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id383" class="indexterm"/>defines where to send a message that has expired.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">expiry-delay</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id384" class="indexterm"/>defines the expiration time that will be used for messages using the default expiration time.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">redelivery-delay</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id385" class="indexterm"/>defines how long to wait before attempting redelivery of a cancelled message.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">max-size-bytes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id386" class="indexterm"/>specifies the maximum size of the message in bytes before entering the <code class="literal">page</code> mode.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">page-size-bytes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id387" class="indexterm"/>specifies the size of each page file used on the paging system.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">max-delivery-attempts</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id388" class="indexterm"/>defines how many times a cancelled message can be redelivered before it is sent to the <code class="literal">dead-letter-address</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">message-counter-history-day-limit</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id389" class="indexterm"/>specifies how many days the message counter history will be kept.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">address-full-policy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id390" class="indexterm"/>used when a destination maximum size is reached. When set to <code class="literal">PAGE</code>, further messages will be paged to the disk. If the value is <code class="literal">DROP</code>, further messages will be silently dropped. When <code class="literal">BLOCK</code> is used, client message producers will be blocked when they try to send further messages.</p>
</td></tr></tbody></table></div></div><div class="section" title="HornetQ persistence configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec30"/>HornetQ persistence configuration</h3></div></div></div><p>The<a id="id391" class="indexterm"/> last HornetQ topic<a id="id392" class="indexterm"/> we need to cover is message persistence. HornetQ has its own optimized persistence engine, which can be further configured when you know all about its various components.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note24"/>Note</h3><p>The secret of HornetQ's high data persistence consists in appending data to the journal files instead of using the costly random-access operations, which require a higher degree of disk-head movement.</p><p>Journal files are precreated and filled with padding characters at runtime. By precreating files, as one is filled, the journal can immediately resume with the next one without pausing to create it.</p></div></div><p>The following are the default journal values for the messaging subsystem. Although these values are not explicitly set in the <code class="literal">standalone-full.xml</code> file, their absence causes these default values to be used.</p><div class="informalexample"><pre class="programlisting">&lt;journal-file-size&gt;102400&lt;/journal-file-size&gt;
&lt;journal-min-files&gt;2&lt;/journal-min-files&gt;
&lt;journal-type&gt;NIO&lt;/journal-type&gt;
&lt;persistence-enabled&gt;true&lt;/persistence-enabled&gt;</pre></div><p>The <a id="id393" class="indexterm"/>default <code class="literal">journal-file-size</code> (expressed in bytes) is <code class="literal">100</code> KB. The minimum number of files the journal will maintain is indicated by the property <code class="literal">journal-min-files</code>, which states that at least two files will be maintained.</p><p>The property<a id="id394" class="indexterm"/> <code class="literal">journal-type</code> indicates the type of input/output libraries used for data persistence. The valid values are <code class="literal">NIO</code> or <code class="literal">ASYNCIO</code>.</p><p>Choosing <code class="literal">NIO</code> sets the Java NIO journal. Choosing <code class="literal">AIO</code> sets the Linux asynchronous I/O journal. If you choose <code class="literal">AIO</code> but are not running Linux or you do not have <code class="literal">libaio</code> installed, then HornetQ will detect this and automatically fall back to using <code class="literal">NIO</code>.</p><p>The <a id="id395" class="indexterm"/>
<code class="literal">persistence-enabled</code> property, when set to <code class="literal">false</code>, will disable message persistence. That <a id="id396" class="indexterm"/>means no binding data, message data, large message data, duplicate ID caches, or paging data will be persisted. Disabling data persistence will give to your applications a remarkable performance boost; however, the other side of it is that your data messaging will inevitably lose reliability.</p><p>For the sake of completeness, we include some additional properties that can be included if you want to customize the messages/paging and journal storage directories. Have a look at the following code:</p><div class="informalexample"><pre class="programlisting">&lt;bindings-directory relative-to="jboss.server.data.dir" path="hornetq/bindings" /&gt;

&lt;large-messages-directory relative-to="jboss.server.data.dir" path="hornetq/largemessages" /&gt;

&lt;paging-directory relative-to="jboss.server.data.dir" path="hornetq/paging" /&gt;

&lt;journal-directory relative-to="jboss.server.data.dir" path="hornetq/journal" /&gt;</pre></div><p>For best performance, we recommend that the journal be located on its own physical volume in order to minimize disk-head movement. If the journal is on a volume that is shared with other processes, which might be writing other files (for example, bindings journal, database, or transaction coordinator), then the disk-head might move rapidly between these files as it writes them, thus drastically reducing performance.</p></div></div><div class="section" title="Configuring the transactions service"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Configuring the transactions service</h2></div></div></div><p>A transaction<a id="id397" class="indexterm"/> can be defined as a group of operations that must be performed as a unit and can involve persisting data objects, sending a message, and so on.</p><p>When the <a id="id398" class="indexterm"/>operations in a transaction are performed across databases or other resources that reside on separate computers or processes, this is known as a distributed transaction. Such enterprise-wide transactions require special coordination between the resources involved and can be extremely difficult to program reliably. This is where <span class="strong"><strong>Java Transaction API</strong></span> (<span class="strong"><strong>JTA</strong></span>)<a id="id399" class="indexterm"/> comes in, providing the interface that resources can implement and to which they can bind in order to participate in a distributed transaction.</p><p>The EJB container is a transaction manager that supports JTA and so can participate in distributed transactions involving other EJB containers as well as third-party JTA resources, such as many database management systems.</p><p>Within WildFly 8, transactions <a id="id400" class="indexterm"/>are configured in their own subsystem. The transactions subsystem consists mainly of four elements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Core environment</li><li class="listitem" style="list-style-type: disc">Recovery environment</li><li class="listitem" style="list-style-type: disc">Coordinator environment</li><li class="listitem" style="list-style-type: disc">Object store</li></ul></div><p>The <a id="id401" class="indexterm"/>core environment<a id="id402" class="indexterm"/> includes the <code class="literal">TransactionManager</code> interface, which allows the application server to control the transaction boundaries on behalf of the resource being managed. Have a look at the following diagram:</p><div class="mediaobject"><img src="graphics/6232OS_03_09.jpg" alt="Configuring the transactions service"/></div><p>A transaction coordinator, in turn, manages communication with transactional objects and resources that participate in transactions.</p><p>The <a id="id403" class="indexterm"/>recovery <a id="id404" class="indexterm"/>subsystem of JBossTS ensures that the results of a transaction <a id="id405" class="indexterm"/>are applied consistently to all resources affected by the transaction even if any of the application processes or the machine hosting them crashes or loses network connectivity.</p><p>Within the<a id="id406" class="indexterm"/> transaction service, JBoss transaction service uses an object store to persistently record the outcomes of transactions for failure recovery. As a matter of fact, the recovery manager scans the object store and other locations of information looking for transactions and resources that require or might require recovery.</p><p>The core and recovery environments can be customized by changing their socket-binding properties, which are referenced in the <code class="literal">socket-binding-group</code> configuration section.</p><p>You might find it more useful to define custom properties in the <a id="id407" class="indexterm"/>coordinator environment <a id="id408" class="indexterm"/>section, which might include the default timeout and logging statistics. Here's a sample custom transaction configuration:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
  &lt;core-environment&gt;
    &lt;process-id&gt;
      &lt;uuid/&gt;
    &lt;/process-id&gt;
  &lt;/core-environment&gt;
  &lt;recovery-environment socket-binding="txn-recovery-environment" status-socket-binding="txn-status-manager"/&gt;
<span class="strong"><strong>  &lt;coordinator-environment default-timeout="300" statistics-enabled="true" /&gt;</strong></span>
&lt;/subsystem&gt;</pre></div><p>The<a id="id409" class="indexterm"/> value of <code class="literal">default-timeout</code> specifies the default transaction timeout to be used for new transactions, which is specified as an integer in seconds.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip15"/>Tip</h3><p>
<span class="strong"><strong>How does the transaction timeout impact your</strong></span> <span class="strong"><strong>applications?</strong></span>
</p><p>The transaction timeout defines the timeout for all JTA transactions enlisted and thus severely affects your application behavior. A typical JTA transaction might be started by your EJBs or by a JMS session. So, if the duration of these transactions exceeds the specified timeout setting, the transaction service will roll back the transactions automatically.</p></div></div><p>The value of <code class="literal">statistics-enabled</code><a id="id410" class="indexterm"/> determines whether or not the transaction service should gather statistical information. The default is to not gather this information.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip16"/>Tip</h3><p>In WildFly, the <code class="literal">enable-statistics</code> property<a id="id411" class="indexterm"/> has been deprecated in favor of <code class="literal">statistics-enabled</code>. If you are migrating from JBoss AS 7, the deprecated property will still work but may be removed in future releases.</p></div></div></div></div>
<div class="section" title="Configuring concurrency"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Configuring concurrency</h1></div></div></div><p>Concurrency <a id="id412" class="indexterm"/>utilities<a id="id413" class="indexterm"/> is new to WildFly 8. As part of Java EE 7, are aim is to ease <a id="id414" class="indexterm"/>the task of multithreading within enterprise applications. Prior to Java EE 7, there was no safe way to create a new thread programmatically in your application.</p><p>With the new concurrency utilities, your new threads are now guaranteed to have access to other enterprise services, such as transactions, and security.</p><p>The main concurrency components<a id="id415" class="indexterm"/> are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ContextService</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ManagedThreadFactory</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ManagedExecutorService</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ManagedScheduledExecutorService</code></li></ul></div><div class="section" title="Configuring the context service"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Configuring the context service</h2></div></div></div><p>The<a id="id416" class="indexterm"/> context service<a id="id417" class="indexterm"/> is used to create contextual proxies from existent objects and is configured within the <code class="literal">ee</code> module of WildFly. The following is the default configuration in WildFly:</p><div class="informalexample"><pre class="programlisting">&lt;subsystem &gt;
    ....
    &lt;concurrent&gt;
        &lt;context-services&gt;
            &lt;context-service name="default" jndi-name="java:jboss/ee/concurrency/context/default" use-transaction-setup-provider="true"/&gt;
        &lt;/context-services&gt;
        ....
    &lt;/concurrent&gt;
&lt;/subsystem&gt;</pre></div><p>The <code class="literal">name</code> attribute is the name of your context service, and the <code class="literal">use-transaction-setup-provider</code> attribute states whether or not the contextual proxies should suspend and resume active transactions.</p></div><div class="section" title="Configuring the managed thread factory"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Configuring the managed thread factory</h2></div></div></div><p>The<a id="id418" class="indexterm"/> <code class="literal">ManagedThreadFactory</code> component is <a id="id419" class="indexterm"/>used to create threads that are managed by the container. The default configuration is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;concurrent&gt;
    ...
    &lt;managed-thread-factories&gt;
        &lt;managed-thread-factory name="default" jndi-name="java:jboss/ee/concurrency/factory/default" context-service="default"/&gt;
    &lt;/managed-thread-factories&gt;
    ...
&lt;/concurrent&gt;</pre></div><p>To use the default thread factory in your Java code, simply use the <code class="literal">@Resource</code> annotation without providing a value for the <code class="literal">lookup</code> attribute, as follows:</p><div class="informalexample"><pre class="programlisting">@Stateless
public class ReportBean {
    @Resource
    private Managed ;
    public void runReports() {
        MyTask myTask = new MyTask();
        Future&lt;Report&gt; future = executorService.submit(myTask);
    }
}</pre></div></div><div class="section" title="Configuring the managed executor service"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Configuring the managed executor service</h2></div></div></div><p>This class <a id="id420" class="indexterm"/>is used to execute tasks in a <a id="id421" class="indexterm"/>second thread within your enterprise application. You should always use this in preference over the executor service found within Java SE libraries. Here is an example of the configuration in WildFly:</p><div class="informalexample"><pre class="programlisting">&lt;concurrent&gt;
    ...
    &lt;managed-executor-services&gt;
       &lt;managed-executor-service name="default" jndi-name="java:jboss/ee/concurrency/executor/default"  context-service="default" hung-task-threshold="60000" core-threads="5" max-threads="25" keepalive-time="5000"/&gt;
                &lt;/managed-executor-services&gt;
    ...
&lt;/concurrent&gt;</pre></div><p>The following is the full list of attributes you can use to configure your <code class="literal">managed-executor-service</code> in WildFly:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">context-service</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id422" class="indexterm"/>defines which context service to use.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">core-threads</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id423" class="indexterm"/> defines the number of threads within the executors thread pool, including idle threads.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">hung-task-threshold</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id424" class="indexterm"/> specifies how long, in milliseconds, the threads can be allowed to run before they are considered unresponsive.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">jndi-name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id425" class="indexterm"/> specifies the JNDI name for this resource.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">keepalive-time</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id426" class="indexterm"/>specifies how long threads can remain idle when the number of threads is greater than the core thread size.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">long-running-tasks</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id427" class="indexterm"/> checks whether the thread is a short-running or long-running thread.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">max-threads</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id428" class="indexterm"/>specifies the maximum number of threads to allow in the executor's pool.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id429" class="indexterm"/>specifies the name of the resource.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">queue-length</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id430" class="indexterm"/>specifies the number of tasks that can be stored in the input queue. Zero means unlimited.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">reject-policy</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id431" class="indexterm"/>defines how you can handle a failed task. An <code class="literal">ABORT</code> value will cause an exception to be thrown; <code class="literal">RETRY_ABORT</code>, which will cause a retry, and then an abort if the retry fails.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">thread-factory</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id432" class="indexterm"/>specifies the name of the thread factory. If it's not supplied, the default thread factory is used.</p>
</td></tr></tbody></table></div></div><div class="section" title="Configuring the managed schedule executor service"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec48"/>Configuring the managed schedule executor service</h2></div></div></div><p>This is <a id="id433" class="indexterm"/>the same as the <code class="literal">ManagedExecutorService</code>, except that it has additional functionality allowing you to schedule a thread to <a id="id434" class="indexterm"/>start at specific times. Here is an example of the configuration:</p><div class="informalexample"><pre class="programlisting">&lt;concurrent&gt;
    ...
    &lt;managed-scheduled-executor-services&gt;
       &lt;managed-scheduled-executor-service name="default" jndi-name="java:jboss/ee/concurrency/scheduler/default" context-service="default" hung-task-threshold="60000" core-threads="2" keepalive-time="3000"/&gt;
                &lt;/managed-scheduled-executor-services&gt;
    ...
&lt;/concurrent&gt;</pre></div><p>The following is the list of attributes that can be used to configure your <code class="literal">managed-scheduled-executor-service</code>. Please see the preceding table in the <code class="literal">managed-executor-service</code> section<a id="id435" class="indexterm"/> for details of each property.</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">context-service</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">core-threads</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">hung-task-threshold</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">jndi-name</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">keepalive-time</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">long-running-tasks</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">name</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">reject-policy</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">thread-factory</code></li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Summary</h1></div></div></div><p>In this chapter, we continued the analysis of the application server configuration by looking at Java's enterprise services.</p><p>We first learned how to configure datasources, which can be used to add database connectivity to your applications. Installing a datasource in WildFly 8 requires two simple steps: installing the JDBC driver and adding the datasource into the server configuration.</p><p>We then looked at the enterprise JavaBeans subsystem, which allows you to configure and tune your EJB container. We looked at the basic EJB component configurations (SLSB, SFSB, and MDB) and then looked at the EJB timer service configuration that can be used to provide time-based services to your applications.</p><p>Next, we described the configuration of the message-oriented middleware, which allows you to loosely couple heterogeneous systems together while typically providing reliability, transactions, and various other features.</p><p>Then we moved on to the transaction subsystem configuration, which can be used to collect transaction logs and define the timeout for all JTA transactions enlisted.</p><p>Finally, we completed our journey by taking a look at how to configure concurrency within WildFly using the <code class="literal">ee</code> subsystem.</p><p>In the next chapter, we will discuss the web container configuration, providing a complete example, that uses a variety of enterprise technologies, and focusing on the structure and the packaging of the application.</p></div></body></html>