<html><head></head><body><div class="chapter" title="Chapter&#xA0;3.&#xA0;Collision Detection"><div class="titlepage"><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Collision Detection</h1></div></div></div><div class="blockquote"><table border="0" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td valign="top"> </td><td valign="top"><p><span class="emphasis"><em>"Live as if you were to die tomorrow. Learn as if you were to live forever."</em></span></p></td><td valign="top"> </td></tr><tr><td valign="top"> </td><td colspan="2" align="right" valign="top" style="text-align: center">--<span class="attribution"><span class="emphasis"><em>Mahatma Gandhi</em></span></span></td></tr></table></div><p>Often, you will need to determine whether two or more objects are touching in Greenfoot. This is known as <span class="emphasis"><em>collision detection</em></span> and <a id="id194" class="indexterm"/>it is necessary for most simulations and games. Detection algorithms range from simple bounding-box methods to very complex pixel color analysis. Greenfoot provides a wide variety of simple methods to accomplish collision detection; you were introduced to some of them in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>, and <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>. In this chapter, you will learn how to use Greenfoot's other built-in collision detection mechanisms and then learn more accurate methods to use them to do collision detection. While pixel-perfect collision detection is beyond the scope of this book, the border-based and hidden-sprite methods of collision detection will be sufficient for most Greenfoot applications. The topics that will be covered in this chapter are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Greenfoot built-in methods</li><li class="listitem">Border-based methods</li><li class="listitem">Hidden-sprite methods</li></ul></div><p>We will take a break from working on Avoider Game and use a simple zombie invasion simulation to illustrate our collision detection methods. Zombies seem apropos for this chapter. Judging from his quote above, I think Gandhi wanted you to learn as if you were a zombie.</p><div class="section" title="ZombieInvasion interactive simulation"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec18"/>ZombieInvasion interactive simulation</h1></div></div></div><p>In <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span> and <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>, we went step by step in building Avoider Game and <a id="id195" class="indexterm"/>ended up with playable versions of the game by the end of each chapter. In the zombie simulation, we will watch a horde of zombies break through a wall and make their way to the homes on the other side. The user will be able to interact with the simulation by placing explosions in the simulation, that will destroy both types of zombies and the wall. For our zombie simulation, I am going to supply most of the code in the beginning, and we will concentrate our efforts on implementing collision detection. All the code supplied uses concepts and techniques we covered in the last two chapters, and it should look very familiar. We will just provide an overview discussion of the code here. <span class="emphasis"><em>Figure 1</em></span> provides a picture of our scenario.</p><div class="mediaobject"><img src="../Images/image00280.jpeg" alt="ZombieInvasion interactive simulation"/><div class="caption"><p>Figure 1: Here's a screenshot of ZombieInvasion</p></div></div><p style="clear:both; height: 1em;"> </p><p>Let's create a new <a id="id196" class="indexterm"/>scenario called <code class="literal">ZombieInvasion</code> and then incrementally add and discuss the <code class="literal">World</code> subclass and <code class="literal">Actor</code> subclasses. Alternatively, you can download the<a id="id197" class="indexterm"/> initial version of <span class="strong"><strong>ZombieInvasion</strong></span> at: <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a></p><div class="section" title="Dynamically creating actors in ZombieInvasionWorld"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec17"/>Dynamically creating actors in ZombieInvasionWorld</h2></div></div></div><p>This class has two main <a id="id198" class="indexterm"/>responsibilities: placing <a id="id199" class="indexterm"/>all the actors in the world and creating an explosion whenever the mouse is clicked. For the most part, the user will just observe the scenario and will only be able to interact with it by creating explosions. The <code class="literal">ZombieInvasionWorld</code> class is rather simple because we are creating an interactive simulation and not a game. Here's the code to accomplish this:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class ZombieInvasionWorld extends World {
  private static final int DELAY = 200;
  int bombDelayCounter = 0; // Controls the rate of bombs

  public ZombieInvasionWorld() {  
   super(600, 400, 1); 
   prepare();
  }

  public void act() {
   if( bombDelayCounter &gt; 0 ) bombDelayCounter--;
   if( Greenfoot.mouseClicked(null) &amp;&amp; (bombDelayCounter == 0) ) {
     MouseInfo mi = Greenfoot.getMouseInfo();
     Boom pow = new Boom();
     addObject(pow, mi.getX(), mi.getY());
     bombDelayCounter = DELAY;
   }
  }

  private void prepare() {
   int i,j;
   for( i=0; i&lt;5; i++) {
     Wall w = new Wall();
     addObject(w, 270, w.getImage().getHeight() * i);
   }
   for( i=0; i&lt;2; i++) {
     for( j=0; j&lt;8; j++) {
      House h = new House();
      addObject(h, 400 + i*60, (12 +h.getImage().getHeight()) * j);
     }
   }
   for( i=0; i&lt;2; i++) {
     for( j=0; j&lt;8; j++) {
      Zombie1 z = new Zombie1();
      addObject(z, 80 + i*60, 15 + (2 +z.getImage().getHeight()) * j);
     }
   }
   for( i=0; i&lt;2; i++) {
     for( j=0; j&lt;7; j++) {
      Zombie2 z = new Zombie2();
      addObject(z, 50 + i*60, 30 + (3 +z.getImage().getHeight()) * j);
     }
   }
  }
}</pre></div><p>When you right-click <a id="id200" class="indexterm"/>on the scenario screen and<a id="id201" class="indexterm"/> choose <span class="strong"><strong>Save the World</strong></span> in the pop-up menu, Greenfoot will automatically create the <code class="literal">prepare()</code> method for you and will supply the appropriate code to add each <code class="literal">Actor</code> on the screen. This creates the initial state of your scenario (the one the user sees when they first run your scenario). In <code class="literal">ZombieInvasionWorld</code>, we are manually implementing the <code class="literal">prepare()</code> method and can do so in a more compact way than Greenfoot. We use for-loops to add our actors. Via this method, we add <code class="literal">Wall</code>, <code class="literal">House</code>, <code class="literal">Zombie1</code>, and <code class="literal">Zombie2</code>. We will implement these classes later in the chapter.</p><p>The <code class="literal">act()</code> method is responsible for listening for mouse-click events. If the mouse is clicked, we add a <code class="literal">Boom</code> object at the current position of the mouse. Boom is an actor we create just to display the explosion, and we want it placed exactly where the mouse was clicked. We use a delay variable, <code class="literal">boomDelayCounter</code>, to prevent the user from rapidly creating too many explosions. Remember, we explained delay variables in detail in the previous chapter, <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>. If you want the user to have the ability to rapidly create explosions, then simply remove the delay variable.</p></div><div class="section" title="Creating obstacles"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec18"/>Creating obstacles</h2></div></div></div><p>We will create two obstacles for<a id="id202" class="indexterm"/> our <a id="id203" class="indexterm"/>zombie horde: houses and walls. In the<a id="id204" class="indexterm"/> simulation, the <code class="literal">House</code> object has no functionality. It is simply an obstacle to zombie actors:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;

public class House extends Actor {
}</pre></div><p>The code for the <code class="literal">House</code> class is extremely simple. Its sole purpose is just to add an image (<code class="literal">buildings/house-8.png</code>) of a house to <code class="literal">Actor</code>. It has no other functionality.</p><p>Walls are more complex than houses. As the zombies beat on the walls, they slowly crumble. The majority of the code for the <code class="literal">Wall</code> class implements this animation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 
import java.util.List;

public class Wall extends Actor {
  int wallStrength = 2000;
  int wallStage = 0;
  
  public void act() {
   crumble();
  } 
  
  private void crumble() {
   // We will implement this in the next section…
  }
  
}</pre></div><p>The<a id="id205" class="indexterm"/> implementation of the <a id="id206" class="indexterm"/>animation of the <code class="literal">Wall</code> class crumbling is<a id="id207" class="indexterm"/> very similar to that of the <code class="literal">Avatar</code> class taking damage that we looked at, in the previous chapter, <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>. The interesting code is all contained in the <code class="literal">crumble()</code> method, which is called repeatedly from the <code class="literal">act()</code> method. <span class="emphasis"><em>Figure 1</em></span> shows the walls in various states of decay. We will implement and explain in detail the <code class="literal">crumble()</code> method in the <span class="emphasis"><em>Detecting a collision with multiple objects</em></span> section.</p></div><div class="section" title="Creating our main actor framework"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec19"/>Creating our main actor framework</h2></div></div></div><p>The <code class="literal">Zombie</code> class contains<a id="id208" class="indexterm"/> all the <a id="id209" class="indexterm"/>code that describes the behavior for zombies in our simulation. Zombies continually lumber forward trying to get to the humans in the houses. They beat on and eventually destroy any walls in the way, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*; 
import java.util.*;

public class Zombie extends Actor {
  int counter, stationaryX, amplitude;
  
  protected void addedToWorld(World w) {
   stationaryX = getX();
   amplitude = Greenfoot.getRandomNumber(6) + 2;
  }
  
  public void act() {
   shake();
   if( canMarch() ) {
     stationaryX = stationaryX + 2;
   }
  } 
  
  public void shake() {
   counter++;
   setLocation((int)(stationaryX + amplitude*Math.sin(counter/2)), getY());
  }
  
  private boolean canMarch() {
   // We will implement this in the next section… 
   return false; // Temporary return value 
  }
}</pre></div><p>The two important <a id="id210" class="indexterm"/>methods in this <a id="id211" class="indexterm"/>class are <code class="literal">shake()</code> and <code class="literal">canMarch()</code>. The <code class="literal">shake()</code> method implements the back-and-forth lumbering movement of the zombies. It calls <code class="literal">setLocation()</code> and leaves the <span class="emphasis"><em>y</em></span> coordinate unchanged. It changes the <span class="emphasis"><em>x</em></span> coordinate to have sinusoidal motion (back and forth). The distance it moves back and forth is defined by the <code class="literal">amplitude</code> variable. This type of motion was also used by one of the power-downs described in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span> and is shown in <span class="emphasis"><em>Figure 2</em></span>.</p><div class="mediaobject"><img src="../Images/image00281.jpeg" alt="Creating our main actor framework"/><div class="caption"><p>Figure 2: This is an illustration of using a sine wave to produce back and forth motion in Zombie objects. We start with a standard sine wave (a), rotate it 90 degrees (b), and reduce the amount we move in the y direction until the desired effect is achieved (not moving in the y-direction). Callouts (c) and (d) show the effects of reducing movement in the y direction.</p></div></div><p style="clear:both; height: 1em;"> </p><p>We will fully implement and explain <code class="literal">canMarch()</code> in the <span class="emphasis"><em>Detecting a collision with multiple objects</em></span> section. The method <code class="literal">canMarch()</code> checks surrounding actors (houses, walls, or other zombies) to see whether any are in the way of the zombie moving forward. As a temporary measure, we insert the following line at the end of <code class="literal">canMarch()</code>:</p><div class="informalexample"><pre class="programlisting">return false;</pre></div><p>This allows us to compile and test the code. By always returning <code class="literal">false</code>, the <code class="literal">Zombie</code> objects will never move forward. This is a simple placeholder, and we will implement the real response later in the chapter.</p><p>We have two subclasses of the <code class="literal">Zombie</code> class: <code class="literal">Zombie1</code> and <code class="literal">Zombie2</code>:</p><div class="informalexample"><pre class="programlisting">public class Zombie1 extends Zombie {
}
public class Zombie2 extends Zombie {
}</pre></div><p>This allows us to <a id="id212" class="indexterm"/>have two <a id="id213" class="indexterm"/>different-looking zombies but only write code for zombie behavior once. I chose to have a blue (<code class="literal">people/ppl1.png</code>) zombie and a yellow-orange (<code class="literal">people/ppl3.png</code>) zombie. If you have any artistic skill, you might want to create your own <code class="literal">PNG</code> images to use. Otherwise, you can continue to use the images provided with Greenfoot, as I have done.</p></div><div class="section" title="Creating an explosion"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Creating an explosion</h2></div></div></div><p>Here is the implementation of the <code class="literal">Boom</code> class we <a id="id214" class="indexterm"/>discussed <a id="id215" class="indexterm"/>previously in the description of the <code class="literal">ZombieInvasionWorld</code> class. The <code class="literal">Boom</code> class will immediately draw an explosion that will wipe out everything contained in the blast and then linger for a short time before disappearing. We create an explosion using the following code:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;
import java.util.List;

public class Boom extends Actor {
  private static final int BOOMLIFE = 50;
  private static final int BOOMRADIUS = 50;
  int boomCounter = BOOMLIFE;
  
  public Boom() {
    GreenfootImage me = new GreenfootImage
    (BOOMRADIUS*2,BOOMRADIUS*2);
    me.setColor(Color.RED);
    me.setTransparency(125);
    me.fillOval(0 , 0, BOOMRADIUS * 2, BOOMRADIUS*2);
    setImage(me);
  }
  
  public void act() {
    if( boomCounter == BOOMLIFE)
    destroyEverything(BOOMRADIUS);
    if( boomCounter-- == 0 ) {
      World w = getWorld();
      w.removeObject(this);
    }
  }
  
  private void destroyEverything(int x) {
    // We will implement this in the next section…
  }
}</pre></div><p>Let's discuss the constructor (<code class="literal">Boom()</code>) and <code class="literal">act()</code> methods. The <code class="literal">Boom()</code> method creates an image manually using the drawing methods of <code class="literal">GreenfootImage</code>. We used these drawing methods in this way to draw the stars and eyes in <code class="literal">AvoiderGame</code>, which we presented over the last two chapters,<a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml"> Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>, and <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>. The constructor concludes by setting this new image to be the image of the actor using <code class="literal">setImage()</code>.</p><p>The <code class="literal">act()</code> method has an <a id="id216" class="indexterm"/>interesting use of a<a id="id217" class="indexterm"/> delay variable. Instead of waiting for a certain amount of time (in terms of the number of calls to the <code class="literal">act()</code> method) before allowing an event to occur, the <code class="literal">boomCounter</code> delay variable is used to control how long this <code class="literal">Boom</code> object lives. After a short delay, the object is removed from the scenario.</p><p>We will discuss the implementation of the <code class="literal">destroyEverything()</code> method in a later section.</p></div><div class="section" title="Test it out"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Test it out</h2></div></div></div><p>You should now have a nearly <a id="id218" class="indexterm"/>complete zombie invasion simulation. Let's compile our scenario and make sure we eliminate any typos or mistakes introduced while adding the code. The scenario will not do much. The zombies will lumber back and forth but not make any forward progress. You can click anywhere in the running scenario and see the <code class="literal">Boom</code> explosion; however, it won't destroy anything yet.</p><p>Let's make this scenario a bit more interesting, using Greenfoot's collision detection methods.</p></div></div></div>
<div class="section" title="Built-in collision detection methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Built-in collision detection methods</h1></div></div></div><p>We are going to go through all the <a id="id219" class="indexterm"/>methods provided by Greenfoot to do collision detection. First, we will go over some methods and discuss their intended use. Then, we'll discuss the remaining methods in the context of more advanced collision detection methods (border-based and hidden-sprite). We have already used a few collision detection methods in the implementation of Avoider Game. We will only briefly describe those particular methods here. Finally, we will not discuss <code class="literal">getNeighbors()</code> and <code class="literal">intersects()</code>, as those methods are only useful for Greenfoot scenarios that contain worlds that are created with a cell size greater than one.</p><div class="note" title="Note"><h3 class="title"><a id="note14"/>Note</h3><p><span class="strong"><strong>Cell size and Greenfoot worlds</strong></span></p><p>Until now, we <a id="id220" class="indexterm"/>have only<a id="id221" class="indexterm"/> created worlds (<code class="literal">AvoiderWorld</code> and <code class="literal">ZombieInvasionWorld</code>) that have set the <code class="literal">cellSize</code> parameter of the <code class="literal">World</code> constructor to <code class="literal">1</code>. The following is an excerpt from Greenfoot's documentation on the <code class="literal">World</code> class:</p><div class="informalexample"><pre class="programlisting">public World(int worldWidth, int worldHeight, int cellSize)

Construct a new world. The size of the world (in number of cells) and the size of each cell (in pixels) must be specified.

Parameters:
worldWidth - The width of the world (in cells).
worldHeight - The height of the world (in cells).
cellSize - Size of a cell in pixels.</pre></div><p>The simple tutorials provided on Greenfoot's website mainly use large cell sizes. This makes game movement, trajectories, and collision detection very simple. We, on the other hand, want to create more flexible games that allow for smooth motion and more realistic animation. Therefore, we define our game cells to be 1 x 1 pixels (one pixel) and, correspondingly, will not discuss methods that target worlds with large cell sizes, such as <code class="literal">getNeighbors()</code> and <code class="literal">intersects()</code>.</p></div><p>As we go through our discussion, remember that we will, at times, add code to our <code class="literal">ZombieInvasion</code> scenario.</p><div class="section" title="Detecting a collision with a single object"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Detecting a collision with a single object</h2></div></div></div><p>The method <code class="literal">getOneIntersectingObject()</code> is great for simple collision detection and often used to <a id="id222" class="indexterm"/>see whether a bullet, or other type of enemy, hit the main <a id="id223" class="indexterm"/>protagonist of the game in order to subtract <a id="id224" class="indexterm"/>health, subtract life, or end the game. This is the method we used and explained in <a class="link" title="Chapter 1. Let's Dive Right in…" href="part0014.xhtml">Chapter 1</a>, <span class="emphasis"><em>Let's Dive Right in…</em></span>, to build our first working version of Avoider Game. We will not discuss it again here and only mention it in the next section as a means to illustrate the use of <code class="literal">isTouching()</code> and <code class="literal">removeTouching()</code>.</p><div class="section" title="isTouching() and removeTouching()"><div class="titlepage"><div><div><h3 class="title"><a id="ch03lvl3sec32"/>isTouching() and removeTouching()</h3></div></div></div><p>The following is a<a id="id225" class="indexterm"/> common pattern <a id="id226" class="indexterm"/>for <a id="id227" class="indexterm"/>using <code class="literal">getOneIntersectingObject()</code>:</p><div class="informalexample"><pre class="programlisting">private void checkForCollisions() {
  Actor enemy = getOneIntersectingObject(Enemy.class);
  if( enemy != null ) { // If not empty, we hit an Enemy
    AvoiderWorld world = (AvoiderWorld) getWorld();
    world.removeObject(this);
  }
}</pre></div><p>We used this basic pattern in Avoider Game several times. The <code class="literal">isTouching()</code> and <code class="literal">removeTouching()</code> methods <a id="id228" class="indexterm"/>provide a more compact way to implement the preceding pattern. Here is an equivalent function using <code class="literal">isTouching()</code> and <code class="literal">removeTouching()</code> instead of <code class="literal">getOneIntersectingObject()</code>:</p><div class="informalexample"><pre class="programlisting">private void checkForCollisions() {
  if( isTouching(Enemy.class) ) { 
    removeTouching(Enemy.class);
  }
}</pre></div><p>If all you're doing is removing an object that the object intersects with, all you need is the <code class="literal">isTouching()</code> and <code class="literal">removeTouching()</code> methods. However, if you want to do something with the object that you're intersecting with, which requires calling methods of the object's class, then you need to store the intersected object in a named variable, which requires using the <code class="literal">getOneIntersectingObject()</code> method.</p><div class="note" title="Note"><h3 class="title"><a id="tip18"/>Tip</h3><p>In general, always use <code class="literal">getOneIntersectingObject()</code> instead of <code class="literal">isTouching()</code> and <code class="literal">removeTouching()</code>. It is more flexible and provides code that is easier to extend in the future.</p></div></div></div><div class="section" title="Detecting a collision with multiple objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Detecting a collision with multiple objects</h2></div></div></div><p>The <a id="id229" class="indexterm"/>collision detection method <code class="literal">getIntersectingObjects()</code> returns<a id="id230" class="indexterm"/> a list of all the actors in a given class <a id="id231" class="indexterm"/>that the calling actor is touching. This method is needed when you need to take an action on every object that is touching a specific actor, or you need to change the state of an actor based on the number of objects touching it. When using <code class="literal">getOneIntersectingObject()</code>, you are only concerned about being touched by at least one object of a given type. For example, in the game <span class="emphasis"><em>PacMan</em></span>, you lose a life anytime you touch a ghost. It wouldn't matter if you ran into one, two, or three; the end result would be the same—you'd lose a life. However, in our zombie simulation, the <code class="literal">Wall</code> actors take damage based on how many zombies are presently beating on it. This is a perfect use for <code class="literal">getIntersectingObjects()</code>.</p><p>In the <code class="literal">Wall</code> code presented above, we left out the implementation of the <code class="literal">crumble()</code> method. Here is that code:</p><div class="informalexample"><pre class="programlisting">private void crumble() {
  List&lt;Zombie&gt; army = getIntersectingObjects(Zombie.class);
  wallStrength = wallStrength - army.size();
  if( wallStrength &lt; 0 ) {
    wallStage++;
    if( wallStage &gt; 4 ) {
      World w = getWorld();
      w.removeObject(this);
    }
    else {
      changeImage();
      wallStrength = 2000;
    }
  }
}

private void changeImage() {
  setImage("brick"+wallStage+".png");
}</pre></div><p>Let's quickly go over the things we saw before. In the <span class="emphasis"><em>Hurting the avatar</em></span> section of <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>, we changed the image of the avatar to look damaged every time it was touched by an enemy. We are using the same animation technique here to make it look like walls are taking damage. However, in this code, we have given walls a durability property that is defined by the <code class="literal">wallStrength</code> variable. The value of <code class="literal">wallStrength</code> determines how many times a wall can be hit by a zombie before it visibly looks more crumbled and cracked.</p><p>The <code class="literal">wallStrength</code> variable is actually just an example of a delay variable that we discussed in the previous chapter, <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>. Instead of this <a id="id232" class="indexterm"/>variable delaying a certain amount of time, it is delaying a certain number of zombie<a id="id233" class="indexterm"/> hits. When <code class="literal">wallStrength</code> is less than 0, we change the image using the method <code class="literal">changeImage()</code> unless this is the fourth time we have crumbled, which will cause us to remove the wall altogether. <span class="emphasis"><em>Figure 3</em></span> shows the wall images I created and used for this animation.</p><div class="mediaobject"><img src="../Images/image00282.jpeg" alt="Detecting a collision with multiple objects"/><div class="caption"><p>Figure 3: These are the four images used to animate the walls crumbling</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now, let's <a id="id234" class="indexterm"/>discuss the collision detection method <code class="literal">getIntersectingObjects()</code>. When called, this method will return all objects of a given class that intersect with the calling object. You specify the class of objects you are interested in by providing it as the argument to this method. In our code, I provided the argument <code class="literal">Zombie.class</code>, so the method would only return all the zombies that are touching the wall. Because of inheritance, we will get all of the <code class="literal">Zombie1</code> objects and all of the <code class="literal">Zombie2</code> objects that intersect. You can access, manipulate, or iterate through the objects returned using the methods defined in the <code class="literal">List</code> interface. For our purposes, we only wanted to count how many zombies we collided with. We get this number by calling the <code class="literal">size()</code> method on the <code class="literal">List</code> object returned from <code class="literal">getIntersectingObjects()</code>.</p><div class="note" title="Note"><h3 class="title"><a id="note16"/>Note</h3><p><span class="strong"><strong>Java interfaces and List</strong></span></p><p>The collision detection method <code class="literal">getIntersectingObjects()</code> introduces us for the first <a id="id235" class="indexterm"/>time to the <code class="literal">List</code> interface<a id="id236" class="indexterm"/>. In Java, interfaces are used to define a certain set of methods that two or more classes will have in common. When Java classes implement an interface, that class is promising that it implements all of the methods defined in that interface. So, the collection of <code class="literal">Actor</code> objects returned by <code class="literal">getIntersectingObjects()</code> could be stored in an array, linked list, queue, tree, or any other data structure. Whatever the data structure used for storing these objects, we know that we can access those objects via the methods defined in the <code class="literal">List</code> interface, such as <code class="literal">get()</code> or <code class="literal">size()</code>.</p><p>For more<a id="id237" class="indexterm"/> information, refer to the following link: <a class="ulink" href="http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html">http://docs.oracle.com/javase/tutorial/java/IandI/createinterface.html</a>.</p></div><p>In our <code class="literal">ZombieInvasion</code> simulation, we need to use <code class="literal">getIntersectingObjects()</code> one more time. Earlier, we left<a id="id238" class="indexterm"/> the implementation of <code class="literal">canMarch()</code> incomplete <a id="id239" class="indexterm"/>when we looked at the code for the <code class="literal">Zombie</code> class. Let's implement that method now using <code class="literal">getIntersectingObjects()</code>. Here is the code:</p><div class="informalexample"><pre class="programlisting">private boolean canMarch() {
  List&lt;Actor&gt; things = getIntersectingObjects(Actor.class);
  for( int i = 0; i &lt; things.size(); i++ ) {
    if( things.get(i).getX() &gt; getX() + 20 ) {
      return false;
    }
  }
  return true;
}</pre></div><p>This method checks <a id="id240" class="indexterm"/>whether or not there are any actors in the way of this object moving forward. It accomplishes this by first getting all objects of the <code class="literal">Actor</code> class that are touching it and then checking each one to see if it is in front of this object. We do not care if <code class="literal">Actor</code> is touching the calling object at the top, bottom, or back as these actors will not prevent this object from moving forward. This line of code in <code class="literal">canMarch()</code> gives us the list of all intersecting actors:</p><div class="informalexample"><pre class="programlisting">List&lt;Actor&gt; things = getIntersectingObjects(Actor.class);</pre></div><p>We then iterate through the list of actors using a <code class="literal">for</code> loop. To access an item in a list, you use the <code class="literal">get()</code> method. The <code class="literal">get()</code> method has one formal parameter that specifies the index of the object in the list that you want. For each actor in the list, we check to see if the <span class="emphasis"><em>x</em></span> coordinate is in front of us. If it is, we return <code class="literal">false</code> (we can't move); otherwise, we return <code class="literal">true</code> (we can move).</p><p>We have added the implementation of the <code class="literal">crumble()</code> method to the <code class="literal">Wall</code> class (don't forget to add <code class="literal">changeImage()</code> too) and the implementation of <code class="literal">canMarch()</code> to the <code class="literal">Zombie</code> class. Let's compile our scenario and observe what happens. Our simulation is almost complete. The only thing missing is the implementation of the <code class="literal">destroyEverything()</code> method in the <code class="literal">Boom</code> class. We will look at that implementation next.</p></div><div class="section" title="Detecting multiple objects in range"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Detecting multiple objects in range</h2></div></div></div><p>The last method <a id="id241" class="indexterm"/>we need to implement to complete our simulation is <code class="literal">destroyEverything()</code>. In <a id="id242" class="indexterm"/>this method, we will use the Greenfoot collision detection method <code class="literal">getObjectsInRange()</code>. This method takes two parameters. We have seen the second parameter in all of the rest of the collision detection methods, and it specifies the class of actors we are testing for collision. The first parameter provides the radius of a circle drawn around the actor that defines where to search for collision. <span class="emphasis"><em>Figure 4</em></span> shows the relationship between the <code class="literal">radius</code> parameter and the search area. Unlike <code class="literal">getIntersectingObjects()</code>, <code class="literal">getObjectsInRange()</code> returns a list of actors that are within the range specified by the calling object.</p><div class="mediaobject"><img src="../Images/image00283.jpeg" alt="Detecting multiple objects in range"/><div class="caption"><p>Figure 4: This shows the purpose of the radius parameter of the getObjectsInRange() method</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now that we know about the method <code class="literal">getObjectsInRange()</code>, let's look at the implementation of <code class="literal">destroyEverything()</code>:</p><div class="informalexample"><pre class="programlisting">private void destroyEverything(int x) {
  List&lt;Actor&gt; objs = getObjectsInRange(x, Actor.class);
  World w = getWorld();
  w.removeObjects(objs);
}</pre></div><p>This method is short, yet<a id="id243" class="indexterm"/> powerful. It calls <code class="literal">getObjectsInRange()</code> with a <a id="id244" class="indexterm"/>radius <code class="literal">x</code>, the value that was passed to <code class="literal">destroyEverything()</code> when called, and <code class="literal">Actor.class</code>, which in Greenfoot terms means everything. All objects within the circle defined by the radius will be returned by <code class="literal">getObjectsInRange()</code> and stored in the <code class="literal">objs</code> variable. Now, we could iterate through all the objects contained in <code class="literal">objs</code> and remove them one at a time. Luckily, Greenfoot provides a function that can remove a list of objects with one call. Here's its definition in Greenfoot's documentation:</p><div class="informalexample"><pre class="programlisting">public void removeObjects(java.util.Collection objects)
Remove a list of objects from the world.

Parameters:
objects - A list of Actors to remove.</pre></div></div><div class="section" title="Time to test it out"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Time to test it out</h2></div></div></div><p>The simulation is complete. Compile<a id="id245" class="indexterm"/> and run it and make sure everything works as anticipated. Remember, you can click anywhere to blow up buildings, walls, and zombies. Reset the scenario and move things around. Add walls and zombies and see what happens. Nice work!</p></div></div>
<div class="section" title="Border-based collision detection methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Border-based collision detection methods</h1></div></div></div><p>Border-based collision detection <a id="id246" class="indexterm"/>involves incrementally searching outward from <code class="literal">Actor</code> until either a collision is detected, or it is determined there are no obstacles in the way. The method finds the edge (or border) of the item collided with. This method is especially useful when objects need to bounce off each other or one object is landing on another and needs to remain on that object for a certain amount of time, for example, when a user-controlled <code class="literal">Actor</code> is jumping on a platform. We will introduce this method of collision detection in this chapter, as well as use it in upcoming chapters.</p><div class="section" title="Detecting single-object collisions at an offset"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Detecting single-object collisions at an offset</h2></div></div></div><p>The <span class="emphasis"><em>at offset</em></span> <a id="id247" class="indexterm"/>versions <a id="id248" class="indexterm"/>of Greenfoot's collision detection methods are well suited to border-based collision detection. They allow us to check for a collision at a certain distance, or offset, from the center of the calling <code class="literal">Actor</code>. To demonstrate the use of this method, we will change the implementation of the <code class="literal">canMarch()</code> method in the <code class="literal">Zombie</code> class. Here is our revised version:</p><div class="informalexample"><pre class="programlisting">private boolean canMarch() {
  int i=0;
  while(i&lt;=step) {
    int front = getImage().getWidth()/2;
    Actor a = getOneObjectAtOffset(i+front, 0, Actor.class);
    if( a != null ) {
      return false;
    }
    i++;
  }
  return true;
}</pre></div><p>Typically, when an actor moves, it will change its position by a certain number of pixels. In the <code class="literal">Zombie</code> class, how far zombies will move, if they can, is stored in the <code class="literal">step</code> variable. We need to declare and initialize this instance variable by inserting the following line of code at the top of the <code class="literal">Zombie</code> class, as follows:</p><div class="informalexample"><pre class="programlisting">private int step = 4;</pre></div><p>Using a <code class="literal">step</code> <a id="id249" class="indexterm"/>variable<a id="id250" class="indexterm"/> to store the length of movement for an actor is common practice. In the implementation of <code class="literal">canMarch()</code> above, we check each pixel in front of a zombie up to and including taking a full step. This is handled by the <code class="literal">while</code> loop. We increment the variable <code class="literal">i</code> from <code class="literal">0</code> to <code class="literal">step</code>, checking for a collision each time at the location <code class="literal">i + front</code>. Since the origin location of an object is its center, we set <code class="literal">front</code> to be half of the width of the image representing this actor. <span class="emphasis"><em>Figure 5</em></span> illustrates this search.</p><div class="mediaobject"><img src="../Images/image00284.jpeg" alt="Detecting single-object collisions at an offset"/><div class="caption"><p>Figure 5: Using border-based detection, an object searches for a collision one pixel at a time. It starts from its front and then searches for an object starting at front + 0 all the way to front + step.</p></div></div><p style="clear:both; height: 1em;"> </p><p>If we detect a collision any time in our while loop, we return <code class="literal">false</code>, indicating the actor cannot move forward; otherwise, we return <code class="literal">true</code>. Test out this new version of <code class="literal">canMarch()</code>.</p></div><div class="section" title="Detecting multiple-object collisions at an offset"><div class="titlepage"><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Detecting multiple-object collisions at an offset</h2></div></div></div><p>The collision <a id="id251" class="indexterm"/>detection method <code class="literal">getObjectsAtOffset()</code> is very similar to <code class="literal">getOneObjectAtOffset()</code>. It<a id="id252" class="indexterm"/> just, as the name implies, returns all actors that collide at the given offset. To demonstrate its use, we are going to re-implement <code class="literal">canMarch()</code> as we did for <code class="literal">getOneObjectAtOffset()</code>. To take advantage of getting a list of actors that collide, we are going to add some additional functionality to <code class="literal">canMarch()</code>. For each actor blocking the forward movement of the zombie, we are going to shove them a little.</p><p>Here's the implementation of <code class="literal">canMarch()</code>:</p><div class="informalexample"><pre class="programlisting">private boolean canMarch() {
  int front = getImage().getWidth()/2;
  int i = 1;
  while(i&lt;=step) {
    List&lt;Actor&gt; a = getObjectsAtOffset(front+i,0,Actor.class);
    if( a.size() &gt; 0 ) {
      for(int j=0;j&lt;a.size()&amp;&amp;a.get(j) instanceof Zombie;j++){
        int toss = Greenfoot.getRandomNumber(100)&lt;50 ? 1 : -1;
        Zombie z = (Zombie) a.get(j);
        z.setLocation(z.getX(),z.getY()+toss);
      }
      return false;
    }
    i++;
  }
  return true;
}</pre></div><p>In this version, we use a <code class="literal">while</code> loop and <code class="literal">step</code> variable in much the same way we did previously for the <code class="literal">getOneObjectAtOffset()</code> version of <code class="literal">canMarch()</code>. Inside the <code class="literal">while</code> loop is where we added the new "shoving" functionality. When we detect that there is at least one <code class="literal">Actor</code> in the list, we iterate through the list using a <code class="literal">for</code> loop to slightly push each actor we collided with. The first thing we do in the <code class="literal">for</code> loop is check whether or not the <code class="literal">Actor</code> class is a <code class="literal">Zombie</code> class using the <code class="literal">instanceof</code> operator. If it isn't, we skip over it. We don't want the ability to shove <code class="literal">Wall</code> or <code class="literal">House</code>. For each zombie we collided with, we set the <code class="literal">toss</code> variable to <code class="literal">1</code> or <code class="literal">-1</code> with equal probability We then move that zombie with <code class="literal">setLocation()</code>. The effect is interesting and gives the illusion that the zombies are trying to push and shove their way to the front. Compile and run the scenario with the changes to <code class="literal">canMarch()</code> and see for yourself. <span class="emphasis"><em>Figure 6</em></span> shows how the zombies bunch up with the preceding changes.</p><div class="note" title="Note"><h3 class="title"><a id="note17"/>Note</h3><p><span class="strong"><strong>The instanceof Operator</strong></span></p><p>Java's <code class="literal">instanceof</code> operator<a id="id253" class="indexterm"/> checks whether the left-hand side argument is<a id="id254" class="indexterm"/> an object created from the class (or any of its subclasses) specified on the right-hand side. It will return <code class="literal">true</code> if it is and <code class="literal">false</code> <a id="id255" class="indexterm"/>otherwise. It will also return <code class="literal">true</code> if the left-hand side object implements the interface specified on the right-hand side.</p></div><div class="mediaobject"><img src="../Images/image00285.jpeg" alt="Detecting multiple-object collisions at an offset"/><div class="caption"><p>Figure 6: Here's a view of the zombies pushing and shoving to get to the humans in the houses first</p></div></div><p style="clear:both; height: 1em;"> </p></div></div>
<div class="section" title="Hidden-sprite collision detection methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Hidden-sprite collision detection methods</h1></div></div></div><p>One flaw with <a id="id256" class="indexterm"/>the <code class="literal">getOneObjectAtOffets()</code> and <code class="literal">getObjectsAtOffset()</code> methods is that they only check the granularity of a single pixel. If an object of interest is one pixel above or below the offset provided to these methods, then no collision will be detected. In fact, in this implementation, if you allow the simulation to run until the zombies reach the houses, you'll notice that some zombies can move past the houses. This is because the pixel-only check fails between houses. One way to handle this deficiency is to use hidden-sprite collision detection. <span class="emphasis"><em>Figure 7</em></span> illustrates this method.</p><div class="mediaobject"><img src="../Images/image00286.jpeg" alt="Hidden-sprite collision detection methods"/><div class="caption"><p>Figure 7: This shows the use of a hidden sprite to check for collisions.</p></div></div><p style="clear:both; height: 1em;"> </p><p>In the hidden-sprite method, you use another <code class="literal">Actor</code> class to test for collisions. <span class="emphasis"><em>Figure 7</em></span> shows a <code class="literal">Zombie</code> object using a smaller, auxiliary <code class="literal">Actor</code> class to determine if a collision occurred with the flower. While the hidden sprite is shown as a translucent red rectangle, in practice, we would set the transparency (using <code class="literal">setTransparency()</code>) to <code class="literal">0</code>, so that it would not be visible. The hidden-sprite method is very flexible because you can create any shape or size for <a id="id257" class="indexterm"/>your hidden sprite, and it does not have the problem of only looking at a single pixel that the two previous collision detection methods had. Next, we will once again change the <code class="literal">canMarch()</code> method in the <code class="literal">Zombie</code> class, this time using hidden-sprite collision detection.</p><p>The first thing we need to do, is create a new <code class="literal">Actor</code> that will serve as the hidden sprite. Because we are going to use this hidden sprite for zombies, let's call it <code class="literal">ZombieHitBox</code>. Create this subclass of <code class="literal">Actor</code> now and do not associate an image with it. We will draw the image in the constructor. Here is the implementation of <code class="literal">ZombieHitBox</code>:</p><div class="informalexample"><pre class="programlisting">import greenfoot.*;
import java.awt.Color;
import java.util.*;

public class ZombieHitBox extends Actor {
  GreenfootImage body;
  int offsetX;
  int offsetY;
  Actor host;
  
  public ZombieHitBox(Actor a, int w, int h, int dx, int dy, boolean visible) {
    host = a;
    offsetX = dx;
    offsetY = dy;
    body = new GreenfootImage(w, h);
    if( visible ) {
      body.setColor(Color.red);
      // Transparency values range from 0 (invisible)
      // to 255 (opaque)
      body.setTransparency(100);
      body.fill();
    }
    setImage(body);
  }
  
  public void act() {
    if( host.getWorld() != null ) {
      setLocation(host.getX()+offsetX, host.getY()+offsetY);
    } else {
      getWorld().removeObject(this);
    }
  }
  
  public List getHitBoxIntersections() {
    return getIntersectingObjects(Actor.class);
  }
}</pre></div><p>The constructor for <code class="literal">ZombieHitBox</code> takes six parameters. The reason it takes so many parameters is that we need to provide the <code class="literal">Actor</code> class to which it is attached (the <code class="literal">a</code> parameter), define <a id="id258" class="indexterm"/>the size of the rectangle to draw (the <code class="literal">w</code> and <code class="literal">h</code> parameters), provide the offset of the rectangle from the provided <code class="literal">Actor</code> (the <code class="literal">dx</code> and <code class="literal">dy</code> parameters), and check whether the hidden sprite is visible (the <code class="literal">visible</code> parameter). In the constructor, we use <code class="literal">GreenfootImage()</code>, <code class="literal">setColor()</code>, <code class="literal">setTransparency()</code>, <code class="literal">fill()</code>, and <code class="literal">setImage()</code> to draw the hidden sprite. We went over these methods previously in <a class="link" title="Chapter 2. Animation" href="part0017.xhtml">Chapter 2</a>, <span class="emphasis"><em>Animation</em></span>.</p><p>We use the <code class="literal">act()</code> method to ensure that this hidden sprite moves along with the <code class="literal">Actor</code> class it is attached to (we will call this the <code class="literal">host</code> actor). To do this, we simply call <code class="literal">setLocation()</code>, provide the current <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> position of the host actor and shift a little according to the offset values provided in the constructor. Before doing this, however, we check whether the <code class="literal">host</code> has not been deleted. If it has, we delete the hit box, as it only has meaning in relation to <code class="literal">host</code>. This handles the case where an explosion destroys <code class="literal">host</code>, but did not quite reach the hit box.</p><p>Finally, we provide one public method that the <code class="literal">host</code> actor will use to get all the actors that are colliding with the hidden sprite. We named this method as <code class="literal">getHitBoxIntersections()</code>.</p><p>Next, we need to augment the <code class="literal">Zombie</code> class to use this new hidden sprite. We need a handle on this hidden sprite, so we need to add a new property to the <code class="literal">Zombie</code> class. Insert this line of code under the declaration of the <code class="literal">step</code> variable:</p><div class="informalexample"><pre class="programlisting">private ZombieHitBox zbh;</pre></div><p>Next, we need to augment the <code class="literal">addedToWorld()</code> method to create and connect <code class="literal">ZombieHitBox</code> to <code class="literal">Zombie</code>. Here is the implementation of that method:</p><div class="informalexample"><pre class="programlisting">protected void addedToWorld(World w) {
  stationaryX = getX();
  amplitude = Greenfoot.getRandomNumber(6) + 2;
  zbh = new ZombieHitBox(this, 10, 25, 10, 5, true);
  getWorld().addObject(zbh, getX(), getY());
}</pre></div><p>We create a 10 x 25 rectangle for our hidden sprite and initially make it visible, so that we can test it in our scenario. Once you are satisfied with the placement and size of your hidden sprite, you should change the <code class="literal">visible</code> parameter of <code class="literal">ZombieHitBox</code> from <code class="literal">true</code> to <code class="literal">false</code>.</p><p>Now that we have created, initialized, and placed <code class="literal">ZombieHitBox</code>, we can make our changes to <code class="literal">canMarch()</code> to <a id="id259" class="indexterm"/>demonstrate the use of the hidden-sprite method:</p><div class="informalexample"><pre class="programlisting">private boolean canMarch() {
  if( zbh.getWorld() != null ) {
    List&lt;Actor&gt; things = zbh.getHitBoxIntersections();
    if( things.size() &gt; 1 ) {
      int infront = 0;
      for(int i=0; i &lt; things.size(); i++ ) {
        Actor a = things.get(i);
        if( a == this || a instanceof ZombieHitBox)
        continue;
        if( a instanceof Zombie) {
          int toss =
          Greenfoot.getRandomNumber(100)&lt;50 ? 1:-1;
          infront += (a.getX() &gt; getX()) ? 1 : 0;
          if( a.getX() &gt;= getX() )
          a.setLocation(a.getX(),a.getY()+toss);
        } else {
          return false;
        }
      }
      if( infront &gt; 0 ) {
        return false;
      } else {
        return true;
      }
    }
    return true;
  } else {
    getWorld().removeObject(this);
  }
  return false;
}</pre></div><p>Unlike previous implementations of <code class="literal">canMarch()</code>, we need to first ask the hidden sprite for a list of actors colliding with this zombie. Once we get that list, we check that it has a size greater than one. The reason why it needs to be greater than one, is that <code class="literal">ZombieHitBox</code> will include the zombie it is attached to. If we are not colliding with any other zombies or actors, we return <code class="literal">true</code>. If we are colliding with a number of actors, then we iterate through them all and make some decisions based on the type of <code class="literal">Actor</code>. If <code class="literal">Actor</code> is this zombie or an instance of <code class="literal">ZombieHitBox</code>, we skip it and don't take any action. The next check is whether or not <code class="literal">Actor</code> is an instance of the <code class="literal">Zombie</code> class. If it isn't, then it is some other object, such as <code class="literal">House</code> or <code class="literal">Wall</code>, and we return <code class="literal">false</code>, so that we will not move forward. If it is an instance of the <code class="literal">Zombie</code> class, we check whether or not it is in front of this zombie. If it is, we shove it a little (just as we did in the previous implementation of <code class="literal">canMarch()</code>) and increment the <code class="literal">infront</code> variable. At the end of iterating through the list of actors, we check the <code class="literal">infront</code> variable. If there were any zombies in front of this <a id="id260" class="indexterm"/>zombie, we return <code class="literal">false</code> to prevent it from moving forward. Otherwise, we return <code class="literal">true</code>. The outermost <code class="literal">if</code> statement simply checks that the hitbox (<code class="literal">zbh</code>) associated with this object has not been previously destroyed by a <code class="literal">Boom</code> object. If it has, then we need to remove this object too.</p><p>Compile and run this version of the scenario. You should observe that the zombies bunch up nicely, push and shove each other, yet they are not able to move past the houses. Using the hidden-sprite method of collision detection is a bit more complex than the rest, but gives us good accuracy.</p></div>
<div class="section" title="Challenge"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Challenge</h1></div></div></div><p>Okay, we have implemented several forms of collision detection in our zombie simulation. Which method of collision detection do you prefer for this simulation?</p><p>For a challenge, create an <code class="literal">Actor</code> ball that occasionally rolls in from the left and knocks zombies out of the way. If the ball hits <code class="literal">Wall</code>, have it do 1,000 damage to it. Which form of collision detection will you use to detect collisions between the ball and zombies and between the ball and a wall?</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Summary</h1></div></div></div><p>Collision detection is a crucial component of any game, simulation, or interactive application. Greenfoot provides built-in methods of detecting collisions. In this chapter, we carefully explained each of these methods and then demonstrated how you could use them to do more advanced collision detection. Specifically, we discussed border-based and hidden-sprite techniques. Moving forward, we will use collision detection often and will choose a method appropriate for our example. In the next chapter, we will look at projectiles and will have ample opportunity to put into practice what you have learned in this chapter.</p></div></body></html>