- en: 12\. Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 12. 并发
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: 'In this chapter we will explore Clojure''s concurrency features. On the JVM,
    you will learn the basics of programming with multiple processor threads: starting
    a new thread and using the results. To coordinate your threads, we will use Clojure''s
    innovative reference types. One of these, the atom, can also be used in a JavaScript
    environment.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探索Clojure的并发特性。在JVM上，你将学习使用多个处理器线程进行编程的基础：启动新线程和使用结果。为了协调你的线程，我们将使用Clojure的创新引用类型。其中之一，原子，也可以在JavaScript环境中使用。
- en: By the end of this chapter, you will be able to build simple browser games and
    manage their state using atoms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够构建简单的浏览器游戏，并使用原子管理它们的状态。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Ever since the Clojure language was first introduced, its concurrency model
    has been one of its major selling points. In programming, the word "concurrency"
    can apply to a lot of different situations. To start with a simple definition,
    any time your program or your system has more than one simultaneous flow of operations,
    you are dealing with concurrency. In multithreaded Java programs, that would mean
    code running simultaneously in separate processor threads. Each processor thread
    follows its own internal logic, but to work properly your program needs to coordinate
    the communication between the different threads. Even though JavaScript runtimes
    are single-threaded, both the browser and Node.js environments have their own
    ways of dealing with simultaneous logical flows. While the roots of Clojure's
    concurrency are definitely in Java, some of the ideas and tools apply equally
    in **ClojureScript**.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Clojure语言首次推出以来，其并发模型一直是其主要卖点之一。在编程中，“并发”一词可以应用于许多不同的场景。首先给出一个简单的定义，任何你的程序或系统有多个同时的操作流程时，你就是在处理并发。在多线程的Java程序中，这意味着代码在独立的处理器线程中同时运行。每个处理器线程遵循其自身的内部逻辑，但为了正常工作，你的程序需要协调不同线程之间的通信。尽管JavaScript运行时是单线程的，但浏览器和Node.js环境都有自己处理同时逻辑流程的方法。虽然Clojure的并发根源肯定在Java中，但其中一些思想和工具在**ClojureScript**中也同样适用。
- en: In this chapter, you will learn the basics of concurrent programming. Some of
    Clojure's features, such as **Software Transactional Memory** (**STM**), are mostly
    useful in large, complex systems. While we can't simulate all of that complexity
    in a single chapter, we will explore the basic concepts and tools that Clojure
    provides. To demonstrate the techniques and get you up to speed on concurrency,
    we'll use two different environments. On the JVM, you'll learn how to create threads
    that communicate with each other. In the browser, you'll learn how to coordinate
    events that occur in different parts of the web page.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习并发编程的基础。Clojure的一些特性，如**软件事务内存**（**STM**），主要适用于大型、复杂的系统。虽然我们无法在一个章节中模拟所有这种复杂性，但我们将探讨Clojure提供的基本概念和工具。为了展示这些技术和让你熟悉并发，我们将使用两个不同的环境。在JVM上，你将学习如何创建相互通信的线程。在浏览器上，你将学习如何协调发生在网页不同部分的事件。
- en: Concurrency in General
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一般的并发
- en: Modern computers use **threads** to distribute execution between multiple processor
    cores. There are many reasons for this, including the physics of microchip design
    and the need for user environments that remain responsive even when one program
    is performing an intensive computation in the background. Everyone wants to be
    able to check their email, listen to music, and run their Clojure REPL at the
    same time! Inside a program, this kind of multitasking can also represent a significant
    performance gain. While one thread is waiting for data from the disk drive, another
    for the network, two other threads can be processing data. When done correctly,
    this can represent a significant gain in performance and overall efficiency. The
    operative phrase here, though, is "when done correctly." Concurrency can be tricky.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 现代计算机使用**线程**在多个处理器核心之间分配执行。这有很多原因，包括微芯片设计的物理特性以及需要用户环境在后台程序进行密集计算时仍然保持响应性的需求。每个人都希望能够在检查电子邮件、听音乐和运行Clojure
    REPL的同时进行操作！在程序内部，这种多任务处理也可以代表显著的性能提升。当一个线程正在等待来自磁盘驱动器的数据，另一个线程等待网络时，另外两个线程可以处理数据。当正确执行时，这可以代表性能和整体效率的显著提升。然而，这里的操作短语是“当正确执行时”。并发可能很棘手。
- en: 'Most computer code is written in a linear manner: do this, do that, then do
    this. The source code for a method or a function reads from top to bottom. We
    think about code linearly when we are writing it. In a multithreaded system, that''s
    not how your code will be executed. Some parts of your program will run in one
    thread, and other parts in other threads, simultaneously. Coordination becomes
    a new problem. Experience shows that multithreaded applications are harder to
    write and tend to be more error-prone than single-threaded applications. Most
    of all, they are harder for us to understand. So, while there is a potential for
    better performance, there is also a potential for greater complexity. Like many
    aspects of programming, it''s all about trade-offs.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机代码是以线性方式编写的：这样做，那样做，然后这样做。方法或函数的源代码是从上到下读取的。我们在编写代码时线性地思考代码。在多线程系统中，代码的执行方式并非如此。程序的一些部分将在一个线程中运行，而其他部分将在其他线程中同时运行。协调成为了一个新的问题。经验表明，多线程应用程序比单线程应用程序更难编写，并且更容易出错。最重要的是，它们对我们来说更难理解。因此，虽然存在更好的性能潜力，但也存在更大的复杂性潜力。就像编程的许多方面一样，这完全是关于权衡。
- en: 'Clojure''s most important concurrency feature is actually one that you''ve
    been using from the beginning: immutability. Clojure''s immutable data types provide
    a special kind of protection throughout your system. Values are locked down once
    and for all; if a separate thread needs to "modify" your data, it will actually
    use an efficient copy that won''t interfere with the other threads. And because
    this feature is a fundamental part of the Clojure language, you get it for "free":
    data is immutable by default, so there is no extra procedure to prepare it for
    concurrency.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure最重要的并发特性实际上是从一开始你就一直在使用的：不可变性。Clojure的不可变数据类型在整个系统中提供了一种特殊类型的保护。值一旦锁定就永远不变；如果另一个线程需要“修改”你的数据，它实际上会使用一个高效的副本，而不会干扰其他线程。而且因为这是Clojure语言的基本组成部分，你可以“免费”获得它：数据默认是不可变的，因此没有额外的程序来为并发做准备。
- en: 'When a new thread is created, we say that the current thread has been forked.
    The parent thread shares its state with the new thread but loses control of the
    execution flow. Let''s take a look at how things can go wrong when values are
    mutable:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的线程时，我们说当前线程已经被分叉。父线程与其新线程共享其状态，但失去了对执行流程的控制。让我们看看当值是可变的时，事情可能会出错：
- en: '![Figure 12.1: Shared state in a language with mutable data structures can
    lead to problems'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.1：在具有可变数据结构的语言中，共享状态可能导致问题]'
- en: '](img/B14502_12_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_12_01.jpg]'
- en: 'Figure 12.1: Shared state in a language with mutable data structures can lead
    to problems'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1：在具有可变数据结构的语言中，共享状态可能导致问题
- en: 'In this diagram, we can see a main thread that creates a fork. In the original
    thread, the variable, `x`, is an array: `[5, 3, 7]`. The fork then modifies the
    array. Because it is shared between the two threads, the array is also modified
    in the main thread. From the point of view of the main thread, the value of `x`
    seems to change suddenly for no reason, as if modified by some external force.
    This is an oversimplification, of course, since languages such as Java do allow
    programmers to protect themselves from problems like this. However, shared mutable
    state does create a risk of this kind of problem.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，我们可以看到一个主线程创建了一个分叉。在原始线程中，变量`x`是一个数组：`[5, 3, 7]`。然后分叉修改了这个数组。因为它在两个线程之间是共享的，所以数组也在主线程中被修改。从主线程的角度来看，`x`的值似乎突然无原因地改变，就像被某种外部力量修改一样。当然，这是一个过于简化的说法，因为像Java这样的语言确实允许程序员保护自己免受这类问题的困扰。然而，共享的可变状态确实会带来这种类型问题的风险。
- en: 'Immutability in Clojure largely solves this part of the problem. Here''s a
    similar diagram representing a Clojure version of the same thing:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中，不可变性在很大程度上解决了这个问题。下面是一个表示Clojure版本相同内容的相似图表：
- en: '![Figure 12.2: Clojure''s immutable data structures are never modified: changes
    create new'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.2：Clojure的不可变数据结构永远不会被修改：更改会创建新的数据版本]'
- en: versions of the data
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数据版本
- en: '](img/B14502_12_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_12_02.jpg]'
- en: 'Figure 12.2: Clojure''s immutable data structures are never modified: changes
    create new versions of the data'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2：Clojure的不可变数据结构永远不会被修改：更改会创建新的数据版本
- en: Automatic Parallelization with pmap
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用pmap进行自动并行化
- en: 'Nearly every kind of concurrency involves some additional complexity for the
    programmer. There is an exception to this rule though: Clojure''s `pmap` function.
    The name is the abbreviation of `map`, `pmap` calls a function on each item in
    a list. The difference is that each function call runs on a separate thread so
    that some of the calculations can be run simultaneously.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎所有类型的并发都会给程序员带来一些额外的复杂性。然而，这个规则有一个例外：Clojure 的 `pmap` 函数。这个名字是 `map` 的缩写，`pmap`
    在列表中的每个项目上调用一个函数。区别在于每个函数调用都在一个单独的线程上运行，这样一些计算可以同时进行。
- en: 'In this diagram, we map an imaginary function, `pfn`, over a simple vector.
    For each item, `pmap` calls `pfn` in a new thread:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们映射一个想象中的函数，`pfn`，到一个简单的向量上。对于每个项目，`pmap` 在一个新线程中调用 `pfn`：
- en: '![Figure 12.3: pmap spawns new threads so that calculations can occur simultaneously'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.3：pmap 生成新线程以便同时进行计算'
- en: '](img/B14502_12_03.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_03.jpg)'
- en: 'Figure 12.3: pmap spawns new threads so that calculations can occur simultaneously'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3：pmap 生成新线程以便同时进行计算
- en: 'This might seem like great news. In certain cases, it might be. But if you''re
    thinking "I''ll use `pmap` all the time and my program will run faster," you''ll
    be disappointed most of the time. The problem is that there is a lot of behind-the-scenes
    work that must occur for `pmap` to spawn new threads. It turns out that `pmap`
    is only more efficient than the single-threaded `map` function when the calculation
    is particularly time-consuming. We can compare the relative speed of `map` and
    `pmap` on a trivial `map` operation. We''ll use Clojure''s `time` macro to compare
    execution times. The `time` macro wraps an expression, evaluates it normally,
    and prints out the time it took to evaluate:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能听起来是个好消息。在某些情况下，可能确实如此。但如果你在想“我将一直使用 `pmap`，我的程序会运行得更快”，你大多数时候都会失望。问题是 `pmap`
    必须进行大量的幕后工作来生成新线程。结果是，当计算特别耗时的时候，`pmap` 才比单线程的 `map` 函数更有效。我们可以通过一个微不足道的 `map`
    操作来比较 `map` 和 `pmap` 的相对速度。我们将使用 Clojure 的 `time` 宏来比较执行时间。`time` 宏包装一个表达式，正常评估它，并打印出评估所需的时间：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Incrementing 10 integers is not a resource-intensive task. With the ordinary
    `map` function, it takes less than a tenth of a microsecond. Performing the same
    operation with `pmap` takes almost 30 times longer! What took so long? Creating
    threads consumes resources. Obviously, `pmap` should only be used when it's clear
    that the additional overhead is worth it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 增加十个整数不是一个资源密集型任务。使用普通的 `map` 函数，它只需要不到十分之一微秒。使用 `pmap` 执行相同的操作需要几乎 30 倍的时间！为什么这么慢？创建线程消耗资源。显然，只有在额外开销值得的时候才应该使用
    `pmap`。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We need to use `doall` here; otherwise, we would just be timing the speed of
    the creation of an unrealized lazy sequence.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里需要使用 `doall`；否则，我们只是计时一个未实现的惰性序列的创建速度。
- en: 'Exercise 12.01: Testing Randomness'
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.01：测试随机性
- en: Back on your job at the data journalism website, one of the analysts is concerned
    that the random number generator used in your programs is not random enough. She
    wants you to test it by generating a very long sequence of random integers and
    then checking a few numbers to see whether they are equally represented. In doing
    this, you'll be able to see whether it's faster to use `map` or `pmap` thanks
    to Clojure's `time` function.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 回到你在数据新闻网站的工作岗位上，一位分析师担心你程序中使用的随机数生成器不够随机。她希望你通过生成一个非常长的随机整数序列并检查几个数字是否均匀分布来测试它。通过这样做，你将能够看到使用
    `map` 或 `pmap` 哪个更快，这要归功于 Clojure 的 `time` 函数。
- en: 'Open a `REPL`. This is a one-off test, so there''s no need to create a project:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个 `REPL`。这是一个一次性测试，所以不需要创建项目：
- en: 'Generate a very long sequence of integers between `0` and `1000`:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个介于 `0` 和 `1000` 之间的非常长的整数序列：
- en: '[PRE1]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we use `doall` to make sure that the lazy sequence returned by `repeatedly`
    is fully realized.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们使用 `doall` 来确保 `repeatedly` 返回的惰性序列被完全实现。
- en: 'Define a function that counts the number of occurrences of an integer in a
    list:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个函数，用于计算列表中整数的出现次数：
- en: '[PRE2]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Use `map` to count the number of occurrences of some integers in `random-ints`:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `map` 来计算 `random-ints` 中某些整数的出现次数：
- en: '[PRE3]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This seems to work, but it is fairly slow. To discover how slow it is, we can
    use Clojure''s `time` function to provide a quick benchmark. Don''t forget to
    wrap the output from `map` in `doall`. Otherwise, you''re just timing the creation
    of an unrealized lazy sequence:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这似乎有效，但速度相当慢。为了发现它有多慢，我们可以使用 Clojure 的 `time` 函数提供一个快速的基准测试。别忘了将 `map` 的输出包裹在
    `doall` 中。否则，你只是在计时一个未实现的惰性序列的创建：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Your time will be longer or shorter, of course.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当然，你的时间可能会更长或更短。
- en: 'Now try using `pmap` instead:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在尝试使用 `pmap`：
- en: '[PRE5]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That's a lot faster! This is good in case the analyst asks for an even bigger
    sample size.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这要快得多！这对于分析师要求更大的样本量时很有用。
- en: In this example, `pmap` came to the rescue and sped things up significantly.
    The beauty of `pmap` is that no extra coding is necessary. It's simple enough
    to write `pmap` instead of `map`. However, like many tools, the most important
    part is knowing when not to use it. This example was particularly well suited
    for parallelization because of the large size of the dataset. `pmap` should only
    be used in situations where you know that the calculation will generally be slow.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`pmap` 出现并显著加快了速度。`pmap` 的美妙之处在于不需要额外的编码。写 `pmap` 而不是 `map` 已经足够简单。然而，像许多工具一样，最重要的是知道何时不要使用它。这个例子特别适合并行化，因为数据集很大。`pmap`
    应该只在你知道计算通常会很慢的情况下使用。
- en: Futures
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 期货
- en: With `pmap`, Clojure takes care of all the thread management for you, which
    makes things easy. A lot of times, however, you need more control over your threads
    than what `pmap` provides. Clojure's **futures** do just this. They are a mechanism
    for spawning and waiting for new threads.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `pmap`，Clojure 会为你处理所有的线程管理，这使得事情变得简单。然而，很多时候，你需要比 `pmap` 提供的更多线程控制。Clojure
    的 **futures** 正是为此而设计的。它们是用于生成和等待新线程的机制。
- en: 'Consider a situation where two expensive calculations are needed to perform
    a third operation, such as adding the two results together. In a single-threaded
    context, we would just write this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一种情况，需要两个昂贵的计算来执行第三个操作，例如将两个结果相加。在单线程环境中，我们只需这样写：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Written this way, the call to `expensive-calc-1` needs to complete before `expensive-calc-2`
    can start. If the calculations could be run in parallel, we would cut the execution
    time nearly in half, in the best cases. Running the two threads in parallel creates
    some new problems, though. We need a way of coordinating the return values, especially
    since we don't know whether `expensive-calc-1` or `expensive-calc-2` will complete
    first. We need a way to wait for both before calling `+`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式编写，`expensive-calc-1` 的调用需要在 `expensive-calc-2` 开始之前完成。如果这两个计算可以并行运行，我们可以在最佳情况下将执行时间缩短近一半。然而，并行运行这两个线程也会带来一些新问题。我们需要一种协调返回值的方法，尤其是当我们不知道
    `expensive-calc-1` 或 `expensive-calc-2` 哪个会先完成时。我们需要一种在调用 `+` 之前等待两者的方法。
- en: Futures are designed for this type of situation. The `future` macro causes the
    code it contains to be run in a separate thread. It immediately returns a placeholder,
    which is a reference to the *future* result. When the code in the new thread has
    completed, the placeholder can be **dereferenced**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Futures 是为此类情况而设计的。`future` 宏会导致其包含的代码在单独的线程中运行。它立即返回一个占位符，这是一个对 *future* 结果的引用。当新线程中的代码完成时，占位符可以被
    **解引用**。
- en: 'In Clojure, dereferencing applies when a value is not immediately available
    and can only be accessed by taking an additional step. With a var or a let binding,
    the value is immediately available. There is no extra step to take. We just use
    it. With a future, as well as with reference types that we''ll see later in the
    chapter, we don''t know whether the value is available yet. Using the `deref`
    function with a future means that we are willing to wait for it to complete. `deref`
    is necessary because we need a way to indicate this special behavior. To make
    your code easier to read (and type), instead of writing `(deref my-future)`, you
    can just type `@my-future`. This is an example of a reader macro: Clojure immediately
    translates `@my-future` into `(deref my-future)` when it reads your code.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Clojure 中，当值不是立即可用，只能通过额外一步来访问时，才会应用解引用。使用 var 或 let 绑定时，值是立即可用的。没有额外的步骤需要执行。我们只需使用它。使用
    future 以及我们将在本章后面看到的引用类型时，我们不知道值是否已经可用。使用 future 的 `deref` 函数意味着我们愿意等待它完成。`deref`
    是必要的，因为我们需要一种方式来指示这种特殊行为。为了使你的代码更容易阅读（和输入），你不必写 `(deref my-future)`，只需输入 `@my-future`
    即可。这是一个读取宏的例子：Clojure 在读取你的代码时会立即将 `@my-future` 转换为 `(deref my-future)`。
- en: 'With this in mind, we can rewrite the preceding expression. First, though,
    we''ll define an artificially slow function using the Java `Thread/sleep` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我们可以重写前面的表达式。不过，首先，我们将使用Java的`Thread/sleep`方法定义一个人为地慢的函数：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `Thread/sleep` method is a convenient piece of Java interop that is useful
    for simulating long-running computations or input/output operations that take
    time. While it's good for experimenting, you rarely need it in production code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`Thread/sleep`方法是Java互操作的一个方便的工具，用于模拟长时间运行的计算或耗时的输入/输出操作。虽然它对实验很有用，但在生产代码中你很少需要它。'
- en: 'With these functions, the original expression evaluates them one after the
    other:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，原始表达式会依次评估它们：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'No matter how many times this function is run, `expensive-calc-1` will always
    return before `expensive-calc-2`. With futures, this will change:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这个函数运行多少次，`expensive-calc-1`总是会在`expensive-calc-2`之前返回。使用未来，这将会改变：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'First of all, you''ll probably notice that this version is slightly faster.
    Sometimes `expensive-calc-1` returns first, sometimes `expensive-calc-2` wins
    the race. It doesn''t matter which one is faster: the final addition only happens
    when both are complete. This is the work of the `deref` function, which blocks
    the evaluation until the computation started by the corresponding call to `future`
    has returned.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能注意到这个版本稍微快一些。有时`expensive-calc-1`先返回，有时`expensive-calc-2`赢得比赛。哪个更快不重要：最终加法只有在两者都完成时才会发生。这是`deref`函数的工作，它会阻塞评估直到由相应的`future`调用启动的计算返回。
- en: The `(deref c1)` or `(deref c2)` expressions can be replaced with `@c1` or `@c2`,
    thanks to the `@` reader macro.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`(deref c1)`或`(deref c2)`表达式可以用`@c1`或`@c2`替换，多亏了`@`读取宏。'
- en: 'Exercise 12.02: A Crowdsourced Spellchecker'
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.02：众包拼写检查器
- en: Have you ever typed a word into a search engine just to see whether you've spelled
    it correctly? In this exercise, we'll build a command-line tool that improves
    on this way of using the internet to verify spellings.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你有没有在搜索引擎中输入一个单词，只是为了看看你是否拼对了？在这个练习中，我们将构建一个命令行工具，它改进了这种使用互联网来验证拼写的方法。
- en: The goal is to be able to write out a command followed by several possible spellings
    for a word. The spelling tool will then query Wikipedia and return the word that
    received the most hits. We will use futures so that the different search queries
    can be run in parallel.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是能够写出一个命令，后面跟着一个单词的几个可能的拼写。拼写工具将查询维基百科，并返回得到最多点击的单词。我们将使用未来，以便不同的搜索查询可以并行运行。
- en: 'Use Leiningen to create a new project using the `app` template. You can call
    it whatever you want. We''ll use `packt-clj.crowdspell` in our examples:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Leiningen创建一个新的项目，使用`app`模板。你可以叫它任何你想要的。在我们的例子中，我们将使用`packt-clj.crowdspell`：
- en: '[PRE10]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Go to the new directory that Leiningen created and modify the dependencies
    in the `project.clj` file. We''ll need three libraries: `org.clojure/tools.cli`
    for accepting user input, `clj-http` for making HTTP requests, and `org.clojure/data.json`.'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往Leiningen创建的新目录，并修改`project.clj`文件中的依赖项。我们需要三个库：`org.clojure/tools.cli`用于接受用户输入，`clj-http`用于发起HTTP请求，以及`org.clojure/data.json`。
- en: 'The `:dependencies` map should look like this:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`:dependencies`映射应该看起来像这样：'
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `src/packt_clj/` directory, create a `crowdspell` directory. We''ll
    use this directory for any namespaces we need to create for the project. Create
    a file there called `fetch.clj` and insert the following namespace definition:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/packt_clj/`目录下，创建一个`crowdspell`目录。我们将使用这个目录来创建项目所需的任何命名空间。在那里创建一个名为`fetch.clj`的文件，并插入以下命名空间定义：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: All of the fetching and parsing of results will happen in this namespace. The
    `clj-http` library will help us to perform our web requests to the Wikipedia endpoint
    and `clojure.data.json` will help us to parse the JSON data that we get back.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有的获取和解析结果都将在这个命名空间中发生。`clj-http`库将帮助我们向维基百科端点发起网络请求，而`clojure.data.json`将帮助我们解析我们得到的JSON数据。
- en: 'While you''re there, create an empty function definition for `get-best-word`.
    This will be the key interface of the application: given a list of words, `get-best-word`
    will return the best one based on the data retrieved from Wikipedia. All we know
    at this point is that it takes a language code and a list of words as an argument:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你在那里时，为`get-best-word`创建一个空的函数定义。这将是应用程序的关键接口：给定一个单词列表，`get-best-word`将根据从维基百科检索到的数据返回最好的一个。目前我们所知道的是它需要一个语言代码和一个单词列表作为参数：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Because Wikipedia uses a separate URL for each language, such as [https://ja.wikipedia.org/](https://ja.wikipedia.org/)
    or https://en.wikipedia.org/, we can use the language code parameter to internationalize
    our app.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于维基百科为每种语言使用不同的URL，例如[https://ja.wikipedia.org/](https://ja.wikipedia.org/)或https://en.wikipedia.org/，我们可以使用语言代码参数来国际化我们的应用程序。
- en: The `packt-clj/crowdspell` namespace, defined in `src/packt_clj/crowdspell.clj`,
    will be the entry point into the application. There should already be a `-main`
    function there, created using the `lein new` command.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/packt_clj/crowdspell.clj`中定义的`packt-clj/crowdspell`命名空间将是应用程序的入口点。那里应该已经有一个由`lein
    new`命令创建的`-main`函数。
- en: Modify the `-main` function so that it calls `get-best-word`. This will also
    require updating the namespace declaration so that you'll have access to `clojure.tools.cli`
    and `packt-clj.crowdspell.fetch`.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 修改`-main`函数，使其调用`get-best-word`。这也需要更新命名空间声明，以便你可以访问`clojure.tools.cli`和`packt-clj.crowdspell.fetch`。
- en: 'The namespace declaration should now look like this:'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名空间声明现在应该看起来像这样：
- en: '[PRE14]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `-main` function should look like this:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-main`函数应该看起来像这样：'
- en: '[PRE15]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For now, we'll just hardcode English as the language code. At this point, the
    application would theoretically compile and run at the command line but would
    not do anything.
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，我们只是将英语作为语言代码硬编码。在这个阶段，应用程序理论上可以在命令行编译和运行，但不会做任何事情。
- en: 'Back in `src/packt_clj/crowdspell/fetch.clj`, write a skeleton for a `word-search`
    function. This function will search for a single word. The `get-best-word` function
    will coordinate several concurrent HTTP requests using futures. Each request will
    be run with `word-search`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/packt_clj/crowdspell/fetch.clj`中，为`word-search`函数编写一个骨架。这个函数将搜索单个单词。`get-best-word`函数将使用futures协调多个并发HTTP请求。每个请求都将运行`word-search`：
- en: '[PRE16]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There's a `language-code` parameter because we want our application to be multilingual.
    We'll add that as a command-line parameter later.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们希望应用程序支持多语言，因此有一个`language-code`参数。我们将在稍后将其作为命令行参数添加。
- en: 'We want to use a `try` block here since our request might fail for any number
    of reasons. We''ve already made a design decision: the function will return a
    map containing, among other things, a `:status` code.'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里使用`try`块，因为我们的请求可能会因为各种原因而失败。我们已经做出了设计决策：函数将返回一个包含，但不仅限于，`:status`代码的map。
- en: 'Now it''s time to write the HTTP request itself. The `clj-http.client` library
    makes this fairly painless. We just have to make sure that we use the proper Wikipedia-specific
    parameters: `srsearch` is our search term, and `srlimit` tells the API that we
    only want one item. Only one item is necessary because the metadata in the response
    includes a field indicating how many total items were found. Since we are only
    interested in counting them, this is all we need. You can try the request in the
    REPL first if you like:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是编写HTTP请求本身的时候了。`clj-http.client`库使得这个过程相对简单。我们只需确保使用正确的维基百科特定参数：`srsearch`是我们的搜索词，而`srlimit`告诉API我们只想得到一个项目。只需要一个项目，因为响应中的元数据包括一个字段，指示找到了多少个项目。由于我们只对计数感兴趣，这就足够了。如果你喜欢，可以先在REPL中尝试这个请求：
- en: '[PRE17]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If all goes well, a map containing HTTP response, including all the headers,
    should fill your REPL. You should find a key that says `:status 200`, which means
    that the request was successful. Any status besides `200` means that something
    is wrong:'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果一切顺利，一个包含HTTP响应（包括所有头信息）的map应该会填充你的REPL。你应该找到一个键，它说`:status 200`，这意味着请求是成功的。除了`200`之外的状态代码都意味着有问题：
- en: '![Figure 12.4: REPL output of a successful HTTP request'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.4：成功HTTP请求的REPL输出'
- en: '](img/B14502_12_04.jpg)'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_04.jpg)'
- en: 'Figure 12.4: REPL output of a successful HTTP request'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.4：成功HTTP请求的REPL输出
- en: 'Let''s add this request as a `let` binding inside the `try` block. The only
    change needed is to insert the two parameters: the word we''re searching for and
    the language. Start by making a `let` binding from the result of the HTTP request
    to the Wikipedia endpoint. We will need the entire request later:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`try`块内添加这个请求作为一个`let`绑定。唯一需要改变的是插入两个参数：我们要搜索的单词和语言。首先，从维基百科端点的HTTP请求结果创建一个`let`绑定。我们稍后需要整个请求：
- en: '[PRE18]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now we just need to interpret the result of the HTTP request. There are really
    two steps: first, convert the raw JSON response into a Clojure map, then extract
    the data we''re looking for. The Wikipedia API provides a `totalhits` field that
    we can use to decide which word is the most popular. We can combine these two
    steps into a brief code snippet:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要解释HTTP请求的结果。实际上有两个步骤：首先，将原始JSON响应转换为Clojure映射，然后提取我们所需的数据。Wikipedia API提供了一个`totalhits`字段，我们可以用它来决定哪个单词最受欢迎。我们可以将这两个步骤合并成一个简短的代码片段：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `json/read-str` does just that: it reads the body of the response and converts
    it into a map. The `:key-fn` option allows us to provide a function that will
    be called on all the keys. In nearly all cases, the `keyword` function is used
    here so that we can have the convenience of Clojure keywords.'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`json/read-str`正是这样做的：它读取响应体并将其转换为映射。`:key-fn`选项允许我们提供一个函数，该函数将在所有键上被调用。在几乎所有情况下，这里都使用`keyword`函数，这样我们就可以享受到Clojure关键字的便利。'
- en: All that's left is to grab the one piece of data that we need. The result map
    is a large, multiple-nested map, which is not a problem for `get-in`.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 剩下的就是抓取我们需要的唯一数据。结果映射是一个大型、多层嵌套的映射，这对于`get-in`来说不是问题。
- en: 'Once we have the number of hits, we wrap all the data we''ll need for later
    in a map: the status, the number of hits, and the word itself:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了出现次数，我们将所有我们稍后需要的所有数据都包装在一个映射中：状态、出现次数和单词本身：
- en: '[PRE20]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We know the word from the original argument supplied to the function. We also
    know that the status is `:ok`: if the query resulted in an error, we would be
    in the catch `block` instead.'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们知道这个单词是从函数提供的原始参数中得到的。我们还知道状态是`:ok`：如果查询导致错误，我们就会在`catch`块中。
- en: 'The final function looks like this:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最终的函数看起来像这样：
- en: '[PRE21]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If you test `word-search` in the REPL, you should see something like this:'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你测试REPL中的`word-search`，你应该看到类似这样的内容：
- en: '![Figure 12.5: The important data extracted from the HTTP request'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.5：从HTTP请求中提取的重要数据'
- en: '](img/B14502_12_05.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_05.jpg)'
- en: 'Figure 12.5: The important data extracted from the HTTP request'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.5：从HTTP请求中提取的重要数据
- en: 'Now we turn to `get-best-word`. Its job is to make parallel calls to `word-search`.
    Futures are exactly what we need for that. Since the words are supplied as a list,
    the first step will be to call `word-search` inside a future for each of the words.
    This is remarkably straightforward:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们转向`get-best-word`。它的任务是并行调用`word-search`。对于这个任务，futures正是我们所需要的。由于单词是以列表形式提供的，第一步将是为每个单词在future中调用`word-search`。这非常直接：
- en: '[PRE22]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The HTTP requests will run simultaneously and the responses become available
    as they complete. This expression will return a list of futures. We will need
    to dereference them before we can use them. Except for that difference, we can
    look at `results` as though it were a list of ordinary values. Clojure's `future`
    and `deref` function manage the asynchronicity for us.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: HTTP请求将同时运行，并且随着它们的完成，响应将变得可用。这个表达式将返回一个future列表。在我们能够使用它们之前，我们需要取消引用它们。除了这个区别之外，我们可以将`results`看作是一个普通值的列表。Clojure的`future`和`deref`函数为我们管理异步性。
- en: 'The final step here will be to select the word with the most hits. We''ll use
    `reduce` with a pattern we introduced in *Chapter 5*, *Many to One: Reducing*:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此处的最后一步将是选择出现次数最多的单词。我们将使用我们在*第五章*中引入的模式`reduce`：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Obviously, dereferencing `@result-future` here is the first very important step.
    But once the value is dereferenced, all the data is available, and we can forget
    all about its asynchronous past.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 显然，在这里取消引用`@result-future`是第一个非常重要的步骤。但是一旦值被取消引用，所有数据都可用，我们就可以忘记它的异步过去。
- en: 'The rest of the call to `reduce` follows the familiar pattern: we check whether
    the current item has a better score than `best-so-far`, and if so, it replaces
    `best-so-far`.'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`reduce`的其余调用遵循熟悉的模式：我们检查当前项是否有比`best-so-far`更好的分数，如果是，它就会替换`best-so-far`。'
- en: To make a very polished app, we would want to warn the user in case there were
    errors, but, for now, it will suffice to simply ignore the failed requests.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了制作一个非常精致的应用程序，我们希望在出现错误时提醒用户，但现在，简单地忽略失败的请求就足够了。
- en: 'Once we''ve found the best word, all that''s left is to extract the `:word`
    key from the best word. For that, we''ll use a threading macro, `->`, and `:word`.
    Altogether, that leaves us with this function:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们找到了最佳单词，剩下的就是从最佳单词中提取`:word`键。为此，我们将使用线程宏`->`和`:word`。总的来说，这给我们留下了这个函数：
- en: '[PRE24]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Test `get-best-word` in the REPL with some really bad spellings of "Clojure"
    alongside the correct one:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在REPL中测试`get-best-word`，使用一些“Clojure”拼写得非常糟糕的单词，以及正确的拼写：
- en: '[PRE25]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: It seems to work!
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看起来一切正常！
- en: To make this into a useful application, we still need to package this behavior
    into a command-line utility. The `-main` function back in `src/packt_clj/crowdspell.clj`
    is almost ready, except that the language code parameter is still just hardcoded
    as `en`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个功能成为一个有用的应用程序，我们仍然需要将这个行为打包成一个命令行工具。在`src/packt_clj/crowdspell.clj`中的`-main`函数几乎已经准备好了，只是语言代码参数仍然硬编码为`en`。
- en: 'The `clojure.tools.cli` library will make it easy to add the language code
    as an optional parameter at the command line. The goal is to be able to compile
    our code to an uberjar and then type this:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`clojure.tools.cli` 库将使您能够在命令行中轻松地将语言代码作为可选参数添加。目标是能够将我们的代码编译成一个uberjar，然后输入以下内容：'
- en: '[PRE26]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `clojure.tools.cli/parse-opts` function takes the `args` value from `-main`
    and a list of argument prefix descriptors. The best way to understand this is
    with an example, like our language code option:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`clojure.tools.cli/parse-opts`函数接受来自`-main`的`args`值和一个参数前缀描述符列表。理解这一点最好的方式是通过一个例子，比如我们的语言代码选项：'
- en: '[PRE27]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The nested vector is the configuration argument to `parse-opts`. `"-l"` and
    `"--language LANG"` define the short and long form of the command-line option.
    Remember that the long form of the option will be used, in keyword form, as the
    name of the argument in the nested `:options` map that `parse-opts` returns.
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 嵌套向量是`parse-opts`的配置参数。`"-l"`和`"--language LANG"`定义了命令行选项的简写和长写形式。请记住，选项的长写形式将以关键字形式用作`parse-opts`返回的嵌套`:options`映射中参数的名称。
- en: The next string is a documentation string that will be displayed if there is
    an error, for example, an unknown option prefix.
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 下一个字符串是一个文档字符串，如果出现错误（例如，未知选项前缀）时将显示出来。
- en: After these first three items, there can be additional keyword-tagged parameters.
    There are a lot of possibilities here that we won't explore. `:default` is enough
    for our purposes here. If the user doesn't supply a `--language` option (or the
    shorter `-l` option), they will get results from the English-language Wikipedia
    output.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这三个项目之后，可能会有额外的关键字标记参数。这里有很多可能性，我们不会一一探索。对于我们的目的来说，`:default`就足够了。如果用户没有提供`--language`选项（或较短的`-l`选项），他们将获得来自英语维基百科输出的结果。
- en: 'To test the configuration of the command-line options, there''s no need to
    actually use the command line. `parse-opts` can be run in the `REPL` with a list
    of strings masquerading as command-line arguments:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试命令行选项的配置，实际上并不需要使用命令行。`parse-opts`可以在`REPL`中运行，使用一个字符串列表伪装成命令行参数：
- en: '[PRE28]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is useful because it shows us the structure of the map that is returned.
    To finalize the `-main` function, we just need to know how to extract the language
    option and the arguments from the map:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这很有用，因为它显示了返回映射的结构。为了最终确定`-main`函数，我们只需要知道如何从映射中提取语言选项和参数：
- en: '[PRE29]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The call to `System/exit` guarantees that our program will exit immediately.
    Because we used `future`, the program otherwise would not exit until the threads
    created by `future` had terminated entirely.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对`System/exit`的调用确保我们的程序将立即退出。因为我们使用了`future`，否则程序将不会退出，直到由`future`创建的线程完全终止。
- en: And that should be all the code we need.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该就是我们需要的所有代码了。
- en: 'Before compiling, we can test our code in the `REPL` by simulating the command-line
    arguments in a list:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编译之前，我们可以在`REPL`中通过模拟命令行参数的列表来测试我们的代码：
- en: '[PRE30]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To compile, simply run `lein uberjar` in the root directory of the project.
    Now we can finally test the entire application:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要编译，只需在项目的根目录中运行`lein uberjar`。现在我们终于可以测试整个应用程序了：
- en: '[PRE31]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: All right, it works. But it's slow. Yes, the Java runtime takes a few seconds
    to get started and it's a problem for something that should be a fast, easy-to-use
    app. It's best to consider this version as a proof of concept. A ClojureScript
    version based on Node.js would have a much shorter startup time. Or this could
    be built as a web service. You'll learn about building an application server in
    *Chapter 14*, *HTTP with Ring*. For now, the fastest and easiest approach would
    be to use `fetch.clj` directly in the REPL, although this requirement might limit
    the number of potential customers.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，它工作得很好。但是速度很慢。是的，Java运行时需要几秒钟才能启动，这对于应该快速、易于使用的应用程序来说是个问题。最好将这个版本视为一个概念验证。基于Node.js的ClojureScript版本将具有更短的启动时间。或者这可以构建成一个网络服务。您将在第14章“HTTP与Ring”中学习如何构建应用程序服务器。现在，最快、最简单的方法是直接在REPL中使用`fetch.clj`，尽管这个要求可能会限制潜在客户数量。
- en: In this exercise, we learned how to write a simple multithreaded application
    using Clojure futures. Futures are particularly well suited for situations where
    discreet tasks can be handed off to separate threads. Even more importantly, `future`,
    with `deref`, provides a way to coordinate the data as it returns from the separate
    threads.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们学习了如何使用Clojure futures编写一个简单的多线程应用程序。Futures特别适合将离散任务分配给单独的线程的情况。更重要的是，`future`结合`deref`提供了一种协调从单独线程返回的数据的方法。
- en: Coordination
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协调
- en: 'Futures work well for cases like the `crowdspell` example. Work is assigned
    to a thread; the thread performs its task independently and returns a result to
    the initial thread. The coordination is in the gathering of the results: evaluation
    is blocked until all the futures have completed. Thanks to immutability, there
    is a guarantee that simultaneous threads won''t interfere with each other because
    nothing is shared.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Futures非常适合像`crowdspell`示例这样的情况。工作被分配给一个线程；线程独立执行其任务并返回结果给初始线程。协调发生在结果的收集：评估会阻塞，直到所有future都完成。由于不可变性，可以保证同时运行的线程不会相互干扰，因为没有共享的内容。
- en: This simple model is effective precisely because it is simple. Sometimes, however,
    more coordination is necessary, especially when communication between threads
    is required.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的模型之所以有效，正是因为它的简单。然而，有时需要更多的协调，尤其是在需要线程间通信时。
- en: 'With a future, we fork, perform a computation, and return the data:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 使用future，我们进行分支，执行计算，并返回数据：
- en: '![Figure 12.6: With a future, coordination occurs when the future is dereferenced'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.6：使用future，当future被取消引用时发生协调'
- en: '](img/B14502_12_06.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_06.jpg)'
- en: 'Figure 12.6: With a future, coordination occurs when the future is dereferenced'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6：使用future，当future被取消引用时发生协调
- en: 'Message sending is one way to communicate among threads. Now, we imagine three
    threads that send messages to one another:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 消息发送是线程之间通信的一种方式。现在，我们想象三个线程相互发送消息：
- en: '![Figure 12.7: Complex interactions between multiple threads'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.7：多个线程之间的复杂交互'
- en: '](img/B14502_12_07.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_07.jpg)'
- en: 'Figure 12.7: Complex interactions between multiple threads'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7：多个线程之间的复杂交互
- en: 'To implement a communication model like this in Clojure, you could also use
    the `core.async` library, which is a sophisticated tool for creating channels
    between threads. The `core.async` library is widely used but would require its
    own chapter to cover it correctly:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在Clojure中实现此类通信模型，您还可以使用`core.async`库，这是一个用于在线程之间创建通道的复杂工具。`core.async`库被广泛使用，但需要单独的章节来正确介绍它：
- en: '![Figure 12.8: Threads referring to and modifying shared data'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.8：线程引用和修改共享数据'
- en: '](img/B14502_12_08.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_08.jpg)'
- en: 'Figure 12.8: Threads referring to and modifying shared data'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8：线程引用和修改共享数据
- en: The fundamental challenge of concurrent programming stems from the fact that
    the timeline of a program is no longer linear. Threads in communication with each
    other do not know when they will receive new data or when the data they've sent
    will be processed on the receiving end. Unless the communication is carefully
    managed, accidents happen. If two threads try to update the same data simultaneously
    without coordination, the results become unpredictable. One update overwrites
    another. While a value is being updated, the original value is modified, and the
    update is suddenly obsolete. If more threads are involved, the interactions (and
    the possibilities for errors) are multiplied. In the `crowdspell` exercise, the
    futures coordinated the return value from the different threads. Instead of clobbering
    each other's data, the results were assembled into a coherent list that the rest
    of the program could use.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 并发编程的基本挑战源于程序的时间线不再是线性的。相互通信的线程不知道何时会收到新数据，也不知道他们发送的数据何时会在接收端被处理。除非通信得到精心管理，否则会发生意外。如果两个线程在没有协调的情况下同时尝试更新相同的数据，结果将变得不可预测。一个更新会覆盖另一个。当一个值正在更新时，原始值被修改，更新突然变得过时。如果涉及更多的线程，交互（以及错误的可能性）会成倍增加。在`crowdspell`练习中，futures协调了不同线程的返回值。而不是相互覆盖数据，结果被组装成一个连贯的列表，程序的其他部分可以使用。
- en: 'Clojure has several `reference types`: vars, atoms, agents, and refs. Before
    talking about each one separately, it might be good to think about what a *reference
    type* actually is. First of all, a reference type is not a data structure. In
    fact, you can use any of Clojure''s data structures with any of these reference
    types. Instead, a reference type sits between your code and your data and provides
    a particular way of referring to your data.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure有几种`引用类型`：vars、atoms、agents和refs。在分别讨论每一种之前，先思考一下什么是*引用类型*可能是个好主意。首先，引用类型不是数据结构。实际上，你可以用Clojure的任何数据结构配合这些引用类型中的任何一种。相反，引用类型位于你的代码和数据之间，并提供了一种特定的方式来引用你的数据。
- en: 'It might help to visualize this relationship. The reference type as an interface
    allows your code to apply changes to the data and retrieve the current state of
    the data. Remember, the values that the reference type points to are still the
    familiar Clojure data types: integers, strings, vectors, maps, and so on:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过可视化这种关系可能会有所帮助。引用类型作为一个接口，允许你的代码对数据进行更改并检索数据的当前状态。记住，引用类型指向的值仍然是熟悉的Clojure数据类型：整数、字符串、向量、映射等等：
- en: '![Figure 12.9: Reference type: a way of referring to and interacting with a
    piece of data'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.9：引用类型：一种引用和交互数据的方式'
- en: '](img/B14502_12_09.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_09.jpg)'
- en: 'Figure 12.9: Reference type: a way of referring to and interacting with a piece
    of data'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.9：引用类型：一种引用和交互数据的方式
- en: 'Most of the time, when coding in Clojure, we don''t think about the difference
    between the name of a thing and thing itself. Consider this simple `let` binding:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，在Clojure中编码时，我们不会考虑事物名称和事物本身之间的区别。考虑这个简单的`let`绑定：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: What is `some-numbers`? Usually, we just say, or think, "it's a vector." Of
    course, it's really a symbol that points at a vector. The fact that it's in a
    `let` binding means that `some-numbers` will only point at `[3 12 -1 55]` inside
    that particular `let` expression. In other words, `let` defines a particular kind
    of pointing.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`some-numbers`是什么？通常，我们只是说，或者想，“它是一个向量。”当然，它实际上是一个指向向量的符号。它在`let`绑定中的事实意味着`some-numbers`将只在该特定的`let`表达式中指向`[3
    12 -1 55]`。换句话说，`let`定义了一种特定的指向方式。'
- en: 'Now consider this `let` binding:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这个`let`绑定：
- en: '[PRE33]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This time, `some-atomic-numbers` is still just a symbol. It points at an atom
    (we''ll explain what that means in a second), and the atom points at the vector:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，`some-atomic-numbers`仍然只是一个符号。它指向一个原子（我们将在下一节解释这是什么意思），而原子指向向量：
- en: '![Figure 12.10: The binding points at the atom, and the atom points at the
    value'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.10：绑定点在原子上，原子指向值'
- en: '](img/B14502_12_10.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_10.jpg)'
- en: 'Figure 12.10: The binding points at the atom, and the atom points at the value'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10：原子上的绑定点，以及原子指向的值
- en: Immutability means that values don't change. An integer remains an integer,
    and a vector remains equal to itself. Immutability does not mean that a symbol
    always points at the same value, though. Clojure's reference types are a way to
    manage certain kinds of change while continuing to use immutable data.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性意味着值不会改变。一个整数仍然是整数，一个向量保持等于自身。不可变性并不意味着符号总是指向同一个值。Clojure的引用类型是管理某些类型变化的同时继续使用不可变数据的一种方式。
- en: 'One of the reference types is already very familiar to you by now: the var,
    which, among other roles, is how Clojure identifies functions. Up until now, we''ve
    treated the var as an immutable identity, and, for the most part, this is accurate.
    Generally, if you see `(def x 5)` in a program, that means that the value of `x`
    will not change.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经非常熟悉一种引用类型：变量，它在其他角色中是Clojure识别函数的方式。到目前为止，我们将变量视为不可变的身份，这在很大程度上是准确的。一般来说，如果你在程序中看到`(def
    x 5)`，这意味着`x`的值不会改变。
- en: 'However, at the REPL, you will quickly find that you can indeed redefine a
    var simply by calling `def` again:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在REPL中，你很快会发现你可以通过再次调用`def`来简单地重新定义一个变量：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'While this is fine when experimenting with the REPL, clobbering a var like
    this in a program would be extremely unusual. That said, the var reference type
    does provide the `alter-var-root` function, which is a more graceful way to update
    a var. It takes a function and updates the value:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在用REPL进行实验时这样做是可以的，但在程序中这样覆盖一个变量会非常不寻常。话虽如此，变量引用类型确实提供了`alter-var-root`函数，这是一种更优雅地更新变量的方式。它接受一个函数并更新其值：
- en: '[PRE35]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you ever actually need to use this function, it will probably be to change
    some feature of your work environment. The point here is not to encourage you
    to start modifying vars, but rather to show how even vars have semantics for changing
    their values. `Vars` happen to be a reference type that strongly discourages change
    but does not prohibit it completely.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实需要使用这个函数，可能是因为要改变你工作环境的一些功能。这里的目的是不是鼓励你开始修改变量，而是要展示即使是变量也有改变其值的语义。`Vars`碰巧是一种强烈反对改变但并不完全禁止改变的引用类型。
- en: 'The other reference types—atoms, agents, and refs—are designed to give you
    much finer control over how to manage change and they do this by controlling what
    they point at. In the preceding diagram, we showed a `let` binding, `some-atomic-numbers`,
    pointing at an atom containing a vector. Now we can complete the picture by showing
    how the atom might evolve as different functions are called on it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其他引用类型——原子、代理和引用——被设计成让你能够更精细地控制如何管理变化，它们通过控制它们指向的内容来实现这一点。在前面的图中，我们展示了`let`绑定`some-atomic-numbers`指向一个包含向量的原子。现在我们可以通过展示原子如何随着对它的不同函数调用而演变来完善这个图景：
- en: '![Figure 12.11: The atom points at different values over time'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.11：原子随时间指向不同的值](img/B14502_12_11.jpg)'
- en: '](img/B14502_12_11.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14502_12_11.jpg](img/B14502_12_11.jpg)'
- en: 'Figure 12.11: The atom points at different values over time'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11：原子随时间指向不同的值
- en: In this picture, the data (the vectors) is still immutable. The atom allows
    us to define some kind of identity that might have different values at different
    times. As we'll see, this turns out to be particularly useful in multithreaded
    programs, where one or more threads need to have access to stable identities in
    another thread.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在这张图片中，数据（向量）仍然是不可变的。原子允许我们定义某种身份，这种身份在不同的时间可能有不同的值。正如我们将看到的，这在多线程程序中特别有用，其中一个或多个线程需要访问另一个线程中的稳定身份。
- en: So, what are atoms, refs, and agents? Let's take a quick look at each of these
    reference types.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，原子、引用和代理是什么？让我们快速看一下这些引用类型中的每一个。
- en: Atoms
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原子
- en: Atoms are the simplest and most commonly used reference type. They are also
    the only reference type that is currently available in ClojureScript, mostly due
    to the fact that the JavaScript runtime is single-threaded.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 原子是最简单且最常用的引用类型。它们也是目前在ClojureScript中唯一可用的引用类型，这主要是因为JavaScript运行时是单线程的。
- en: 'The life-cycle of an atom starts with an initial definition of the data with
    the `atom` function:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 原子的生命周期从使用`atom`函数对数据进行初始定义开始：
- en: '[PRE36]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Just with like `future`, the underlying data can be accessed with `deref` (or
    the `@` reader macro):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 就像`future`一样，可以使用`deref`（或`@`读取宏）访问底层数据：
- en: '[PRE37]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Changing the data is done with `swap!`, which updates the atom by applying
    the function you supply to the current value that the atom points to:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`swap!`来更改数据，它通过应用你提供的函数来更新原子指向的当前值：
- en: '[PRE38]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `swap!` function doesn't assign a value to the atom. Instead, it applies
    a function. This way, if the value of the atom has changed since the last time
    we dereferenced it, the function will simply be applied to the new value, whatever
    it is.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`swap!`函数不会将值分配给原子。相反，它应用一个函数。这样，如果自上次我们解引用原子以来，原子的值已更改，则函数将简单地应用于新的值，无论它是什么。'
- en: 'Let''s see this in action. Here is the code we are going to execute in the
    REPL, once again using `Thread/sleep` to simulate some long-running task:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个动作。以下是我们在REPL中将要执行的代码，再次使用`Thread/sleep`来模拟一些长时间运行的任务：
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'What''s going on here? The first future waits half a second before calling
    `swap!`. The second future executes right away, multiplying the current value
    of the atom, `6`, by `1000`. Now try dereferencing `integer-atom` again:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么？第一个future在调用`swap!`之前等待半秒钟。第二个future立即执行，将原子的当前值`6`乘以`1000`。现在再次尝试解引用`integer-atom`：
- en: '[PRE40]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If we change the timing by modifying the durations of the `Thread/sleep` calls,
    the results change too:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过修改`Thread/sleep`调用的持续时间来改变时间，结果也会改变：
- en: '[PRE41]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: When calling `swap!`, you can't be sure ahead of time what the value of the
    atom will be. But you know that your function will be called on whatever the value
    happens to be at that point in time.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`swap!`时，你无法提前确定原子的值。但你知道你的函数将在那个时间点被调用，无论值是什么。
- en: Note
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: There is also a more rarely used `compare-and-set!` function that provides finer
    grained control. It takes an additional value, usually the current value of the
    atom, and will only modify the atom if it still matches that. In other words,
    if another thread has already done something to your atom, `compare-and-set!`
    will leave it alone.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个较少使用的`compare-and-set!`函数，它提供了更细粒度的控制。它接受一个额外的值，通常是原子的当前值，并且只有在它仍然匹配时才会修改原子。换句话说，如果另一个线程已经对你的原子做了某些操作，`compare-and-set!`将保持不变。
- en: 'Concept: Retries'
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概念：重试
- en: Changes to an atom are not instantaneous. Remember, we're sending a function
    to the atom. Depending on the work being done, some functions may take more time
    to complete. In a busy environment, it might mean that several threads try to
    make changes to an atom at the same time.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 原子的更改不是瞬时的。记住，我们向原子发送了一个函数。根据正在执行的工作，某些函数可能需要更多时间来完成。在繁忙的环境中，这可能意味着几个线程同时尝试更改原子。
- en: 'The following diagram shows a naïve implementation of an atom being modified
    by two threads, `Thread A` and `Thread B`. Even though they are just multiplying
    the value of the atom by 3 or by 4, let''s imagine that this operation takes a
    few milliseconds:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了两个线程`Thread A`和`Thread B`对一个原子简单实现的修改。尽管它们只是将原子的值乘以3或4，但让我们想象这个操作需要几毫秒：
- en: '![Figure 12.12: Overlapping updates to a naive implementation of a Clojure
    atom'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.12：对Clojure原子简单实现的重叠更新'
- en: '](img/B14502_12_12.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_12.jpg)'
- en: 'Figure 12.12: Overlapping updates to a naive implementation of a Clojure atom'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12：对Clojure原子简单实现的重叠更新
- en: The initial value of the atom is 5\. Then `Thread A` intervenes to multiply
    by 3\. As it is starting to perform its operation, `Thread B` starts as well.
    The input to the function of `Thread B`'s is still `5`. The function of `Thread
    A` completes, and the value of the atom is set to `15`. Then Thread B's function
    completes its calculation without having seen the new value of the atom. This
    result is based on a "stale" version of the initial value, but it overwrites the
    result of the first calculation. In the end, it's as if Thread A's update had
    never happened.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 原子的初始值为5。然后`Thread A`介入，将其乘以3。当它开始执行其操作时，`Thread B`也开始。`Thread B`的函数输入仍然是`5`。`Thread
    A`的函数完成，原子的值设置为`15`。然后`Thread B`的函数完成其计算，而没有看到原子的新值。这个结果是基于“过时”的初始版本，但它覆盖了第一次计算的结果。最终，就像`Thread
    A`的更新从未发生一样。
- en: 'Clojure does not want this to happen to you! Here''s what would take place
    with a real Clojure atom:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure不希望这种情况发生在你身上！以下是一个真实Clojure原子的行为：
- en: '![Figure 12.13: A real Clojure atom retries when a conflict occurs'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.13：当发生冲突时，真实的Clojure原子会重试'
- en: '](img/B14502_12_13.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14502_12_13.jpg)'
- en: 'Figure 12.13: A real Clojure atom retries when a conflict occurs'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13：当发生冲突时，真实的Clojure原子会重试
- en: This time, when the atom tries to apply the update from `Thread B`, it detects
    that the underlying value has changed and reapplies the function with the new
    value.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当原子尝试应用来自`Thread B`的更新时，它检测到基础值已更改，并重新应用函数以使用新值。
- en: 'We can observe this in the REPL, using one slow-acting (long-sleeping) function
    and a quick function in two separate threads:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在REPL（读取-评估-打印-循环）中观察到这一点，使用一个动作缓慢（长时间休眠）的函数和一个快速函数在两个不同的线程中：
- en: '[PRE42]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In this scenario, we can consider that both calls to `swap!` execute at approximately
    the same time, when the value of `integer-atom` is still 5\. By dereferencing
    `integer-atom` at the end of the `do` block, we can see that the atom hasn't been
    updated yet. Yet, a couple of seconds later, the results indicate that both functions
    were applied, and in the correct order.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们可以认为对`swap!`的两次调用几乎同时执行，当时`integer-atom`的值仍然是5。通过在`do`块结束时取消引用`integer-atom`，我们可以看到原子尚未被更新。然而，几秒钟后，结果显示两个函数都已应用，并且顺序正确。
- en: Refs and Software Transactional Memory
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考和软件事务内存
- en: Refs are Clojure's most sophisticated reference type. They are why the Clojure
    language, when it was first introduced, became known for its advanced concurrency
    management and, more specifically, for STM. STM is an abstraction that guarantees
    that changes can be made to multiple *refs* in a safe, coordinated manner.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 参考是Clojure最复杂的引用类型。正是由于这些参考，Clojure语言在首次推出时因其在并发管理方面的先进性而闻名，特别是STM（软件事务内存）。STM是一种抽象，它保证了可以以安全、协调的方式对多个*refs*进行更改。
- en: 'Behind STM, there is a fundamental concept: the transaction. If you have worked
    with database transactions, you are already familiar with the basic idea. A database
    transaction might consist of several related operations. If, during the transaction,
    any individual operation fails, the entire transaction is "rolled back" to the
    initial state, as if nothing had happened. Transactions are a way of avoiding
    invalid states where only part of an action is performed.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在STM（扫描隧道显微镜）背后，有一个基本概念：事务。如果你已经与数据库事务工作过，你对基本想法已经很熟悉了。一个数据库事务可能由几个相关操作组成。如果在事务过程中，任何单个操作失败，整个事务将“回滚”到初始状态，就像什么都没发生一样。事务是一种避免只执行部分动作的无效状态的方法。
- en: Note
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *Chapter 13*, *Database Interaction and the Application Layer*, we will take
    a closer look at database transactions.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13章“数据库交互和应用层”中，我们将更深入地探讨数据库事务。
- en: 'The classic example for explaining database transactions also applies here:
    imagine a bank transaction where money moves from one account to another. To do
    this, at least two actions need to occur: an amount of money is removed from one
    account and added to another. If for some reason one of those operations fails,
    we don''t want the other to succeed. If the second account was deleted after the
    funds are debited from the first account, those funds should return to the original
    account; otherwise, they would vanish into thin air. In a database transaction,
    if the second step is not completed, the first step is canceled as well. This
    way, the system returns automatically to a known, correct state.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 解释数据库事务的经典例子也适用于此处：想象一个银行交易，其中资金从一个账户转移到另一个账户。为此，至少需要发生两个动作：从第一个账户中扣除一定金额，并将其添加到另一个账户。如果由于某种原因其中一个操作失败，我们不希望另一个操作成功。如果在第一个账户的资金扣除后第二个账户被删除，那么这些资金应该返回到原始账户；否则，它们将消失得无影无踪。在数据库事务中，如果第二步没有完成，第一步也会被取消。这样，系统会自动返回到一个已知、正确的状态。
- en: 'Clojure''s software transactional memory is conceptually similar to database
    transactions but works with data inside your program. A transaction in Clojure
    is managed by the `dosync` macro, which creates a space in which actions on refs
    will be coordinated. Imagine that the preceding banking scenario was implemented
    using Clojure reference types instead of a database. If you are drawing from one
    bank account ref and depositing to another, then both operations will succeed
    or the entire `dosync` block will be retried. Like database transactions, the
    purpose of refs is to make sure that your system remains in a coherent state.
    This is one of the first key differences between refs and atoms: unlike atoms,
    refs can provide coordination. When two atoms are updated, there is no such guarantee.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Clojure的软件事务内存在概念上与数据库事务相似，但它是与程序内部的数据一起工作的。Clojure中的事务由`dosync`宏管理，它创建了一个空间，在这个空间中，对refs的操作将被协调。想象一下，前面提到的银行场景是使用Clojure引用类型而不是数据库来实现的。如果你从一个银行账户引用中提取资金并存入另一个账户，那么这两个操作都将成功，或者整个`dosync`块将重试。像数据库事务一样，refs的目的确保你的系统保持一致状态。这是refs和atoms之间第一个主要区别之一：与atoms不同，refs可以提供协调。当两个atoms被更新时，没有这样的保证。
- en: 'Refs actually offer even more fine-grained control over how they are modified.
    There are several functions that can update a ref, each with different semantics.
    The two most common are `alter` and `commute`. `alter` is the most restrictive:
    if the underlying value has changed outside the `dosync` block, then the entire
    transaction will be retried. The `commute` function can be used when this kind
    of guarantee is not necessary. When adding or subtracting from a total, for example,
    the order of operations does not affect the result, so these operations can accept
    changes to the underlying value without a retry. And when accessing the data,
    the `ensure` function can be used instead of `deref`. In this case, if a ref that
    is being read from has changed, a retry will be triggered.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 引用实际上提供了更细粒度的控制，以修改它们。有几个函数可以更新引用，每个函数都有不同的语义。最常见的是 `alter` 和 `commute`。`alter`
    是最限制性的：如果基础值在 `dosync` 块外部已更改，则整个事务将重试。当不需要此类保证时，可以使用 `commute` 函数。例如，在添加或从总数中减去时，操作顺序不影响结果，因此这些操作可以接受基础值的更改而不需要重试。并且当访问数据时，可以使用
    `ensure` 函数代替 `deref`。在这种情况下，如果正在读取的引用已更改，将触发重试。
- en: 'Exercise 12.03: Stock Trading'
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 12.03：股票交易
- en: In this exercise, we will observe refs in the REPL to get a better sense of
    their behavior.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将观察 REPL 中的引用以更好地了解其行为。
- en: 'Your current project is a prototype for a stock trading application. You need
    to write a function that will simulate a client buying some numbers of stocks
    at a given price. For the purchase to succeed, four things must happen:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您当前的项目是一个股票交易应用的原型。您需要编写一个函数来模拟客户以给定价格购买一定数量的股票。为了使购买成功，必须发生以下四件事：
- en: The client account is debited for the amount of the transaction.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户账户会因交易金额而被借记。
- en: The broker account is credited for the same amount.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经纪人账户会因相同金额而被贷记。
- en: The broker stock account (for that particular stock) is debited, that is, there
    are now *n* fewer stocks in that account.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经纪人的股票账户（针对该特定股票）被借记，也就是说，该账户现在有 *n* 少量股票。
- en: 'The client stock account (for that particular stock) is credited: there are
    now *n* more stocks.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户的股票账户（针对该特定股票）被贷记：现在有 *n* 更多股票。
- en: However, if the price of the stock changes while this is happening, the entire
    purchase must be invalidated and retried.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果在发生此操作期间股票价格发生变化，整个购买必须被无效化并重试。
- en: 'Also, since this is a simulation, we will use `Thread/sleep` to slow the functions
    down:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于这是一个模拟，我们将使用 `Thread/sleep` 来减慢函数的执行速度：
- en: 'In the REPL, set up some refs for the five different values we''ll need. The
    first three will have integer values, representing account balances in whatever
    currency is being used:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 REPL 中，为我们将需要的五个不同值设置一些引用。前三个将具有整数值，代表使用任何货币的账户余额：
- en: '[PRE43]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Because the client and the broker would probably own stocks for various firms,
    we''ll use maps for that:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于客户和经纪人可能会为不同的公司拥有股票，我们将使用映射来处理：
- en: '[PRE44]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The client starts off with zero `Acme Corp` stocks and a currency balance of
    `2100` in her account. The broker has `50` stocks and a balance of `10000`.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 客户开始时拥有零 `Acme Corp` 股票和账户中的 `2100` 货币余额。经纪人拥有 `50` 股票和 `10000` 的余额。
- en: 'Write a function that describes a complete transaction:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个描述完整交易的函数：
- en: '[PRE45]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'All our code here is wrapped in a `dosync` macro. Beyond that, the code is
    quite simple. Even in a `dosync` environment, it is necessary to dereference other
    refs when accessing their value, which is why we write `@acme-corp-share-price`.
    The syntax for updating the `client-stocks` and `broker-stocks` maps might look
    a little bit strange. The second argument to `alter` is always a function, and
    in this case it''s the `update` function we''ve already used for updating maps.
    The remaining arguments to `alter` will be simply passed on to `update`, after
    the initial argument, which will be the map contained in the ref. All told, the
    final call to `update` will be as follows:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里的所有代码都包含在 `dosync` 宏中。除此之外，代码相当简单。即使在 `dosync` 环境中，在访问其值时也需要解引用其他引用，这就是为什么我们写
    `@acme-corp-share-price`。更新 `client-stocks` 和 `broker-stocks` 映射的语法可能看起来有点奇怪。`alter`
    函数的第二个参数始终是一个函数，在这种情况下，它是我们之前用于更新映射的 `update` 函数。`alter` 函数的其他参数将简单地传递给 `update`，在初始参数之后，该参数将是包含在引用中的映射。总的来说，最终的
    `update` 调用将如下所示：
- en: '[PRE46]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Because `update` behaves in the same way as `alter` and passes any additional
    arguments on to the provided function, our calls to `alter` could be rewritten
    like this:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因为`update`的行为与`alter`相同，并将任何额外的参数传递给提供的函数，所以我们可以将我们对`alter`的调用重写如下：
- en: '[PRE47]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'And likewise, the previous lines could use the same syntax:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，前面的行也可以使用相同的语法：
- en: '[PRE48]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: These forms are more concise and might be easier to read for experienced Clojure
    programmers. The forms using anonymous functions have the advantage of explicitly
    reminding us that we are providing functions as well as clearly laying out the
    order of the arguments.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些形式更简洁，可能对经验丰富的Clojure程序员来说更容易阅读。使用匿名函数的形式具有明确提醒我们我们正在提供函数的优点，并且清楚地展示了参数的顺序。
- en: 'Let''s try our new function:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试我们的新函数：
- en: '[PRE49]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `dosync` block returns the last value, which, in this case, is the in-transaction
    value of `broker-account`. That might be useful sometimes, but the data we''re
    really interested in is in the refs:'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`dosync`块返回最后一个值，在这种情况下，是`broker-account`在交易中的值。这有时可能很有用，但我们真正感兴趣的数据在refs中：'
- en: '[PRE50]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Here, we see that the balances of the two accounts have been correctly updated
    and that one stock has moved from `broker-stocks` to `client-stocks`.
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到两个账户的余额已经正确更新，并且一股股票已经从`broker-stocks`移动到`client-stocks`。
- en: 'This means that our best-case scenario works: none of the refs are changed
    outside of the current thread and the transactions are instantaneous. In these
    conditions, atoms would work just as well. Now it''s time to simulate a more demanding
    environment for the purchase!'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们的最佳情况场景是有效的：没有refs在当前线程之外被更改，并且交易是瞬时的。在这些条件下，原子会表现得一样好。现在是我们模拟一个更具挑战性的购买环境的时候了！
- en: 'Modify `buy-acme-corp-shares` to make the transaction slower and print some
    information:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`buy-acme-corp-shares`以使交易变慢并打印一些信息：
- en: '[PRE51]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: With `Thread/sleep`, the transaction will now last one second.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`Thread/sleep`，交易现在将持续一秒钟。
- en: 'Reset all the accounts to their initial values. To make this easier, let''s
    write a quick reset function using the `ref-set` function:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有账户重置为其初始值。为了使这更容易，让我们使用`ref-set`函数编写一个快速重置函数：
- en: '[PRE52]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: All the accounts and the stock price should now be back at their initial values.
    This will make it easier to observe the behavior of the function.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有账户和股价现在都应该回到它们的初始值。这将使观察函数的行为更容易。
- en: 'Use two separate threads to change the client''s account during the transaction.
    To do this, we''ll use `future` and set a shorter wait time to the thread by changing
    `client-account`:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用两个独立的线程在交易期间更改客户的账户。为此，我们将使用`future`并缩短线程的等待时间，通过更改`client-account`：
- en: '[PRE53]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Notice that the `println` message appears twice. What happened? Let''s look
    at the values:'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意到`println`消息出现了两次。发生了什么？让我们看看这些值：
- en: '[PRE54]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Both transactions were correctly recorded: +500 and -22\. Here''s what happened:
    first, `buy-acme-corp-shares` tried to complete the transaction but when it was
    time to write the new account balance to `client-account`, the underlying value
    had changed due to the deposit from the other thread. Without this, `buy-acme-corp-shares`
    would have overwritten the account balance, ignoring the recent deposit. The client
    would not have been pleased.'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 两次交易都被正确记录：+500和-22。发生了什么：首先，`buy-acme-corp-shares`试图完成交易，但在将新的账户余额写入`client-account`的时候，由于另一个线程的存款，基础值已经改变。如果没有这个，`buy-acme-corp-shares`就会覆盖账户余额，忽略最近的存款。客户不会高兴。
- en: 'Simulate a busy broker account. The broker account is probably much busier
    than the client''s account. Let''s add more transactions:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模拟一个繁忙的经纪人账户。经纪人账户可能比客户的账户要繁忙得多。让我们添加更多交易：
- en: '[PRE55]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Dereference the atoms to see their final values:'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 解引用原子以查看它们的最终值：
- en: '[PRE56]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'More changes to the refs cause more restarts, which we can see because the
    `Let''s buy 1 stock(s) at 22 per stock` message is printed three times. Each modification
    of an account causes the entire transaction to be retried. This is what atoms
    cannot do: with refs inside a `dosync` block, a change to any of the refs causes
    the entire block to restart.'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对refs的更多更改会导致更多的重启，这一点我们可以从“让我们以每股22美元的价格购买1股股票”的消息打印了三次中看出。每次对账户的修改都会导致整个交易被重试。这正是原子无法做到的：在`dosync`块内部，对任何refs的更改都会导致整个块重启。
- en: This exercise shows the basics of using refs to simplify the sharing of data
    across threads. Obviously, real-life uses would generally be much more complex,
    but even at this scale we can see some of the difficulties posed by concurrency
    and how Clojure provides tools for dealing with it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了使用refs简化跨线程数据共享的基本方法。显然，现实生活中的应用通常会更加复杂，但即使在这个规模上，我们也能看到并发带来的困难以及Clojure如何提供处理这些困难的工具。
- en: 'There are a few things that we can observe. Like with atoms, the retry strategy
    used by refs prevents near-simultaneous operations from interfering with one another.
    But refs go further by making sure that even if one ref causes a retry, all the
    updates in the transaction will be retried. This guarantees data coherence. It
    also means that we give up some control of when changes to refs will be made.
    As programmers, we are used to thinking in a very linear fashion: "do this, then
    do that." Multithreaded applications break this way of thinking. Clojure''s reference
    types, and refs in particular, can help us write better code, especially if we
    learn to think less in terms of the strict order of operations and more in terms
    of the correctness and coherence of the operations.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以观察到的有几件事情。与原子一样，refs使用的重试策略防止了几乎同时发生的操作相互干扰。但refs更进一步，确保即使一个refs导致重试，事务中的所有更新都将重试。这保证了数据一致性。这也意味着我们放弃了某些对refs更改时间的控制。作为程序员，我们习惯于非常线性地思考：“这样做，然后那样做。”多线程应用程序打破了这种思维方式。Clojure的引用类型，尤其是refs，可以帮助我们编写更好的代码，特别是如果我们学会更多地从操作的正确性和一致性而不是严格的操作顺序来思考。
- en: More Cohesion with refs
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与引用更多的凝聚力
- en: 'In the previous example, STM helped us to make sure that the updates were coherent:
    the buyer had less money in her account, but more stocks; the seller had more
    money, but fewer stocks. If any one of those four changes had failed, the system
    would have returned to the previous valid state. Either way, everyone ends up
    with the correct balances on their accounts. There is, however, one possibility
    we didn''t consider. What if the price of the stock changes during the transaction?
    Let''s take a look:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，STM帮助我们确保更新是一致的：买家账户中的钱少了，但股票多了；卖家钱多了，但股票少了。如果这四个变化中的任何一个失败了，系统就会回到之前的有效状态。无论如何，每个人最终都会在他们的账户上得到正确的余额。然而，我们还没有考虑到一种可能性。如果在交易期间股票价格发生变化怎么办？让我们看看：
- en: '[PRE57]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The balance on the client's account indicates that the purchase price was 22\.
    The sequence of events suggests that the client got a good deal. While `buy-acme-corp-shares`
    was waiting for 1,000 milliseconds, in the second future, the stock price was
    changed to 32\. When the purchase was finally complete, the price was no longer
    22 but 32\. Why didn't the refs protect us from this?
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 客户账户上的余额表明购买价格为22。事件序列表明客户得到了一笔好交易。当`buy-acme-corp-shares`等待1,000毫秒时，在第二个未来，股票价格变更为32。当购买最终完成时，价格不再是22而是32。为什么引用没有保护我们免受这种情况的影响？
- en: 'The problem here is that the `buy-acme-corp-shares` function consults the value
    of the `acme-corp-share-price` atom but does not do anything with it. As a result,
    `dosync` does not track the changes made to that ref. In the next exercise, we''ll
    explore two different solutions: the `ensure` function and a clever way to use
    `alter`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`buy-acme-corp-shares`函数查询了`acme-corp-share-price`原子的值，但没有对它做任何事情。因此，`dosync`没有跟踪对该引用所做的更改。在下一个练习中，我们将探索两种不同的解决方案：`ensure`函数和巧妙地使用`alter`。
- en: 'Exercise 12.04: Keeping up with the Stock Price'
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.04：跟上股票价格
- en: The initial prototype for the stock purchase function seems to be working but
    the team has realized that it does not react correctly to variations in the stock
    price that occur while the transaction is completing. You've been asked to suggest
    some solutions.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 股票购买功能的初始原型似乎正在正常工作，但团队意识到它无法正确响应在交易完成期间发生的股票价格变动。你被要求提出一些解决方案。
- en: In your REPL, use the same environment as in the previous exercise. If necessary,
    recreate the same five refs and make sure that the `reset-accounts` function is
    defined.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的REPL中，使用与上一个练习相同的环境。如果需要，重新创建相同的五个refs，并确保`reset-accounts`函数已定义。
- en: 'In `buy-acme-corp-shares`, use `ensure` to dereference `acme-corps-stock-price`:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`buy-acme-corp-shares`中使用`ensure`来取消引用`acme-corps-stock-price`：
- en: '[PRE58]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Run the same transaction as before. We''ll add an extra `println` statement
    to see when the share price updates occur:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行与之前相同的交易。我们将添加一个额外的`println`语句来查看股票价格更新发生的时间：
- en: '[PRE59]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'There are two noteworthy things in this output: `Raising share price…` was
    printed 3 times and the client account balance is still only down by 22\. What
    happened?'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个输出中，有两点值得注意：`Raising share price…` 被打印了 3 次，而客户账户余额仍然只减少了 22。发生了什么？
- en: As soon as `ensure` was called in `buy-acme-corp-shares`, the value of `acme-corp-share-price`
    was frozen until the `dosync` block had completed. The second `dosync` macro then
    kept retrying until the first had completed. When `buy-acme-corp-shares` had terminated,
    `acme-corp-share-price` could finally be raised.
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当在 `buy-acme-corp-shares` 中调用 `ensure` 时，`acme-corp-share-price` 的值被冻结，直到 `dosync`
    块完成。第二个 `dosync` 宏会一直重试，直到第一个完成。当 `buy-acme-corp-shares` 终止后，`acme-corp-share-price`
    最终可以提升。
- en: At the very instant that `buy-acme-corp-shares` purchased the shares, the price
    was still 22\. Data coherence was thus maintained. There is, however, a problem.
    In the real world, a single buyer cannot force the rest of the stock market to
    wait for a purchase to go through. This solution is correct in a way, but in this
    scenario it would not work.
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `buy-acme-corp-shares` 购买股票的瞬间，价格仍然是 22。因此，数据一致性得到了保持。然而，存在一个问题。在现实世界中，单个买家无法迫使整个股市等待一笔交易完成。这种解决方案在某种程度上是正确的，但在这个场景中它不会起作用。
- en: 'Use `alter` to trigger a retry. This time, we''ll go back to `deref` for accessing
    the current share price. We''ll also call `alter` on `acme-corp-share-price` to
    trigger a retry if that ref has changed. You might think "we can''t change the
    share price!" You''re right, of course, but our call to `alter` won''t actually
    do anything, since we will only provide the `identity` function as an argument.
    We call `alter`, but just as a way to say "stay the way you are":'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `alter` 触发重试。这次，我们将回到 `deref` 来访问当前股价。我们还会在 `acme-corp-share-price` 上调用 `alter`，如果该引用已更改，则触发重试。你可能认为“我们无法更改股价！”当然，你是对的，但我们的
    `alter` 调用实际上不会做任何事情，因为我们只会提供一个 `identity` 函数作为参数。我们调用 `alter`，但仅仅是为了说“保持原样”：
- en: '[PRE60]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Let''s see what happens:'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看会发生什么：
- en: '[PRE61]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'This time, `Let''s buy 1 stock(s)…` is printed twice, with two different prices.
    `Raising share price…` is printed only once. The share price is changed during
    the first call to `buy-acme-corp-shares`. Because of the change, a retry is triggered,
    now with the correct share price. The purchase finally completes, with the correct
    price:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次，`Let's buy 1 stock(s)…` 被打印了两次，价格不同。`Raising share price…` 只打印了一次。在第一次调用
    `buy-acme-corp-shares` 时，股价发生了变化。由于变化，触发了重试，现在有了正确的股价。购买最终以正确的价格完成：
- en: '[PRE62]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This exercise demonstrates the power and the subtlety of Clojure's STM. Depending
    on the problem you need to solve and on the environment you're working in, you
    will need retries to happen in slightly different circumstances. In this example,
    it was obvious that we could not ask the stock market to wait even 1 second for
    our transaction to complete. Refs give you the ability to precisely define the
    retry behavior that you need. (In addition to `alter` and `ref-set`, there is
    `commute`, which provides yet another set of semantics for updating refs when
    less control is needed.) And of course, this degree of control also requires careful
    thought about the relationships between refs.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了 Clojure 的 STM 的强大功能和微妙之处。根据你需要解决的问题和你工作的环境，你可能需要在不同的环境下进行重试。在这个例子中，很明显我们无法要求股市等待甚至
    1 秒钟来完成我们的交易。引用（Refs）让你能够精确地定义所需的重试行为。（除了 `alter` 和 `ref-set`，还有 `commute`，它提供了一套更新引用的语义，当需要较少的控制时使用。）当然，这种程度上的控制也需要仔细思考引用之间的关系。
- en: Agents
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理
- en: The primary difference between agents and the other reference types is that,
    while updates to atoms and refs are `synchronous`, updates to agents are `asynchronous`.
    Changes made to an agent are sent to a queue, a waiting list of changes, and the
    functions are run in a separate thread. Unlike refs and atoms, the calling thread
    is not blocked while waiting for the action to complete. So, while agents provide
    far less control over updates than refs, they do not slow down operations with
    retries. In atoms and refs, retries are necessary to solve the problem of simultaneous
    mutations; in agents, the same problem is solved by giving up on simultaneity
    and simply executing incoming functions in the order they are received.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 代理与其他引用类型的主要区别在于，虽然原子和引用的更新是`同步`的，但代理的更新是`异步`的。对代理所做的更改被发送到一个队列，一个等待更改的列表，函数在另一个线程中运行。与引用和原子不同，调用线程在等待操作完成时不会被阻塞。因此，虽然代理在更新方面提供的控制比引用少得多，但它们不会因为重试而减慢操作。在原子和引用中，重试是解决同时性突变问题的必要手段；在代理中，通过放弃同时性，简单地按接收顺序执行传入的函数来解决这个问题。
- en: 'We can observe the asynchronous nature of an agent by making changes that take
    a few seconds to complete, thanks to `Thread/sleep` again:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过进行需要几秒钟才能完成的更改来观察代理的异步特性，这要归功于`Thread/sleep`：
- en: '[PRE63]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: First, we define the agent, setting its value to `5`. Then we `send` two identical
    modifications to increment the agent's value after 5 seconds. If we quickly type
    `@integer-agent` (or `(deref`
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义代理，将其值设置为`5`。然后我们在5秒后发送两个相同的修改来增加代理的值。如果我们快速输入`@integer-agent`（或`(deref`（整数代理）`），但那需要更多时间），我们会看到值仍然是`5`。如果我们等待一段时间后再输入`@integer-agent`，我们会看到值已经增加到`6`。然后几秒钟后，它再次增加到`7`。
- en: '`integer-agent)`, but that takes more time), we see that the value is still
    `5`. If we wait a little bit longer and type `@integer-agent` again, we see that
    the value has moved to `6`. And a few seconds later, it increments again to `7`.'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们快速输入`@integer-agent`（或`(deref`（整数代理）`），但那需要更多时间），我们会看到值仍然是`5`。如果我们等待一段时间后再输入`@integer-agent`，我们会看到值已经增加到`6`。然后几秒钟后，它再次增加到`7`。
- en: 'If we replace the agent in the preceding example with an atom (and use `swap!`
    instead of `send`), the final result is the same but we are forced to wait for
    the operation to complete before we regain control of the REPL:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前一个例子中的代理替换为原子（并使用`swap!`而不是`send`），最终结果相同，但我们被迫等待操作完成才能重新获得REPL（读取-评估-打印-循环）的控制权：
- en: '[PRE64]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If you try this in your REPL, you will see that the REPL prompt is blocked for
    5 seconds after each call to `swap!`.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试在你的REPL中这样做，你将看到每次调用`swap!`后，REPL提示符都会被阻塞5秒钟。
- en: 'Because they do not block, there are some situations where agents are preferable
    to atoms or refs. For example, suppose your main application divides a processor-intensive
    task into several parts that can be passed to separate threads. While these threads
    are working, you want to present a progress bar to the user. When a thread accomplishes
    one unit of work, it increments a counter in an agent. The advantage of an asynchronous
    agent is that this would not slow the worker thread down: control returns immediately
    to the thread, which can start working again right away, and the agent can handle
    the update on its own:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们不会阻塞，有些情况下代理比原子或引用更可取。例如，假设你的主应用程序将一个计算密集型任务分成几个部分，这些部分可以传递给不同的线程。当这些线程在工作时，你想要向用户展示一个进度条。当一个线程完成一项工作单元时，它会在代理中增加一个计数器。异步代理的优势在于这不会减慢工作线程的速度：控制权立即返回到线程，该线程可以立即开始工作，代理可以独立处理更新：
- en: '![Figure 12.14: The worker threads send progress updates to the agent'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14：工作线程向代理发送进度更新](img/B14502_12_14.jpg)'
- en: '](img/B14502_12_14.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.14：工作线程向代理发送进度更新](img/B14502_12_14.jpg)'
- en: 'Figure 12.14: The worker threads send progress updates to the agent'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.14：工作线程向代理发送进度更新
- en: Like refs and unlink atoms, agents also benefit from STM. Inside a `dosync`
    block, changes made to several agents benefit from the same retry semantics as
    refs. Because updates to agents are asynchronous, on the output side they do not
    provide as much control as refs, but they are less prone to deadlock from endless
    retries in very busy systems.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于引用和解除链接的原子，代理也受益于STM（软件事务内存）。在一个`dosync`块内部，对多个代理所做的更改可以享受与引用相同的重试语义。因为代理的更新是异步的，所以在输出方面，它们不像引用那样提供那么多的控制，但它们在非常繁忙的系统中的无限重试导致的死锁倾向较小。
- en: Atoms in ClojureScript
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ClojureScript中的原子
- en: Vars and atoms are the only reference types available in ClojureScript. Even
    though JavaScript runtimes are not multithreaded, code execution is often non-linear.
    In the browser, a single-page application needs to be able to handle events that
    can come from every link or input, or from actions such as scrolling and hovering.
    Application state needs to be shared by the code triggered by these events, and
    atoms turn out to be a very good choice. (This is fortunate, since they are the
    only choice.)
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和原子是 ClojureScript 中唯一可用的引用类型。尽管 JavaScript 运行时不是多线程的，但代码执行通常是线性的。在浏览器中，单页应用程序需要能够处理来自每个链接或输入的事件，或者来自滚动和悬停等操作的事件。应用程序状态需要由触发这些事件的代码共享，而原子被证明是一个非常不错的选择。（这是幸运的，因为它们是唯一的选择。）
- en: The rest of this chapter will focus on atoms in the browser. The odds are that
    your first real-life experience of concurrency in Clojure won't be a complex multithreaded
    JVM application. There's a good chance that you'll take your first Clojure concurrency
    steps in a browser-based ClojureScript program. Many of the best-known ClojureScript
    frameworks for building browser applications, such as Reagent, Re-frame, and Om,
    use atoms to manage state.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将专注于浏览器中的原子。你的 Clojure 并发第一次真正的生活体验可能不会是一个复杂的多线程 JVM 应用程序。你很可能在基于浏览器的
    ClojureScript 程序中迈出你的第一个 Clojure 并发步骤。许多最著名的用于构建浏览器应用程序的 ClojureScript 框架，如 Reagent、Re-frame
    和 Om，都使用原子来管理状态。
- en: 'Exercise 12.05: Rock, Scissors, Paper'
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.05：剪刀石头布
- en: In this exercise, we're going to implement the famous Rock, Scissors, Paper
    game in ClojureScript. The real game is played between two people who count to
    three and then simultaneously make a hand gesture, either a "rock," "scissors,"
    or "paper." Each of the three choices can defeat one of the other two and be defeated
    by the other. Thus, "rock crushes scissors," "scissors cut paper," and "paper
    wraps rock". If both players choose the same object, it's a draw and they play
    again.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用 ClojureScript 实现著名的剪刀石头布游戏。真正的游戏是在两个人之间进行的，他们数到三然后同时做出手势，要么是“石头”、“剪刀”或“布”。这三个选择中的每一个都可以击败另外两个，并且可以被另一个击败。因此，“石头砸剪刀”，“剪刀剪布”，“布包石头”。如果两个玩家选择了相同的物品，那么就是平局，他们需要再次进行游戏。
- en: 'At the command-line prompt, create a new `figwheel` project using the following
    `Leiningen` command:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行提示符下，使用以下 `Leiningen` 命令创建一个新的 `figwheel` 项目：
- en: '[PRE65]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Move to the `packt-clj.rock-scissors-paper/` directory and type the following:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到 `packt-clj.rock-scissors-paper/` 目录，并输入以下内容：
- en: '[PRE66]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 几秒钟后，你的浏览器应该会打开默认的 Figwheel 页面：
- en: '![Figure 12.15: A fresh ClojureScript project waiting for your code'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.15：一个等待你编写代码的全新 ClojureScript 项目'
- en: '](img/B14502_12_15.jpg)'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_15.jpg)'
- en: 'Figure 12.15: A fresh ClojureScript project waiting for your code'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.15：一个等待你编写代码的全新 ClojureScript 项目
- en: Open `packt-clj.rock-scissors-paper/src/packt_clj/rock_scissors_paper/core.cljs`
    and get ready to write some code.
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开 `packt-clj.rock-scissors-paper/src/packt_clj/rock_scissors_paper/core.cljs`
    并准备编写一些代码。
- en: 'Let''s start by designing the underlying data. This is a very simple game,
    so it won''t take much. We need to keep track of the computer''s choice (rock,
    scissors, or paper) and the user''s choice. We also need to have a game state,
    which will be one of three states: `:setup` (the game hasn''t started yet), `:waiting`
    (waiting for the user to play), and `:complete` (we''ll show who won and offer
    to play again).'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先设计底层的数据。这是一个非常简单的游戏，所以不会占用太多时间。我们需要跟踪电脑的选择（石头、剪刀或布）和用户的选择。我们还需要有一个游戏状态，它将是三种状态之一：`:setup`（游戏尚未开始），`:waiting`（等待用户进行游戏），和`:complete`（我们将显示获胜者并提议再次进行游戏）。
- en: 'Replace the supplied `app-state` definition with the following:'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将提供的 `app-state` 定义替换为以下内容：
- en: '[PRE67]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: We also want to make this our own app, so let's update some of the function
    names. Rename the `hello-world` component as `rock-scissors-paper`, for example.
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还希望将其变成我们自己的应用程序，所以让我们更新一些函数名。例如，将 `hello-world` 组件重命名为 `rock-scissors-paper`。
- en: 'All of the game logic will go in a `rock-paper-scissors` component. For now,
    we''ll just have it display some text:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的游戏逻辑都将放在一个 `rock-paper-scissors` 组件中。目前，我们只需显示一些文本：
- en: '[PRE68]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'While we''re there, we can change the end of the file slightly to use the pattern
    that we used in *Chapter 9*, *Host Platform interoperability with Java and JavaScript*:'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们在这里时，我们可以稍微改变文件末尾，以使用我们在*第9章*中使用的模式，*Java和JavaScript与宿主平台的互操作性*：
- en: '[PRE69]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now we''ll define the game logic itself. We''ll try to have this part of the
    program not be dependent on ClojureScript. The first function will determine the
    computer''s choice of rock, paper, or scissors:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将定义游戏逻辑本身。我们将尝试让这个程序的部分不依赖于ClojureScript。第一个函数将确定电脑选择石头、纸或剪刀：
- en: '[PRE70]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The only slightly complex problem is translating the "rock crushes scissors"
    rules into code. Of course, we could just write a long `cond` structure, but since
    this is Clojure, so we''ll use a data structure instead:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一稍微复杂的问题是将“石头砸剪刀”规则转换成代码。当然，我们可以简单地写一个长的 `cond` 结构，但由于这是Clojure，所以我们将使用数据结构：
- en: '[PRE71]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In the `resolutions` map, the top-level keys correspond to the human player's
    choice. Each item contains two possible outcomes, based on the two non-tie choices
    the computer might make.
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `resolutions` 映射中，顶层键对应于人类玩家的选择。每个项目包含基于电脑可能做出的两个非平局选择的两种可能结果。
- en: 'That means that if the player chooses `:rock` and the computer chooses `:scissors`,
    we can get the result like this:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这意味着如果玩家选择 `:rock` 而电脑选择 `:scissors`，我们可以得到如下结果：
- en: '[PRE72]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This is how we''ll write our `resolve-game` function. Checking for ties is
    easy with a simple equality check:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是我们将如何编写我们的 `resolve-game` 函数。通过简单的相等检查来检查平局是容易的：
- en: '[PRE73]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We also want to tell the user why they won or lost by providing a message such
    as "Rock crushes scissors." These messages don''t need to mention who won, so
    we only need associate pairs of objects with a message. `:rock` and `:paper` in
    any order should result in `Paper wraps rock`. Since order isn''t important, `sets`
    might be a good choice. We can use the sets as map keys, like this:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望通过提供像“石头砸剪刀”这样的消息来告诉用户他们赢或输的原因。这些消息不需要提到谁赢了，所以我们只需要将一对对象与一个消息关联起来。无论顺序如何，`:rock`
    和 `:paper` 应该导致 `Paper wraps rock`。由于顺序不重要，`sets` 可能是一个不错的选择。我们可以使用集合作为映射键，如下所示：
- en: '[PRE74]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Most of the time we use keywords as map keys, to the point that we forget sometimes
    that more complex data structures can also be used. This way, it doesn''t matter
    if we write the following:'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大多数时候我们使用关键词作为映射键，以至于有时我们会忘记更复杂的数据结构也可以使用。这样，我们写以下内容时就不重要了：
- en: '[PRE75]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can also write the following:'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们也可以写出以下内容：
- en: '[PRE76]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Let''s wrap this logic into a function:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这个逻辑封装成一个函数：
- en: '[PRE77]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Here, `hash-set` builds the set to be used to look for the appropriate message.
    The `a` and `b` parameters can be, interchangeably, the player's choice or the
    computer's choice.
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，`hash-set` 构建了用于查找适当消息的集合。`a` 和 `b` 参数可以互换，是玩家的选择或电脑的选择。
- en: 'At this point, a game can be resolved with two function calls: one to know
    who won, the other to know why. Here, the player chooses `:scissors` and defeats
    the computer, who unwisely chose `:paper`:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，一个游戏可以通过两次函数调用来解决：一次是知道谁赢了，另一次是知道为什么。在这里，玩家选择了 `:scissors` 并击败了选择了 `:paper`
    的电脑：
- en: '[PRE78]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The next step is to convert our gameplay into views. Let''s break the game
    view out into its own component, which we''ll call `game-view`. There are only
    three game states, so we can get away with a `case` expression. We''ll start with
    just placeholders:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将我们的游戏玩法转换成视图。让我们将游戏视图拆分成它自己的组件，我们将称之为 `game-view`。游戏状态只有三种，所以我们可以通过 `case`
    表达式来避免。我们将从占位符开始：
- en: '[PRE79]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To see the output from this component, we can plug it into the `(rock-scissors-paper)`
    function we defined earlier:'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要查看这个组件的输出，我们可以将其连接到我们之前定义的 `(rock-scissors-paper)` 函数：
- en: '[PRE80]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'At this point, the `game-view` component just shows some different markups
    depending on the game state, which is stuck at `:setup` because there is no code
    to make anything happen yet. Still, it''s a good idea to make sure that everything
    is working as expected. The key here is how `app-state` is dereferenced using
    `rum/react`. The `rum` library adds a lot of built-in behavior that goes beyond
    just dereferencing. For now, though, we can think of `rum/react` as a fancy, framework-specific
    version of `deref`:'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，`game-view` 组件只是根据游戏状态显示一些不同的标记，因为游戏状态卡在 `:setup` 上，因为没有代码让任何事情发生。尽管如此，确保一切按预期工作仍然是一个好主意。这里的重点是
    `app-state` 如何通过 `rum/react` 进行解引用。`rum` 库添加了许多超出只是解引用的内置行为。现在，我们可以将 `rum/react`
    视为一个花哨的、特定于框架的 `deref` 版本：
- en: '![Figure 12.16: We have a start screen but no gameplay yet'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.16：我们有一个开始屏幕，但还没有游戏玩法'
- en: '](img/B14502_12_16.jpg)'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_16.jpg)'
- en: 'Figure 12.16: We have a start screen but no gameplay yet'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.16：我们有一个开始屏幕，但还没有游戏玩法
- en: To move on to the next game state, something needs to happen when the player
    clicks on `Start`. We need a function that will start the game.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要进入下一个游戏状态，当玩家点击“开始”时需要发生某些事情。我们需要一个启动游戏的函数。
- en: 'To start a new game, we need to do two things to `app-state`: set `:game-state`
    to `:waiting` and set `:computer-choice` to the output from our `computer-choice`
    function. It''s also probably good practice to clean up the `:player-choice` field
    as well, since it is no longer valid. Our `start-game` function can look like
    this:'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要开始新游戏，我们需要对`app-state`做两件事：将`:game-state`设置为`:waiting`，并将`:computer-choice`设置为`computer-choice`函数的输出。同样，清理`:player-choice`字段也可能是良好的实践，因为它不再有效。我们的`start-game`函数可以看起来像这样：
- en: '[PRE81]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Notice that we''re using `swap!`. Since `app-state` is a real atom, this is
    how we have to interact with it, by providing a function. If we wanted to be more
    concise, our call to `swap!` could be rewritten like this:'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们正在使用`swap!`。由于`app-state`是一个真正的原子，这就是我们必须通过提供函数与之交互的方式。如果我们想更简洁，我们的`swap!`调用可以重写如下：
- en: '[PRE82]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Inside the `game-view` component, we can now add `start-game` as a click handler
    in both the `:setup` and `:complete` phases:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`game-view`组件内部，我们现在可以在`:setup`和`:complete`阶段添加`start-game`作为点击处理程序：
- en: '[PRE83]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Let''s check this new behavior. If you click on `Start`, you should now see
    this:'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们检查这个新行为。如果你点击“开始”，你现在应该看到这个：
- en: '![Figure 12.17: Starting the Rock, Paper, Scissors application'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.17：启动石头、剪刀、布应用程序'
- en: '](img/B14502_12_17.jpg)'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_17.jpg)'
- en: 'Figure 12.17: Starting the Rock, Paper, Scissors application'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.17：启动石头、剪刀、布应用程序
- en: 'Now we need handlers for each of the choices. Since each handler will do essentially
    the same thing, just with a different value, let''s write a function that returns
    a function using that value. We''ll call it `player-choice`:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要为每个选择编写处理程序。由于每个处理程序基本上都会做同样的事情，只是值不同，让我们编写一个返回函数的函数，我们将它称为`player-choice`：
- en: '[PRE84]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The changes made to `app-state` here move the `:game-state` to the next phase
    and add in the `choice` parameter as a means of closure for the anonymous function.
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里对`app-state`所做的更改将`:game-state`移动到下一个阶段，并添加`choice`参数作为匿名函数的关闭手段。
- en: 'Instead of writing three separate handlers, we can just call these functions
    in the view. Now our `game-view` component looks like this:'
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不需要编写三个单独的处理程序，我们可以在视图中调用这些函数。现在我们的`game-view`组件看起来像这样：
- en: '[PRE85]'
  id: totrans-377
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Notice that with the `start-game` handler, we supply the function itself, without
    parentheses. That's because `start-game` itself is the handler. With `player-choice`,
    we call the function when defining the view; it isn't the handler, instead it
    returns an anonymous handler, which is what will actually be called when the user
    clicks the link.
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，使用`start-game`处理程序时，我们提供的是函数本身，不带括号。这是因为`start-game`本身是处理程序。对于`player-choice`，我们在定义视图时调用该函数；它不是处理程序，而是返回一个匿名处理程序，当用户点击链接时，实际上会调用这个处理程序。
- en: 'Now, when clicking on `Rock`, `Scissors`, or `Paper`, you should see the final
    screen:![Figure 12.18: Final screen of Rock, Paper, Scissors'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，当点击“石头”、“剪刀”或“布”时，你应该看到最终屏幕：![图12.18：石头、剪刀、布的最终屏幕
- en: '](img/B14502_12_18.jpg)'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_18.jpg)'
- en: 'Figure 12.18: Final screen of Rock, Paper, Scissors'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.18：石头、剪刀、布的最终屏幕
- en: 'The last step is to display the results. Since this is more complex than the
    other views, it''s worth breaking it out into a new component, which we''ll call
    `result-view`. Let''s look at the code and then we''ll go through the logic:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是显示结果。由于这比其他视图更复杂，所以将其拆分为一个新的组件是值得的，我们将它称为`result-view`。让我们看看代码，然后我们将通过逻辑来分析：
- en: '[PRE86]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: We start off with some `let` bindings for the player choice, the computer choice,
    and the result, which is derived from the two choices.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们从为玩家选择、电脑选择和结果（由两个选择推导而来）设置一些`let`绑定开始，结果。
- en: Everything after that takes place in a single `:div` element. This is necessary
    because in React, and thus in all the React-based ClojureScript frameworks, a
    component can only return a single HTML element. Without this wrapping `:div`
    element, we would get an error.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之后的所有内容都在单个`:div`元素中完成。这是必要的，因为在React中，以及在所有基于React的ClojureScript框架中，一个组件只能返回一个HTML元素。如果没有这个包装`:div`元素，我们会得到一个错误。
- en: After displaying both of the choices, using `name` to convert the keywords to
    strings, we get to the actual results. In case of a tie, there is not much to
    display, so we test for that first. The `result-messages` function provides a
    nice summary of what happened and then we can finally tell the player whether
    they won or lost, depending on the value of `result`. At the end, we've placed
    the "`Play again?`" link that was previously in the `game-view` component.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在显示两个选项之后，使用`name`将关键字转换为字符串，我们就可以得到实际的结果。在出现平局的情况下，没有太多可以显示的，所以我们首先测试这一点。`result-messages`函数提供了一个关于发生了什么的良好总结，然后我们可以根据`result`的值最终告诉玩家他们赢了还是输了。最后，我们在`game-view`组件中放置了之前在其中的"`Play
    again?`"链接。
- en: 'Now we just need to insert the `result-view` component into the `game-view`
    component:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要将`result-view`组件插入到`game-view`组件中：
- en: '[PRE87]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Note
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The complete code for this exercise is available on the book''s GitHub repository:
    [https://packt.live/2uoDolF](https://packt.live/2uoDolF).'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本练习的完整代码可在本书的GitHub仓库中找到：[https://packt.live/2uoDolF](https://packt.live/2uoDolF)。
- en: 'Now you should be able to play the game:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在你应该能够玩游戏了：
- en: '![Figure 12.19: Prompt to play again'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.19：再次玩游戏的提示'
- en: '](img/B14502_12_19.jpg)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_12_19.jpg)'
- en: 'Figure 12.19: Prompt to play again'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19：再次玩游戏的提示
- en: You won! By building this simple game, you've learned a basic template for stateful
    ClojureScript applications, using one of Clojure's reference types. Even though
    the JavaScript runtime is single-threaded, atoms are useful here because they
    allow event handlers to interact with shared program state in a safer way than
    simply overwriting data.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你赢了！通过构建这个简单的游戏，你已经学会了使用Clojure的一种引用类型的基本模板，用于有状态的ClojureScript应用程序。尽管JavaScript运行时是单线程的，但原子在这里很有用，因为它们允许事件处理器以比简单覆盖数据更安全的方式与共享程序状态交互。
- en: Watchers
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视器
- en: 'In the previous exercise, we mentioned that when using the `Rum` library, writing
    `(rum/react app-state)` basically dereferences the `app-state` atom. There is,
    however, a little bit more going on, obviously, since otherwise we would use `deref`
    instead. In ClojureScript libraries such as Rum, atoms often serve as the application''s
    "single source of truth." Rum and the Om framework both use plain atoms; Reagent
    and the popular `Re-frame` library, which is based on Reagent, both use a special
    `atom` implementation sometimes referred to as a "ratom" (from **r/atom**, if
    **r** is a namespace alias for Reagent). You''ll learn more about Reagent in *Chapter
    15*, *The Front End: A ClojureScript UI*.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的练习中，我们提到，当使用`Rum`库时，编写`(rum/react app-state)`基本上是取消引用`app-state`原子。然而，显然还有更多的事情在进行中，否则我们就会使用`deref`。在Rum等ClojureScript库中，原子通常作为应用程序的“单一事实来源”。Rum和Om框架都使用普通的原子；Reagent以及基于Reagent的流行库`Re-frame`，都使用一种特殊的`atom`实现，有时被称为“ratom”（来自**r/atom**，如果**r**是Reagent的命名空间别名）。你将在第15章*前端：ClojureScript
    UI*中了解更多关于Reagent的内容。
- en: Why are atoms so popular for ClojureScript libraries? First of all, atoms help
    manage concurrent updates. When there is a single source of truth, that means
    that many parts of the program may interfere with each other when they all try
    to update the same data source. As we've already seen, atoms, with their built-in
    retry logic, help avoid many of these issues.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么原子在ClojureScript库中如此受欢迎？首先，原子有助于管理并发更新。当存在单一事实来源时，这意味着当所有部分都尝试更新相同的数据源时，程序中的许多部分可能会相互干扰。正如我们之前所看到的，原子及其内置的重试逻辑有助于避免许多这些问题。
- en: 'Beyond this, however, Clojure (and ClojureScript) atoms have another important
    feature that makes them particularly useful as the single source of truth in a
    browser-based application. A common pattern in modern JavaScript architectures
    goes something like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除此之外，Clojure（以及ClojureScript）的原子还具有另一个重要的特性，使它们在基于浏览器的应用程序中作为单一事实来源特别有用。现代JavaScript架构中的一种常见模式大致如下：
- en: 'An event occurs and is handled by the application. In the previous exercise,
    these were the click handlers. There are, of course, many other kinds of events
    that might occur: scrolling events, timeouts, successful (or failed) network requests,
    and so on.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发生一个事件并由应用程序处理。在之前的练习中，这些是点击处理器。当然，还有许多其他可能发生的事件：滚动事件、超时、成功（或失败）的网络请求等等。
- en: In response to the event, the application state is modified. In the Rock, Paper,
    Scissors game, the player made their choice, and this was reflected in `app-state`,
    via `swap!`.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件发生时，应用程序状态被修改。在剪刀石头布游戏中，玩家做出了选择，并通过`swap!`反映在`app-state`中。
- en: The rest of the application reacts to this change in the application state.
    Views that reference the application state are updated automatically. Advancing
    the `:game-state` field in `app-state` caused the different phases of the game
    to be displayed. Once the appropriate views were defined, the framework seemed
    to take care of making sure that the views were updated.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的其他部分会对应用程序状态的变化做出反应。引用应用程序状态的视图会自动更新。在`app-state`中推进`:game-state`字段导致游戏的不同阶段被显示。一旦定义了适当的视图，框架似乎会确保视图被更新。
- en: 'When one part of the application updates the application states, the other
    parts respond. Atoms help with this because they accept "watcher" functions that
    are called when the atom changes. To "watch" an atom, we use the `add-watch` function:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序的一部分更新应用程序状态时，其他部分会做出响应。原子通过接受在原子变化时被调用的“观察者”函数来帮助实现这一点。要“观察”一个原子，我们使用`add-watch`函数：
- en: '[PRE88]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We've provided an anonymous function that simply prints out a message when the
    atom is changed. When adding a `watch` function, a key such as `:watcher-1` is
    required so that, later, that particular watcher can be identified for removal
    by the `remove-watch` function. That key is then available as the first argument
    to the watcher function, `k` in this example. The `a` argument is the atom itself.
    Often, these two arguments will not be used; in most cases, what you really need
    is in the `old` and `new` arguments.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提供了一个匿名函数，当原子发生变化时，它只是简单地打印出一条消息。当添加`watch`函数时，需要一个像`:watcher-1`这样的键，以便稍后可以通过`remove-watch`函数识别并移除特定的观察者。这个键随后作为观察者函数的第一个参数可用，在这个例子中是`k`。`a`参数是原子本身。通常，这两个参数不会被使用；在大多数情况下，你真正需要的是在`old`和`new`参数中。
- en: 'In the previous exercise, we defined our components using the `rum/reactive`
    mixin as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们使用`rum/reactive`混合物如下定义了我们的组件：
- en: '[PRE89]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '`rum/reactive` then adds watchers as appropriate so that the component knows
    when to update. This way, multiple components can reference the same data in `app-state`;
    when the data changes, the components are watching, and they can update accordingly.
    This pattern happens to mesh nicely with some of the common patterns used with
    React.js, which is why it is seen so often in ClojureScript libraries and applications.
    Generally, when using these frameworks, you will not need to define your own watchers.
    The frameworks take care of that for you.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`rum/reactive`随后根据需要添加观察者，以便组件知道何时更新。这样，多个组件可以引用`app-state`中的相同数据；当数据发生变化时，组件正在观察，并且可以相应地更新。这种模式恰好与React.js中使用的某些常见模式相匹配，这就是为什么它在ClojureScript库和应用程序中如此常见。通常，当使用这些框架时，你不需要定义自己的观察者。框架会为你处理这些。'
- en: 'Validators are another feature of atoms that you could actually use in your
    ClojureScript app. Like watchers, validators are functions that can be added to
    Clojure reference types. When an atom, for example, is about to be modified by
    a call to `swap!`, if any validators have been set on the atom, they will be called.
    If any of them do not return `true`, the update will fail and an exception (or
    an error, if this is on the JavaScript runtime) will be thrown:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 验证器是原子的另一个特性，你可以在你的ClojureScript应用程序中使用它。像观察者一样，验证器是可以添加到Clojure引用类型的函数。例如，当原子即将通过调用`swap!`被修改时，如果原子上设置了任何验证器，它们将被调用。如果其中任何一个没有返回`true`，更新将失败，并抛出异常（或者在JavaScript运行时是错误）：
- en: '![Figure 12.20: Execution error'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.20：执行错误'
- en: '](img/B14502_12_20.jpg)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14502_12_20.jpg)'
- en: 'Figure 12.20: Execution error'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20：执行错误
- en: When an update fails validation, an exception is thrown.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 当更新失败验证时，会抛出异常。
- en: Here, the validator enforces a "less than 6" rule on `integer-atom`. The call
    to `swap!` tries to increment the value to `6` but an exception is thrown instead.
    In the next exercise, we will incorporate some validation.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，验证器对`integer-atom`强制执行“小于6”的规则。`swap!`的调用试图将值增加到`6`，但相反抛出了异常。在下一个练习中，我们将结合一些验证。
- en: 'Exercise 12.06: One, Two, Three… "Rock!"'
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12.06：一、二、三…“Rock!”
- en: 'Your in-browser Rock, Paper, Scissors game is starting to generate some interest.
    You''ve created a start-up around it and now your investors want an improved version
    that is more like the original. Your plan is to introduce a countdown before the
    user can make their choice, just like in the original version of the game, where
    the two players coordinate their moves before revealing their choices: "One, two,
    three…Rock!"'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你的网页版剪刀石头布游戏开始引起一些兴趣。你已经围绕它创建了一个初创公司，现在你的投资者想要一个更接近原始版本的游戏改进版。你的计划是在用户做出选择之前引入倒计时，就像游戏原始版本中两个玩家在揭示选择前协调他们的动作一样：“一、二、三……石头！”
- en: To do this, we'll use JavaScript intervals to provide some timing for the countdown.
    In the browser, intervals are how JavaScript developers can cause a function to
    be called repeatedly after a certain number of milliseconds. We will use intervals
    to simulate a ticking clock, where each tick of the clock will be an event that
    the application reacts to. This will show how application state can be used to
    coordinate and react to events.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用JavaScript间隔来为倒计时提供一些时间。在浏览器中，间隔是JavaScript开发者可以导致函数在经过一定数量的毫秒后重复调用的方式。我们将使用间隔来模拟一个滴答作响的时钟，其中时钟的每一次滴答都将是一个应用程序需要响应的事件。这将展示如何使用应用程序状态来协调和响应事件。
- en: Note
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This exercise builds on your code from the previous exercise. Either use the
    same project or make a copy.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习基于你之前练习中的代码。要么使用同一个项目，要么创建一个副本。
- en: 'At the command-line prompt, start the ClojureScript REPL:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行提示符下，启动ClojureScript REPL：
- en: '[PRE90]'
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: A browser window should open, inviting you to play a game of Rock, Paper, Scissors.
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应该打开一个浏览器窗口，邀请你玩一个剪刀石头布的游戏。
- en: 'Add a `:countdown` field to the `app-state` atom:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app-state`原子中添加一个`:countdown`字段：
- en: '[PRE91]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Add a validator to the `app-state` to make sure that the `:game-state` field
    always contains a game phase keyword and that the countdown never goes beyond
    3 or below 0:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`app-state`添加一个验证器，以确保`:game-state`字段始终包含游戏阶段关键字，并且倒计时永远不会超过3或低于0：
- en: '[PRE92]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Note
  id: totrans-427
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The greater-than and less-than family of functions all take more than two arguments.
    This is a convenient way of testing whether a value is between two other values.
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 大于和小于函数族都接受超过两个参数。这是一种方便的测试一个值是否介于两个其他值之间的方法。
- en: 'Most of the improvements we want to make are going to affect the `:waiting`
    phase of the game. Let''s make a dedicated view, which we''ll call the `choices-view`
    function. It will show two things: the countdown and the list of choices.'
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想要做的绝大多数改进都将影响游戏的`:waiting`阶段。让我们创建一个专门的视图，我们将称之为`choices-view`函数。它将显示两个东西：倒计时和选择列表。
- en: 'As a first step, set up the view with the same list of choices as before:'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 作为第一步，设置与之前相同的选项列表视图：
- en: '[PRE93]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'At the same time, add this new view to `game-view`, instead of the previous
    list corresponding to the `:waiting` game state:'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同时，将这个新视图添加到`game-view`中，而不是之前与`:waiting`游戏状态对应的列表：
- en: '[PRE94]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: At this point, the game should still work exactly as before.
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这一点上，游戏应该仍然像以前一样工作。
- en: 'Before the countdown reaches zero, the links in the list of choices should
    be inactive to prevent the player from clicking too soon. Since each link needs
    to handle two different states, it makes sense to encapsulate that behavior in
    a component, like this:'
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在倒计时达到零之前，选择列表中的链接应该处于非活动状态，以防止玩家过早点击。由于每个链接都需要处理两种不同的状态，因此将这种行为封装在组件中是有意义的，如下所示：
- en: '[PRE95]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Note
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to place `choice-link-view` before `choices-view` in the source file.
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记得在源文件中将`choice-link-view`放在`choices-view`之前。
- en: The first two arguments simply supply the keyword and the text label necessary
    for building the links, as before. The `countdown` argument, however, will allow
    us to determine what should be displayed. If the countdown has reached zero, we
    display the link. If not, we simply display the label.
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前两个参数简单地提供了构建链接所需的键和文本标签，就像以前一样。然而，`countdown`参数将允许我们确定应该显示什么。如果倒计时已达到零，我们显示链接。如果没有，我们只显示标签。
- en: 'We need to update `choices-view` as well:'
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更新`choices-view`：
- en: '[PRE96]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'When you try to play the game now, if you click on `Start`, you should see
    this:'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当你尝试玩游戏时，如果你点击“开始”，你应该看到这个：
- en: '![Figure 12.21: Options available on clicking Start'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.21：点击“开始”可用的选项'
- en: '](img/B14502_12_21.jpg)'
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/B14502_12_21.jpg)'
- en: 'Figure 12.21: Options available on clicking Start'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.21：点击“开始”可用的选项
- en: 'We also want to display the countdown in this view. Let''s make a new component
    for that too so that we can add a little bit of display logic:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还希望在视图中也显示倒计时。让我们也为此创建一个新的组件，这样我们就可以添加一些显示逻辑：
- en: '[PRE97]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'And this view can be called from `choices-view` as well:'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 而这个视图也可以从`choices-view`中调用：
- en: '[PRE98]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If you try to play the game at this point, you should see `3` displayed above
    the inactive links:'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你在这个时候尝试玩游戏，你应该会看到在非活动链接上方显示`3`：
- en: '![Figure 12.22: The countdown is there but it''s not moving yet'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图12.22：倒计时已经存在，但还没有开始移动]'
- en: '](img/B14502_12_22.jpg)'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图片 B14502_12_22.jpg]'
- en: 'Figure 12.22: The countdown is there but it''s not moving yet'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图12.22：倒计时已经存在，但还没有开始移动
- en: 'For the timing of the countdown, we''ll use `setInterval`, which means that
    we need some JavaScript interop. This function will cause the `:countdown` field
    to decrement every second:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于倒计时的计时，我们将使用`setInterval`，这意味着我们需要一些JavaScript互操作。这个函数将导致`:countdown`字段每秒递减：
- en: '[PRE99]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The `setInterval` function returns an identifier that we''ll need later for
    canceling the interval. Each time a new game starts, we need to start the interval
    and record its identifier. These things can be done by the `start-game` function,
    which we''ll update. (For this reason, `start-countdown` will need to be placed
    before the `start-game` function in your source file.):'
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`setInterval`函数返回一个标识符，我们稍后会需要它来取消间隔。每次新游戏开始时，我们需要启动间隔并记录其标识符。这些事情可以通过`start-game`函数来完成，我们将更新它。（因此，`start-countdown`需要放在你的源文件中的`start-game`函数之前。）'
- en: '[PRE100]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The `interval` goes into the app-state for later use.
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`interval`将被放入app-state中以便稍后使用。'
- en: We know that we don't want the countdown to go below 0\. We also don't want
    to start a new interval in a game without canceling the previous interval. After
    a few games, we would end up with many intervals all trying to update the `:countdown`
    field.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道我们不想让倒计时低于0。我们也不想在游戏中不取消上一个间隔就启动一个新的间隔。经过几轮游戏后，我们会有许多间隔都在尝试更新`:countdown`字段。
- en: 'Stopping the interval is easy enough with the `clearInterval` function. But
    how do we know when it should be called? One solution would be to add a check
    in the function we passed to `setInterval` in the `start-countdown` function.
    For this exercise, though, we''ll use a watcher:'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用`clearInterval`函数停止间隔非常简单。但我们是怎样知道何时应该调用它的呢？一个解决方案是在`start-countdown`函数中传递给`setInterval`的函数中添加一个检查。然而，对于这个练习，我们将使用一个观察者：
- en: '[PRE101]'
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: We won't ever remove this watcher, but we still need to give it an identifier,
    for which we use a descriptive keyword. The interesting part of this call to `add-watch`
    is the anonymous function we provide. This function will be called every time
    a change occurs in the `app-state` atom. Most of the time, this function will
    do nothing. The exception, of course, is when the countdown is about to go to
    zero. In that case, `clearInterval` is called with the interval identifier stored
    in the atom.
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们不会移除这个观察者，但我们仍然需要给它一个标识符，我们使用一个描述性的关键字。这个`add-watch`调用的有趣之处在于我们提供的匿名函数。这个函数将在`app-state`原子中的每次变化时被调用。大多数时候，这个函数将不会做任何事情。当然，例外的情况是当倒计时即将达到零时。在这种情况下，使用存储在原子中的间隔标识符调用`clearInterval`。
- en: 'Now the countdown should work as planned. When it reaches zero, the message
    changes to `Go!` and the links become active:'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在倒计时应该按计划工作。当它达到零时，消息变为`Go!`，链接变为活动状态：
- en: '![Figure 12.23: A successful countdown'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '![图12.23：成功的倒计时]'
- en: '](img/B14502_12_23.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_12_23.jpg]'
- en: 'Figure 12.23: A successful countdown'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23：成功的倒计时
- en: This exercise showed us how watchers and validators work. Remember, in Clojure
    they can be used on all the different kinds of reference types.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习向我们展示了观察者和验证者是如何工作的。记住，在Clojure中，它们可以用于所有不同类型的引用类型。
- en: 'Activity 12.01: A DOM Whack-a-mole Game'
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动12.01：一个DOM Whack-a-mole游戏
- en: After the amazing success of your Rock, Paper, Scissors browser game, you've
    decided to create an even more ambitious product, based on the classic Whack-a-mole
    game. Whack-a-mole is an early arcade game. Moles pop up at random from several
    holes in a table. The player holds a mallet and tries to whack the moles as soon
    as they appear. When hit, the mole disappears back into its hole until it pops
    back up again.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的Rock, Paper, Scissors浏览器游戏取得惊人的成功之后，你决定创建一个更加雄心勃勃的产品，基于经典的Whack-a-mole游戏。Whack-a-mole是一款早期的街机游戏。老鼠从桌子上的几个洞中随机弹出。玩家拿着一根槌子，试图在老鼠出现时立即击打它们。被击中后，老鼠会消失回它的洞中，直到再次弹出。
- en: 'Your version of Whack-a-mole will use DOM elements in a web browser. It might
    look something like this (if you know some CSS, you''re free to make it look a
    little better):'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Whack-a-mole 版本将在网页浏览器中使用 DOM 元素。它可能看起来像这样（如果你懂一些 CSS，你可以自由地让它看起来更好一些）：
- en: '![Figure 12.24: Before the game starts'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.24：游戏开始前](img/B14502_12_24.jpg)'
- en: '](img/B14502_12_24.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_12_24.jpg](img/B14502_12_24.jpg)'
- en: 'Figure 12.24: Before the game starts'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.24：游戏开始前](img/B14502_12_24.jpg)'
- en: 'Once the player clicks on the `Click to play!` button, the clock starts and
    the moles, who are actually just HTML `<div>` elements, start to randomly activate:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦玩家点击“点击开始！”按钮，时钟开始，实际上只是 HTML `<div>` 元素的地鼠开始随机激活：
- en: '![Figure 12.25: Click on the moles!'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.25：点击地鼠！](img/B14502_12_25.jpg)'
- en: '](img/B14502_12_25.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14502_12_25.jpg](img/B14502_12_25.jpg)'
- en: 'Figure 12.25: Click on the moles!'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 12.25：点击地鼠！](img/B14502_12_25.jpg)'
- en: At this point, if the player clicks on a mole, it goes back to the waiting state
    and a point is added to the player's score. The game stops after a fixed number
    of seconds, probably 20 or so.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果玩家点击地鼠，它将回到等待状态，并为玩家的得分加一分。游戏在固定秒数后停止，可能是 20 秒左右。
- en: 'The behavior of the moles follows these rules: Only two moles are visible at
    a time. The moles to be made visible are selected randomly. A mole is visible
    for a fixed duration (2 or 3 seconds, probably) and reverts to the hidden state
    after that time if the player has not clicked on it.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 地鼠的行为遵循以下规则：一次只能看到两个地鼠。要显示的地鼠是随机选择的。地鼠在固定的时间内可见（可能是 2 或 3 秒），如果玩家在这段时间内没有点击它，它将恢复到隐藏状态。
- en: 'To build this game, you should take these basic steps:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建这个游戏，你应该采取以下基本步骤：
- en: Use the same basic ClojureScript and Rum setup used in the Rock, Paper, Scissors
    exercises.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用在“剪刀石头布”练习中使用的相同的基本 ClojureScript 和 Rum 设置。
- en: As in the last exercise, use `setInterval` to count down the seconds after the
    game starts. For more fluidity, it's probably best to use an interval smaller
    than 1 second. 100 milliseconds is probably about right.
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同上一个练习，使用 `setInterval` 来在游戏开始后倒计时秒数。为了更流畅，可能最好使用小于 1 秒的间隔。100 毫秒可能恰到好处。
- en: 'Use multiple atoms for the various counters that you''ll need: the countdown
    clock (the interval itself), the number of milliseconds remaining in the game,
    the game state (`:waiting` or `:playing`), and a vector of moles.'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个 atoms 来管理所需的各个计数器：倒计时时钟（间隔本身）、游戏中剩余的毫秒数、游戏状态（`:waiting` 或 `:playing`）和地鼠的向量。
- en: 'The moles themselves should have two values: their status (`:waiting` or `:live`)
    and the number of remaining milliseconds remaining if they are in the `:live`
    state. These values could be contained in a map or a two-item vector tuple.'
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地鼠本身应该有两个值：它们的状态（`:waiting` 或 `:live`）以及如果它们处于 `:live` 状态，剩余的毫秒数。这些值可以包含在一个
    map 或一个包含两个元素的向量元组中。
- en: Write event handlers for clicks on the `Start` button and on the active moles.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为“开始”按钮和活动地鼠的点击编写事件处理器。
- en: If you know some CSS, feel free to make the game look better by adding some
    definitions to `resources/public/css/style.css`.
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你懂一些 CSS，请随意通过向 `resources/public/css/style.css` 添加一些定义来使游戏看起来更好。
- en: Note
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution for this activity can be found on page 738.
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在第 738 页找到。
- en: Summary
  id: totrans-489
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Concurrency, by its very nature, is a complex problem. While it''s impossible
    to cover all the techniques you might need, hopefully, this chapter will provide
    you with the tools to get started. We covered the usage of `pmap` and `future`
    for using multiple threads. We also saw Clojure''s reference types: var, atoms,
    agents, and refs. We used atoms to manage state in a browser-based ClojureScript
    application.'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 并发，由于其本质，是一个复杂的问题。虽然不可能涵盖你可能需要的所有技术，但希望这一章能为你提供开始所需的工具。我们介绍了 `pmap` 和 `future`
    的用法来使用多线程。我们还看到了 Clojure 的引用类型：var、atoms、agents 和 refs。我们使用 atoms 在基于浏览器的 ClojureScript
    应用程序中管理状态。
- en: For each of these topics, there is a lot more that can be said. What you learn
    further down the road will depend on the kinds of problems you need to solve.
    Concurrency is one of the areas where the problems will be more diverse than almost
    any other. Familiarity with Clojure's basic approach to these questions will start
    you in the right direction when you search for solutions.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些主题中的每一个，都有更多可以说的。你以后学到的东西将取决于你需要解决的问题的类型。并发是问题比几乎所有其他领域都更加多样化的领域之一。熟悉 Clojure
    对这些问题的基本方法将帮助你找到解决方案的正确方向。
- en: In the next chapter, we will take another big step toward real-world Clojure
    by learning how to interact with databases.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将迈出另一大步，通过学习如何与数据库交互，向现实世界的Clojure迈进。
