- en: 12\. Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will explore Clojure''s concurrency features. On the JVM,
    you will learn the basics of programming with multiple processor threads: starting
    a new thread and using the results. To coordinate your threads, we will use Clojure''s
    innovative reference types. One of these, the atom, can also be used in a JavaScript
    environment.'
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to build simple browser games and
    manage their state using atoms.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ever since the Clojure language was first introduced, its concurrency model
    has been one of its major selling points. In programming, the word "concurrency"
    can apply to a lot of different situations. To start with a simple definition,
    any time your program or your system has more than one simultaneous flow of operations,
    you are dealing with concurrency. In multithreaded Java programs, that would mean
    code running simultaneously in separate processor threads. Each processor thread
    follows its own internal logic, but to work properly your program needs to coordinate
    the communication between the different threads. Even though JavaScript runtimes
    are single-threaded, both the browser and Node.js environments have their own
    ways of dealing with simultaneous logical flows. While the roots of Clojure's
    concurrency are definitely in Java, some of the ideas and tools apply equally
    in **ClojureScript**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn the basics of concurrent programming. Some of
    Clojure's features, such as **Software Transactional Memory** (**STM**), are mostly
    useful in large, complex systems. While we can't simulate all of that complexity
    in a single chapter, we will explore the basic concepts and tools that Clojure
    provides. To demonstrate the techniques and get you up to speed on concurrency,
    we'll use two different environments. On the JVM, you'll learn how to create threads
    that communicate with each other. In the browser, you'll learn how to coordinate
    events that occur in different parts of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrency in General
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modern computers use **threads** to distribute execution between multiple processor
    cores. There are many reasons for this, including the physics of microchip design
    and the need for user environments that remain responsive even when one program
    is performing an intensive computation in the background. Everyone wants to be
    able to check their email, listen to music, and run their Clojure REPL at the
    same time! Inside a program, this kind of multitasking can also represent a significant
    performance gain. While one thread is waiting for data from the disk drive, another
    for the network, two other threads can be processing data. When done correctly,
    this can represent a significant gain in performance and overall efficiency. The
    operative phrase here, though, is "when done correctly." Concurrency can be tricky.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most computer code is written in a linear manner: do this, do that, then do
    this. The source code for a method or a function reads from top to bottom. We
    think about code linearly when we are writing it. In a multithreaded system, that''s
    not how your code will be executed. Some parts of your program will run in one
    thread, and other parts in other threads, simultaneously. Coordination becomes
    a new problem. Experience shows that multithreaded applications are harder to
    write and tend to be more error-prone than single-threaded applications. Most
    of all, they are harder for us to understand. So, while there is a potential for
    better performance, there is also a potential for greater complexity. Like many
    aspects of programming, it''s all about trade-offs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure''s most important concurrency feature is actually one that you''ve
    been using from the beginning: immutability. Clojure''s immutable data types provide
    a special kind of protection throughout your system. Values are locked down once
    and for all; if a separate thread needs to "modify" your data, it will actually
    use an efficient copy that won''t interfere with the other threads. And because
    this feature is a fundamental part of the Clojure language, you get it for "free":
    data is immutable by default, so there is no extra procedure to prepare it for
    concurrency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new thread is created, we say that the current thread has been forked.
    The parent thread shares its state with the new thread but loses control of the
    execution flow. Let''s take a look at how things can go wrong when values are
    mutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: Shared state in a language with mutable data structures can
    lead to problems'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: Shared state in a language with mutable data structures can lead
    to problems'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this diagram, we can see a main thread that creates a fork. In the original
    thread, the variable, `x`, is an array: `[5, 3, 7]`. The fork then modifies the
    array. Because it is shared between the two threads, the array is also modified
    in the main thread. From the point of view of the main thread, the value of `x`
    seems to change suddenly for no reason, as if modified by some external force.
    This is an oversimplification, of course, since languages such as Java do allow
    programmers to protect themselves from problems like this. However, shared mutable
    state does create a risk of this kind of problem.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Immutability in Clojure largely solves this part of the problem. Here''s a
    similar diagram representing a Clojure version of the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Clojure''s immutable data structures are never modified: changes
    create new'
  prefs: []
  type: TYPE_NORMAL
- en: versions of the data
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Clojure''s immutable data structures are never modified: changes
    create new versions of the data'
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Parallelization with pmap
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Nearly every kind of concurrency involves some additional complexity for the
    programmer. There is an exception to this rule though: Clojure''s `pmap` function.
    The name is the abbreviation of `map`, `pmap` calls a function on each item in
    a list. The difference is that each function call runs on a separate thread so
    that some of the calculations can be run simultaneously.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this diagram, we map an imaginary function, `pfn`, over a simple vector.
    For each item, `pmap` calls `pfn` in a new thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3: pmap spawns new threads so that calculations can occur simultaneously'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.3: pmap spawns new threads so that calculations can occur simultaneously'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem like great news. In certain cases, it might be. But if you''re
    thinking "I''ll use `pmap` all the time and my program will run faster," you''ll
    be disappointed most of the time. The problem is that there is a lot of behind-the-scenes
    work that must occur for `pmap` to spawn new threads. It turns out that `pmap`
    is only more efficient than the single-threaded `map` function when the calculation
    is particularly time-consuming. We can compare the relative speed of `map` and
    `pmap` on a trivial `map` operation. We''ll use Clojure''s `time` macro to compare
    execution times. The `time` macro wraps an expression, evaluates it normally,
    and prints out the time it took to evaluate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Incrementing 10 integers is not a resource-intensive task. With the ordinary
    `map` function, it takes less than a tenth of a microsecond. Performing the same
    operation with `pmap` takes almost 30 times longer! What took so long? Creating
    threads consumes resources. Obviously, `pmap` should only be used when it's clear
    that the additional overhead is worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We need to use `doall` here; otherwise, we would just be timing the speed of
    the creation of an unrealized lazy sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: Testing Randomness'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back on your job at the data journalism website, one of the analysts is concerned
    that the random number generator used in your programs is not random enough. She
    wants you to test it by generating a very long sequence of random integers and
    then checking a few numbers to see whether they are equally represented. In doing
    this, you'll be able to see whether it's faster to use `map` or `pmap` thanks
    to Clojure's `time` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a `REPL`. This is a one-off test, so there''s no need to create a project:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a very long sequence of integers between `0` and `1000`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we use `doall` to make sure that the lazy sequence returned by `repeatedly`
    is fully realized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define a function that counts the number of occurrences of an integer in a
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `map` to count the number of occurrences of some integers in `random-ints`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This seems to work, but it is fairly slow. To discover how slow it is, we can
    use Clojure''s `time` function to provide a quick benchmark. Don''t forget to
    wrap the output from `map` in `doall`. Otherwise, you''re just timing the creation
    of an unrealized lazy sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Your time will be longer or shorter, of course.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now try using `pmap` instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's a lot faster! This is good in case the analyst asks for an even bigger
    sample size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this example, `pmap` came to the rescue and sped things up significantly.
    The beauty of `pmap` is that no extra coding is necessary. It's simple enough
    to write `pmap` instead of `map`. However, like many tools, the most important
    part is knowing when not to use it. This example was particularly well suited
    for parallelization because of the large size of the dataset. `pmap` should only
    be used in situations where you know that the calculation will generally be slow.
  prefs: []
  type: TYPE_NORMAL
- en: Futures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `pmap`, Clojure takes care of all the thread management for you, which
    makes things easy. A lot of times, however, you need more control over your threads
    than what `pmap` provides. Clojure's **futures** do just this. They are a mechanism
    for spawning and waiting for new threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a situation where two expensive calculations are needed to perform
    a third operation, such as adding the two results together. In a single-threaded
    context, we would just write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Written this way, the call to `expensive-calc-1` needs to complete before `expensive-calc-2`
    can start. If the calculations could be run in parallel, we would cut the execution
    time nearly in half, in the best cases. Running the two threads in parallel creates
    some new problems, though. We need a way of coordinating the return values, especially
    since we don't know whether `expensive-calc-1` or `expensive-calc-2` will complete
    first. We need a way to wait for both before calling `+`.
  prefs: []
  type: TYPE_NORMAL
- en: Futures are designed for this type of situation. The `future` macro causes the
    code it contains to be run in a separate thread. It immediately returns a placeholder,
    which is a reference to the *future* result. When the code in the new thread has
    completed, the placeholder can be **dereferenced**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Clojure, dereferencing applies when a value is not immediately available
    and can only be accessed by taking an additional step. With a var or a let binding,
    the value is immediately available. There is no extra step to take. We just use
    it. With a future, as well as with reference types that we''ll see later in the
    chapter, we don''t know whether the value is available yet. Using the `deref`
    function with a future means that we are willing to wait for it to complete. `deref`
    is necessary because we need a way to indicate this special behavior. To make
    your code easier to read (and type), instead of writing `(deref my-future)`, you
    can just type `@my-future`. This is an example of a reader macro: Clojure immediately
    translates `@my-future` into `(deref my-future)` when it reads your code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With this in mind, we can rewrite the preceding expression. First, though,
    we''ll define an artificially slow function using the Java `Thread/sleep` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Thread/sleep` method is a convenient piece of Java interop that is useful
    for simulating long-running computations or input/output operations that take
    time. While it's good for experimenting, you rarely need it in production code.
  prefs: []
  type: TYPE_NORMAL
- en: 'With these functions, the original expression evaluates them one after the
    other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'No matter how many times this function is run, `expensive-calc-1` will always
    return before `expensive-calc-2`. With futures, this will change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'First of all, you''ll probably notice that this version is slightly faster.
    Sometimes `expensive-calc-1` returns first, sometimes `expensive-calc-2` wins
    the race. It doesn''t matter which one is faster: the final addition only happens
    when both are complete. This is the work of the `deref` function, which blocks
    the evaluation until the computation started by the corresponding call to `future`
    has returned.'
  prefs: []
  type: TYPE_NORMAL
- en: The `(deref c1)` or `(deref c2)` expressions can be replaced with `@c1` or `@c2`,
    thanks to the `@` reader macro.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: A Crowdsourced Spellchecker'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Have you ever typed a word into a search engine just to see whether you've spelled
    it correctly? In this exercise, we'll build a command-line tool that improves
    on this way of using the internet to verify spellings.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to be able to write out a command followed by several possible spellings
    for a word. The spelling tool will then query Wikipedia and return the word that
    received the most hits. We will use futures so that the different search queries
    can be run in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use Leiningen to create a new project using the `app` template. You can call
    it whatever you want. We''ll use `packt-clj.crowdspell` in our examples:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Go to the new directory that Leiningen created and modify the dependencies
    in the `project.clj` file. We''ll need three libraries: `org.clojure/tools.cli`
    for accepting user input, `clj-http` for making HTTP requests, and `org.clojure/data.json`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `:dependencies` map should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `src/packt_clj/` directory, create a `crowdspell` directory. We''ll
    use this directory for any namespaces we need to create for the project. Create
    a file there called `fetch.clj` and insert the following namespace definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All of the fetching and parsing of results will happen in this namespace. The
    `clj-http` library will help us to perform our web requests to the Wikipedia endpoint
    and `clojure.data.json` will help us to parse the JSON data that we get back.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'While you''re there, create an empty function definition for `get-best-word`.
    This will be the key interface of the application: given a list of words, `get-best-word`
    will return the best one based on the data retrieved from Wikipedia. All we know
    at this point is that it takes a language code and a list of words as an argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because Wikipedia uses a separate URL for each language, such as [https://ja.wikipedia.org/](https://ja.wikipedia.org/)
    or https://en.wikipedia.org/, we can use the language code parameter to internationalize
    our app.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `packt-clj/crowdspell` namespace, defined in `src/packt_clj/crowdspell.clj`,
    will be the entry point into the application. There should already be a `-main`
    function there, created using the `lein new` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `-main` function so that it calls `get-best-word`. This will also
    require updating the namespace declaration so that you'll have access to `clojure.tools.cli`
    and `packt-clj.crowdspell.fetch`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The namespace declaration should now look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `-main` function should look like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For now, we'll just hardcode English as the language code. At this point, the
    application would theoretically compile and run at the command line but would
    not do anything.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Back in `src/packt_clj/crowdspell/fetch.clj`, write a skeleton for a `word-search`
    function. This function will search for a single word. The `get-best-word` function
    will coordinate several concurrent HTTP requests using futures. Each request will
    be run with `word-search`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There's a `language-code` parameter because we want our application to be multilingual.
    We'll add that as a command-line parameter later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We want to use a `try` block here since our request might fail for any number
    of reasons. We''ve already made a design decision: the function will return a
    map containing, among other things, a `:status` code.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now it''s time to write the HTTP request itself. The `clj-http.client` library
    makes this fairly painless. We just have to make sure that we use the proper Wikipedia-specific
    parameters: `srsearch` is our search term, and `srlimit` tells the API that we
    only want one item. Only one item is necessary because the metadata in the response
    includes a field indicating how many total items were found. Since we are only
    interested in counting them, this is all we need. You can try the request in the
    REPL first if you like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all goes well, a map containing HTTP response, including all the headers,
    should fill your REPL. You should find a key that says `:status 200`, which means
    that the request was successful. Any status besides `200` means that something
    is wrong:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.4: REPL output of a successful HTTP request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.4: REPL output of a successful HTTP request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s add this request as a `let` binding inside the `try` block. The only
    change needed is to insert the two parameters: the word we''re searching for and
    the language. Start by making a `let` binding from the result of the HTTP request
    to the Wikipedia endpoint. We will need the entire request later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we just need to interpret the result of the HTTP request. There are really
    two steps: first, convert the raw JSON response into a Clojure map, then extract
    the data we''re looking for. The Wikipedia API provides a `totalhits` field that
    we can use to decide which word is the most popular. We can combine these two
    steps into a brief code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `json/read-str` does just that: it reads the body of the response and converts
    it into a map. The `:key-fn` option allows us to provide a function that will
    be called on all the keys. In nearly all cases, the `keyword` function is used
    here so that we can have the convenience of Clojure keywords.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All that's left is to grab the one piece of data that we need. The result map
    is a large, multiple-nested map, which is not a problem for `get-in`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we have the number of hits, we wrap all the data we''ll need for later
    in a map: the status, the number of hits, and the word itself:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We know the word from the original argument supplied to the function. We also
    know that the status is `:ok`: if the query resulted in an error, we would be
    in the catch `block` instead.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final function looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you test `word-search` in the REPL, you should see something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.5: The important data extracted from the HTTP request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.5: The important data extracted from the HTTP request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we turn to `get-best-word`. Its job is to make parallel calls to `word-search`.
    Futures are exactly what we need for that. Since the words are supplied as a list,
    the first step will be to call `word-search` inside a future for each of the words.
    This is remarkably straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The HTTP requests will run simultaneously and the responses become available
    as they complete. This expression will return a list of futures. We will need
    to dereference them before we can use them. Except for that difference, we can
    look at `results` as though it were a list of ordinary values. Clojure's `future`
    and `deref` function manage the asynchronicity for us.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step here will be to select the word with the most hits. We''ll use
    `reduce` with a pattern we introduced in *Chapter 5*, *Many to One: Reducing*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Obviously, dereferencing `@result-future` here is the first very important step.
    But once the value is dereferenced, all the data is available, and we can forget
    all about its asynchronous past.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The rest of the call to `reduce` follows the familiar pattern: we check whether
    the current item has a better score than `best-so-far`, and if so, it replaces
    `best-so-far`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make a very polished app, we would want to warn the user in case there were
    errors, but, for now, it will suffice to simply ignore the failed requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once we''ve found the best word, all that''s left is to extract the `:word`
    key from the best word. For that, we''ll use a threading macro, `->`, and `:word`.
    Altogether, that leaves us with this function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Test `get-best-word` in the REPL with some really bad spellings of "Clojure"
    alongside the correct one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It seems to work!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To make this into a useful application, we still need to package this behavior
    into a command-line utility. The `-main` function back in `src/packt_clj/crowdspell.clj`
    is almost ready, except that the language code parameter is still just hardcoded
    as `en`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `clojure.tools.cli` library will make it easy to add the language code
    as an optional parameter at the command line. The goal is to be able to compile
    our code to an uberjar and then type this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `clojure.tools.cli/parse-opts` function takes the `args` value from `-main`
    and a list of argument prefix descriptors. The best way to understand this is
    with an example, like our language code option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The nested vector is the configuration argument to `parse-opts`. `"-l"` and
    `"--language LANG"` define the short and long form of the command-line option.
    Remember that the long form of the option will be used, in keyword form, as the
    name of the argument in the nested `:options` map that `parse-opts` returns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next string is a documentation string that will be displayed if there is
    an error, for example, an unknown option prefix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After these first three items, there can be additional keyword-tagged parameters.
    There are a lot of possibilities here that we won't explore. `:default` is enough
    for our purposes here. If the user doesn't supply a `--language` option (or the
    shorter `-l` option), they will get results from the English-language Wikipedia
    output.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test the configuration of the command-line options, there''s no need to
    actually use the command line. `parse-opts` can be run in the `REPL` with a list
    of strings masquerading as command-line arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is useful because it shows us the structure of the map that is returned.
    To finalize the `-main` function, we just need to know how to extract the language
    option and the arguments from the map:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The call to `System/exit` guarantees that our program will exit immediately.
    Because we used `future`, the program otherwise would not exit until the threads
    created by `future` had terminated entirely.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And that should be all the code we need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before compiling, we can test our code in the `REPL` by simulating the command-line
    arguments in a list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To compile, simply run `lein uberjar` in the root directory of the project.
    Now we can finally test the entire application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All right, it works. But it's slow. Yes, the Java runtime takes a few seconds
    to get started and it's a problem for something that should be a fast, easy-to-use
    app. It's best to consider this version as a proof of concept. A ClojureScript
    version based on Node.js would have a much shorter startup time. Or this could
    be built as a web service. You'll learn about building an application server in
    *Chapter 14*, *HTTP with Ring*. For now, the fastest and easiest approach would
    be to use `fetch.clj` directly in the REPL, although this requirement might limit
    the number of potential customers.
  prefs: []
  type: TYPE_NORMAL
- en: In this exercise, we learned how to write a simple multithreaded application
    using Clojure futures. Futures are particularly well suited for situations where
    discreet tasks can be handed off to separate threads. Even more importantly, `future`,
    with `deref`, provides a way to coordinate the data as it returns from the separate
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Coordination
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Futures work well for cases like the `crowdspell` example. Work is assigned
    to a thread; the thread performs its task independently and returns a result to
    the initial thread. The coordination is in the gathering of the results: evaluation
    is blocked until all the futures have completed. Thanks to immutability, there
    is a guarantee that simultaneous threads won''t interfere with each other because
    nothing is shared.'
  prefs: []
  type: TYPE_NORMAL
- en: This simple model is effective precisely because it is simple. Sometimes, however,
    more coordination is necessary, especially when communication between threads
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a future, we fork, perform a computation, and return the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6: With a future, coordination occurs when the future is dereferenced'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.6: With a future, coordination occurs when the future is dereferenced'
  prefs: []
  type: TYPE_NORMAL
- en: 'Message sending is one way to communicate among threads. Now, we imagine three
    threads that send messages to one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7: Complex interactions between multiple threads'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.7: Complex interactions between multiple threads'
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement a communication model like this in Clojure, you could also use
    the `core.async` library, which is a sophisticated tool for creating channels
    between threads. The `core.async` library is widely used but would require its
    own chapter to cover it correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8: Threads referring to and modifying shared data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.8: Threads referring to and modifying shared data'
  prefs: []
  type: TYPE_NORMAL
- en: The fundamental challenge of concurrent programming stems from the fact that
    the timeline of a program is no longer linear. Threads in communication with each
    other do not know when they will receive new data or when the data they've sent
    will be processed on the receiving end. Unless the communication is carefully
    managed, accidents happen. If two threads try to update the same data simultaneously
    without coordination, the results become unpredictable. One update overwrites
    another. While a value is being updated, the original value is modified, and the
    update is suddenly obsolete. If more threads are involved, the interactions (and
    the possibilities for errors) are multiplied. In the `crowdspell` exercise, the
    futures coordinated the return value from the different threads. Instead of clobbering
    each other's data, the results were assembled into a coherent list that the rest
    of the program could use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure has several `reference types`: vars, atoms, agents, and refs. Before
    talking about each one separately, it might be good to think about what a *reference
    type* actually is. First of all, a reference type is not a data structure. In
    fact, you can use any of Clojure''s data structures with any of these reference
    types. Instead, a reference type sits between your code and your data and provides
    a particular way of referring to your data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It might help to visualize this relationship. The reference type as an interface
    allows your code to apply changes to the data and retrieve the current state of
    the data. Remember, the values that the reference type points to are still the
    familiar Clojure data types: integers, strings, vectors, maps, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9: Reference type: a way of referring to and interacting with a
    piece of data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.9: Reference type: a way of referring to and interacting with a piece
    of data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the time, when coding in Clojure, we don''t think about the difference
    between the name of a thing and thing itself. Consider this simple `let` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: What is `some-numbers`? Usually, we just say, or think, "it's a vector." Of
    course, it's really a symbol that points at a vector. The fact that it's in a
    `let` binding means that `some-numbers` will only point at `[3 12 -1 55]` inside
    that particular `let` expression. In other words, `let` defines a particular kind
    of pointing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now consider this `let` binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, `some-atomic-numbers` is still just a symbol. It points at an atom
    (we''ll explain what that means in a second), and the atom points at the vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10: The binding points at the atom, and the atom points at the
    value'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.10: The binding points at the atom, and the atom points at the value'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability means that values don't change. An integer remains an integer,
    and a vector remains equal to itself. Immutability does not mean that a symbol
    always points at the same value, though. Clojure's reference types are a way to
    manage certain kinds of change while continuing to use immutable data.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reference types is already very familiar to you by now: the var,
    which, among other roles, is how Clojure identifies functions. Up until now, we''ve
    treated the var as an immutable identity, and, for the most part, this is accurate.
    Generally, if you see `(def x 5)` in a program, that means that the value of `x`
    will not change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, at the REPL, you will quickly find that you can indeed redefine a
    var simply by calling `def` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'While this is fine when experimenting with the REPL, clobbering a var like
    this in a program would be extremely unusual. That said, the var reference type
    does provide the `alter-var-root` function, which is a more graceful way to update
    a var. It takes a function and updates the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you ever actually need to use this function, it will probably be to change
    some feature of your work environment. The point here is not to encourage you
    to start modifying vars, but rather to show how even vars have semantics for changing
    their values. `Vars` happen to be a reference type that strongly discourages change
    but does not prohibit it completely.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other reference types—atoms, agents, and refs—are designed to give you
    much finer control over how to manage change and they do this by controlling what
    they point at. In the preceding diagram, we showed a `let` binding, `some-atomic-numbers`,
    pointing at an atom containing a vector. Now we can complete the picture by showing
    how the atom might evolve as different functions are called on it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11: The atom points at different values over time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.11: The atom points at different values over time'
  prefs: []
  type: TYPE_NORMAL
- en: In this picture, the data (the vectors) is still immutable. The atom allows
    us to define some kind of identity that might have different values at different
    times. As we'll see, this turns out to be particularly useful in multithreaded
    programs, where one or more threads need to have access to stable identities in
    another thread.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are atoms, refs, and agents? Let's take a quick look at each of these
    reference types.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Atoms are the simplest and most commonly used reference type. They are also
    the only reference type that is currently available in ClojureScript, mostly due
    to the fact that the JavaScript runtime is single-threaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The life-cycle of an atom starts with an initial definition of the data with
    the `atom` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Just with like `future`, the underlying data can be accessed with `deref` (or
    the `@` reader macro):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing the data is done with `swap!`, which updates the atom by applying
    the function you supply to the current value that the atom points to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The `swap!` function doesn't assign a value to the atom. Instead, it applies
    a function. This way, if the value of the atom has changed since the last time
    we dereferenced it, the function will simply be applied to the new value, whatever
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see this in action. Here is the code we are going to execute in the
    REPL, once again using `Thread/sleep` to simulate some long-running task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'What''s going on here? The first future waits half a second before calling
    `swap!`. The second future executes right away, multiplying the current value
    of the atom, `6`, by `1000`. Now try dereferencing `integer-atom` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change the timing by modifying the durations of the `Thread/sleep` calls,
    the results change too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: When calling `swap!`, you can't be sure ahead of time what the value of the
    atom will be. But you know that your function will be called on whatever the value
    happens to be at that point in time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There is also a more rarely used `compare-and-set!` function that provides finer
    grained control. It takes an additional value, usually the current value of the
    atom, and will only modify the atom if it still matches that. In other words,
    if another thread has already done something to your atom, `compare-and-set!`
    will leave it alone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Concept: Retries'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changes to an atom are not instantaneous. Remember, we're sending a function
    to the atom. Depending on the work being done, some functions may take more time
    to complete. In a busy environment, it might mean that several threads try to
    make changes to an atom at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a naïve implementation of an atom being modified
    by two threads, `Thread A` and `Thread B`. Even though they are just multiplying
    the value of the atom by 3 or by 4, let''s imagine that this operation takes a
    few milliseconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12: Overlapping updates to a naive implementation of a Clojure
    atom'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.12: Overlapping updates to a naive implementation of a Clojure atom'
  prefs: []
  type: TYPE_NORMAL
- en: The initial value of the atom is 5\. Then `Thread A` intervenes to multiply
    by 3\. As it is starting to perform its operation, `Thread B` starts as well.
    The input to the function of `Thread B`'s is still `5`. The function of `Thread
    A` completes, and the value of the atom is set to `15`. Then Thread B's function
    completes its calculation without having seen the new value of the atom. This
    result is based on a "stale" version of the initial value, but it overwrites the
    result of the first calculation. In the end, it's as if Thread A's update had
    never happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure does not want this to happen to you! Here''s what would take place
    with a real Clojure atom:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13: A real Clojure atom retries when a conflict occurs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.13: A real Clojure atom retries when a conflict occurs'
  prefs: []
  type: TYPE_NORMAL
- en: This time, when the atom tries to apply the update from `Thread B`, it detects
    that the underlying value has changed and reapplies the function with the new
    value.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe this in the REPL, using one slow-acting (long-sleeping) function
    and a quick function in two separate threads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, we can consider that both calls to `swap!` execute at approximately
    the same time, when the value of `integer-atom` is still 5\. By dereferencing
    `integer-atom` at the end of the `do` block, we can see that the atom hasn't been
    updated yet. Yet, a couple of seconds later, the results indicate that both functions
    were applied, and in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: Refs and Software Transactional Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Refs are Clojure's most sophisticated reference type. They are why the Clojure
    language, when it was first introduced, became known for its advanced concurrency
    management and, more specifically, for STM. STM is an abstraction that guarantees
    that changes can be made to multiple *refs* in a safe, coordinated manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Behind STM, there is a fundamental concept: the transaction. If you have worked
    with database transactions, you are already familiar with the basic idea. A database
    transaction might consist of several related operations. If, during the transaction,
    any individual operation fails, the entire transaction is "rolled back" to the
    initial state, as if nothing had happened. Transactions are a way of avoiding
    invalid states where only part of an action is performed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 13*, *Database Interaction and the Application Layer*, we will take
    a closer look at database transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The classic example for explaining database transactions also applies here:
    imagine a bank transaction where money moves from one account to another. To do
    this, at least two actions need to occur: an amount of money is removed from one
    account and added to another. If for some reason one of those operations fails,
    we don''t want the other to succeed. If the second account was deleted after the
    funds are debited from the first account, those funds should return to the original
    account; otherwise, they would vanish into thin air. In a database transaction,
    if the second step is not completed, the first step is canceled as well. This
    way, the system returns automatically to a known, correct state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clojure''s software transactional memory is conceptually similar to database
    transactions but works with data inside your program. A transaction in Clojure
    is managed by the `dosync` macro, which creates a space in which actions on refs
    will be coordinated. Imagine that the preceding banking scenario was implemented
    using Clojure reference types instead of a database. If you are drawing from one
    bank account ref and depositing to another, then both operations will succeed
    or the entire `dosync` block will be retried. Like database transactions, the
    purpose of refs is to make sure that your system remains in a coherent state.
    This is one of the first key differences between refs and atoms: unlike atoms,
    refs can provide coordination. When two atoms are updated, there is no such guarantee.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refs actually offer even more fine-grained control over how they are modified.
    There are several functions that can update a ref, each with different semantics.
    The two most common are `alter` and `commute`. `alter` is the most restrictive:
    if the underlying value has changed outside the `dosync` block, then the entire
    transaction will be retried. The `commute` function can be used when this kind
    of guarantee is not necessary. When adding or subtracting from a total, for example,
    the order of operations does not affect the result, so these operations can accept
    changes to the underlying value without a retry. And when accessing the data,
    the `ensure` function can be used instead of `deref`. In this case, if a ref that
    is being read from has changed, a retry will be triggered.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: Stock Trading'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will observe refs in the REPL to get a better sense of
    their behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your current project is a prototype for a stock trading application. You need
    to write a function that will simulate a client buying some numbers of stocks
    at a given price. For the purchase to succeed, four things must happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The client account is debited for the amount of the transaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The broker account is credited for the same amount.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The broker stock account (for that particular stock) is debited, that is, there
    are now *n* fewer stocks in that account.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The client stock account (for that particular stock) is credited: there are
    now *n* more stocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, if the price of the stock changes while this is happening, the entire
    purchase must be invalidated and retried.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, since this is a simulation, we will use `Thread/sleep` to slow the functions
    down:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the REPL, set up some refs for the five different values we''ll need. The
    first three will have integer values, representing account balances in whatever
    currency is being used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because the client and the broker would probably own stocks for various firms,
    we''ll use maps for that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The client starts off with zero `Acme Corp` stocks and a currency balance of
    `2100` in her account. The broker has `50` stocks and a balance of `10000`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a function that describes a complete transaction:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All our code here is wrapped in a `dosync` macro. Beyond that, the code is
    quite simple. Even in a `dosync` environment, it is necessary to dereference other
    refs when accessing their value, which is why we write `@acme-corp-share-price`.
    The syntax for updating the `client-stocks` and `broker-stocks` maps might look
    a little bit strange. The second argument to `alter` is always a function, and
    in this case it''s the `update` function we''ve already used for updating maps.
    The remaining arguments to `alter` will be simply passed on to `update`, after
    the initial argument, which will be the map contained in the ref. All told, the
    final call to `update` will be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Because `update` behaves in the same way as `alter` and passes any additional
    arguments on to the provided function, our calls to `alter` could be rewritten
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And likewise, the previous lines could use the same syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These forms are more concise and might be easier to read for experienced Clojure
    programmers. The forms using anonymous functions have the advantage of explicitly
    reminding us that we are providing functions as well as clearly laying out the
    order of the arguments.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s try our new function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `dosync` block returns the last value, which, in this case, is the in-transaction
    value of `broker-account`. That might be useful sometimes, but the data we''re
    really interested in is in the refs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we see that the balances of the two accounts have been correctly updated
    and that one stock has moved from `broker-stocks` to `client-stocks`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This means that our best-case scenario works: none of the refs are changed
    outside of the current thread and the transactions are instantaneous. In these
    conditions, atoms would work just as well. Now it''s time to simulate a more demanding
    environment for the purchase!'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Modify `buy-acme-corp-shares` to make the transaction slower and print some
    information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With `Thread/sleep`, the transaction will now last one second.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Reset all the accounts to their initial values. To make this easier, let''s
    write a quick reset function using the `ref-set` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All the accounts and the stock price should now be back at their initial values.
    This will make it easier to observe the behavior of the function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use two separate threads to change the client''s account during the transaction.
    To do this, we''ll use `future` and set a shorter wait time to the thread by changing
    `client-account`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that the `println` message appears twice. What happened? Let''s look
    at the values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Both transactions were correctly recorded: +500 and -22\. Here''s what happened:
    first, `buy-acme-corp-shares` tried to complete the transaction but when it was
    time to write the new account balance to `client-account`, the underlying value
    had changed due to the deposit from the other thread. Without this, `buy-acme-corp-shares`
    would have overwritten the account balance, ignoring the recent deposit. The client
    would not have been pleased.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Simulate a busy broker account. The broker account is probably much busier
    than the client''s account. Let''s add more transactions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Dereference the atoms to see their final values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'More changes to the refs cause more restarts, which we can see because the
    `Let''s buy 1 stock(s) at 22 per stock` message is printed three times. Each modification
    of an account causes the entire transaction to be retried. This is what atoms
    cannot do: with refs inside a `dosync` block, a change to any of the refs causes
    the entire block to restart.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This exercise shows the basics of using refs to simplify the sharing of data
    across threads. Obviously, real-life uses would generally be much more complex,
    but even at this scale we can see some of the difficulties posed by concurrency
    and how Clojure provides tools for dealing with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few things that we can observe. Like with atoms, the retry strategy
    used by refs prevents near-simultaneous operations from interfering with one another.
    But refs go further by making sure that even if one ref causes a retry, all the
    updates in the transaction will be retried. This guarantees data coherence. It
    also means that we give up some control of when changes to refs will be made.
    As programmers, we are used to thinking in a very linear fashion: "do this, then
    do that." Multithreaded applications break this way of thinking. Clojure''s reference
    types, and refs in particular, can help us write better code, especially if we
    learn to think less in terms of the strict order of operations and more in terms
    of the correctness and coherence of the operations.'
  prefs: []
  type: TYPE_NORMAL
- en: More Cohesion with refs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous example, STM helped us to make sure that the updates were coherent:
    the buyer had less money in her account, but more stocks; the seller had more
    money, but fewer stocks. If any one of those four changes had failed, the system
    would have returned to the previous valid state. Either way, everyone ends up
    with the correct balances on their accounts. There is, however, one possibility
    we didn''t consider. What if the price of the stock changes during the transaction?
    Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The balance on the client's account indicates that the purchase price was 22\.
    The sequence of events suggests that the client got a good deal. While `buy-acme-corp-shares`
    was waiting for 1,000 milliseconds, in the second future, the stock price was
    changed to 32\. When the purchase was finally complete, the price was no longer
    22 but 32\. Why didn't the refs protect us from this?
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem here is that the `buy-acme-corp-shares` function consults the value
    of the `acme-corp-share-price` atom but does not do anything with it. As a result,
    `dosync` does not track the changes made to that ref. In the next exercise, we''ll
    explore two different solutions: the `ensure` function and a clever way to use
    `alter`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: Keeping up with the Stock Price'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initial prototype for the stock purchase function seems to be working but
    the team has realized that it does not react correctly to variations in the stock
    price that occur while the transaction is completing. You've been asked to suggest
    some solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In your REPL, use the same environment as in the previous exercise. If necessary,
    recreate the same five refs and make sure that the `reset-accounts` function is
    defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `buy-acme-corp-shares`, use `ensure` to dereference `acme-corps-stock-price`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the same transaction as before. We''ll add an extra `println` statement
    to see when the share price updates occur:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There are two noteworthy things in this output: `Raising share price…` was
    printed 3 times and the client account balance is still only down by 22\. What
    happened?'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As soon as `ensure` was called in `buy-acme-corp-shares`, the value of `acme-corp-share-price`
    was frozen until the `dosync` block had completed. The second `dosync` macro then
    kept retrying until the first had completed. When `buy-acme-corp-shares` had terminated,
    `acme-corp-share-price` could finally be raised.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At the very instant that `buy-acme-corp-shares` purchased the shares, the price
    was still 22\. Data coherence was thus maintained. There is, however, a problem.
    In the real world, a single buyer cannot force the rest of the stock market to
    wait for a purchase to go through. This solution is correct in a way, but in this
    scenario it would not work.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `alter` to trigger a retry. This time, we''ll go back to `deref` for accessing
    the current share price. We''ll also call `alter` on `acme-corp-share-price` to
    trigger a retry if that ref has changed. You might think "we can''t change the
    share price!" You''re right, of course, but our call to `alter` won''t actually
    do anything, since we will only provide the `identity` function as an argument.
    We call `alter`, but just as a way to say "stay the way you are":'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s see what happens:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, `Let''s buy 1 stock(s)…` is printed twice, with two different prices.
    `Raising share price…` is printed only once. The share price is changed during
    the first call to `buy-acme-corp-shares`. Because of the change, a retry is triggered,
    now with the correct share price. The purchase finally completes, with the correct
    price:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This exercise demonstrates the power and the subtlety of Clojure's STM. Depending
    on the problem you need to solve and on the environment you're working in, you
    will need retries to happen in slightly different circumstances. In this example,
    it was obvious that we could not ask the stock market to wait even 1 second for
    our transaction to complete. Refs give you the ability to precisely define the
    retry behavior that you need. (In addition to `alter` and `ref-set`, there is
    `commute`, which provides yet another set of semantics for updating refs when
    less control is needed.) And of course, this degree of control also requires careful
    thought about the relationships between refs.
  prefs: []
  type: TYPE_NORMAL
- en: Agents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary difference between agents and the other reference types is that,
    while updates to atoms and refs are `synchronous`, updates to agents are `asynchronous`.
    Changes made to an agent are sent to a queue, a waiting list of changes, and the
    functions are run in a separate thread. Unlike refs and atoms, the calling thread
    is not blocked while waiting for the action to complete. So, while agents provide
    far less control over updates than refs, they do not slow down operations with
    retries. In atoms and refs, retries are necessary to solve the problem of simultaneous
    mutations; in agents, the same problem is solved by giving up on simultaneity
    and simply executing incoming functions in the order they are received.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can observe the asynchronous nature of an agent by making changes that take
    a few seconds to complete, thanks to `Thread/sleep` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the agent, setting its value to `5`. Then we `send` two identical
    modifications to increment the agent's value after 5 seconds. If we quickly type
    `@integer-agent` (or `(deref`
  prefs: []
  type: TYPE_NORMAL
- en: '`integer-agent)`, but that takes more time), we see that the value is still
    `5`. If we wait a little bit longer and type `@integer-agent` again, we see that
    the value has moved to `6`. And a few seconds later, it increments again to `7`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we replace the agent in the preceding example with an atom (and use `swap!`
    instead of `send`), the final result is the same but we are forced to wait for
    the operation to complete before we regain control of the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If you try this in your REPL, you will see that the REPL prompt is blocked for
    5 seconds after each call to `swap!`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because they do not block, there are some situations where agents are preferable
    to atoms or refs. For example, suppose your main application divides a processor-intensive
    task into several parts that can be passed to separate threads. While these threads
    are working, you want to present a progress bar to the user. When a thread accomplishes
    one unit of work, it increments a counter in an agent. The advantage of an asynchronous
    agent is that this would not slow the worker thread down: control returns immediately
    to the thread, which can start working again right away, and the agent can handle
    the update on its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14: The worker threads send progress updates to the agent'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.14: The worker threads send progress updates to the agent'
  prefs: []
  type: TYPE_NORMAL
- en: Like refs and unlink atoms, agents also benefit from STM. Inside a `dosync`
    block, changes made to several agents benefit from the same retry semantics as
    refs. Because updates to agents are asynchronous, on the output side they do not
    provide as much control as refs, but they are less prone to deadlock from endless
    retries in very busy systems.
  prefs: []
  type: TYPE_NORMAL
- en: Atoms in ClojureScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Vars and atoms are the only reference types available in ClojureScript. Even
    though JavaScript runtimes are not multithreaded, code execution is often non-linear.
    In the browser, a single-page application needs to be able to handle events that
    can come from every link or input, or from actions such as scrolling and hovering.
    Application state needs to be shared by the code triggered by these events, and
    atoms turn out to be a very good choice. (This is fortunate, since they are the
    only choice.)
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter will focus on atoms in the browser. The odds are that
    your first real-life experience of concurrency in Clojure won't be a complex multithreaded
    JVM application. There's a good chance that you'll take your first Clojure concurrency
    steps in a browser-based ClojureScript program. Many of the best-known ClojureScript
    frameworks for building browser applications, such as Reagent, Re-frame, and Om,
    use atoms to manage state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.05: Rock, Scissors, Paper'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to implement the famous Rock, Scissors, Paper
    game in ClojureScript. The real game is played between two people who count to
    three and then simultaneously make a hand gesture, either a "rock," "scissors,"
    or "paper." Each of the three choices can defeat one of the other two and be defeated
    by the other. Thus, "rock crushes scissors," "scissors cut paper," and "paper
    wraps rock". If both players choose the same object, it's a draw and they play
    again.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command-line prompt, create a new `figwheel` project using the following
    `Leiningen` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Move to the `packt-clj.rock-scissors-paper/` directory and type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few seconds, your browser should open to the default Figwheel page:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.15: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_15.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.15: A fresh ClojureScript project waiting for your code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Open `packt-clj.rock-scissors-paper/src/packt_clj/rock_scissors_paper/core.cljs`
    and get ready to write some code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s start by designing the underlying data. This is a very simple game,
    so it won''t take much. We need to keep track of the computer''s choice (rock,
    scissors, or paper) and the user''s choice. We also need to have a game state,
    which will be one of three states: `:setup` (the game hasn''t started yet), `:waiting`
    (waiting for the user to play), and `:complete` (we''ll show who won and offer
    to play again).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the supplied `app-state` definition with the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We also want to make this our own app, so let's update some of the function
    names. Rename the `hello-world` component as `rock-scissors-paper`, for example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All of the game logic will go in a `rock-paper-scissors` component. For now,
    we''ll just have it display some text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'While we''re there, we can change the end of the file slightly to use the pattern
    that we used in *Chapter 9*, *Host Platform interoperability with Java and JavaScript*:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we''ll define the game logic itself. We''ll try to have this part of the
    program not be dependent on ClojureScript. The first function will determine the
    computer''s choice of rock, paper, or scissors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only slightly complex problem is translating the "rock crushes scissors"
    rules into code. Of course, we could just write a long `cond` structure, but since
    this is Clojure, so we''ll use a data structure instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `resolutions` map, the top-level keys correspond to the human player's
    choice. Each item contains two possible outcomes, based on the two non-tie choices
    the computer might make.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That means that if the player chooses `:rock` and the computer chooses `:scissors`,
    we can get the result like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This is how we''ll write our `resolve-game` function. Checking for ties is
    easy with a simple equality check:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also want to tell the user why they won or lost by providing a message such
    as "Rock crushes scissors." These messages don''t need to mention who won, so
    we only need associate pairs of objects with a message. `:rock` and `:paper` in
    any order should result in `Paper wraps rock`. Since order isn''t important, `sets`
    might be a good choice. We can use the sets as map keys, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Most of the time we use keywords as map keys, to the point that we forget sometimes
    that more complex data structures can also be used. This way, it doesn''t matter
    if we write the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can also write the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s wrap this logic into a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `hash-set` builds the set to be used to look for the appropriate message.
    The `a` and `b` parameters can be, interchangeably, the player's choice or the
    computer's choice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'At this point, a game can be resolved with two function calls: one to know
    who won, the other to know why. Here, the player chooses `:scissors` and defeats
    the computer, who unwisely chose `:paper`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to convert our gameplay into views. Let''s break the game
    view out into its own component, which we''ll call `game-view`. There are only
    three game states, so we can get away with a `case` expression. We''ll start with
    just placeholders:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To see the output from this component, we can plug it into the `(rock-scissors-paper)`
    function we defined earlier:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, the `game-view` component just shows some different markups
    depending on the game state, which is stuck at `:setup` because there is no code
    to make anything happen yet. Still, it''s a good idea to make sure that everything
    is working as expected. The key here is how `app-state` is dereferenced using
    `rum/react`. The `rum` library adds a lot of built-in behavior that goes beyond
    just dereferencing. For now, though, we can think of `rum/react` as a fancy, framework-specific
    version of `deref`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.16: We have a start screen but no gameplay yet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.16: We have a start screen but no gameplay yet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To move on to the next game state, something needs to happen when the player
    clicks on `Start`. We need a function that will start the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To start a new game, we need to do two things to `app-state`: set `:game-state`
    to `:waiting` and set `:computer-choice` to the output from our `computer-choice`
    function. It''s also probably good practice to clean up the `:player-choice` field
    as well, since it is no longer valid. Our `start-game` function can look like
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice that we''re using `swap!`. Since `app-state` is a real atom, this is
    how we have to interact with it, by providing a function. If we wanted to be more
    concise, our call to `swap!` could be rewritten like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `game-view` component, we can now add `start-game` as a click handler
    in both the `:setup` and `:complete` phases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s check this new behavior. If you click on `Start`, you should now see
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.17: Starting the Rock, Paper, Scissors application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_17.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.17: Starting the Rock, Paper, Scissors application'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we need handlers for each of the choices. Since each handler will do essentially
    the same thing, just with a different value, let''s write a function that returns
    a function using that value. We''ll call it `player-choice`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The changes made to `app-state` here move the `:game-state` to the next phase
    and add in the `choice` parameter as a means of closure for the anonymous function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Instead of writing three separate handlers, we can just call these functions
    in the view. Now our `game-view` component looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that with the `start-game` handler, we supply the function itself, without
    parentheses. That's because `start-game` itself is the handler. With `player-choice`,
    we call the function when defining the view; it isn't the handler, instead it
    returns an anonymous handler, which is what will actually be called when the user
    clicks the link.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, when clicking on `Rock`, `Scissors`, or `Paper`, you should see the final
    screen:![Figure 12.18: Final screen of Rock, Paper, Scissors'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14502_12_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.18: Final screen of Rock, Paper, Scissors'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The last step is to display the results. Since this is more complex than the
    other views, it''s worth breaking it out into a new component, which we''ll call
    `result-view`. Let''s look at the code and then we''ll go through the logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We start off with some `let` bindings for the player choice, the computer choice,
    and the result, which is derived from the two choices.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Everything after that takes place in a single `:div` element. This is necessary
    because in React, and thus in all the React-based ClojureScript frameworks, a
    component can only return a single HTML element. Without this wrapping `:div`
    element, we would get an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After displaying both of the choices, using `name` to convert the keywords to
    strings, we get to the actual results. In case of a tie, there is not much to
    display, so we test for that first. The `result-messages` function provides a
    nice summary of what happened and then we can finally tell the player whether
    they won or lost, depending on the value of `result`. At the end, we've placed
    the "`Play again?`" link that was previously in the `game-view` component.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we just need to insert the `result-view` component into the `game-view`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The complete code for this exercise is available on the book''s GitHub repository:
    [https://packt.live/2uoDolF](https://packt.live/2uoDolF).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now you should be able to play the game:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.19: Prompt to play again'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.19: Prompt to play again'
  prefs: []
  type: TYPE_NORMAL
- en: You won! By building this simple game, you've learned a basic template for stateful
    ClojureScript applications, using one of Clojure's reference types. Even though
    the JavaScript runtime is single-threaded, atoms are useful here because they
    allow event handlers to interact with shared program state in a safer way than
    simply overwriting data.
  prefs: []
  type: TYPE_NORMAL
- en: Watchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous exercise, we mentioned that when using the `Rum` library, writing
    `(rum/react app-state)` basically dereferences the `app-state` atom. There is,
    however, a little bit more going on, obviously, since otherwise we would use `deref`
    instead. In ClojureScript libraries such as Rum, atoms often serve as the application''s
    "single source of truth." Rum and the Om framework both use plain atoms; Reagent
    and the popular `Re-frame` library, which is based on Reagent, both use a special
    `atom` implementation sometimes referred to as a "ratom" (from **r/atom**, if
    **r** is a namespace alias for Reagent). You''ll learn more about Reagent in *Chapter
    15*, *The Front End: A ClojureScript UI*.'
  prefs: []
  type: TYPE_NORMAL
- en: Why are atoms so popular for ClojureScript libraries? First of all, atoms help
    manage concurrent updates. When there is a single source of truth, that means
    that many parts of the program may interfere with each other when they all try
    to update the same data source. As we've already seen, atoms, with their built-in
    retry logic, help avoid many of these issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beyond this, however, Clojure (and ClojureScript) atoms have another important
    feature that makes them particularly useful as the single source of truth in a
    browser-based application. A common pattern in modern JavaScript architectures
    goes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An event occurs and is handled by the application. In the previous exercise,
    these were the click handlers. There are, of course, many other kinds of events
    that might occur: scrolling events, timeouts, successful (or failed) network requests,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In response to the event, the application state is modified. In the Rock, Paper,
    Scissors game, the player made their choice, and this was reflected in `app-state`,
    via `swap!`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the application reacts to this change in the application state.
    Views that reference the application state are updated automatically. Advancing
    the `:game-state` field in `app-state` caused the different phases of the game
    to be displayed. Once the appropriate views were defined, the framework seemed
    to take care of making sure that the views were updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When one part of the application updates the application states, the other
    parts respond. Atoms help with this because they accept "watcher" functions that
    are called when the atom changes. To "watch" an atom, we use the `add-watch` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We've provided an anonymous function that simply prints out a message when the
    atom is changed. When adding a `watch` function, a key such as `:watcher-1` is
    required so that, later, that particular watcher can be identified for removal
    by the `remove-watch` function. That key is then available as the first argument
    to the watcher function, `k` in this example. The `a` argument is the atom itself.
    Often, these two arguments will not be used; in most cases, what you really need
    is in the `old` and `new` arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous exercise, we defined our components using the `rum/reactive`
    mixin as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '`rum/reactive` then adds watchers as appropriate so that the component knows
    when to update. This way, multiple components can reference the same data in `app-state`;
    when the data changes, the components are watching, and they can update accordingly.
    This pattern happens to mesh nicely with some of the common patterns used with
    React.js, which is why it is seen so often in ClojureScript libraries and applications.
    Generally, when using these frameworks, you will not need to define your own watchers.
    The frameworks take care of that for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Validators are another feature of atoms that you could actually use in your
    ClojureScript app. Like watchers, validators are functions that can be added to
    Clojure reference types. When an atom, for example, is about to be modified by
    a call to `swap!`, if any validators have been set on the atom, they will be called.
    If any of them do not return `true`, the update will fail and an exception (or
    an error, if this is on the JavaScript runtime) will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.20: Execution error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.20: Execution error'
  prefs: []
  type: TYPE_NORMAL
- en: When an update fails validation, an exception is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Here, the validator enforces a "less than 6" rule on `integer-atom`. The call
    to `swap!` tries to increment the value to `6` but an exception is thrown instead.
    In the next exercise, we will incorporate some validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.06: One, Two, Three… "Rock!"'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Your in-browser Rock, Paper, Scissors game is starting to generate some interest.
    You''ve created a start-up around it and now your investors want an improved version
    that is more like the original. Your plan is to introduce a countdown before the
    user can make their choice, just like in the original version of the game, where
    the two players coordinate their moves before revealing their choices: "One, two,
    three…Rock!"'
  prefs: []
  type: TYPE_NORMAL
- en: To do this, we'll use JavaScript intervals to provide some timing for the countdown.
    In the browser, intervals are how JavaScript developers can cause a function to
    be called repeatedly after a certain number of milliseconds. We will use intervals
    to simulate a ticking clock, where each tick of the clock will be an event that
    the application reacts to. This will show how application state can be used to
    coordinate and react to events.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This exercise builds on your code from the previous exercise. Either use the
    same project or make a copy.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the command-line prompt, start the ClojureScript REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A browser window should open, inviting you to play a game of Rock, Paper, Scissors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a `:countdown` field to the `app-state` atom:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a validator to the `app-state` to make sure that the `:game-state` field
    always contains a game phase keyword and that the countdown never goes beyond
    3 or below 0:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The greater-than and less-than family of functions all take more than two arguments.
    This is a convenient way of testing whether a value is between two other values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Most of the improvements we want to make are going to affect the `:waiting`
    phase of the game. Let''s make a dedicated view, which we''ll call the `choices-view`
    function. It will show two things: the countdown and the list of choices.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As a first step, set up the view with the same list of choices as before:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the same time, add this new view to `game-view`, instead of the previous
    list corresponding to the `:waiting` game state:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, the game should still work exactly as before.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Before the countdown reaches zero, the links in the list of choices should
    be inactive to prevent the player from clicking too soon. Since each link needs
    to handle two different states, it makes sense to encapsulate that behavior in
    a component, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Remember to place `choice-link-view` before `choices-view` in the source file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first two arguments simply supply the keyword and the text label necessary
    for building the links, as before. The `countdown` argument, however, will allow
    us to determine what should be displayed. If the countdown has reached zero, we
    display the link. If not, we simply display the label.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to update `choices-view` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When you try to play the game now, if you click on `Start`, you should see
    this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.21: Options available on clicking Start'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_21.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.21: Options available on clicking Start'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also want to display the countdown in this view. Let''s make a new component
    for that too so that we can add a little bit of display logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And this view can be called from `choices-view` as well:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you try to play the game at this point, you should see `3` displayed above
    the inactive links:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.22: The countdown is there but it''s not moving yet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B14502_12_22.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.22: The countdown is there but it''s not moving yet'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For the timing of the countdown, we''ll use `setInterval`, which means that
    we need some JavaScript interop. This function will cause the `:countdown` field
    to decrement every second:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `setInterval` function returns an identifier that we''ll need later for
    canceling the interval. Each time a new game starts, we need to start the interval
    and record its identifier. These things can be done by the `start-game` function,
    which we''ll update. (For this reason, `start-countdown` will need to be placed
    before the `start-game` function in your source file.):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `interval` goes into the app-state for later use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We know that we don't want the countdown to go below 0\. We also don't want
    to start a new interval in a game without canceling the previous interval. After
    a few games, we would end up with many intervals all trying to update the `:countdown`
    field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stopping the interval is easy enough with the `clearInterval` function. But
    how do we know when it should be called? One solution would be to add a check
    in the function we passed to `setInterval` in the `start-countdown` function.
    For this exercise, though, we''ll use a watcher:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We won't ever remove this watcher, but we still need to give it an identifier,
    for which we use a descriptive keyword. The interesting part of this call to `add-watch`
    is the anonymous function we provide. This function will be called every time
    a change occurs in the `app-state` atom. Most of the time, this function will
    do nothing. The exception, of course, is when the countdown is about to go to
    zero. In that case, `clearInterval` is called with the interval identifier stored
    in the atom.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now the countdown should work as planned. When it reaches zero, the message
    changes to `Go!` and the links become active:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.23: A successful countdown'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.23: A successful countdown'
  prefs: []
  type: TYPE_NORMAL
- en: This exercise showed us how watchers and validators work. Remember, in Clojure
    they can be used on all the different kinds of reference types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: A DOM Whack-a-mole Game'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the amazing success of your Rock, Paper, Scissors browser game, you've
    decided to create an even more ambitious product, based on the classic Whack-a-mole
    game. Whack-a-mole is an early arcade game. Moles pop up at random from several
    holes in a table. The player holds a mallet and tries to whack the moles as soon
    as they appear. When hit, the mole disappears back into its hole until it pops
    back up again.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your version of Whack-a-mole will use DOM elements in a web browser. It might
    look something like this (if you know some CSS, you''re free to make it look a
    little better):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24: Before the game starts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.24: Before the game starts'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the player clicks on the `Click to play!` button, the clock starts and
    the moles, who are actually just HTML `<div>` elements, start to randomly activate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25: Click on the moles!'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14502_12_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.25: Click on the moles!'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if the player clicks on a mole, it goes back to the waiting state
    and a point is added to the player's score. The game stops after a fixed number
    of seconds, probably 20 or so.
  prefs: []
  type: TYPE_NORMAL
- en: 'The behavior of the moles follows these rules: Only two moles are visible at
    a time. The moles to be made visible are selected randomly. A mole is visible
    for a fixed duration (2 or 3 seconds, probably) and reverts to the hidden state
    after that time if the player has not clicked on it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build this game, you should take these basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the same basic ClojureScript and Rum setup used in the Rock, Paper, Scissors
    exercises.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As in the last exercise, use `setInterval` to count down the seconds after the
    game starts. For more fluidity, it's probably best to use an interval smaller
    than 1 second. 100 milliseconds is probably about right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use multiple atoms for the various counters that you''ll need: the countdown
    clock (the interval itself), the number of milliseconds remaining in the game,
    the game state (`:waiting` or `:playing`), and a vector of moles.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The moles themselves should have two values: their status (`:waiting` or `:live`)
    and the number of remaining milliseconds remaining if they are in the `:live`
    state. These values could be contained in a map or a two-item vector tuple.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write event handlers for clicks on the `Start` button and on the active moles.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you know some CSS, feel free to make the game look better by adding some
    definitions to `resources/public/css/style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The solution for this activity can be found on page 738.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Concurrency, by its very nature, is a complex problem. While it''s impossible
    to cover all the techniques you might need, hopefully, this chapter will provide
    you with the tools to get started. We covered the usage of `pmap` and `future`
    for using multiple threads. We also saw Clojure''s reference types: var, atoms,
    agents, and refs. We used atoms to manage state in a browser-based ClojureScript
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: For each of these topics, there is a lot more that can be said. What you learn
    further down the road will depend on the kinds of problems you need to solve.
    Concurrency is one of the areas where the problems will be more diverse than almost
    any other. Familiarity with Clojure's basic approach to these questions will start
    you in the right direction when you search for solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take another big step toward real-world Clojure
    by learning how to interact with databases.
  prefs: []
  type: TYPE_NORMAL
