- en: JSON Processing with JSON-P and JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JSON**, or the **JavaScript Object Notation**, is a human-readable data interchange
    format. As its name implies, JSON is derived from JavaScript. Java EE 7 introduced
    **JSON-P**, the Java API for JSON processing. Java EE 8 introduced an additional
    JSON API, namely, the Java API for **JSON Binding** (**JSON-B**). In this chapter,
    we will cover both JSON-P and JSON-B.'
  prefs: []
  type: TYPE_NORMAL
- en: JSON-P includes two APIs for processing JSON, the **Model API** and the **Streaming
    API**, both of which will be covered in this chapter. JSON-B transparently populates
    Java objects from JSON strings, as well as easily generating JSON strings from
    Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JSON-P Model API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating JSON data with the Model API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON data with the Model API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The JSON-P Streaming API:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating JSON data with the Streaming API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing JSON data with the Streaming API
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Populating Java objects from JSON with JSON-B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generating JSON strings from Java objects with JSON-B
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The JSON-P Model API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSON-P Model API allows us to generate an in-memory representation of a
    JSON object. This API is more flexible than the Streaming API discussed later
    in this chapter, however, it is slower and requires more memory, which can be
    a concern when handling large volumes of data.
  prefs: []
  type: TYPE_NORMAL
- en: Generating JSON data with the Model API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the heart of the JSON-P Model API is the `JsonObjectBuilder` class. This
    class has several overloaded `add()` methods, which can be used to add properties
    and their corresponding values to generated JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample illustrates how to generate JSON data using the Model
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: As can be seen in the preceding example, we generate an instance of `JsonObject`
    by invoking the `add()` method on an instance of `JsonObjectBuilder`. In the preceding
    example, we see how we can add `String` values to our `JsonObject` by invoking
    the `add()` method on `JsonObjectBuilder`. The first parameter of the `add()`
    method is the property name of the generated JSON object, and the second parameter
    corresponds to the value of said property. The return value of the `add()` method
    is another instance of `JsonObjectBuilder`, therefore, invocations to the `add()`
    method can be chained, as shown in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding example is a CDI-named bean corresponding to a larger JSF application.
    Other parts of the application are not shown because they are not relevant to
    the discussion. The complete sample application can be obtained as part of this
    book's example code download.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have added all the desired properties, we need to invoke the `build()`
    method of `JsonObjectBuilder`, which returns an instance of a class implementing
    the `JsonObject` interface.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, we will want to generate a `String` representation of the JSON
    object we created so that it can be processed by another process or service. We
    can do this by creating an instance of a class implementing the `JsonWriter` interface
    by invoking the static `createWriter()` method of the `Json` class and passing
    an instance of `StringWriter` as its sole parameter. Once we have an instance
    of the `JsonWriter` implementation, we need to invoke its `writeObject()` method,
    passing our `JsonObject` instance as its sole parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our `StringWriter` instance will have the `String` representation
    of our JSON object as its value, so invoking its `toString()` method will return
    a `String` containing our JSON object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our specific example will generate a JSON string that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Although, in our example, we added only `String` objects to our JSON object,
    we are not limited to this type of value; `JsonObjectBuilder` has several overloaded
    versions of its `add()` method, allowing us to add several different types of
    values to our JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes all of the available versions of the `add()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `add`(`String` name, `BigDecimal` value) | Adds a `BigDecimal` value to our
    JSON object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `BigInteger` value) | Adds a `BigInteger` value to our
    JSON object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `JsonArrayBuilder` value) | Adds an array to our JSON
    object. A `JsonArrayBuilder` implementation allows us to create JSON arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `JsonObjectBuilder` value) | Adds another JSON object
    to our original JSON object (property values for JSON objects can be other JSON
    objects). The added `JsonObject` implementation is built from the provided `JsonObjectBuilder`
    parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `JsonValue` value) | Adds another JSON object to our
    original JSON object (property values for JSON objects can be other JSON objects).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `String` value) | Adds a `String` value to our JSON
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `boolean` value) | Adds a `boolean` value to our JSON
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `double` value) | Adds a `double` value to our JSON
    object. |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `int` value) | Adds an `int` value to our JSON object.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `add`(`String` name, `long` value) | Adds a `long` value to our JSON object.
    |'
  prefs: []
  type: TYPE_TB
- en: In all cases, the first parameter of the `add()` method corresponds to the name
    of the property in our JSON object, and the second parameter corresponds to the
    value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON data with the Model API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last section, we saw how to generate JSON data from our Java code with
    the object model API. In this section, we will see how we can read and parse existing
    JSON data. The following code sample illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To parse an existing JSON string, we need to create a `StringReader` object,
    passing the `String` object containing the JSON to be parsed as a parameter. We
    then pass the resulting `StringReader` instance to the static `createReader()`
    method of the `Json` class. This method invocation will return an instance of
    `JsonReader`. We can then obtain an instance of `JsonObject` by invoking the `readObject()`
    method on it.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we used the `getString()` method to obtain the values
    of all properties in our JSON object. The first and only argument for this method
    is the name of the property we wish to retrieve. Unsurprisingly, the return value
    is the value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the `getString()` method, there are several other similar methods
    to obtain values of other types. The following table summarizes these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `get`(`Object` key) | Retrieves an instance of a class implementing the `JsonValue`
    interface. |'
  prefs: []
  type: TYPE_TB
- en: '| `getBoolean`(`String` name) | Retrieves a `boolean` value corresponding to
    the given key. |'
  prefs: []
  type: TYPE_TB
- en: '| `getInt`(`String` name) | Retrieves a `int` value corresponding to the given
    key. |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonArray`(`String` name) | Retrieves the instance of a class implementing
    the `JsonArray` interface corresponding to the given key. |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonNumber`(`String` name) | Retrieves the instance of a class implementing
    the `JsonNumber` interface corresponding to the given key. |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonObject`(`String` name) | Retrieves the instance of a class implementing
    the `JsonObject` interface corresponding to the given key. |'
  prefs: []
  type: TYPE_TB
- en: '| `getJsonString`(`String` name) | Retrieves the instance of a class implementing
    the `JsonString` interface corresponding to the given key. |'
  prefs: []
  type: TYPE_TB
- en: '| `getString`(`String` name) | Retrieves a `String` corresponding to the given
    key. |'
  prefs: []
  type: TYPE_TB
- en: In all cases, the `String` parameter of the method corresponds to the key name,
    and the return value is the JSON property value we wish to retrieve.
  prefs: []
  type: TYPE_NORMAL
- en: The JSON-P Streaming API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSON-P Streaming API allows sequential reading of a JSON object from a stream
    (a subclass of `java.io.OutputStream` or a subclass of `java.io.Writer`). It is
    faster and more memory efficient than the Model API, however, the trade-off is
    that it is more limited, since the JSON data needs to be read sequentially and
    we cannot access specific JSON properties directly the way the Model API allows.
  prefs: []
  type: TYPE_NORMAL
- en: Generating JSON data with the Streaming API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The JSON Streaming API has a `JsonGenerator` class that we can use to generate
    JSON data and write it to a stream. This class has several overloaded `write()`
    methods, which can be used to add properties and their corresponding values to
    the generated JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample illustrates how to generate JSON data using the Streaming
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We create an instance of `JsonGenerator` by invoking the `createGenerator()`
    static method of the `Json` class. The JSON-P API provides two overloaded versions
    of this method: one takes an instance of a class that extends `java.io.Writer`
    (such as `StringWriter`, which we used in our example), and the other one takes
    an instance of a class that extends `java.io.OutputStream`.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can start adding properties to the generated JSON stream, we need
    to invoke the `writeStartObject()` method on `JsonGenerator`. This method writes
    the JSON start object character (represented by an opening curly brace ("`{`")
    in JSON strings), and returns another instance of `JsonGenerator`, allowing us
    to chain write() invocations to add properties to our JSON stream.
  prefs: []
  type: TYPE_NORMAL
- en: The `write()` method on `JsonGenerator` allows us to add properties to the JSON
    stream we are generating. Its first parameter is a `String` corresponding to the
    name of the property we are adding, and the second parameter is the value of the
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we are adding only `String` values to the JSON stream we are
    creating, however, we are not limited to Strings; the JSON-P Streaming API provides
    several overloaded `write()` methods that allow us to add several different types
    of data to our JSON stream. The following table summarizes all of the available
    versions of the `write()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `write(String name, BigDecimal value)` | Writes a `BigDecimal` value to our
    JSON stream. |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name, BigInteger value)` | Writes a `BigInteger` value to our
    JSON stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name, JsonValue value)` | Writes a JSON object to our JSON
    stream (property values for JSON streams can be other JSON objects) |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name, String value)` | Writes a `String` value to our JSON
    stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name, boolean value)` | Writes a `boolean` value to our JSON
    stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name, double value)` | Writes a `double` value to our JSON
    stream |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name, int value)` | Writes an `int` value to our JSON stream
    |'
  prefs: []
  type: TYPE_TB
- en: '| `write(String name, long value)` | Writes a `long` value to our JSON stream
    |'
  prefs: []
  type: TYPE_TB
- en: In all cases, the first parameter of the `write()` method corresponds to the
    name of the property we are adding to our JSON stream, and the second parameter
    corresponds to the value of the property.
  prefs: []
  type: TYPE_NORMAL
- en: Once we are done adding properties to our JSON stream, we need to invoke the
    `writeEnd()` method on `JsonGenerator`. This method adds the JSON end object character
    (represented by a closing curly brace (`}`) in JSON strings).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, our stream or reader is populated with the JSON data we generated.
    What we do with it depends on our application logic. In our example, we simply
    invoked the `toString()` method of our `StringReader` to obtain the `String` representation
    of the JSON data we created.
  prefs: []
  type: TYPE_NORMAL
- en: Parsing JSON data with the Streaming API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover how to parse the JSON data we receive from a
    stream. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing we need to do to read JSON data using the Streaming API is
    to create an instance of `JsonParser` by invoking the static `createJsonParser()`
    method on the `Json` class. There are two overloaded versions of the `createJsonParser()`
    method: one takes an instance of a class that extends `java.io.InputStream`, the
    other one takes an instance of a class that extends `java.io.Reader`. In our example,
    we use the latter, passing an instance of `java.io.StringReader`, which is a subclass
    of `java.io.Reader`.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to loop through the JSON data to obtain the data to be parsed.
    We can achieve this by invoking the `hasNext()` method on `JsonParser`, which
    returns true if there is more data to be read, and false otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: We then need to read the next piece of data in our stream. The `JsonParser.next()`
    method returns an instance of `JsonParser.Event`, which indicates the type of
    data that we just read. In our example, we check only for key names (that is,
    `firstName`, `lastName`, and `email`), and the corresponding string values. We
    check for the type of data we just read by comparing the event returned by `JsonParser.next()`
    against several values defined in the `Event` enum defined in `JsonParser`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table summarizes all of the possible events that can be returned
    from `JsonParser.next()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Event.START_OBJECT` | Indicates the start of a JSON object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.END_OBJECT` | Indicates the end of a JSON object. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.START_ARRAY` | Indicates the start of an array. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.END_ARRAY` | Indicates the end of an array. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.KEY_NAME` | Indicates the name of a JSON property was read; we can
    obtain the key name by invoking `getString()` on `JsonParser`. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_TRUE` | Indicates that a Boolean value of `true` was read. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_FALSE` | Indicates that a Boolean value of `false` was read.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_NULL` | Indicates that a `null` value was read. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_NUMBER` | Indicates that a `numeric` value was read. |'
  prefs: []
  type: TYPE_TB
- en: '| `Event.VALUE_STRING` | Indicates that a `string` value was read. |'
  prefs: []
  type: TYPE_TB
- en: 'As shown in the example, `String` values can be retrieved by invoking `getString()`
    on `JsonParser`. Numeric values can be retrieved in several different formats;
    the following table summarizes the methods in `JsonParser` that can be used to
    retrieve numeric values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `getInt()` | Retrieves the numeric value as an `int`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getLong()` | Retrieves the numeric value as a `long`. |'
  prefs: []
  type: TYPE_TB
- en: '| `getBigDecimal()` | Retrieves the numeric value as an instance of `java.math.BigDecimal`.
    |'
  prefs: []
  type: TYPE_TB
- en: '`JsonParser` also provides a convenience `isIntegralNumber()` method, which
    returns `true` if the numeric value can be safely cast to an `int` or a `long`.'
  prefs: []
  type: TYPE_NORMAL
- en: What we do with the values we obtain from the stream depends on our application
    logic. In our example, we place them on a `Map`, then use said `Map` to populate
    a Java class.
  prefs: []
  type: TYPE_NORMAL
- en: JSON pointer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON-P 1.1, introduced in Java EE 8, introduces support for JSON Pointer. JSON
    Pointer is an **Internet Engineering Task Force** (**IETF**) standard that defines
    a string syntax to identify a specific value within a JSON document, similar to
    what XPath provides for XML documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for JSON Pointer is straightforward, for example, suppose we have
    the following JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If we would like to obtain the value of the `lastName` property of the document,
    the JSON Pointer expression to use would be `"/lastName"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If our JSON document consisted of an array, then we would have to prefix the
    property with the index in the array, for example, to obtain the `lastName` property
    of the second element in the following JSON array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The JSON Pointer expression to do so would be `"/1/lastName"`. The `"/1"` at
    the beginning of the expression refers to the element index in the array. Just
    as in Java, JSON arrays are `0` indexed, therefore, in this example, we are obtaining
    the value of the `lastName` property in the second element of the array. Let''s
    now look at an example of how we would use the new JSON-P JSON Pointer API to
    perform this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code sample is a RESTful web service written using Java EE's JAX-RS
    API (see [Chapter 10](4987ac18-1f2a-410c-9613-530174a64bad.xhtml), *RESTful Web
    Services with JAX-RS* for details). In order to read property values from a JSON
    document, we first need to create an instance of `javax.json.JsonReader` by invoking
    the static `createReader()` method on `javax.json.Json`. The `createReader()`
    method takes an instance of any class implementing the `java.io.Reader` interface
    as an argument. In our example, we are creating a new instance of `java.io.StringReader`
    on the fly, and passing our JSON string as a parameter to its constructor.
  prefs: []
  type: TYPE_NORMAL
- en: There is an overloaded version of `JSON.createReader()` that takes an instance
    of any class implementing `java.io.InputStream`.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, our JSON document consists of an array of objects, therefore,
    we populate an instance of `javax.json.JsonArray` by invoking the `readArray()`
    method on the `JsonReader` object we created (if our JSON document had consisted
    of a single JSON object, we would have invoked `JsonReader.readObject()` instead).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have populated our `JsonArray` variable, we create an instance of
    `javax.json.JsonPointer` and initialize it with the JSON Pointer expression we
    want to use to obtain the value we are searching for. Remember that we are looking
    for the value of the `lastName` property in the second element of the array, therefore,
    the appropriate JSON Pointer expression is `/1/lastName`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have created an instance of `JsonPointer` with the appropriate JSON
    Pointer expression, we simply invoke its `getValue()` method, passing our `JsonArray`
    object as a parameter, then invoke `toString()` on the result. The return value
    of this invocation will be the value of the `lastName` property on the JSON document
    ("Heffelfinger", in our example).
  prefs: []
  type: TYPE_NORMAL
- en: JSON Patch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSON-P 1.1 also introduced support for JSON Patch, another **Internet Engineering
    Task Force** standard, this one providing a series of operations that can be applied
    to a JSON document. JSON Patch allows us to perform partial updates on a JSON
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following operations are supported by JSON Patch:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **JSON Patch Operation** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `add` | Adds an element to a JSON document. |'
  prefs: []
  type: TYPE_TB
- en: '| `remove` | Removes an element from a JSON document. |'
  prefs: []
  type: TYPE_TB
- en: '| `replace` | Replaces a value in a JSON document with a new value. |'
  prefs: []
  type: TYPE_TB
- en: '| `move` | Moves a value in a JSON document from its current location in the
    document to a new position. |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` | Copies a value in a JSON document to a new location in the document.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `test` | Verifies that the value in a specific location in a JSON document
    is equal to the specified value. |'
  prefs: []
  type: TYPE_TB
- en: JSON-P supports all of the preceding JSON Patch operations, which rely on JSON
    Pointer expressions to locate the source and target locations in JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates how we can use JSON Patch with JSON-P 1.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, let''s assume we are dealing with the same JSON document we
    used in our previous example: an array of two individual JSON objects, each with
    a `dateOfBirth` property (among other properties).'
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we create an instance of `JsonArray`, as before, then modify
    the `dateOfBirth` of the second element in the array. In order to do this, we
    create an instance of `javax.json.JsonPatchBuilder` via the static `createPatchBuilder()`
    method in the `javax.json.Json` class. In our example, we are replacing the value
    of one of the properties with a new value. We use the `replace()` method of our
    `JsonPatch` instance to accomplish this; the first argument in the method is a
    JSON Pointer expression indicating the location of the property we are going to
    modify, the second argument is the new value for the property. As its name implies
    `JsonPatchBuilder` follows the `Builder` design pattern, meaning that most of
    its methods return another instance of `JsonPatchBuilder`; this allows us to chain
    method calls on the resulting instances of `JsonPatchBuilder` (in our example,
    we are performing only one operation, but this doesn't have to be the case).
  prefs: []
  type: TYPE_NORMAL
- en: Once we are done specifying the operation(s) to perform on our JSON object,
    we create an instance of `javax.json.JsonPatch` by invoking the `build()` method
    on `JsonPatchBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have created the patch, we apply it to our JSON object (an instance
    of `JsonArray`, in our example), by invoking its `patch()` method, passing the
    JSON object as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: In our example of how to replace the value of a JSON property with another via
    JSON Patch support in JSON-P 1.1, JSON-P supports all operations currently supported
    by JSON Patch. The API is straightforward. For details on how to use other JSON
    Patch operations with JSON-P, consult the Java EE 8 API documentation at [https://javaee.github.io/javaee-spec/javadocs/](https://javaee.github.io/javaee-spec/javadocs/).
  prefs: []
  type: TYPE_NORMAL
- en: Populating Java objects from JSON with JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common programming task is to populate Java objects from JSON strings. It
    is such a common tasks that several libraries have been created to transparently
    populate Java objects from JSON, freeing application developers from having to
    manually code this functionality. There are some non-standard Java libraries that
    accomplish this task, such as Jackson ([https://github.com/FasterXML/jackson](https://github.com/FasterXML/jackson)),
    JSON-simple ([https://github.com/fangyidong/json-simple](https://github.com/fangyidong/json-simple)),
    and Gson ([https://github.com/google/gson](https://github.com/google/gson)). Java
    EE 8 introduces a new API providing this functionality, namely the Java API for
    JSON Binding (JSON-B). In this section, we will cover how to transparently populate
    a Java object from a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows a RESTful web service written using the Java API
    for RESTful Web Services (JAX-RS). The service responds to HTTP POST requests
    in its `addCustomer()` method. This method takes a `String` as a parameter and
    this string is expected to contain valid JSON. Please refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The JSON-B implementation provided by our application server provides an instance
    of a class implementing the `JsonbBuilder` interface. This class provides a static
    `create()` method that we can use to obtain an instance of `Jsonb`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have an instance of `Jsonb`, we can use it to parse a JSON string and
    automatically populate a Java object. This is done via its `fromJson()` method.
    The `fromJson()` method takes a `String` containing the JSON data we need to parse
    as its first parameter, and the type of the object we wish to populate as its
    second parameter. In our example, we are populating a simple `Customer` class
    containing fields such as `firstName`, `middleName`, `lastName`, and `dateOfBirth`.
    JSON-B will look for JSON property names matching the property names in the Java
    object and automatically populate the Java object with the corresponding JSON
    properties. It couldn't be more simple than that.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have populated our Java object, we can do whatever we need to do with
    it. In our example, we simply log the properties of the Java object to verify
    that it was populated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Generating JSON strings from Java objects with JSON-B
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to populating Java objects from JSON data, JSON-B can also generate
    JSON strings from Java objects. The following example illustrates how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are converting a `List` of `Customer` objects to JSON.
  prefs: []
  type: TYPE_NORMAL
- en: We chose a `List` for the example to illustrate that JSON-B supports this functionality,
    but of course, we could also convert a single object to its JSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: Just as before, we create an instance of `javax.json.bind.Jsonb` by invoking
    the static `javax.json.bind.JsonbBuilder.create()` method. Once we have our `Jsonb`
    instance, we simply invoke its `toJson()` method to convert the list of objects
    to its equivalent JSON representation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the Java API for JSON Processing (JSON-P). We illustrated
    how to generate and parse JSON data via JSON-P's model and Streaming APIs. Additionally,
    we covered new JSON-P 1.1 features, such as support for JSON Pointer and JSON
    Patch. Finally, we covered how to seamlessly populate Java objects from JSON,
    and how to easily generate JSON strings from Java objects via the new JSON-B API.
  prefs: []
  type: TYPE_NORMAL
