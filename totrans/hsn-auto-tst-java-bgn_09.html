<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Understanding the Collections Framework</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we will delve into the collections framework, which consists of interfaces and classes. We will have a look at the three major collections: <kbd class="calibre16">List</kbd>, <kbd class="calibre16">Set</kbd>, and <kbd class="calibre16">Map</kbd>. <kbd class="calibre16">ArrayList</kbd> from the <kbd class="calibre16">List</kbd> collection, <kbd class="calibre16">HashSet</kbd> from the <kbd class="calibre16">Set</kbd> collection, and <kbd class="calibre16">HashMap</kbd> and <kbd class="calibre16">HashTable</kbd> from the <kbd class="calibre16">Map</kbd> collection will be discussed in this chapter. We will go through each concept by looking at examples.</p>
<p class="mce-root">We will cover the following topics in this chapter:</p>
<ul class="calibre13">
<li class="calibre14">The collections framework</li>
<li class="calibre14">The list collection</li>
<li class="calibre14">The set collection</li>
<li class="calibre14">The map collection</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The collections framework</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The Java collections framework is basically a collection of interfaces and classes. To program efficiently, or use the flexibility of Java methods, Java has designed a framework, which consists of different classes and interfaces. The collections framework helps in storing and processing data efficiently. This framework has several useful classes that have tons of useful functions, that make a programmer's task super easy.</p>
<p class="mce-root">We have seen a lot of concepts about arrays and multidimensional arrays. For example, in an array, if we want to delete one of the indexes out of a new set of arrays, we can do that using the collections framework. Let's say in one array there are 10 values, and we want to remove the fifth value, or insert a value between the fifth and sixth values—there are some flexibility methods that you will get in the collections framework.</p>
<p class="mce-root">The kinds of method available in this collection framework, and how they can be used effectively, will be discussed in further sections. So just to give you an idea, remember that a collection is a set of classes and interfaces.</p>
<p class="mce-root">We will have a look at the collections this framework has to offer.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The List collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">The first one is the <kbd class="calibre16">List</kbd> collection/interface. A list is an ordered collection, sometimes we call it as a sequence as well. Lists may contain duplicate elements, just like arrays, but there are lots of differences between an array and <kbd class="calibre16">ArrayList</kbd>. You can insert multiple values into this <kbd class="calibre16">List</kbd> container, and it might contain duplicate elements as well. You can actually add any value and remove any value from any index. Let's say you added 15 elements sequentially into the list, now you want to remove 6<sup class="calibre84">th</sup> element, or you want to insert an element between the 10<sup class="calibre84">th</sup> and 11<sup class="calibre84">th </sup>elements, or you want to know an element at what index it is out of those 15 elements. There are lots of helpful APIs to retrieve elements from the list container, which we don't get in arrays. Arrays can only be initialized; apart from that, you cannot perform any methods on an array, whereas with <kbd class="calibre16">ArrayList</kbd> you have lots of flexible methods to play around with.</p>
<p class="mce-root">The <kbd class="calibre16">List</kbd> interface is a collection, and <kbd class="calibre16">ArrayList</kbd>, <kbd class="calibre16">LinkedList</kbd>, and <kbd class="calibre16">vector</kbd> are the three classes that implement this interface. This interface provides a set of methods. It exposes a few methods, whereas these three classes use these methods in their classes.</p>
<p class="mce-root">Out of these three, let's discuss <kbd class="calibre16">ArrayList</kbd>. This is one of the most famous ones, and is used by most Java programmers. Once you understand <kbd class="calibre16">ArrayList</kbd>, you can easily figure out <kbd class="calibre16">LinkedLists</kbd> and <kbd class="calibre16">vector</kbd>. In the next section, we will create an <kbd class="calibre16">ArrayList</kbd> class and implement methods present in the <kbd class="calibre16">List</kbd> interface, to see how flexible these methods are at retrieving or organizing data. When you have a set of data in a container, you can easily organize that data with the help of the <kbd class="calibre16">List</kbd> interface.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The ArrayList class</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Let's get started with the <kbd class="calibre16">ArrayList</kbd> class, which implements the <kbd class="calibre16">List</kbd> interface. Create a new class and name it <kbd class="calibre16">arrayListexample</kbd>. We will first look at the methods present in <kbd class="calibre16">ArrayList</kbd>, and then we'll discuss the difference between an array and <kbd class="calibre16">ArrayList</kbd>.</p>
<p class="mce-root">We start by declaring <kbd class="calibre16">ArrayList</kbd> as follows. If you hover over <kbd class="calibre16">ArrayList</kbd> in your IDE, you'll see a suggestion telling you to import <kbd class="calibre16">java.util</kbd> for <kbd class="calibre16">ArrayList</kbd>:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/><br class="calibre2"/>public class arrayListexample {<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/><br class="calibre2"/>        ArrayList a=new ArrayList();<br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Once you do this, it'll still show a suggestion for <kbd class="calibre16">ArrayList</kbd>, and if you hover over it, it will suggest adding argument types. To remove this suggestion, you can pass an argument type to <kbd class="calibre16">ArrayList</kbd>, such as <kbd class="calibre16">Integer</kbd> or <kbd class="calibre16">String</kbd>:</p>
<pre class="calibre21">        ArrayList&lt;String&gt; a=new ArrayList&lt;String&gt;();<br class="calibre2"/>        a.add("rahul");<br class="calibre2"/>        a.add("java");</pre>
<p class="mce-root">After passing the argument type, you can easily add some string instances by using <kbd class="calibre16">a.</kbd> and it'll show you a list of different types supported by <kbd class="calibre16">ArrayList</kbd>. For <kbd class="calibre16">ArrayList</kbd>, we didn't define a specific array size, whereas when you see in arrays, we have explicitly defined a size. In arrays, once we define the size, you cannot decrease or increase the size. But in <kbd class="calibre16">ArrayList</kbd>, you could add or delete elements anytime from the list, it is a dynamic size array. This is one of the basic differences between array and <kbd class="calibre16">ArrayList</kbd>.</p>
<p class="mce-root">If we want to print this <kbd class="calibre16">ArrayList</kbd>, we can simply do that by adding the following line of code:</p>
<pre class="calibre21">        System.out.println(a);</pre>
<p class="mce-root">On running, it prints <kbd class="calibre16">[rahul, java]</kbd>. But if you want to print this in arrays, we need to write a <kbd class="calibre16">for</kbd> loop. We add another object and this time we specify the index where we want the string to go:</p>
<pre class="calibre21">        a.add("rahul");<br class="calibre2"/>        a.add("java");<br class="calibre2"/>        System.out.println(a);<br class="calibre2"/>        a.add(0, "student");<br class="calibre2"/>        System.out.println(a);</pre>
<p class="mce-root">When we print this, it gives the following output:</p>
<pre class="calibre21"><strong class="calibre3">[rahul, java]</strong><br class="calibre2"/><strong class="calibre3">[student, rahul, java]</strong></pre>
<p class="mce-root">You can see that in the second line, <kbd class="calibre16">student</kbd> is added before <kbd class="calibre16">rahul</kbd> in the list as we have specified its index as <kbd class="calibre16">0</kbd>.</p>
<p class="mce-root">If we want to remove an entry from the list, we can do that by adding the following lines of code:</p>
<pre class="calibre21">        a.remove(1);<br class="calibre2"/>        a.remove("java");</pre>
<p class="mce-root">The first line of code will remove the entry from the list present at the first index, whereas the second line will find the string in the list and remove it. If you want to get the entry for a specific index, you can do that using the <kbd class="calibre16">get</kbd> method:</p>
<pre class="calibre21">       a.get(2);</pre>
<p class="mce-root">The preceding line of code will print <kbd class="calibre16">java</kbd> as the output, as it is the element present at index <kbd class="calibre16">2</kbd>.</p>
<p class="mce-root">Let's say you have a list of 50 elements, and you need to find out whether a particular string/integer is present in that list. If you were to go with arrays, you would have to create a <kbd class="calibre16">for</kbd> loop and find out whether the element is present, but in <kbd class="calibre16">ArrayList</kbd>, we have a <kbd class="calibre16">contains</kbd> method that checks the entire list for us and gives the output in the form of <kbd class="calibre16">true</kbd> or <kbd class="calibre16">false</kbd>:</p>
<pre class="calibre21">        System.out.println(a.contains("java"));</pre>
<p class="mce-root">This will print the output as <kbd class="calibre16">true</kbd> as the element is present in our list; if you change it to, for example, <kbd class="calibre16">testing</kbd>, it will return the value as <kbd class="calibre16">false</kbd> as it is not present in our list.</p>
<p class="mce-root">Another useful method present in <kbd class="calibre16">ArrayList</kbd> is the <kbd class="calibre16">indexOf</kbd> method. If we want to find the index value of a particular element from the list, we can know that by using <kbd class="calibre16">indexOf</kbd>:</p>
<pre class="calibre21">        System.out.println(a.indexOf("rahul"))</pre>
<p class="mce-root">This will return the index number of this string.</p>
<p class="mce-root">Now, if we want to check whether the array is empty, we can do that using the <kbd class="calibre16">isEmpty</kbd> method in <kbd class="calibre16">ArrayList</kbd>, which will return the value as <kbd class="calibre16">true</kbd> or <kbd class="calibre16">false</kbd>:</p>
<pre class="calibre21">        System.out.println(a.isEmpty());</pre>
<p class="mce-root">This will return the value as <kbd class="calibre16">false</kbd> as our list is not empty.</p>
<p class="mce-root">The last and most important method in <kbd class="calibre16">ArrayList</kbd> is the <kbd class="calibre16">size</kbd> method, which returns the length of the list:</p>
<pre class="calibre21">        System.out.println(a.size());</pre>
<p class="mce-root"> One more thing you need to know about <kbd class="calibre16">ArrayList</kbd> is that all the classes that implement the <kbd class="calibre16">List</kbd> interface can accept duplicate values. We know the classes that extend <kbd class="calibre16">List</kbd> in the collection interface: <kbd class="calibre16">ArrayList</kbd>, <kbd class="calibre16">LinkedList</kbd>, and <kbd class="calibre16">vector</kbd>. And all these classes can accept duplicate values.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Example of ArrayList</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre9">Let's say</span> we h<span class="calibre9">ave an array with duplicate numbers, such as <kbd class="calibre16">{4, 5, 5, 5, 4, 6, 6, 9, 4}</kbd>, and</span> we want to print out the unique number from this, and <span class="calibre9">how many times this number is repeated in this array. Our output should be "four is repeated three times, five is repeated three times, six twice, nine once."</span></p>
<p class="mce-root"><span class="calibre9">Let's bring in the <kbd class="calibre16">ArrayList</kbd> concept here to solve this puzzle:</span></p>
<pre class="calibre21">package demopack;<br class="calibre2"/>import java.util.ArrayList;<br class="calibre2"/>public class collectiondemo {<br class="calibre2"/>    public static void main(String[] args) { <br class="calibre2"/>        int a[] ={ 4,5,5,5,4,6,6,9,4}; <br class="calibre2"/>        ArrayList&lt;Integer&gt;ab =new ArrayList&lt;Integer&gt;(); <br class="calibre2"/>        for(int i=0;i&lt;a.length;i++) <br class="calibre2"/>        { <br class="calibre2"/>            int k=0; <br class="calibre2"/>            if(!ab.contains(a[i])) <br class="calibre2"/>            { <br class="calibre2"/>                ab.add(a[i]); <br class="calibre2"/>                k++; <br class="calibre2"/>                for(int j=i+1;j&lt;a.length;j++) <br class="calibre2"/>                { <br class="calibre2"/>                    if(a[i]==a[j]) <br class="calibre2"/>                    { <br class="calibre2"/>                       k++; <br class="calibre2"/>                    } <br class="calibre2"/>                } <br class="calibre2"/>                System.out.println(a[i]); <br class="calibre2"/>                System.out.println(k); <br class="calibre2"/>                if(k==1) <br class="calibre2"/>                    System.out.println(a[i]+"is unique number"); <br class="calibre2"/>            } <br class="calibre2"/>        } <br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root"><span class="calibre9">The preceding snippet is the entire code required to solve this puzzle. Let's try to understand the key logical concepts within the code. We start by defining the array and then create an empty <kbd class="calibre16">ArrayList</kbd> with the <kbd class="calibre16">ab</kbd> object type. Then we create a <kbd class="calibre16">for</kbd> loop, and within it we use an <kbd class="calibre16">if</kbd> loop with <kbd class="calibre16">!ab.contains</kbd> to check whether the element is present within the loop. We need another <kbd class="calibre16">for</kbd> loop within this <kbd class="calibre16">if</kbd> loop to iterate through the remaining part of the array. The <kbd class="calibre16">if</kbd> loop within this <kbd class="calibre16">for</kbd> loop will work as a counter for us to increment the number of times a number is repeated in the array.</span></p>
<p class="mce-root">We're done with the <kbd class="calibre16">for</kbd> and <kbd class="calibre16">if</kbd> loops. We print out each element from the array and the number of instances each element is present in the array. To print the unique number, that is, the number that is not repeated in the array, we use an <kbd class="calibre16">if</kbd> loop and print it. </p>
<p class="mce-root">That's it for this example; you can try coding this example with your own logic.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Set collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">Another important collection present in Java is the <kbd class="calibre16">Set</kbd> collection/interface. <kbd class="calibre16">HashSet</kbd>, <kbd class="calibre16">TreeSet</kbd>, and <kbd class="calibre16">LinkedHashSet</kbd> are the three classes that implement the <kbd class="calibre16">Set</kbd> interface. The main difference between <kbd class="calibre16">Set</kbd> and <kbd class="calibre16">List</kbd> is that <kbd class="calibre16">Set</kbd> does not accept duplicate values. One more difference between the <kbd class="calibre16">Set</kbd> and <kbd class="calibre16">List</kbd> interfaces is that there is no guarantee that elements are stored in sequential order.</p>
<p class="mce-root">We will mainly be discussing <kbd class="calibre16">HashSet</kbd> in this section. We will take an example class and try to understand this concept. Create a class and name it <kbd class="calibre16">hashSetexample</kbd> for this section, and create an object within the class to use <kbd class="calibre16">HashSet</kbd>; it'll suggest you add the argument type, which is <kbd class="calibre16">String</kbd> in our case:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/><br class="calibre2"/>import java.util.HashSet;<br class="calibre2"/><br class="calibre2"/>public class hashSetexample {<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>        <br class="calibre2"/>       HashSet&lt;String&gt; hs= new HashSet&lt;String&gt;();<br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">In your IDE when you type <kbd class="calibre16">hs.</kbd>, it'll show you all the methods provided by <kbd class="calibre16">HashSet</kbd>:</p>
<p class="cdpaligncenter"><img src="Images/43eefee7-fe95-435d-a7c3-e83ec95f6ce2.png" width="357" height="235" class="calibre85"/></p>
<p class="mce-root">Start by adding a few string instances of duplicate entries:</p>
<pre class="calibre21">        HashSet&lt;String hs= new HashSet&lt;String&gt;();<br class="calibre2"/>        hs.add("USA");<br class="calibre2"/>        hs.add("UK");<br class="calibre2"/>        hs.add("INDIA");<br class="calibre2"/>        hs.add("INDIA");<br class="calibre2"/>        System.out.println(hs);</pre>
<p class="mce-root">When you print this, the output will be as follows:</p>
<pre class="calibre21"><strong class="calibre3">[USA, UK, INDIA]</strong></pre>
<p class="mce-root">We see that the duplicate entry for <kbd class="calibre16">INDIA</kbd> is rejected by <kbd class="calibre16">HashSet</kbd> and we only see one instance.</p>
<p class="mce-root">If we wish to remove any object, we can do so using the <kbd class="calibre16">remove</kbd> method, and to get the size of the list use the <kbd class="calibre16">size</kbd> method:</p>
<pre class="calibre21">        System.out.println(hs.remove("UK"));<br class="calibre2"/>        System.out.println(hs.isEmpty());<br class="calibre2"/>        System.out.println(hs.size());</pre>
<p class="mce-root">The <kbd class="calibre16">isEmpty</kbd> method tells us whether the list is empty—if it's empty, it'll return <kbd class="calibre16">true</kbd>, otherwise it returns <kbd class="calibre16">false</kbd>.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Using iterator</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">To iterate through each element present within a list, we use the <kbd class="calibre16">iterator</kbd> method. We need to create another object for this <kbd class="calibre16">Iterator</kbd> class, along with the <kbd class="calibre16">String</kbd> argument type:</p>
<pre class="calibre21">        Iterator&lt;String&gt; i=hs.iterator();</pre>
<p class="mce-root">Imagine that we have a set of elements and they are in order starting from zero, one, two, and so on. <kbd class="calibre16">iterator</kbd> goes through each element starting from zero and prints the element present at each value. We have created an object for iterator and we print the values as follows:</p>
<pre class="calibre21">        System.out.println(i.next());<br class="calibre2"/>        System.out.println(i.next());</pre>
<p class="mce-root">The first instance of <kbd class="calibre16">i.next()</kbd> will print the values present at the zero index and the next <kbd class="calibre16">i.next()</kbd> instance prints the value at index one. If we have a set where we have around 100 values, we will have to use the <kbd class="calibre16">while</kbd> loop:</p>
<pre class="calibre21">        while(i.hasNext())<br class="calibre2"/>        {<br class="calibre2"/>            System.out.println(i.next());<br class="calibre2"/>        }</pre>
<p class="mce-root">Here, we have used the <kbd class="calibre16">hasNext</kbd> method, which checks the set for next values. If there are values present in the next index, it'll return <kbd class="calibre16">true</kbd> and if not, it returns <kbd class="calibre16">false</kbd>. In our case, it'll return <kbd class="calibre16">true</kbd> for 100 values and <kbd class="calibre16">false</kbd> after that, and exit the <kbd class="calibre16">while</kbd> loop.</p>
<p class="mce-root">This is how you can iterate through the objects present in the <kbd class="calibre16">Set</kbd> interface using <kbd class="calibre16">iterator</kbd>. If you are working on automation testing, such as Selenium, you'll be using this <kbd class="calibre16">while</kbd> loop frequently.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">The Map collection</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">We have one more collection, called <kbd class="calibre16">Map</kbd>. We will take an example and discuss <kbd class="calibre16">Map</kbd> as we proceed with the code. This interface takes the values in the form of a key and value pair. </p>
<p class="mce-root">We create a class, <kbd class="calibre16">hashMapexample</kbd>, and within that the we define <kbd class="calibre16">HashMap</kbd>. <kbd class="calibre16">HashMap</kbd> requires two types of argument, such as <kbd class="calibre16">Integer</kbd> and <kbd class="calibre16">String</kbd>:</p>
<pre class="calibre21">package coreJava;<br class="calibre2"/><br class="calibre2"/>import java.util.HashMap;<br class="calibre2"/><br class="calibre2"/>public class hashMapexample {<br class="calibre2"/><br class="calibre2"/>    public static void main(String[] args) {<br class="calibre2"/>        <br class="calibre2"/>       HashMap&lt;Integer, String&gt; hm= new HashSet&lt;Integer, String&gt;();<br class="calibre2"/><br class="calibre2"/>    }<br class="calibre2"/>}</pre>
<p class="mce-root">Here, <kbd class="calibre16">Integer</kbd> is the key and <kbd class="calibre16">String</kbd> is the value. Now if you type <kbd class="calibre16">hm.</kbd> in your IDE, you will see a few methods present in <kbd class="calibre16">HashMap</kbd>; let's use the <kbd class="calibre16">put</kbd> method:</p>
<pre class="calibre21">        hm.put(0, "hello");<br class="calibre2"/>        hm.put(1, "goodbye");<br class="calibre2"/>        hm.put(2, "morning");<br class="calibre2"/>        hm.put(3, "evening");</pre>
<p class="mce-root">The <kbd class="calibre16">put</kbd> method takes the input in the form of keys and values. Also, the value of the key needs to be an integer, it can be a string as well. The key is just something we define for the value. We can remove a value using the <kbd class="calibre16">remove</kbd> method:</p>
<pre class="calibre21">        hm.remove(2);</pre>
<p class="mce-root">The <kbd class="calibre16">entrySet</kbd> method in <kbd class="calibre16">HashMap</kbd> stores each key and value in the form of a set index:</p>
<pre class="calibre21">        Set sn= hm.entrySet();</pre>
<p class="mce-root">We have now converted this <kbd class="calibre16">HashMap</kbd> into a set. To traverse through each index of this set, we use <kbd class="calibre16">iterator</kbd> and, just like in the previous section, we use the <kbd class="calibre16">while</kbd> loop:</p>
<pre class="calibre21">        Iterator it= sn.iterator();<br class="calibre2"/>        <br class="calibre2"/>        while(it.hasNext())<br class="calibre2"/>        {<br class="calibre2"/>            Map.Entry mp=(Map.Entry)it.next();<br class="calibre2"/>            System.out.println(mp.getKey());<br class="calibre2"/>            System.out.println(mp.getValues());<br class="calibre2"/>        }</pre>
<p class="mce-root">We need to use <kbd class="calibre16">Map.Entry</kbd> here, as the element in each index consists of a key and a value, and <kbd class="calibre16">Map.Entry</kbd> helps us to separate out the keys and values. When you print this <kbd class="calibre16">while</kbd> loop, you should get the following output:</p>
<pre class="calibre21"><strong class="calibre3">0</strong><br class="calibre2"/><strong class="calibre3">hello</strong><br class="calibre2"/><strong class="calibre3">1</strong><br class="calibre2"/><strong class="calibre3">goodbye</strong><br class="calibre2"/><strong class="calibre3">2</strong><br class="calibre2"/><strong class="calibre3">morning</strong><br class="calibre2"/><strong class="calibre3">3</strong><br class="calibre2"/><strong class="calibre3">evening</strong></pre>
<p class="mce-root">Without using <kbd class="calibre16">Map.Entry</kbd>, it'll throw an error. This is how <kbd class="calibre16">HashMap</kbd> works.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">HashTable</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">There is one more collection, called <kbd class="calibre16">HashTable</kbd>, but it lies along the same lines as <kbd class="calibre16">HashMap</kbd>. <span class="calibre9">You just need to change </span><kbd class="calibre16">HashMap</kbd><span class="calibre9"> to </span><kbd class="calibre16">HashTable</kbd>—<span class="calibre9">that's it. </span>There's a slight difference between <kbd class="calibre16">HashMap</kbd> and <kbd class="calibre16">HashTable</kbd> though. </p>
<p class="mce-root">The differences between <kbd class="calibre16">HashMap</kbd> and <kbd class="calibre16">HashTable</kbd> are as follows:</p>
<ul class="calibre13">
<li class="calibre14">Synchronized or thread-safe</li>
<li class="calibre14">Null keys and null values</li>
<li class="calibre14">Iterating values</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Synchronized or thread-safe</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><span class="calibre9">This is the most important difference between the two. </span><kbd class="calibre16">HashMap</kbd><span class="calibre9"> is non-synchronized and not thread-safe. </span><span class="calibre9">So what is meant by non-synchronized? It means if multiple programs simultaneously access </span><kbd class="calibre16">HashMap</kbd><span class="calibre9">, it keeps on updating. Now let's say there are five threads working on </span><kbd class="calibre16">HashMap</kbd><span class="calibre9">. That means five different programs or threads can access </span><kbd class="calibre16">HashMap</kbd><span class="calibre9"> at the same time, which means there is no synchronization. But in </span><kbd class="calibre16">HashTable</kbd><span class="calibre9">, if one program is accessing </span><kbd class="calibre16">HashTable</kbd><span class="calibre9">, the other program needs to wait until the first program releases the </span><kbd class="calibre16">HashTable</kbd><span class="calibre9"> resources. That's the major difference. </span><span class="calibre9">On the other hand, </span><kbd class="calibre16">HashTable</kbd><span class="calibre9"> is thread-safe and synchronized. When should you use </span><kbd class="calibre16">HashMap</kbd><span class="calibre9">? If your application does not require a multithreading task—in other words, </span><kbd class="calibre16">HashMap</kbd><span class="calibre9"> is better for non-threading applications. </span><kbd class="calibre16">HashTable</kbd><span class="calibre9"> should be used in multithreading applications.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Null keys and null values</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">HashMap</kbd> <span class="calibre9">allows one null key and any number of null values, while</span> <kbd class="calibre16">HashTable</kbd> <span class="calibre9">does not allow null keys and null values in the </span><kbd class="calibre16">HashTable</kbd> <span class="calibre9">object. Let's say you are entering employee records into a database and while uploading the employee details into your database, maybe you feel that you would not know their phone number, but you enter the field called phone number in a key value, and index value for now you would leave it as a null; you could update it later. This works in <kbd class="calibre16">HashMap</kbd>, but when you are working with <kbd class="calibre16">HashTable</kbd>, it will not allow any nul</span>l keys a<span class="calibre9">nd null values. If you feel that you want to make your program very secure and you want to block multiple threads from accessing it simultaneously, then you should go with <kbd class="calibre16">HashTable</kbd>. <kbd class="calibre16">HashTable</kbd> is thread-safe, and it will not release its object to another program until one program completes its operation on <kbd class="calibre16">HashTable</kbd>.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Iterating values</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root"><kbd class="calibre16">HashMap</kbd> <span class="calibre9">object values are iterated by using </span><kbd class="calibre16">iterator</kbd><span class="calibre9">.</span> <kbd class="calibre16">HashTable</kbd> <span class="calibre9">is the only class other than vector which uses enumerator to iterate the values of the</span> <kbd class="calibre16">HashTable</kbd> <span class="calibre9">object.</span></p>
<p class="mce-root"><span class="calibre9">The operations are the same across <kbd class="calibre16">HashMap</kbd> and <kbd class="calibre16">HashTable</kbd>, except for the three differences we've just described.</span></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content" class="calibre1"><section class="calibre2">

                            <header class="calibre2">
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article class="calibre2">
                
<p class="mce-root">In this chapter, we had a look at the collections framework and the three types of collection: <kbd class="calibre16">List</kbd>, <kbd class="calibre16">Set</kbd>, and <kbd class="calibre16">Map</kbd>. We explored <kbd class="calibre16">ArrayList</kbd> in the <kbd class="calibre16">List</kbd> collection, and also explored an example of <kbd class="calibre16">ArrayList</kbd>. The <kbd class="calibre16">Set</kbd> collection is different from <kbd class="calibre16">ArrayList</kbd>—the major difference is that <kbd class="calibre16">Set</kbd> does not accept duplicate values. In the last collection, that is, the <kbd class="calibre16">Map</kbd> collection, we saw two types, <kbd class="calibre16">HashMap</kbd> and <kbd class="calibre16">HashTable</kbd>, and the differences between the two.</p>


            </article>

            
        </section>
    </div>



  </body></html>