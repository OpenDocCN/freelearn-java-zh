- en: Chapter 7. Adding Web Services to Your Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed the Java Messaging Service API, which
    is commonly used to develop loosely coupled applications and a common integration
    pattern for Java-to-Java systems. In this chapter, you will learn about web services
    that are defined by W3C as software systems, and designed to support interoperable
    machine-to-machine interaction over a network.
  prefs: []
  type: TYPE_NORMAL
- en: What makes web services different from other forms of distributed computing
    is that information is exchanged using only simple and nonproprietary protocols.
    This means the services can communicate with each other regardless of location,
    platform, or programming language. Essentially, web services protocols provide
    a platform-independent way to perform **Remote Procedure Calls** (**RPCs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The focus of this chapter will be on the two chief web services standards,
    **JAX-WS** (**JSR 224**) and **JAX-RS** (**JSR 339**), and how they are implemented
    in WildFly. As you can imagine, there is a lot of ground to cover, so we will
    quickly get our hands dirty with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A short introduction to SOAP-based web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, deploying, and using the JBoss JAX-WS implementation (Apache CXF)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick overview of REST web services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create, deploy, and use services using the JBoss JAX-RS implementation
    (RESTEasy)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating JAR-RS with an external non-Java application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing SOAP-based web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As stated, web services are based on the exchange of messages using nonproprietary
    protocol messages. The messages themselves are not sufficient to define the web
    service platform. We actually need a list of standard components, including the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: A language used to define the interfaces provided by a web service in a manner
    that is not dependent on the platform on which it is running or the programming
    language used to implement it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common standard format to exchange messages between web service **providers**
    and web service **consumers**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A registry within which service definitions can be placed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Web Service Description Language**, also known as **WSDL**, ([http://www.w3.org/TR/wsdl](http://www.w3.org/TR/wsdl))
    is the de facto standard to provide a description of a web service contract exposed
    to clients. In particular, a WSDL document describes a web service in terms of
    the operations that it provides, and the data types that each operation requires
    as inputs and can return in the form of results.
  prefs: []
  type: TYPE_NORMAL
- en: Communication between the service provider and service consumer happens by means
    of XML messages that rely on the SOAP specification.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic SOAP message consists of an envelope that may contain any number of
    headers and a body. These parts are delimited by XML elements called `envelope`,
    `header`, and `body`, which belong to a namespace defined by the SOAP specification.
    The following figure depicts the basic structure of a SOAP message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Developing SOAP-based web services](img/00062.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Strategies to build SOAP-based web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have just discussed, the service description is provided by a commonly
    used document interface named WSDL that exposes the services as a collection of
    networks, endpoints, and ports, using the XML format.
  prefs: []
  type: TYPE_NORMAL
- en: You may logically be inclined to think that it is necessary to state the corresponding
    programming interfaces at the beginning of the contract of a service and then
    produce them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actually, you can follow two approaches to develop your SOAP web services:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top-down**: This development strategy involves creating a web service from
    a WSDL file. The top-down approach is likely to be used when creating web services
    from scratch. It is the preferred choice of pure web service engineers because
    it is business-driven, that is, the contract is defined by business people and
    so the software is designed to fit the web service contract.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Bottom-up**: This approach requires the WSDL file to be generated by the
    programming interfaces. It is likely to be used when we have existing applications
    that we want to expose as web services. As this approach does not require a deep
    knowledge of the WSDL syntax, it is the easiest choice if you want to turn your
    Java classes or EJB into web services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the audience of this book is composed mainly of Java developers with little
    or no knowledge of WSDL basics, we will focus primarily on the bottom-up approach.
  prefs: []
  type: TYPE_NORMAL
- en: Designing top-down web services, on the other hand, will require you to integrate
    the basic web services notions provided with this chapter with a comprehensive
    awareness of the WSDL standard.
  prefs: []
  type: TYPE_NORMAL
- en: JBoss SOAP-based web services stack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All JAX-WS functionalities provided on top of WildFly are currently served through
    a proper integration of the JBoss web services stack with most of the **Apache
    CXF** project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apache CXF is an open source web service framework that provides an easy-to-use,
    standard-based programming model to develop both SOAP and REST web services. The
    integration layer (JBossWS-CXF in short hereafter) allows us to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use standard web services APIs (including JAX-WS) on a WildFly Application Server;
    this is performed internally by leveraging Apache CXF, without requiring the user
    to deal with it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage Apache CXF's advanced native features on top of a WildFly Application
    Server without the need for the user to deal with all the required integration
    steps to run the application in such a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, the focus of the next section will be on developing JAX-WS web services
    using the built-in Apache CXF configuration. If you want to further expand your
    knowledge about Apache CXF's native features, you can refer to the official documentation
    that is available at [http://cxf.apache.org/](http://cxf.apache.org/).
  prefs: []
  type: TYPE_NORMAL
- en: A brief look at the JAX WS architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a SOAP message sent by the client enters the web service runtime environment,
    it is captured by a component named **server endpoint listener**, which, in turn,
    uses the **Dispatcher** module to deliver the SOAP message to that service.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the HTTP request is converted internally into a SOAP message.
    The message content is extracted from the transport protocol and processed through
    the handler chain configured for the web service.
  prefs: []
  type: TYPE_NORMAL
- en: SOAP message handlers are used to intercept SOAP messages as they make their
    way from the client to the endpoint service and vice versa. These handlers intercept
    SOAP messages for both the request and response of the web service.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is unmarshalling the SOAP message into Java objects. This process
    is governed by WSDL to Java Mapping and XML to Java Mapping. The former is performed
    by the JAX-WS engine, and it determines which endpoint to invoke from the SOAP
    message. The latter, performed by the JAXB libraries, deserializes the SOAP message
    so that it is ready to invoke the endpoint method.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the deserialized SOAP message reaches the actual web service implementation
    and the method is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Once the call is completed, the process is reversed. The return value from the
    web service method is marshalled into a SOAP response message using JAX-WS WSDL
    to Java mapping and JAXB 2.0 XML to Java mapping.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JAXB provides a fast and convenient way to bind XML schemas and Java representations,
    making it easy for Java developers to incorporate XML data and process functions
    in Java applications. As part of this process, JAXB provides methods to unmarshal
    XML instance documents into Java content trees, and then marshal Java content
    trees back into XML instance documents. JAXB also provides a way to generate XML
    schema from Java objects.
  prefs: []
  type: TYPE_NORMAL
- en: Next, the outbound message is processed by handlers before returning it to the
    dispatcher and endpoint listener that will transmit the message as an HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram describes how data flows from a web service client to
    a web service endpoint and back:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A brief look at the JAX WS architecture](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Coding SOAP web services with WildFly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first deliverable, we will show how easily you can turn a plain Java
    class into a web service. The newly created service will then be tested using
    a simple Eclipse-based testing GUI. The second part of this section will draw
    your attention to how EJBs can be exposed as web service endpoints by enhancing
    your ticket application with a web service.
  prefs: []
  type: TYPE_NORMAL
- en: Developing a POJO web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will start developing web services, using our project from [Chapter 4](part0028_split_000.html#page
    "Chapter 4. Learning Context and Dependency Injection"), *Learning Context and
    Dependency Injection* (`ticket-agency-cdi`) as a base. We will omit the current
    JSF-based web layer for now. You can safely remove all of the JSF-related classes
    and configurations. If you encounter any problems, remember that you'll find a
    fully working project in the code examples, upon completion of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first class will not be related to our ticket application, but it will
    just demonstrate how to create a web service from a `POJO` class named `CalculatePowerWebService`.
    This class has a method named `calculatePower`, which returns the power of an
    argument, as shown in the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will turn this simple class into a web service by adding the mandatory
    `@WebService` annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `@WebService` annotation, you can specify additional elements, such
    as the `targetNamespace` element that declares the namespace used for the WSDL
    elements generated by the web service. If you don't specify this element, the
    web service container will use the Java package name to generate a default XML
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `serviceName` element to specify the service name. The
    name specified using `serviceName` is used to generate the name attribute in the
    service element in the WSDL interface. If you don't specify the `serviceName`
    element, the server will generate it using the default value, which is the bean
    class name appended with the service.
  prefs: []
  type: TYPE_NORMAL
- en: In the next row, we state that the web service is of the type **Remote Procedure
    Call** using the `@javax.jws.SOAPBinding` annotation. The possible values are
    `DOCUMENT` and `RPC`, the first one being the default value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The choice between the RPC and Document style boils down to the different ways
    we can construct services using these two styles. The body of an RPC-style SOAP
    message is constructed in a specific way, which is defined in the SOAP standard.
    This is built on the assumption that you want to call the web service just like
    you would call a normal function or method that is part of your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the RPC is more tightly coupled because if you make any changes in
    the message structure, you'll need to change all the clients and servers processing
    this kind of message.
  prefs: []
  type: TYPE_NORMAL
- en: A document-style web service, on the other hand, contains no restrictions for
    how the SOAP body must be constructed. It allows you to include whatever XML data
    you want and also a schema for this XML. Therefore, the document style is probably
    more flexible, but the effort to implement the web service and clients may be
    slightly more.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, the likelihood of change is a factor that one has to consider when
    choosing whether to use RPC- or Document-style web services.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching the `@WebMethod` attribute to a public method indicates that you want
    the method exposed as part of the web service.
  prefs: []
  type: TYPE_NORMAL
- en: The `@WebParam` annotation is used to specify the parameter's name that needs
    to be exhibited in the WSDL. You should always consider using a `WebParam` annotation,
    especially when using multiple parameters, otherwise the WSDL will use the default
    argument parameter (in this case, `arg0`), which is meaningless for web service
    consumers.
  prefs: []
  type: TYPE_NORMAL
- en: The `@WebResult` annotation is quite similar to `@WebParam` in the sense that
    it can be used to specify the name of the value returned by the WSDL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your web service is now complete. In order to deploy your web service, run
    the following Maven goal, which will package and deploy your web service to your
    running WildFly instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'WildFly will provide a minimal output on the console; this will inform you
    that the web service project has been deployed and the WSDL file has been generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: From the short log, you can pick up some useful information. For example, the
    first line states that the web service has been bound in the endpoint registry
    as `{http://www.packtpub.com/}CalculatePowerService`. Next is the information
    about the web context path, which, by default, has the same name as your project,
    that is, `ticket-agency-ws`. The last piece of information is about the web service
    address, which is `http://localhost:8080/ticket-agency-ws/CalculatePowerService`.
    By appending the `?wsdl` suffix to the end of the address, you can inspect the
    web service contract.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `data` directory contains a versioned list of all the generated WSDLs. So,
    you might find the entire history of your web services published by `ticket-agency-ws`
    in `JBOSS_HOME/standalone/data/wsdl/ticket-agency-ws.war`.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the web service from the console
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can inspect the web services subsystem by moving to the web admin console
    and navigating to **Runtime** | **Status** | **Subsystems** | **Web Services**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can gather some useful information about the services deployed. In
    fact, the most useful option is the list of endpoint contracts available, which
    is needed when developing our clients. The following screenshot shows a view of
    the web service endpoints from the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Inspecting the web service from the console](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Particularly, in the lower part of the screen, you can read the web service
    endpoint address that bears the web application context name and registered name
    for the web service. In our case, it is `http://localhost:8080/ticket-agency-ws/CalculatePowerService?wsdl`.
  prefs: []
  type: TYPE_NORMAL
- en: Testing our simple web service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since our first web service is not yet connected to our ticketing system, we
    will use an external client application to test our web service. One of the best
    tools to test web services is **SoapUI**.
  prefs: []
  type: TYPE_NORMAL
- en: SoapUI is a free, open source, cross-platform functional testing solution with
    an easy-to-use graphical interface and enterprise-class features. This tool allows
    you to create and execute automated, functional, regression, compliance, and load
    tests easily and rapidly. SoapUI is also available as an Eclipse plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we will use the SoapUI standalone application. Run it and create a new
    SOAP project providing the URL to the service WSDL, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our simple web service](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After this, you''ll see a view containing a few windows. The most important
    ones show the request logs and the project view in the navigator window, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our simple web service](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, your service operations have been automatically discovered.
    Double-click on the **Request 1** tree element; the SoapUI request window will
    appear where you can enter the named parameters. Enter the two arguments for the
    web service, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our simple web service](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the **Submit** button on the toolbar and check the result in the SOAP
    response window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Testing our simple web service](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: EJB3 Stateless Session Bean (SLSB) web services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JAX-WS programming model supports the same set of annotations on EJB3 Stateless
    Session Bean as it does on POJO endpoints. Now that we already have some web service
    muscle, we will engineer one of the examples introduced in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our main web service class will be named `DefaultTicketWebService` and will
    use some of the core classes that we described in [Chapter 3](part0023_split_000.html#page
    "Chapter 3. Introducing Java EE 7 – EJBs"), *Introducing Java EE 7 – EJBs*, such
    as `TheatreBox`, which will keep in memory the ticket bookings and the `Seat`
    class as the model. The business methods of our web service will be described
    by a **Service Endpoint Interface** (**SEI**) named `TicketWebService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Writing the service interface is always a good practice as it gives a proper
    client-side view of our Service methods. The implementation class can then implement
    the methods defined in the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now implement the interface by providing the business logic to the
    interface methods in the `DefaultTicketWebService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the implementation class contains the `getSeats` method, which
    returns the list of seats that are self-generated when the `TheatreBox` object
    is initialized. The `bookSeat` method will be able to book seats for your web
    service clients as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now deploy your web service and verify on the console that it has been correctly
    registered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Developing a web service consumer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The web service consumer of the `TicketWebService` class will be coded using
    the standard Java SE classes. We want to show here how to use these standard APIs.
    For this reason, you can just add a class named `TicketWebServiceTestApplication`
    to your current or a separate project in the package `com.packtpub.wflydevelopment.chapter7.webservice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The service WSDL URL and name are needed for retrieval of the `Service` object.
    Finally, the `getPort` method will return a proxy to your web service that can
    be used to test two basic operations: booking a seat and checking from the `Seat`
    list if the seat has actually been reserved.'
  prefs: []
  type: TYPE_NORMAL
- en: This small standalone class has shown how it is possible to use SOAP-based services
    from the client-side perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most interesting part, however, is at the bottom of the Maven output, where
    the `Ticket` list is dumped after booking one seat, as depicted in the following
    command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Developing REST-based web services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**JAX-RS 2.0** (JSR-339 can be found at [https://jcp.org/en/jsr/detail?id=339](https://jcp.org/en/jsr/detail?id=339))
    is a JCP specification that provides a Java API for RESTful web services in the
    HTTP protocol. It is a major refresh from the old Version 1.1\. Some of the new
    features are the client API, HATEOAS support, and asynchronous calls.'
  prefs: []
  type: TYPE_NORMAL
- en: In their simplest form, RESTful web services are networked applications that
    manipulate the state of system resources. In this context, resource manipulation
    means resource creation, retrieval, updatation, and deletion (CRUD). However,
    RESTful web services are not limited to just these four basic data manipulation
    concepts. On the contrary, RESTful web services can execute logic at the server
    level but remember that every result must be a resource representation of the
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference with SOAP web services is that REST asks developers to use
    HTTP methods explicitly and in a way that's consistent with the protocol definition.
    This basic REST design principle establishes a **one-to-one** mapping between
    CRUD operations and HTTP methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, with the delineated roles for resources and representations, we
    can now map our CRUD actions to the HTTP methods `POST`, `GET`, `PUT`, and `DELETE`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Action | HTTP protocol equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| RETRIEVE | GET |'
  prefs: []
  type: TYPE_TB
- en: '| CREATE | POST |'
  prefs: []
  type: TYPE_TB
- en: '| UPDATE | PUT |'
  prefs: []
  type: TYPE_TB
- en: '| DELETE | DELETE |'
  prefs: []
  type: TYPE_TB
- en: Accessing REST resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we said, REST resources can be accessed using actions that map an equivalent
    HTTP request. In order to simplify the development of REST applications, you can
    use simple annotations to map your actions; for example, in order to retrieve
    some data from your application, you can use something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first annotation, `@Path`, in our example is used to specify the URI that
    is assigned to this web service. Subsequent methods have their specific `@Path`
    annotation so that you can provide a different response according to the URI requested.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have an `@GET` annotation that maps an HTTP `GET` request and an `@POST`
    annotation that handles an HTTP `POST` request. So, in this example, if we were
    to request for a web application bound to the `example` web context, an HTTP `GET`
    request to the URL `http://host/example/users` would trigger the `handleGETRequest`
    method; on the other hand, an HTTP `POST` request to the same URL would conversely
    invoke the `handlePOSTRequest` method.
  prefs: []
  type: TYPE_NORMAL
- en: JBoss REST web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having understood the basics of REST services, let's see how we can develop
    a RESTful web service using WildFly. The application server includes an out-of-the-box
    RESTEasy library that is a portable implementation of the JSR-339 specification.
    RESTEasy can run in any servlet container; however, it is perfectly integrated
    with WildFly, thus making the user experience nicer in that environment.
  prefs: []
  type: TYPE_NORMAL
- en: Besides the server-side specification, in the past, RESTEasy has been innovative
    in bringing JAX-RS to the client through the RESTEasy **JAX-RS Client Framework**.
    However, the latest version of the JAX-RS specification comes with a client API,
    which we can use in every JAX-RS implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Activating JAX-RS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'RESTEasy is bundled with WildFly, so you need very little effort to get started.
    You have two choices. The first one is to use the `@ApplicationPath` annotation
    in a class that extends `javax.ws.rs.core.Application`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The second choice is less popular and used to configure the application using
    a `web.xml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This simply means that if we were to deploy our former example, the HTTP `GET`
    method, `http://host/example/rest/users` would trigger our `getUser` business
    method, while the same URL will place a request through the `handlePOSTRequest`
    method using a `POST` request.
  prefs: []
  type: TYPE_NORMAL
- en: Adding REST to our ticket example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With all the configurations in place, we can now add a simple REST web service
    to our `Ticket Web Service` project, which will provide the same functionalities
    as our SOAP web service.
  prefs: []
  type: TYPE_NORMAL
- en: 'So add a new class to your project and name it `SeatsResource`. The code for
    this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you have understood our earlier section well, this code will be almost intuitive
    to you. We have included two methods here, just like the SOAP alter ego; the former
    one is named `getSeatList`, which is bound to an HTTP `GET` request and produces
    the list of `Seats`. The list is returned using a JSON representation that is
    pretty common when returning Java objects to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The grammar for JSON objects is simple and requires the grouping of the data
    definition and data values; it is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Elements are enclosed within curly brackets (`{` and `}`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Values of elements come in pairs with the structure of `name:value` and are
    comma separated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arrays are enclosed within square brackets (`[` and `]`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's all there is to it (for the full JSON grammar description, visit [http://www.json.org/](http://www.json.org/)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method included in this class is `bookPlace`, which will be used
    to invoke the corresponding `bookSeat` class of our EJB. This method, on the other
    hand, is bound to the following HTTP `POST` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You might be thinking that this `Path` expression seems a bit weird, but all
    it does is map a URI parameter (included in the `Path` expression) to a method
    parameter. In short, the parameter that is included in the URL will be passed
    to the method in the `ID` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The previous method also returns a JSON-formatted string that is encoded and
    decoded using Jackson (by default, it is possible to create your own message body
    providers!), a library that transforms POJOs to JSON (and vice versa).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we proceed, we need to extend our sample with a new resource account,
    which will allow us to check the cash status and optionally reset it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The account representation is available, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step is to update our `TheatreBooker` class to use our new account
    representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The newest version of JAX-RS also supports server-side asynchronous responses.
    Thanks to the `@Suspended` annotation and the `AsyncResponse` class, you can use
    a separate (possibly delayed) thread to handle a request call.
  prefs: []
  type: TYPE_NORMAL
- en: Adding filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX-RS allows us to define filters and interceptors for both the client and
    server. They allow the developer to address cross-cutting concerns, such as security,
    auditing, or compression. Basically, you can treat filters and interceptors as
    extension points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Filters are used mainly on headers of requests and responses. For example,
    you can block a request based on its header fields or log only failed requests.
    On the contrary, interceptors deal with message bodies, for example, you can sign
    or compress the messages. Interceptors also come in two flavors: one for reading
    (they are executed when a message is translated into a POJO, for example JSON
    to `SeatDto`) and one for writing (they are used for POJO to message translation).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a simple server-side logging filter to our application by creating
    the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we implement two pretty straightforward interfaces: `ContainerRequestFilter`
    and `ContainerResponseFilter`. We simply log some information about the HTTP request
    and response. To activate the filter, we use the `@Provider` annotation; without
    additional configuration, the filter will work for every REST resource in our
    application. Additionally, if we would like to reject a request in the filter,
    there is a `requestContext.abortWith` method.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The client side has two corresponding interfaces: `ClientRequestFilter` and
    `ClientResponseFilter`. The implementations, however, must be registered manually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the REST service is complete and we can start deploying it in the usual
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you followed all the steps so far, the `http://localhost:8080/ticket-agency-ws/rest/seat
    GET` method issued by your browser should print out the list of available seats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Going to `http://localhost:8080/ticket-agency-ws/rest/account` will result
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should also see some log statements from our filter in the console, for
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Consuming our REST service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Connecting to a RESTful web service takes no more work than directly connecting
    to the service through an HTTP connection. For this reason, you can use plenty
    of APIs to access your REST services, such as the JDK `URLConnection` class or
    Jakarta Commons HttpClient API, since we have a standardized client available
    in JAX-RS.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to retrieve the list of `Seats` from your REST service, your code
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The previous code will simply perform a `GET` action to the REST service that
    is deployed as part of the `ticket-agency-ws` web application. RESTEasy (using
    Jackson) will transform the JSON objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following standalone sample will get the data from the account and seat
    resources and attempt to book all of the available seats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the highlighted fragments, you can see the REST calls used to retrieve the
    data and booking seats. Our `post` call requires an ID to be specified; we do
    that by using the `path` method of the `request` builder. It is also possible
    to make the call asynchronously, using the `async` method and a `Future` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the new `CompletableFuture` class from Java 8 to be notified about
    the completion of a request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After receiving the data, we simply print it out. Another option is to simply
    create an `InvocationCallback` class and pass it as a second argument to the `get`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling our ticket example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Our sample can reside in a separate Maven module or you can leave it with the
    server content (although it is not a good practice). In order to compile our client
    project with the REST web service, we need to import the JAX-RS API that is included
    in the application server libraries. We will need the following dependencies in
    our standalone application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you have any problems with the creation of the POM file, you can look it
    up in the samples that are distributed with this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now simply run your application, and you should see something similar to the
    following console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Adding AngularJS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our samples for the REST integration are not very spectacular. However, because
    we expose the functionality of our application via a REST API, it is easy to create
    a non-Java GUI, which can be used to control the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a GUI that uses only the REST API to communicate with our Java backend,
    we will use a popular JavaScript framework: AngularJS ([http://angularjs.org/](http://angularjs.org/)).
    We won''t get into too much detail of the JavaScript code. The most interesting
    part for us is the usage of our REST API, which we currently consume only in a
    Java application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in [Chapter 5](part0030_split_000.html#page "Chapter 5. Combining Persistence
    with CDI"), *Combining Persistence with CDI*, we will use WebJars. This time,
    apart from Bootstrap, we need the AngularJS (preferably in Version 3.x) and Angular
    UI Bootstrap package ([http://angular-ui.github.io/bootstrap/](http://angular-ui.github.io/bootstrap/)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember that all the files that are required to run this sample are available
    with the code attached to this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need an `index.html` file to start our work and an empty `scripts`
    directory to store our logic. Our directory structure should currently look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding AngularJS](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the `index.html` file, we need to add all the required libraries along with
    our well-known Bootstrap structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have also noticed two strange-looking attributes in the `html` tags:
    `ng-app` and `ng-controller`. These are AngularJS directives that point to the
    web page being an AngularJS application, and that the container div will use a
    `SeatCtrl` controller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need the following files placed in our `scripts` directory. The
    first one is the initialization file `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next we will initialize the address of our seat resource in `scripts/services/seatservice.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we mapped our REST URL to the JavaScript code along with two
    HTTP methods: `GET` and `POST`. They will be called by the controller to communicate
    with the server; the same goes for our account resource, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we create a simple controller to place our logic at `scripts/controllers/seat.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted portions of code are calls to the services we defined previously.
    For instance, `$scope.seats = SeatService.query()` will issue a `GET` request
    to retrieve a list of seats in the JSON format. The case for `seat.$book` is similar;
    it will issue a `POST` request to book a specific seat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our whole JavaScript logic is now in place. One final move is to place some
    HTML code bound to it in our `index.html` file. Insert the following code in the
    `index.html` file, inside the `content` div:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The code is similar to the JSF tables we created in the earlier chapters. What
    is important to us is that the `{{ }}` symbols are used by AngularJS to bind the
    displayed data with a variable in a controller, which, in fact, is a representation
    of our REST endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `ng-click` directives are bound to the appropriate methods
    in the controller. The `bookTicket` method issues a `seat.$book` call, which is
    propagated as a `POST` request to our backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now deploy our application to the server. After going to `http://localhost:8080/ticket-agency-ws/index.html`
    in your browser, you should see your application running, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding AngularJS](img/00070.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can use the developer''s tools in Chrome (or FireBug in Mozilla Firefox)
    to inspect the `rest` calls that are done against the server; simply press *F12*
    and switch to the **Network** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding AngularJS](img/00071.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You have just created a modern Internet application and combined
    it with a REST API that was earlier used by a standalone console application!
  prefs: []
  type: TYPE_NORMAL
- en: Choosing between SOAP and REST services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The choice of adopting SOAP rather than REST depends on your application's requirements.
    SOAP web services are exposed using their own well-defined protocol and focus
    on exposing pieces of application logic as services. So if your requirement is
    to consume business services that are exposed using a well-defined and negotiated
    contract (between the service consumer and service provider), SOAP web services
    are a perfect match.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you need to access some server resources using stateless
    HTTP invocations and as little as possible of the navigation bar of your browser,
    you should probably go with RESTful web services.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, there may still be some scenarios that could fit both the options,
    and you are free to choose whichever web service suits your requirements the best.
    Recently, REST has gained popularity, thanks to its interoperability. We use only
    the HTTP protocol and JSON, which almost every language can handle. Therefore,
    a REST API developed using Java EE can be used by a wide variety of clients along
    with mobile devices. Often, this feature is a deal breaker when it comes to designing
    a system.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced some of the basic web services concepts so that
    you could get acquainted with these technologies before using them to enhance
    your ticket application.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we went through SOAP-based web services that are based on a contract between
    the service and client defined by the WSDL file. SOAP web services are an excellent
    option to integrate systems when you have well-defined, abstract operations exposed
    using standard XML files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we discussed REST services. The key to the REST methodology is to write
    web services using an interface that is already well known and widely used: the
    URI. The twist here is to identify the key system resources (this can be entities,
    collections, or anything else the designer thinks is worthy of having its own
    URI) and expose them using standard methods that are mapped to standard methods.
    In this case, the HTTP verbs are mapped to resource-specific semantics.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We created two applications that use our REST API: one console-based and one
    written purely in JavaScript using AngularJS. Both of these use the same REST
    endpoints and the second one knows only about JSON; it has no idea about the Java
    classes underneath (or even about Java).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We discussed application server resources a lot. In the next chapter, we will
    explore another approach for client-server communication: WebSockets.'
  prefs: []
  type: TYPE_NORMAL
