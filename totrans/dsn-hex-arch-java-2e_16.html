<html><head></head><body>
<div id="_idContainer091">
<h1 class="chapter-number" id="_idParaDest-258"><a id="_idTextAnchor324"/><span class="koboSpan" id="kobo.1.1">16</span></h1>
<h1 id="_idParaDest-259"><a id="_idTextAnchor325"/><span class="koboSpan" id="kobo.2.1">Using SOLID Principles with Hexagonal Architecture</span><a id="_idTextAnchor326"/><a id="_idTextAnchor327"/></h1>
<p><span class="koboSpan" id="kobo.3.1">The idea of having a set of principles to help us develop better software amuses me. </span><span class="koboSpan" id="kobo.3.2">Over the years, programmers have faced many problems; some happened so often that patterns to solve such issues emerged, giving rise to the </span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.4.1">so-called </span><strong class="bold"><span class="koboSpan" id="kobo.5.1">design patterns</span></strong><span class="koboSpan" id="kobo.6.1">. </span><span class="koboSpan" id="kobo.6.2">These patterns have been employed to solve specific software development problems. </span><span class="koboSpan" id="kobo.6.3">Complementing design patterns that act more on recurrent and specific coding problems, ideas have emerged on tackling maintainability problems in software projects. </span><span class="koboSpan" id="kobo.6.4">A remarkable and influential set of those ideas has been synthesized into what is known</span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.7.1"> as </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.8.1">SOLID principles</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">This chapter will explore SOLID principles and how we can tap into them while using hexagonal architecture. </span><span class="koboSpan" id="kobo.10.2">We will start by reviewing each principle, and then we will proceed to see how they can be applied in the context of a hexagonal system. </span><span class="koboSpan" id="kobo.10.3">Finally, we will discuss how design patterns, such as builder and abstract factory, can be used with </span><span class="No-Break"><span class="koboSpan" id="kobo.11.1">hexagonal architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.12.1">The following topics will be covered in </span><span class="No-Break"><span class="koboSpan" id="kobo.13.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.14.1">Understanding </span><span class="No-Break"><span class="koboSpan" id="kobo.15.1">SOLID principles</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Applying SOLID on a hexagonal </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">architecture system</span></span></li>
<li><span class="koboSpan" id="kobo.18.1">Exploring other </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">design patterns</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.20.1">After completing this chapter, you will be able to employ SOLID principles in conjunction with hexagonal architecture techniques. </span><span class="koboSpan" id="kobo.20.2">Also, you will know how to use design patterns, such as chain of responsibility, decorator, builder, and singleton, while developing a </span><span class="No-Break"><span class="koboSpan" id="kobo.21.1">hexagonal system.</span></span></p>
<h1 id="_idParaDest-260"><a id="_idTextAnchor328"/><span class="koboSpan" id="kobo.22.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.23.1">To compile and run the code examples presented in this chapter, you will need the latest </span><strong class="bold"><span class="koboSpan" id="kobo.24.1">Java SE Development Kit</span></strong><span class="koboSpan" id="kobo.25.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.26.1">Maven 3.8</span></strong><span class="koboSpan" id="kobo.27.1"> installed on your computer. </span><span class="koboSpan" id="kobo.27.2">They are available for the Linux, MacOS, and Windows </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">operating systems.</span></span></p>
<p><span class="koboSpan" id="kobo.29.1">You can find the code files for this chapter on GitHub </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">at </span></span><a href="https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16"><span class="No-Break"><span class="koboSpan" id="kobo.31.1">https://github.com/PacktPublishing/-Designing-Hexagonal-Architecture-with-Java---Second-Edition/tree/main/Chapter16</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.32.1">.</span></span></p>
<h1 id="_idParaDest-261"><a id="_idTextAnchor329"/><span class="koboSpan" id="kobo.33.1">Understanding SOLID principles</span></h1>
<p><span class="koboSpan" id="kobo.34.1">Since the advent of </span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.35.1">programming, developers have discussed ideas and captured principles to help develop better software. </span><span class="koboSpan" id="kobo.35.2">These principles arose as a response to help handle highly complex code. </span><span class="koboSpan" id="kobo.35.3">After suffering multiple times from the same recurrent problems, developers started recognizing those problems’ patterns and devised techniques to prevent such issues. </span><span class="koboSpan" id="kobo.35.4">A notable example is</span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.36.1"> the </span><strong class="bold"><span class="koboSpan" id="kobo.37.1">Gang of Four</span></strong><span class="koboSpan" id="kobo.38.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.39.1">GoF</span></strong><span class="koboSpan" id="kobo.40.1">) book on design patterns, which caused a tremendous impact in the object-oriented world and continues to influence generations of developers to this day. </span><span class="koboSpan" id="kobo.40.2">Another remarkable and influential example is the ideas formulated by Robert Martin that led to </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">SOLID principles.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">SOLID stands for the </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">following principles:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.44.1">Single Responsibility </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.45.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.46.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.47.1">SRP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.49.1">Open Closed </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.50.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.51.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.52.1">OCP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.54.1">Liskov Substitution </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.55.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.56.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.57.1">LSP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Interface Segregation </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.60.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.61.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.62.1">ISP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">)</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.64.1">Dependency Inversion </span></strong><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.65.1">Principle</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.66.1"> (</span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.67.1">DIP</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">)</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.69.1">These principles aim to help developers create robust and easy-to-change software through code, based on a set of rules defined by those principles. </span><span class="koboSpan" id="kobo.69.2">I believe that using these principles does not fully guarantee that software is free of maintainability problems. </span><span class="koboSpan" id="kobo.69.3">However, such principles can significantly improve overall code quality. </span><span class="koboSpan" id="kobo.69.4">In essence, it’s all about employing techniques that allow the introduction of changes to a code base in a sustainable way. </span><span class="koboSpan" id="kobo.69.5">I mean, the software will grow, but its complexity will be kept </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">under control.</span></span></p>
<p><span class="koboSpan" id="kobo.71.1">SOLID principles work in a similar way to hexagonal architecture because both aim to provide techniques to develop more maintainable, change-tolerant software. </span><span class="koboSpan" id="kobo.71.2">Therefore, it makes sense to </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.72.1">explore how those principles can be applied in the context of a hexagonal application. </span><span class="koboSpan" id="kobo.72.2">Let’s start our exploration by reviewing each one of the </span><span class="No-Break"><span class="koboSpan" id="kobo.73.1">SOLID principles.</span></span></p>
<h2 id="_idParaDest-262"><a id="_idTextAnchor330"/><span class="koboSpan" id="kobo.74.1">Single Responsibility Principle (SRP)</span></h2>
<p><span class="koboSpan" id="kobo.75.1">It’s not hard for me</span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.76.1"> to remember a </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.77.1">situation where I would witness or be the author of a code change that caused side effects, discovered only after an application was deployed to a staging or, even worse, production environment. </span><span class="koboSpan" id="kobo.77.2">A stakeholder would report problems in the application that started to occur right after the change that caused the side effect was deployed. </span><span class="koboSpan" id="kobo.77.3">So, although the change solved the problem for one stakeholder, it created a problem for another. </span><span class="koboSpan" id="kobo.77.4">Why? </span><span class="koboSpan" id="kobo.77.5">Because the change responsible for the problem has violated the SRP. </span><span class="koboSpan" id="kobo.77.6">The violation occurred because the same system logic served two different stakeholders. </span><span class="koboSpan" id="kobo.77.7">The change solved the problem for one stakeholder but created a side effect that caused trouble for </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">the other.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">An SRP violation can also occur when we define abstractions too early. </span><span class="koboSpan" id="kobo.79.2">Suppose we define an abstract class with certain data and behaviors we believe will be common to all future implementations of that abstract class. </span><span class="koboSpan" id="kobo.79.3">Then, later on, we discover, through an unfortunate incident report, that some data or behavior from that abstract class causes unexpected outcomes in a recent implementation provided by another developer, who assumed the behaviors and data provided by that abstraction would work in the implementation that causes </span><span class="No-Break"><span class="koboSpan" id="kobo.80.1">the trouble.</span></span></p>
<p><span class="koboSpan" id="kobo.81.1">The SRP ensures a method or function is changed based on requests from only one type of stakeholder or actor, usually a department or a line of business in an organization. </span><span class="koboSpan" id="kobo.81.2">It is important to ensure the logic from department A, for example, does not mess up the logic from department B, which can be accomplished by arranging the code in a way that the logic to serve different stakeholders is </span><span class="No-Break"><span class="koboSpan" id="kobo.82.1">adequately separated.</span></span></p>
<h2 id="_idParaDest-263"><a id="_idTextAnchor331"/><span class="koboSpan" id="kobo.83.1">Open-Closed Principle (OCP)</span></h2>
<p><span class="koboSpan" id="kobo.84.1">The idea behind this </span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.85.1">principle lies in increasing what </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.86.1">software can do without changing the existing things in it. </span><span class="koboSpan" id="kobo.86.2">In order to do this, a software component or module should be open for extension but closed for modification. </span><span class="koboSpan" id="kobo.86.3">I can recall an experience where I was implementing a reporting feature. </span><span class="koboSpan" id="kobo.86.4">Instead of having one class to deal with all kinds of reports, I created a base abstract class with basic attributes common to reports. </span><span class="koboSpan" id="kobo.86.5">Every time a new type of report had to be implemented, a new concrete class would be created by implementing the base abstract class. </span><span class="koboSpan" id="kobo.86.6">Additional attributes and functions would be appended to the basic attributes of the base </span><span class="No-Break"><span class="koboSpan" id="kobo.87.1">abstract class.</span></span></p>
<p><span class="koboSpan" id="kobo.88.1">We use the OCP to avoid those situations where we want to add a new feature, and to do so, we also need to change some piece of logic already supporting an existing feature. </span><span class="koboSpan" id="kobo.88.2">By doing that, we violate the OCP. </span><span class="koboSpan" id="kobo.88.3">Instead, we need to arrange code so that we can add new features without modifying the code already serving </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">existing features.</span></span></p>
<h2 id="_idParaDest-264"><a id="_idTextAnchor332"/><span class="koboSpan" id="kobo.90.1">Liskov Substitution Principle (LSP)</span></h2>
<p><span class="koboSpan" id="kobo.91.1">Based on the </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.92.1">reporting example I gave in the </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.93.1">OCP description, let’s suppose we have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">Report</span></strong><span class="koboSpan" id="kobo.95.1"> class containing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">print</span></strong><span class="koboSpan" id="kobo.97.1"> method declaration. </span><span class="koboSpan" id="kobo.97.2">According to a given problem domain, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">print</span></strong><span class="koboSpan" id="kobo.99.1"> method is a behavior supported by any report. </span><span class="koboSpan" id="kobo.99.2">In addition to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">Report</span></strong><span class="koboSpan" id="kobo.101.1"> class, imagine we have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.102.1">WorkdayReport</span></strong><span class="koboSpan" id="kobo.103.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">WeekendReport</span></strong><span class="koboSpan" id="kobo.105.1"> classes extending it. </span><span class="koboSpan" id="kobo.105.2">The LSP prescribes that if we pass objects of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.106.1">WorkdayReport</span></strong><span class="koboSpan" id="kobo.107.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.108.1">WeekendReport</span></strong><span class="koboSpan" id="kobo.109.1"> to a method expecting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">Report</span></strong><span class="koboSpan" id="kobo.111.1"> type, that method will be able to trigger the behaviors inherent to all kinds of reports – in this case, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">print</span></strong><span class="koboSpan" id="kobo.113.1"> method. </span><span class="koboSpan" id="kobo.113.2">The bottom line is that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">Report</span></strong><span class="koboSpan" id="kobo.115.1"> type should be designed so that its declared methods, when overridden for sub-types, should be coherent with the </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">subtype’s purpose.</span></span></p>
<h2 id="_idParaDest-265"><a id="_idTextAnchor333"/><span class="koboSpan" id="kobo.117.1">Interface Segregation Principle (ISP)</span></h2>
<p><span class="koboSpan" id="kobo.118.1">The ISP is </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.119.1">helpful whenever we want to</span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.120.1"> provide clients with an interface containing only the method declarations they need. </span><span class="koboSpan" id="kobo.120.2">This principle is usually employed when we have a single interface with many method declarations, and a given client only implements some methods and provides dummy implementations for those they don’t need. </span><span class="koboSpan" id="kobo.120.3">By employing the ISP, we break that single interface with multiple interfaces tailored for</span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.121.1"> specific </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">client needs.</span></span></p>
<h2 id="_idParaDest-266"><a id="_idTextAnchor334"/><span class="koboSpan" id="kobo.123.1">Dependency Inversion Principle (DIP)</span></h2>
<p><span class="koboSpan" id="kobo.124.1">Stable and </span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.125.1">unstable software components</span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.126.1"> have distinct concepts. </span><em class="italic"><span class="koboSpan" id="kobo.127.1">Stable</span></em><span class="koboSpan" id="kobo.128.1"> means those components that don’t change too often, while </span><em class="italic"><span class="koboSpan" id="kobo.129.1">unstable</span></em><span class="koboSpan" id="kobo.130.1"> is the opposite. </span><span class="koboSpan" id="kobo.130.2">Having a client component depending directly on an unstable component may be risky because changes in unstable code can trigger changes in the client. </span><span class="koboSpan" id="kobo.130.3">Most of the time, the unstable component is a concrete class with implementation details that don’t need to be exposed to </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">its clients.</span></span></p>
<p><span class="koboSpan" id="kobo.132.1">To avoid exposing such implementation details and protect the client from dependency changes, DIP prescribes that clients should always depend on abstractions rather than concretions. </span><span class="koboSpan" id="kobo.132.2">The unstable component – a concrete class with implementation details – should derive from an abstraction by implementing an interface, for example. </span><span class="koboSpan" id="kobo.132.3">Then, the client should rely on a stable component, an interface implemented by the unstable component (a concrete class). </span><span class="koboSpan" id="kobo.132.4">We call an interface a stable component because it acts as a contract, and contracts are less susceptible </span><span class="No-Break"><span class="koboSpan" id="kobo.133.1">to change.</span></span></p>
<p><span class="koboSpan" id="kobo.134.1">Let’s see in the next section how we can apply SOLID principles to an application developed using </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">hexagonal architecture.</span></span></p>
<h1 id="_idParaDest-267"><a id="_idTextAnchor335"/><span class="koboSpan" id="kobo.136.1">Applying SOLID on a hexagonal architecture system</span></h1>
<p><span class="koboSpan" id="kobo.137.1">To see how each</span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.138.1"> SOLID principle </span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.139.1">is applied, we will go back to the topology and inventory system we have developed throughout the book. </span><span class="koboSpan" id="kobo.139.2">Let’s start by seeing how the SRP can be applied in the topology and </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">inventory system.</span></span></p>
<h2 id="_idParaDest-268"><a id="_idTextAnchor336"/><span class="koboSpan" id="kobo.141.1">Applying the SRP</span></h2>
<p><span class="koboSpan" id="kobo.142.1">Just to recap, the</span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.143.1"> topology </span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.144.1">and inventory system manages network resources such as routers and switches. </span><span class="koboSpan" id="kobo.144.2">Such a system is suited for telecommunication </span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.145.1">or </span><strong class="bold"><span class="koboSpan" id="kobo.146.1">Internet Service Provider</span></strong><span class="koboSpan" id="kobo.147.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.148.1">ISP</span></strong><span class="koboSpan" id="kobo.149.1">) companies that want to keep an inventory of the network resources they use to serve </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">their customers.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">In the topology and inventory system, we have core and edge routers. </span><span class="koboSpan" id="kobo.151.2">Core routers handle high-load network traffic from one or more edge routers. </span><span class="koboSpan" id="kobo.151.3">Edge routers are used to handle traffic from end users. </span><span class="koboSpan" id="kobo.151.4">Edge routers connect to </span><span class="No-Break"><span class="koboSpan" id="kobo.152.1">network switches.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">Consider a scenario where core and edge routers change locations. </span><span class="koboSpan" id="kobo.153.2">For example, a core router that is now localized in France needs, for some reason, to be re-provisioned in Italy, and an edge router that is in Frankfurt needs to be re-provisioned in Berlin. </span><span class="koboSpan" id="kobo.153.3">Consider also that network changes across countries are handled by actor A, and network changes across cities are handled by </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">actor B.</span></span></p>
<p><span class="koboSpan" id="kobo.155.1">Let’s change the topology and inventory application to fulfill the described requirement. </span><span class="koboSpan" id="kobo.155.2">The changes </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.156.1">described as follows </span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.157.1">are made in the </span><span class="No-Break"><span class="koboSpan" id="kobo.158.1">Domain hexagon:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.159.1">Create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">AllowedCountrySpec</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.161.1">specification class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.162.1">
public final class AllowedCountrySpec extends Ab
  stractSpecification&lt;Location&gt; {
    private List&lt;String&gt; allowedCountries =
    List.of(
    "Germany", "France", "Italy", "United States");
    @Override
    public boolean isSatisfiedBy(Location location) {
        return allowedCountries
                .stream()
                .anyMatch(
                 allowedCountry -&gt; allowedCountry
                 .equals(location.country()));
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.163.1">This specification limits which countries can be chosen through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">allowedCountries</span></strong><span class="koboSpan" id="kobo.165.1"> attribute. </span><span class="koboSpan" id="kobo.165.2">That’s not how you should represent it in a real application, but it is enough to illustrate the </span><span class="No-Break"><span class="koboSpan" id="kobo.166.1">SRP idea.</span></span></p></li> <li><span class="koboSpan" id="kobo.167.1">Now, create</span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.168.1"> the </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">AllowedCitySpec</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.170.1">specification</span></span><span class="No-Break"><a id="_idIndexMarker1035"/></span><span class="No-Break"><span class="koboSpan" id="kobo.171.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.172.1">
public final class AllowedCitySpec extends Ab
  stractSpecification&lt;Location&gt; {
    private List&lt;String&gt; allowedCities =
    List.of(
    "Berlin", "Paris", "Rome", "New York");
    @Override
    public oolean isSatisfiedBy(Location location) {
        return allowedCities
                .stream()
                .anyMatch(
                 allowedCountry -&gt; allowedCountry
                .equals(location.city()));
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.173.1">Following the same idea from the previous specification, here we limit which cities are allowed through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">allowedCities</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.175.1"> attribute.</span></span></p></li> <li><span class="koboSpan" id="kobo.176.1">Declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">changeLocation</span></strong><span class="koboSpan" id="kobo.178.1"> method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.179.1">Router</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.180.1">abstract class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.181.1">
public abstract sealed class Router extends Equipment
  permits CoreRouter, EdgeRouter {
   /** Code omitted **/
   public abstract void changeLocation(
   Location location);
   /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.182.1">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">Router</span></strong><span class="koboSpan" id="kobo.184.1"> is an abstract sealed class, allowing only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.186.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.188.1"> classes to </span><span class="No-Break"><span class="koboSpan" id="kobo.189.1">implement it.</span></span></p></li> <li><span class="koboSpan" id="kobo.190.1">Provide</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.191.1"> an implementation</span><a id="_idIndexMarker1037"/> <span class="No-Break"><span class="koboSpan" id="kobo.192.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">CoreRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.195.1">
@Override
public void changeLocation(Location location) {
    var allowedCountrySpec = new AllowedCountrySpec();
    allowedCountrySpec.check(location);
    this.location = location;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.196.1">We use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">AllowedCountrySpec</span></strong><span class="koboSpan" id="kobo.198.1"> to check whether the new router </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">Location</span></strong><span class="koboSpan" id="kobo.200.1"> is allowed. </span><span class="koboSpan" id="kobo.200.2">If a non-allowed country is provided, an exception is thrown. </span><span class="koboSpan" id="kobo.200.3">Otherwise, the new location is assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">location</span></strong><span class="koboSpan" id="kobo.202.1"> variable from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.204.1"> object.</span></span></p></li> <li><span class="koboSpan" id="kobo.205.1">Provide an implementation </span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">for </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">EdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.208.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.209.1">
@Override
public void changeLocation(Location location) {
    var allowedCountrySpec = new AllowedCountrySpec();
    var allowedCitySpec = new AllowedCitySpec();
    allowedCountrySpec.check(location);
    allowedCitySpec.check(location);
    this.location = location;
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.210.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.212.1"> implementation is slightly different. </span><span class="koboSpan" id="kobo.212.2">In addition to </span><strong class="source-inline"><span class="koboSpan" id="kobo.213.1">AllowedCountrySpec</span></strong><span class="koboSpan" id="kobo.214.1">, we also have </span><strong class="source-inline"><span class="koboSpan" id="kobo.215.1">AllowedCitySpec</span></strong><span class="koboSpan" id="kobo.216.1">. </span><span class="koboSpan" id="kobo.216.2">A new </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">Location</span></strong><span class="koboSpan" id="kobo.218.1"> will be assigned to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Router</span></strong><span class="koboSpan" id="kobo.220.1"> object only after fulfilling these </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">two specifications.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.222.1">Let’s review what we have done here. </span><span class="koboSpan" id="kobo.222.2">We started by creating the </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">AllowedCountrySpec</span></strong><span class="koboSpan" id="kobo.224.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">AllowedCitySpec</span></strong><span class="koboSpan" id="kobo.226.1"> specifications; then, we declared the </span><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">changeLocation</span></strong><span class="koboSpan" id="kobo.228.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Router</span></strong><span class="koboSpan" id="kobo.230.1"> abstract class. </span><span class="koboSpan" id="kobo.230.2">As both </span><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.232.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.233.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.234.1"> implement this class, we had to override the </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">changeLocation</span></strong><span class="koboSpan" id="kobo.236.1"> method to serve the needs of actor A and actor B. </span><span class="koboSpan" id="kobo.236.2">Actor A is responsible for handling location changes across countries – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.237.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.238.1">. </span><span class="koboSpan" id="kobo.238.2">Actor B is in charge of handling location changes across cities, which is the responsibility </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">EdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">’.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.242.1">Suppose that instead of declaring </span><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">changeLocation</span></strong><span class="koboSpan" id="kobo.244.1"> as abstract, we provided a concrete</span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.245.1"> implementation</span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.246.1"> shared by both the </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.248.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.249.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.250.1"> classes. </span><span class="koboSpan" id="kobo.250.2">That would violate the SRP because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.251.1">changeLocation</span></strong><span class="koboSpan" id="kobo.252.1"> logic would serve </span><span class="No-Break"><span class="koboSpan" id="kobo.253.1">different actors.</span></span></p></li> </ol>
<h2 id="_idParaDest-269"><a id="_idTextAnchor337"/><span class="koboSpan" id="kobo.254.1">Applying the OCP</span></h2>
<p><span class="koboSpan" id="kobo.255.1">We have not </span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.256.1">stated it yet, but</span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.257.1"> the arrangement between the </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">Router</span></strong><span class="koboSpan" id="kobo.259.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.261.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.262.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.263.1"> classes represents an application of the OCP. </span><span class="koboSpan" id="kobo.263.2">Observe the following Unified Modeling Language (</span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">UML) diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer089">
<span class="koboSpan" id="kobo.265.1"><img alt="Figure 16.1 – Applying the OCP" src="image/B19777_16_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.266.1">Figure 16.1 – Applying the OCP</span></p>
<p><span class="koboSpan" id="kobo.267.1">The OCP ensures that a module or component is closed for change but open for extension. </span><span class="koboSpan" id="kobo.267.2">Instead of providing a class design where one single class would contain the logic to handle both core and edge routers, we leverage the inheritance capability from Java to extend the </span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.268.1">possibilities of </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.269.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.270.1">Router</span></strong><span class="koboSpan" id="kobo.271.1"> abstract class, without changing its attributes and behaviors. </span><span class="koboSpan" id="kobo.271.2">Such extensions are possible through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.272.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.273.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.275.1"> concrete </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">class implementations.</span></span></p>
<h2 id="_idParaDest-270"><a id="_idTextAnchor338"/><span class="koboSpan" id="kobo.277.1">Applying the LSP</span></h2>
<p><span class="koboSpan" id="kobo.278.1">To demonstrate </span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.279.1">the application </span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.280.1">of the LSP, we need to make more changes in the topology and inventory system. </span><span class="koboSpan" id="kobo.280.2">While applying the SRP and OCP, we changed the Domain hexagon. </span><span class="koboSpan" id="kobo.280.3">Now, we will make changes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">Application hexagon:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.282.1">Declare the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">changeLocation</span></strong><span class="koboSpan" id="kobo.284.1"> method in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.285.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.286.1"> interface:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.287.1">
public interface RouterManagementUseCase {
    /** Code omitted **/
    Router changeLocation(
    Router router, Location location);
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.288.1">Changing a router’s location is a new use case that we add to the topology and inventory system, so we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">changeLocation</span></strong><span class="koboSpan" id="kobo.290.1"> method declaration to express that </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">use case.</span></span></p></li> <li><span class="koboSpan" id="kobo.292.1">Implement </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.293.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">changeLocation</span></strong><span class="koboSpan" id="kobo.295.1"> method</span><a id="_idIndexMarker1047"/> <span class="No-Break"><span class="koboSpan" id="kobo.296.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.297.1">RouterManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.299.1">
public class RouterManagementInputPort implements
  RouterManagementUseCase {
    /** Code omitted **/
    @Override
    public Router changeLocation(Router router,
    Location location) {
        router.changeLocation(location);
        return persistRouter(router);
    }
    /** Code omitted **/
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.300.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.301.1">changeLocation</span></strong><span class="koboSpan" id="kobo.302.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.303.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.304.1"> calls </span><strong class="source-inline"><span class="koboSpan" id="kobo.305.1">changeLocation</span></strong><span class="koboSpan" id="kobo.306.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.307.1">Router</span></strong><span class="koboSpan" id="kobo.308.1"> by passing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.309.1">Location</span></strong><span class="koboSpan" id="kobo.310.1"> object. </span><strong class="source-inline"><span class="koboSpan" id="kobo.311.1">changeLocation</span></strong><span class="koboSpan" id="kobo.312.1"> from </span><strong class="source-inline"><span class="koboSpan" id="kobo.313.1">Router</span></strong><span class="koboSpan" id="kobo.314.1"> has a logic that checks whether the provided </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">Location</span></strong><span class="koboSpan" id="kobo.316.1"> is allowed. </span><span class="koboSpan" id="kobo.316.2">If everything is fine, we call </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">persitRouter</span></strong><span class="koboSpan" id="kobo.318.1"> to persist </span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">Router</span></strong><span class="koboSpan" id="kobo.320.1"> with its </span><span class="No-Break"><span class="koboSpan" id="kobo.321.1">new </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">Location</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.324.1">The LSP application can be observed when we implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">changeLocation</span></strong><span class="koboSpan" id="kobo.326.1"> method in </span><strong class="source-inline"><span class="koboSpan" id="kobo.327.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.328.1">. </span><span class="koboSpan" id="kobo.328.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">changeLocation</span></strong><span class="koboSpan" id="kobo.330.1"> expects a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">Router</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.332.1"> type:</span></span></p><pre class="source-code"><span class="koboSpan" id="kobo.333.1">public Router changeLocation(Router router,
  Location location) {
    router.changeLocation(location);
    return persistRouter(router);
}</span></pre></li> </ol>
<p><span class="koboSpan" id="kobo.334.1">It means we can pass here either a </span><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.336.1"> or an </span><strong class="source-inline"><span class="koboSpan" id="kobo.337.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.338.1"> object because both </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.339.1">extend </span><strong class="source-inline"><span class="koboSpan" id="kobo.340.1">Router</span></strong><span class="koboSpan" id="kobo.341.1">, and both </span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.342.1">provide an implementation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">changeLocation</span></strong><span class="koboSpan" id="kobo.344.1">, a behavior inherent to </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">all routers.</span></span></p>
<h2 id="_idParaDest-271"><a id="_idTextAnchor339"/><span class="koboSpan" id="kobo.346.1">Applying the ISP</span></h2>
<p><span class="koboSpan" id="kobo.347.1">While applying</span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.348.1"> the LSP, we </span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.349.1">created </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.351.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.353.1"> in the Application hexagon. </span><span class="koboSpan" id="kobo.353.2">Let’s finish our implementation by providing an input adapter in the Framework hexagon to connect the input adapter to the </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">input port:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.355.1">Implement the </span><strong class="source-inline"><span class="koboSpan" id="kobo.356.1">changeLocation</span></strong><span class="koboSpan" id="kobo.357.1"> method in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">RouterManagementAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.359.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.360.1">
@Transactional
@POST
@Path("/changeLocation/{routerId}")
@Operation(operationId = "changeLocation", description
  = "Change a router location")
public Uni&lt;Response&gt; changeLocation(@PathParam
  ("routerId") String routerId, LocationChange loca
    tionChange) {
    Router router = routerManagementUseCase
       .retrieveRouter(Id.withId(routerId));
    Location location =
        locationChange.mapToDomain();
        return Uni.createFrom()
       .item(routerManagementUseCase.changeLocation(ro
        uter, location))
       .onItem()
       .transform(f -&gt; f != null ? </span><span class="koboSpan" id="kobo.360.2">Response.ok(f) :
              Response.ok(null))
             .onItem()
             .transform(
                Response.ResponseBuilder::build);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.361.1">With </span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.362.1">the </span><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">POST</span></strong><span class="koboSpan" id="kobo.364.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">PATH</span></strong><span class="koboSpan" id="kobo.366.1"> annotations, we</span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.367.1"> turn this method into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">REST</span></strong><span class="koboSpan" id="kobo.369.1"> endpoint to receive requests sent to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.370.1">/router/changeLocation/{routerId}</span></strong><span class="koboSpan" id="kobo.371.1"> URI. </span><span class="koboSpan" id="kobo.371.2">The router part of the URI comes from the top-level definition of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.372.1">PATH</span></strong><span class="koboSpan" id="kobo.373.1"> annotation of the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">RouterManagementAdapter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.375.1"> class.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.376.1">This input adapter gets </span><strong class="source-inline"><span class="koboSpan" id="kobo.377.1">Router</span></strong><span class="koboSpan" id="kobo.378.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.379.1">retrieveRouter</span></strong><span class="koboSpan" id="kobo.380.1"> method from </span><strong class="source-inline"><span class="koboSpan" id="kobo.381.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.382.1">. </span><span class="koboSpan" id="kobo.382.2">Then, it converts the </span><strong class="source-inline"><span class="koboSpan" id="kobo.383.1">LocationRequest</span></strong><span class="koboSpan" id="kobo.384.1"> object into a </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">Location</span></strong><span class="koboSpan" id="kobo.386.1"> domain object. </span><span class="koboSpan" id="kobo.386.2">Finally, it passes </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">Router</span></strong><span class="koboSpan" id="kobo.388.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.389.1">Location</span></strong><span class="koboSpan" id="kobo.390.1"> to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">changeLocation</span></strong><span class="koboSpan" id="kobo.392.1"> method </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">RouterManagementUseCase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">.</span></span></p><p class="list-inset"><span class="koboSpan" id="kobo.396.1">To confirm that our implementation works, let’s implement a test to check the </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">entire flow.</span></span></p></li> <li><span class="koboSpan" id="kobo.398.1">Implement the</span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.399.1"> following</span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.400.1"> test in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">RouterManagementAdapterTest</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> class:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.403.1">
@Test
public void changeLocation() throws IOException {
    var routerId =
        "b832ef4f-f894-4194-8feb-a99c2cd4be0c";
    var expectedCountry = "Germany";
    var location = createLocation("Germany",
        "Berlin");
    var updatedRouterStr = given()
          .contentType("application/json")
          .pathParam("routerId", routerId)
          .body(location)
          .when()
          .post("/router/changeLocation/{routerId}")
          .then()
          .statusCode(200)
          .extract()
          .asString();
    var changedCountry =
    getRouterDeserialized(
    updatedRouterStr).getLocation().country();
    assertEquals(expectedCountry, changedCountry);
}</span></pre><p class="list-inset"><span class="koboSpan" id="kobo.404.1">This test changes the location of the Router, which is a core router located in the United States. </span><span class="koboSpan" id="kobo.404.2">After sending a </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">POST</span></strong><span class="koboSpan" id="kobo.406.1"> request containing a </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">Location</span></strong><span class="koboSpan" id="kobo.408.1"> object with </span><strong class="source-inline"><span class="koboSpan" id="kobo.409.1">Germany</span></strong><span class="koboSpan" id="kobo.410.1"> as the country and </span><strong class="source-inline"><span class="koboSpan" id="kobo.411.1">Berlin</span></strong><span class="koboSpan" id="kobo.412.1"> as the city, we run an assertion to ensure that the returned </span><strong class="source-inline"><span class="koboSpan" id="kobo.413.1">Router</span></strong><span class="koboSpan" id="kobo.414.1"> object has the changed location – Germany instead of the </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">United States.</span></span></p></li> </ol>
<p><span class="koboSpan" id="kobo.416.1">The ISP can be observed in making use-case operations available to the input adapter. </span><span class="koboSpan" id="kobo.416.2">We have the </span><strong class="source-inline"><span class="koboSpan" id="kobo.417.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.418.1"> class implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.419.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.420.1"> interface. </span><span class="koboSpan" id="kobo.420.2">The ISP is employed because all method declarations </span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.421.1">from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.423.1"> interface </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.424.1">are relevant and implemented </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.426.1">RouterManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.427.1">.</span></span></p>
<h2 id="_idParaDest-272"><a id="_idTextAnchor340"/><span class="koboSpan" id="kobo.428.1">Applying the DIP</span></h2>
<p><span class="koboSpan" id="kobo.429.1">We discussed </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.430.1">dependency</span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.431.1"> inversion in </span><a href="B19777_09.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.432.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.433.1">, </span><em class="italic"><span class="koboSpan" id="kobo.434.1">Applying Dependency Inversion with Java Modules</span></em><span class="koboSpan" id="kobo.435.1">, where we used the </span><strong class="bold"><span class="koboSpan" id="kobo.436.1">Java Platform Module System</span></strong><span class="koboSpan" id="kobo.437.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.438.1">JPMS</span></strong><span class="koboSpan" id="kobo.439.1">) to</span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.440.1"> apply dependency inversion. </span><span class="koboSpan" id="kobo.440.2">To recap, let’s review the </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer090">
<span class="koboSpan" id="kobo.442.1"><img alt="Figure 16.2 – Reviewing dependency inversion" src="image/B19777_16_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.443.1">Figure 16.2 – Reviewing dependency inversion</span></p>
<p><span class="koboSpan" id="kobo.444.1">The DIP states </span><a id="_idIndexMarker1061"/><span class="koboSpan" id="kobo.445.1">that clients should </span><a id="_idIndexMarker1062"/><span class="koboSpan" id="kobo.446.1">always depend on abstractions rather than concretions. </span><span class="koboSpan" id="kobo.446.2">That is precisely what we are doing by making </span><strong class="source-inline"><span class="koboSpan" id="kobo.447.1">RouterManagementAdapter</span></strong><span class="koboSpan" id="kobo.448.1"> depend on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.449.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.450.1"> interface, rather than the </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">RouterManagementInputPort</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.452.1">concrete class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.453.1">
public class RouterManagementAdapter {
    @Inject
    RouterManagementUseCase routerManagementUseCase;
    /** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.454.1">In </span><a href="B19777_09.xhtml#_idTextAnchor192"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.455.1">Chapter 9</span></em></span></a><span class="koboSpan" id="kobo.456.1">, </span><em class="italic"><span class="koboSpan" id="kobo.457.1">Applying Dependency Inversion with Java Modules</span></em><span class="koboSpan" id="kobo.458.1">, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.459.1">RouterManagementUseCase</span></strong><span class="koboSpan" id="kobo.460.1"> interface implementation – a </span><strong class="source-inline"><span class="koboSpan" id="kobo.461.1">RouterManagementInputPort</span></strong><span class="koboSpan" id="kobo.462.1"> object – is provided by the JPMS. </span><span class="koboSpan" id="kobo.462.2">In the current implementation, we use Quarkus with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.463.1">@Inject</span></strong><span class="koboSpan" id="kobo.464.1"> annotation</span><a id="_idIndexMarker1063"/><span class="koboSpan" id="kobo.465.1"> to </span><a id="_idIndexMarker1064"/><span class="No-Break"><span class="koboSpan" id="kobo.466.1">provide </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">RouterManagementInputPort</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.468.1">.</span></span></p>
<h1 id="_idParaDest-273"><a id="_idTextAnchor341"/><span class="koboSpan" id="kobo.469.1">Exploring other design patterns</span></h1>
<p><span class="koboSpan" id="kobo.470.1">In previous chapters, we </span><a id="_idIndexMarker1065"/><span class="koboSpan" id="kobo.471.1">applied some design patterns while developing the topology and inventory system. </span><span class="koboSpan" id="kobo.471.2">These patterns helped us arrange code to support application needs better. </span><span class="koboSpan" id="kobo.471.3">So, in this section, we will review the design patterns we applied while implementing </span><span class="No-Break"><span class="koboSpan" id="kobo.472.1">hexagonal architecture.</span></span></p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor342"/><span class="koboSpan" id="kobo.473.1">Singleton</span></h2>
<p><span class="koboSpan" id="kobo.474.1">Before </span><a id="_idIndexMarker1066"/><span class="koboSpan" id="kobo.475.1">introducing Quarkus to our topology and inventory </span><a id="_idIndexMarker1067"/><span class="koboSpan" id="kobo.476.1">system, we had to provide our own mechanism to create a single database connection object. </span><span class="koboSpan" id="kobo.476.2">When handling database-based connections, it’s common to have just one instance that connects to a database and shares that connection with </span><span class="No-Break"><span class="koboSpan" id="kobo.477.1">other objects.</span></span></p>
<p><span class="koboSpan" id="kobo.478.1">Singleton is the pattern we used to create a single database connection instance, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.479.1">following example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.480.1">
public class RouterNetworkH2Adapter implements RouterNet
  workOutputPort {
    private static RouterNetworkH2Adapter instance;
    @PersistenceContext
    private EntityManager em;
    private RouterNetworkH2Adapter(){
        setUpH2Database();
    }
    private void setUpH2Database() {
        EntityManagerFactory entityManagerFactory =
        Persistence.createEntityManagerFactory
          ("inventory");
        EntityManager em =
        entityManagerFactory.createEntityManager();
        this.em = em;
    }
    public static RouterNetworkH2Adapter getInstance() {
        if (instance == null) {
            instance = new RouterNetworkH2Adapter();
        }
        return instance;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.481.1">To ensure only an object is created, we create a private constructor to prevent clients from creating additional instances. </span><span class="koboSpan" id="kobo.481.2">The object creation is handled by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">getInstance</span></strong><span class="koboSpan" id="kobo.483.1"> method, which checks whether the instance attribute is </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">null.</span></strong><span class="koboSpan" id="kobo.485.1"> If it is </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">null</span></strong><span class="koboSpan" id="kobo.487.1">, then it creates a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">RouterNetworkH2Adapter</span></strong><span class="koboSpan" id="kobo.489.1"> and assigns it to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">instance</span></strong><span class="koboSpan" id="kobo.491.1"> variable. </span><span class="koboSpan" id="kobo.491.2">The private constructor then creates a database connection </span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">using </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.493.1">EntityManagerFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">When </span><a id="_idIndexMarker1068"/><span class="koboSpan" id="kobo.496.1">executing </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">getInstance</span></strong><span class="koboSpan" id="kobo.498.1"> for</span><a id="_idIndexMarker1069"/><span class="koboSpan" id="kobo.499.1"> a second time, instead of creating a new </span><strong class="source-inline"><span class="koboSpan" id="kobo.500.1">RouterNetworkH2Adapter</span></strong><span class="koboSpan" id="kobo.501.1">, we return the existing instance </span><span class="No-Break"><span class="koboSpan" id="kobo.502.1">created previously.</span></span></p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor343"/><span class="koboSpan" id="kobo.503.1">Builder</span></h2>
<p><span class="koboSpan" id="kobo.504.1">Builder is a design </span><a id="_idIndexMarker1070"/><span class="koboSpan" id="kobo.505.1">pattern that helps us expressively create </span><a id="_idIndexMarker1071"/><span class="koboSpan" id="kobo.506.1">complex objects. </span><span class="koboSpan" id="kobo.506.2">It’s intended for scenarios with constructors with many parameters and different ways to make the same object. </span><span class="koboSpan" id="kobo.506.3">We have used that design pattern to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.507.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.508.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.509.1">EdgeRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.510.1"> objects.</span></span></p>
<p><span class="koboSpan" id="kobo.511.1">Consider the following example, where we create an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.512.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.513.1"> using </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">its constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.515.1">
var router = new CoreRouter(
                  id,
                  parentRouterId,
                  vendor,
                  model,
                  ip,
                  location,
                  routerType,
                  routers);</span></pre> <p><span class="koboSpan" id="kobo.516.1">One of the drawbacks of using the constructor directly is that we need to know how to pass the parameters in the correct order. </span><span class="koboSpan" id="kobo.516.2">In the previous example, we must pass first </span><strong class="source-inline"><span class="koboSpan" id="kobo.517.1">id</span></strong><span class="koboSpan" id="kobo.518.1">, then </span><strong class="source-inline"><span class="koboSpan" id="kobo.519.1">parentRouterId</span></strong><span class="koboSpan" id="kobo.520.1">, and </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.522.1">Now, let’s see the object creation </span><span class="No-Break"><span class="koboSpan" id="kobo.523.1">using builder:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.524.1">
var router = CoreRouter.builder()
              .id(id == null ? </span><span class="koboSpan" id="kobo.524.2">Id.withoutId() : id)
              .vendor(vendor)
              .model(model)
              .ip(ip)
              .location(location)
              .routerType(routerType)
              .build();</span></pre> <p><span class="koboSpan" id="kobo.525.1">Other than skipping some parameters such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.526.1">parentRouterId</span></strong><span class="koboSpan" id="kobo.527.1">, we pass the parameters in any order through builder methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">vendor</span></strong><span class="koboSpan" id="kobo.529.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">model</span></strong><span class="koboSpan" id="kobo.531.1">. </span><span class="koboSpan" id="kobo.531.2">Once we are done, we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.532.1">build</span></strong><span class="koboSpan" id="kobo.533.1"> method to return the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.534.1">CoreRouter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.535.1"> instance.</span></span></p>
<p><span class="koboSpan" id="kobo.536.1">Throughout the book, we have not provided a custom builder implementation. </span><span class="koboSpan" id="kobo.536.2">Instead, we relied on the helpful Lombok libraries to create builders by simply adding the </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">Builder</span></strong><span class="koboSpan" id="kobo.538.1"> annotation to the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">class’s constructor:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.540.1">
@Builder
public CoreRouter(Id id, Id parentRouterId, Vendor vendor,
  Model model, IP ip, Location location, RouterType router
    Type, Map&lt;Id, Router&gt; routers) {
/** Code omitted **/
}</span></pre> <p><span class="koboSpan" id="kobo.541.1">Lombok is probably enough for you if you don’t have special requirements for how your objects should be created. </span><span class="koboSpan" id="kobo.541.2">Otherwise, you can implement your own builder mechanism. </span><span class="koboSpan" id="kobo.541.3">That is usually</span><a id="_idIndexMarker1072"/><span class="koboSpan" id="kobo.542.1"> done </span><a id="_idIndexMarker1073"/><span class="koboSpan" id="kobo.543.1">when you want to define mandatory or optional parameters and other rules for </span><span class="No-Break"><span class="koboSpan" id="kobo.544.1">object creation.</span></span></p>
<h2 id="_idParaDest-276"><a id="_idTextAnchor344"/><span class="koboSpan" id="kobo.545.1">Abstract factory</span></h2>
<p><span class="koboSpan" id="kobo.546.1">We discussed in</span><a id="_idIndexMarker1074"/><span class="koboSpan" id="kobo.547.1"> the </span><a id="_idIndexMarker1075"/><span class="koboSpan" id="kobo.548.1">previous section how applying the LSP enables us to pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.549.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.550.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.552.1"> object to a method expecting a </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">Router</span></strong><span class="koboSpan" id="kobo.554.1"> type, and then we can use that object without any issues. </span><span class="koboSpan" id="kobo.554.2">The abstract factory pattern comes into play whenever we need to create </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.556.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.558.1"> objects. </span><span class="koboSpan" id="kobo.558.2">We did so when we implemented the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.559.1">RouterFactory</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.560.1"> class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.561.1">
public class RouterFactory {
    public static Router getRouter(Id id,
                                   Vendor vendor,
                                   Model model,
                                   IP ip,
                                   Location location,
                                   RouterType routerType){
        switch (routerType) {
            case CORE -&gt; {
                 return CoreRouter.builder().
</span><span class="koboSpan" id="kobo.561.2">                     Id(id == null ? </span><span class="koboSpan" id="kobo.561.3">Id.withoutId() : id).
</span><span class="koboSpan" id="kobo.561.4">                     Vendor(vendor).
</span><span class="koboSpan" id="kobo.561.5">                     Model(model).
</span><span class="koboSpan" id="kobo.561.6">                     Ip(ip).
</span><span class="koboSpan" id="kobo.561.7">                     Location(location).
</span><span class="koboSpan" id="kobo.561.8">                     routerType(routerType).
</span><span class="koboSpan" id="kobo.561.9">                     Build();
            }
            case EDGE -&gt; {
                 return EdgeRouter.builder().
</span><span class="koboSpan" id="kobo.561.10">                     Id(id==null ? </span><span class="koboSpan" id="kobo.561.11">Id.withoutId():id).
</span><span class="koboSpan" id="kobo.561.12">                     Vendor(vendor).
</span><span class="koboSpan" id="kobo.561.13">                     Model(model).
</span><span class="koboSpan" id="kobo.561.14">                     Ip(ip).
</span><span class="koboSpan" id="kobo.561.15">                     Location(location).
</span><span class="koboSpan" id="kobo.561.16">                     routerType(routerType).
</span><span class="koboSpan" id="kobo.561.17">                     Build();
            }
            default -&gt; throw new
            UnsupportedOperationException(
            "No valid router type informed");
        }
    }
}</span></pre> <p><span class="koboSpan" id="kobo.562.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">RouterFactory</span></strong><span class="koboSpan" id="kobo.564.1"> class contains only the </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">getRouter</span></strong><span class="koboSpan" id="kobo.566.1"> method, which receives some parameters required to create code and edge routers and returns an object of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">Router</span></strong><span class="koboSpan" id="kobo.568.1">. </span><span class="koboSpan" id="kobo.568.2">Note that we pass a </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">RouterType</span></strong><span class="koboSpan" id="kobo.570.1"> parameter used in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">switch</span></strong><span class="koboSpan" id="kobo.572.1"> statement to identify which kind of router needs to be created, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">CoreRouter</span></strong><span class="koboSpan" id="kobo.574.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">EdgeRouter</span></strong><span class="koboSpan" id="kobo.576.1">. </span><span class="koboSpan" id="kobo.576.2">Regardless</span><a id="_idIndexMarker1076"/><span class="koboSpan" id="kobo.577.1"> of the specific router subtype, we</span><a id="_idIndexMarker1077"/><span class="koboSpan" id="kobo.578.1"> always return it as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">Router</span></strong><span class="koboSpan" id="kobo.580.1"> supertype for use, for example, in scenarios where the LSP can </span><span class="No-Break"><span class="koboSpan" id="kobo.581.1">be applied.</span></span></p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor345"/><span class="koboSpan" id="kobo.582.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.583.1">This chapter allowed us to explore how SOLID principles can be employed together with hexagonal architecture. </span><span class="koboSpan" id="kobo.583.2">We also reviewed our design patterns while implementing the topology and inventory system. </span><span class="koboSpan" id="kobo.583.3">We started by briefly discussing </span><span class="No-Break"><span class="koboSpan" id="kobo.584.1">SOLID principles.</span></span></p>
<p><span class="koboSpan" id="kobo.585.1">After getting a basic understanding of the principles, we moved on to see how they can be applied in the context of a hexagonal application. </span><span class="koboSpan" id="kobo.585.2">We then implemented the change router location feature to the topology and inventory system. </span><span class="koboSpan" id="kobo.585.3">Finally, we reviewed how design patterns such as builder, singleton, and abstract factory are employed while designing the </span><span class="No-Break"><span class="koboSpan" id="kobo.586.1">hexagonal system.</span></span></p>
<p><span class="koboSpan" id="kobo.587.1">The next and final chapter will explore further design practices to help us build </span><span class="No-Break"><span class="koboSpan" id="kobo.588.1">better software.</span></span></p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor346"/><span class="koboSpan" id="kobo.589.1">Questions</span></h1>
<ol>
<li><span class="koboSpan" id="kobo.590.1">What does OCP stand for, and what is </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">its purpose?</span></span></li>
<li><span class="koboSpan" id="kobo.592.1">What is the goal of </span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">the DIP?</span></span></li>
<li><span class="koboSpan" id="kobo.594.1">Which design pattern can support </span><span class="No-Break"><span class="koboSpan" id="kobo.595.1">the LSP?</span></span></li>
</ol>
<h1 id="_idParaDest-279"><a id="_idTextAnchor347"/><span class="koboSpan" id="kobo.596.1">Answers</span></h1>
<ol>
<li value="1"><span class="koboSpan" id="kobo.597.1">It stands for the </span><strong class="bold"><span class="koboSpan" id="kobo.598.1">Open-Closed Principle</span></strong><span class="koboSpan" id="kobo.599.1">. </span><span class="koboSpan" id="kobo.599.2">Its purpose is to ensure a software component or module is closed for modification but open </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">for extension.</span></span></li>
<li><span class="koboSpan" id="kobo.601.1">The DIP prescribes that clients should always depend on abstractions rather than concretions. </span><span class="koboSpan" id="kobo.601.2">By doing that, we protect clients from changes in the concretions that may require changes in the </span><span class="No-Break"><span class="koboSpan" id="kobo.602.1">client code.</span></span></li>
<li><span class="koboSpan" id="kobo.603.1">The abstract factory pattern provides objects based on their supertype, which can be used in LSP, where supertypes are replaced with subtypes while retaining the object’s </span><span class="No-Break"><span class="koboSpan" id="kobo.604.1">behavior consistency.</span></span></li>
</ol>
</div>
</body></html>