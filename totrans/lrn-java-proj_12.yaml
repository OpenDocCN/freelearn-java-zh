- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Java Core API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 核心API
- en: In this chapter, we will delve more deeply into popular classes and interfaces
    from the Java API. We will start with the `Scanner` class, which is commonly used
    for scanning and parsing text from sources such as the keyboard (the user). We
    will then examine the very popular `String` and `StringBuilder` classes. We will
    discuss their differences, which will require contrasting mutable and immutable
    types. We will also show you how to design immutable types and look at the `List`
    interface and its popular implementation class, `ArrayList`. Lastly, we will examine
    the Date API, which was overhauled in Java 8.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨 Java API 中流行的类和接口。我们将从常用的 `Scanner` 类开始，该类常用于从键盘（用户）等来源扫描和解析文本。然后，我们将检查非常流行的
    `String` 和 `StringBuilder` 类。我们将讨论它们之间的区别，这需要对比可变和不可变类型。我们还将向您展示如何设计不可变类型，并查看
    `List` 接口及其流行的实现类 `ArrayList`。最后，我们将检查在 Java 8 中进行重写的 `Date` API。
- en: 'For further details on the types covered in this chapter, please refer to the
    Java Docs API: [https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的类型更详细的信息，请参阅 Java Docs API：[https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html)。
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Understanding the `Scanner` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `Scanner` 类
- en: Comparing `String` with `StringBuilder`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 `String` 与 `StringBuilder`
- en: Designing an immutable type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计不可变类型
- en: Examining `List` and `ArrayList`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 `List` 和 `ArrayList`
- en: Exploring the Date API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `Date` API
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12)。
- en: Understanding the Scanner class
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `Scanner` 类
- en: '`Scanner` (from the `java.util` package) is a text scanner that can parse primitives
    and strings using regular expressions. A regular expression is a pattern that
    enables string manipulation. As it states so eloquently in the Java API: “*A Scanner
    breaks its input into tokens using a delimiter pattern, which by default matches
    whitespace. The resulting tokens may then be converted into values of different
    types using the various* *next methods.*”'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`（来自 `java.util` 包）是一个文本扫描器，可以使用正则表达式解析基本类型和字符串。正则表达式是一个允许字符串操作的模式。正如
    Java API 中所明确指出的：“*Scanner 使用分隔符模式将其输入拆分为标记，默认情况下匹配空白。然后可以使用各种 *next 方法* 将这些标记转换为不同类型的值。*”'
- en: These `nextXXX()` methods convert the tokens on the input stream into primitives.
    For example, if the user has typed in `23`, then `nextInt()` would return an `int`
    value of `23`; if the user typed in `45.89`, then `nextDouble()` would return
    a `double` value of `45.89`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `nextXXX()` 方法将输入流中的标记转换为基本类型。例如，如果用户输入了 `23`，则 `nextInt()` 会返回 `23` 的 `int`
    值；如果用户输入了 `45.89`，则 `nextDouble()` 会返回 `45.89` 的 `double` 值。
- en: However, if the token on the input stream is not an integer and `nextInt()`
    is called, an `InputMismatchException` error is thrown. This could occur if the
    user types in `"abc"` and `nextInt()` is called. To protect against this, each
    of the `nextXXX()` methods has a corresponding guardian angel method, namely `hasNextXXX()`.
    For example, `nextInt()` has a corresponding `hasNextInt()` method, `nextDouble()`
    has a corresponding `hasNextDouble()` method, and so forth. The `hasNextXXX()`
    methods all take a sneak peek at the input stream for the next token (without
    consuming it) and check if that token can be successfully converted into the type
    in question. They return `true` or `false` accordingly. If `true` is returned,
    then the corresponding `nextXXX()` method can safely be used without causing an
    exception.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果输入流中的标记不是整数并且调用了 `nextInt()`，则会抛出 `InputMismatchException` 错误。这可能会发生在用户输入
    `"abc"` 并调用 `nextInt()` 的情况下。为了防止这种情况，每个 `nextXXX()` 方法都有一个相应的守护天使方法，即 `hasNextXXX()`。例如，`nextInt()`
    有一个相应的 `hasNextInt()` 方法，`nextDouble()` 有一个相应的 `hasNextDouble()` 方法，依此类推。`hasNextXXX()`
    方法都会预先查看输入流中的下一个标记（不消耗它）并检查该标记是否可以成功转换为所需类型。它们相应地返回 `true` 或 `false`。如果返回 `true`，则可以安全地使用相应的
    `nextXXX()` 方法而不会引发异常。
- en: '*Table 12.1* shows some of the more important `Scanner` methods. Note that
    we have just listed one of the `hasNextXXX()` methods, namely `hasNextDouble()`,
    along with its corresponding `nextXXX()` method, namely `nextDouble()`. All of
    the following types follow the same pattern: `boolean`, `byte`, `float`, `int`,
    `long`, and `short`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 12.1* 展示了一些更重要的 `Scanner` 方法。请注意，我们只列出了一种 `hasNextXXX()` 方法，即 `hasNextDouble()`，以及其对应的
    `nextXXX()` 方法，即 `nextDouble()`。所有以下类型都遵循相同的模式：`boolean`、`byte`、`float`、`int`、`long`
    和 `short`：'
- en: '| **Method Name** | **Description** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Scanner(InputStream source)` | Creates a `Scanner` class that produces values
    from the specified input stream – for example, the keyboard |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner(InputStream source)` | 创建一个 `Scanner` 类，它从指定的输入流中生成值 - 例如，键盘 |'
- en: '| `Scanner(File source)` | Creates a `Scanner` class that produces values from
    the specified file |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner(File source)` | 创建一个 `Scanner` 类，它从指定的文件中生成值 |'
- en: '| `Scanner(String source)` | Creates a `Scanner` class that produces values
    from the specified string |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner(String source)` | 创建一个 `Scanner` 类，它从指定的字符串中生成值 |'
- en: '| `String next()` | Returns the next token |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `String next()` | 返回下一个标记 |'
- en: '| `boolean hasNextDouble()` | Returns `true` if and only if the next token
    is a valid `double` value |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `boolean hasNextDouble()` | 返回 `true` 当且仅当下一个标记是一个有效的 `double` 值 |'
- en: '| `double nextDouble()` | Scans the next token as a `double` value |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `double nextDouble()` | 将下一个标记扫描为 `double` 值 |'
- en: '| `String nextLine()` | Returns (the rest of) the line |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `String nextLine()` | 返回（行的剩余部分） |'
- en: '| `Scanner` `useDelimiter(String pattern)` | Sets the Scanner’s delimiting
    pattern according to the argument passed |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner` `useDelimiter(String pattern)` | 根据传递的参数设置 Scanner 的分隔模式 |'
- en: Table 12.1 – Sample “Scanner” API methods
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1 – “Scanner” API 方法示例
- en: Now, let’s look at some examples in code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些代码示例。
- en: Using Scanner to read from the keyboard
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Scanner 从键盘读取
- en: 'The standard input stream can be accessed with `System.in`. Typically, this
    is the keyboard. When creating our `Scanner`, we must pass the input source (`System.in`,
    in this case) as an argument of the `Scanner` constructor. *Figure 12**.1* shows
    an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入流可以通过 `System.in` 访问。通常，这是键盘。在创建我们的 `Scanner` 时，我们必须将输入源（在这种情况下为 `System.in`）作为
    `Scanner` 构造函数的参数传递。*图 12.1* 展示了一个示例：
- en: '![Figure 12.1 – “Scanner” taking input from the keyboard](img/B19793_12_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – “Scanner” 从键盘获取输入](img/B19793_12_01.jpg)'
- en: Figure 12.1 – “Scanner” taking input from the keyboard
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – “Scanner” 从键盘获取输入
- en: In this figure, on line 23, we create a `Scanner` object referring to the keyboard
    by passing `System.in` to the `Scanner` constructor. Line 24 simply prompts the
    user to type in an age. Line 25 is the guardian angel method to protect against
    exceptions. If the next token on the input is of the `int` type, then the condition
    on line 25 will be `true` and we can safely execute `nextInt()` on line 26\. Line
    27 echoes the integer that was typed on the keyboard.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第 23 行我们创建了一个 `Scanner` 对象，通过将 `System.in` 传递给 `Scanner` 构造函数来引用键盘。第 24
    行简单地提示用户输入年龄。第 25 行是守护天使方法，用于防止异常。如果输入的下一个标记是 `int` 类型，那么第 25 行的条件将为 `true`，我们就可以安全地在第
    26 行执行 `nextInt()`。第 27 行回显在键盘上输入的整数。
- en: Closing a Scanner resource
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭 Scanner 资源
- en: Closing resources once you are finished with them is prudent as it prevents
    resource leaks. However, a `Scanner` object wrapped around `System.in` is a little
    different. In effect, if we close a `Scanner` object that was wrapped around `System.in`,
    we won’t be able to read from standard input again.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭已经完成使用的资源是明智的，因为它可以防止资源泄漏。然而，围绕 `System.in` 包装的 `Scanner` 对象略有不同。实际上，如果我们关闭了一个围绕
    `System.in` 包装的 `Scanner` 对象，我们将无法再次从标准输入读取。
- en: This is what lines 30-34 in *Figure 12**.1* are demonstrating. If we close the
    `Scanner` object (line 30), even though lines 31-34 are essentially the same as
    lines 23-27 (bar `hasNextInt()`), an exception is thrown on line 33\. This is
    because we are attempting to access a closed resource.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 *图 12.1* 中的第 30-34 行所展示的。如果我们关闭 `Scanner` 对象（第 30 行），即使第 31-34 行在本质上与第 23-27
    行相同（除了 `hasNextInt()`），第 33 行将抛出异常。这是因为我们正在尝试访问一个已关闭的资源。
- en: 'Now, let’s look at an example that will further explain tokens and delimiters:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个将进一步解释标记和分隔符的示例：
- en: '![Figure 12.2 – next() delimited by whitespace](img/B19793_12_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 由空白分隔的 next()](img/B19793_12_02.jpg)'
- en: Figure 12.2 – next() delimited by whitespace
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 由空白分隔的 next()
- en: 'In this figure, we are using `next()` to try and parse `Sean Kennedy` from
    the input stream (keyboard). However, the (default) delimiter is whitespace, and
    thus, `Sean` is returned. Note that `Kennedy` is still there in the input stream.
    We could invoke `next()` a second time to consume the extra `Kennedy` token. However,
    there is a method that solves this issue: `nextLine()`. *Figure 12**.3* shows
    `nextLine()` in action:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们使用`next()`尝试从输入流（键盘）中解析`Sean Kennedy`。然而，（默认）分隔符是空白字符，因此返回的是`Sean`。请注意，`Kennedy`仍然在输入流中。我们可以再次调用`next()`来消费额外的`Kennedy`标记。但是，有一个方法可以解决这个问题：`nextLine()`。*图12.3*展示了`nextLine()`的作用：
- en: '![Figure 12.3 – nextLine() delimited by the end of the line](img/B19793_12_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 由行尾分隔的nextLine()](img/B19793_12_03.jpg)'
- en: Figure 12.3 – nextLine() delimited by the end of the line
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 由行尾分隔的nextLine()
- en: In this figure, we are using `nextLine()`, which uses a different delimiter.
    Rather than whitespace delimiting the tokens (as with `next()`), the newline character
    delimits `nextLine()`). In effect, `nextLine()` reads a line of text, whereas
    `next()` reads words. Line 17 demonstrates this by outputting `Sean Kennedy`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们使用`nextLine()`，它使用不同的分隔符。与`next()`不同，它不是用空白字符分隔标记（如`next()`），而是用换行符分隔`nextLine()`。实际上，`nextLine()`读取一行文本，而`next()`读取单词。第17行通过输出`Sean
    Kennedy`来演示这一点。
- en: '`Scanner` can be redirected to other sources for input. One such source is
    a file.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`可以重定向到其他输入源。其中一个源是文件。'
- en: Using Scanner to read from a file
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scanner从文件中读取
- en: 'Let’s examine how we can direct `Scanner` to read from a file, as opposed to
    the keyboard. *Figure 12**.4* shows such an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将`Scanner`重定向到从文件中读取，而不是从键盘读取。*图12.4*展示了这样一个例子：
- en: '![Figure 12.4 – “Scanner” taking input from a file](img/B19793_12_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – “Scanner”从文件中读取输入](img/B19793_12_04.jpg)'
- en: Figure 12.4 – “Scanner” taking input from a file
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – “Scanner”从文件中读取输入
- en: In the preceding figure, the file in question (`ages.txt`) is a simple text
    file containing the number `12`, followed by a carriage return. We pass the `File`
    object into the `Scanner` constructor (lines 34-36). The `String` object that’s
    passed into the `File` constructor (lines 35-36) is a relative path. In other
    words, it is appended to the current working directory (as opposed to an absolute
    path, which contains the full path from the root). `\\` within `String` is where
    we are escaping the backslash (`\`). Java converts `\\` into a single backslash
    internally. Therefore, `"out\\production"` becomes `"out\production"`. The `hasNextInt()`
    and `nextInt()` methods (lines 37 and 38) work as before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，所涉及的文件（`ages.txt`）是一个简单的文本文件，包含数字`12`，后面跟着一个回车符。我们将`File`对象传递给`Scanner`构造函数（第34-36行）。传递给`File`构造函数的`String`对象（第35-36行）是一个相对路径。换句话说，它附加到当前工作目录（与包含从根目录的完整路径的绝对路径相对）。`String`中的`\\`是我们对反斜杠（`\`）进行转义的地方。Java将`\\`内部转换为单个反斜杠。因此，`"out\\production"`变为`"out\production"`。`hasNextInt()`和`nextInt()`方法（第37和38行）与之前的工作方式相同。
- en: As we are using try-with-resources, we do not need to remember to explicitly
    close the `Scanner` or `File` resources (they are closed implicitly for us).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了try-with-resources，我们不需要记住显式关闭`Scanner`或`File`资源（它们会为我们隐式关闭）。
- en: Another possible source for `Scanner` input is a `String` object. Let’s look
    at that now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`输入的另一个可能来源是`String`对象。现在让我们看看这一点。'
- en: Using Scanner to read from a string
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scanner从字符串中读取
- en: 'Using `String` as an input `Scanner` source is also possible. *Figure 12**.5*
    shows such an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`String`作为输入`Scanner`源也是可能的。*图12.5*展示了这样一个例子：
- en: '![Figure 12.5 – “Scanner” taking input from a string](img/B19793_12_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – “Scanner”从字符串中读取输入](img/B19793_12_05.jpg)'
- en: Figure 12.5 – “Scanner” taking input from a string
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – “Scanner”从字符串中读取输入
- en: In this figure, we declare a `String` object (line 14) and pass it to the `Scanner`
    constructor (line 15). We then chain the `useDelimiter(String)` method onto the
    `Scanner` object that is returned. This method accepts `String` as an argument
    and represents the regular expression pattern required to parse the input. The
    double backslash is, as before, simply escaping the backslash. In other words,
    `\\` becomes `\`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们声明了一个`String`对象（第14行）并将其传递给`Scanner`构造函数（第15行）。然后我们将`useDelimiter(String)`方法链接到返回的`Scanner`对象。此方法接受`String`作为参数，并代表解析输入所需的正则表达式模式。双反斜杠，正如之前一样，只是简单地转义反斜杠。换句话说，`\\`变为`\`。
- en: The `\s*` regular expression translates into *0 or more whitespace characters*.
    `*` represents *0 or more* and `\s` represents *a single whitespace character*.
    The `delim` string is hardcoded. This means that the input tokens are delimited
    by 0 or more spaces, followed by the `delim` token, followed by 0 or more spaces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式 `\s*` 转换为 *0 个或多个空白字符*。`*` 代表 *0 个或多个*，`\s` 代表 *单个空白字符*。`delim` 字符串是硬编码的。这意味着输入标记由
    0 个或多个空格、`delim` 标记以及 0 个或多个空格分隔。
- en: When we apply this delimiter pattern to the given input string (line 14), the
    first token returned by `next()` is `Maaike`. This is output by line 16\. As `Maaike`
    has now been consumed from the input stream, the `next()` method call (line 17)
    returns the `van` token, which is then output. Similarly, the `next()` method
    on line 18 returns `Putten` to be output. Lastly, line 19 uses `nextInt()` to
    return 22 as an `int` type, which is then output to the screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此分隔符模式应用于给定的输入字符串（第14行）时，`next()` 返回的第一个标记是 `Maaike`。这是在第16行输出的。由于 `Maaike`
    已经从输入流中消耗掉，第17行的 `next()` 方法调用返回 `van` 标记，然后输出。同样，第18行的 `next()` 方法返回 `Putten`
    以供输出。最后，第19行使用 `nextInt()` 返回 22 作为 `int` 类型，然后输出到屏幕。
- en: Now that we know how to obtain input from the user, let’s cover two of the most
    important classes dealing with strings, namely `String` and `StringBuilder`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从用户那里获取输入，让我们来介绍两个处理字符串的最重要类，即 `String` 和 `StringBuilder`。
- en: Comparing String with StringBuilder
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较String与StringBuilder
- en: When dealing with strings, these two classes are your go-to classes. Their primary
    difference is that `String` objects are immutable, whereas `StringBuilder` objects
    are mutable. This means that for strings, once you create a `String` object, you
    cannot ever change that object. Java might make it look like you changed the object
    but you haven’t; a new object, reflecting your changes, has been created. `StringBuilder`
    objects, on the other hand, are mutable. This means that you are working with
    one object all the time. We will delve into this with an example later.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字符串时，这两个类是你的首选类。它们的主要区别在于 `String` 对象是不可变的，而 `StringBuilder` 对象是可变的。这意味着对于字符串，一旦创建了
    `String` 对象，就不能再更改该对象。Java 可能会让你看起来改变了对象，但你并没有；一个新的对象，反映了你的更改，已经被创建。另一方面，`StringBuilder`
    对象是可变的。这意味着你始终在处理一个对象。我们将在稍后的示例中深入探讨这一点。
- en: Why immutability?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是不可变的？
- en: Immutability is attractive from a security perspective as immutable objects
    cannot be changed. In addition, immutable objects are thread-safe in a multi-threaded
    environment. In multi-threaded environments, changes to (non-immutable) objects
    have to be synchronized one at a time so that changes do not interfere with one
    another Immutable objects are, by definition, protected from that. See [*Chapter
    17*](B19793_17.xhtml#_idTextAnchor430) (Concurrency) for a discussion on multi-threading.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来说，不可变性很有吸引力，因为不可变对象不能被更改。此外，在多线程环境中，不可变对象是线程安全的。在多线程环境中，对（非不可变）对象的更改必须逐个同步，以防止更改相互干扰。不可变对象按照定义是受到保护的。参见[*第17章*](B19793_17.xhtml#_idTextAnchor430)（并发）中关于多线程的讨论。
- en: For the moment, let’s start with the `String` class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们从 `String` 类开始。
- en: String class
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类
- en: The `String` class is in the `java.lang` package and represents a sequence of
    characters. As the class is in `java.lang`, it is automatically imported for you.
    The `String` class implements the `Comparable` interface, meaning that a natural
    ordering is defined when sorting strings. This ordering is alphabetic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类位于 `java.lang` 包中，表示字符序列。由于该类位于 `java.lang` 中，它将自动为你导入。`String` 类实现了
    `Comparable` 接口，这意味着在排序字符串时定义了自然排序。这种排序是字母顺序。'
- en: As stated, `String` is an immutable type. Objects of the `String` type, once
    created, cannot be modified. `String` is also a `final` class, which means that
    you cannot subclass it. This is deliberate – the Java designers expect strings
    to behave in a certain way. If we were allowed to subclass `String` and override
    its behavior, unexpected results would occur. So, making the class `final` prevents
    this by ensuring predictable string behavior.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，`String` 是一个不可变类型。一旦创建了 `String` 类型的对象，就不能对其进行修改。`String` 也是一个 `final`
    类，这意味着你不能对其进行子类化。这是故意的——Java 设计者期望字符串以某种方式行为。如果我们被允许子类化 `String` 并覆盖其行为，可能会出现意外结果。因此，通过确保字符串行为的可预测性，将类设置为
    `final` 防止了这种情况。
- en: All `String` literals are instances of the `String` class. `String` literals
    are stored in a special area of the heap called the string pool (or string constant
    pool). This is known as *interning* the string. If another string literal with
    the same character sequence is encountered, the string in the string pool is reused.
    This saves on memory. However, if you use the `new` keyword to create your `String`
    object, a new object with the character sequence is created on the heap, even
    if such an object is available in the string pool. In other words, the string
    pool is ignored if `new` is used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`String`字面量都是`String`类的实例。`String`字面量存储在堆的一个特殊区域，称为字符串池（或字符串常量池）。这被称为字符串的内部化。如果遇到具有相同字符序列的另一个字符串字面量，将重用字符串池中的字符串。这可以节省内存。然而，如果您使用`new`关键字来创建您的`String`对象，即使该对象在字符串池中可用，也会在堆的另一个部分创建一个新的具有字符序列的对象。换句话说，如果使用`new`，则忽略字符串池。
- en: Let’s look at an example in code, as well as a supporting in-memory diagram.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例以及一个内存图来查看一个示例。
- en: String example (code)
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串示例（代码）
- en: '*Figure 12**.6* represents the code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.6* 表示以下代码：'
- en: '![Figure 12.6 – “String” example in code](img/B19793_12_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – “字符串”示例在代码中](img/B19793_12_06.jpg)'
- en: Figure 12.6 – “String” example in code
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 代码中的“字符串”示例
- en: In this figure, on line 5, we use the `s1` string reference to refer to the
    `"abc"` string literal. When the JVM encounters a string literal, it first checks
    if the same string literal exists in the string pool. If it does, it reuses the
    one from the pool. As line 5 is the first time `"abc"` is encountered, the `String`
    object with `"abc"` is inserted into the pool. Note that the string pool is simply
    a special area in the heap.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第5行，我们使用`s1`字符串引用来引用`"abc"`字符串字面量。当JVM遇到字符串字面量时，它首先检查是否在字符串池中存在相同的字符串字面量。如果存在，它将重用池中的那个。由于第5行是第一次遇到`"abc"`，因此带有`"abc"`的`String`对象被插入到池中。请注意，字符串池只是堆中的一个特殊区域。
- en: Line 6 is where the string pool object is reused. Now, we have both `s1` and
    `s2` referring to the same `String` object (in the pool). This is why line 7 outputs
    `true`. Recall that when the `==` operator is used with references, we are comparing
    the references. In other words, are both `s1` and `s2` referring to the same object
    in memory? Yes, they are.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行是字符串池对象被重用的地方。现在，`s1`和`s2`都引用了同一个`String`对象（在池中）。这就是为什么第7行输出`true`的原因。回想一下，当使用`==`运算符与引用一起使用时，我们是在比较引用。换句话说，`s1`和`s2`是否都指向内存中的同一个对象？是的，它们是。
- en: Line 8 uses the `new` keyword to create a `String` object. Once `new` is used,
    regardless of the same literal `"abc"` being used, a completely new object is
    created in a separate part of the heap. As line 8 creates a new object, when we
    compare `s1` and `s3` on line 9, the result is `false`. This is because `s1` and
    `s3` refer to two different objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行使用`new`关键字创建一个`String`对象。一旦使用`new`，无论是否使用相同的字面量`"abc"`，都会在堆的另一个部分创建一个全新的对象。由于第8行创建了一个新对象，当我们第9行比较`s1`和`s3`时，结果是`false`。这是因为`s1`和`s3`引用了两个不同的对象。
- en: The `String` object’s method, `equals()`, operates differently from the equivalence
    operator, `==`. Rather than compare the references, `equals()` compares the contents
    of the objects. As line 10 returns `true`, it shows that the contents of the objects
    referred to by `s1` and `s2` are the same. This should not be a surprise as both
    `s1` and `s2` refer to the same object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象的`equals()`方法与等价运算符`==`操作不同。`equals()`不是比较引用，而是比较对象的内容。由于第10行返回`true`，这表明`s1`和`s2`引用的对象内容是相同的。这不应该令人惊讶，因为`s1`和`s2`都引用了同一个对象。'
- en: Line 11, however, also returns `true`. Even though `s1` and `s3` refer to different
    objects, this demonstrates that `equals()` compares the object’s contents and
    not the references.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第11行也返回`true`。尽管`s1`和`s3`引用了不同的对象，但这表明`equals()`比较的是对象的内容，而不是引用。
- en: Line 12 is interesting. We can intern a string by using its `intern()` method.
    What we are saying on line 12 is “Intern in the string pool what `s3` is referring
    to, and make the `s3` reference refer to the string pool object.” Line 13 returns
    `true`, demonstrating that both `s1` and `s3` now refer to the same string object.
    Note that line 13 is the same code as line 9, which returned `false` previously.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第12行很有趣。我们可以通过使用其`intern()`方法来内部化一个字符串。第12行所说的就是“将`s3`引用指向的内容在字符串池中内部化，并使`s3`引用指向字符串池对象。”第13行返回`true`，表明`s1`和`s3`现在都引用了同一个字符串对象。注意，第13行与之前返回`false`的第9行是相同的代码。
- en: A diagram will certainly help here, so let’s examine what is happening in memory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的图表肯定会很有帮助，所以让我们检查内存中发生了什么。
- en: String example (diagram)
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: String示例（图表）
- en: '*Figure 12**.7* represents the in-memory representation of the code in *Figure
    12**.6*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.7* 表示了 *图12**.6* 中的代码的内存表示：'
- en: '![Figure 12.7 – “String” example in memory](img/B19793_12_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – “String”在内存中的示例](img/B19793_12_07.jpg)'
- en: Figure 12.7 – “String” example in memory
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – “String”在内存中的示例
- en: 'As can be seen from the preceding figure, both `s1` and `s2` refer to the `"abc"`
    object in the string pool. The dashed line from `s3` represents the object that
    was created by using the `new` keyword (line 8). Thus, we have two separate string
    objects: one on the heap and one in the pool (which is also part of the heap).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`s1`和`s2`都指向字符串池中的`"abc"`对象。从`s3`发出的虚线代表由`new`关键字（第8行）创建的对象。因此，我们有两个独立的字符串对象：一个在堆上，一个在池中（池也是堆的一部分）。
- en: The solid line from `s3` represents the result of the interning operation on
    line 12\. Now, it is straightforward to see why, after line 12, that `s1 == s3`
    returns `true`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从`s3`发出的实线代表第12行上intern操作的结果。现在，很容易看出为什么在第12行之后，`s1 == s3`返回`true`。
- en: So, when using strings, if you are interested in comparing the contents, use
    the `equals()` method. Note that `equals()` is case-sensitive. There is a method,
    namely `equalsIgnoreCase()`, which is case insensitive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用字符串时，如果您想比较内容，请使用`equals()`方法。请注意，`equals()`是区分大小写的。有一个方法，即`equalsIgnoreCase()`，它是不区分大小写的。
- en: An important property of `String` objects is the fact that they are immutable.
    Let’s discuss that now.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象的一个重要属性是它们是不可变的。现在让我们来讨论这一点。'
- en: String immutability
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: String不可变性
- en: This topic is very important if you want to create immutable types or wish to
    obtain Java certification. We will discuss how to create a custom immutable type
    later. Regarding the `String` class, it is the object that is immutable and not
    the reference. What this means is that you can change the reference to point to
    a different string, but you cannot change the contents of the string object itself.
    Also, note that all the “wrapper” types, such as `Integer`, `Double`, `Float`,
    and `Character`, are also immutable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建不可变类型或希望获得Java认证，这个主题非常重要。我们将在稍后讨论如何创建自定义不可变类型。关于`String`类，它是不可变对象，而不是引用。这意味着您可以更改引用以指向不同的字符串，但不能更改字符串对象的内容。此外，请注意，所有“包装”类型，如`Integer`、`Double`、`Float`和`Character`，也都是不可变的。
- en: 'Let’s look at an example in code, with an associated in-memory diagram. *Figure
    12**.8* represents the code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例和相关的内存图表来查看。*图12**.8* 表示了代码：
- en: '![Figure 12.8 – “String” immutability (code)](img/B19793_12_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – “String”不可变性（代码）](img/B19793_12_08.jpg)'
- en: Figure 12.8 – “String” immutability (code)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – “String”不可变性（代码）
- en: 'In this figure, on line 18, using the `"The "` literal, we create a `String`
    object that’s referred to by the `s` reference. As this is a literal, the object
    goes into the string pool. Line 19 appends `"quick "` to `s` using the `+=` operator.
    As line 20 outputs `"The quick "`, you would be forgiven for thinking that the
    string object referred to by `s` has changed. This is not the case. As `String`
    objects are immutable, this is not allowed. What happens is that a new `String`
    object is created reflecting the requested changes. Therefore, we have three `String`
    objects on line 20: the two literals, `"The "` and `"quick "`, are in the string
    pool, and the newly created `"The quick "` object is on the heap.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，第18行使用`"The "`字面量创建了一个由`s`引用的`String`对象。由于这是一个字面量，对象进入字符串池。第19行使用`+=`运算符将`"quick
    "`追加到`s`。由于第20行输出`"The quick "`,您可能会认为由`s`引用的字符串对象已经改变。事实并非如此。由于`String`对象是不可变的，这是不允许的。发生的情况是创建了一个新的`String`对象，反映了所需的变化。因此，在第20行我们有三个`String`对象：两个字面量`"The
    "`和`"quick "`在字符串池中，新创建的`"The quick "`对象在堆上。
- en: Line 21 is revealing. Many of the `String` API methods return a `String` (reference).
    As `String` objects are immutable, this `String` reference that’s returned is
    a reference to the newly created `String` object. This object is created in the
    background and reflects the requested changes. As we have not stored the reference
    on line 21, this object is lost to us and is immediately eligible for garbage
    collection. When we output `s` on line 22, you can see that it has not changed;
    its content is still `"The` `quick "`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第 21 行是揭示性的。许多 `String` API 方法返回一个 `String`（引用）。由于 `String` 对象是不可变的，因此返回的这个
    `String` 引用是到新创建的 `String` 对象的引用。这个对象在后台创建，反映了请求的更改。由于我们没有在第 21 行存储引用，因此这个对象对我们来说是丢失的，并且立即可以回收。当我们第
    22 行输出 `s` 时，你可以看到它没有改变；其内容仍然是 `"The` `quick "`。
- en: Line 23 shows what line 21 should have done. By reinitializing `s`, we redirect
    the reference to the newly created object. Consequently, when we output `s` on
    line 24, we get the full string – that is, `"The quick` `brown fox"`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第 23 行显示了第 21 行应该做的事情。通过重新初始化 `s`，我们重定向了引用到新创建的对象。因此，当我们第 24 行输出 `s` 时，我们得到完整的字符串，即
    `"The quick` `brown fox"`。
- en: 'A diagram representing what is happening in memory will help here. *Figure
    12**.9* represents the in-memory representation of the code from *Figure 12**.8*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表示内存中发生情况的图表将有助于理解。*图 12.9* 表示 *图 12.8* 代码的内存表示：
- en: '![Figure 12.9 – “String” immutability (diagram)](img/B19793_12_09.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – “String”不可变性（图表）](img/B19793_12_09.jpg)'
- en: Figure 12.9 – “String” immutability (diagram)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – “String”不可变性（图表）
- en: In the preceding figure, dashed lines represent overwritten references. We have
    six `String` objects in total – three string literals in the pool and three constructed
    string objects using both the `+=` operator and the `concat()` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，虚线表示被覆盖的引用。我们总共有六个 `String` 对象 – 池中的三个字符串字面量以及使用 `+=` 操作符和 `concat()`
    方法的三个构造的字符串对象。
- en: Notice that the string object in the middle (at the bottom), has no reference
    pointing to it. It never had, hence there is no dashed line pointing to it. This
    is the object that was created by line 21 but as the reference was never assigned
    to a variable, it was lost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到中间的字符串对象（在底部），没有引用指向它。它从未有过，因此没有虚线指向它。这就是第 21 行创建的对象，但由于引用从未分配给变量，它已经丢失了。
- en: On the other hand, line 23 did store the reference to the newly created string
    object. It overwrote what was in the `s` reference. This is why `s` is referring
    to `"The quick` `brown fox"`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第 23 行确实存储了新创建的字符串对象的引用。它覆盖了 `s` 引用中的内容。这就是为什么 `s` 指向 `"The quick` `brown
    fox"`。
- en: 'When we discuss `StringBuilder`, we will re-write the code from *Figure 12**.8*.
    For the moment, we will look at the more important methods in the `String` API.
    These are reflected in *Table 12.2*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 `StringBuilder` 时，我们将重新编写 *图 12.8* 中的代码。目前，我们将查看 `String` API 中更重要的方法。这些方法反映在
    *表 12.2* 中：
- en: '| **Method Name** | **Description** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `char` `charAt(int index)` | Returns the character at the specified index.
    Indices range from 0 (as per arrays) to `length()`-1. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `char` `charAt(int index)` | 返回指定索引处的字符。索引范围从 0（与数组相同）到 `length()`-1。 |'
- en: '| `int` `compareTo(String anotherString)` | Compares two strings character
    by character lexicographically (dictionary order). In other words, `this.charAt(k)-anotherString.charAt(k)`.
    For example, `"ace"` comes before `"bat"`, `"and"` comes before `"at"`, and so
    forth. If all characters match but the two string lengths differ, then the shorter
    string precedes the longer string. For example, `"bat"` comes before `"battle"`.
    Let’s take a look:`"ace".compareTo("bat")` returns `-1`;`"and".compareTo("at")`
    returns `-6`;`"bat".compareTo("battle")` returns `-3` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `int` `compareTo(String anotherString)` | 按字典顺序逐字符比较两个字符串。换句话说，`this.charAt(k)-anotherString.charAt(k)`。例如，`"ace"`
    在 `"bat"` 之前，`"and"` 在 `"at"` 之前，以此类推。如果所有字符都匹配但两个字符串长度不同，则较短的字符串排在较长的字符串之前。例如，`"bat"`
    在 `"battle"` 之前。让我们看一下：`"ace".compareTo("bat")` 返回 `-1`；`"and".compareTo("at")`
    返回 `-6`；`"bat".compareTo("battle")` 返回 `-3` |'
- en: '| `String` `concat(String str)` | Concatenates the argument string to this
    string.`"abc".concat("def")` returns `"abcdef"`. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `String` `concat(String str)` | 将参数字符串连接到这个字符串上。`"abc".concat("def")` 返回
    `"abcdef"`。 |'
- en: '| `boolean` `endsWith(String suffix)` | Does this string end with the specified
    suffix? As it uses `equals(Object)`, it is case-sensitive.`"abc".endsWith("bc")`
    returns true.`"abc".endsWith("BC")` returns false. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `boolean endsWith(String suffix)` | 此字符串是否以指定的后缀结束？因为它使用`equals(Object)`，所以它是区分大小写的。“abc.endsWith("bc")”返回`true`。“abc.endsWith("BC")”返回`false`。
    |'
- en: '| `int hashCode()` | Returns a hash code for this string. Hash codes are used
    to store/retrieve objects used in hash-based collections such as `HashMap`. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `int hashCode()` | 返回此字符串的哈希码。哈希码用于存储/检索用于基于哈希的集合（如`HashMap`）中的对象。 |'
- en: '| `int` `indexOf(String str)` | Returns the index of the first occurrence of
    the specified substring. It is case-sensitive and overloaded.`"abcdef".indexOf("b")`
    returns `1`.`"abcdef".indexOf("B")` returns `-1`. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `int indexOf(String str)` | 返回指定子字符串首次出现处的索引。它是区分大小写的，并且是重载的。“abcdef.indexOf("b")”返回`1`。“abcdef.indexOf("B")”返回`-1`。
    |'
- en: '| `int length()` | Returns the length of the string. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `int length()` | 返回字符串的长度。 |'
- en: '| `String` `substring(int beginIndex)` | Returns the substring of this string,
    starting at the specified `beginIndex` and proceeding until the end of this string.
    Indices start at 0.`"abcdef".substring(3)` returns `"def"`. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `String substring(int beginIndex)` | 返回此字符串的子字符串，从指定的`beginIndex`开始，并继续到字符串的末尾。索引从0开始。“abcdef.substring(3)”返回`"def"`。
    |'
- en: '| `String substring(int beginIndex,` `int endIndex)` | Returns the substring
    of this string. The substring begins at the specified `beginIndex` and extends
    to the character at `endIndex`-1\. Indices start at 0.Think: “Give me `endIndex-startIndex`
    characters, starting at `startIndex`.” For example,`"Sean Kennedy".substring(3,8)`
    means “Give me 5 characters, starting at index 3,” which returns `"``n Ken"`.
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `String substring(int beginIndex, int endIndex)` | 返回此字符串的子字符串。子字符串从指定的`beginIndex`开始，延伸到`endIndex`-1处的字符。索引从0开始。思考：
    “给我`endIndex-startIndex`个字符，从`startIndex`开始。” 例如，`"Sean Kennedy".substring(3,8)`意味着“给我5个字符，从索引3开始”，它返回`"n
    Ken"`。 |'
- en: '| `String toLowerCase()``String toUpperCase()` | Converts the string to lowercase
    and uppercase, respectively. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `String toLowerCase()``String toUpperCase()` | 分别将字符串转换为小写和大写。 |'
- en: '| `String trim()` | The `trim()` method removes whitespace from both ends of
    a string – for example,`" lots of spaces here` `".trim()` returns `""lots of spaces`
    `here""` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `String trim()` | `trim()`方法从字符串的两端删除空白字符 – 例如，`" lots of spaces here".trim()`返回`"
    lots of spaces here"` |'
- en: Table 12.2 – Sample “String” API methods
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2 – “String”API方法示例
- en: Now, let’s turn our attention to the `StringBuilder` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向`StringBuilder`类。
- en: StringBuilder class
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`StringBuilder`类'
- en: The `StringBuilder` class is also in the `java.lang` package and represents
    a mutable sequence of characters. The API for `StringBuilder` is the same as for
    the `StringBuffer` class. Use `StringBuilder` in a single-thread environment and
    use `StringBuffer` in a multithreading environment. `StringBuilder` also implements
    the `Comparable` interface where the natural ordering defined for sorting is also
    alphabetic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`类也在`java.lang`包中，表示一个可变的字符序列。`StringBuilder`的API与`StringBuffer`类相同。在单线程环境中使用`StringBuilder`，在多线程环境中使用`StringBuffer`。`StringBuilder`还实现了`Comparable`接口，其中定义的自然排序顺序也是字母顺序。'
- en: '`StringBuilder` is a mutable type. `StringBuilder` is also a `final` class,
    which means that you cannot subclass it. Again, this is deliberate as the Java
    designers wanted to ensure predictable behavior from `StringBuilder` objects.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`是一个可变类型。`StringBuilder`也是一个`final`类，这意味着你不能从它派生子类。再次强调，这是故意的，因为Java设计者希望确保`StringBuilder`对象的行为可预测。'
- en: As promised earlier, we will refactor *Figure 12**.8* to use `StringBuilder`
    instead of `String`. In addition, we will diagram the differences in memory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将重构*图12**.8*，使用`StringBuilder`代替`String`。此外，我们还将绘制内存中的差异图。
- en: StringBuilder example (code)
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`StringBuilder`示例（代码）'
- en: '*Figure 12**.10* represents the code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.10* 表示的代码：'
- en: '![Figure 12.10 – “StringBuilder” example in code](img/B19793_12_10.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – 代码中的“StringBuilder”示例](img/B19793_12_10.jpg)'
- en: Figure 12.10 – “StringBuilder” example in code
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 代码中的“StringBuilder”示例
- en: In this figure, line 49 creates a new `StringBuilder` object and initializes
    it to `"The "`. Line 50 uses the `append()` method to append `"quick "` to the
    object referenced by `sb`. As `StringBuilder` objects are mutable, we can ignore
    the reference returned (as we have that reference in `sb` already). Line 51 outputs
    `"The quick "`, thereby demonstrating that the (one) `StringBuilder` object was
    changed. Line 52 appends `"brown fox"` to the `StringBuilder` object and line
    53 again shows that there is only one object all the time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the in-memory representation of *Figure 12**.10*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder example (diagram)
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.11* represents the in-memory representation of the code in *Figure
    12**.10*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – “StringBuilder” example in memory](img/B19793_12_11.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – “StringBuilder” example in memory
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from this figure, apart from the string pool objects (which are
    there as they are string literals), we only have one `StringBuilder` object. Each
    time we call `append()`, that one mutable `StringBuilder` object is changed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the more commonly used API methods from `StringBuilder`.
    *Table 12.3* reflects this API:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Description** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| `StringBuilder` `append(String str)` | Appends the specified string to `StringBuilder`.
    Overloaded versions are available (see the API). |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| `char` `charAt(int index)` | Returns the character at the specified index.
    Indices range from 0. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| `int` `indexOf(String str)` | Returns the index of the first occurrence of
    the specified substring. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| `StringBuilder insert(int offset,` `String str)` | Inserts the given string
    into the `StringBuilder` object at the specified offset, moving any characters
    above that position upwards. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '| `String` `substring(int beginIndex)` | Returns a new string, starting at
    the specified `beginIndex`, and proceeds until the end of this string builder.
    Indices start at 0. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: '| `String substring(int beginIndex,` `int endIndex)` | Returns a new string,
    starting at the specified `beginIndex`, and extends to the character at `endIndex-1`.
    Indices start at 0. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
- en: '| `String toString()` | Returns a string representation of the character sequence.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
- en: Table 12.3 – Sample “StringBuilder” API methods
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the major difference between `String` and `StringBuilder` is
    that `String` objects are immutable, whereas `StringBuilder` objects are mutable.
    Let’s look at an example that will help bring that difference into sharp focus.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: String versus StringBuilder example
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a sample piece of code to demonstrate this. This code will help
    highlight both the immutability of `String` objects and the mutability of `StringBuilder`
    objects. As a bonus, because we are using methods, the code will help us revise
    the principle of call by value. *Figure 12**.12* shows the code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – “String” versus “StringBuilder” code example](img/B19793_12_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – “String” versus “StringBuilder” code example
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, on line 11, we declare a `String` reference, `s`, that’s referring
    to `"Hi"` and a `StringBuilder` reference, `sb`, that contains `"Hi"` also. On
    line 13, we invoke the `whatHappens()` method, passing in both `s` and `sb`, respectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: As Java uses call by value, a copy of each reference is made. Thus, the `s`
    and `sb` references in the method declaration (line 4) refer to the same objects
    that were declared on lines 11 and 12, respectively. While not necessary, keeping
    the same identifiers, `s` and `sb`, helps emphasize this point.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Line 5 then concatenates `" there!"` onto the string referenced by `s`. As strings
    are immutable, that object cannot be changed, so the JVM creates a new object
    with the character sequence (string value) of `"Hi there!"`. Line 7 outputs this
    new string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Line 6 appends `" there!"` to the `StringBuilder` object. As it is mutable,
    the object is simply modified. Line 8 outputs `sb` after this change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: After the method call on line 13 returns, we output both the values of the string
    object referred to by `s` and the string builder object referred to by `sb`. Remember,
    because we passed in references and because of call by value, the `whatHappens()`
    method had direct access to the objects declared in `main()` on lines 11 and 12\.
    However, when we output the string object (line 14), we see that it is still `"Hi"`,
    demonstrating that `String` objects are immutable. On the other hand, when we
    output the `StringBuilder` object, it has changed to `"Hi there!"`, demonstrating
    the mutability of `StringBuilder` objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram will help here. However, to keep the diagram simple and to focus
    on mutability/immutability, the string pool has been omitted. *Figure 12**.13*
    is the in-memory representation of the code in *Figure 12**.12*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 - ”String” versus “StringBuilder” in memory](img/B19793_12_13.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 - ”String” versus “StringBuilder” in memory
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: This figure represents the picture in memory as we are just about to leave the
    `whatHappens()` method (line 9). The dashed arrow is the important arrow. When
    we entered the `whatHappens()` method, both `s` references were pointing at the
    same `String` object. Line 5 changes the local `s` reference to point to the new
    `String` object and the original `String` object was untouched (as it is immutable).
    The other thing to notice is that the `StringBuilder` object has been modified
    (we used a strikethrough to highlight this).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when we return to `main()` after calling the method (line 13), the `s`
    reference is referring to the untouched `String` object containing `"Hi"`, whereas
    the `sb` reference is referring to the modified `StringBuilder` object containing
    `"``Hi there!"`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: This discussion on immutable types leads to a natural question, how do I create
    a custom immutable type? That is the topic of the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Designing a custom immutable type
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the API, there are mutable types, such as `StringBuilder` and `ArrayList`,
    and immutable types, such as `String` and `Integer`. When something is “immutable,”
    it means it cannot change. We can use the `final` keyword to make a primitive
    value immutable. When we apply `final` to a reference, it is the reference that
    is immutable and not the object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted to create our own type (class) and make it immutable? In other
    words, we want the *objects* based on our custom class to be immutable. What considerations
    are involved? That is what we’ll discuss in this section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Before we present the checklist, recall that Java uses call by value when passing
    arguments to, and retrieving values from, methods. Call by value implies that
    a copy of the argument is made and that the method works with that copy. For primitives,
    this means that the called method cannot change the primitive value passed from
    the caller method. This is analogous to passing a photocopy of a sheet of paper;
    the photocopied sheet can be written on, without it changing the original. For
    references, however, the situation is different. Passing a reference to a method
    means that the called method can change the object that the caller method is looking
    at. This is analogous to passing a copy of a remote control; the copy-remote can
    change the TV channel also. This is reflected in the checklist. Let’s examine
    this checklist.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The checklist
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The checklist to apply is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Do not provide any “setter” methods
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make all the fields `private` and `final`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prevent subclassing (so that methods cannot be overridden):'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the class `final`
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the constructor `private` and provide a `public static` factory method
    such as `createNewInstance`
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding instance fields, bear in mind that:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable types such as `String` are ok
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For mutable types such as `StringBuilder`, do *not* share the references – use
    the advanced encapsulation technique outlined in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
    This technique is also known as “defensive copying”.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This checklist is best explained with the aid of a code example. We will start
    with an example that looks fine but has a subtle issue. We will examine the issue
    in memory to explain it further. Finally, we will address the issue in code and
    show why it works in memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Immutable type (breaking encapsulation)
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.14* presents such an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – A custom immutable type that breaks encapsulation](img/B19793_12_14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – A custom immutable type that breaks encapsulation
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an immutable type called `Farm`. The class is `final`
    (line 6), so it cannot be subclassed. All of the fields are `private` and `final`
    (lines 8-10). Marking them as `private` ensures no external classes can change
    their values without our knowledge (basic encapsulation). Marking them as `final`
    means that once given initial values, those values cannot change. In this example,
    as they are not given initial values at the point of declaration, they are known
    as *blank finals*. Blank finals must be initialized before the constructor finishes,
    which is what we do (lines 14-17).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Our constructor is marked `private` on line 13\. Thus, no external class can
    `new` a `Farm` object directly via this constructor. This is another way to prevent
    subclassing, as no subclass will have access to this constructor and as we have
    a constructor coded, the compiler will not insert the default constructor either.
    We have marked the constructor parameters as `final` also, in case of accidental
    change.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The `createNewInstance()` factory method (lines 20-23) is how we enable external
    classes to create `Farm` objects. We provide a `public` `static` method that calls
    the `private` constructor on their behalf. Marking it as `public` gives every
    class access to this method; marking it as `static` ensures that clients do not
    have to create an object to create a `Farm` (which they can’t do directly anyway!).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are no `set` methods, only `get` methods (lines 25-34). There
    is one `get` method per instance variable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: Note that this class breaks encapsulation. This is because, in the constructor
    (line 17), we are storing the reference that was passed in. In addition, our `getAnimals()`
    method is returning the reference we stored. We will see the implications of this
    in memory shortly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for now, let’s look at a client class utilizing the “supposedly immutable”
    `Farm` class. *Figure 12**.15* highlights an issue:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – A class that uses a weakly encapsulated custom immutable type](img/B19793_12_15.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – A class that uses a weakly encapsulated custom immutable type
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we declare a `List` (interface) reference, namely `animals`,
    referring to an `ArrayList` object (line 54). By stating the reference is of the
    `List<String>` type, we are telling the compiler that only strings are allowed.
    This gives us type safety, as we cannot, for example, add an `Integer` object
    to our list. As `ArrayList` is a mutable type, it is perfect for our example.
    Line 55 adds `"Cattle"` to our `ArrayList`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Line 57 uses the `createNewInstance()` factory method, passing in `"Small Farm"`,
    `25`, and our `animals` array list. Line 58 proves that the object was created
    properly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Lines 61-63 are where we initialize the local variables based on the `Farm`
    object’s state (the values of the instance variables). Lines 64-65 check that
    they are set as expected.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Lines 68-70 are where we change the *local* variables. This is the acid test.
    Changing the local variables should *not* affect the state of our `Farm` object.
    On line 73, we output the instance variables again, via the implicit call to `toString()`.
    The output is in a comment on the previous line, line 72\. As can be seen from
    the output, the instance’s `String` variable name is unaffected (still `"Small
    Farm"`) and the `numAnimals` instance primitive is also unaffected (still 25).
    However, the `animals` instance variable has changed! The `ArrayList` object type
    is the issue here. Originally, the list was just `"Cattle"`; now, it is `"Cattle"`,
    `"Sheep"`, and `"Horses"`. This change is highlighted by the rectangles. How did
    this happen? Looking at the situation in memory will reveal the issue.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: In-memory representation (breaking encapsulation)
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.16* shows the situation in memory (as we are just about to exit
    the program). Note that *Figure 12**.16* represents the whole program across both
    figures, namely *Figure 12**.14* and *Figure 12**.15*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.16 – Encapsulation broken by a custom “immutable” type](img/B19793_12_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – Encapsulation broken by a custom “immutable” type
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the dashed lines represent original states or values.
    For example, the dashed line from the `name` variable, on the stack in `main()`,
    represents line 61 in the code. In contrast, the sold line from the same variable
    represents line 68.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the stack first. The local `farm` reference refers to the `Farm`
    object on the heap, which is where the `name`, `numAnimals`, and `animals` instance
    variables are initialized accordingly. As stated, the local `name` variable in
    `main()` is initialized (line 61) to refer to the same `String` object that the
    instance variable in the `Farm` object is looking at. The local `numAnimals` variable
    is initialized to the value of the instance variable of the same name (line 62).
    Note that the local copy is represented as a rectangle and not an arrow; this
    reflects the photocopy of a sheet of paper analogy. Line 63 initializes the local
    `animals` reference to point to the same `ArrayList` object as the `animals` instance
    variable in the `Farm` object on the heap. This is the problem, as we shall see
    very shortly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Just as we start to execute line 68, both `name` references, the local one on
    the stack and the instance one on the heap, are referring to the same `String`
    object. Line 68 changes the `name` local variable to `"Big Farm"`. However, as
    `String` objects are immutable, a new `String` object is created on the heap reflecting
    those changes. In other words, a new `String` object with `"Big Farm"` is created
    and `name` (on the stack) refers to it. The dashed line, referring to the original
    `String` object, and the solid line referring to the new `String` object represent
    this (from `name` on the stack).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `name` *instance* variable is completely unaffected by this change.
    That is the strength of immutable types. Other classes are unable to change their
    values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Line 69 changes the `numAnimals` local variable (on the stack) to 500\. The
    strikethrough font for the old value and 500 for the new value represent this.
    Again, the `numAnimals` instance variable is untouched, demonstrating that primitives
    are fine in custom immutable types.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The issue becomes apparent on line 70, where we add `"Sheep"` and `"Horses"`
    to the local array list. This should not change the supposedly `private` list
    that the instance variable is looking at. But it does!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: So, we know there is a problem, but how do we fix it?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Immutable types (properly encapsulated)
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The issue here is with the reference to the mutable type being passed in and
    returned. A custom immutable type should not store or return the reference *directly*.
    Once you do that, the external class is looking at the same object and as it is
    mutable, you have no protection from the JVM. That is why lines 17 and 33 are
    in bold in *Figure 12**.16* – they are the lines causing the problem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we solve this? Well, the solution is to refer back to what we discussed
    in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), *Mastering Advanced Encapsulation*.
    In summary, we should use a technique known as “defensive copying” to deal with
    this situation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'Only two code changes need to be made to our immutable `Farm` type. One is
    in the constructor; the other is in the relevant `get` method, namely `getAnimals()`.
    *Figure 12**.17* shows the code changes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.17 – Custom immutable type, properly encapsulated](img/B19793_12_17.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Custom immutable type, properly encapsulated
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Rather than present code that has not changed, this figure presents a segment
    of the class so that we can focus on the changes. Line 16, which was commented
    out before, is now uncommented and line 17, which has the issue, is now commented
    out. Contrasting them, we can see that instead of directly storing the reference
    passed in (line 17), we are now creating a `ArrayList` object, based on the contents
    of the list passed in. We then store the reference to the new `ArrayList` object
    in our `private` instance variable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: The other change relates to lines 32 and 33\. Line 33, which has the issue,
    has been commented out, whereas line 32, which has the fix, has been uncommented.
    Again, rather than returning a copy of our `private` instance variable (line 33),
    we are creating a `ArrayList` object based on the contents of our array list and
    returning that reference. The contents of the new object can be identical to our
    private copy, so long as the external class cannot change our private copy. These
    changes achieve that. Let’s look at the situation in memory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: In-memory representation (properly encapsulated)
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the interests of clarity in the diagram, we have only shown the `ArrayList`
    objects and their references. *Figure 12**.16* already demonstrated that `String`
    objects and primitives were fine, so there’s no need to look at those elements
    again.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.18* shows the situation in memory now (at the end of the program,
    just before we exit):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.18 - In-memory representation of properly encapsulated custom
    immutable type](img/B19793_12_18.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 - In-memory representation of properly encapsulated custom immutable
    type
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the methods where each of the three `ArrayList` objects are
    created are marked in bold. For example, the bottom `ArrayList` object (marked
    A) was created in `main()`. Examining that object for a moment, we can see that
    the `animals` reference on the stack initially (dashed line) refers to it. There
    is just one `String` in it, `"Cattle"`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: This object is passed via the factory method into the constructor, where its
    content (`"Cattle"`) is used to create a *new* array list object and initialize
    the `animals` instance variable so that it points at the new object (line 16).
    This is represented in the figure by the `ArrayList` object being marked with
    `Farm()` (and the letter B).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: The call to `getAnimals()` also results in a new array list object being created
    (line 32). This new object is marked by the method name creating it, namely `getAnimals()`,
    and the letter C. Initially, it just contains `"Cattle"` as this is what the instance
    variable contains. The dashed rectangle represents this.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Now, however, when we use the local animals reference to insert both “Sheep”
    and “Horses” into the array list (marked D), the private instance array list is
    **not** affected. Thus, this class is properly encapsulated.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: That completes our coverage on creating a custom immutable type. The next few
    topics are ones we have touched upon in our recent example, namely `List` and
    `ArrayList`. Let’s discuss both in more detail now.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Examining List and ArrayList
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` is an interface implemented by the `ArrayList` class. Therefore, any
    API method in `List` is automatically in `ArrayList`. As we know, it is good coding
    practice to use an interface reference (`List`) to refer to an object (`ArrayList`).
    As the compiler looks at the reference type, this frees you up in the future to
    use different implementations of `List`, such as `LinkedList`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Both `List` and `ArrayList` are in the `java.util` package. In the API, both
    are typed generically with `E` (for `Element`), which means we are free to specify
    the type we want to store in our list. Failure to follow the declared type results
    in a compiler error. We will cover generics in detail in [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: List properties
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A list is an ordered collection (sometimes called a sequence). We have precise
    control over where in the list an element is inserted. Indices (as with arrays)
    start at 0 and duplicate elements are allowed. The order that lists maintain is
    insertion order. In other words, if you simply add two elements, the second one
    is positioned after the first one. So, lists maintain order and allow duplicates.
    *Figure 12**.19* shows a small piece of code that captures these properties:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.19 – Code demonstrating List properties](img/B19793_12_19.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – Code demonstrating List properties
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 11 declares a `List` reference called `list`, referring
    to an `ArrayList` object. The `List` reference is typed for strings, meaning that
    we can only add `String` objects to the list. As the list is implemented by `ArrayList`,
    the properties outlined here apply to `ArrayList` implementations also.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Lines 12-15 add the `J`, `A`, `V`, and `A` strings in sequence. When we output
    the list (line 17), we can see that the insertion order is maintained and that
    duplicate elements are allowed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate precise control over where elements are inserted, lines 18-19
    add `"O"` to two different locations, namely indices 1 and 3\. When we output
    the list again (line 21), we can see that the strings have been inserted into
    their correct locations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example showing other `List`/`ArrayList` API calls:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.20 – Code demonstrating “List” and ”ArrayList”](img/B19793_12_20.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – Code demonstrating “List” and ”ArrayList”
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we have several API calls and their respective output is in
    commented form on the right-hand side of each line. In this figure, our list contains
    `"Joe"`, `"Mary"`, and `"Joe"` in that order. We have the following sequence of
    API calls:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '`contains(Object o)` checks if `"Mary"` is in the list. This returns `true`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(int index)` returns the element at index 0, namely `"Joe"`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf(Object o)` returns the index of the first occurrence of `2`. This
    will be boxed as an `Integer` type, which “is-a” `Object`. However, as there is
    no such object in the list, `-1` is returned.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` as this is the index of the first occurrence of `"Joe"` in the list.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(Object o)` removes the first occurrence of the object from the list
    and returns true/false depending on whether the object was found or not. As `"Joe"`
    was present in the list, `true` is returned.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Mary"` and `"Joe"`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(int index)` removes the object at index 0, which is `"Mary"`.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Joe"` (the second `"Joe"`).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(int index, E element)` changes the contents of the given index to the
    object passed. Therefore, `"Paul"` is now in index `0`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 36**: This shows that line 35 operated as expected.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have discussed some of the API methods, let’s discuss some others.
    *Table 12.4* presents this information:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Description** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| `void add(int index,` `E element)` | Adds the element at the specified index
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `add(E e)` | Adds the element to the end of the list |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: '| `void clear()` | Removes all the elements from the list |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `contains(Object o)` | Returns `true` if the object is in the list
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
- en: '| `E` `get(int index)` | Returns the element at the specified index |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
- en: '| `boolean isEmpty()` | Returns `true` if the list is empty |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
- en: '| `int` `indexOf(Object o)` | Returns the index of the first occurrence of
    the specified element; its returns -1 if no such element exists in the list |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
- en: '| `E` `remove(int index)` | Removes the element at the specified index |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `remove(Object o)` | Removes the first occurrence of the specified
    object |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
- en: '| `E set(int index,` `E element)` | Replaces the element at the specified index
    with the given element |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
- en: '| `int size()` | Returns the number of elements in the list |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
- en: Table 12.4 – Sample “List” and “ArrayList” API methods
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: That concludes this section on examining `List` and `ArrayList`. For further
    reading please see the JavaDocs at [https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html).
    Now, let’s move on to exploring the Date API.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Date API
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.time` package was introduced in Java 8 and was designed to replace
    the previous `java.util.Date`, `java.util.Calendar`, and `java.text.DateFormat`
    classes. The classes in `java.time` represent dates, times, timezones, instants,
    periods, and durations. The ISO calendar system is followed, which is the de facto
    world calendar (following Gregorian rules). All the classes are immutable and
    thread-safe.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: It is a large API ([https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html))
    with a large number of classes for dealing with dates, with relatively fewer classes
    dealing with times. Thankfully, despite the large number of methods available,
    the consistent use of method prefixes makes this manageable. We will look at these
    API prefixes shortly. But before we do that, let’s discuss the more important
    date and time classes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Coordinated Universal Time (UTC)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: UTC is the standard by which the world regulates clocks and time. It is effectively
    a successor to **Greenwich Mean Time** (**GMT**). UTC makes no adjustment for
    daylight savings time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: The time zone uses UTC+/-00:00, which is sometimes denoted by the letter Z –
    a reference to the equivalent nautical time zone (GMT). Since the NATO phonetic
    alphabet word for Z is “Zulu”, UTC is sometimes referred to as “Zulu time.”
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: Dates and times
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five important classes here. Let’s examine each in turn:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`Instant`: An instant is a numeric timestamp. It is useful for logging and
    persistence. Historically, `System.currentTimeMillis()` would have been used.
    `System.currentTimeMillis()` returns the number of milliseconds since the “epoch
    day” (Jan 1st, 1970 at 00:00:00 UTC). The epoch is a fixed time from which all
    timestamps are calculated.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate`: Stores a date without a time. This is useful for representing
    birthdays such as 2000-10-21\. As it follows ISO-8601, the format is year-month-day.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalTime`: Stores a time without a date. This is useful for representing
    opening/closing hours such as 09:00.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDateTime`: Stores a date and time such as 2000-10-21T17:00\. Note the
    “T” used as a date and time separator. This is useful for representing the date
    and time of a scheduled event, such as a concert.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZonedDateTime`: Represents a “full” date-time with a time zone and resolved
    offset from UTC. For example, 2023-02-14T16:45+01:00[Europe/Zurich] is the date-time
    for the Europe/Zurich time zone and is 1 hour ahead of UTC.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duration and Period
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to dates and times, the API also represents durations and periods
    of time. Let’s look at these now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '`Duration`: An amount of time, represented in seconds (and nanoseconds); for
    example, “54 seconds.”'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Period`: Represents an amount of time in units more meaningful to humans,
    such as years or days. For example, “3 years, 6 months, and 12 days.”'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional interesting types
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other types are interesting also. Let’s examine some of these now.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '`Month`: Represents a month on its own; for example, JANUARY.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DayOfWeek`: Represents a day-of-week on its own; for example, FRIDAY.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YearMonth`: Represents a year and month, without a day or time; for example,
    2025-12\. This could be useful for a credit card expiry date.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonthDay`: Represents a month and day, without a year or time; for example,
    --08-09\. This could be useful for an annual event, such as an anniversary.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZoneOffset`: Represents a time zone offset from GMT/UTC, such as +2:00.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As stated earlier, there are a large number of methods across the classes. However,
    as the prefixes are consistently applied, this is manageable. *Table 12.5* represents
    these prefixes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Prefix** | **Description**Note: `ld2` and so forth used in these
    examples are related. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
- en: '| `of` | A static factory method for creating instances – for example,`LocalDate
    ld1 = LocalDate.of(2023,` `3, 17);` |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
- en: '| `parse` | A static factory method for creating instances – for example,`LocalDate
    ld2 =` `LocalDate.parse("2023-03-17");` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
- en: '| `get` | Gets the value of something – for example,`int dayOfMonth = ld2.getDayOfMonth();
    //` `17` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| `is` | Checks if something is true – for example,`boolean isLeapYear = ld2.isLeapYear();
    //` `false` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| `with` | The immutable equivalent of a setter method – for example,`LocalDate
    ld3 = ld2.withDayOfMonth(25); //` `2023-03-25` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| `plus` | Adds an amount to an object – for example,`LocalDate ld4 = ld3.plusDays(2);
    //` `2023-03-27` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| `minus` | Subtracts an amount from an object – for example,`LocalDate ld5
    = ld4.minusMonths(2); //` `2023-01-27` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| `at` | Combines this object with another – for example,`LocalDateTime ldt1
    = ld5.atTime(13, 45, 10); //` `2023-01-27T13:45:10` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: Table 12.5 – Date API method prefixes
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have had a look at the prefixes in the API, let’s look at some
    sample code to reinforce them. *Figure 12**.21* shows some code for manipulating
    dates and times:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21 – Code for manipulating dates and times](img/B19793_12_21.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – Code for manipulating dates and times
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 13 creates `LocalDate` using the factory `now()` method.
    This creates a `LocalDate` object based on the system clock setting for the default
    locale. Also, using the `now()` method, lines 14-15 create `LocalTime` and `LocalDateTime`
    objects, respectively. Line 16 shows another way to create `LocalDateTime` objects
    by using the `of()` factory method to pass in both `LocalDate` and `LocalTime`
    objects. Line 17 shows the output of the `LocalDateTime` object to be `yyyy-mm-ddThh:mm:ss:nnnnnnnnn`.
    The date part comes first, then `"T"`, which separates the date from the time,
    where `n` in the time part represent nanoseconds.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to create `LocalDate` values representing St. Patrick’s Day (March
    17), 2025\. Line 20 uses the `of()` factory method and passes in numeric values
    for the year, month, and day. Note that the months start at 1 and not 0\. Thus,
    March is represented as 3.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Line 21 uses an alternative factory method, namely `parse(String)`, which accepts
    a `String` and creates a `LocalDate` accordingly. If the string cannot be parsed,
    an exception will occur.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Line 22 outputs what day of the week, March 17, 2025, occurs (which is a Monday).
    Line 23 “modifies” the months, changing it from 3 to 5 (March to May). As the
    Date API types are immutable, the change is made to a new object in the background
    (`ld2` is untouched). The `ld3` reference refers to this new object (`2025-05-17`).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Line 25 adds a year, so we now have 2026-05-17\. Line 27 subtracts 5 days, so
    we now have 2026-05-12\. Lastly, on line 29, we “change” our `LocalDate` to `LocalDateTime`.
    As we already have a date, we just provided the time elements. The nanoseconds,
    which are not provided, are set to 0 and are not displayed as a result.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a `ZonedDateTime` example in *Figure 12**.22*:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22 – ZonedDateTime example](img/B19793_12_22.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
- en: Figure 12.22 – ZonedDateTime example
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, a flight leaves Dublin for Paris at 1 PM local time. The flight
    duration is 1 hour 45 minutes. We are trying to calculate the local time in Paris
    when the flight lands. The solution presented here is one option.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Lines 34-38 create a `LocalDateTime` object for the departure date and time
    (November 24th, 2023, at 1 P.M.). Line 39 zones the date-time object using the
    `atZone()` method by passing in the relevant time zone (a `ZoneId`). To get the
    time zone `ZoneId` object, simply call the factory `of()` method while passing
    in the relevant time zone string. In this example, it is `"Europe/Dublin"`. Line
    40 shows the format of the `ZonedDateTime` object. Note `"Z"` for Zulu time (UTC).
    At that time of year, as summertime has ended, Dublin is in line with UTC.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Lines 42-45 represent the calculation of the local arrival time in Paris. Line
    43 calculates what time is it in Paris when the flight leaves Dublin using the
    `withZoneSameInstant()` method. Now, all we have to do is add on the flight time
    of 1 hour and 45 minutes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Line 47 shows the `ZonedDateTime` for the arrival time. The time and zoned offset
    elements are interesting. The local time allows for the fact that Paris is 1 hour
    ahead of Dublin. This time difference is reflected in the offset of `+1:00`. Thus,
    Paris is 1 hour ahead of UTC.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at some code that uses `Period` and `Duration`. *Figure 12**.23*
    presents an example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.23 – An example using Period and Duration](img/B19793_12_23.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
- en: Figure 12.23 – An example using Period and Duration
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, both `Period` and `Duration` are demonstrated. `Period` is suited
    for time blocks of greater than 1 day; for example, 2 years, 5 months, and 11
    days. `Duration` is more suited to blocks of time of less than 1 day; for example,
    8 hours and 20 seconds.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Lines 57-63 calculate and output the number of years, months, and days the American
    Civil War lasted. Firstly, we create `LocalDate` objects for the start and end
    dates (lines 57-58). Line 59 creates a `Period` object using the static `Period.between()`
    method, passing in the relevant start and end dates. Line 60 outputs the period
    object, `P3Y11M28D`, which represents a `Period` of 3 years, 11 months, and 28
    days (weeks are represented in days). Lines 61-63 output the years, months, and
    days values separately.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at `Duration`. In this case, we use two `LocalTime` objects;
    one representing 12:00:20 (line 66) and the other representing 14:45:40 (line
    67). Line 68 calculates the time difference between both and line 69 outputs the
    result. Note that there is no Y, M, or D (years, months, or days) as there was
    on line 60 (`Period`). Now, on line 69, we have a `Duration` of `PT2H45M20S` representing
    2 hours, 45 minutes, and 20 seconds.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let’s look at how to format dates and times.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Formatting dates and times
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A formatter can work in both directions: formatting your temporal (time-related)
    object as a string or parsing a string into a temporal object. Both approaches
    work with formatters. This is represented by the following code from the API:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will focus on how to create formatters for the `format()` method. However,
    as formatters are common to both formatting and parsing, what we say for one applies
    to the other.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: We have a lot of flexibility in how we specify the format for our dates and
    times. Firstly, there are pre-defined standard formats available for us. In addition,
    we can specify custom formats. When specifying custom formats, the letters A-Z
    and a-z are reserved and have specific semantics. Importantly, the number of format
    letters is important – for example, MMM formats the month to Aug, whereas MM produces
    08.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: There are two common approaches to formatting your dates and times. One is to
    use `format(DateTimeFormatter)` in the `LocalDate`, `LocalTime`, `LocalDateTime`,
    and `ZonedDateTime` temporal classes. Its signature accepts a parameter of the
    `DateTimeFormatter` type. The other approach is to use `format(TemporalAccessor)`
    in the `DateTimeFormatter` class itself. `TemporalAccessor` is an interface that’s
    implemented by the temporal classes just mentioned.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at some example code, we must cover the more popular pre-defined
    formatters and format patterns. There are quite a few and we encourage you to
    look up the API for further details.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Pre-defined formatters
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to access these formatters is to use the constants in the `DateTimeFormatter`
    class or by calling the factory “of” methods in `DateTimeFormatter`. *Table 12.6*
    presents an overview of the more popular ones. Please see the API for further
    details. Note that **ISO** stands for **International Organization** **for Standardization**:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '| **Formatter** | **Description** | **Example** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
- en: '| `ofLocalizedDate (dateStyle)` | Formatter with the date style from the locale
    | This depends on the style that’s passed in. An example is “Monday 10 July 2023”.
    |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
- en: '| `ofLocalizedTime (timeStyle)` | Formatter with the time style from the locale
    | This depends on the style that’s passed in. An example is “15:47”. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
- en: '| `ofLocalizedDateTime (dateTimeStyle)` | Formatter with the date and time
    styles from the locale | This depends on the style that’s passed in. An example
    is“3 July 2018 09:19”. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
- en: '| `ISO_DATE` | ISO date (may contain offset) | “2023-07-10”, “2023-07-10+01:00”.
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| `ISO_TIME` | ISO time (may contain offset) | “15:47:13”, “15:47:13+01:00”.
    |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| `ISO_LOCAL_DATE` | ISO local date (no offset) | “2023-07-10”. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| `ISO_LOCAL_TIME` | ISO local time (no offset) | “16:00:03”. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: '| `ISO_ZONED_DATE_TIME` | Zoned date time | “2023-07-12T09:33:03+01:00 [Europe/Dublin]”.
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
- en: Table 12.6 – Date API pre-defined formatters
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine some code that uses pre-defined formatters.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.24* presents code that uses these pre-defined formatters:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24 – Code example using pre-defined formatters](img/B19793_12_24.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: Figure 12.24 – Code example using pre-defined formatters
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we represent the current date (line 74) and the current time
    (line 81) in various formats, based on the pre-defined formats available in `DateTimeFormatter`.
    First up is `ISO_DATE` (line 75). Its output (in comments on line 76) is `2023-07-10`,
    which is in yyyy-mm-dd format.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Line 78 uses the `ofLocalizedDate()` factory method to create a format. By passing
    in the `FormatStyle.FULL` enum constant, we are requesting as much detail as possible.
    As a result, this format outputs (line 79) `Monday 10 July 2023`. As can be seen,
    this is more detailed than the `ISO_DATE` format.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Line 82 creates an `ISO_TIME` formatter and applies it (line 83) to the time
    object that’s already been created (line 81). Line 85 uses the `ofLocalizedTime()`
    factory method. The `FormatStyle.SHORT` enum returns the fewest details, typically
    numeric.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: That covers the pre-defined formatters. Now, let’s discuss how to specify custom
    formatters.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Custom formatters
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Custom formatters are defined using pattern letters, where the number of letters
    used is significant. Let’s discuss the most commonly used pattern letters first
    and then present some code that utilizes them. *Table 12.7* presents a summary
    of the pattern letters:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: '| **Letter** | **Description** | **Examples** |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
- en: '| y | Year | 2023; 23 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
- en: '| M | Month | 8; 08; Aug; August |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
- en: '| d | Day of the month | 16 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
- en: '| E | Day of the week | Wed; Wednesday |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
- en: '| D | Day of the year | 145 |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
- en: '| h | Hour of the day; 12-hour clock (1-12) | 10 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| H | Hour of the day; 24-hour clock (0-23) | 19 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| m | Minute of the hour | 32 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| s | Second of the minute | 55 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '| a | A.M. or P.M. | PM |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '| z | Timezone | GMT |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| G | Era | AD |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: Table 12.7 – Date API pattern letters overview
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: 'This table is best explained with the aid of an example. *Figure 12**.25* presents
    an example that uses the pattern letters from *Table 12.7*:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25 – Code example using pattern letters](img/B19793_12_25.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
- en: Figure 12.25 – Code example using pattern letters
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 91 gets the current date and time for this timezone, which
    is **Irish Standard** **Time** (**IST**).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Irish Standard Time (IST)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: This is the timezone that’s used in Ireland. In Ireland, we utilize daylight
    savings time (“summertime”). This means that during the summer months, we advance
    the clocks forward 1 hour so that darkness falls at a later clock time. Therefore,
    in March, we put the clocks forward 1 hour, and in October, we put the clocks
    back 1 hour.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: There is no “summertime” in UTC. Because of this and the fact that it is July
    right now, IST is +1:00 hours ahead of UTC.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: The output for line 92 is in a comment to the right. The date and time are separated,
    as usual, by “T.” The zone offset is “+1:00,” indicating that this zoned time
    is 1 hour ahead of UTC. The zone ID is “[Europe/Dublin].”
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: We will first look at a date-related formatter. Line 93 creates a formatter
    using the `yy-MMM-dd E D` pattern. The output it generates is `23-Jul-11 Tue 192`
    (line 94). Thus, the current year of 2023 is output as `23` because we only provided
    `yy` in the format (as opposed to `yyyy`). Note that, had it been `yyyy` in the
    format, `2023` would have been output. This is why the number of pattern letters
    is important. The capital `M` is for the month. `M` produces `7`, `MM` produces
    `07`, `MMM` (as in the pattern) produces `Jul`, and `MMMM` produces `July`. Again,
    this demonstrates that the number of pattern letters is important.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: The `dd` pattern outputs the day of the month. This gives us `11` for the `11th`.
    `E` gives us the day of the week, which is `Tue`. Note that `EEEE` returns `Tuesday`.
    `D` represents the day of the year; the 192nd in this example.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Note that the dashes and spaces are simply inserted into the output. This is
    because, unlike letters, they are not reserved. We will learn how to insert words
    (containing letters) into the output without causing exceptions shortly.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine a time-related formatter. Line 96 creates a formatter using
    the `hh:mm:ss a z G` pattern, which generates the output (line 97) of `09:05:50
    a.m. IST AD`. The `hh:mm:ss` pattern returns the current time in hours (12-hour
    clock), minutes, and seconds format. `a` returns whether it is A.M. or P.M. Right
    now, it is the morning, so `am` is returned. The `z` pattern letter returns the
    abbreviated zone name, `IST`. Expanding this to `zzzz` returns `Irish Standard
    Time`. Lastly, `G` returns the era, `AD` (Anno Domini).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s learn how to insert text into our formatter. As we know, the letters
    a-z and A-Z are reserved. So, how do we insert letters as regular letters and
    not pattern letters? To do this, we must surround the regular letters with single
    quotes. Line 101 specifies a pattern that uses both regular letters and pattern
    letters. The pattern is “’Year: ‘*yyyy*’. Month: ‘*MMMM*’. Day: ‘*dd*’.’”. The
    pattern letters are in italics. Any other characters are enclosed in single quotes.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '`Year: 2023\. Month: July. Day: 11.` is generated as output.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the year value, `2023`, is preceded by the text `"Year: "`.
    This was achieved by surrounding the text with single quotes: `''Year: ''`. Following
    the year pattern `yyyy`, the regular text `''. Month: ''` is inserted. Thus, the
    capital `M` is treated as simply a capital M, instead of a month pattern letter.
    After that, `''. Day: ''` is inserted to precede the day of the month, which is
    `11`. Lastly, a period is inserted at the end by enclosing it in single quotes
    also. Note that the period without single quotes is also fine as it is not a reserved
    character.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let’s look at an example of parsing where we can create temporal objects
    from `String` values. Line 105 declares a string of `"2023-07-10 22:10"`. Line
    106 then declares a pattern that will be able to parse this string. The pattern
    is `"yyyy-MM-dd HH:mm"`. Note that `"HH"` represents the 24-hour clock. This will
    enable us to parse the time of `"22"` in the string.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: Line 107 creates a `LocalDateTime` object by parsing the string according to
    the pattern provided. Line 108 outputs the `LocalDateTime` object, producing `"2023-07-10T22:10"`,
    which is what the string represents.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on custom formatters and concludes [*Chapter 12*](B19793_12.xhtml#_idTextAnchor293).
    Now, let’s put that knowledge into practice to reinforce the concepts we’ve covered.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve learned so many fun new things in this chapter. It’s time to enlighten
    the users of the Mesozoic Eden software with some new features that have been
    built with our new skills:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Manage the birthdays of the dinosaurs in our park. Add the `birthday` property
    to the `Dinosaur` class.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The park operates on a strict schedule. Create a simple system to log events
    such as feeding times, cleaning, and emergency drills in the park using the Date
    API.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Mesozoic Eden, we have a very strong safety-first policy. Regular inspections
    help us maintain our high standards of safety. Create a program that calculates
    how many days are left until the park’s next safety inspection, based on the date
    of the last safety inspection. Safety inspections need to happen every 45 days.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a newborn Theropod. The guests were asked to submit names for our youngest
    inhabitant of Mesozoic Eden. 10 names were picked. Create a list for these 10
    names.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to create a string with the newborn’s full name. Use `StringBuilder`
    to append every name to its new name, and then convert it into a string when you’re
    done. (Hint: Use a loop combined with `StringBuilder`.)'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – dinosaur care system
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll continue to work on our “dinosaur care system” by adding functionality
    to log daily care activities for dinosaurs using the Java Core API. This includes
    features to accept user input, maintain a history of activities, and store dinosaur
    health data over time. Don’t worry – we’ll break this down for you step by step.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Add additional** **Java classes**:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package named `coreapi`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this package, create a class named `Dinosaur`. This class should have
    properties such as name, species, health status, and so on.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, create a class named `Activity` with properties such as name, date, dinosaur,
    and so on.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 2: Extend the dinosaur** **care system**:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: In your `DinosaurCareSystem` class, create a `List` to hold `Dinosaur` objects,
    and another `List` to hold `Activity` objects.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a method called `addDinosaur()` that takes user input to create a new
    `Dinosaur` object and add it to the list of dinosaurs.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a method called `logActivity()` that also takes user input to create
    a new `Activity` object (including selecting a dinosaur from the list) and add
    it to the list of activities.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is some sample code to get you started with this step:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Step 3: Interact with** **the system**:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: In your main class, create a `DinosaurCareSystem` object and use a loop to continuously
    ask the user what they want to do (add a dinosaur, log activity, and so on). Use
    a `Scanner` object to get input from the user.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s some code to get you started:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As always, feel free to expand on this and let your creativity run free!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at popular classes from the Java Core API. We started
    with `Scanner`, a useful class for reading input. `Scanner` can be directed to
    read from a file, a `String` object, or the keyboard. Reading from the keyboard
    is particularly useful for dealing with user input.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: We examined the `String` class and its API. We saw how `String` literals use
    the string constant pool to save on memory. We examined an important property
    of `String` objects, namely immutability. A `String` object, once created, cannot
    be changed.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examined `StringBuilder` and its API. We discussed that `StringBuilder`
    is a mutable type and thus, there is only ever one object in memory.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Given that `String` is immutable but `StringBuilder` is mutable, we presented
    a detailed example with both code and supporting diagrams to compare and contrast
    `String` and `StringBuilder`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: This led to a discussion on how to create our own custom immutable types. We
    examined a checklist of steps you must perform to ensure that your class is immutable.
    We then showed an example where, very subtly, Java’s call by value principle broke
    encapsulation (and hence immutability). We discussed how to fix such an issue
    using defensive copying. Effectively, for our `private` instance mutable types,
    we had to ensure that the references passed in to initialize them were not stored
    directly; we must copy them first. In addition, we had to ensure that we did not
    return the references to our `private` instance mutable types either; we must
    copy them first also.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: From there we examined the `List` and `ArrayList` APIs. `List` is an interface
    and `ArrayList` is an implementation of `List`. `ArrayList` is essentially an
    expandable array. It maintains the order of insertion and allows duplicates.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined the Date API, which was overhauled in Java 8\. We discussed
    `Instant`, `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`, `Period`,
    and `Duration`. All of these types are immutable, meaning we can use factory methods
    (such as `now()` and `of()`) to create instances. In a large API, the consistency
    of method prefix names is helpful.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed how we can format a temporal object for output and also
    how we can parse a string into a temporal object. We examined the pre-defined
    formatters available and in addition, we designed custom formatters using reserved
    pattern letters.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on the Java Core API. We will move on to generics
    and collections in the next chapter.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Topics'
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will take a look at some of the more advanced topics in Java.
    We will start with the Java Collection framework. This will include several of
    its popular interfaces and their common implementations. We will discuss sorting
    in Java and how to work with generics. We then move on to lambda expressions and
    their relationship to functional interfaces. We will look at popular functional
    interfaces from the API and also method references. We will then discuss streams
    over two chapters, both the fundamentals and advanced topics. The fundamentals
    will cover topics such as the stream pipeline, stream laziness, and terminal operations.
    The advanced chapter will discuss intermediate operations, primitive streams,
    `Optional`s, and parallel streams. Lastly, we will discuss concurrency, where
    we will explain multi-threading, data races, `ExecutorService,` and concurrent
    collections.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19793_13.xhtml#_idTextAnchor317), *Generics and Collections*'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19793_14.xhtml#_idTextAnchor355), *Lambda Expressions*'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19793_15.xhtml#_idTextAnchor377), *Streams: Fundamentals*'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19793_16.xhtml#_idTextAnchor401), *Streams: Advanced Concepts*'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19793_17.xhtml#_idTextAnchor430), *Concurrency*'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
