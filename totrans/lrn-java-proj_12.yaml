- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java Core API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will delve more deeply into popular classes and interfaces
    from the Java API. We will start with the `Scanner` class, which is commonly used
    for scanning and parsing text from sources such as the keyboard (the user). We
    will then examine the very popular `String` and `StringBuilder` classes. We will
    discuss their differences, which will require contrasting mutable and immutable
    types. We will also show you how to design immutable types and look at the `List`
    interface and its popular implementation class, `ArrayList`. Lastly, we will examine
    the Date API, which was overhauled in Java 8.
  prefs: []
  type: TYPE_NORMAL
- en: 'For further details on the types covered in this chapter, please refer to the
    Java Docs API: [https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the `Scanner` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing `String` with `StringBuilder`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing an immutable type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examining `List` and `ArrayList`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Date API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Scanner class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Scanner` (from the `java.util` package) is a text scanner that can parse primitives
    and strings using regular expressions. A regular expression is a pattern that
    enables string manipulation. As it states so eloquently in the Java API: “*A Scanner
    breaks its input into tokens using a delimiter pattern, which by default matches
    whitespace. The resulting tokens may then be converted into values of different
    types using the various* *next methods.*”'
  prefs: []
  type: TYPE_NORMAL
- en: These `nextXXX()` methods convert the tokens on the input stream into primitives.
    For example, if the user has typed in `23`, then `nextInt()` would return an `int`
    value of `23`; if the user typed in `45.89`, then `nextDouble()` would return
    a `double` value of `45.89`.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the token on the input stream is not an integer and `nextInt()`
    is called, an `InputMismatchException` error is thrown. This could occur if the
    user types in `"abc"` and `nextInt()` is called. To protect against this, each
    of the `nextXXX()` methods has a corresponding guardian angel method, namely `hasNextXXX()`.
    For example, `nextInt()` has a corresponding `hasNextInt()` method, `nextDouble()`
    has a corresponding `hasNextDouble()` method, and so forth. The `hasNextXXX()`
    methods all take a sneak peek at the input stream for the next token (without
    consuming it) and check if that token can be successfully converted into the type
    in question. They return `true` or `false` accordingly. If `true` is returned,
    then the corresponding `nextXXX()` method can safely be used without causing an
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 12.1* shows some of the more important `Scanner` methods. Note that
    we have just listed one of the `hasNextXXX()` methods, namely `hasNextDouble()`,
    along with its corresponding `nextXXX()` method, namely `nextDouble()`. All of
    the following types follow the same pattern: `boolean`, `byte`, `float`, `int`,
    `long`, and `short`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Scanner(InputStream source)` | Creates a `Scanner` class that produces values
    from the specified input stream – for example, the keyboard |'
  prefs: []
  type: TYPE_TB
- en: '| `Scanner(File source)` | Creates a `Scanner` class that produces values from
    the specified file |'
  prefs: []
  type: TYPE_TB
- en: '| `Scanner(String source)` | Creates a `Scanner` class that produces values
    from the specified string |'
  prefs: []
  type: TYPE_TB
- en: '| `String next()` | Returns the next token |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean hasNextDouble()` | Returns `true` if and only if the next token
    is a valid `double` value |'
  prefs: []
  type: TYPE_TB
- en: '| `double nextDouble()` | Scans the next token as a `double` value |'
  prefs: []
  type: TYPE_TB
- en: '| `String nextLine()` | Returns (the rest of) the line |'
  prefs: []
  type: TYPE_TB
- en: '| `Scanner` `useDelimiter(String pattern)` | Sets the Scanner’s delimiting
    pattern according to the argument passed |'
  prefs: []
  type: TYPE_TB
- en: Table 12.1 – Sample “Scanner” API methods
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at some examples in code.
  prefs: []
  type: TYPE_NORMAL
- en: Using Scanner to read from the keyboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The standard input stream can be accessed with `System.in`. Typically, this
    is the keyboard. When creating our `Scanner`, we must pass the input source (`System.in`,
    in this case) as an argument of the `Scanner` constructor. *Figure 12**.1* shows
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – “Scanner” taking input from the keyboard](img/B19793_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – “Scanner” taking input from the keyboard
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, on line 23, we create a `Scanner` object referring to the keyboard
    by passing `System.in` to the `Scanner` constructor. Line 24 simply prompts the
    user to type in an age. Line 25 is the guardian angel method to protect against
    exceptions. If the next token on the input is of the `int` type, then the condition
    on line 25 will be `true` and we can safely execute `nextInt()` on line 26\. Line
    27 echoes the integer that was typed on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Closing a Scanner resource
  prefs: []
  type: TYPE_NORMAL
- en: Closing resources once you are finished with them is prudent as it prevents
    resource leaks. However, a `Scanner` object wrapped around `System.in` is a little
    different. In effect, if we close a `Scanner` object that was wrapped around `System.in`,
    we won’t be able to read from standard input again.
  prefs: []
  type: TYPE_NORMAL
- en: This is what lines 30-34 in *Figure 12**.1* are demonstrating. If we close the
    `Scanner` object (line 30), even though lines 31-34 are essentially the same as
    lines 23-27 (bar `hasNextInt()`), an exception is thrown on line 33\. This is
    because we are attempting to access a closed resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at an example that will further explain tokens and delimiters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – next() delimited by whitespace](img/B19793_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – next() delimited by whitespace
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we are using `next()` to try and parse `Sean Kennedy` from
    the input stream (keyboard). However, the (default) delimiter is whitespace, and
    thus, `Sean` is returned. Note that `Kennedy` is still there in the input stream.
    We could invoke `next()` a second time to consume the extra `Kennedy` token. However,
    there is a method that solves this issue: `nextLine()`. *Figure 12**.3* shows
    `nextLine()` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – nextLine() delimited by the end of the line](img/B19793_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – nextLine() delimited by the end of the line
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we are using `nextLine()`, which uses a different delimiter.
    Rather than whitespace delimiting the tokens (as with `next()`), the newline character
    delimits `nextLine()`). In effect, `nextLine()` reads a line of text, whereas
    `next()` reads words. Line 17 demonstrates this by outputting `Sean Kennedy`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Scanner` can be redirected to other sources for input. One such source is
    a file.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Scanner to read from a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s examine how we can direct `Scanner` to read from a file, as opposed to
    the keyboard. *Figure 12**.4* shows such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – “Scanner” taking input from a file](img/B19793_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – “Scanner” taking input from a file
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the file in question (`ages.txt`) is a simple text
    file containing the number `12`, followed by a carriage return. We pass the `File`
    object into the `Scanner` constructor (lines 34-36). The `String` object that’s
    passed into the `File` constructor (lines 35-36) is a relative path. In other
    words, it is appended to the current working directory (as opposed to an absolute
    path, which contains the full path from the root). `\\` within `String` is where
    we are escaping the backslash (`\`). Java converts `\\` into a single backslash
    internally. Therefore, `"out\\production"` becomes `"out\production"`. The `hasNextInt()`
    and `nextInt()` methods (lines 37 and 38) work as before.
  prefs: []
  type: TYPE_NORMAL
- en: As we are using try-with-resources, we do not need to remember to explicitly
    close the `Scanner` or `File` resources (they are closed implicitly for us).
  prefs: []
  type: TYPE_NORMAL
- en: Another possible source for `Scanner` input is a `String` object. Let’s look
    at that now.
  prefs: []
  type: TYPE_NORMAL
- en: Using Scanner to read from a string
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `String` as an input `Scanner` source is also possible. *Figure 12**.5*
    shows such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – “Scanner” taking input from a string](img/B19793_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – “Scanner” taking input from a string
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we declare a `String` object (line 14) and pass it to the `Scanner`
    constructor (line 15). We then chain the `useDelimiter(String)` method onto the
    `Scanner` object that is returned. This method accepts `String` as an argument
    and represents the regular expression pattern required to parse the input. The
    double backslash is, as before, simply escaping the backslash. In other words,
    `\\` becomes `\`.
  prefs: []
  type: TYPE_NORMAL
- en: The `\s*` regular expression translates into *0 or more whitespace characters*.
    `*` represents *0 or more* and `\s` represents *a single whitespace character*.
    The `delim` string is hardcoded. This means that the input tokens are delimited
    by 0 or more spaces, followed by the `delim` token, followed by 0 or more spaces.
  prefs: []
  type: TYPE_NORMAL
- en: When we apply this delimiter pattern to the given input string (line 14), the
    first token returned by `next()` is `Maaike`. This is output by line 16\. As `Maaike`
    has now been consumed from the input stream, the `next()` method call (line 17)
    returns the `van` token, which is then output. Similarly, the `next()` method
    on line 18 returns `Putten` to be output. Lastly, line 19 uses `nextInt()` to
    return 22 as an `int` type, which is then output to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to obtain input from the user, let’s cover two of the most
    important classes dealing with strings, namely `String` and `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing String with StringBuilder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When dealing with strings, these two classes are your go-to classes. Their primary
    difference is that `String` objects are immutable, whereas `StringBuilder` objects
    are mutable. This means that for strings, once you create a `String` object, you
    cannot ever change that object. Java might make it look like you changed the object
    but you haven’t; a new object, reflecting your changes, has been created. `StringBuilder`
    objects, on the other hand, are mutable. This means that you are working with
    one object all the time. We will delve into this with an example later.
  prefs: []
  type: TYPE_NORMAL
- en: Why immutability?
  prefs: []
  type: TYPE_NORMAL
- en: Immutability is attractive from a security perspective as immutable objects
    cannot be changed. In addition, immutable objects are thread-safe in a multi-threaded
    environment. In multi-threaded environments, changes to (non-immutable) objects
    have to be synchronized one at a time so that changes do not interfere with one
    another Immutable objects are, by definition, protected from that. See [*Chapter
    17*](B19793_17.xhtml#_idTextAnchor430) (Concurrency) for a discussion on multi-threading.
  prefs: []
  type: TYPE_NORMAL
- en: For the moment, let’s start with the `String` class.
  prefs: []
  type: TYPE_NORMAL
- en: String class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `String` class is in the `java.lang` package and represents a sequence of
    characters. As the class is in `java.lang`, it is automatically imported for you.
    The `String` class implements the `Comparable` interface, meaning that a natural
    ordering is defined when sorting strings. This ordering is alphabetic.
  prefs: []
  type: TYPE_NORMAL
- en: As stated, `String` is an immutable type. Objects of the `String` type, once
    created, cannot be modified. `String` is also a `final` class, which means that
    you cannot subclass it. This is deliberate – the Java designers expect strings
    to behave in a certain way. If we were allowed to subclass `String` and override
    its behavior, unexpected results would occur. So, making the class `final` prevents
    this by ensuring predictable string behavior.
  prefs: []
  type: TYPE_NORMAL
- en: All `String` literals are instances of the `String` class. `String` literals
    are stored in a special area of the heap called the string pool (or string constant
    pool). This is known as *interning* the string. If another string literal with
    the same character sequence is encountered, the string in the string pool is reused.
    This saves on memory. However, if you use the `new` keyword to create your `String`
    object, a new object with the character sequence is created on the heap, even
    if such an object is available in the string pool. In other words, the string
    pool is ignored if `new` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at an example in code, as well as a supporting in-memory diagram.
  prefs: []
  type: TYPE_NORMAL
- en: String example (code)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.6* represents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.6 – “String” example in code](img/B19793_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – “String” example in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, on line 5, we use the `s1` string reference to refer to the
    `"abc"` string literal. When the JVM encounters a string literal, it first checks
    if the same string literal exists in the string pool. If it does, it reuses the
    one from the pool. As line 5 is the first time `"abc"` is encountered, the `String`
    object with `"abc"` is inserted into the pool. Note that the string pool is simply
    a special area in the heap.
  prefs: []
  type: TYPE_NORMAL
- en: Line 6 is where the string pool object is reused. Now, we have both `s1` and
    `s2` referring to the same `String` object (in the pool). This is why line 7 outputs
    `true`. Recall that when the `==` operator is used with references, we are comparing
    the references. In other words, are both `s1` and `s2` referring to the same object
    in memory? Yes, they are.
  prefs: []
  type: TYPE_NORMAL
- en: Line 8 uses the `new` keyword to create a `String` object. Once `new` is used,
    regardless of the same literal `"abc"` being used, a completely new object is
    created in a separate part of the heap. As line 8 creates a new object, when we
    compare `s1` and `s3` on line 9, the result is `false`. This is because `s1` and
    `s3` refer to two different objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `String` object’s method, `equals()`, operates differently from the equivalence
    operator, `==`. Rather than compare the references, `equals()` compares the contents
    of the objects. As line 10 returns `true`, it shows that the contents of the objects
    referred to by `s1` and `s2` are the same. This should not be a surprise as both
    `s1` and `s2` refer to the same object.
  prefs: []
  type: TYPE_NORMAL
- en: Line 11, however, also returns `true`. Even though `s1` and `s3` refer to different
    objects, this demonstrates that `equals()` compares the object’s contents and
    not the references.
  prefs: []
  type: TYPE_NORMAL
- en: Line 12 is interesting. We can intern a string by using its `intern()` method.
    What we are saying on line 12 is “Intern in the string pool what `s3` is referring
    to, and make the `s3` reference refer to the string pool object.” Line 13 returns
    `true`, demonstrating that both `s1` and `s3` now refer to the same string object.
    Note that line 13 is the same code as line 9, which returned `false` previously.
  prefs: []
  type: TYPE_NORMAL
- en: A diagram will certainly help here, so let’s examine what is happening in memory.
  prefs: []
  type: TYPE_NORMAL
- en: String example (diagram)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.7* represents the in-memory representation of the code in *Figure
    12**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – “String” example in memory](img/B19793_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – “String” example in memory
  prefs: []
  type: TYPE_NORMAL
- en: 'As can be seen from the preceding figure, both `s1` and `s2` refer to the `"abc"`
    object in the string pool. The dashed line from `s3` represents the object that
    was created by using the `new` keyword (line 8). Thus, we have two separate string
    objects: one on the heap and one in the pool (which is also part of the heap).'
  prefs: []
  type: TYPE_NORMAL
- en: The solid line from `s3` represents the result of the interning operation on
    line 12\. Now, it is straightforward to see why, after line 12, that `s1 == s3`
    returns `true`.
  prefs: []
  type: TYPE_NORMAL
- en: So, when using strings, if you are interested in comparing the contents, use
    the `equals()` method. Note that `equals()` is case-sensitive. There is a method,
    namely `equalsIgnoreCase()`, which is case insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: An important property of `String` objects is the fact that they are immutable.
    Let’s discuss that now.
  prefs: []
  type: TYPE_NORMAL
- en: String immutability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This topic is very important if you want to create immutable types or wish to
    obtain Java certification. We will discuss how to create a custom immutable type
    later. Regarding the `String` class, it is the object that is immutable and not
    the reference. What this means is that you can change the reference to point to
    a different string, but you cannot change the contents of the string object itself.
    Also, note that all the “wrapper” types, such as `Integer`, `Double`, `Float`,
    and `Character`, are also immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example in code, with an associated in-memory diagram. *Figure
    12**.8* represents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – “String” immutability (code)](img/B19793_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – “String” immutability (code)
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, on line 18, using the `"The "` literal, we create a `String`
    object that’s referred to by the `s` reference. As this is a literal, the object
    goes into the string pool. Line 19 appends `"quick "` to `s` using the `+=` operator.
    As line 20 outputs `"The quick "`, you would be forgiven for thinking that the
    string object referred to by `s` has changed. This is not the case. As `String`
    objects are immutable, this is not allowed. What happens is that a new `String`
    object is created reflecting the requested changes. Therefore, we have three `String`
    objects on line 20: the two literals, `"The "` and `"quick "`, are in the string
    pool, and the newly created `"The quick "` object is on the heap.'
  prefs: []
  type: TYPE_NORMAL
- en: Line 21 is revealing. Many of the `String` API methods return a `String` (reference).
    As `String` objects are immutable, this `String` reference that’s returned is
    a reference to the newly created `String` object. This object is created in the
    background and reflects the requested changes. As we have not stored the reference
    on line 21, this object is lost to us and is immediately eligible for garbage
    collection. When we output `s` on line 22, you can see that it has not changed;
    its content is still `"The` `quick "`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 23 shows what line 21 should have done. By reinitializing `s`, we redirect
    the reference to the newly created object. Consequently, when we output `s` on
    line 24, we get the full string – that is, `"The quick` `brown fox"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram representing what is happening in memory will help here. *Figure
    12**.9* represents the in-memory representation of the code from *Figure 12**.8*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.9 – “String” immutability (diagram)](img/B19793_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – “String” immutability (diagram)
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, dashed lines represent overwritten references. We have
    six `String` objects in total – three string literals in the pool and three constructed
    string objects using both the `+=` operator and the `concat()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that the string object in the middle (at the bottom), has no reference
    pointing to it. It never had, hence there is no dashed line pointing to it. This
    is the object that was created by line 21 but as the reference was never assigned
    to a variable, it was lost.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, line 23 did store the reference to the newly created string
    object. It overwrote what was in the `s` reference. This is why `s` is referring
    to `"The quick` `brown fox"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we discuss `StringBuilder`, we will re-write the code from *Figure 12**.8*.
    For the moment, we will look at the more important methods in the `String` API.
    These are reflected in *Table 12.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `char` `charAt(int index)` | Returns the character at the specified index.
    Indices range from 0 (as per arrays) to `length()`-1. |'
  prefs: []
  type: TYPE_TB
- en: '| `int` `compareTo(String anotherString)` | Compares two strings character
    by character lexicographically (dictionary order). In other words, `this.charAt(k)-anotherString.charAt(k)`.
    For example, `"ace"` comes before `"bat"`, `"and"` comes before `"at"`, and so
    forth. If all characters match but the two string lengths differ, then the shorter
    string precedes the longer string. For example, `"bat"` comes before `"battle"`.
    Let’s take a look:`"ace".compareTo("bat")` returns `-1`;`"and".compareTo("at")`
    returns `-6`;`"bat".compareTo("battle")` returns `-3` |'
  prefs: []
  type: TYPE_TB
- en: '| `String` `concat(String str)` | Concatenates the argument string to this
    string.`"abc".concat("def")` returns `"abcdef"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `endsWith(String suffix)` | Does this string end with the specified
    suffix? As it uses `equals(Object)`, it is case-sensitive.`"abc".endsWith("bc")`
    returns true.`"abc".endsWith("BC")` returns false. |'
  prefs: []
  type: TYPE_TB
- en: '| `int hashCode()` | Returns a hash code for this string. Hash codes are used
    to store/retrieve objects used in hash-based collections such as `HashMap`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int` `indexOf(String str)` | Returns the index of the first occurrence of
    the specified substring. It is case-sensitive and overloaded.`"abcdef".indexOf("b")`
    returns `1`.`"abcdef".indexOf("B")` returns `-1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `int length()` | Returns the length of the string. |'
  prefs: []
  type: TYPE_TB
- en: '| `String` `substring(int beginIndex)` | Returns the substring of this string,
    starting at the specified `beginIndex` and proceeding until the end of this string.
    Indices start at 0.`"abcdef".substring(3)` returns `"def"`. |'
  prefs: []
  type: TYPE_TB
- en: '| `String substring(int beginIndex,` `int endIndex)` | Returns the substring
    of this string. The substring begins at the specified `beginIndex` and extends
    to the character at `endIndex`-1\. Indices start at 0.Think: “Give me `endIndex-startIndex`
    characters, starting at `startIndex`.” For example,`"Sean Kennedy".substring(3,8)`
    means “Give me 5 characters, starting at index 3,” which returns `"``n Ken"`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `String toLowerCase()``String toUpperCase()` | Converts the string to lowercase
    and uppercase, respectively. |'
  prefs: []
  type: TYPE_TB
- en: '| `String trim()` | The `trim()` method removes whitespace from both ends of
    a string – for example,`" lots of spaces here` `".trim()` returns `""lots of spaces`
    `here""` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.2 – Sample “String” API methods
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s turn our attention to the `StringBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `StringBuilder` class is also in the `java.lang` package and represents
    a mutable sequence of characters. The API for `StringBuilder` is the same as for
    the `StringBuffer` class. Use `StringBuilder` in a single-thread environment and
    use `StringBuffer` in a multithreading environment. `StringBuilder` also implements
    the `Comparable` interface where the natural ordering defined for sorting is also
    alphabetic.
  prefs: []
  type: TYPE_NORMAL
- en: '`StringBuilder` is a mutable type. `StringBuilder` is also a `final` class,
    which means that you cannot subclass it. Again, this is deliberate as the Java
    designers wanted to ensure predictable behavior from `StringBuilder` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: As promised earlier, we will refactor *Figure 12**.8* to use `StringBuilder`
    instead of `String`. In addition, we will diagram the differences in memory.
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder example (code)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.10* represents the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – “StringBuilder” example in code](img/B19793_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – “StringBuilder” example in code
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 49 creates a new `StringBuilder` object and initializes
    it to `"The "`. Line 50 uses the `append()` method to append `"quick "` to the
    object referenced by `sb`. As `StringBuilder` objects are mutable, we can ignore
    the reference returned (as we have that reference in `sb` already). Line 51 outputs
    `"The quick "`, thereby demonstrating that the (one) `StringBuilder` object was
    changed. Line 52 appends `"brown fox"` to the `StringBuilder` object and line
    53 again shows that there is only one object all the time.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s have a look at the in-memory representation of *Figure 12**.10*.
  prefs: []
  type: TYPE_NORMAL
- en: StringBuilder example (diagram)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.11* represents the in-memory representation of the code in *Figure
    12**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – “StringBuilder” example in memory](img/B19793_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – “StringBuilder” example in memory
  prefs: []
  type: TYPE_NORMAL
- en: As can be seen from this figure, apart from the string pool objects (which are
    there as they are string literals), we only have one `StringBuilder` object. Each
    time we call `append()`, that one mutable `StringBuilder` object is changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the more commonly used API methods from `StringBuilder`.
    *Table 12.3* reflects this API:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `StringBuilder` `append(String str)` | Appends the specified string to `StringBuilder`.
    Overloaded versions are available (see the API). |'
  prefs: []
  type: TYPE_TB
- en: '| `char` `charAt(int index)` | Returns the character at the specified index.
    Indices range from 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `int` `indexOf(String str)` | Returns the index of the first occurrence of
    the specified substring. |'
  prefs: []
  type: TYPE_TB
- en: '| `StringBuilder insert(int offset,` `String str)` | Inserts the given string
    into the `StringBuilder` object at the specified offset, moving any characters
    above that position upwards. |'
  prefs: []
  type: TYPE_TB
- en: '| `String` `substring(int beginIndex)` | Returns a new string, starting at
    the specified `beginIndex`, and proceeds until the end of this string builder.
    Indices start at 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `String substring(int beginIndex,` `int endIndex)` | Returns a new string,
    starting at the specified `beginIndex`, and extends to the character at `endIndex-1`.
    Indices start at 0. |'
  prefs: []
  type: TYPE_TB
- en: '| `String toString()` | Returns a string representation of the character sequence.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.3 – Sample “StringBuilder” API methods
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, the major difference between `String` and `StringBuilder` is
    that `String` objects are immutable, whereas `StringBuilder` objects are mutable.
    Let’s look at an example that will help bring that difference into sharp focus.
  prefs: []
  type: TYPE_NORMAL
- en: String versus StringBuilder example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will use a sample piece of code to demonstrate this. This code will help
    highlight both the immutability of `String` objects and the mutability of `StringBuilder`
    objects. As a bonus, because we are using methods, the code will help us revise
    the principle of call by value. *Figure 12**.12* shows the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – “String” versus “StringBuilder” code example](img/B19793_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – “String” versus “StringBuilder” code example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, on line 11, we declare a `String` reference, `s`, that’s referring
    to `"Hi"` and a `StringBuilder` reference, `sb`, that contains `"Hi"` also. On
    line 13, we invoke the `whatHappens()` method, passing in both `s` and `sb`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As Java uses call by value, a copy of each reference is made. Thus, the `s`
    and `sb` references in the method declaration (line 4) refer to the same objects
    that were declared on lines 11 and 12, respectively. While not necessary, keeping
    the same identifiers, `s` and `sb`, helps emphasize this point.
  prefs: []
  type: TYPE_NORMAL
- en: Line 5 then concatenates `" there!"` onto the string referenced by `s`. As strings
    are immutable, that object cannot be changed, so the JVM creates a new object
    with the character sequence (string value) of `"Hi there!"`. Line 7 outputs this
    new string.
  prefs: []
  type: TYPE_NORMAL
- en: Line 6 appends `" there!"` to the `StringBuilder` object. As it is mutable,
    the object is simply modified. Line 8 outputs `sb` after this change.
  prefs: []
  type: TYPE_NORMAL
- en: After the method call on line 13 returns, we output both the values of the string
    object referred to by `s` and the string builder object referred to by `sb`. Remember,
    because we passed in references and because of call by value, the `whatHappens()`
    method had direct access to the objects declared in `main()` on lines 11 and 12\.
    However, when we output the string object (line 14), we see that it is still `"Hi"`,
    demonstrating that `String` objects are immutable. On the other hand, when we
    output the `StringBuilder` object, it has changed to `"Hi there!"`, demonstrating
    the mutability of `StringBuilder` objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'A diagram will help here. However, to keep the diagram simple and to focus
    on mutability/immutability, the string pool has been omitted. *Figure 12**.13*
    is the in-memory representation of the code in *Figure 12**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 - ”String” versus “StringBuilder” in memory](img/B19793_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 - ”String” versus “StringBuilder” in memory
  prefs: []
  type: TYPE_NORMAL
- en: This figure represents the picture in memory as we are just about to leave the
    `whatHappens()` method (line 9). The dashed arrow is the important arrow. When
    we entered the `whatHappens()` method, both `s` references were pointing at the
    same `String` object. Line 5 changes the local `s` reference to point to the new
    `String` object and the original `String` object was untouched (as it is immutable).
    The other thing to notice is that the `StringBuilder` object has been modified
    (we used a strikethrough to highlight this).
  prefs: []
  type: TYPE_NORMAL
- en: Thus, when we return to `main()` after calling the method (line 13), the `s`
    reference is referring to the untouched `String` object containing `"Hi"`, whereas
    the `sb` reference is referring to the modified `StringBuilder` object containing
    `"``Hi there!"`.
  prefs: []
  type: TYPE_NORMAL
- en: This discussion on immutable types leads to a natural question, how do I create
    a custom immutable type? That is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Designing a custom immutable type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the API, there are mutable types, such as `StringBuilder` and `ArrayList`,
    and immutable types, such as `String` and `Integer`. When something is “immutable,”
    it means it cannot change. We can use the `final` keyword to make a primitive
    value immutable. When we apply `final` to a reference, it is the reference that
    is immutable and not the object.
  prefs: []
  type: TYPE_NORMAL
- en: What if we wanted to create our own type (class) and make it immutable? In other
    words, we want the *objects* based on our custom class to be immutable. What considerations
    are involved? That is what we’ll discuss in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Before we present the checklist, recall that Java uses call by value when passing
    arguments to, and retrieving values from, methods. Call by value implies that
    a copy of the argument is made and that the method works with that copy. For primitives,
    this means that the called method cannot change the primitive value passed from
    the caller method. This is analogous to passing a photocopy of a sheet of paper;
    the photocopied sheet can be written on, without it changing the original. For
    references, however, the situation is different. Passing a reference to a method
    means that the called method can change the object that the caller method is looking
    at. This is analogous to passing a copy of a remote control; the copy-remote can
    change the TV channel also. This is reflected in the checklist. Let’s examine
    this checklist.
  prefs: []
  type: TYPE_NORMAL
- en: The checklist
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The checklist to apply is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Do not provide any “setter” methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make all the fields `private` and `final`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prevent subclassing (so that methods cannot be overridden):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the class `final`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the constructor `private` and provide a `public static` factory method
    such as `createNewInstance`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Regarding instance fields, bear in mind that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable types such as `String` are ok
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For mutable types such as `StringBuilder`, do *not* share the references – use
    the advanced encapsulation technique outlined in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
    This technique is also known as “defensive copying”.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This checklist is best explained with the aid of a code example. We will start
    with an example that looks fine but has a subtle issue. We will examine the issue
    in memory to explain it further. Finally, we will address the issue in code and
    show why it works in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable type (breaking encapsulation)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.14* presents such an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.14 – A custom immutable type that breaks encapsulation](img/B19793_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – A custom immutable type that breaks encapsulation
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we have an immutable type called `Farm`. The class is `final`
    (line 6), so it cannot be subclassed. All of the fields are `private` and `final`
    (lines 8-10). Marking them as `private` ensures no external classes can change
    their values without our knowledge (basic encapsulation). Marking them as `final`
    means that once given initial values, those values cannot change. In this example,
    as they are not given initial values at the point of declaration, they are known
    as *blank finals*. Blank finals must be initialized before the constructor finishes,
    which is what we do (lines 14-17).
  prefs: []
  type: TYPE_NORMAL
- en: Our constructor is marked `private` on line 13\. Thus, no external class can
    `new` a `Farm` object directly via this constructor. This is another way to prevent
    subclassing, as no subclass will have access to this constructor and as we have
    a constructor coded, the compiler will not insert the default constructor either.
    We have marked the constructor parameters as `final` also, in case of accidental
    change.
  prefs: []
  type: TYPE_NORMAL
- en: The `createNewInstance()` factory method (lines 20-23) is how we enable external
    classes to create `Farm` objects. We provide a `public` `static` method that calls
    the `private` constructor on their behalf. Marking it as `public` gives every
    class access to this method; marking it as `static` ensures that clients do not
    have to create an object to create a `Farm` (which they can’t do directly anyway!).
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are no `set` methods, only `get` methods (lines 25-34). There
    is one `get` method per instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this class breaks encapsulation. This is because, in the constructor
    (line 17), we are storing the reference that was passed in. In addition, our `getAnimals()`
    method is returning the reference we stored. We will see the implications of this
    in memory shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, for now, let’s look at a client class utilizing the “supposedly immutable”
    `Farm` class. *Figure 12**.15* highlights an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – A class that uses a weakly encapsulated custom immutable type](img/B19793_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – A class that uses a weakly encapsulated custom immutable type
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we declare a `List` (interface) reference, namely `animals`,
    referring to an `ArrayList` object (line 54). By stating the reference is of the
    `List<String>` type, we are telling the compiler that only strings are allowed.
    This gives us type safety, as we cannot, for example, add an `Integer` object
    to our list. As `ArrayList` is a mutable type, it is perfect for our example.
    Line 55 adds `"Cattle"` to our `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: Line 57 uses the `createNewInstance()` factory method, passing in `"Small Farm"`,
    `25`, and our `animals` array list. Line 58 proves that the object was created
    properly.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 61-63 are where we initialize the local variables based on the `Farm`
    object’s state (the values of the instance variables). Lines 64-65 check that
    they are set as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 68-70 are where we change the *local* variables. This is the acid test.
    Changing the local variables should *not* affect the state of our `Farm` object.
    On line 73, we output the instance variables again, via the implicit call to `toString()`.
    The output is in a comment on the previous line, line 72\. As can be seen from
    the output, the instance’s `String` variable name is unaffected (still `"Small
    Farm"`) and the `numAnimals` instance primitive is also unaffected (still 25).
    However, the `animals` instance variable has changed! The `ArrayList` object type
    is the issue here. Originally, the list was just `"Cattle"`; now, it is `"Cattle"`,
    `"Sheep"`, and `"Horses"`. This change is highlighted by the rectangles. How did
    this happen? Looking at the situation in memory will reveal the issue.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory representation (breaking encapsulation)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*Figure 12**.16* shows the situation in memory (as we are just about to exit
    the program). Note that *Figure 12**.16* represents the whole program across both
    figures, namely *Figure 12**.14* and *Figure 12**.15*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.16 – Encapsulation broken by a custom “immutable” type](img/B19793_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – Encapsulation broken by a custom “immutable” type
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the dashed lines represent original states or values.
    For example, the dashed line from the `name` variable, on the stack in `main()`,
    represents line 61 in the code. In contrast, the sold line from the same variable
    represents line 68.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s discuss the stack first. The local `farm` reference refers to the `Farm`
    object on the heap, which is where the `name`, `numAnimals`, and `animals` instance
    variables are initialized accordingly. As stated, the local `name` variable in
    `main()` is initialized (line 61) to refer to the same `String` object that the
    instance variable in the `Farm` object is looking at. The local `numAnimals` variable
    is initialized to the value of the instance variable of the same name (line 62).
    Note that the local copy is represented as a rectangle and not an arrow; this
    reflects the photocopy of a sheet of paper analogy. Line 63 initializes the local
    `animals` reference to point to the same `ArrayList` object as the `animals` instance
    variable in the `Farm` object on the heap. This is the problem, as we shall see
    very shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Just as we start to execute line 68, both `name` references, the local one on
    the stack and the instance one on the heap, are referring to the same `String`
    object. Line 68 changes the `name` local variable to `"Big Farm"`. However, as
    `String` objects are immutable, a new `String` object is created on the heap reflecting
    those changes. In other words, a new `String` object with `"Big Farm"` is created
    and `name` (on the stack) refers to it. The dashed line, referring to the original
    `String` object, and the solid line referring to the new `String` object represent
    this (from `name` on the stack).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `name` *instance* variable is completely unaffected by this change.
    That is the strength of immutable types. Other classes are unable to change their
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Line 69 changes the `numAnimals` local variable (on the stack) to 500\. The
    strikethrough font for the old value and 500 for the new value represent this.
    Again, the `numAnimals` instance variable is untouched, demonstrating that primitives
    are fine in custom immutable types.
  prefs: []
  type: TYPE_NORMAL
- en: The issue becomes apparent on line 70, where we add `"Sheep"` and `"Horses"`
    to the local array list. This should not change the supposedly `private` list
    that the instance variable is looking at. But it does!
  prefs: []
  type: TYPE_NORMAL
- en: So, we know there is a problem, but how do we fix it?
  prefs: []
  type: TYPE_NORMAL
- en: Immutable types (properly encapsulated)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The issue here is with the reference to the mutable type being passed in and
    returned. A custom immutable type should not store or return the reference *directly*.
    Once you do that, the external class is looking at the same object and as it is
    mutable, you have no protection from the JVM. That is why lines 17 and 33 are
    in bold in *Figure 12**.16* – they are the lines causing the problem.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do we solve this? Well, the solution is to refer back to what we discussed
    in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), *Mastering Advanced Encapsulation*.
    In summary, we should use a technique known as “defensive copying” to deal with
    this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only two code changes need to be made to our immutable `Farm` type. One is
    in the constructor; the other is in the relevant `get` method, namely `getAnimals()`.
    *Figure 12**.17* shows the code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.17 – Custom immutable type, properly encapsulated](img/B19793_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Custom immutable type, properly encapsulated
  prefs: []
  type: TYPE_NORMAL
- en: Rather than present code that has not changed, this figure presents a segment
    of the class so that we can focus on the changes. Line 16, which was commented
    out before, is now uncommented and line 17, which has the issue, is now commented
    out. Contrasting them, we can see that instead of directly storing the reference
    passed in (line 17), we are now creating a `ArrayList` object, based on the contents
    of the list passed in. We then store the reference to the new `ArrayList` object
    in our `private` instance variable.
  prefs: []
  type: TYPE_NORMAL
- en: The other change relates to lines 32 and 33\. Line 33, which has the issue,
    has been commented out, whereas line 32, which has the fix, has been uncommented.
    Again, rather than returning a copy of our `private` instance variable (line 33),
    we are creating a `ArrayList` object based on the contents of our array list and
    returning that reference. The contents of the new object can be identical to our
    private copy, so long as the external class cannot change our private copy. These
    changes achieve that. Let’s look at the situation in memory.
  prefs: []
  type: TYPE_NORMAL
- en: In-memory representation (properly encapsulated)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the interests of clarity in the diagram, we have only shown the `ArrayList`
    objects and their references. *Figure 12**.16* already demonstrated that `String`
    objects and primitives were fine, so there’s no need to look at those elements
    again.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.18* shows the situation in memory now (at the end of the program,
    just before we exit):'
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.18 - In-memory representation of properly encapsulated custom
    immutable type](img/B19793_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.18 - In-memory representation of properly encapsulated custom immutable
    type
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, the methods where each of the three `ArrayList` objects are
    created are marked in bold. For example, the bottom `ArrayList` object (marked
    A) was created in `main()`. Examining that object for a moment, we can see that
    the `animals` reference on the stack initially (dashed line) refers to it. There
    is just one `String` in it, `"Cattle"`.
  prefs: []
  type: TYPE_NORMAL
- en: This object is passed via the factory method into the constructor, where its
    content (`"Cattle"`) is used to create a *new* array list object and initialize
    the `animals` instance variable so that it points at the new object (line 16).
    This is represented in the figure by the `ArrayList` object being marked with
    `Farm()` (and the letter B).
  prefs: []
  type: TYPE_NORMAL
- en: The call to `getAnimals()` also results in a new array list object being created
    (line 32). This new object is marked by the method name creating it, namely `getAnimals()`,
    and the letter C. Initially, it just contains `"Cattle"` as this is what the instance
    variable contains. The dashed rectangle represents this.
  prefs: []
  type: TYPE_NORMAL
- en: Now, however, when we use the local animals reference to insert both “Sheep”
    and “Horses” into the array list (marked D), the private instance array list is
    **not** affected. Thus, this class is properly encapsulated.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our coverage on creating a custom immutable type. The next few
    topics are ones we have touched upon in our recent example, namely `List` and
    `ArrayList`. Let’s discuss both in more detail now.
  prefs: []
  type: TYPE_NORMAL
- en: Examining List and ArrayList
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`List` is an interface implemented by the `ArrayList` class. Therefore, any
    API method in `List` is automatically in `ArrayList`. As we know, it is good coding
    practice to use an interface reference (`List`) to refer to an object (`ArrayList`).
    As the compiler looks at the reference type, this frees you up in the future to
    use different implementations of `List`, such as `LinkedList`.'
  prefs: []
  type: TYPE_NORMAL
- en: Both `List` and `ArrayList` are in the `java.util` package. In the API, both
    are typed generically with `E` (for `Element`), which means we are free to specify
    the type we want to store in our list. Failure to follow the declared type results
    in a compiler error. We will cover generics in detail in [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317).
  prefs: []
  type: TYPE_NORMAL
- en: List properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A list is an ordered collection (sometimes called a sequence). We have precise
    control over where in the list an element is inserted. Indices (as with arrays)
    start at 0 and duplicate elements are allowed. The order that lists maintain is
    insertion order. In other words, if you simply add two elements, the second one
    is positioned after the first one. So, lists maintain order and allow duplicates.
    *Figure 12**.19* shows a small piece of code that captures these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.19 – Code demonstrating List properties](img/B19793_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.19 – Code demonstrating List properties
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 11 declares a `List` reference called `list`, referring
    to an `ArrayList` object. The `List` reference is typed for strings, meaning that
    we can only add `String` objects to the list. As the list is implemented by `ArrayList`,
    the properties outlined here apply to `ArrayList` implementations also.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 12-15 add the `J`, `A`, `V`, and `A` strings in sequence. When we output
    the list (line 17), we can see that the insertion order is maintained and that
    duplicate elements are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate precise control over where elements are inserted, lines 18-19
    add `"O"` to two different locations, namely indices 1 and 3\. When we output
    the list again (line 21), we can see that the strings have been inserted into
    their correct locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example showing other `List`/`ArrayList` API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '![   Figure 12.20 – Code demonstrating “List” and ”ArrayList”](img/B19793_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.20 – Code demonstrating “List” and ”ArrayList”
  prefs: []
  type: TYPE_NORMAL
- en: 'In this figure, we have several API calls and their respective output is in
    commented form on the right-hand side of each line. In this figure, our list contains
    `"Joe"`, `"Mary"`, and `"Joe"` in that order. We have the following sequence of
    API calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '`contains(Object o)` checks if `"Mary"` is in the list. This returns `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`get(int index)` returns the element at index 0, namely `"Joe"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`indexOf(Object o)` returns the index of the first occurrence of `2`. This
    will be boxed as an `Integer` type, which “is-a” `Object`. However, as there is
    no such object in the list, `-1` is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0` as this is the index of the first occurrence of `"Joe"` in the list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(Object o)` removes the first occurrence of the object from the list
    and returns true/false depending on whether the object was found or not. As `"Joe"`
    was present in the list, `true` is returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Mary"` and `"Joe"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remove(int index)` removes the object at index 0, which is `"Mary"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Joe"` (the second `"Joe"`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set(int index, E element)` changes the contents of the given index to the
    object passed. Therefore, `"Paul"` is now in index `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 36**: This shows that line 35 operated as expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have discussed some of the API methods, let’s discuss some others.
    *Table 12.4* presents this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Name** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `void add(int index,` `E element)` | Adds the element at the specified index
    |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `add(E e)` | Adds the element to the end of the list |'
  prefs: []
  type: TYPE_TB
- en: '| `void clear()` | Removes all the elements from the list |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `contains(Object o)` | Returns `true` if the object is in the list
    |'
  prefs: []
  type: TYPE_TB
- en: '| `E` `get(int index)` | Returns the element at the specified index |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean isEmpty()` | Returns `true` if the list is empty |'
  prefs: []
  type: TYPE_TB
- en: '| `int` `indexOf(Object o)` | Returns the index of the first occurrence of
    the specified element; its returns -1 if no such element exists in the list |'
  prefs: []
  type: TYPE_TB
- en: '| `E` `remove(int index)` | Removes the element at the specified index |'
  prefs: []
  type: TYPE_TB
- en: '| `boolean` `remove(Object o)` | Removes the first occurrence of the specified
    object |'
  prefs: []
  type: TYPE_TB
- en: '| `E set(int index,` `E element)` | Replaces the element at the specified index
    with the given element |'
  prefs: []
  type: TYPE_TB
- en: '| `int size()` | Returns the number of elements in the list |'
  prefs: []
  type: TYPE_TB
- en: Table 12.4 – Sample “List” and “ArrayList” API methods
  prefs: []
  type: TYPE_NORMAL
- en: That concludes this section on examining `List` and `ArrayList`. For further
    reading please see the JavaDocs at [https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html).
    Now, let’s move on to exploring the Date API.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Date API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `java.time` package was introduced in Java 8 and was designed to replace
    the previous `java.util.Date`, `java.util.Calendar`, and `java.text.DateFormat`
    classes. The classes in `java.time` represent dates, times, timezones, instants,
    periods, and durations. The ISO calendar system is followed, which is the de facto
    world calendar (following Gregorian rules). All the classes are immutable and
    thread-safe.
  prefs: []
  type: TYPE_NORMAL
- en: It is a large API ([https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html))
    with a large number of classes for dealing with dates, with relatively fewer classes
    dealing with times. Thankfully, despite the large number of methods available,
    the consistent use of method prefixes makes this manageable. We will look at these
    API prefixes shortly. But before we do that, let’s discuss the more important
    date and time classes.
  prefs: []
  type: TYPE_NORMAL
- en: Coordinated Universal Time (UTC)
  prefs: []
  type: TYPE_NORMAL
- en: UTC is the standard by which the world regulates clocks and time. It is effectively
    a successor to **Greenwich Mean Time** (**GMT**). UTC makes no adjustment for
    daylight savings time.
  prefs: []
  type: TYPE_NORMAL
- en: The time zone uses UTC+/-00:00, which is sometimes denoted by the letter Z –
    a reference to the equivalent nautical time zone (GMT). Since the NATO phonetic
    alphabet word for Z is “Zulu”, UTC is sometimes referred to as “Zulu time.”
  prefs: []
  type: TYPE_NORMAL
- en: Dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are five important classes here. Let’s examine each in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Instant`: An instant is a numeric timestamp. It is useful for logging and
    persistence. Historically, `System.currentTimeMillis()` would have been used.
    `System.currentTimeMillis()` returns the number of milliseconds since the “epoch
    day” (Jan 1st, 1970 at 00:00:00 UTC). The epoch is a fixed time from which all
    timestamps are calculated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDate`: Stores a date without a time. This is useful for representing
    birthdays such as 2000-10-21\. As it follows ISO-8601, the format is year-month-day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalTime`: Stores a time without a date. This is useful for representing
    opening/closing hours such as 09:00.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LocalDateTime`: Stores a date and time such as 2000-10-21T17:00\. Note the
    “T” used as a date and time separator. This is useful for representing the date
    and time of a scheduled event, such as a concert.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZonedDateTime`: Represents a “full” date-time with a time zone and resolved
    offset from UTC. For example, 2023-02-14T16:45+01:00[Europe/Zurich] is the date-time
    for the Europe/Zurich time zone and is 1 hour ahead of UTC.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Duration and Period
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to dates and times, the API also represents durations and periods
    of time. Let’s look at these now.
  prefs: []
  type: TYPE_NORMAL
- en: '`Duration`: An amount of time, represented in seconds (and nanoseconds); for
    example, “54 seconds.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Period`: Represents an amount of time in units more meaningful to humans,
    such as years or days. For example, “3 years, 6 months, and 12 days.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional interesting types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Other types are interesting also. Let’s examine some of these now.
  prefs: []
  type: TYPE_NORMAL
- en: '`Month`: Represents a month on its own; for example, JANUARY.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DayOfWeek`: Represents a day-of-week on its own; for example, FRIDAY.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`YearMonth`: Represents a year and month, without a day or time; for example,
    2025-12\. This could be useful for a credit card expiry date.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MonthDay`: Represents a month and day, without a year or time; for example,
    --08-09\. This could be useful for an annual event, such as an anniversary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ZoneOffset`: Represents a time zone offset from GMT/UTC, such as +2:00.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As stated earlier, there are a large number of methods across the classes. However,
    as the prefixes are consistently applied, this is manageable. *Table 12.5* represents
    these prefixes.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method Prefix** | **Description**Note: `ld2` and so forth used in these
    examples are related. |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `of` | A static factory method for creating instances – for example,`LocalDate
    ld1 = LocalDate.of(2023,` `3, 17);` |'
  prefs: []
  type: TYPE_TB
- en: '| `parse` | A static factory method for creating instances – for example,`LocalDate
    ld2 =` `LocalDate.parse("2023-03-17");` |'
  prefs: []
  type: TYPE_TB
- en: '| `get` | Gets the value of something – for example,`int dayOfMonth = ld2.getDayOfMonth();
    //` `17` |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | Checks if something is true – for example,`boolean isLeapYear = ld2.isLeapYear();
    //` `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `with` | The immutable equivalent of a setter method – for example,`LocalDate
    ld3 = ld2.withDayOfMonth(25); //` `2023-03-25` |'
  prefs: []
  type: TYPE_TB
- en: '| `plus` | Adds an amount to an object – for example,`LocalDate ld4 = ld3.plusDays(2);
    //` `2023-03-27` |'
  prefs: []
  type: TYPE_TB
- en: '| `minus` | Subtracts an amount from an object – for example,`LocalDate ld5
    = ld4.minusMonths(2); //` `2023-01-27` |'
  prefs: []
  type: TYPE_TB
- en: '| `at` | Combines this object with another – for example,`LocalDateTime ldt1
    = ld5.atTime(13, 45, 10); //` `2023-01-27T13:45:10` |'
  prefs: []
  type: TYPE_TB
- en: Table 12.5 – Date API method prefixes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have had a look at the prefixes in the API, let’s look at some
    sample code to reinforce them. *Figure 12**.21* shows some code for manipulating
    dates and times:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.21 – Code for manipulating dates and times](img/B19793_12_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.21 – Code for manipulating dates and times
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 13 creates `LocalDate` using the factory `now()` method.
    This creates a `LocalDate` object based on the system clock setting for the default
    locale. Also, using the `now()` method, lines 14-15 create `LocalTime` and `LocalDateTime`
    objects, respectively. Line 16 shows another way to create `LocalDateTime` objects
    by using the `of()` factory method to pass in both `LocalDate` and `LocalTime`
    objects. Line 17 shows the output of the `LocalDateTime` object to be `yyyy-mm-ddThh:mm:ss:nnnnnnnnn`.
    The date part comes first, then `"T"`, which separates the date from the time,
    where `n` in the time part represent nanoseconds.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we want to create `LocalDate` values representing St. Patrick’s Day (March
    17), 2025\. Line 20 uses the `of()` factory method and passes in numeric values
    for the year, month, and day. Note that the months start at 1 and not 0\. Thus,
    March is represented as 3.
  prefs: []
  type: TYPE_NORMAL
- en: Line 21 uses an alternative factory method, namely `parse(String)`, which accepts
    a `String` and creates a `LocalDate` accordingly. If the string cannot be parsed,
    an exception will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Line 22 outputs what day of the week, March 17, 2025, occurs (which is a Monday).
    Line 23 “modifies” the months, changing it from 3 to 5 (March to May). As the
    Date API types are immutable, the change is made to a new object in the background
    (`ld2` is untouched). The `ld3` reference refers to this new object (`2025-05-17`).
  prefs: []
  type: TYPE_NORMAL
- en: Line 25 adds a year, so we now have 2026-05-17\. Line 27 subtracts 5 days, so
    we now have 2026-05-12\. Lastly, on line 29, we “change” our `LocalDate` to `LocalDateTime`.
    As we already have a date, we just provided the time elements. The nanoseconds,
    which are not provided, are set to 0 and are not displayed as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at a `ZonedDateTime` example in *Figure 12**.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.22 – ZonedDateTime example](img/B19793_12_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.22 – ZonedDateTime example
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, a flight leaves Dublin for Paris at 1 PM local time. The flight
    duration is 1 hour 45 minutes. We are trying to calculate the local time in Paris
    when the flight lands. The solution presented here is one option.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 34-38 create a `LocalDateTime` object for the departure date and time
    (November 24th, 2023, at 1 P.M.). Line 39 zones the date-time object using the
    `atZone()` method by passing in the relevant time zone (a `ZoneId`). To get the
    time zone `ZoneId` object, simply call the factory `of()` method while passing
    in the relevant time zone string. In this example, it is `"Europe/Dublin"`. Line
    40 shows the format of the `ZonedDateTime` object. Note `"Z"` for Zulu time (UTC).
    At that time of year, as summertime has ended, Dublin is in line with UTC.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 42-45 represent the calculation of the local arrival time in Paris. Line
    43 calculates what time is it in Paris when the flight leaves Dublin using the
    `withZoneSameInstant()` method. Now, all we have to do is add on the flight time
    of 1 hour and 45 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Line 47 shows the `ZonedDateTime` for the arrival time. The time and zoned offset
    elements are interesting. The local time allows for the fact that Paris is 1 hour
    ahead of Dublin. This time difference is reflected in the offset of `+1:00`. Thus,
    Paris is 1 hour ahead of UTC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at some code that uses `Period` and `Duration`. *Figure 12**.23*
    presents an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.23 – An example using Period and Duration](img/B19793_12_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.23 – An example using Period and Duration
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, both `Period` and `Duration` are demonstrated. `Period` is suited
    for time blocks of greater than 1 day; for example, 2 years, 5 months, and 11
    days. `Duration` is more suited to blocks of time of less than 1 day; for example,
    8 hours and 20 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Lines 57-63 calculate and output the number of years, months, and days the American
    Civil War lasted. Firstly, we create `LocalDate` objects for the start and end
    dates (lines 57-58). Line 59 creates a `Period` object using the static `Period.between()`
    method, passing in the relevant start and end dates. Line 60 outputs the period
    object, `P3Y11M28D`, which represents a `Period` of 3 years, 11 months, and 28
    days (weeks are represented in days). Lines 61-63 output the years, months, and
    days values separately.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at `Duration`. In this case, we use two `LocalTime` objects;
    one representing 12:00:20 (line 66) and the other representing 14:45:40 (line
    67). Line 68 calculates the time difference between both and line 69 outputs the
    result. Note that there is no Y, M, or D (years, months, or days) as there was
    on line 60 (`Period`). Now, on line 69, we have a `Duration` of `PT2H45M20S` representing
    2 hours, 45 minutes, and 20 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let’s look at how to format dates and times.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting dates and times
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A formatter can work in both directions: formatting your temporal (time-related)
    object as a string or parsing a string into a temporal object. Both approaches
    work with formatters. This is represented by the following code from the API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will focus on how to create formatters for the `format()` method. However,
    as formatters are common to both formatting and parsing, what we say for one applies
    to the other.
  prefs: []
  type: TYPE_NORMAL
- en: We have a lot of flexibility in how we specify the format for our dates and
    times. Firstly, there are pre-defined standard formats available for us. In addition,
    we can specify custom formats. When specifying custom formats, the letters A-Z
    and a-z are reserved and have specific semantics. Importantly, the number of format
    letters is important – for example, MMM formats the month to Aug, whereas MM produces
    08.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common approaches to formatting your dates and times. One is to
    use `format(DateTimeFormatter)` in the `LocalDate`, `LocalTime`, `LocalDateTime`,
    and `ZonedDateTime` temporal classes. Its signature accepts a parameter of the
    `DateTimeFormatter` type. The other approach is to use `format(TemporalAccessor)`
    in the `DateTimeFormatter` class itself. `TemporalAccessor` is an interface that’s
    implemented by the temporal classes just mentioned.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at some example code, we must cover the more popular pre-defined
    formatters and format patterns. There are quite a few and we encourage you to
    look up the API for further details.
  prefs: []
  type: TYPE_NORMAL
- en: Pre-defined formatters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The easiest way to access these formatters is to use the constants in the `DateTimeFormatter`
    class or by calling the factory “of” methods in `DateTimeFormatter`. *Table 12.6*
    presents an overview of the more popular ones. Please see the API for further
    details. Note that **ISO** stands for **International Organization** **for Standardization**:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Formatter** | **Description** | **Example** |'
  prefs: []
  type: TYPE_TB
- en: '| `ofLocalizedDate (dateStyle)` | Formatter with the date style from the locale
    | This depends on the style that’s passed in. An example is “Monday 10 July 2023”.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ofLocalizedTime (timeStyle)` | Formatter with the time style from the locale
    | This depends on the style that’s passed in. An example is “15:47”. |'
  prefs: []
  type: TYPE_TB
- en: '| `ofLocalizedDateTime (dateTimeStyle)` | Formatter with the date and time
    styles from the locale | This depends on the style that’s passed in. An example
    is“3 July 2018 09:19”. |'
  prefs: []
  type: TYPE_TB
- en: '| `ISO_DATE` | ISO date (may contain offset) | “2023-07-10”, “2023-07-10+01:00”.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ISO_TIME` | ISO time (may contain offset) | “15:47:13”, “15:47:13+01:00”.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ISO_LOCAL_DATE` | ISO local date (no offset) | “2023-07-10”. |'
  prefs: []
  type: TYPE_TB
- en: '| `ISO_LOCAL_TIME` | ISO local time (no offset) | “16:00:03”. |'
  prefs: []
  type: TYPE_TB
- en: '| `ISO_ZONED_DATE_TIME` | Zoned date time | “2023-07-12T09:33:03+01:00 [Europe/Dublin]”.
    |'
  prefs: []
  type: TYPE_TB
- en: Table 12.6 – Date API pre-defined formatters
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine some code that uses pre-defined formatters.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 12**.24* presents code that uses these pre-defined formatters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.24 – Code example using pre-defined formatters](img/B19793_12_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.24 – Code example using pre-defined formatters
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, we represent the current date (line 74) and the current time
    (line 81) in various formats, based on the pre-defined formats available in `DateTimeFormatter`.
    First up is `ISO_DATE` (line 75). Its output (in comments on line 76) is `2023-07-10`,
    which is in yyyy-mm-dd format.
  prefs: []
  type: TYPE_NORMAL
- en: Line 78 uses the `ofLocalizedDate()` factory method to create a format. By passing
    in the `FormatStyle.FULL` enum constant, we are requesting as much detail as possible.
    As a result, this format outputs (line 79) `Monday 10 July 2023`. As can be seen,
    this is more detailed than the `ISO_DATE` format.
  prefs: []
  type: TYPE_NORMAL
- en: Line 82 creates an `ISO_TIME` formatter and applies it (line 83) to the time
    object that’s already been created (line 81). Line 85 uses the `ofLocalizedTime()`
    factory method. The `FormatStyle.SHORT` enum returns the fewest details, typically
    numeric.
  prefs: []
  type: TYPE_NORMAL
- en: That covers the pre-defined formatters. Now, let’s discuss how to specify custom
    formatters.
  prefs: []
  type: TYPE_NORMAL
- en: Custom formatters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Custom formatters are defined using pattern letters, where the number of letters
    used is significant. Let’s discuss the most commonly used pattern letters first
    and then present some code that utilizes them. *Table 12.7* presents a summary
    of the pattern letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Letter** | **Description** | **Examples** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| y | Year | 2023; 23 |'
  prefs: []
  type: TYPE_TB
- en: '| M | Month | 8; 08; Aug; August |'
  prefs: []
  type: TYPE_TB
- en: '| d | Day of the month | 16 |'
  prefs: []
  type: TYPE_TB
- en: '| E | Day of the week | Wed; Wednesday |'
  prefs: []
  type: TYPE_TB
- en: '| D | Day of the year | 145 |'
  prefs: []
  type: TYPE_TB
- en: '| h | Hour of the day; 12-hour clock (1-12) | 10 |'
  prefs: []
  type: TYPE_TB
- en: '| H | Hour of the day; 24-hour clock (0-23) | 19 |'
  prefs: []
  type: TYPE_TB
- en: '| m | Minute of the hour | 32 |'
  prefs: []
  type: TYPE_TB
- en: '| s | Second of the minute | 55 |'
  prefs: []
  type: TYPE_TB
- en: '| a | A.M. or P.M. | PM |'
  prefs: []
  type: TYPE_TB
- en: '| z | Timezone | GMT |'
  prefs: []
  type: TYPE_TB
- en: '| G | Era | AD |'
  prefs: []
  type: TYPE_TB
- en: Table 12.7 – Date API pattern letters overview
  prefs: []
  type: TYPE_NORMAL
- en: 'This table is best explained with the aid of an example. *Figure 12**.25* presents
    an example that uses the pattern letters from *Table 12.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.25 – Code example using pattern letters](img/B19793_12_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.25 – Code example using pattern letters
  prefs: []
  type: TYPE_NORMAL
- en: In this figure, line 91 gets the current date and time for this timezone, which
    is **Irish Standard** **Time** (**IST**).
  prefs: []
  type: TYPE_NORMAL
- en: Irish Standard Time (IST)
  prefs: []
  type: TYPE_NORMAL
- en: This is the timezone that’s used in Ireland. In Ireland, we utilize daylight
    savings time (“summertime”). This means that during the summer months, we advance
    the clocks forward 1 hour so that darkness falls at a later clock time. Therefore,
    in March, we put the clocks forward 1 hour, and in October, we put the clocks
    back 1 hour.
  prefs: []
  type: TYPE_NORMAL
- en: There is no “summertime” in UTC. Because of this and the fact that it is July
    right now, IST is +1:00 hours ahead of UTC.
  prefs: []
  type: TYPE_NORMAL
- en: The output for line 92 is in a comment to the right. The date and time are separated,
    as usual, by “T.” The zone offset is “+1:00,” indicating that this zoned time
    is 1 hour ahead of UTC. The zone ID is “[Europe/Dublin].”
  prefs: []
  type: TYPE_NORMAL
- en: We will first look at a date-related formatter. Line 93 creates a formatter
    using the `yy-MMM-dd E D` pattern. The output it generates is `23-Jul-11 Tue 192`
    (line 94). Thus, the current year of 2023 is output as `23` because we only provided
    `yy` in the format (as opposed to `yyyy`). Note that, had it been `yyyy` in the
    format, `2023` would have been output. This is why the number of pattern letters
    is important. The capital `M` is for the month. `M` produces `7`, `MM` produces
    `07`, `MMM` (as in the pattern) produces `Jul`, and `MMMM` produces `July`. Again,
    this demonstrates that the number of pattern letters is important.
  prefs: []
  type: TYPE_NORMAL
- en: The `dd` pattern outputs the day of the month. This gives us `11` for the `11th`.
    `E` gives us the day of the week, which is `Tue`. Note that `EEEE` returns `Tuesday`.
    `D` represents the day of the year; the 192nd in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the dashes and spaces are simply inserted into the output. This is
    because, unlike letters, they are not reserved. We will learn how to insert words
    (containing letters) into the output without causing exceptions shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s examine a time-related formatter. Line 96 creates a formatter using
    the `hh:mm:ss a z G` pattern, which generates the output (line 97) of `09:05:50
    a.m. IST AD`. The `hh:mm:ss` pattern returns the current time in hours (12-hour
    clock), minutes, and seconds format. `a` returns whether it is A.M. or P.M. Right
    now, it is the morning, so `am` is returned. The `z` pattern letter returns the
    abbreviated zone name, `IST`. Expanding this to `zzzz` returns `Irish Standard
    Time`. Lastly, `G` returns the era, `AD` (Anno Domini).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s learn how to insert text into our formatter. As we know, the letters
    a-z and A-Z are reserved. So, how do we insert letters as regular letters and
    not pattern letters? To do this, we must surround the regular letters with single
    quotes. Line 101 specifies a pattern that uses both regular letters and pattern
    letters. The pattern is “’Year: ‘*yyyy*’. Month: ‘*MMMM*’. Day: ‘*dd*’.’”. The
    pattern letters are in italics. Any other characters are enclosed in single quotes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Year: 2023\. Month: July. Day: 11.` is generated as output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, the year value, `2023`, is preceded by the text `"Year: "`.
    This was achieved by surrounding the text with single quotes: `''Year: ''`. Following
    the year pattern `yyyy`, the regular text `''. Month: ''` is inserted. Thus, the
    capital `M` is treated as simply a capital M, instead of a month pattern letter.
    After that, `''. Day: ''` is inserted to precede the day of the month, which is
    `11`. Lastly, a period is inserted at the end by enclosing it in single quotes
    also. Note that the period without single quotes is also fine as it is not a reserved
    character.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, let’s look at an example of parsing where we can create temporal objects
    from `String` values. Line 105 declares a string of `"2023-07-10 22:10"`. Line
    106 then declares a pattern that will be able to parse this string. The pattern
    is `"yyyy-MM-dd HH:mm"`. Note that `"HH"` represents the 24-hour clock. This will
    enable us to parse the time of `"22"` in the string.
  prefs: []
  type: TYPE_NORMAL
- en: Line 107 creates a `LocalDateTime` object by parsing the string according to
    the pattern provided. Line 108 outputs the `LocalDateTime` object, producing `"2023-07-10T22:10"`,
    which is what the string represents.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on custom formatters and concludes [*Chapter 12*](B19793_12.xhtml#_idTextAnchor293).
    Now, let’s put that knowledge into practice to reinforce the concepts we’ve covered.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve learned so many fun new things in this chapter. It’s time to enlighten
    the users of the Mesozoic Eden software with some new features that have been
    built with our new skills:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage the birthdays of the dinosaurs in our park. Add the `birthday` property
    to the `Dinosaur` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The park operates on a strict schedule. Create a simple system to log events
    such as feeding times, cleaning, and emergency drills in the park using the Date
    API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Mesozoic Eden, we have a very strong safety-first policy. Regular inspections
    help us maintain our high standards of safety. Create a program that calculates
    how many days are left until the park’s next safety inspection, based on the date
    of the last safety inspection. Safety inspections need to happen every 45 days.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a newborn Theropod. The guests were asked to submit names for our youngest
    inhabitant of Mesozoic Eden. 10 names were picked. Create a list for these 10
    names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We want to create a string with the newborn’s full name. Use `StringBuilder`
    to append every name to its new name, and then convert it into a string when you’re
    done. (Hint: Use a loop combined with `StringBuilder`.)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Project – dinosaur care system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll continue to work on our “dinosaur care system” by adding functionality
    to log daily care activities for dinosaurs using the Java Core API. This includes
    features to accept user input, maintain a history of activities, and store dinosaur
    health data over time. Don’t worry – we’ll break this down for you step by step.
  prefs: []
  type: TYPE_NORMAL
- en: '**Step 1: Add additional** **Java classes**:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new package named `coreapi`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside this package, create a class named `Dinosaur`. This class should have
    properties such as name, species, health status, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, create a class named `Activity` with properties such as name, date, dinosaur,
    and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Step 2: Extend the dinosaur** **care system**:'
  prefs: []
  type: TYPE_NORMAL
- en: In your `DinosaurCareSystem` class, create a `List` to hold `Dinosaur` objects,
    and another `List` to hold `Activity` objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a method called `addDinosaur()` that takes user input to create a new
    `Dinosaur` object and add it to the list of dinosaurs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a method called `logActivity()` that also takes user input to create
    a new `Activity` object (including selecting a dinosaur from the list) and add
    it to the list of activities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is some sample code to get you started with this step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**Step 3: Interact with** **the system**:'
  prefs: []
  type: TYPE_NORMAL
- en: In your main class, create a `DinosaurCareSystem` object and use a loop to continuously
    ask the user what they want to do (add a dinosaur, log activity, and so on). Use
    a `Scanner` object to get input from the user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s some code to get you started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As always, feel free to expand on this and let your creativity run free!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at popular classes from the Java Core API. We started
    with `Scanner`, a useful class for reading input. `Scanner` can be directed to
    read from a file, a `String` object, or the keyboard. Reading from the keyboard
    is particularly useful for dealing with user input.
  prefs: []
  type: TYPE_NORMAL
- en: We examined the `String` class and its API. We saw how `String` literals use
    the string constant pool to save on memory. We examined an important property
    of `String` objects, namely immutability. A `String` object, once created, cannot
    be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we examined `StringBuilder` and its API. We discussed that `StringBuilder`
    is a mutable type and thus, there is only ever one object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: Given that `String` is immutable but `StringBuilder` is mutable, we presented
    a detailed example with both code and supporting diagrams to compare and contrast
    `String` and `StringBuilder`.
  prefs: []
  type: TYPE_NORMAL
- en: This led to a discussion on how to create our own custom immutable types. We
    examined a checklist of steps you must perform to ensure that your class is immutable.
    We then showed an example where, very subtly, Java’s call by value principle broke
    encapsulation (and hence immutability). We discussed how to fix such an issue
    using defensive copying. Effectively, for our `private` instance mutable types,
    we had to ensure that the references passed in to initialize them were not stored
    directly; we must copy them first. In addition, we had to ensure that we did not
    return the references to our `private` instance mutable types either; we must
    copy them first also.
  prefs: []
  type: TYPE_NORMAL
- en: From there we examined the `List` and `ArrayList` APIs. `List` is an interface
    and `ArrayList` is an implementation of `List`. `ArrayList` is essentially an
    expandable array. It maintains the order of insertion and allows duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined the Date API, which was overhauled in Java 8\. We discussed
    `Instant`, `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`, `Period`,
    and `Duration`. All of these types are immutable, meaning we can use factory methods
    (such as `now()` and `of()`) to create instances. In a large API, the consistency
    of method prefix names is helpful.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed how we can format a temporal object for output and also
    how we can parse a string into a temporal object. We examined the pre-defined
    formatters available and in addition, we designed custom formatters using reserved
    pattern letters.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our discussion on the Java Core API. We will move on to generics
    and collections in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Advanced Topics'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, we will take a look at some of the more advanced topics in Java.
    We will start with the Java Collection framework. This will include several of
    its popular interfaces and their common implementations. We will discuss sorting
    in Java and how to work with generics. We then move on to lambda expressions and
    their relationship to functional interfaces. We will look at popular functional
    interfaces from the API and also method references. We will then discuss streams
    over two chapters, both the fundamentals and advanced topics. The fundamentals
    will cover topics such as the stream pipeline, stream laziness, and terminal operations.
    The advanced chapter will discuss intermediate operations, primitive streams,
    `Optional`s, and parallel streams. Lastly, we will discuss concurrency, where
    we will explain multi-threading, data races, `ExecutorService,` and concurrent
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19793_13.xhtml#_idTextAnchor317), *Generics and Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19793_14.xhtml#_idTextAnchor355), *Lambda Expressions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19793_15.xhtml#_idTextAnchor377), *Streams: Fundamentals*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B19793_16.xhtml#_idTextAnchor401), *Streams: Advanced Concepts*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 17*](B19793_17.xhtml#_idTextAnchor430), *Concurrency*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
