- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Java Core API
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Java 核心API
- en: In this chapter, we will delve more deeply into popular classes and interfaces
    from the Java API. We will start with the `Scanner` class, which is commonly used
    for scanning and parsing text from sources such as the keyboard (the user). We
    will then examine the very popular `String` and `StringBuilder` classes. We will
    discuss their differences, which will require contrasting mutable and immutable
    types. We will also show you how to design immutable types and look at the `List`
    interface and its popular implementation class, `ArrayList`. Lastly, we will examine
    the Date API, which was overhauled in Java 8.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将更深入地探讨 Java API 中流行的类和接口。我们将从常用的 `Scanner` 类开始，该类常用于从键盘（用户）等来源扫描和解析文本。然后，我们将检查非常流行的
    `String` 和 `StringBuilder` 类。我们将讨论它们之间的区别，这需要对比可变和不可变类型。我们还将向您展示如何设计不可变类型，并查看
    `List` 接口及其流行的实现类 `ArrayList`。最后，我们将检查在 Java 8 中进行重写的 `Date` API。
- en: 'For further details on the types covered in this chapter, please refer to the
    Java Docs API: [https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html).'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本章涵盖的类型更详细的信息，请参阅 Java Docs API：[https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html)。
- en: 'This chapter covers the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要主题：
- en: Understanding the `Scanner` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `Scanner` 类
- en: Comparing `String` with `StringBuilder`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比较 `String` 与 `StringBuilder`
- en: Designing an immutable type
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计不可变类型
- en: Examining `List` and `ArrayList`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 `List` 和 `ArrayList`
- en: Exploring the Date API
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 `Date` API
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上找到：[https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12](https://github.com/PacktPublishing/Learn-Java-with-Projects/tree/main/ch12)。
- en: Understanding the Scanner class
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 `Scanner` 类
- en: '`Scanner` (from the `java.util` package) is a text scanner that can parse primitives
    and strings using regular expressions. A regular expression is a pattern that
    enables string manipulation. As it states so eloquently in the Java API: “*A Scanner
    breaks its input into tokens using a delimiter pattern, which by default matches
    whitespace. The resulting tokens may then be converted into values of different
    types using the various* *next methods.*”'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`（来自 `java.util` 包）是一个文本扫描器，可以使用正则表达式解析基本类型和字符串。正则表达式是一个允许字符串操作的模式。正如
    Java API 中所明确指出的：“*Scanner 使用分隔符模式将其输入拆分为标记，默认情况下匹配空白。然后可以使用各种 *next 方法* 将这些标记转换为不同类型的值。*”'
- en: These `nextXXX()` methods convert the tokens on the input stream into primitives.
    For example, if the user has typed in `23`, then `nextInt()` would return an `int`
    value of `23`; if the user typed in `45.89`, then `nextDouble()` would return
    a `double` value of `45.89`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `nextXXX()` 方法将输入流中的标记转换为基本类型。例如，如果用户输入了 `23`，则 `nextInt()` 会返回 `23` 的 `int`
    值；如果用户输入了 `45.89`，则 `nextDouble()` 会返回 `45.89` 的 `double` 值。
- en: However, if the token on the input stream is not an integer and `nextInt()`
    is called, an `InputMismatchException` error is thrown. This could occur if the
    user types in `"abc"` and `nextInt()` is called. To protect against this, each
    of the `nextXXX()` methods has a corresponding guardian angel method, namely `hasNextXXX()`.
    For example, `nextInt()` has a corresponding `hasNextInt()` method, `nextDouble()`
    has a corresponding `hasNextDouble()` method, and so forth. The `hasNextXXX()`
    methods all take a sneak peek at the input stream for the next token (without
    consuming it) and check if that token can be successfully converted into the type
    in question. They return `true` or `false` accordingly. If `true` is returned,
    then the corresponding `nextXXX()` method can safely be used without causing an
    exception.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果输入流中的标记不是整数并且调用了 `nextInt()`，则会抛出 `InputMismatchException` 错误。这可能会发生在用户输入
    `"abc"` 并调用 `nextInt()` 的情况下。为了防止这种情况，每个 `nextXXX()` 方法都有一个相应的守护天使方法，即 `hasNextXXX()`。例如，`nextInt()`
    有一个相应的 `hasNextInt()` 方法，`nextDouble()` 有一个相应的 `hasNextDouble()` 方法，依此类推。`hasNextXXX()`
    方法都会预先查看输入流中的下一个标记（不消耗它）并检查该标记是否可以成功转换为所需类型。它们相应地返回 `true` 或 `false`。如果返回 `true`，则可以安全地使用相应的
    `nextXXX()` 方法而不会引发异常。
- en: '*Table 12.1* shows some of the more important `Scanner` methods. Note that
    we have just listed one of the `hasNextXXX()` methods, namely `hasNextDouble()`,
    along with its corresponding `nextXXX()` method, namely `nextDouble()`. All of
    the following types follow the same pattern: `boolean`, `byte`, `float`, `int`,
    `long`, and `short`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 12.1* 展示了一些更重要的 `Scanner` 方法。请注意，我们只列出了一种 `hasNextXXX()` 方法，即 `hasNextDouble()`，以及其对应的
    `nextXXX()` 方法，即 `nextDouble()`。所有以下类型都遵循相同的模式：`boolean`、`byte`、`float`、`int`、`long`
    和 `short`：'
- en: '| **Method Name** | **Description** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Scanner(InputStream source)` | Creates a `Scanner` class that produces values
    from the specified input stream – for example, the keyboard |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner(InputStream source)` | 创建一个 `Scanner` 类，它从指定的输入流中生成值 - 例如，键盘 |'
- en: '| `Scanner(File source)` | Creates a `Scanner` class that produces values from
    the specified file |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner(File source)` | 创建一个 `Scanner` 类，它从指定的文件中生成值 |'
- en: '| `Scanner(String source)` | Creates a `Scanner` class that produces values
    from the specified string |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner(String source)` | 创建一个 `Scanner` 类，它从指定的字符串中生成值 |'
- en: '| `String next()` | Returns the next token |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `String next()` | 返回下一个标记 |'
- en: '| `boolean hasNextDouble()` | Returns `true` if and only if the next token
    is a valid `double` value |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `boolean hasNextDouble()` | 返回 `true` 当且仅当下一个标记是一个有效的 `double` 值 |'
- en: '| `double nextDouble()` | Scans the next token as a `double` value |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `double nextDouble()` | 将下一个标记扫描为 `double` 值 |'
- en: '| `String nextLine()` | Returns (the rest of) the line |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `String nextLine()` | 返回（行的剩余部分） |'
- en: '| `Scanner` `useDelimiter(String pattern)` | Sets the Scanner’s delimiting
    pattern according to the argument passed |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `Scanner` `useDelimiter(String pattern)` | 根据传递的参数设置 Scanner 的分隔模式 |'
- en: Table 12.1 – Sample “Scanner” API methods
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.1 – “Scanner” API 方法示例
- en: Now, let’s look at some examples in code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些代码示例。
- en: Using Scanner to read from the keyboard
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Scanner 从键盘读取
- en: 'The standard input stream can be accessed with `System.in`. Typically, this
    is the keyboard. When creating our `Scanner`, we must pass the input source (`System.in`,
    in this case) as an argument of the `Scanner` constructor. *Figure 12**.1* shows
    an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 标准输入流可以通过 `System.in` 访问。通常，这是键盘。在创建我们的 `Scanner` 时，我们必须将输入源（在这种情况下为 `System.in`）作为
    `Scanner` 构造函数的参数传递。*图 12.1* 展示了一个示例：
- en: '![Figure 12.1 – “Scanner” taking input from the keyboard](img/B19793_12_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – “Scanner” 从键盘获取输入](img/B19793_12_01.jpg)'
- en: Figure 12.1 – “Scanner” taking input from the keyboard
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – “Scanner” 从键盘获取输入
- en: In this figure, on line 23, we create a `Scanner` object referring to the keyboard
    by passing `System.in` to the `Scanner` constructor. Line 24 simply prompts the
    user to type in an age. Line 25 is the guardian angel method to protect against
    exceptions. If the next token on the input is of the `int` type, then the condition
    on line 25 will be `true` and we can safely execute `nextInt()` on line 26\. Line
    27 echoes the integer that was typed on the keyboard.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第 23 行我们创建了一个 `Scanner` 对象，通过将 `System.in` 传递给 `Scanner` 构造函数来引用键盘。第 24
    行简单地提示用户输入年龄。第 25 行是守护天使方法，用于防止异常。如果输入的下一个标记是 `int` 类型，那么第 25 行的条件将为 `true`，我们就可以安全地在第
    26 行执行 `nextInt()`。第 27 行回显在键盘上输入的整数。
- en: Closing a Scanner resource
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭 Scanner 资源
- en: Closing resources once you are finished with them is prudent as it prevents
    resource leaks. However, a `Scanner` object wrapped around `System.in` is a little
    different. In effect, if we close a `Scanner` object that was wrapped around `System.in`,
    we won’t be able to read from standard input again.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭已经完成使用的资源是明智的，因为它可以防止资源泄漏。然而，围绕 `System.in` 包装的 `Scanner` 对象略有不同。实际上，如果我们关闭了一个围绕
    `System.in` 包装的 `Scanner` 对象，我们将无法再次从标准输入读取。
- en: This is what lines 30-34 in *Figure 12**.1* are demonstrating. If we close the
    `Scanner` object (line 30), even though lines 31-34 are essentially the same as
    lines 23-27 (bar `hasNextInt()`), an exception is thrown on line 33\. This is
    because we are attempting to access a closed resource.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是 *图 12.1* 中的第 30-34 行所展示的。如果我们关闭 `Scanner` 对象（第 30 行），即使第 31-34 行在本质上与第 23-27
    行相同（除了 `hasNextInt()`），第 33 行将抛出异常。这是因为我们正在尝试访问一个已关闭的资源。
- en: 'Now, let’s look at an example that will further explain tokens and delimiters:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个将进一步解释标记和分隔符的示例：
- en: '![Figure 12.2 – next() delimited by whitespace](img/B19793_12_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 由空白分隔的 next()](img/B19793_12_02.jpg)'
- en: Figure 12.2 – next() delimited by whitespace
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 由空白分隔的 next()
- en: 'In this figure, we are using `next()` to try and parse `Sean Kennedy` from
    the input stream (keyboard). However, the (default) delimiter is whitespace, and
    thus, `Sean` is returned. Note that `Kennedy` is still there in the input stream.
    We could invoke `next()` a second time to consume the extra `Kennedy` token. However,
    there is a method that solves this issue: `nextLine()`. *Figure 12**.3* shows
    `nextLine()` in action:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们使用`next()`尝试从输入流（键盘）中解析`Sean Kennedy`。然而，（默认）分隔符是空白字符，因此返回的是`Sean`。请注意，`Kennedy`仍然在输入流中。我们可以再次调用`next()`来消费额外的`Kennedy`标记。但是，有一个方法可以解决这个问题：`nextLine()`。*图12.3*展示了`nextLine()`的作用：
- en: '![Figure 12.3 – nextLine() delimited by the end of the line](img/B19793_12_03.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 由行尾分隔的nextLine()](img/B19793_12_03.jpg)'
- en: Figure 12.3 – nextLine() delimited by the end of the line
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 由行尾分隔的nextLine()
- en: In this figure, we are using `nextLine()`, which uses a different delimiter.
    Rather than whitespace delimiting the tokens (as with `next()`), the newline character
    delimits `nextLine()`). In effect, `nextLine()` reads a line of text, whereas
    `next()` reads words. Line 17 demonstrates this by outputting `Sean Kennedy`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们使用`nextLine()`，它使用不同的分隔符。与`next()`不同，它不是用空白字符分隔标记（如`next()`），而是用换行符分隔`nextLine()`。实际上，`nextLine()`读取一行文本，而`next()`读取单词。第17行通过输出`Sean
    Kennedy`来演示这一点。
- en: '`Scanner` can be redirected to other sources for input. One such source is
    a file.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`可以重定向到其他输入源。其中一个源是文件。'
- en: Using Scanner to read from a file
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scanner从文件中读取
- en: 'Let’s examine how we can direct `Scanner` to read from a file, as opposed to
    the keyboard. *Figure 12**.4* shows such an example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将`Scanner`重定向到从文件中读取，而不是从键盘读取。*图12.4*展示了这样一个例子：
- en: '![Figure 12.4 – “Scanner” taking input from a file](img/B19793_12_04.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – “Scanner”从文件中读取输入](img/B19793_12_04.jpg)'
- en: Figure 12.4 – “Scanner” taking input from a file
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – “Scanner”从文件中读取输入
- en: In the preceding figure, the file in question (`ages.txt`) is a simple text
    file containing the number `12`, followed by a carriage return. We pass the `File`
    object into the `Scanner` constructor (lines 34-36). The `String` object that’s
    passed into the `File` constructor (lines 35-36) is a relative path. In other
    words, it is appended to the current working directory (as opposed to an absolute
    path, which contains the full path from the root). `\\` within `String` is where
    we are escaping the backslash (`\`). Java converts `\\` into a single backslash
    internally. Therefore, `"out\\production"` becomes `"out\production"`. The `hasNextInt()`
    and `nextInt()` methods (lines 37 and 38) work as before.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，所涉及的文件（`ages.txt`）是一个简单的文本文件，包含数字`12`，后面跟着一个回车符。我们将`File`对象传递给`Scanner`构造函数（第34-36行）。传递给`File`构造函数的`String`对象（第35-36行）是一个相对路径。换句话说，它附加到当前工作目录（与包含从根目录的完整路径的绝对路径相对）。`String`中的`\\`是我们对反斜杠（`\`）进行转义的地方。Java将`\\`内部转换为单个反斜杠。因此，`"out\\production"`变为`"out\production"`。`hasNextInt()`和`nextInt()`方法（第37和38行）与之前的工作方式相同。
- en: As we are using try-with-resources, we do not need to remember to explicitly
    close the `Scanner` or `File` resources (they are closed implicitly for us).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用了try-with-resources，我们不需要记住显式关闭`Scanner`或`File`资源（它们会为我们隐式关闭）。
- en: Another possible source for `Scanner` input is a `String` object. Let’s look
    at that now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`Scanner`输入的另一个可能来源是`String`对象。现在让我们看看这一点。'
- en: Using Scanner to read from a string
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Scanner从字符串中读取
- en: 'Using `String` as an input `Scanner` source is also possible. *Figure 12**.5*
    shows such an example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`String`作为输入`Scanner`源也是可能的。*图12.5*展示了这样一个例子：
- en: '![Figure 12.5 – “Scanner” taking input from a string](img/B19793_12_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – “Scanner”从字符串中读取输入](img/B19793_12_05.jpg)'
- en: Figure 12.5 – “Scanner” taking input from a string
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – “Scanner”从字符串中读取输入
- en: In this figure, we declare a `String` object (line 14) and pass it to the `Scanner`
    constructor (line 15). We then chain the `useDelimiter(String)` method onto the
    `Scanner` object that is returned. This method accepts `String` as an argument
    and represents the regular expression pattern required to parse the input. The
    double backslash is, as before, simply escaping the backslash. In other words,
    `\\` becomes `\`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们声明了一个`String`对象（第14行）并将其传递给`Scanner`构造函数（第15行）。然后我们将`useDelimiter(String)`方法链接到返回的`Scanner`对象。此方法接受`String`作为参数，并代表解析输入所需的正则表达式模式。双反斜杠，正如之前一样，只是简单地转义反斜杠。换句话说，`\\`变为`\`。
- en: The `\s*` regular expression translates into *0 or more whitespace characters*.
    `*` represents *0 or more* and `\s` represents *a single whitespace character*.
    The `delim` string is hardcoded. This means that the input tokens are delimited
    by 0 or more spaces, followed by the `delim` token, followed by 0 or more spaces.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式 `\s*` 转换为 *0 个或多个空白字符*。`*` 代表 *0 个或多个*，`\s` 代表 *单个空白字符*。`delim` 字符串是硬编码的。这意味着输入标记由
    0 个或多个空格、`delim` 标记以及 0 个或多个空格分隔。
- en: When we apply this delimiter pattern to the given input string (line 14), the
    first token returned by `next()` is `Maaike`. This is output by line 16\. As `Maaike`
    has now been consumed from the input stream, the `next()` method call (line 17)
    returns the `van` token, which is then output. Similarly, the `next()` method
    on line 18 returns `Putten` to be output. Lastly, line 19 uses `nextInt()` to
    return 22 as an `int` type, which is then output to the screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此分隔符模式应用于给定的输入字符串（第14行）时，`next()` 返回的第一个标记是 `Maaike`。这是在第16行输出的。由于 `Maaike`
    已经从输入流中消耗掉，第17行的 `next()` 方法调用返回 `van` 标记，然后输出。同样，第18行的 `next()` 方法返回 `Putten`
    以供输出。最后，第19行使用 `nextInt()` 返回 22 作为 `int` 类型，然后输出到屏幕。
- en: Now that we know how to obtain input from the user, let’s cover two of the most
    important classes dealing with strings, namely `String` and `StringBuilder`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何从用户那里获取输入，让我们来介绍两个处理字符串的最重要类，即 `String` 和 `StringBuilder`。
- en: Comparing String with StringBuilder
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比较String与StringBuilder
- en: When dealing with strings, these two classes are your go-to classes. Their primary
    difference is that `String` objects are immutable, whereas `StringBuilder` objects
    are mutable. This means that for strings, once you create a `String` object, you
    cannot ever change that object. Java might make it look like you changed the object
    but you haven’t; a new object, reflecting your changes, has been created. `StringBuilder`
    objects, on the other hand, are mutable. This means that you are working with
    one object all the time. We will delve into this with an example later.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理字符串时，这两个类是你的首选类。它们的主要区别在于 `String` 对象是不可变的，而 `StringBuilder` 对象是可变的。这意味着对于字符串，一旦创建了
    `String` 对象，就不能再更改该对象。Java 可能会让你看起来改变了对象，但你并没有；一个新的对象，反映了你的更改，已经被创建。另一方面，`StringBuilder`
    对象是可变的。这意味着你始终在处理一个对象。我们将在稍后的示例中深入探讨这一点。
- en: Why immutability?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么是不可变的？
- en: Immutability is attractive from a security perspective as immutable objects
    cannot be changed. In addition, immutable objects are thread-safe in a multi-threaded
    environment. In multi-threaded environments, changes to (non-immutable) objects
    have to be synchronized one at a time so that changes do not interfere with one
    another Immutable objects are, by definition, protected from that. See [*Chapter
    17*](B19793_17.xhtml#_idTextAnchor430) (Concurrency) for a discussion on multi-threading.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来说，不可变性很有吸引力，因为不可变对象不能被更改。此外，在多线程环境中，不可变对象是线程安全的。在多线程环境中，对（非不可变）对象的更改必须逐个同步，以防止更改相互干扰。不可变对象按照定义是受到保护的。参见[*第17章*](B19793_17.xhtml#_idTextAnchor430)（并发）中关于多线程的讨论。
- en: For the moment, let’s start with the `String` class.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，让我们从 `String` 类开始。
- en: String class
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类
- en: The `String` class is in the `java.lang` package and represents a sequence of
    characters. As the class is in `java.lang`, it is automatically imported for you.
    The `String` class implements the `Comparable` interface, meaning that a natural
    ordering is defined when sorting strings. This ordering is alphabetic.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`String` 类位于 `java.lang` 包中，表示字符序列。由于该类位于 `java.lang` 中，它将自动为你导入。`String` 类实现了
    `Comparable` 接口，这意味着在排序字符串时定义了自然排序。这种排序是字母顺序。'
- en: As stated, `String` is an immutable type. Objects of the `String` type, once
    created, cannot be modified. `String` is also a `final` class, which means that
    you cannot subclass it. This is deliberate – the Java designers expect strings
    to behave in a certain way. If we were allowed to subclass `String` and override
    its behavior, unexpected results would occur. So, making the class `final` prevents
    this by ensuring predictable string behavior.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如所述，`String` 是一个不可变类型。一旦创建了 `String` 类型的对象，就不能对其进行修改。`String` 也是一个 `final`
    类，这意味着你不能对其进行子类化。这是故意的——Java 设计者期望字符串以某种方式行为。如果我们被允许子类化 `String` 并覆盖其行为，可能会出现意外结果。因此，通过确保字符串行为的可预测性，将类设置为
    `final` 防止了这种情况。
- en: All `String` literals are instances of the `String` class. `String` literals
    are stored in a special area of the heap called the string pool (or string constant
    pool). This is known as *interning* the string. If another string literal with
    the same character sequence is encountered, the string in the string pool is reused.
    This saves on memory. However, if you use the `new` keyword to create your `String`
    object, a new object with the character sequence is created on the heap, even
    if such an object is available in the string pool. In other words, the string
    pool is ignored if `new` is used.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`String`字面量都是`String`类的实例。`String`字面量存储在堆的一个特殊区域，称为字符串池（或字符串常量池）。这被称为字符串的内部化。如果遇到具有相同字符序列的另一个字符串字面量，将重用字符串池中的字符串。这可以节省内存。然而，如果您使用`new`关键字来创建您的`String`对象，即使该对象在字符串池中可用，也会在堆的另一个部分创建一个新的具有字符序列的对象。换句话说，如果使用`new`，则忽略字符串池。
- en: Let’s look at an example in code, as well as a supporting in-memory diagram.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例以及一个内存图来查看一个示例。
- en: String example (code)
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字符串示例（代码）
- en: '*Figure 12**.6* represents the code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.6* 表示以下代码：'
- en: '![Figure 12.6 – “String” example in code](img/B19793_12_06.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – “字符串”示例在代码中](img/B19793_12_06.jpg)'
- en: Figure 12.6 – “String” example in code
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 代码中的“字符串”示例
- en: In this figure, on line 5, we use the `s1` string reference to refer to the
    `"abc"` string literal. When the JVM encounters a string literal, it first checks
    if the same string literal exists in the string pool. If it does, it reuses the
    one from the pool. As line 5 is the first time `"abc"` is encountered, the `String`
    object with `"abc"` is inserted into the pool. Note that the string pool is simply
    a special area in the heap.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第5行，我们使用`s1`字符串引用来引用`"abc"`字符串字面量。当JVM遇到字符串字面量时，它首先检查是否在字符串池中存在相同的字符串字面量。如果存在，它将重用池中的那个。由于第5行是第一次遇到`"abc"`，因此带有`"abc"`的`String`对象被插入到池中。请注意，字符串池只是堆中的一个特殊区域。
- en: Line 6 is where the string pool object is reused. Now, we have both `s1` and
    `s2` referring to the same `String` object (in the pool). This is why line 7 outputs
    `true`. Recall that when the `==` operator is used with references, we are comparing
    the references. In other words, are both `s1` and `s2` referring to the same object
    in memory? Yes, they are.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行是字符串池对象被重用的地方。现在，`s1`和`s2`都引用了同一个`String`对象（在池中）。这就是为什么第7行输出`true`的原因。回想一下，当使用`==`运算符与引用一起使用时，我们是在比较引用。换句话说，`s1`和`s2`是否都指向内存中的同一个对象？是的，它们是。
- en: Line 8 uses the `new` keyword to create a `String` object. Once `new` is used,
    regardless of the same literal `"abc"` being used, a completely new object is
    created in a separate part of the heap. As line 8 creates a new object, when we
    compare `s1` and `s3` on line 9, the result is `false`. This is because `s1` and
    `s3` refer to two different objects.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 第8行使用`new`关键字创建一个`String`对象。一旦使用`new`，无论是否使用相同的字面量`"abc"`，都会在堆的另一个部分创建一个全新的对象。由于第8行创建了一个新对象，当我们第9行比较`s1`和`s3`时，结果是`false`。这是因为`s1`和`s3`引用了两个不同的对象。
- en: The `String` object’s method, `equals()`, operates differently from the equivalence
    operator, `==`. Rather than compare the references, `equals()` compares the contents
    of the objects. As line 10 returns `true`, it shows that the contents of the objects
    referred to by `s1` and `s2` are the same. This should not be a surprise as both
    `s1` and `s2` refer to the same object.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象的`equals()`方法与等价运算符`==`操作不同。`equals()`不是比较引用，而是比较对象的内容。由于第10行返回`true`，这表明`s1`和`s2`引用的对象内容是相同的。这不应该令人惊讶，因为`s1`和`s2`都引用了同一个对象。'
- en: Line 11, however, also returns `true`. Even though `s1` and `s3` refer to different
    objects, this demonstrates that `equals()` compares the object’s contents and
    not the references.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，第11行也返回`true`。尽管`s1`和`s3`引用了不同的对象，但这表明`equals()`比较的是对象的内容，而不是引用。
- en: Line 12 is interesting. We can intern a string by using its `intern()` method.
    What we are saying on line 12 is “Intern in the string pool what `s3` is referring
    to, and make the `s3` reference refer to the string pool object.” Line 13 returns
    `true`, demonstrating that both `s1` and `s3` now refer to the same string object.
    Note that line 13 is the same code as line 9, which returned `false` previously.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第12行很有趣。我们可以通过使用其`intern()`方法来内部化一个字符串。第12行所说的就是“将`s3`引用指向的内容在字符串池中内部化，并使`s3`引用指向字符串池对象。”第13行返回`true`，表明`s1`和`s3`现在都引用了同一个字符串对象。注意，第13行与之前返回`false`的第9行是相同的代码。
- en: A diagram will certainly help here, so let’s examine what is happening in memory.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的图表肯定会很有帮助，所以让我们检查内存中发生了什么。
- en: String example (diagram)
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: String示例（图表）
- en: '*Figure 12**.7* represents the in-memory representation of the code in *Figure
    12**.6*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.7* 表示了 *图12**.6* 中的代码的内存表示：'
- en: '![Figure 12.7 – “String” example in memory](img/B19793_12_07.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – “String”在内存中的示例](img/B19793_12_07.jpg)'
- en: Figure 12.7 – “String” example in memory
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – “String”在内存中的示例
- en: 'As can be seen from the preceding figure, both `s1` and `s2` refer to the `"abc"`
    object in the string pool. The dashed line from `s3` represents the object that
    was created by using the `new` keyword (line 8). Thus, we have two separate string
    objects: one on the heap and one in the pool (which is also part of the heap).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`s1`和`s2`都指向字符串池中的`"abc"`对象。从`s3`发出的虚线代表由`new`关键字（第8行）创建的对象。因此，我们有两个独立的字符串对象：一个在堆上，一个在池中（池也是堆的一部分）。
- en: The solid line from `s3` represents the result of the interning operation on
    line 12\. Now, it is straightforward to see why, after line 12, that `s1 == s3`
    returns `true`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从`s3`发出的实线代表第12行上intern操作的结果。现在，很容易看出为什么在第12行之后，`s1 == s3`返回`true`。
- en: So, when using strings, if you are interested in comparing the contents, use
    the `equals()` method. Note that `equals()` is case-sensitive. There is a method,
    namely `equalsIgnoreCase()`, which is case insensitive.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当使用字符串时，如果您想比较内容，请使用`equals()`方法。请注意，`equals()`是区分大小写的。有一个方法，即`equalsIgnoreCase()`，它是不区分大小写的。
- en: An important property of `String` objects is the fact that they are immutable.
    Let’s discuss that now.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`String`对象的一个重要属性是它们是不可变的。现在让我们来讨论这一点。'
- en: String immutability
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: String不可变性
- en: This topic is very important if you want to create immutable types or wish to
    obtain Java certification. We will discuss how to create a custom immutable type
    later. Regarding the `String` class, it is the object that is immutable and not
    the reference. What this means is that you can change the reference to point to
    a different string, but you cannot change the contents of the string object itself.
    Also, note that all the “wrapper” types, such as `Integer`, `Double`, `Float`,
    and `Character`, are also immutable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建不可变类型或希望获得Java认证，这个主题非常重要。我们将在稍后讨论如何创建自定义不可变类型。关于`String`类，它是不可变对象，而不是引用。这意味着您可以更改引用以指向不同的字符串，但不能更改字符串对象的内容。此外，请注意，所有“包装”类型，如`Integer`、`Double`、`Float`和`Character`，也都是不可变的。
- en: 'Let’s look at an example in code, with an associated in-memory diagram. *Figure
    12**.8* represents the code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码示例和相关的内存图表来查看。*图12**.8* 表示了代码：
- en: '![Figure 12.8 – “String” immutability (code)](img/B19793_12_08.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图12.8 – “String”不可变性（代码）](img/B19793_12_08.jpg)'
- en: Figure 12.8 – “String” immutability (code)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.8 – “String”不可变性（代码）
- en: 'In this figure, on line 18, using the `"The "` literal, we create a `String`
    object that’s referred to by the `s` reference. As this is a literal, the object
    goes into the string pool. Line 19 appends `"quick "` to `s` using the `+=` operator.
    As line 20 outputs `"The quick "`, you would be forgiven for thinking that the
    string object referred to by `s` has changed. This is not the case. As `String`
    objects are immutable, this is not allowed. What happens is that a new `String`
    object is created reflecting the requested changes. Therefore, we have three `String`
    objects on line 20: the two literals, `"The "` and `"quick "`, are in the string
    pool, and the newly created `"The quick "` object is on the heap.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图表中，第18行使用`"The "`字面量创建了一个由`s`引用的`String`对象。由于这是一个字面量，对象进入字符串池。第19行使用`+=`运算符将`"quick
    "`追加到`s`。由于第20行输出`"The quick "`,您可能会认为由`s`引用的字符串对象已经改变。事实并非如此。由于`String`对象是不可变的，这是不允许的。发生的情况是创建了一个新的`String`对象，反映了所需的变化。因此，在第20行我们有三个`String`对象：两个字面量`"The
    "`和`"quick "`在字符串池中，新创建的`"The quick "`对象在堆上。
- en: Line 21 is revealing. Many of the `String` API methods return a `String` (reference).
    As `String` objects are immutable, this `String` reference that’s returned is
    a reference to the newly created `String` object. This object is created in the
    background and reflects the requested changes. As we have not stored the reference
    on line 21, this object is lost to us and is immediately eligible for garbage
    collection. When we output `s` on line 22, you can see that it has not changed;
    its content is still `"The` `quick "`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 第 21 行是揭示性的。许多 `String` API 方法返回一个 `String`（引用）。由于 `String` 对象是不可变的，因此返回的这个
    `String` 引用是到新创建的 `String` 对象的引用。这个对象在后台创建，反映了请求的更改。由于我们没有在第 21 行存储引用，因此这个对象对我们来说是丢失的，并且立即可以回收。当我们第
    22 行输出 `s` 时，你可以看到它没有改变；其内容仍然是 `"The` `quick "`。
- en: Line 23 shows what line 21 should have done. By reinitializing `s`, we redirect
    the reference to the newly created object. Consequently, when we output `s` on
    line 24, we get the full string – that is, `"The quick` `brown fox"`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第 23 行显示了第 21 行应该做的事情。通过重新初始化 `s`，我们重定向了引用到新创建的对象。因此，当我们第 24 行输出 `s` 时，我们得到完整的字符串，即
    `"The quick` `brown fox"`。
- en: 'A diagram representing what is happening in memory will help here. *Figure
    12**.9* represents the in-memory representation of the code from *Figure 12**.8*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表示内存中发生情况的图表将有助于理解。*图 12.9* 表示 *图 12.8* 代码的内存表示：
- en: '![Figure 12.9 – “String” immutability (diagram)](img/B19793_12_09.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – “String”不可变性（图表）](img/B19793_12_09.jpg)'
- en: Figure 12.9 – “String” immutability (diagram)
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – “String”不可变性（图表）
- en: In the preceding figure, dashed lines represent overwritten references. We have
    six `String` objects in total – three string literals in the pool and three constructed
    string objects using both the `+=` operator and the `concat()` method.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，虚线表示被覆盖的引用。我们总共有六个 `String` 对象 – 池中的三个字符串字面量以及使用 `+=` 操作符和 `concat()`
    方法的三个构造的字符串对象。
- en: Notice that the string object in the middle (at the bottom), has no reference
    pointing to it. It never had, hence there is no dashed line pointing to it. This
    is the object that was created by line 21 but as the reference was never assigned
    to a variable, it was lost.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到中间的字符串对象（在底部），没有引用指向它。它从未有过，因此没有虚线指向它。这就是第 21 行创建的对象，但由于引用从未分配给变量，它已经丢失了。
- en: On the other hand, line 23 did store the reference to the newly created string
    object. It overwrote what was in the `s` reference. This is why `s` is referring
    to `"The quick` `brown fox"`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，第 23 行确实存储了新创建的字符串对象的引用。它覆盖了 `s` 引用中的内容。这就是为什么 `s` 指向 `"The quick` `brown
    fox"`。
- en: 'When we discuss `StringBuilder`, we will re-write the code from *Figure 12**.8*.
    For the moment, we will look at the more important methods in the `String` API.
    These are reflected in *Table 12.2*:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们讨论 `StringBuilder` 时，我们将重新编写 *图 12.8* 中的代码。目前，我们将查看 `String` API 中更重要的方法。这些方法反映在
    *表 12.2* 中：
- en: '| **Method Name** | **Description** |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **描述** |'
- en: '| --- | --- |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `char` `charAt(int index)` | Returns the character at the specified index.
    Indices range from 0 (as per arrays) to `length()`-1. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `char` `charAt(int index)` | 返回指定索引处的字符。索引范围从 0（与数组相同）到 `length()`-1。 |'
- en: '| `int` `compareTo(String anotherString)` | Compares two strings character
    by character lexicographically (dictionary order). In other words, `this.charAt(k)-anotherString.charAt(k)`.
    For example, `"ace"` comes before `"bat"`, `"and"` comes before `"at"`, and so
    forth. If all characters match but the two string lengths differ, then the shorter
    string precedes the longer string. For example, `"bat"` comes before `"battle"`.
    Let’s take a look:`"ace".compareTo("bat")` returns `-1`;`"and".compareTo("at")`
    returns `-6`;`"bat".compareTo("battle")` returns `-3` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `int` `compareTo(String anotherString)` | 按字典顺序逐字符比较两个字符串。换句话说，`this.charAt(k)-anotherString.charAt(k)`。例如，`"ace"`
    在 `"bat"` 之前，`"and"` 在 `"at"` 之前，以此类推。如果所有字符都匹配但两个字符串长度不同，则较短的字符串排在较长的字符串之前。例如，`"bat"`
    在 `"battle"` 之前。让我们看一下：`"ace".compareTo("bat")` 返回 `-1`；`"and".compareTo("at")`
    返回 `-6`；`"bat".compareTo("battle")` 返回 `-3` |'
- en: '| `String` `concat(String str)` | Concatenates the argument string to this
    string.`"abc".concat("def")` returns `"abcdef"`. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `String` `concat(String str)` | 将参数字符串连接到这个字符串上。`"abc".concat("def")` 返回
    `"abcdef"`。 |'
- en: '| `boolean` `endsWith(String suffix)` | Does this string end with the specified
    suffix? As it uses `equals(Object)`, it is case-sensitive.`"abc".endsWith("bc")`
    returns true.`"abc".endsWith("BC")` returns false. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `boolean endsWith(String suffix)` | 此字符串是否以指定的后缀结束？因为它使用`equals(Object)`，所以它是区分大小写的。“abc.endsWith("bc")”返回`true`。“abc.endsWith("BC")”返回`false`。
    |'
- en: '| `int hashCode()` | Returns a hash code for this string. Hash codes are used
    to store/retrieve objects used in hash-based collections such as `HashMap`. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `int hashCode()` | 返回此字符串的哈希码。哈希码用于存储/检索用于基于哈希的集合（如`HashMap`）中的对象。 |'
- en: '| `int` `indexOf(String str)` | Returns the index of the first occurrence of
    the specified substring. It is case-sensitive and overloaded.`"abcdef".indexOf("b")`
    returns `1`.`"abcdef".indexOf("B")` returns `-1`. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `int indexOf(String str)` | 返回指定子字符串首次出现处的索引。它是区分大小写的，并且是重载的。“abcdef.indexOf("b")”返回`1`。“abcdef.indexOf("B")”返回`-1`。
    |'
- en: '| `int length()` | Returns the length of the string. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `int length()` | 返回字符串的长度。 |'
- en: '| `String` `substring(int beginIndex)` | Returns the substring of this string,
    starting at the specified `beginIndex` and proceeding until the end of this string.
    Indices start at 0.`"abcdef".substring(3)` returns `"def"`. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `String substring(int beginIndex)` | 返回此字符串的子字符串，从指定的`beginIndex`开始，并继续到字符串的末尾。索引从0开始。“abcdef.substring(3)”返回`"def"`。
    |'
- en: '| `String substring(int beginIndex,` `int endIndex)` | Returns the substring
    of this string. The substring begins at the specified `beginIndex` and extends
    to the character at `endIndex`-1\. Indices start at 0.Think: “Give me `endIndex-startIndex`
    characters, starting at `startIndex`.” For example,`"Sean Kennedy".substring(3,8)`
    means “Give me 5 characters, starting at index 3,” which returns `"``n Ken"`.
    |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `String substring(int beginIndex, int endIndex)` | 返回此字符串的子字符串。子字符串从指定的`beginIndex`开始，延伸到`endIndex`-1处的字符。索引从0开始。思考：
    “给我`endIndex-startIndex`个字符，从`startIndex`开始。” 例如，`"Sean Kennedy".substring(3,8)`意味着“给我5个字符，从索引3开始”，它返回`"n
    Ken"`。 |'
- en: '| `String toLowerCase()``String toUpperCase()` | Converts the string to lowercase
    and uppercase, respectively. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `String toLowerCase()``String toUpperCase()` | 分别将字符串转换为小写和大写。 |'
- en: '| `String trim()` | The `trim()` method removes whitespace from both ends of
    a string – for example,`" lots of spaces here` `".trim()` returns `""lots of spaces`
    `here""` |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `String trim()` | `trim()`方法从字符串的两端删除空白字符 – 例如，`" lots of spaces here".trim()`返回`"
    lots of spaces here"` |'
- en: Table 12.2 – Sample “String” API methods
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2 – “String”API方法示例
- en: Now, let’s turn our attention to the `StringBuilder` class.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将注意力转向`StringBuilder`类。
- en: StringBuilder class
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`StringBuilder`类'
- en: The `StringBuilder` class is also in the `java.lang` package and represents
    a mutable sequence of characters. The API for `StringBuilder` is the same as for
    the `StringBuffer` class. Use `StringBuilder` in a single-thread environment and
    use `StringBuffer` in a multithreading environment. `StringBuilder` also implements
    the `Comparable` interface where the natural ordering defined for sorting is also
    alphabetic.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`类也在`java.lang`包中，表示一个可变的字符序列。`StringBuilder`的API与`StringBuffer`类相同。在单线程环境中使用`StringBuilder`，在多线程环境中使用`StringBuffer`。`StringBuilder`还实现了`Comparable`接口，其中定义的自然排序顺序也是字母顺序。'
- en: '`StringBuilder` is a mutable type. `StringBuilder` is also a `final` class,
    which means that you cannot subclass it. Again, this is deliberate as the Java
    designers wanted to ensure predictable behavior from `StringBuilder` objects.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`是一个可变类型。`StringBuilder`也是一个`final`类，这意味着你不能从它派生子类。再次强调，这是故意的，因为Java设计者希望确保`StringBuilder`对象的行为可预测。'
- en: As promised earlier, we will refactor *Figure 12**.8* to use `StringBuilder`
    instead of `String`. In addition, we will diagram the differences in memory.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将重构*图12**.8*，使用`StringBuilder`代替`String`。此外，我们还将绘制内存中的差异图。
- en: StringBuilder example (code)
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`StringBuilder`示例（代码）'
- en: '*Figure 12**.10* represents the code:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.10* 表示的代码：'
- en: '![Figure 12.10 – “StringBuilder” example in code](img/B19793_12_10.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图12.10 – 代码中的“StringBuilder”示例](img/B19793_12_10.jpg)'
- en: Figure 12.10 – “StringBuilder” example in code
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.10 – 代码中的“StringBuilder”示例
- en: In this figure, line 49 creates a new `StringBuilder` object and initializes
    it to `"The "`. Line 50 uses the `append()` method to append `"quick "` to the
    object referenced by `sb`. As `StringBuilder` objects are mutable, we can ignore
    the reference returned (as we have that reference in `sb` already). Line 51 outputs
    `"The quick "`, thereby demonstrating that the (one) `StringBuilder` object was
    changed. Line 52 appends `"brown fox"` to the `StringBuilder` object and line
    53 again shows that there is only one object all the time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第49行创建了一个新的`StringBuilder`对象并将其初始化为`"The "`。第50行使用`append()`方法将`"quick
    "`追加到由`sb`引用的对象中。由于`StringBuilder`对象是可变的，我们可以忽略返回的引用（因为我们已经在`sb`中有了这个引用）。第51行输出了`"The
    quick "`，从而证明了（唯一的）`StringBuilder`对象已被更改。第52行将`"brown fox"`追加到`StringBuilder`对象中，第53行再次显示始终只有一个对象。
- en: Let’s have a look at the in-memory representation of *Figure 12**.10*.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看*图12.10**的内存表示。
- en: StringBuilder example (diagram)
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: StringBuilder示例（图表）
- en: '*Figure 12**.11* represents the in-memory representation of the code in *Figure
    12**.10*:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.11*代表了*图12.10*中代码的内存表示：'
- en: '![Figure 12.11 – “StringBuilder” example in memory](img/B19793_12_11.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图12.11 – 内存中的“StringBuilder”示例](img/B19793_12_11.jpg)'
- en: Figure 12.11 – “StringBuilder” example in memory
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.11 – 内存中的“StringBuilder”示例
- en: As can be seen from this figure, apart from the string pool objects (which are
    there as they are string literals), we only have one `StringBuilder` object. Each
    time we call `append()`, that one mutable `StringBuilder` object is changed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个图中可以看出，除了字符串池对象（因为它们是字符串字面量）之外，我们只有一个`StringBuilder`对象。每次我们调用`append()`时，那个可变的`StringBuilder`对象都会被更改。
- en: 'Let’s have a look at the more commonly used API methods from `StringBuilder`.
    *Table 12.3* reflects this API:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`StringBuilder`中更常用的API方法。*表12.3*反映了这个API：
- en: '| **Method Name** | **Description** |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **描述** |'
- en: '| `StringBuilder` `append(String str)` | Appends the specified string to `StringBuilder`.
    Overloaded versions are available (see the API). |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `StringBuilder` `append(String str)` | 将指定的字符串追加到`StringBuilder`。有可用的重载版本（见API）。|'
- en: '| `char` `charAt(int index)` | Returns the character at the specified index.
    Indices range from 0. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `char` `charAt(int index)` | 返回指定索引处的字符。索引范围从0。|'
- en: '| `int` `indexOf(String str)` | Returns the index of the first occurrence of
    the specified substring. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `int` `indexOf(String str)` | 返回指定子字符串首次出现的索引。|'
- en: '| `StringBuilder insert(int offset,` `String str)` | Inserts the given string
    into the `StringBuilder` object at the specified offset, moving any characters
    above that position upwards. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `StringBuilder insert(int offset,` `String str)` | 在指定的偏移量处将给定的字符串插入到`StringBuilder`对象中，并将该位置以上的任何字符向上移动。|'
- en: '| `String` `substring(int beginIndex)` | Returns a new string, starting at
    the specified `beginIndex`, and proceeds until the end of this string builder.
    Indices start at 0. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `String` `substring(int beginIndex)` | 返回一个新的字符串，从指定的`beginIndex`开始，直到此字符串构建器的末尾。索引从0开始。|'
- en: '| `String substring(int beginIndex,` `int endIndex)` | Returns a new string,
    starting at the specified `beginIndex`, and extends to the character at `endIndex-1`.
    Indices start at 0. |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `String substring(int beginIndex,` `int endIndex)` | 返回一个新的字符串，从指定的`beginIndex`开始，并扩展到`endIndex-1`处的字符。索引从0开始。|'
- en: '| `String toString()` | Returns a string representation of the character sequence.
    |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `String toString()` | 返回字符序列的字符串表示。|'
- en: Table 12.3 – Sample “StringBuilder” API methods
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.3 – 样本“StringBuilder”API方法
- en: As we have seen, the major difference between `String` and `StringBuilder` is
    that `String` objects are immutable, whereas `StringBuilder` objects are mutable.
    Let’s look at an example that will help bring that difference into sharp focus.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`String`和`StringBuilder`之间的主要区别在于`String`对象是不变的，而`StringBuilder`对象是可变的。让我们看看一个将有助于将这种差异清晰地聚焦的示例。
- en: String versus StringBuilder example
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: String与StringBuilder示例
- en: 'We will use a sample piece of code to demonstrate this. This code will help
    highlight both the immutability of `String` objects and the mutability of `StringBuilder`
    objects. As a bonus, because we are using methods, the code will help us revise
    the principle of call by value. *Figure 12**.12* shows the code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个示例代码来演示这一点。此代码将帮助我们突出`String`对象的不变性和`StringBuilder`对象的可变性。作为额外的好处，因为我们使用了方法，所以代码将帮助我们复习按值传递的原则。**图12.12**显示了代码：
- en: '![Figure 12.12 – “String” versus “StringBuilder” code example](img/B19793_12_12.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图12.12 – “String”与“StringBuilder”代码示例](img/B19793_12_12.jpg)'
- en: Figure 12.12 – “String” versus “StringBuilder” code example
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.12 – “String”与“StringBuilder”代码示例
- en: In this figure, on line 11, we declare a `String` reference, `s`, that’s referring
    to `"Hi"` and a `StringBuilder` reference, `sb`, that contains `"Hi"` also. On
    line 13, we invoke the `whatHappens()` method, passing in both `s` and `sb`, respectively.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，在第11行，我们声明了一个指向`"Hi"`的`String`引用`s`和一个包含`"Hi"`的`StringBuilder`引用`sb`。在第13行，我们调用`whatHappens()`方法，分别传入`s`和`sb`。
- en: As Java uses call by value, a copy of each reference is made. Thus, the `s`
    and `sb` references in the method declaration (line 4) refer to the same objects
    that were declared on lines 11 and 12, respectively. While not necessary, keeping
    the same identifiers, `s` and `sb`, helps emphasize this point.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java使用按值调用，每个引用都会创建一个副本。因此，方法声明（第4行）中的`s`和`sb`引用分别指向第11行和第12行声明的相同对象。虽然不是必需的，但保持相同的标识符`s`和`sb`有助于强调这一点。
- en: Line 5 then concatenates `" there!"` onto the string referenced by `s`. As strings
    are immutable, that object cannot be changed, so the JVM creates a new object
    with the character sequence (string value) of `"Hi there!"`. Line 7 outputs this
    new string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第5行然后将`" there!"`连接到由`s`引用的字符串。由于字符串是不可变的，该对象不能被更改，因此JVM创建了一个具有字符序列（字符串值）为`"Hi
    there!"`的新对象。第7行输出这个新字符串。
- en: Line 6 appends `" there!"` to the `StringBuilder` object. As it is mutable,
    the object is simply modified. Line 8 outputs `sb` after this change.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 第6行将`" there!"`追加到`StringBuilder`对象。由于它是可变的，对象只是被修改。修改后，第8行输出`sb`。
- en: After the method call on line 13 returns, we output both the values of the string
    object referred to by `s` and the string builder object referred to by `sb`. Remember,
    because we passed in references and because of call by value, the `whatHappens()`
    method had direct access to the objects declared in `main()` on lines 11 and 12\.
    However, when we output the string object (line 14), we see that it is still `"Hi"`,
    demonstrating that `String` objects are immutable. On the other hand, when we
    output the `StringBuilder` object, it has changed to `"Hi there!"`, demonstrating
    the mutability of `StringBuilder` objects.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在第13行的方法调用返回后，我们输出由`s`引用的字符串对象的值和由`sb`引用的字符串构建器对象的值。记住，因为我们传递了引用，并且由于按值调用，`whatHappens()`方法可以直接访问第11行和第12行在`main()`中声明的对象。然而，当我们输出字符串对象（第14行）时，我们看到它仍然是`"Hi"`，这证明了`String`对象是不可变的。另一方面，当我们输出`StringBuilder`对象时，它已变为`"Hi
    there!"`，这证明了`StringBuilder`对象的可变性。
- en: 'A diagram will help here. However, to keep the diagram simple and to focus
    on mutability/immutability, the string pool has been omitted. *Figure 12**.13*
    is the in-memory representation of the code in *Figure 12**.12*:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个图表会有帮助。然而，为了使图表简单并专注于可变/不可变，省略了字符串池。*图12*.*13*是*图12*.*12*中代码的内存表示：
- en: '![Figure 12.13 - ”String” versus “StringBuilder” in memory](img/B19793_12_13.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图12.13 - 内存中的“String”与“StringBuilder”](img/B19793_12_13.jpg)'
- en: Figure 12.13 - ”String” versus “StringBuilder” in memory
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.13 - 内存中的“String”与“StringBuilder”
- en: This figure represents the picture in memory as we are just about to leave the
    `whatHappens()` method (line 9). The dashed arrow is the important arrow. When
    we entered the `whatHappens()` method, both `s` references were pointing at the
    same `String` object. Line 5 changes the local `s` reference to point to the new
    `String` object and the original `String` object was untouched (as it is immutable).
    The other thing to notice is that the `StringBuilder` object has been modified
    (we used a strikethrough to highlight this).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表示我们即将离开`whatHappens()`方法（第9行）时的内存图片。虚线箭头是重要的箭头。当我们进入`whatHappens()`方法时，两个`s`引用都指向同一个`String`对象。第5行将局部`s`引用更改为指向新的`String`对象，而原始`String`对象保持未变（因为它是不可变的）。要注意的另一件事是`StringBuilder`对象已被修改（我们使用删除线来突出这一点）。
- en: Thus, when we return to `main()` after calling the method (line 13), the `s`
    reference is referring to the untouched `String` object containing `"Hi"`, whereas
    the `sb` reference is referring to the modified `StringBuilder` object containing
    `"``Hi there!"`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在调用方法（第13行）后返回`main()`，`s`引用指向未更改的包含`"Hi"`的`String`对象，而`sb`引用指向已修改的包含`"Hi
    there!"`的`StringBuilder`对象。
- en: This discussion on immutable types leads to a natural question, how do I create
    a custom immutable type? That is the topic of the next section.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于不可变类型的讨论引出一个自然的问题，我如何创建一个自定义的不可变类型？这就是下一节的主题。
- en: Designing a custom immutable type
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计一个自定义的不可变类型
- en: In the API, there are mutable types, such as `StringBuilder` and `ArrayList`,
    and immutable types, such as `String` and `Integer`. When something is “immutable,”
    it means it cannot change. We can use the `final` keyword to make a primitive
    value immutable. When we apply `final` to a reference, it is the reference that
    is immutable and not the object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 API 中，有可变类型，如 `StringBuilder` 和 `ArrayList`，以及不可变类型，如 `String` 和 `Integer`。当某物是“不可变”的时候，意味着它不能改变。我们可以使用
    `final` 关键字来使原始类型不可变。当我们对引用应用 `final` 时，是不可变的引用而不是对象。
- en: What if we wanted to create our own type (class) and make it immutable? In other
    words, we want the *objects* based on our custom class to be immutable. What considerations
    are involved? That is what we’ll discuss in this section.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建自己的类型（类）并使其不可变呢？换句话说，我们希望基于我们的自定义类的 *对象* 是不可变的。涉及哪些考虑因素？这就是我们将在本节中讨论的内容。
- en: Before we present the checklist, recall that Java uses call by value when passing
    arguments to, and retrieving values from, methods. Call by value implies that
    a copy of the argument is made and that the method works with that copy. For primitives,
    this means that the called method cannot change the primitive value passed from
    the caller method. This is analogous to passing a photocopy of a sheet of paper;
    the photocopied sheet can be written on, without it changing the original. For
    references, however, the situation is different. Passing a reference to a method
    means that the called method can change the object that the caller method is looking
    at. This is analogous to passing a copy of a remote control; the copy-remote can
    change the TV channel also. This is reflected in the checklist. Let’s examine
    this checklist.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们展示清单之前，请记住，Java 在向方法传递参数和从方法中检索值时使用按值传递。按值传递意味着会创建参数的副本，并且方法使用这个副本。对于原始类型，这意味着被调用方法不能改变从调用方法传递过来的原始类型值。这类似于传递一张纸的复印件；复印的纸张可以被写上内容，而不会改变原件。然而，对于引用来说，情况就不同了。向方法传递引用意味着被调用方法可以改变调用方法正在查看的对象。这类似于传递一个遥控器的副本；遥控器的副本也可以改变电视频道。这在清单中得到了体现。让我们来检查这个清单。
- en: The checklist
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清单
- en: 'The checklist to apply is as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 应用的清单如下：
- en: Do not provide any “setter” methods
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要提供任何“setter”方法
- en: Make all the fields `private` and `final`
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有字段 `private` 化并设置为 `final`
- en: 'Prevent subclassing (so that methods cannot be overridden):'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止子类化（这样方法就不能被重写）：
- en: Make the class `final`
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将类 `final` 化
- en: Make the constructor `private` and provide a `public static` factory method
    such as `createNewInstance`
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将构造函数 `private` 化并提供一个 `public static` 工厂方法，例如 `createNewInstance`
- en: 'Regarding instance fields, bear in mind that:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于实例字段，请注意以下几点：
- en: Immutable types such as `String` are ok
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像字符串 `String` 这样的不可变类型是可以的
- en: For mutable types such as `StringBuilder`, do *not* share the references – use
    the advanced encapsulation technique outlined in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168).
    This technique is also known as “defensive copying”.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于像 `StringBuilder` 这样的可变类型，*不要* 共享引用 – 使用在 [*第 8 章*](B19793_08.xhtml#_idTextAnchor168)
    中概述的高级封装技术。这项技术也被称为“防御性复制”。
- en: This checklist is best explained with the aid of a code example. We will start
    with an example that looks fine but has a subtle issue. We will examine the issue
    in memory to explain it further. Finally, we will address the issue in code and
    show why it works in memory.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个清单最好通过代码示例来解释。我们将从一个看起来不错但存在细微问题的示例开始。我们将通过内存中的问题来进一步解释这个问题。最后，我们将通过代码来解决这个问题，并展示为什么它在内存中是可行的。
- en: Immutable type (breaking encapsulation)
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变类型（破坏封装）
- en: '*Figure 12**.14* presents such an example:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 12.14* 展示了这样一个示例：'
- en: '![Figure 12.14 – A custom immutable type that breaks encapsulation](img/B19793_12_14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 一个破坏封装的自定义不可变类型](img/B19793_12_14.jpg)'
- en: Figure 12.14 – A custom immutable type that breaks encapsulation
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 一个破坏封装的自定义不可变类型
- en: In this figure, we have an immutable type called `Farm`. The class is `final`
    (line 6), so it cannot be subclassed. All of the fields are `private` and `final`
    (lines 8-10). Marking them as `private` ensures no external classes can change
    their values without our knowledge (basic encapsulation). Marking them as `final`
    means that once given initial values, those values cannot change. In this example,
    as they are not given initial values at the point of declaration, they are known
    as *blank finals*. Blank finals must be initialized before the constructor finishes,
    which is what we do (lines 14-17).
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有一个名为`Farm`的不可变类型。该类是`final`（第6行），因此不能被继承。所有的字段都是`private`和`final`（第8-10行）。将它们标记为`private`确保没有外部类可以在不知情的情况下更改它们的值（基本的封装）。将它们标记为`final`意味着一旦赋予初始值，这些值就不能改变。在这个例子中，由于它们在声明点没有赋予初始值，因此它们被称为*空白final*。空白final必须在构造函数完成之前初始化，这正是我们所做的（第14-17行）。
- en: Our constructor is marked `private` on line 13\. Thus, no external class can
    `new` a `Farm` object directly via this constructor. This is another way to prevent
    subclassing, as no subclass will have access to this constructor and as we have
    a constructor coded, the compiler will not insert the default constructor either.
    We have marked the constructor parameters as `final` also, in case of accidental
    change.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造函数在第13行被标记为`private`。因此，没有外部类可以通过这个构造函数直接`new`一个`Farm`对象。这是防止继承的另一种方式，因为子类无法访问这个构造函数，并且因为我们已经编写了构造函数，编译器也不会插入默认构造函数。我们还把构造函数参数标记为`final`，以防意外更改。
- en: The `createNewInstance()` factory method (lines 20-23) is how we enable external
    classes to create `Farm` objects. We provide a `public` `static` method that calls
    the `private` constructor on their behalf. Marking it as `public` gives every
    class access to this method; marking it as `static` ensures that clients do not
    have to create an object to create a `Farm` (which they can’t do directly anyway!).
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`createNewInstance()`工厂方法（第20-23行）是我们如何使外部类能够创建`Farm`对象。我们提供了一个`public` `static`方法，代表它们调用`private`构造函数。将其标记为`public`使得每个类都可以访问这个方法；将其标记为`static`确保客户端不需要创建一个对象来创建`Farm`（他们直接也无法做到！）。'
- en: Note that there are no `set` methods, only `get` methods (lines 25-34). There
    is one `get` method per instance variable.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，没有`set`方法，只有`get`方法（第25-34行）。每个实例变量都有一个`get`方法。
- en: Note that this class breaks encapsulation. This is because, in the constructor
    (line 17), we are storing the reference that was passed in. In addition, our `getAnimals()`
    method is returning the reference we stored. We will see the implications of this
    in memory shortly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个类打破了封装。这是因为，在构造函数（第17行）中，我们存储了传入的引用。此外，我们的`getAnimals()`方法返回我们存储的引用。我们将在稍后的内存中看到这一点的含义。
- en: 'However, for now, let’s look at a client class utilizing the “supposedly immutable”
    `Farm` class. *Figure 12**.15* highlights an issue:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们看看一个利用“看似不可变”的`Farm`类的客户端类。*图12.15*突出了一个问题：
- en: '![Figure 12.15 – A class that uses a weakly encapsulated custom immutable type](img/B19793_12_15.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图12.15 – 使用弱封装的自定义不可变类型的类](img/B19793_12_15.jpg)'
- en: Figure 12.15 – A class that uses a weakly encapsulated custom immutable type
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.15 – 使用弱封装的自定义不可变类型的类
- en: In this figure, we declare a `List` (interface) reference, namely `animals`,
    referring to an `ArrayList` object (line 54). By stating the reference is of the
    `List<String>` type, we are telling the compiler that only strings are allowed.
    This gives us type safety, as we cannot, for example, add an `Integer` object
    to our list. As `ArrayList` is a mutable type, it is perfect for our example.
    Line 55 adds `"Cattle"` to our `ArrayList`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们声明了一个`List`（接口）引用，即`animals`，它指向一个`ArrayList`对象（第54行）。通过声明引用是`List<String>`类型，我们告诉编译器只允许字符串。这为我们提供了类型安全，因为我们不能，例如，向我们的列表中添加一个`Integer`对象。由于`ArrayList`是可变类型，它非常适合我们的例子。第55行将`"Cattle"`添加到我们的`ArrayList`中。
- en: Line 57 uses the `createNewInstance()` factory method, passing in `"Small Farm"`,
    `25`, and our `animals` array list. Line 58 proves that the object was created
    properly.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 第57行使用了`createNewInstance()`工厂方法，传递了`"Small Farm"`、`25`和我们的`animals`数组列表。第58行证明了对象被正确创建。
- en: Lines 61-63 are where we initialize the local variables based on the `Farm`
    object’s state (the values of the instance variables). Lines 64-65 check that
    they are set as expected.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 第61-63行是初始化局部变量的地方，这些变量基于`Farm`对象的状态（实例变量的值）。第64-65行检查它们是否按预期设置。
- en: Lines 68-70 are where we change the *local* variables. This is the acid test.
    Changing the local variables should *not* affect the state of our `Farm` object.
    On line 73, we output the instance variables again, via the implicit call to `toString()`.
    The output is in a comment on the previous line, line 72\. As can be seen from
    the output, the instance’s `String` variable name is unaffected (still `"Small
    Farm"`) and the `numAnimals` instance primitive is also unaffected (still 25).
    However, the `animals` instance variable has changed! The `ArrayList` object type
    is the issue here. Originally, the list was just `"Cattle"`; now, it is `"Cattle"`,
    `"Sheep"`, and `"Horses"`. This change is highlighted by the rectangles. How did
    this happen? Looking at the situation in memory will reveal the issue.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 第68-70行是我们更改局部变量的地方。这是关键测试。更改局部变量不应该影响我们的`Farm`对象的状态。在第73行，我们再次通过隐式调用`toString()`输出实例变量。输出在上一行的注释中，即第72行。从输出中可以看出，实例的`String`变量名未受影响（仍然是`"Small
    Farm"`)，而`numAnimals`实例原始值也未受影响（仍然是25）。然而，`animals`实例变量已更改！这里的`ArrayList`对象类型是问题所在。最初，列表中只有`"Cattle"`；现在，它变成了`"Cattle"`、`"Sheep"`和`"Horses"`。这种变化通过矩形突出显示。这是怎么发生的？查看内存中的情况将揭示问题。
- en: In-memory representation (breaking encapsulation)
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存表示（破坏封装）
- en: '*Figure 12**.16* shows the situation in memory (as we are just about to exit
    the program). Note that *Figure 12**.16* represents the whole program across both
    figures, namely *Figure 12**.14* and *Figure 12**.15*.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12.16*显示了内存中的情况（因为我们即将退出程序）。请注意，*图12.16*代表整个程序，即*图12.14*和*图12.15*。'
- en: '![   Figure 12.16 – Encapsulation broken by a custom “immutable” type](img/B19793_12_16.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图12.16 – 被自定义“不可变”类型破坏的封装](img/B19793_12_16.jpg)'
- en: Figure 12.16 – Encapsulation broken by a custom “immutable” type
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.16 – 被自定义“不可变”类型破坏的封装
- en: In the preceding figure, the dashed lines represent original states or values.
    For example, the dashed line from the `name` variable, on the stack in `main()`,
    represents line 61 in the code. In contrast, the sold line from the same variable
    represents line 68.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，虚线表示原始状态或值。例如，从`name`变量到`main()`中栈上的虚线表示代码中的第61行。相比之下，从同一变量的实线表示第68行。
- en: Let’s discuss the stack first. The local `farm` reference refers to the `Farm`
    object on the heap, which is where the `name`, `numAnimals`, and `animals` instance
    variables are initialized accordingly. As stated, the local `name` variable in
    `main()` is initialized (line 61) to refer to the same `String` object that the
    instance variable in the `Farm` object is looking at. The local `numAnimals` variable
    is initialized to the value of the instance variable of the same name (line 62).
    Note that the local copy is represented as a rectangle and not an arrow; this
    reflects the photocopy of a sheet of paper analogy. Line 63 initializes the local
    `animals` reference to point to the same `ArrayList` object as the `animals` instance
    variable in the `Farm` object on the heap. This is the problem, as we shall see
    very shortly.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先讨论栈。局部`farm`引用指向堆上的`Farm`对象，在那里初始化了相应的`name`、`numAnimals`和`animals`实例变量。正如所述，`main()`中的局部`name`变量初始化（第61行）为引用与`Farm`对象中的实例变量查看相同的`String`对象。局部`numAnimals`变量初始化为同名实例变量的值（第62行）。请注意，局部副本表示为矩形而不是箭头；这反映了纸张复印件的类比。第63行初始化局部`animals`引用指向堆上`Farm`对象的`animals`实例变量相同的`ArrayList`对象。这正是问题所在，正如我们很快就会看到的。
- en: Just as we start to execute line 68, both `name` references, the local one on
    the stack and the instance one on the heap, are referring to the same `String`
    object. Line 68 changes the `name` local variable to `"Big Farm"`. However, as
    `String` objects are immutable, a new `String` object is created on the heap reflecting
    those changes. In other words, a new `String` object with `"Big Farm"` is created
    and `name` (on the stack) refers to it. The dashed line, referring to the original
    `String` object, and the solid line referring to the new `String` object represent
    this (from `name` on the stack).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正当我们开始执行第68行时，两个`name`引用，栈上的局部引用和堆上的实例引用，都指向相同的`String`对象。第68行将`name`局部变量更改为`"Big
    Farm"`。然而，由于`String`对象是不可变的，堆上创建了一个新的`String`对象来反映这些更改。换句话说，创建了一个新的`"Big Farm"`的`String`对象，而`name`（在栈上）指向它。虚线和实线表示这一点（从栈上的`name`）。
- en: Note that the `name` *instance* variable is completely unaffected by this change.
    That is the strength of immutable types. Other classes are unable to change their
    values.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`name`实例变量完全不受此更改的影响。这正是不可变类型的优势。其他类无法更改它们的值。
- en: Line 69 changes the `numAnimals` local variable (on the stack) to 500\. The
    strikethrough font for the old value and 500 for the new value represent this.
    Again, the `numAnimals` instance variable is untouched, demonstrating that primitives
    are fine in custom immutable types.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第69行将局部变量`numAnimals`（在栈上）更改为500。旧值的删除线字体和新的500代表这一点。再次强调，`numAnimals`实例变量未受影响，这证明了在自定义不可变类型中原始数据类型是安全的。
- en: The issue becomes apparent on line 70, where we add `"Sheep"` and `"Horses"`
    to the local array list. This should not change the supposedly `private` list
    that the instance variable is looking at. But it does!
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在第70行变得明显，我们在局部数组列表中添加了`"Sheep"`和`"Horses"`。这不应该改变实例变量所查看的所谓`private`列表。但它确实改变了！
- en: So, we know there is a problem, but how do we fix it?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们知道存在问题，但我们该如何修复它呢？
- en: Immutable types (properly encapsulated)
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变类型（正确封装）
- en: The issue here is with the reference to the mutable type being passed in and
    returned. A custom immutable type should not store or return the reference *directly*.
    Once you do that, the external class is looking at the same object and as it is
    mutable, you have no protection from the JVM. That is why lines 17 and 33 are
    in bold in *Figure 12**.16* – they are the lines causing the problem.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是传入并返回的可变类型引用。自定义不可变类型不应直接存储或返回引用。一旦这样做，外部类就会查看同一个对象，由于它是可变的，你无法从JVM中获得保护。这就是为什么在*图12.16*中，17行和33行被加粗。它们是导致问题的行。
- en: So, how do we solve this? Well, the solution is to refer back to what we discussed
    in [*Chapter 8*](B19793_08.xhtml#_idTextAnchor168), *Mastering Advanced Encapsulation*.
    In summary, we should use a technique known as “defensive copying” to deal with
    this situation.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何解决这个问题呢？好吧，解决方案是回顾我们在[*第8章*](B19793_08.xhtml#_idTextAnchor168)中讨论的内容，*精通高级封装*。总的来说，我们应该使用一种称为“防御性复制”的技术来处理这种情况。
- en: 'Only two code changes need to be made to our immutable `Farm` type. One is
    in the constructor; the other is in the relevant `get` method, namely `getAnimals()`.
    *Figure 12**.17* shows the code changes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只需对我们的不可变`Farm`类型进行两个代码更改。一个是在构造函数中；另一个是在相关的`get`方法中，即`getAnimals()`。*图12.17*显示了代码更改：
- en: '![   Figure 12.17 – Custom immutable type, properly encapsulated](img/B19793_12_17.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图12.17 – 正确封装的自定义不可变类型](img/B19793_12_17.jpg)'
- en: Figure 12.17 – Custom immutable type, properly encapsulated
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.17 – 正确封装的自定义不可变类型
- en: Rather than present code that has not changed, this figure presents a segment
    of the class so that we can focus on the changes. Line 16, which was commented
    out before, is now uncommented and line 17, which has the issue, is now commented
    out. Contrasting them, we can see that instead of directly storing the reference
    passed in (line 17), we are now creating a `ArrayList` object, based on the contents
    of the list passed in. We then store the reference to the new `ArrayList` object
    in our `private` instance variable.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是展示未更改的代码，此图展示了一个类段，以便我们可以关注更改。之前被注释掉的16行现在被取消注释，而存在问题的17行现在被注释掉。通过对比它们，我们可以看到，我们现在是创建一个基于传入列表内容的`ArrayList`对象（第17行），而不是直接存储传入的引用。然后我们将新`ArrayList`对象的引用存储在我们的`private`实例变量中。
- en: The other change relates to lines 32 and 33\. Line 33, which has the issue,
    has been commented out, whereas line 32, which has the fix, has been uncommented.
    Again, rather than returning a copy of our `private` instance variable (line 33),
    we are creating a `ArrayList` object based on the contents of our array list and
    returning that reference. The contents of the new object can be identical to our
    private copy, so long as the external class cannot change our private copy. These
    changes achieve that. Let’s look at the situation in memory.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个更改与第32行和33行有关。存在问题的第33行已被注释掉，而具有修复功能的第32行已被取消注释。同样，我们不是返回我们的`private`实例变量的副本（第33行），而是基于我们的数组列表内容创建一个`ArrayList`对象，并返回该引用。新对象的内容可以与我们的私有副本完全相同，只要外部类不能更改我们的私有副本。这些更改实现了这一点。让我们看看内存中的情况。
- en: In-memory representation (properly encapsulated)
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内存表示（正确封装）
- en: In the interests of clarity in the diagram, we have only shown the `ArrayList`
    objects and their references. *Figure 12**.16* already demonstrated that `String`
    objects and primitives were fine, so there’s no need to look at those elements
    again.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在图中保持清晰，我们只展示了`ArrayList`对象及其引用。*图12**.16* 已经展示了`String`对象和原始数据类型是正常的，所以没有必要再次查看这些元素。
- en: '*Figure 12**.18* shows the situation in memory now (at the end of the program,
    just before we exit):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.18* 展示了当前内存中的情况（在程序结束前，在我们退出之前）：'
- en: '![   Figure 12.18 - In-memory representation of properly encapsulated custom
    immutable type](img/B19793_12_18.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![   图12.18 - 正确封装的自定义不可变类型的内存表示](img/B19793_12_18.jpg)'
- en: Figure 12.18 - In-memory representation of properly encapsulated custom immutable
    type
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.18 - 正确封装的自定义不可变类型的内存表示
- en: In this figure, the methods where each of the three `ArrayList` objects are
    created are marked in bold. For example, the bottom `ArrayList` object (marked
    A) was created in `main()`. Examining that object for a moment, we can see that
    the `animals` reference on the stack initially (dashed line) refers to it. There
    is just one `String` in it, `"Cattle"`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，标记了创建三个`ArrayList`对象的每个方法。例如，底部的`ArrayList`对象（标记为A）是在`main()`中创建的。暂时检查该对象，我们可以看到堆栈上的`animals`引用最初（虚线）指向它。它里面只有一个`String`，即`"Cattle"`。
- en: This object is passed via the factory method into the constructor, where its
    content (`"Cattle"`) is used to create a *new* array list object and initialize
    the `animals` instance variable so that it points at the new object (line 16).
    This is represented in the figure by the `ArrayList` object being marked with
    `Farm()` (and the letter B).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象通过工厂方法传递到构造函数中，其中其内容（`"Cattle"”）被用来创建一个新的数组列表对象并初始化`animals`实例变量，使其指向新对象（第16行）。这在图中通过标记为`Farm()`（以及字母B）的`ArrayList`对象来表示。
- en: The call to `getAnimals()` also results in a new array list object being created
    (line 32). This new object is marked by the method name creating it, namely `getAnimals()`,
    and the letter C. Initially, it just contains `"Cattle"` as this is what the instance
    variable contains. The dashed rectangle represents this.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对`getAnimals()`的调用也会导致创建一个新的数组列表对象（第32行）。这个新对象由创建它的方法名称标记，即`getAnimals()`，以及字母C。最初，它只包含`"Cattle"`，因为这正是实例变量包含的内容。虚线矩形表示这一点。
- en: Now, however, when we use the local animals reference to insert both “Sheep”
    and “Horses” into the array list (marked D), the private instance array list is
    **not** affected. Thus, this class is properly encapsulated.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在当我们使用局部动物引用将“羊”和“马”都插入到数组列表（标记为D）中时，私有实例数组列表**不受影响**。因此，这个类被正确封装。
- en: That completes our coverage on creating a custom immutable type. The next few
    topics are ones we have touched upon in our recent example, namely `List` and
    `ArrayList`. Let’s discuss both in more detail now.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这就完成了我们对创建自定义不可变类型的覆盖。接下来几个主题是我们最近示例中提到的，即`List`和`ArrayList`。现在让我们更详细地讨论这两个主题。
- en: Examining List and ArrayList
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查List和ArrayList
- en: '`List` is an interface implemented by the `ArrayList` class. Therefore, any
    API method in `List` is automatically in `ArrayList`. As we know, it is good coding
    practice to use an interface reference (`List`) to refer to an object (`ArrayList`).
    As the compiler looks at the reference type, this frees you up in the future to
    use different implementations of `List`, such as `LinkedList`.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`是由`ArrayList`类实现的一个接口。因此，`List`中的任何API方法都自动在`ArrayList`中。正如我们所知，使用接口引用（`List`）来引用对象（`ArrayList`）是良好的编码实践。由于编译器查看引用类型，这使你在未来可以使用不同的`List`实现，例如`LinkedList`。'
- en: Both `List` and `ArrayList` are in the `java.util` package. In the API, both
    are typed generically with `E` (for `Element`), which means we are free to specify
    the type we want to store in our list. Failure to follow the declared type results
    in a compiler error. We will cover generics in detail in [*Chapter 13*](B19793_13.xhtml#_idTextAnchor317).
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`List`和`ArrayList`都在`java.util`包中。在API中，两者都使用泛型`E`（代表`Element`）进行类型化，这意味着我们可以自由指定我们想要存储在列表中的类型。未能遵循声明的类型会导致编译器错误。我们将在[*第13章*](B19793_13.xhtml#_idTextAnchor317)中详细介绍泛型。'
- en: List properties
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: List属性
- en: 'A list is an ordered collection (sometimes called a sequence). We have precise
    control over where in the list an element is inserted. Indices (as with arrays)
    start at 0 and duplicate elements are allowed. The order that lists maintain is
    insertion order. In other words, if you simply add two elements, the second one
    is positioned after the first one. So, lists maintain order and allow duplicates.
    *Figure 12**.19* shows a small piece of code that captures these properties:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是有序集合（有时称为序列）。我们可以精确控制元素在列表中的插入位置。索引（与数组一样）从0开始，允许重复元素。列表保持的顺序是插入顺序。换句话说，如果你简单地添加两个元素，第二个元素将位于第一个元素之后。因此，列表保持顺序并允许重复。*图12**.19*展示了捕获这些属性的小段代码：
- en: '![   Figure 12.19 – Code demonstrating List properties](img/B19793_12_19.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![   图12.19 – 展示List属性的代码](img/B19793_12_19.jpg)'
- en: Figure 12.19 – Code demonstrating List properties
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 – 展示List属性的代码
- en: In this figure, line 11 declares a `List` reference called `list`, referring
    to an `ArrayList` object. The `List` reference is typed for strings, meaning that
    we can only add `String` objects to the list. As the list is implemented by `ArrayList`,
    the properties outlined here apply to `ArrayList` implementations also.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第11行声明了一个名为`list`的`List`引用，它引用一个`ArrayList`对象。`List`引用被类型化为字符串，这意味着我们只能向列表中添加`String`对象。由于列表是通过`ArrayList`实现的，因此这里概述的属性也适用于`ArrayList`实现。
- en: Lines 12-15 add the `J`, `A`, `V`, and `A` strings in sequence. When we output
    the list (line 17), we can see that the insertion order is maintained and that
    duplicate elements are allowed.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第12-15行按顺序添加了`J`，`A`，`V`和`A`字符串。当我们输出列表（第17行）时，我们可以看到插入顺序得到保持，并且允许重复元素。
- en: To demonstrate precise control over where elements are inserted, lines 18-19
    add `"O"` to two different locations, namely indices 1 and 3\. When we output
    the list again (line 21), we can see that the strings have been inserted into
    their correct locations.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示对元素插入位置的精确控制，第18-19行将`"O"`插入到两个不同的位置，即索引1和3。当我们再次输出列表（第21行）时，我们可以看到字符串已插入到它们正确的位置。
- en: 'Let’s look at another example showing other `List`/`ArrayList` API calls:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个示例，展示其他`List`/`ArrayList` API调用：
- en: '![   Figure 12.20 – Code demonstrating “List” and ”ArrayList”](img/B19793_12_20.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![   图12.20 – 展示“List”和”ArrayList”的代码](img/B19793_12_20.jpg)'
- en: Figure 12.20 – Code demonstrating “List” and ”ArrayList”
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 – 展示“List”和”ArrayList”的代码
- en: 'In this figure, we have several API calls and their respective output is in
    commented form on the right-hand side of each line. In this figure, our list contains
    `"Joe"`, `"Mary"`, and `"Joe"` in that order. We have the following sequence of
    API calls:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们有几个API调用及其相应的输出以注释形式显示在每行的右侧。在这个图中，我们的列表包含`"Joe"`，`"Mary"`和`"Joe"`，顺序如下。我们有以下API调用序列：
- en: '`contains(Object o)` checks if `"Mary"` is in the list. This returns `true`.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains(Object o)`检查`"Mary"`是否在列表中。这返回`true`。'
- en: '`get(int index)` returns the element at index 0, namely `"Joe"`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`get(int index)`返回索引0处的元素，即`"Joe"`。'
- en: '`indexOf(Object o)` returns the index of the first occurrence of `2`. This
    will be boxed as an `Integer` type, which “is-a” `Object`. However, as there is
    no such object in the list, `-1` is returned.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`indexOf(Object o)`返回`2`第一次出现的位置。这将作为`Integer`类型装箱，它是`Object`的子类。然而，由于列表中没有这样的对象，返回`-1`。'
- en: '`0` as this is the index of the first occurrence of `"Joe"` in the list.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`0`，因为这将是列表中`"Joe"`第一次出现的位置。'
- en: '`remove(Object o)` removes the first occurrence of the object from the list
    and returns true/false depending on whether the object was found or not. As `"Joe"`
    was present in the list, `true` is returned.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(Object o)`从列表中移除对象的第一次出现，并根据对象是否找到返回true/false。由于`"Joe"`在列表中，返回`true`。'
- en: '`"Mary"` and `"Joe"`.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Mary"`和`"Joe"`。'
- en: '`remove(int index)` removes the object at index 0, which is `"Mary"`.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remove(int index)`移除索引0处的对象，即`"Mary"`。'
- en: '`"Joe"` (the second `"Joe"`).'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"Joe"`（第二个`"Joe"`）。'
- en: '`set(int index, E element)` changes the contents of the given index to the
    object passed. Therefore, `"Paul"` is now in index `0`.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set(int index, E element)`将给定索引的内容更改为传递的对象。因此，`"Paul"`现在位于索引`0`。'
- en: '**Line 36**: This shows that line 35 operated as expected.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第36行**：这表明第35行按预期操作。'
- en: 'Now that we have discussed some of the API methods, let’s discuss some others.
    *Table 12.4* presents this information:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了一些API方法，让我们再讨论一些其他的。*表12.4*展示了这些信息：
- en: '| **Method Name** | **Description** |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| **方法名称** | **描述** |'
- en: '| `void add(int index,` `E element)` | Adds the element at the specified index
    |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `void add(int index, E element)` | 在指定索引处添加元素 |'
- en: '| `boolean` `add(E e)` | Adds the element to the end of the list |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| `boolean add(E e)` | 将元素添加到列表的末尾 |'
- en: '| `void clear()` | Removes all the elements from the list |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| `void clear()` | 从列表中移除所有元素 |'
- en: '| `boolean` `contains(Object o)` | Returns `true` if the object is in the list
    |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| `boolean contains(Object o)` | 如果对象在列表中，则返回 `true` |'
- en: '| `E` `get(int index)` | Returns the element at the specified index |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| `E get(int index)` | 返回指定索引处的元素 |'
- en: '| `boolean isEmpty()` | Returns `true` if the list is empty |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| `boolean isEmpty()` | 如果列表为空，则返回 `true` |'
- en: '| `int` `indexOf(Object o)` | Returns the index of the first occurrence of
    the specified element; its returns -1 if no such element exists in the list |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `int indexOf(Object o)` | 返回指定元素的第一个出现的索引；如果列表中不存在此类元素，则返回 -1 |'
- en: '| `E` `remove(int index)` | Removes the element at the specified index |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `E remove(int index)` | 移除指定索引处的元素 |'
- en: '| `boolean` `remove(Object o)` | Removes the first occurrence of the specified
    object |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `boolean remove(Object o)` | 移除指定的第一个对象 |'
- en: '| `E set(int index,` `E element)` | Replaces the element at the specified index
    with the given element |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `E set(int index, E element)` | 使用给定的元素替换指定索引处的元素 |'
- en: '| `int size()` | Returns the number of elements in the list |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `int size()` | 返回列表中的元素数量 |'
- en: Table 12.4 – Sample “List” and “ArrayList” API methods
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 表 12.4 – “List” 和 “ArrayList” API 方法示例
- en: That concludes this section on examining `List` and `ArrayList`. For further
    reading please see the JavaDocs at [https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html).
    Now, let’s move on to exploring the Date API.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了关于检查 `List` 和 `ArrayList` 的本节。欲了解更多信息，请参阅 Java 文档 [https://docs.oracle.com/en/java/javase/21/docs/api/index.html](https://docs.oracle.com/en/java/javase/21/docs/api/index.html)。现在，让我们继续探索日期
    API。
- en: Exploring the Date API
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索日期 API
- en: The `java.time` package was introduced in Java 8 and was designed to replace
    the previous `java.util.Date`, `java.util.Calendar`, and `java.text.DateFormat`
    classes. The classes in `java.time` represent dates, times, timezones, instants,
    periods, and durations. The ISO calendar system is followed, which is the de facto
    world calendar (following Gregorian rules). All the classes are immutable and
    thread-safe.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.time` 包是在 Java 8 中引入的，旨在取代之前的 `java.util.Date`、`java.util.Calendar` 和
    `java.text.DateFormat` 类。`java.time` 中的类代表日期、时间、时区、瞬间、期间和持续时间。遵循 ISO 日历系统，这是事实上的世界日历（遵循格里高利规则）。所有类都是不可变的且线程安全的。'
- en: It is a large API ([https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html))
    with a large number of classes for dealing with dates, with relatively fewer classes
    dealing with times. Thankfully, despite the large number of methods available,
    the consistent use of method prefixes makes this manageable. We will look at these
    API prefixes shortly. But before we do that, let’s discuss the more important
    date and time classes.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个大型 API ([https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/time/package-summary.html))，包含大量处理日期的类，而处理时间的类相对较少。幸运的是，尽管有大量方法可用，但方法前缀的一致使用使得管理变得可行。我们很快就会查看这些
    API 前缀。但在我们这样做之前，让我们讨论一下更重要的日期和时间类。
- en: Coordinated Universal Time (UTC)
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 协调世界时（UTC）
- en: UTC is the standard by which the world regulates clocks and time. It is effectively
    a successor to **Greenwich Mean Time** (**GMT**). UTC makes no adjustment for
    daylight savings time.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: UTC 是世界调节时钟和时间的标准。它实际上是格林尼治平均时间（GMT）的继任者。UTC 不对夏令时进行调整。
- en: The time zone uses UTC+/-00:00, which is sometimes denoted by the letter Z –
    a reference to the equivalent nautical time zone (GMT). Since the NATO phonetic
    alphabet word for Z is “Zulu”, UTC is sometimes referred to as “Zulu time.”
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 时区使用 UTC+/-00:00，有时用字母 Z 表示，这是对等效航海时区（GMT）的引用。由于北约语音字母表中的 Z 对应的单词是“Zulu”，因此
    UTC 有时被称为“Zulu 时间。”
- en: Dates and times
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期和时间
- en: 'There are five important classes here. Let’s examine each in turn:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有几个重要的类。让我们逐一检查：
- en: '`Instant`: An instant is a numeric timestamp. It is useful for logging and
    persistence. Historically, `System.currentTimeMillis()` would have been used.
    `System.currentTimeMillis()` returns the number of milliseconds since the “epoch
    day” (Jan 1st, 1970 at 00:00:00 UTC). The epoch is a fixed time from which all
    timestamps are calculated.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Instant`: 一个瞬间是一个数值时间戳。它对日志记录和持久化很有用。历史上，`System.currentTimeMillis()`会被使用。`System.currentTimeMillis()`返回自“纪元日”（1970年1月1日00:00:00
    UTC）以来的毫秒数。纪元是一个固定的时间点，所有时间戳都从这个时间点开始计算。'
- en: '`LocalDate`: Stores a date without a time. This is useful for representing
    birthdays such as 2000-10-21\. As it follows ISO-8601, the format is year-month-day.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDate`: 存储不带时间的日期。这对于表示生日，如2000-10-21很有用。因为它遵循ISO-8601，格式为年-月-日。'
- en: '`LocalTime`: Stores a time without a date. This is useful for representing
    opening/closing hours such as 09:00.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalTime`: 存储不带日期的时间。这对于表示营业/关闭时间，如09:00很有用。'
- en: '`LocalDateTime`: Stores a date and time such as 2000-10-21T17:00\. Note the
    “T” used as a date and time separator. This is useful for representing the date
    and time of a scheduled event, such as a concert.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LocalDateTime`: 存储日期和时间，如2000-10-21T17:00。注意用作日期和时间分隔符的“T”。这对于表示预定事件的日期和时间，如音乐会很有用。'
- en: '`ZonedDateTime`: Represents a “full” date-time with a time zone and resolved
    offset from UTC. For example, 2023-02-14T16:45+01:00[Europe/Zurich] is the date-time
    for the Europe/Zurich time zone and is 1 hour ahead of UTC.'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZonedDateTime`: 表示带有时区和从UTC解析的偏移的“完整”日期时间。例如，2023-02-14T16:45+01:00[Europe/Zurich]是欧洲/Zurich时区的日期时间，并且比UTC快1小时。'
- en: Duration and Period
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续时间和周期
- en: In addition to dates and times, the API also represents durations and periods
    of time. Let’s look at these now.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 除了日期和时间之外，该API还表示持续时间和时间周期。现在让我们来看看这些。
- en: '`Duration`: An amount of time, represented in seconds (and nanoseconds); for
    example, “54 seconds.”'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration`: 表示时间量，以秒（和纳秒）为单位；例如，“54秒。”'
- en: '`Period`: Represents an amount of time in units more meaningful to humans,
    such as years or days. For example, “3 years, 6 months, and 12 days.”'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Period`: 表示对人类更有意义的时间单位，如年或天。例如，“3年，6个月和12天。”'
- en: Additional interesting types
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他有趣类型
- en: Other types are interesting also. Let’s examine some of these now.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 其他类型也很有趣。现在让我们来检查其中的一些。
- en: '`Month`: Represents a month on its own; for example, JANUARY.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Month`: 表示一个月份；例如，JANUARY。'
- en: '`DayOfWeek`: Represents a day-of-week on its own; for example, FRIDAY.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DayOfWeek`: 表示一周中的某一天；例如，FRIDAY。'
- en: '`YearMonth`: Represents a year and month, without a day or time; for example,
    2025-12\. This could be useful for a credit card expiry date.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`YearMonth`: 表示年份和月份，没有日期或时间；例如，2025-12\. 这可能对信用卡到期日很有用。'
- en: '`MonthDay`: Represents a month and day, without a year or time; for example,
    --08-09\. This could be useful for an annual event, such as an anniversary.'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MonthDay`: 表示月份和日期，没有年份或时间；例如，--08-09。这可能对年度事件，如周年纪念很有用。'
- en: '`ZoneOffset`: Represents a time zone offset from GMT/UTC, such as +2:00.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ZoneOffset`: 表示从GMT/UTC的时间区域偏移，例如+2:00。'
- en: As stated earlier, there are a large number of methods across the classes. However,
    as the prefixes are consistently applied, this is manageable. *Table 12.5* represents
    these prefixes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，类中存在大量方法。然而，由于前缀应用一致，这还是可以管理的。*表12.5* 表示了这些前缀。
- en: '| **Method Prefix** | **Description**Note: `ld2` and so forth used in these
    examples are related. |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **方法前缀** | **描述**注意：在这些示例中使用到的`ld2`等都是相关的。|'
- en: '| --- | --- |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `of` | A static factory method for creating instances – for example,`LocalDate
    ld1 = LocalDate.of(2023,` `3, 17);` |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| `of` | 创建实例的静态工厂方法 - 例如，`LocalDate ld1 = LocalDate.of(2023,` `3, 17);` |'
- en: '| `parse` | A static factory method for creating instances – for example,`LocalDate
    ld2 =` `LocalDate.parse("2023-03-17");` |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| `parse` | 创建实例的静态工厂方法 - 例如，`LocalDate ld2 =` `LocalDate.parse("2023-03-17");`
    |'
- en: '| `get` | Gets the value of something – for example,`int dayOfMonth = ld2.getDayOfMonth();
    //` `17` |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| `get` | 获取某个值 - 例如，`int dayOfMonth = ld2.getDayOfMonth(); //` `17` |'
- en: '| `is` | Checks if something is true – for example,`boolean isLeapYear = ld2.isLeapYear();
    //` `false` |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| `is` | 检查某物是否为真 - 例如，`boolean isLeapYear = ld2.isLeapYear(); //` `false`
    |'
- en: '| `with` | The immutable equivalent of a setter method – for example,`LocalDate
    ld3 = ld2.withDayOfMonth(25); //` `2023-03-25` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| `with` | setter方法的不可变等效 - 例如，`LocalDate ld3 = ld2.withDayOfMonth(25); //`
    `2023-03-25` |'
- en: '| `plus` | Adds an amount to an object – for example,`LocalDate ld4 = ld3.plusDays(2);
    //` `2023-03-27` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| `plus` | 向对象添加一个量 - 例如，`LocalDate ld4 = ld3.plusDays(2); //` `2023-03-27`
    |'
- en: '| `minus` | Subtracts an amount from an object – for example,`LocalDate ld5
    = ld4.minusMonths(2); //` `2023-01-27` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| `minus` | 从对象中减去一个量 – 例如，`LocalDate ld5 = ld4.minusMonths(2); //` `2023-01-27`
    |'
- en: '| `at` | Combines this object with another – for example,`LocalDateTime ldt1
    = ld5.atTime(13, 45, 10); //` `2023-01-27T13:45:10` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| `at` | 将此对象与另一个对象组合 – 例如，`LocalDateTime ldt1 = ld5.atTime(13, 45, 10); //`
    `2023-01-27T13:45:10` |'
- en: Table 12.5 – Date API method prefixes
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.5 – 日期API方法前缀
- en: 'Now that we have had a look at the prefixes in the API, let’s look at some
    sample code to reinforce them. *Figure 12**.21* shows some code for manipulating
    dates and times:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经查看了一下API中的前缀，让我们看看一些示例代码来加强它们。*图12**.21*显示了用于操作日期和时间的代码：
- en: '![Figure 12.21 – Code for manipulating dates and times](img/B19793_12_21.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图12.21 – 操作日期和时间的代码](img/B19793_12_21.jpg)'
- en: Figure 12.21 – Code for manipulating dates and times
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 – 操作日期和时间的代码
- en: In this figure, line 13 creates `LocalDate` using the factory `now()` method.
    This creates a `LocalDate` object based on the system clock setting for the default
    locale. Also, using the `now()` method, lines 14-15 create `LocalTime` and `LocalDateTime`
    objects, respectively. Line 16 shows another way to create `LocalDateTime` objects
    by using the `of()` factory method to pass in both `LocalDate` and `LocalTime`
    objects. Line 17 shows the output of the `LocalDateTime` object to be `yyyy-mm-ddThh:mm:ss:nnnnnnnnn`.
    The date part comes first, then `"T"`, which separates the date from the time,
    where `n` in the time part represent nanoseconds.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第13行使用`now()`工厂方法创建`LocalDate`。这基于默认区域设置的系统时钟设置创建一个`LocalDate`对象。同时，使用`now()`方法，第14-15行分别创建`LocalTime`和`LocalDateTime`对象。第16行显示了使用`of()`工厂方法通过传入`LocalDate`和`LocalTime`对象来创建`LocalDateTime`对象的另一种方式。第17行显示了`LocalDateTime`对象的输出为`yyyy-mm-ddThh:mm:ss:nnnnnnnnn`。日期部分在前，然后是`"T"`，它将日期与时间分开，其中时间部分中的`n`代表纳秒。
- en: Next, we want to create `LocalDate` values representing St. Patrick’s Day (March
    17), 2025\. Line 20 uses the `of()` factory method and passes in numeric values
    for the year, month, and day. Note that the months start at 1 and not 0\. Thus,
    March is represented as 3.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要创建代表2025年圣帕特里克节（3月17日）的`LocalDate`值。第20行使用`of()`工厂方法，并传入年、月和日的数值。请注意，月份从1开始，而不是0。因此，三月表示为3。
- en: Line 21 uses an alternative factory method, namely `parse(String)`, which accepts
    a `String` and creates a `LocalDate` accordingly. If the string cannot be parsed,
    an exception will occur.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第21行使用了一个替代的工厂方法，即`parse(String)`，它接受一个`String`并相应地创建一个`LocalDate`。如果字符串无法解析，将发生异常。
- en: Line 22 outputs what day of the week, March 17, 2025, occurs (which is a Monday).
    Line 23 “modifies” the months, changing it from 3 to 5 (March to May). As the
    Date API types are immutable, the change is made to a new object in the background
    (`ld2` is untouched). The `ld3` reference refers to this new object (`2025-05-17`).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 第22行输出2025年3月17日是星期几（星期一）。第23行“修改”月份，将其从3改为5（三月改为五月）。由于Date API类型是不可变的，更改是在后台对新对象进行的（`ld2`保持不变）。`ld3`引用指向这个新对象（`2025-05-17`）。
- en: Line 25 adds a year, so we now have 2026-05-17\. Line 27 subtracts 5 days, so
    we now have 2026-05-12\. Lastly, on line 29, we “change” our `LocalDate` to `LocalDateTime`.
    As we already have a date, we just provided the time elements. The nanoseconds,
    which are not provided, are set to 0 and are not displayed as a result.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 第25行增加了一年，所以我们现在有2026-05-17。第27行减去5天，所以我们现在有2026-05-12。最后，在第29行，我们将我们的`LocalDate`转换为`LocalDateTime`。因为我们已经有了日期，所以我们只提供了时间元素。未提供的时间单位（纳秒）被设置为0，并且结果中不显示。
- en: 'Now, let’s look at a `ZonedDateTime` example in *Figure 12**.22*:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看*图12**.22*中的`ZonedDateTime`示例：
- en: '![Figure 12.22 – ZonedDateTime example](img/B19793_12_22.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![图12.22 – ZonedDateTime示例](img/B19793_12_22.jpg)'
- en: Figure 12.22 – ZonedDateTime example
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.22 – ZonedDateTime示例
- en: In this figure, a flight leaves Dublin for Paris at 1 PM local time. The flight
    duration is 1 hour 45 minutes. We are trying to calculate the local time in Paris
    when the flight lands. The solution presented here is one option.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，一架航班在当地时间下午1点从都柏林飞往巴黎。飞行时长为1小时45分钟。我们正在尝试计算飞机降落时在巴黎的当地时间。这里提出的解决方案是其中一个选项。
- en: Lines 34-38 create a `LocalDateTime` object for the departure date and time
    (November 24th, 2023, at 1 P.M.). Line 39 zones the date-time object using the
    `atZone()` method by passing in the relevant time zone (a `ZoneId`). To get the
    time zone `ZoneId` object, simply call the factory `of()` method while passing
    in the relevant time zone string. In this example, it is `"Europe/Dublin"`. Line
    40 shows the format of the `ZonedDateTime` object. Note `"Z"` for Zulu time (UTC).
    At that time of year, as summertime has ended, Dublin is in line with UTC.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 第34-38行创建了一个`LocalDateTime`对象，用于出发日期和时间（2023年11月24日，下午1点）。第39行使用`atZone()`方法将日期时间对象时区化，通过传递相关的时间区域（`ZoneId`）。要获取时间区域`ZoneId`对象，只需调用工厂`of()`方法，并传递相关的时间区域字符串。在这个例子中，它是`"Europe/Dublin"`。第40行显示了`ZonedDateTime`对象的格式。注意`"Z"`代表Zulu时间（UTC）。在这一年中的这个时候，由于夏令期已经结束，都柏林与UTC保持一致。
- en: Lines 42-45 represent the calculation of the local arrival time in Paris. Line
    43 calculates what time is it in Paris when the flight leaves Dublin using the
    `withZoneSameInstant()` method. Now, all we have to do is add on the flight time
    of 1 hour and 45 minutes.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 第42-45行表示在巴黎计算本地到达时间。第43行使用`withZoneSameInstant()`方法计算当航班从都柏林起飞时巴黎的时间。现在，我们只需要加上1小时45分钟的飞行时间。
- en: Line 47 shows the `ZonedDateTime` for the arrival time. The time and zoned offset
    elements are interesting. The local time allows for the fact that Paris is 1 hour
    ahead of Dublin. This time difference is reflected in the offset of `+1:00`. Thus,
    Paris is 1 hour ahead of UTC.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 第47行显示了到达时间的`ZonedDateTime`。时间和时区偏移量元素很有趣。本地时间允许巴黎比都柏林快1小时。这种时间差异反映在`+1:00`的偏移量中。因此，巴黎比UTC快1小时。
- en: 'Now, let’s look at some code that uses `Period` and `Duration`. *Figure 12**.23*
    presents an example:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一些使用`Period`和`Duration`的代码。*图12.23*展示了示例：
- en: '![Figure 12.23 – An example using Period and Duration](img/B19793_12_23.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![图12.23 – 使用Period和Duration的示例](img/B19793_12_23.jpg)'
- en: Figure 12.23 – An example using Period and Duration
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.23 – 使用Period和Duration的示例
- en: In this figure, both `Period` and `Duration` are demonstrated. `Period` is suited
    for time blocks of greater than 1 day; for example, 2 years, 5 months, and 11
    days. `Duration` is more suited to blocks of time of less than 1 day; for example,
    8 hours and 20 seconds.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，`Period`和`Duration`都得到了演示。`Period`适用于大于1天的时间块；例如，2年、5个月和11天。`Duration`更适合于小于1天的时间块；例如，8小时和20秒。
- en: Lines 57-63 calculate and output the number of years, months, and days the American
    Civil War lasted. Firstly, we create `LocalDate` objects for the start and end
    dates (lines 57-58). Line 59 creates a `Period` object using the static `Period.between()`
    method, passing in the relevant start and end dates. Line 60 outputs the period
    object, `P3Y11M28D`, which represents a `Period` of 3 years, 11 months, and 28
    days (weeks are represented in days). Lines 61-63 output the years, months, and
    days values separately.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第57-63行计算并输出美国内战持续了多少年、月和日。首先，我们创建起始和结束日期的`LocalDate`对象（第57-58行）。第59行使用静态`Period.between()`方法创建一个`Period`对象，传递相关起始和结束日期。第60行输出`Period`对象，`P3Y11M28D`，代表3年、11个月和28天（周用天数表示）。第61-63行分别输出年、月和日值。
- en: Next, we will look at `Duration`. In this case, we use two `LocalTime` objects;
    one representing 12:00:20 (line 66) and the other representing 14:45:40 (line
    67). Line 68 calculates the time difference between both and line 69 outputs the
    result. Note that there is no Y, M, or D (years, months, or days) as there was
    on line 60 (`Period`). Now, on line 69, we have a `Duration` of `PT2H45M20S` representing
    2 hours, 45 minutes, and 20 seconds.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看`Duration`。在这种情况下，我们使用两个`LocalTime`对象；一个代表12:00:20（第66行），另一个代表14:45:40（第67行）。第68行计算两者之间的时间差，第69行输出结果。注意，与第60行（`Period`）上的Y、M或D（年、月或日）不同，这里没有。现在，在第69行，我们有一个`Duration`为`PT2H45M20S`，代表2小时、45分钟和20秒。
- en: Lastly, let’s look at how to format dates and times.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看如何格式化日期和时间。
- en: Formatting dates and times
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 格式化日期和时间
- en: 'A formatter can work in both directions: formatting your temporal (time-related)
    object as a string or parsing a string into a temporal object. Both approaches
    work with formatters. This is represented by the following code from the API:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化器可以在两个方向上工作：将你的时间相关对象格式化为字符串或将字符串解析为时间对象。这两种方法都适用于格式化器。这可以通过以下API中的代码表示：
- en: '[PRE0]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will focus on how to create formatters for the `format()` method. However,
    as formatters are common to both formatting and parsing, what we say for one applies
    to the other.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将关注如何为`format()`方法创建格式化工具。然而，由于格式化工具在格式化和解析中都是通用的，所以我们所说的适用于两者。
- en: We have a lot of flexibility in how we specify the format for our dates and
    times. Firstly, there are pre-defined standard formats available for us. In addition,
    we can specify custom formats. When specifying custom formats, the letters A-Z
    and a-z are reserved and have specific semantics. Importantly, the number of format
    letters is important – for example, MMM formats the month to Aug, whereas MM produces
    08.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在指定日期和时间的格式方面有很多灵活性。首先，我们有可用的预定义标准格式。此外，我们可以指定自定义格式。在指定自定义格式时，字母A-Z和a-z是保留的，并且具有特定的语义。重要的是，格式字母的数量很重要——例如，MMM将月份格式化为Aug，而MM产生08。
- en: There are two common approaches to formatting your dates and times. One is to
    use `format(DateTimeFormatter)` in the `LocalDate`, `LocalTime`, `LocalDateTime`,
    and `ZonedDateTime` temporal classes. Its signature accepts a parameter of the
    `DateTimeFormatter` type. The other approach is to use `format(TemporalAccessor)`
    in the `DateTimeFormatter` class itself. `TemporalAccessor` is an interface that’s
    implemented by the temporal classes just mentioned.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 格式化日期和时间有两种常见的方法。一种是在`LocalDate`、`LocalTime`、`LocalDateTime`和`ZonedDateTime`时间类中使用`format(DateTimeFormatter)`。它的签名接受一个`DateTimeFormatter`类型的参数。另一种方法是在`DateTimeFormatter`类本身中使用`format(TemporalAccessor)`。`TemporalAccessor`是一个接口，由前面提到的几个时间类实现。
- en: Before we look at some example code, we must cover the more popular pre-defined
    formatters and format patterns. There are quite a few and we encourage you to
    look up the API for further details.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看一些示例代码之前，我们必须介绍更受欢迎的预定义格式化工具和格式模式。它们有很多，我们鼓励您查阅API以获取更多详细信息。
- en: Pre-defined formatters
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预定义格式化工具
- en: 'The easiest way to access these formatters is to use the constants in the `DateTimeFormatter`
    class or by calling the factory “of” methods in `DateTimeFormatter`. *Table 12.6*
    presents an overview of the more popular ones. Please see the API for further
    details. Note that **ISO** stands for **International Organization** **for Standardization**:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 访问这些格式化工具最简单的方法是使用`DateTimeFormatter`类中的常量或通过调用`DateTimeFormatter`中的“of”工厂方法。*表12.6*展示了更受欢迎的一些格式化工具的概述。请参阅API以获取更多详细信息。注意，**ISO**代表**国际标准化组织**：
- en: '| **Formatter** | **Description** | **Example** |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| **格式化工具** | **描述** | **示例** |'
- en: '| `ofLocalizedDate (dateStyle)` | Formatter with the date style from the locale
    | This depends on the style that’s passed in. An example is “Monday 10 July 2023”.
    |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '| `ofLocalizedDate (dateStyle)` | 使用地区日期样式的格式化工具 | 这取决于传入的样式。一个例子是“星期一 10七月
    2023”。 |'
- en: '| `ofLocalizedTime (timeStyle)` | Formatter with the time style from the locale
    | This depends on the style that’s passed in. An example is “15:47”. |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| `ofLocalizedTime (timeStyle)` | 使用地区时间样式的格式化工具 | 这取决于传入的样式。一个例子是“15:47”。
    |'
- en: '| `ofLocalizedDateTime (dateTimeStyle)` | Formatter with the date and time
    styles from the locale | This depends on the style that’s passed in. An example
    is“3 July 2018 09:19”. |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| `ofLocalizedDateTime (dateTimeStyle)` | 使用地区日期和时间样式的格式化工具 | 这取决于传入的样式。一个例子是“3七月
    2018 09:19”。 |'
- en: '| `ISO_DATE` | ISO date (may contain offset) | “2023-07-10”, “2023-07-10+01:00”.
    |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '| `ISO_DATE` | ISO日期（可能包含偏移） | “2023-07-10”， “2023-07-10+01:00”。 |'
- en: '| `ISO_TIME` | ISO time (may contain offset) | “15:47:13”, “15:47:13+01:00”.
    |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| `ISO_TIME` | ISO时间（可能包含偏移） | “15:47:13”， “15:47:13+01:00”。 |'
- en: '| `ISO_LOCAL_DATE` | ISO local date (no offset) | “2023-07-10”. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| `ISO_LOCAL_DATE` | ISO本地日期（无偏移） | “2023-07-10”。 |'
- en: '| `ISO_LOCAL_TIME` | ISO local time (no offset) | “16:00:03”. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| `ISO_LOCAL_TIME` | ISO本地时间（无偏移） | “16:00:03”。 |'
- en: '| `ISO_ZONED_DATE_TIME` | Zoned date time | “2023-07-12T09:33:03+01:00 [Europe/Dublin]”.
    |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| `ISO_ZONED_DATE_TIME` | 时区日期时间 | “2023-07-12T09:33:03+01:00 [Europe/Dublin]”。
    |'
- en: Table 12.6 – Date API pre-defined formatters
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.6 – 日期API预定义格式化工具
- en: Now, let’s examine some code that uses pre-defined formatters.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们检查一些使用预定义格式化工具的代码。
- en: '*Figure 12**.24* presents code that uses these pre-defined formatters:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '*图12**.24*展示了使用这些预定义格式化工具的代码：'
- en: '![Figure 12.24 – Code example using pre-defined formatters](img/B19793_12_24.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图12.24 – 使用预定义格式化工具的代码示例](img/B19793_12_24.jpg)'
- en: Figure 12.24 – Code example using pre-defined formatters
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.24 – 使用预定义格式化工具的代码示例
- en: In this figure, we represent the current date (line 74) and the current time
    (line 81) in various formats, based on the pre-defined formats available in `DateTimeFormatter`.
    First up is `ISO_DATE` (line 75). Its output (in comments on line 76) is `2023-07-10`,
    which is in yyyy-mm-dd format.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，我们根据`DateTimeFormatter`中可用的预定义格式，以各种格式表示当前日期（第74行）和当前时间（第81行）。首先是`ISO_DATE`（第75行）。其输出（在第76行的注释中）是`2023-07-10`，这是yyyy-mm-dd格式。
- en: Line 78 uses the `ofLocalizedDate()` factory method to create a format. By passing
    in the `FormatStyle.FULL` enum constant, we are requesting as much detail as possible.
    As a result, this format outputs (line 79) `Monday 10 July 2023`. As can be seen,
    this is more detailed than the `ISO_DATE` format.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 第78行使用`ofLocalizedDate()`工厂方法创建一个格式。通过传递`FormatStyle.FULL`枚举常量，我们请求尽可能多的细节。因此，这个格式输出（第79行）是`Monday
    10 July 2023`。如所见，这比`ISO_DATE`格式更详细。
- en: Line 82 creates an `ISO_TIME` formatter and applies it (line 83) to the time
    object that’s already been created (line 81). Line 85 uses the `ofLocalizedTime()`
    factory method. The `FormatStyle.SHORT` enum returns the fewest details, typically
    numeric.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 第82行创建了一个`ISO_TIME`格式化程序，并将其（第83行）应用于已经创建的时间对象（第81行）。第85行使用`ofLocalizedTime()`工厂方法。`FormatStyle.SHORT`枚举返回最少的细节，通常是数字。
- en: That covers the pre-defined formatters. Now, let’s discuss how to specify custom
    formatters.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了预定义的格式化程序。现在，让我们讨论如何指定自定义格式化程序。
- en: Custom formatters
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义格式化程序
- en: 'Custom formatters are defined using pattern letters, where the number of letters
    used is significant. Let’s discuss the most commonly used pattern letters first
    and then present some code that utilizes them. *Table 12.7* presents a summary
    of the pattern letters:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义格式化程序使用模式字母定义，使用的字母数量很重要。让我们首先讨论最常用的模式字母，然后展示一些使用它们的代码。*表12.7*展示了模式字母的总结：
- en: '| **Letter** | **Description** | **Examples** |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **字母** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| y | Year | 2023; 23 |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '| y | 年 | 2023; 23 |'
- en: '| M | Month | 8; 08; Aug; August |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '| M | 月份 | 8; 08; Aug; August |'
- en: '| d | Day of the month | 16 |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '| d | 月份中的天数 | 16 |'
- en: '| E | Day of the week | Wed; Wednesday |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| E | 星期中的天数 | Wed; Wednesday |'
- en: '| D | Day of the year | 145 |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| D | 年中的天数 | 145 |'
- en: '| h | Hour of the day; 12-hour clock (1-12) | 10 |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| h | 一天中的小时；12小时制（1-12） | 10 |'
- en: '| H | Hour of the day; 24-hour clock (0-23) | 19 |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| H | 一天中的小时；24小时制（0-23） | 19 |'
- en: '| m | Minute of the hour | 32 |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| m | 小时中的分钟 | 32 |'
- en: '| s | Second of the minute | 55 |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| s | 分钟中的秒 | 55 |'
- en: '| a | A.M. or P.M. | PM |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| a | A.M.或P.M. | PM |'
- en: '| z | Timezone | GMT |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| z | 时区 | GMT |'
- en: '| G | Era | AD |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| G | 时代 | AD |'
- en: Table 12.7 – Date API pattern letters overview
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.7 – 日期API模式字母概述
- en: 'This table is best explained with the aid of an example. *Figure 12**.25* presents
    an example that uses the pattern letters from *Table 12.7*:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表格最好通过例子来解释。*图12**.25*展示了使用*表12.7*中的模式字母的例子：
- en: '![Figure 12.25 – Code example using pattern letters](img/B19793_12_25.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图12.25 – 使用模式字母的代码示例](img/B19793_12_25.jpg)'
- en: Figure 12.25 – Code example using pattern letters
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.25 – 使用模式字母的代码示例
- en: In this figure, line 91 gets the current date and time for this timezone, which
    is **Irish Standard** **Time** (**IST**).
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个图中，第91行获取该时区的当前日期和时间，这是**爱尔兰标准时间**（**IST**）。
- en: Irish Standard Time (IST)
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 爱尔兰标准时间（IST）
- en: This is the timezone that’s used in Ireland. In Ireland, we utilize daylight
    savings time (“summertime”). This means that during the summer months, we advance
    the clocks forward 1 hour so that darkness falls at a later clock time. Therefore,
    in March, we put the clocks forward 1 hour, and in October, we put the clocks
    back 1 hour.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 这是爱尔兰使用的时区。在爱尔兰，我们使用夏令时（“夏令时”）。这意味着在夏季月份，我们将时钟向前调整1小时，以便黑暗在更晚的时钟时间降临。因此，在三月，我们将时钟向前调整1小时，而在十月，我们将时钟向后调整1小时。
- en: There is no “summertime” in UTC. Because of this and the fact that it is July
    right now, IST is +1:00 hours ahead of UTC.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: UTC中没有“夏令时”。由于这个原因，再加上现在是七月，IST比UTC快1小时。
- en: The output for line 92 is in a comment to the right. The date and time are separated,
    as usual, by “T.” The zone offset is “+1:00,” indicating that this zoned time
    is 1 hour ahead of UTC. The zone ID is “[Europe/Dublin].”
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 第92行的输出在右侧的注释中。日期和时间通常由“T.”分隔。时区偏移量为“+1:00”，表示此时区时间比UTC快1小时。时区ID是“[Europe/Dublin]”。
- en: We will first look at a date-related formatter. Line 93 creates a formatter
    using the `yy-MMM-dd E D` pattern. The output it generates is `23-Jul-11 Tue 192`
    (line 94). Thus, the current year of 2023 is output as `23` because we only provided
    `yy` in the format (as opposed to `yyyy`). Note that, had it been `yyyy` in the
    format, `2023` would have been output. This is why the number of pattern letters
    is important. The capital `M` is for the month. `M` produces `7`, `MM` produces
    `07`, `MMM` (as in the pattern) produces `Jul`, and `MMMM` produces `July`. Again,
    this demonstrates that the number of pattern letters is important.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将查看一个与日期相关的格式化器。第93行使用`yy-MMM-dd E D`模式创建了一个格式化器。它生成的输出是`23-Jul-11 Tue 192`（第94行）。因此，当前年份2023以`23`输出，因为我们只提供了格式中的`yy`（而不是`yyyy`）。注意，如果格式中是`yyyy`，则输出将是`2023`。这就是为什么模式字母的数量很重要。大写字母`M`代表月份。`M`产生`7`，`MM`产生`07`，`MMM`（如模式所示）产生`Jul`，而`MMMM`产生`July`。再次，这表明模式字母的数量很重要。
- en: The `dd` pattern outputs the day of the month. This gives us `11` for the `11th`.
    `E` gives us the day of the week, which is `Tue`. Note that `EEEE` returns `Tuesday`.
    `D` represents the day of the year; the 192nd in this example.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`dd`模式输出月份的日期。这给我们`11`，对应于`11th`。`E`给出星期几，这里是`Tue`。注意，`EEEE`返回`Tuesday`。`D`代表一年中的天数；在这个例子中是第192天。'
- en: Note that the dashes and spaces are simply inserted into the output. This is
    because, unlike letters, they are not reserved. We will learn how to insert words
    (containing letters) into the output without causing exceptions shortly.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，破折号和空格只是简单地插入到输出中。这是因为，与字母不同，它们没有被保留。我们很快就会学习如何在不引起异常的情况下将单词（包含字母）插入到输出中。
- en: Now, let’s examine a time-related formatter. Line 96 creates a formatter using
    the `hh:mm:ss a z G` pattern, which generates the output (line 97) of `09:05:50
    a.m. IST AD`. The `hh:mm:ss` pattern returns the current time in hours (12-hour
    clock), minutes, and seconds format. `a` returns whether it is A.M. or P.M. Right
    now, it is the morning, so `am` is returned. The `z` pattern letter returns the
    abbreviated zone name, `IST`. Expanding this to `zzzz` returns `Irish Standard
    Time`. Lastly, `G` returns the era, `AD` (Anno Domini).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们考察一个与时间相关的格式化器。第96行使用`hh:mm:ss a z G`模式创建了一个格式化器，它生成了（第97行）`09:05:50 a.m.
    IST AD`的输出。`hh:mm:ss`模式以小时（12小时制）、分钟和秒的格式返回当前时间。`a`返回是上午还是下午。现在，是上午，所以返回`am`。`z`模式字母返回缩写的时区名称，`IST`。将其扩展到`zzzz`返回`Irish
    Standard Time`。最后，`G`返回时代，`AD`（公元）。
- en: 'Now, let’s learn how to insert text into our formatter. As we know, the letters
    a-z and A-Z are reserved. So, how do we insert letters as regular letters and
    not pattern letters? To do this, we must surround the regular letters with single
    quotes. Line 101 specifies a pattern that uses both regular letters and pattern
    letters. The pattern is “’Year: ‘*yyyy*’. Month: ‘*MMMM*’. Day: ‘*dd*’.’”. The
    pattern letters are in italics. Any other characters are enclosed in single quotes.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，让我们学习如何将文本插入到我们的格式化器中。正如我们所知，字母a-z和A-Z是保留的。那么，我们如何将字母作为常规字母插入，而不是模式字母呢？为了做到这一点，我们必须用单引号包围常规字母。第101行指定了一个使用常规字母和模式字母的模式。模式是“`''Year:
    ‘*yyyy*’. Month: ‘*MMMM*’. Day: ‘*dd*’.’`”。模式字母是斜体的。任何其他字符都包含在单引号中。'
- en: '`Year: 2023\. Month: July. Day: 11.` is generated as output.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`Year: 2023\. Month: July. Day: 11.`被生成为输出。'
- en: 'As we can see, the year value, `2023`, is preceded by the text `"Year: "`.
    This was achieved by surrounding the text with single quotes: `''Year: ''`. Following
    the year pattern `yyyy`, the regular text `''. Month: ''` is inserted. Thus, the
    capital `M` is treated as simply a capital M, instead of a month pattern letter.
    After that, `''. Day: ''` is inserted to precede the day of the month, which is
    `11`. Lastly, a period is inserted at the end by enclosing it in single quotes
    also. Note that the period without single quotes is also fine as it is not a reserved
    character.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们所见，年份值`2023`前面是文本`"Year: "`。这是通过将文本用单引号包围来实现的：`''Year: ''`。在`yyyy`年模式之后，插入常规文本`''.
    Month: ''`。因此，大写字母`M`被简单地视为一个大写字母`M`，而不是月份模式字母。之后，插入`''. Day: ''`来在月份的日期`11`之前。最后，通过将其用单引号包围，在末尾插入一个句号。注意，没有单引号的句号也是可以的，因为它不是一个保留字符。'
- en: Lastly, let’s look at an example of parsing where we can create temporal objects
    from `String` values. Line 105 declares a string of `"2023-07-10 22:10"`. Line
    106 then declares a pattern that will be able to parse this string. The pattern
    is `"yyyy-MM-dd HH:mm"`. Note that `"HH"` represents the 24-hour clock. This will
    enable us to parse the time of `"22"` in the string.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看一个解析示例，我们可以从`String`值创建时间对象。第105行声明了一个字符串`"2023-07-10 22:10"`。第106行声明了一个可以解析这个字符串的模式。模式是`"yyyy-MM-dd
    HH:mm"`。注意，`"HH"`代表24小时制。这将使我们能够解析字符串中的`"22"`时间。
- en: Line 107 creates a `LocalDateTime` object by parsing the string according to
    the pattern provided. Line 108 outputs the `LocalDateTime` object, producing `"2023-07-10T22:10"`,
    which is what the string represents.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 第107行通过提供的模式解析字符串来创建一个`LocalDateTime`对象。第108行输出`LocalDateTime`对象，生成`"2023-07-10T22:10"`，这正是字符串所表示的。
- en: That completes our discussion on custom formatters and concludes [*Chapter 12*](B19793_12.xhtml#_idTextAnchor293).
    Now, let’s put that knowledge into practice to reinforce the concepts we’ve covered.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就完成了对自定义格式器的讨论，并结束了[*第12章*](B19793_12.xhtml#_idTextAnchor293)。现在，让我们将所学知识付诸实践，以巩固我们所学过的概念。
- en: Exercises
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'We’ve learned so many fun new things in this chapter. It’s time to enlighten
    the users of the Mesozoic Eden software with some new features that have been
    built with our new skills:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学到了许多有趣的新知识。是时候用我们新掌握的一些新功能来启发Mesozoic Eden软件的用户了：
- en: Manage the birthdays of the dinosaurs in our park. Add the `birthday` property
    to the `Dinosaur` class.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 管理我们公园中恐龙的生日。将`birthday`属性添加到`Dinosaur`类中。
- en: The park operates on a strict schedule. Create a simple system to log events
    such as feeding times, cleaning, and emergency drills in the park using the Date
    API.
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 公园按照严格的日程表运行。使用日期API创建一个简单的系统来记录公园中的事件，如喂食时间、清洁和紧急演习。
- en: In Mesozoic Eden, we have a very strong safety-first policy. Regular inspections
    help us maintain our high standards of safety. Create a program that calculates
    how many days are left until the park’s next safety inspection, based on the date
    of the last safety inspection. Safety inspections need to happen every 45 days.
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Mesozoic Eden中，我们有一个非常强的以安全为第一的政策。定期的检查帮助我们保持高标准的安全。创建一个程序，根据上次安全检查的日期计算公园下一次安全检查前还有多少天。安全检查需要每45天进行一次。
- en: We have a newborn Theropod. The guests were asked to submit names for our youngest
    inhabitant of Mesozoic Eden. 10 names were picked. Create a list for these 10
    names.
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们有一个新生的兽脚类恐龙。游客被要求为我们Mesozoic Eden最年轻的居民提交名字。选出了10个名字。为这10个名字创建一个列表。
- en: 'We want to create a string with the newborn’s full name. Use `StringBuilder`
    to append every name to its new name, and then convert it into a string when you’re
    done. (Hint: Use a loop combined with `StringBuilder`.)'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想创建一个包含新生儿的全名的字符串。使用`StringBuilder`将每个名字附加到新名字上，完成后将其转换为字符串。（提示：使用循环结合`StringBuilder`。）
- en: Project – dinosaur care system
  id: totrans-386
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目 – 恐龙护理系统
- en: We’ll continue to work on our “dinosaur care system” by adding functionality
    to log daily care activities for dinosaurs using the Java Core API. This includes
    features to accept user input, maintain a history of activities, and store dinosaur
    health data over time. Don’t worry – we’ll break this down for you step by step.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续完善我们的“恐龙护理系统”，通过使用Java核心API添加功能来记录恐龙的日常护理活动。这包括接受用户输入、维护活动历史记录以及随时间存储恐龙的健康数据。别担心——我们会一步步为您分解。
- en: '**Step 1: Add additional** **Java classes**:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '**第一步：添加额外的** **Java类**：'
- en: Create a new package named `coreapi`.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`coreapi`的新包。
- en: Inside this package, create a class named `Dinosaur`. This class should have
    properties such as name, species, health status, and so on.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这个包内部，创建一个名为`Dinosaur`的类。这个类应该具有名称、物种、健康状况等属性。
- en: Also, create a class named `Activity` with properties such as name, date, dinosaur,
    and so on.
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，创建一个名为`Activity`的类，具有名称、日期、恐龙等属性。
- en: '**Step 2: Extend the dinosaur** **care system**:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**第二步：扩展恐龙** **护理系统**：'
- en: In your `DinosaurCareSystem` class, create a `List` to hold `Dinosaur` objects,
    and another `List` to hold `Activity` objects.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的`DinosaurCareSystem`类中，创建一个`List`来保存`Dinosaur`对象，并创建另一个`List`来保存`Activity`对象。
- en: Create a method called `addDinosaur()` that takes user input to create a new
    `Dinosaur` object and add it to the list of dinosaurs.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`addDinosaur()`的方法，该方法接受用户输入以创建一个新的`Dinosaur`对象并将其添加到恐龙列表中。
- en: Create a method called `logActivity()` that also takes user input to create
    a new `Activity` object (including selecting a dinosaur from the list) and add
    it to the list of activities.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`logActivity()`的方法，该方法也接受用户输入以创建一个新的`Activity`对象（包括从列表中选择恐龙）并将其添加到活动列表中。
- en: 'Here is some sample code to get you started with this step:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些示例代码可以帮助你开始这一步：
- en: '[PRE1]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Step 3: Interact with** **the system**:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**第3步：与** **系统** **交互**：'
- en: In your main class, create a `DinosaurCareSystem` object and use a loop to continuously
    ask the user what they want to do (add a dinosaur, log activity, and so on). Use
    a `Scanner` object to get input from the user.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的主类中，创建一个`DinosaurCareSystem`对象，并使用循环不断询问用户他们想做什么（添加恐龙、记录活动等）。使用`Scanner`对象从用户那里获取输入。
- en: 'Here’s some code to get you started:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些代码可以帮助你开始：
- en: '[PRE2]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As always, feel free to expand on this and let your creativity run free!
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，你可以自由地扩展它，让你的创造力自由发挥！
- en: Summary
  id: totrans-403
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at popular classes from the Java Core API. We started
    with `Scanner`, a useful class for reading input. `Scanner` can be directed to
    read from a file, a `String` object, or the keyboard. Reading from the keyboard
    is particularly useful for dealing with user input.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Java核心API中的流行类。我们从`Scanner`类开始，这是一个用于读取输入的有用类。`Scanner`可以指向从文件、`String`对象或键盘读取。从键盘读取特别有助于处理用户输入。
- en: We examined the `String` class and its API. We saw how `String` literals use
    the string constant pool to save on memory. We examined an important property
    of `String` objects, namely immutability. A `String` object, once created, cannot
    be changed.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 我们检查了`String`类及其API。我们看到了字符串字面量如何使用字符串常量池来节省内存。我们检查了`String`对象的一个重要属性，即不可变性。一旦创建，`String`对象就不能被更改。
- en: Next, we examined `StringBuilder` and its API. We discussed that `StringBuilder`
    is a mutable type and thus, there is only ever one object in memory.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查了`StringBuilder`及其API。我们讨论了`StringBuilder`是一个可变类型，因此内存中只有一个对象。
- en: Given that `String` is immutable but `StringBuilder` is mutable, we presented
    a detailed example with both code and supporting diagrams to compare and contrast
    `String` and `StringBuilder`.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`String`是不可变的，而`StringBuilder`是可变的，我们提供了一个详细的示例，包括代码和支持图表，以比较和对比`String`和`StringBuilder`。
- en: This led to a discussion on how to create our own custom immutable types. We
    examined a checklist of steps you must perform to ensure that your class is immutable.
    We then showed an example where, very subtly, Java’s call by value principle broke
    encapsulation (and hence immutability). We discussed how to fix such an issue
    using defensive copying. Effectively, for our `private` instance mutable types,
    we had to ensure that the references passed in to initialize them were not stored
    directly; we must copy them first. In addition, we had to ensure that we did not
    return the references to our `private` instance mutable types either; we must
    copy them first also.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这引发了对如何创建我们自己的自定义不可变类型的讨论。我们检查了一个必须执行的步骤清单，以确保你的类是不可变的。然后，我们展示了一个例子，其中，非常微妙地，Java的按值调用原则破坏了封装（从而破坏了不可变性）。我们讨论了如何使用防御性复制来修复此类问题。实际上，对于我们的`private`实例可变类型，我们必须确保传递给初始化它们的引用没有被直接存储；我们必须先复制它们。此外，我们还必须确保我们不返回我们的`private`实例可变类型的引用；我们也必须先复制它们。
- en: From there we examined the `List` and `ArrayList` APIs. `List` is an interface
    and `ArrayList` is an implementation of `List`. `ArrayList` is essentially an
    expandable array. It maintains the order of insertion and allows duplicates.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们检查了`List`和`ArrayList` API。`List`是一个接口，`ArrayList`是`List`的一个实现。`ArrayList`本质上是一个可扩展的数组。它维护插入顺序并允许重复。
- en: Then, we examined the Date API, which was overhauled in Java 8\. We discussed
    `Instant`, `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`, `Period`,
    and `Duration`. All of these types are immutable, meaning we can use factory methods
    (such as `now()` and `of()`) to create instances. In a large API, the consistency
    of method prefix names is helpful.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们检查了Java 8中彻底重写的日期API。我们讨论了`Instant`、`LocalDate`、`LocalTime`、`LocalDateTime`、`ZonedDateTime`、`Period`和`Duration`。所有这些类型都是不可变的，这意味着我们可以使用工厂方法（如`now()`和`of()`）来创建实例。在一个大型API中，方法前缀名称的一致性是有帮助的。
- en: Finally, we discussed how we can format a temporal object for output and also
    how we can parse a string into a temporal object. We examined the pre-defined
    formatters available and in addition, we designed custom formatters using reserved
    pattern letters.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们讨论了如何格式化时间对象以供输出，以及如何将字符串解析为时间对象。我们检查了可用的预定义格式化程序，并且还设计了使用保留模式字母的自定义格式化程序。
- en: That completes our discussion on the Java Core API. We will move on to generics
    and collections in the next chapter.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对Java核心API的讨论。我们将继续到下一章的泛型和集合。
- en: 'Part 3: Advanced Topics'
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：高级主题
- en: In this part, we will take a look at some of the more advanced topics in Java.
    We will start with the Java Collection framework. This will include several of
    its popular interfaces and their common implementations. We will discuss sorting
    in Java and how to work with generics. We then move on to lambda expressions and
    their relationship to functional interfaces. We will look at popular functional
    interfaces from the API and also method references. We will then discuss streams
    over two chapters, both the fundamentals and advanced topics. The fundamentals
    will cover topics such as the stream pipeline, stream laziness, and terminal operations.
    The advanced chapter will discuss intermediate operations, primitive streams,
    `Optional`s, and parallel streams. Lastly, we will discuss concurrency, where
    we will explain multi-threading, data races, `ExecutorService,` and concurrent
    collections.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分，我们将探讨Java中的一些更高级的主题。我们将从Java集合框架开始。这包括其几个流行的接口及其常见实现。我们将讨论Java中的排序以及如何处理泛型。然后我们转向lambda表达式及其与函数式接口的关系。我们将查看API中的流行函数式接口以及方法引用。然后我们将讨论两章的流，包括基础和高级主题。基础部分将涵盖流管道、流惰性以及终端操作等主题。高级章节将讨论中间操作、原始流、`Optional`s以及并行流。最后，我们将讨论并发，其中我们将解释多线程、数据竞争、`ExecutorService`以及并发集合。
- en: 'This section has the following chapters:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 本节包含以下章节：
- en: '[*Chapter 13*](B19793_13.xhtml#_idTextAnchor317), *Generics and Collections*'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19793_13.xhtml#_idTextAnchor317), *泛型和集合*'
- en: '[*Chapter 14*](B19793_14.xhtml#_idTextAnchor355), *Lambda Expressions*'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19793_14.xhtml#_idTextAnchor355), *Lambda表达式*'
- en: '[*Chapter 15*](B19793_15.xhtml#_idTextAnchor377), *Streams: Fundamentals*'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19793_15.xhtml#_idTextAnchor377), *流：基础*'
- en: '[*Chapter 16*](B19793_16.xhtml#_idTextAnchor401), *Streams: Advanced Concepts*'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19793_16.xhtml#_idTextAnchor401), *流：高级概念*'
- en: '[*Chapter 17*](B19793_17.xhtml#_idTextAnchor430), *Concurrency*'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B19793_17.xhtml#_idTextAnchor430), *并发*'
