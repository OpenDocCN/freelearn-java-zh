["```java\nsealed trait State \ncase object Created extends State \ncase object Idle extends State \ncase class Copying(n: Int) extends State \ncase object Deleted extends State \n\n```", "```java\ndef inc: State = Copying(n + 1) \ndef dec: State = if (n > 1) Copying(n - 1) else Idle \n\n```", "```java\ncase class FileInfo(path: String, name: String, \n  parent: String, modified: String, isDir: Boolean, \n  size: Long, state: State) \n\n```", "```java\nclass FileSystem(val rootpath: String) { \n  val files = TMap[String, FileInfo]() \n} \n\n```", "```java\ndef init() = atomic { implicit txn => \n  files.clear() \n  val rootDir = new File(rootpath) \n  val all = TrueFileFilter.INSTANCE \n  val fileIterator = \n    FileUtils.iterateFilesAndDirs(rootDir, all, all).asScala \n  for (file <- fileIterator) { \n    val info = FileInfo(file) \n    files(info.path) = info \n  } \n} \n\n```", "```java\ndef getFileList(dir: String): Map[String, FileInfo] = \n  atomic { implicit txn => \n    files.filter(_._2.parent == dir) \n  } \n\n```", "```java\ndef copyFile(src: String, dest: String) = atomic { implicit txn => \n  val srcfile = new File(src) \n  val destfile = new File(dest) \n  val info = files(src) \n  if (files.contains(dest)) sys.error(s\"Destination exists.\") \n  info.state match { \n    case Idle | Copying(_) => \n      files(src) = info.copy(state = info.state.inc) \n      files(dest) = FileInfo.creating(destfile, info.size) \n      Txn.afterCommit { _ => copyOnDisk(srcfile, destfile) } \n      src \n  } \n} \n\n```", "```java\nprivate def copyOnDisk(srcfile: File, destfile: File) = { \n  FileUtils.copyFile(srcfile, destfile) \n  atomic { implicit txn => \n    val ninfo = files(srcfile.getPath) \n    files(srcfile.getPath) = ninfo.copy(state = ninfo.state.dec) \n    files(destfile.getPath) = FileInfo(destfile) \n  } \n} \n\n```", "```java\ndef deleteFile(srcpath: String): String = atomic { implicit txn => \n  val info = files(srcpath) \n  info.state match { \n    case Idle => \n      files(srcpath) = info.copy(state = Deleted) \n      Txn.afterCommit { _ => \n        FileUtils.forceDelete(info.toFile) \n        files.single.remove(srcpath) \n      } \n      srcpath \n  } \n} \n\n```", "```java\nobject FTPServerActor { \n  sealed trait Command \n  case class GetFileList(dir: String) extends Command \n  case class CopyFile(src: String, dest: String) extends Command \n  case class DeleteFile(path: String) extends Command \n  def apply(fs: FileSystem) = Props(classOf[FTPServerActor], fs) \n} \n\n```", "```java\nclass FTPServerActor(fileSystem: FileSystem) extends Actor { \n  val log = Logging(context.system, this) \n  def receive = { \n    case GetFileList(dir) => \n      val filesMap = fileSystem.getFileList(dir) \n      val files = filesMap.map(_._2).to[Seq] \n      sender ! files \n    case CopyFile(srcpath, destpath) => \n      Future { \n        Try(fileSystem.copyFile(srcpath, destpath)) \n      } pipeTo sender \n    case DeleteFile(path) => \n      Future { \n        Try(fileSystem.deleteFile(path)) \n      } pipeTo sender \n  } \n} \n\n```", "```java\nobject FTPServer extends App { \n  val fileSystem = new FileSystem(\".\") \n  fileSystem.init() \n  val port = args(0).toInt \n  val actorSystem = ch8.remotingSystem(\"FTPServerSystem\", port) \n  actorSystem.actorOf(FTPServerActor(fileSystem), \"server\") \n} \n\n```", "```java\nrun 12345 \n\n```", "```java\nobject FTPClientActor { \n  case class Start(host: String) \n} \n\n```", "```java\nclass FTPClientActor(implicit val timeout: Timeout) \nextends Actor \n\n```", "```java\ndef unconnected: Actor.Receive = { \n  case Start(host) => \n    val serverActorPath = \n      s\"akka.tcp://FTPServerSystem@$host/user/server\" \n    val serverActorSel = context.actorSelection(serverActorPath) \n    serverActorSel ! Identify(()) \n    context.become(connecting(sender)) \n} \n\n```", "```java\ndef connecting(clientApp: ActorRef): Actor.Receive = { \n  case ActorIdentity(_, Some(ref)) => \n    clientApp ! true \n    context.become(connected(ref)) \n  case ActorIdentity(_, None) => \n    clientApp ! false \n    context.become(unconnected) \n} \n\n```", "```java\ndef connected(serverActor: ActorRef): Actor.Receive = { \n  case command: Command => \n    (serverActor ? command).pipeTo(sender) \n} \n\n```", "```java\ndef receive = unconnected \n\n```", "```java\ntrait FTPClientApi { \n  implicit val timeout: Timeout = Timeout(4 seconds) \n  private val props = Props(classOf[FTPClientActor], timeout) \n  private val system = ch8.remotingSystem(\"FTPClientSystem\", 0) \n  private val clientActor = system.actorOf(props) \n  def host: String \n  val connected: Future[Boolean] = { \n    val f = clientActor ? FTPClientActor.Start \n    f.mapTo[Boolean] \n  } \n  def getFileList(d: String): Future[(String, Seq[FileInfo])] = { \n    val f = clientActor ? FTPServerActor.GetFileList(d) \n    f.mapTo[Seq[FileInfo]].map(fs => (d, fs)) \n  } \n  def copyFile(src: String, dest: String): Future[String] = { \n    val f = clientActor ? FTPServerActor.CopyFile(src, dest) \n    f.mapTo[Try[String]].map(_.get) \n  } \n  def deleteFile(srcpath: String): Future[String] = { \n    val f = clientActor ? FTPServerActor.DeleteFile(srcpath) \n    f.mapTo[Try[String]].map(_.get) \n  } \n} \n\n```", "```java\nabstract class FTPClientFrame extends MainFrame { \n  title = \"ScalaFTP\" \n} \n\n```", "```java\nobject menu extends MenuBar { \n  object file extends Menu(\"File\") { \n    val exit = new MenuItem(\"Exit ScalaFTP\") \n    contents += exit \n  } \n  object help extends Menu(\"Help\") { \n    val about = new MenuItem(\"About...\") \n    contents += about \n  } \n  contents += file += help \n} \n\n```", "```java\nobject status extends BorderPanel { \n  val label = new Label(\"connecting...\", null, Alignment.Left) \n  layout(new Label(\"Status: \")) = West \n  layout(label) = Center \n} \n\n```", "```java\nclass FilePane extends BorderPanel \n\n```", "```java\nobject pathBar extends BorderPanel { \n  val label = new Label(\"Path:\") \n  val filePath = new TextField(\".\") { editable = false } \n  val upButton = new Button(\"^\") \n  layout(label) = West \n  layout(filePath) = Center \n  layout(upButton) = East \n} \n\n```", "```java\nobject scrollPane extends ScrollPane { \n  val columnNames = \n    Array[AnyRef](\"Filename\", \"Size\", \"Date modified\") \n  val fileTable = new Table { \n    showGrid = true \n    model = new DefaultTableModel(columnNames, 0) { \n      override def isCellEditable(r: Int, c: Int) = false \n    } \n    selection.intervalMode = Table.IntervalMode.Single \n  } \n  contents = fileTable \n} \n\n```", "```java\nobject buttons extends GridPanel(1, 2) { \n  val copyButton = new Button(\"Copy\") \n  val deleteButton = new Button(\"Delete\") \n  contents += copyButton += deleteButton \n} \n\n```", "```java\nlayout(pathBar) = North \nlayout(scrollPane) = Center \nlayout(buttons) = South \n\n```", "```java\nvar parent: String = \".\" \nvar dirFiles: Seq[FileInfo] = Nil \ndef table = scrollPane.fileTable \ndef currentPath = pathBar.filePath.text \n\n```", "```java\nobject files extends GridPanel(1, 2) { \n  val leftPane = new FilePane \n  val rightPane = new FilePane \n  contents += leftPane += rightPane \n  def opposite(pane: FilePane) = \n    if (pane eq leftPane) rightPane else leftPane \n} \n\n```", "```java\ncontents = new BorderPanel { \n  layout(menu) = North \n  layout(files) = Center \n  layout(status) = South \n} \n\n```", "```java\ntrait FTPClientLogic { \n  self: FTPClientFrame with FTPClientApi => \n} \n\n```", "```java\ndef swing(body: =>Unit) = { \n  val r = new Runnable { def run() = body } \n  javax.swing.SwingUtilities.invokeLater(r) \n} \n\n```", "```java\nconnected.onComplete { \n  case Failure(t) => \n    swing { status.label.text = s\"Could not connect: $t\" } \n  case Success(false) => \n    swing { status.label.text = \"Could not find server.\" } \n  case Success(true) => \n    swing { \n      status.label.text = \"Connected!\" \n      refreshPane(files.leftPane) \n      refreshPane(files.rightPane) \n    } \n} \n\n```", "```java\ndef refreshPane(pane: FilePane): Unit = { \n  val dir = pane.pathBar.filePath.text \n  getFileList(dir) onComplete { \n    case Success((dir, files)) => \n      swing { updatePane(pane, dir, files) } \n    case Failure(t) => \n      swing { status.label.text = s\"Could not update pane: $t\" } \n  } \n} \n\n```", "```java\ndef updatePane(p: FilePane, dir: String, files: Seq[FileInfo]) = { \n  val table = p.scrollPane.fileTable \n  table.model match { \n    case d: DefaultTableModel => \n      d.setRowCount(0) \n      p.parent = \n        if (dir == \".\") \".\" \n        else dir.take(dir.lastIndexOf(File.separator)) \n      p.dirFiles = files.sortBy(!_.isDir) \n      for (f <- p.dirFiles) d.addRow(f.toRow) \n  } \n} \n\n```", "```java\ndef toRow = Array[AnyRef]( \n  name, if (isDir) \"\" else size / 1000 + \"kB\", modified) \n\n```", "```java\nimplicit class TableOps(val self: Table) { \n  def rowDoubleClicks = Observable[Int] { sub => \n    self.peer.addMouseListener(new MouseAdapter { \n      override def mouseClicked(e: java.awt.event.MouseEvent) { \n        if (e.getClickCount == 2) { \n          val row = self.peer.getSelectedRow \n          sub.onNext(row) \n        } \n      } \n    }) \n  } \n} \n\n```", "```java\ndef setupPane(pane: FilePane): Unit \n\n```", "```java\nval fileClicks = \n  pane.table.rowDoubleClicks.map(row => pane.dirFiles(row)) \nfileClicks.filter(_.isDir).subscribe { fileInfo => \n  pane.pathBar.filePath.text = \n    pane.pathBar.filePath.text + File.separator + fileInfo.name \n  refreshPane(pane) \n} \n\n```", "```java\npane.pathBar.upButton.clicks.subscribe { _ => \n  pane.pathBar.filePath.text = pane.parent \n  refreshPane(pane) \n} \n\n```", "```java\ndef rowActions(button: Button): Observable[FileInfo] = \n  button.clicks \n    .map(_ => pane.table.peer.getSelectedRow) \n    .filter(_ != -1) \n    .map(row => pane.dirFiles(row)) \n\n```", "```java\nrowActions(pane.buttons.copyButton) \n  .map(info => (info, files.opposite(pane).currentPath)) \n  .subscribe { t => \n    val (info, destDir) = t \n    val dest = destDir + File.separator + info.name \n    copyFile(info.path, dest) onComplete { \n      case Success(s) => \n        swing { \n          status.label.text = s\"File copied: $s\" \n          refreshPane(pane) \n        } \n    } \n  } \n\n```", "```java\nsetupPane(files.leftPane) \nsetupPane(files.rightPane) \n\n```", "```java\n> set fork := true\n> run 12345\n\n```", "```java\n> set fork := true\n> run 127.0.0.1:12345\n\n```", "```java\nsealed trait FileEvent \ncase class FileCreated(path: String) extends FileEvent \ncase class FileDeleted(path: String) extends FileEvent \ncase class FileModified(path: String) extends FileEvent \n\n```", "```java\noverride def onFileCreate(file: File) = \n  obs.onNext(FileCreated(file.getPath)) \noverride def onFileChange(file: File) = \n  obs.onNext(FileModified(file.getPath)) \noverride def onFileDelete(file: File) = \n  obs.onNext(FileDeleted(file.getPath)) \n\n```", "```java\nfileSystemEvents(\".\").subscribe { e => e match { \n    case FileCreated(path) => \n      fileSystem.files.single(path) = FileInfo(new File(path)) \n    case FileDeleted(path) => \n      fileSystem.files.single.remove(path) \n    case FileModified(path) => \n      fileSystem.files.single(path) = FileInfo(new File(path)) \n  } \n} \n\n```", "```java\n> set fork := true\n\n```", "```java\nclass Account(var money: Int) \n\ndef send(a: Account, b: Account, n: Int) = a.synchronized { \n  b.synchronized { \n    a.money -= n \n    b.money += n \n  } \n} \n\n```", "```java\nval a = new Account(1000) \nval b = new Account(2000) \nval t1 = ch2.thread { for (i <- 0 until 100) send(a, b, 1) } \nval t2 = ch2.thread { for (i <- 0 until 100) send(b, a, 1) } \nt1.join() \nt2.join() \n\n```", "```java\n$ jvisualvm\n\n```", "```java\ndef fold[T](fs: Seq[Future[T]])(z: T)(op: (T, T) => T): Future[T] \n\n```", "```java\nval fs: Seq[Future[Int]] = for (i <- 0 until 5) yield Future { i } \nval sum: Future[Int] = fold(fs)(0)(_ + _) \n\n```", "```java\nclass Accumulator[T](z: T)(op: (T, T) => T) { \n  private val value = new AtomicReference(z) \n  def apply(): T = value.get \n  @tailrec final def add(v: T): Unit = { \n    val ov = value.get \n    val nv = op(ov, v) \n    if (!value.compareAndSet(ov, nv)) add(v) \n  } \n} \n\n```", "```java\nclass CountDownLatch(n: Int)(action: =>Unit) { \n  private val left = new AtomicInteger(n) \n  def count() = \n    if (left.decrementAndGet() <= 1) action \n} \n\n```", "```java\ndef fold[T](fs: Seq[Future[T]])(z: T)(op: (T, T) => T) = { \n  val p = Promise[T]() \n  val accu = new Accumulator(z)(op) \n  val latch = new CountDownLatch(fs.length)({ \n    p.trySuccess(accu())) \n  }) \n  for (f <- fs) f foreach { case v => \n    accu.add(v) \n    latch.count() \n  } \n  p.future \n} \n\n```", "```java\nval fs = for (i <- 0 until 5) yield Future { i } \nval folded = fold(fs)(0)(_ + _) \nfolded foreach { case v => log(s\"folded: $v\") } \n\n```", "```java\nval total = accu() \nprintln(total) \np.trySuccess(total) \n\n```", "```java\n8\n10\nForkJoinPool-1-worker-1: folded: 8\n\n```", "```java\ndef count() = { \n  val v = left.decrementAndGet() \n  if (v <= 1) { \n    println(v) \n    action \n  } \n} \n\n```", "```java\n1\n0\nForkJoinPool-1-worker-15: folded: 7\n\n```", "```java\ndef count() = \n  if (left.decrementAndGet() == 0) action \n\n```", "```java\np.success(accu())) \n\n```", "```java\njava.lang.IllegalStateException: Promise already completed. \n\n```", "```java\nlibraryDependencies += \n  \"com.storm-enroute\" %% \"scalameter-core\" % \"0.6\" \n\n```", "```java\nimport org.scalameter._ \n\n```", "```java\nval time = measure { \n  val acc = new Accumulator(0)(_ + _) \n  var i = 0 \n  val total = 1000000 \n  while (i < total) { \n    acc.add(i) \n    i += 1 \n  } \n} \n\n```", "```java\nRunning time: 34.60\n\n```", "```java\nval accTime = config( \n  Key.exec.minWarmupRuns -> 20, \n  Key.exec.maxWarmupRuns -> 40, \n  Key.exec.benchRuns -> 30, \n  Key.verbose -> true \n) withWarmer(new Warmer.Default) measure { \n  val acc = new Accumulator(0L)(_ + _) \n  var i = 0 \n  val total = 1000000 \n  while (i < total) { \n    acc.add(i) \n    i += 1 \n  } \n} \nprintln(\"Accumulator time: \" + accTime) \n\n```", "```java\n18\\. warmup run running time: 17.285859\nGC detected.\n19\\. warmup run running time: 21.460975\n20\\. warmup run running time: 16.557505\n21\\. warmup run running time: 17.712535\n22\\. warmup run running time: 16.355897\nSteady-state detected.\nAccumulator time: 17.24\n\n```", "```java\nclass LongAccumulator(z: Long)(op: (Long, Long) => Long) { \n  private val value = new AtomicLong(z) \n  @tailrec final def add(v: Long): Unit = { \n    val ov = value.get \n    val nv = op(ov, v) \n    if (!value.compareAndSet(ov, nv)) add(v) \n  } \n  def apply() = value.get \n} \n\n```", "```java\nLong accumulator time: 8.88\n\n```", "```java\nval intAccTime4 = config( \n  Key.exec.minWarmupRuns -> 20, \n  Key.exec.maxWarmupRuns -> 40, \n  Key.exec.benchRuns -> 30, \n  Key.verbose -> true \n) withWarmer(new Warmer.Default) measure { \n  val acc = new LongAccumulator(0L)(_ + _) \n  val total = 1000000 \n  val p = 4 \n  val threads = for (j <- 0 until p) yield ch2.thread { \n    val start = j * total / p \n    var i = start \n    while (i < start + total / p) { \n      acc.add(i) \n      i += 1 \n    } \n  } \n  for (t <- threads) t.join() \n} \nprintln(\"4 threads integer accumulator time: \" + intAccTime4) \n\n```", "```java\n4 threads integer accumulator time: 95.85\n\n```", "```java\nimport scala.util.hashing \nclass ParLongAccumulator(z: Long)(op: (Long, Long) => Long) { \n  private val par = Runtime.getRuntime.availableProcessors * 128 \n  private val values = new AtomicLongArray(par) \n  @tailrec final def add(v: Long): Unit = { \n    val id = Thread.currentThread.getId.toInt \n    val pos = math.abs(hashing.byteswap32(id)) % par \n    val ov = values.get(pos) \n    val nv = op(ov, v) \n    if (!values.compareAndSet(pos, ov, nv)) add(v) \n  } \n  def apply(): Long = { \n    var total = z \n    for (i <- 0 until values.length) \n      total = op(total, values.get(i)) \n    total \n  } \n} \n\n```", "```java\nParallel integer accumulator time: 3.34\n\n```", "```java\n            class ConcurrentPool[T] { \n              def add(x: T): Unit = ??? \n              def remove(): T = ??? \n              def isEmpty(): Boolean = ??? \n            } \n\n    ```"]