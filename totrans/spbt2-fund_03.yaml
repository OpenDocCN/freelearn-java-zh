- en: Testing Spring Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will learn about different ways to test Spring applications.
    This section will focus on unit tests and how they are different than the other
    test types. After studying a bit of theory, you can continue to the practical
    sub-section, where you should start writing simple unit tests on their own.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Create unit tests for Spring applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create integration tests that start parts of the application internally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize the rich Spring toolset for tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze the different test types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you saw how you can create a Spring application and
    how you can add dependencies among components within the application.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will see how you can test the classes of your application
    as regular classes or with some Spring support for wiring dependencies. Writing
    these tests on your own is important so that you know what you wrote works. UI
    tests are sometimes written by a dedicated QA department.
  prefs: []
  type: TYPE_NORMAL
- en: By using these fake dependencies, you can simulate behavior of other classes
    or verify that the dependency has been called the correct way. For more information,
    especially on fake dependencies and mocking, you can have a look at Martin Fowler's
    article at [https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs](https://martinfowler.com/articles/mocksArentStubs.html#TheDifferenceBetweenMocksAndStubs).
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software development, you have multiple layers of tests that you can write.
    Unit tests are the most basic tests that test small parts of the software and
    usually run very fast. They are very important to verify that the functionality
    that you wrote works on a fundamental level.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider a method that adds two numbers, which is used in some
    ledger applications. You want to make sure that this method is able to cope with
    all sorts of errors and inputs. This can be easily tested by using unit tests.
    There is virtually no setup, and they can test a lot in a short amount of time.
    You can even test very detailed things such as integer overflows when you add
    two very big numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a testing pyramid, which highlights that the most tests should consist
    of unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/81e14f01-26d0-4107-abbe-08831a53aef0.png)'
  prefs: []
  type: TYPE_IMG
- en: Test Types – Side by Side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is no fixed definition on the testing terms, but besides unit tests,
    there are also two other types that are commonly referred to: integration tests
    and UI tests. Depending on the project, there are also test types in-between these
    three types:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following table that highlights the main concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/368a9b3a-292c-4dbd-ad8b-5a7c8b6a272b.png)'
  prefs: []
  type: TYPE_IMG
- en: When writing tests, make sure that they are reliable. Try to avoid random numbers,
    time-based assertions, and so on. Whenever possible or necessary, try to provide
    a fixed set of numbers or your own "clock" so that you can reliably test your
    code. Nothing is worse than tests that fail from time to time because of an edge
    case, for example, due to date changes or unforeseen random numbers. There are
    input generators that can provide you with random data that fits a provided set
    of requirements, but overall, I would suggest sticking to reproducible, well-known
    (and thought through) inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Unit Tests with Plain JUnits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Spring Initializr already adds the test dependencies and also creates an
    empty test class for you. We are going to show you how to write unit tests by
    testing the `BlogRepository` based on the code of *Configuration of Spring Boot
    Applications* from *[Chapter 2](f4efef8a-3e71-483b-84be-a741a3f8ff0d.xhtml): Building
    a Spring Application*. The most bare-bones way to write tests is to just use JUnit
    and test the class on its own.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to set a list of blog entries, we have to add a setter to the `BlogRepository`
    class, or we can create a constructor that we can use in the test. Alternatively,
    we can simply use constructor injection by adding the annotation `@AllArgsConstructor`
    to the `BlogRepository`. Of course, this class is very simple, and usually you
    don''t use an in-memory list as a data source, so this example is a little bit
    fabricated to show unit testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This test creates the `BlogRepository` with an `ArrayList` instance that is
    under our control. Then, we can add the `BlogEntry` and verify that it has been
    stored. We are using `assertThat()` from `AssertJ`, which is a very nice assertion
    framework that is already added as a dependency by Spring.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Unit Tests with Mockito Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, **Mockito**, a mocking framework, is also included in the dependencies,
    and it has a nice Spring integration as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just add the runner by using the `@RunWith` annotation, and then you can
    define the class you want to test as a field and mark it with the `@InjectMocks`
    annotation. All dependencies that you want to use can be added with the `@Mock`
    annotation. They will be recreated for each test and contain a mocked version
    of the class. In your test, you can define the behavior for calls by using `Mockito.when(...)`.
    You can also verify that, for example, certain calls have been made with given
    parameters. This is done using the `Mockito.verify(...)` methods. The injection
    works as it does with Spring, so when Spring is able to autowire a dependency,
    Mockito will very likely be able to as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For detailed information regarding Mockito, please check out its website at [http://site.mockito.org/](http://site.mockito.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Creating Unit Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The aim is to create small unit tests for classes. Now you are going to write
    your own unit tests for the `BlogService` class. Writing tests is very important
    to ensure that your code not only works now, but also keeps working when the project
    advances. So, in professional software development, writing unit tests and the
    other test types is very important. The steps for completion are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the IDE and the `BlogMania` application for this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41ac7889-4156-486c-a53d-17c28d2198f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Open the `BlogService` class, place the cursor on the class name, and press
    Shift-CTRL-T, which should open a menu to create the test class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select JUnit as `test-library`, select the save method in the box at the bottom,
    and press OK. IntelliJ will create and open the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Mockito annotations and fields for the service and its dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a simple test for the public methods of the `BlogService`. For example,
    check that the entry is stored, that certain methods are called on the dependencies,
    or that the output starts with a given string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All data is present and add has been called on the `BlogRepository`. The blog's
    title is missing, and you expect an `IllegalArgumentException`. You can add a
    try catch to the test method or examine the `@Test` annotation, as it has a property
    for that.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2p4Wc3C](https://bit.ly/2p4Wc3C) to access the code for
    the `BlogServiceTest.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2NDu8SQ](https://bit.ly/2NDu8SQ) to access the code for
    the `BlogmaniaApplicationTests.java` file.
  prefs: []
  type: TYPE_NORMAL
- en: Add another test that checks whether a date has been added when it's not set
    before the entry is saved by the repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, you have created your first simple unit tests for a spring class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the screenshot of your outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1a0ef137-d440-41e5-9f52-9895dd901414.png)'
  prefs: []
  type: TYPE_IMG
- en: Integration Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, you saw how you can test Spring applications using
    unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: While this is a very important way to test your application, a few things should
    be tested with more of the infrastructure of the application and maybe the surrounding
    services that are present. You might want to test whether the SQL you send to
    the database works or that your REST API generates the correct JSON format when
    all of Spring's mechanisms are in place and active.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you will create integration tests of different kinds and dip
    your toes into the test support of Spring.
  prefs: []
  type: TYPE_NORMAL
- en: JUnit has the concept of a test runner, which handles the way the tests in this
    particular class are executed. This is used by Mockito to create mocked instances
    before the tests are executed.
  prefs: []
  type: TYPE_NORMAL
- en: To make a test for a Spring integration test, you only need to add the `SpringRunner`
    as a JUnit test runner and add the `@SpringBootTest` annotation to the test class.
    This enables Spring to start the application inside the test and make it available
    for you.
  prefs: []
  type: TYPE_NORMAL
- en: The @SpringBootTest Annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Take a look at this sample code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This test starts up and only serves the purpose of checking whether you have
    made a mistake configuring Spring. The reason for this is that this only fails
    when the Spring context can't start, for example, due to missing classes or Bean
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests are usually much slower than unit tests. Try to keep the number
    of integration tests low. Don't try to test every aspect using ITs. Negative tests
    should be done as unit tests. Try to write mainly "happy-path" tests that verify
    basic functionality. When it takes too long to run all tests, they lose their
    value as a feedback mechanism during development.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Beans
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we revisit the `BlogRepositoryTest` and recreate it as an integration
    test, it would look as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we now have to verify the result of the test in the `db-bean`,
    because this way we don't have a way to verify calls on the `BlogRepository`.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we have to check whether the call had the desired effect by
    hand.
  prefs: []
  type: TYPE_NORMAL
- en: However, the advantage is that all of the mechanisms that Spring offers are
    in place. So, when there are proxies around Beans or special scopes on Beans,
    for example, you can test that using these tests. You can also test your web applications
    using these kinds of tests, but due to time constraints, this will not be covered
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a reason that Mockito is already added by Spring. We can simply mock
    Beans in a test and verify their calls or configure effects of calls on a Bean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: By marking the list with `@MockBean`, we utilize Spring's Mockito support. We
    now get the full Spring context, but this Bean has been replaced with a mocked
    version. We can configure it any way we need it for the test. This is a very handy
    feature and allows us to write tests with ease, which would have been very complex
    to write otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other annotations such as `@SpyBean`, which wrap a proxy around
    the original Bean to enable you to verify whether certain calls are made, while
    keeping the old functionality intact.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Test Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you only use the `@SpringBootTest` annotation, you will get the full Spring
    context. This may not always be what you need for your tests. In this case, you
    can configure Spring differently for your test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Go to [https://bit.ly/2NGKolQ](https://bit.ly/2NGKolQ) to access the complete
    code for the *Configuring the Test Context code example*.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are configuring two properties for the Spring context and
    we are also preventing the whole context from starting. We provide the `TestConfigClass`
    to the `@SpringBootTest` annotation, which will be used to start the application
    context. In this case, we only load Beans from the service package and provide
    our own `db-bean`, which in this case uses a `LinkedList`. If the `ComponentScan`
    adds a `db-bean` as well, then our local Bean overrides the Bean from the scan.
    As you can see, this provides you with a lot of ways to modify and monitor what
    your application code does when you test it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity: Writing Integration Tests'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Aim**'
  prefs: []
  type: TYPE_NORMAL
- en: To write integration tests for the application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scenario**'
  prefs: []
  type: TYPE_NORMAL
- en: You should reuse the project that has been used for this chapter and open it
    in the IDE.
  prefs: []
  type: TYPE_NORMAL
- en: '**Steps for Completion**'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new integration test class on your own.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aafda812-ad23-454f-9223-22efc26bd431.png)'
  prefs: []
  type: TYPE_IMG
- en: Create various tests for the method of the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a happy path test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create tests for interesting parameter combinations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fix the service code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For those of you that are advanced:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following types of tests, have a look at them, and analyze their
    advantages/disadvantages (omit the type you created in *step 2*):'
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests without Mockito
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit tests with Mockito
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests without any mocking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests with `MockBeans`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests with `SpyBeans`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Go to [https://bit.ly/2MqhUZ4](https://bit.ly/2MqhUZ4) to access the code for
    the `BlogService` test files. To refer to the detailed steps, go to the *Solutions* section
    at the end of this book on page 251.
  prefs: []
  type: TYPE_NORMAL
- en: '**Outcome**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The resulting code is in the `com/packt/springboot/blogmania/blogentries/service/activity`
    package of the source code by going to [https://bit.ly/2MqhUZ4](https://bit.ly/2MqhUZ4).
    Take a look at this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9067b68-fa64-402c-b9dc-3e3ddd9cada7.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you saw how you can test a Spring application. You have experienced
    the simplicity and the speed of unit tests and the expressiveness and power of
    integration tests.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will start looking at web application development, so
    that you can create applications that really matter.
  prefs: []
  type: TYPE_NORMAL
