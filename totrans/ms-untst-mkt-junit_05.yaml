- en: Chapter 5. Exploring Code Coverage
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章：探索代码覆盖率
- en: This chapter explains the code coverage, coverage tools, and provides step-by-step
    guidance to generate a coverage report.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了代码覆盖率、覆盖率工具，并提供了生成覆盖率报告的逐步指导。
- en: 'The following topics are covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Code, branch, and line coverage
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码、分支和行覆盖率
- en: Coverage tools such as Clover, Cobertura, EclEmma, and JaCoCo
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖率工具，如Clover、Cobertura、EclEmma和JaCoCo
- en: Measuring coverage using Eclipse plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Eclipse插件测量覆盖率
- en: Using Ant, Maven, and Gradle to generate reports
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Ant、Maven和Gradle生成报告
- en: Understanding code coverage
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解代码覆盖率
- en: '**Code coverage** is a measurement of percentage of instructions of code being
    executed while the automated tests are running.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码覆盖率**是在自动化测试运行时，代码指令被执行的百分比度量。'
- en: A piece of code with high code coverage implies that the code has been thoroughly
    unit tested and has a lower chance of containing bugs than code with a low code
    coverage. You should concentrate on writing meaningful (business logic) unit tests
    and not on having 100 percent coverage because it's easy to cheat and have 100
    percent coverage with completely useless tests.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 高代码覆盖率意味着代码已经彻底进行了单元测试，并且比低代码覆盖率代码含有更少的错误机会。你应该专注于编写有意义的（业务逻辑）单元测试，而不是追求100%的覆盖率，因为很容易通过完全无用的测试来欺骗并达到100%的覆盖率。
- en: 'Numerous metrics can be used to measure the code coverage. The following are
    the ones that are widely used:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多指标来衡量代码覆盖率。以下是一些广泛使用的指标：
- en: '**Statement or line coverage**: This measures the statements or lines being
    covered'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句或行覆盖率**：这衡量了被覆盖的语句或行'
- en: '**Branch coverage**: This measures the percentage of each branch of each control
    structure, such as the if else and switch case statements'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支覆盖率**：这衡量了每个控制结构（如if-else和switch-case语句）的每个分支的百分比'
- en: '**Function or method coverage**: This measures the function execution'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数或方法覆盖率**：这衡量了函数的执行'
- en: The following Java code will elucidate the metrics.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Java代码将阐明这些指标。
- en: 'An `absSum` method takes two integer arguments and then returns the absolute
    sum of the two arguments. An `Integer` type can hold a `NULL` value, so the method
    checks for `NULL`. If both arguments are `NULL`, then the method returns `0` as
    given in the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`absSum`方法接受两个整数参数，然后返回这两个参数的绝对和。`Integer`类型可以持有`NULL`值，因此该方法会检查`NULL`。如果两个参数都是`NULL`，则该方法返回`0`，如下面的代码所示：'
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This example has 10 branches: the first `if(op1 == null && op2 == null)` statement
    has four branches: `op1 == null`, `op1!= null`, `op2 == null`, and `op2 != null`.
    Similarly, the second `if` statement has four branches and the last `if (op2 ==
    null)` statement has two branches, `op2== null` and `op2 != null`.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例有10个分支：第一个`if(op1 == null && op2 == null)`语句有四个分支：`op1 == null`、`op1!= null`、`op2
    == null`和`op2 != null`。同样，第二个`if`语句有四个分支，最后一个`if (op2 == null)`语句有两个分支，`op2==
    null`和`op2 != null`。
- en: If a test passes two non-null integers to the `absSum` method, then it covers
    four lines, that is, three `if` statements and the final `return` statement, but
    the first three `return` statements remain uncovered. It covers three out of ten
    branches; the first `if` statement covers one out of four branches, that is, `op1
    == null`. Similarly, the second `if` statement covers one branch out of four branches,
    and the last `if` statement covers one branch out of two branches `op2 != null`.
    So, the branch coverage becomes 30 percent.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试将两个非空整数传递给`absSum`方法，则它覆盖了四行，即三个`if`语句和最后的`return`语句，但前三个`return`语句仍然未被覆盖。它覆盖了十个分支中的三个；第一个`if`语句覆盖了四个分支中的一个，即`op1
    == null`。同样，第二个`if`语句覆盖了四个分支中的一个，最后一个`if`语句覆盖了两个分支中的一个`op2 != null`。因此，分支覆盖率变为30%。
- en: 'To cover all instructions and all branches, the following four input pairs
    need to be passed to the method: `[null, null]`, `[null, value]`, `[value, null]`,
    and `[value, value]`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要覆盖所有指令和所有分支，需要将以下四个输入对传递给方法：`[null, null]`、`[null, value]`、`[value, null]`和`[value,
    value]`。
- en: Learning the inner details of code instrumentation
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学习代码插装的内部细节
- en: Coverage is measured by the ratio of basic code branches or instructions that
    were exercised by some tests to the total number of instructions or branches available
    in the system under test.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率是通过基本代码分支或指令被某些测试执行的比例来衡量的，与在测试的系统中的指令或分支总数相比。
- en: The ratio is measured in a series of steps. First, in a copy of source code,
    each block of statement is instrumented with an accumulator flag. Then, the tests
    run on the instrumented code and update the flags. Finally, a program collects
    the accumulator flags and measures the ratio of the flags turned on versus the
    total number of flags. Bytecode can be changed on the fly or during compilation.
    This is actually what test coverage frameworks do under the covers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 比率是通过一系列步骤测量的。首先，在源代码的一个副本中，每个语句块都被一个累加标志检测。然后，在检测代码上运行测试并更新标志。最后，一个程序收集累加标志并测量开启的标志与总标志数的比例。字节码可以在运行时或编译时更改。这正是测试覆盖率框架在幕后所做的事情。
- en: 'Two code instrumentation options are available: source code instrumentation
    and object code instrumentation. Object code instrumentation modifies the generated
    bytecode, so it is hard to implement.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种代码检测选项：源代码检测和对象代码检测。对象代码检测修改生成的字节码，因此很难实现。
- en: 'The preceding code coverage example has seven lines, but if we expand the branches
    into lines, then it will result in 14 lines. If a coverage tool needs to instrument
    the code, then it will modify the source code and initialize an array of length
    14 with `0` and set `1` when a line is executed while a test is being run. The
    following example demonstrates the source code instrumentation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码覆盖率示例有七行，但如果我们将分支展开成行，那么就会变成 14 行。如果一个覆盖率工具需要为代码添加检测点，那么它将修改源代码，并初始化一个长度为
    14 的数组，初始值为 `0`，当测试运行时执行一行，则将该值设置为 `1`。以下示例演示了源代码检测：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After test execution, the coverage tool checks the `visitedLines` array and
    computes the ratio of all lines that have `visitedLines[index]` equal to `1` versus
    the total number of lines. If we test the method with the input sets `[null, null]`
    and `[value, value]`, then the five lines (lines 4, 7, 8, 9, and 12) remain uncovered.
    To cover 100 percent, we need to test the method with four possible combinations
    of null and non-null integers.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 测试执行后，覆盖率工具检查 `visitedLines` 数组，并计算所有 `visitedLines[index]` 等于 `1` 的行的比例与总行数的比例。如果我们用输入集
    `[null, null]` 和 `[value, value]` 测试该方法，那么五行（第 4、7、8、9 和 12 行）仍然未被覆盖。要达到 100%
    的覆盖率，我们需要用四个可能的 null 和非 null 整数的组合来测试该方法。
- en: Configuring the Eclipse plugin
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置 Eclipse 插件
- en: 'We learned that the coverage tools can either instrument the object code or
    source code. Java code coverage tools can be categorized into two sections: tools
    that instrument the source code and tools that instrument the bytecode.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到覆盖率工具可以检测对象代码或源代码。Java 代码覆盖率工具可以分为两类：检测源代码的工具和检测字节码的工具。
- en: Source code instrumentation is easier but requires source code recompilation.
    Bytecode instrumentation is complex but doesn't require source code recompilation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码检测更容易，但需要重新编译源代码。字节码检测更复杂，但不需要重新编译源代码。
- en: 'The following are the available Java code coverage tools:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是可以用的 Java 代码覆盖率工具：
- en: '**Cobertura**: This tool instruments the bytecode offline and is a widely used
    coverage tool. Cobertura is an open source project (GNU GPL) and is very easy
    to configure with Eclipse and build tools. Version 1.9, which was released in
    March 2010, is the latest stable version.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cobertura**：这个工具在离线检测字节码，是一个广泛使用的覆盖率工具。Cobertura 是一个开源项目（GNU GPL），并且与 Eclipse
    和构建工具配置非常简单。2010 年 3 月发布的 1.9 版本是最新的稳定版本。'
- en: '**EMMA**: This tool instruments the bytecode offline or on the fly and is distributed
    under the **Common Public License** (**CPL**). Version 2.1, released in June 2005,
    is the latest version. **Google CodePro AnalytiX** is based on EMMA.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EMMA**：这个工具可以在离线或运行时检测字节码，并在 Common Public License（CPL）下分发。2005 年 6 月发布的
    2.1 版本是最新的版本。**Google CodePro AnalytiX** 基于EMMA。'
- en: '**Clover**: This tool instruments the source code and comes with a proprietary
    Atlassian license, and the latest stable version, 3.2, was released in February
    2014.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clover**：这个工具检测源代码，并附带 Atlassian 的专有许可证，最新的稳定版本 3.2 于 2014 年 2 月发布。'
- en: '**JaCoCo**: This tool is distributed under **Eclipse Public License** (**EPL**).
    JaCoCo instruments the bytecode on the fly while running the code. The latest
    stable version, 0.6.4, was released in December 2013\. JaCoCo was a replacement
    of EMMA. EclEmma is a JaCoCo-based Eclipse plugin.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JaCoCo**：这个工具在 Eclipse Public License（EPL）下分发。JaCoCo 在运行代码时动态检测字节码。最新的稳定版本，0.6.4，于
    2013 年 12 月发布。JaCoCo 是 EMMA 的替代品。EclEmma 是基于 JaCoCo 的 Eclipse 插件。'
- en: The following section will explore the Eclipse plugins based on the preceding
    Java-based coverage tools.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将探讨基于前面Java覆盖率工具的Eclipse插件。
- en: Uncovering the Clover plugin
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 揭示Clover插件
- en: A trial version of the Clover plugin can be installed for a month. You can refer
    to the installation instruction at [https://confluence.atlassian.com/display/CLOVER/](https://confluence.atlassian.com/display/CLOVER/).
    The Clover Eclipse plugin supports the site update and manual download installation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以安装Clover插件的试用版一个月。您可以在[https://confluence.atlassian.com/display/CLOVER/](https://confluence.atlassian.com/display/CLOVER/)查看安装说明。Clover
    Eclipse插件支持站点更新和手动下载安装。
- en: 'The following are the steps to install and execute the Clover plugin:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下安装和执行Clover插件的步骤：
- en: During installation, Clover shows a list of installable elements. Expand the
    **Clover** blind and select **Clover 3** and **Clover 3 Ant Support**. The following
    screenshot displays the details:![Uncovering the Clover plugin](img/00059.jpeg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在安装过程中，Clover显示可安装元素的列表。展开**Clover**选项卡，选择**Clover 3**和**Clover 3 Ant Support**。以下截图显示了详细信息：![揭示Clover插件](img/00059.jpeg)
- en: Open the **Show View** menu and select all **Clover** views. The following screenshot
    displays the **Clover** views:![Uncovering the Clover plugin](img/00060.jpeg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**显示视图**菜单，选择所有**Clover**视图。以下截图显示了**Clover**视图：![揭示Clover插件](img/00060.jpeg)
- en: Create a new Java project named `Chapter05` and add the `Metrics.java` and `MetricsTest.java`
    Java files as designed in the preceding section. Open Clover's **Coverage Explorer**
    and click on the **Enable or disable Clover on one or more project** button. The
    following screenshot shows the button details:![Uncovering the Clover plugin](img/00061.jpeg)
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter05`的新Java项目，并将`Metrics.java`和`MetricsTest.java`Java文件添加到项目中，如前所述。打开Clover的**覆盖率探索器**，点击**启用或禁用Clover在项目上**按钮。以下截图显示了按钮的详细信息：![揭示Clover插件](img/00061.jpeg)
- en: Select the `Chapter05` project. Clover will enable the source code instrumentation
    on this project. Right-click on the `MetricsTest` file and go to **Run With Clover
    As** | **JUnit Test**. The following screenshot shows the pop-up menu:![Uncovering
    the Clover plugin](img/00062.jpeg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Chapter05`项目。Clover将在此项目上启用源代码仪器化。右键单击`MetricsTest`文件，转到**使用Clover运行** |
    **JUnit测试**。以下截图显示了弹出菜单：![揭示Clover插件](img/00062.jpeg)
- en: Open **Coverage Explorer** and it will show the following coverage output:![Uncovering
    the Clover plugin](img/00063.jpeg)
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**覆盖率探索器**，它将显示以下覆盖率输出：![揭示Clover插件](img/00063.jpeg)
- en: Open **Clover Dashboard**. The dashboard will show you the coverage details,
    test results, complexity, and the least-tested methods. The following screenshot
    shows the dashboard details:![Uncovering the Clover plugin](img/00064.jpeg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Clover仪表板**。仪表板将显示覆盖率细节、测试结果、复杂性和最少测试的方法。以下截图显示了仪表板的详细信息：![揭示Clover插件](img/00064.jpeg)
- en: Open the source code. The clover plugin decorates the source code; the uncovered
    lines become red and the covered lines become green. It also shows the execution
    count against each line. The following is the instrumented source code output:![Uncovering
    the Clover plugin](img/00065.jpeg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开源代码。Clover插件装饰了源代码；未覆盖的行变成红色，覆盖的行变成绿色。它还显示每行的执行次数。以下是对仪器化源代码输出的显示：![揭示Clover插件](img/00065.jpeg)
- en: Working with the EclEmma plugin
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EclEmma插件
- en: EclEmma Version 2.0 is based on the JaCoCo code coverage library. Follow the
    instructions at [http://www.eclemma.org/index.html](http://www.eclemma.org/index.html)
    to install the EclEmma Eclipse plugin. Like Clover, EclEmma supports site update
    and its manual download.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: EclEmma版本2.0基于JaCoCo代码覆盖率库。按照[http://www.eclemma.org/index.html](http://www.eclemma.org/index.html)上的说明安装EclEmma
    Eclipse插件。与Clover一样，EclEmma支持站点更新和手动下载。
- en: 'Once EclEmma is installed, follow the steps to configure and execute tests
    using EclEmma:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了EclEmma，请按照以下步骤配置和执行测试：
- en: Right-click on the test class and go to **Coverage As** | **1 JUnit Test**.
    This will instrument the bytecode on the fly and bring up the coverage report.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击测试类，转到**覆盖率** | **1 JUnit测试**。这将即时对字节码进行仪器化，并显示覆盖率报告。
- en: After EclEmma installation, a new menu button appears under the main menu panel.
    When you expand this menu, it shows the JUnit tests that have been executed recently.
    Click on the menu button to generate the coverage report. The following screenshot
    shows the EclEmma code coverage menu button:![Working with the EclEmma plugin](img/00066.jpeg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在EclEmma安装后，主菜单面板下会出现一个新的菜单按钮。当你展开这个菜单时，它会显示最近执行过的JUnit测试。点击菜单按钮以生成覆盖率报告。以下截图显示了EclEmma代码覆盖率菜单按钮：![使用EclEmma插件](img/00066.jpeg)
- en: When you open the **Coverage** tab, it shows the coverage details. The following
    screenshot shows the output:![Working with the EclEmma plugin](img/00067.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你打开**覆盖率**标签时，它会显示覆盖率详情。以下截图显示了输出：![使用EclEmma插件](img/00067.jpeg)
- en: The branch coverage report is more prominent in EclEmma. The following screenshot
    shows the coverage details:![Working with the EclEmma plugin](img/00068.jpeg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在EclEmma中，分支覆盖率报告更为突出。以下截图显示了覆盖率详情：![使用EclEmma插件](img/00068.jpeg)
- en: A green diamond signifies that the branch is 100 percent covered, a red diamond
    signifies the branch is not covered, and a yellow diamond signifies that the branch
    is partially covered.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 绿色菱形表示分支被100%覆盖，红色菱形表示分支没有被覆盖，黄色菱形表示分支部分被覆盖。
- en: Examining the eCobertura plugin
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查eCobertura插件
- en: '**eCobertura** is a Cobertura-based Eclipse plugin. eCobertura shows the branch
    coverage in a tabular format. To install the eCobertura plugin, go to [https://marketplace.eclipse.org/content/ecobertura#.UxYBmoVh85w](https://marketplace.eclipse.org/content/ecobertura#.UxYBmoVh85w)
    and drag the **Install** button to your Eclipse workspace that is running. Eclipse
    will automatically install the plugin for you. The following screenshot shows
    the Marketplace **Install** button:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**eCobertura**是一个基于Cobertura的Eclipse插件。eCobertura以表格格式显示分支覆盖率。要安装eCobertura插件，请访问[https://marketplace.eclipse.org/content/ecobertura#.UxYBmoVh85w](https://marketplace.eclipse.org/content/ecobertura#.UxYBmoVh85w)，并将**安装**按钮拖到正在运行的Eclipse工作空间中。Eclipse将自动为你安装插件。以下截图显示了Marketplace的**安装**按钮：'
- en: '![Examining the eCobertura plugin](img/00069.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![检查eCobertura插件](img/00069.jpeg)'
- en: 'After installation, a new menu button appears under the menu panel for Cobertura,
    as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，Cobertura菜单面板下会出现一个新的菜单按钮，如下截图所示：
- en: '![Examining the eCobertura plugin](img/00070.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![检查eCobertura插件](img/00070.jpeg)'
- en: 'The following are the steps to measure code coverage using eCobertura:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 使用eCobertura测量代码覆盖率有以下步骤：
- en: Go to **Show View** | **Other,** and select the **Coverage Session View** option
    under **eCobertura**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往**显示视图** | **其他**，然后在**eCobertura**下选择**覆盖率会话视图**选项。
- en: Execute the test and then click on the Cobertura menu button, or from the dropdown,
    select the test you want to measure.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行测试然后点击Cobertura菜单按钮，或者从下拉菜单中选择你想要测量的测试。
- en: Open the **Coverage Session View** tab. This will show you the following output:![Examining
    the eCobertura plugin](img/00071.jpeg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**覆盖率会话视图**标签。这将显示以下输出：![检查eCobertura插件](img/00071.jpeg)
- en: Note that the branch coverage is 60 percent. In the preceding section, we measured
    10 branches. Using our custom coverage program, we measured that 4 out of 10 branches
    were covered. It proves that our custom code coverage program works fine.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意分支覆盖率是60%。在上一个章节中，我们测量了10个分支。使用我们的自定义覆盖率程序，我们测量出10个分支中有4个被覆盖。这证明了我们的自定义代码覆盖率程序运行良好。
- en: Measuring coverage using Gradle
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Gradle测量覆盖率
- en: Gradle can be configured to generate coverage reports using JaCoCo. This section
    will explain how to configure the Gradle JaCoCo plugin in your project.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle可以被配置为使用JaCoCo生成覆盖率报告。本节将解释如何在项目中配置Gradle JaCoCo插件。
- en: 'The following are the steps to configure the Gradle plugin:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何配置Gradle插件的步骤：
- en: Create a base folder named `Chapter05` under any directory, such as `D:/Packt`;
    then, add a `lib` folder under `Chapter05` and copy the `JUnit4` and `hamcrest`
    JARs to the `lib` folder. Add another folder named `Chapter05` under the base
    folder `Chapter05` for the Java project. As per Gradle conventions, source files
    are kept under `src/main/java` and test files are kept under `src/test/java`.
    Create the directories under `Chapter05\Chapter05`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在任何目录下创建一个名为`Chapter05`的基础文件夹，例如`D:/Packt`；然后在`Chapter05`下添加一个`lib`文件夹，并将`JUnit4`和`hamcrest`
    JAR文件复制到`lib`文件夹中。在基础文件夹`Chapter05`下添加另一个名为`Chapter05`的文件夹用于Java项目。根据Gradle约定，源文件保存在`src/main/java`下，测试文件保存在`src/test/java`下。在`Chapter05\Chapter05`下创建目录。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This `Chapter05` naming strategy is used for you to easily track the project
    and download the code from the Packt Publishing website, but your code should
    express the intent of the code. The name `Chapter05` doesn't make any sense, maybe
    you can name it something like `SimpleGradleProject` or `GradleCoverageProject`.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`Chapter05`命名策略是为了让您更容易跟踪项目并从Packt Publishing网站下载代码，但您的代码应该表达代码的意图。名称`Chapter05`没有任何意义，也许您可以将其命名为类似`SimpleGradleProject`或`GradleCoverageProject`。
- en: Copy the content of the Eclipse project and the `Metrics` and `MetricsTest`
    Java files that we created in the *Uncovering the Clover plugin* section to the
    new directory. Copy the content of the `src` folder to `src/main/java` and the
    `test` folder to `src/test/java` (as per Gradle conventions).
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Eclipse项目的内容以及我们在“揭示Clover插件”部分创建的`Metrics`和`MetricsTest` Java文件复制到新目录。按照Gradle约定，将`src`文件夹的内容复制到`src/main/java`，将`test`文件夹的内容复制到`src/test/java`。
- en: 'Create a `build.gradle` file directly under `Chapter05\Chapter05`, and add
    the following code snippet to the file to enable the JaCoCo coverage:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter05\Chapter05`下直接创建一个`build.gradle`文件，并将以下代码片段添加到文件中以启用JaCoCo覆盖率：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `jaCoCo` plugin adds a new task, `jacocoTestReport`. To execute the `jacocoTestReport`
    task, a `mavenCentral()` repository dependency needs to be added to the `repositories`
    closure. Gradle downloads the required `jaCoCo` JARs from the `mavenCentral` repository.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`jaCoCo`插件添加了一个新的任务`jacocoTestReport`。要执行`jacocoTestReport`任务，需要在`repositories`闭包中添加一个`mavenCentral()`仓库依赖项。Gradle从`mavenCentral`仓库下载所需的`jaCoCo`
    JAR文件。'
- en: Open the command prompt, go to the `Chapter05\Chapter05` directory, and run
    the `gradle jacocoTestReport` command. This will download the JAR files and generate
    the coverage report. The following screenshot shows the console output:![Measuring
    coverage using Gradle](img/00072.jpeg)
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，转到`Chapter05\Chapter05`目录，并运行`gradle jacocoTestReport`命令。这将下载JAR文件并生成覆盖率报告。以下截图显示了控制台输出：![使用Gradle测量覆盖率](img/00072.jpeg)
- en: Open `Chapter05\Chapter05\build\jacocoHtml` and launch the `index.html` file.
    The following is the JaCoCo coverage report output:![Measuring coverage using
    Gradle](img/00073.jpeg)
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Chapter05\Chapter05\build\jacocoHtml`并启动`index.html`文件。以下是JaCoCo覆盖率报告输出：![使用Gradle测量覆盖率](img/00073.jpeg)
- en: Working with the Maven Cobertura plugin
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Maven Cobertura插件
- en: Maven has a Cobertura plugin to measure code coverage; this section will explain
    how to configure the Cobertura Maven plugin in your project.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Maven有一个Cobertura插件来测量代码覆盖率；本节将解释如何配置项目中的Cobertura Maven插件。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Cobertura uses `asm` to instrument the bytecode. The `asm` framework is a Java
    bytecode manipulation and analysis framework. Visit [http://asm.ow2.org/](http://asm.ow2.org/)
    for `asm` details. Cobertura modifies the `.class` file, imports `net.sourceforge.cobertura.coveragedata.*`,
    implements the `HasBeenInstrumented` interface, and adds code to capture coverage,
    such as `ProjectData.getGlobalProjectData().getOrCreateClassData("com.packt.coverage.Metrics").touch(21);`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Cobertura使用`asm`来检测字节码。`asm`框架是一个Java字节码操作和分析框架。访问[http://asm.ow2.org/](http://asm.ow2.org/)获取`asm`的详细信息。Cobertura修改`.class`文件，导入`net.sourceforge.cobertura.coveragedata.*`，实现`HasBeenInstrumented`接口，并添加捕获覆盖率的代码，例如`ProjectData.getGlobalProjectData().getOrCreateClassData("com.packt.coverage.Metrics").touch(21);`。
- en: After instrumenting the bytecode, Cobertura creates a `.ser` file and updates
    the file during test execution. This `.ser` file contains the test coverage details.
    The instrumented bytecode can be slightly slower than normal without it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在检测字节码后，Cobertura创建一个`.ser`文件并在测试执行期间更新该文件。这个`.ser`文件包含测试覆盖率详情。没有它，检测过的字节码可能会比正常字节码稍微慢一些。
- en: 'Follow the ensuing steps to configure Maven to generate a Cobertura report:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤配置Maven以生成Cobertura报告：
- en: Create a `pom.xml` file and place it under `/Chapter05/Chapter05`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`pom.xml`文件并将其放置在`/Chapter05/Chapter05`下。
- en: 'Modify the `pom.xml` file to add the project details as follows:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`pom.xml`文件以添加项目详细信息如下：
- en: '[PRE3]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the Cobertura plugin details as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式添加Cobertura插件的详细信息：
- en: '[PRE4]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Open the command prompt, change the directory to `/Chapter05/Chapter05`, and
    issue the `mvn cobertura:cobertura` command. This will start downloading Cobertura
    plugin files and start instrumenting the `.class` files. The following screenshot
    portrays the Maven console output:![Working with the Maven Cobertura plugin](img/00074.jpeg)
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，将目录更改为`/Chapter05/Chapter05`，并执行`mvn cobertura:cobertura`命令。这将开始下载Cobertura插件文件并开始对`.class`文件进行检测。以下截图展示了Maven控制台输出：![使用Maven
    Cobertura插件](img/00074.jpeg)
- en: 'Open `/Chapter05/Chapter05/target`. The `target` folder contains the following
    important subfolders:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`/Chapter05/Chapter05/target`。`target`文件夹包含以下重要子文件夹：
- en: '`cobertura`: This contains the `cobertura.ser` file'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cobertura`: 这包含`cobertura.ser`文件'
- en: '`generated-classes`: This contains the instrumented bytecode or the `.class`
    files'
  id: totrans-90
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`generated-classes`: 这包含被检测的字节码或`.class`文件'
- en: '`site`: This contains the coverage report in XML and HTML formats'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`site`: 这包含XML和HTML格式的覆盖率报告'
- en: '`surefire-reports`: This contains the test execution report'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`surefire-reports`: 这包含测试执行报告'
- en: 'The following screenshot shows the coverage report generated in the HTML format
    in the `site` folder:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在`site`文件夹中生成的HTML格式的覆盖率报告：
- en: '![Working with the Maven Cobertura plugin](img/00075.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![使用Maven Cobertura插件工作](img/00075.jpeg)'
- en: Running the Cobertura Ant task
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行Cobertura Ant任务
- en: This section will explain how to configure the Cobertura Ant task in your project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释如何在项目中配置Cobertura Ant任务。
- en: 'The following are the steps for configuration:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为配置的步骤：
- en: Gradle and Maven can download the coverage tool JARs while running the build,
    but Ant needs the Cobertura JAR files to the classpath. Download the Cobertura
    ZIP file from [http://cobertura.github.io/cobertura/](http://cobertura.github.io/cobertura/).
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Gradle和Maven可以在构建过程中下载覆盖率工具JAR文件，但Ant需要将Cobertura JAR文件添加到类路径。从[http://cobertura.github.io/cobertura/](http://cobertura.github.io/cobertura/)下载Cobertura
    ZIP文件。
- en: Extract the ZIP file and copy all JAR files in the downloaded ZIP to `Chapter05\lib`.
    Include all JARs from the `lib` folder and `cobertura.jar` from the `root` folder.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提取ZIP文件，并将下载的ZIP文件中的所有JAR文件复制到`Chapter05\lib`。包括`lib`文件夹中的所有JAR文件以及`root`文件夹中的`cobertura.jar`。
- en: 'Create a `build.properties` file under `Chapter05\Chapter05` and enter the
    following information:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter05\Chapter05`下创建一个`build.properties`文件，并输入以下信息：
- en: '[PRE5]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `src.dir` attribute represents the source folder location and `test.dir`
    represents the test file location. The `cobertura.dir` attribute refers to the
    Cobertura library or JAR files. The coverage tool needs to access the Cobertura
    library files. The other entries are required for report generation and bytecode
    instrumentation.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`src.dir`属性表示源文件夹位置，`test.dir`表示测试文件位置。`cobertura.dir`属性指的是Cobertura库或JAR文件。覆盖率工具需要访问Cobertura库文件。其他条目是用于报告生成和字节码检测所必需的。'
- en: Create a `build.xml` file under `Chapter05\Chapter05`, and add targets for Cobertura
    instrumentation and JUnit test to update the `.ser` file and generate the report.
    Download the `build.xml` file from the Packt Publishing website (the `Chapter05`
    code). The important targets are `init`, `compile`, `testcompile`, `instrument`,
    `test`, `coverage-report`, `summary-coverage-report`, `alternate-coverage-report`,
    and `clean`.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Chapter05\Chapter05`下创建一个`build.xml`文件，并添加Cobertura检测和JUnit测试的目标以更新`.ser`文件并生成报告。从Packt
    Publishing网站（`Chapter05`代码）下载`build.xml`文件。重要目标包括`init`、`compile`、`testcompile`、`instrument`、`test`、`coverage-report`、`summary-coverage-report`、`alternate-coverage-report`和`clean`。
- en: Open the command prompt, change the directory to `Chapter05\Chapter05`, and
    issue the `ant` command. This will generate the report. The following is the console
    output of the command:![Running the Cobertura Ant task](img/00076.jpeg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符，将目录更改为`Chapter05\Chapter05`，并执行`ant`命令。这将生成报告。以下是该命令的控制台输出：![运行Cobertura
    Ant任务](img/00076.jpeg)
- en: Cobertura generates the report in `Chapter05\Chapter05\reports`. The `reports`
    folder contains various reports in XML and HTML formats.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Cobertura在`Chapter05\Chapter05\reports`中生成报告。`reports`文件夹包含各种XML和HTML格式的报告。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Code coverage is not a silver bullet that can deliver zero-defect software!
    The most important thing is writing effective tests and unit testing the logic.
    Writing tests for getters and setters or constructor doesn't add value.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 代码覆盖率并不是一个能够提供零缺陷软件的银弹！最重要的是编写有效的测试和单元测试逻辑。为getter和setter或构造函数编写测试并不增加价值。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, code coverage is described in depth and examples are provided
    to measure code coverage using Eclipse plugins and various coverage tools, such
    as Clover, JaCoCo, EclEmma, and Cobertura. We have also configured Ant, Maven,
    and Gradle to generate code coverage reports using coverage tools.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入介绍代码覆盖率，并提供使用Eclipse插件和各种覆盖率工具（如Clover、JaCoCo、EclEmma和Cobertura）来测量代码覆盖率的示例。我们还已配置Ant、Maven和Gradle，使用覆盖率工具生成代码覆盖率报告。
- en: By the end of this chapter, you should be able configure Eclipse plugins and
    build scripts to measure code coverage.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你应该能够配置Eclipse插件和构建脚本来测量代码覆盖率。
- en: The next chapter covers the static code analysis, code metrics, and various
    open source tools. It configures and uses PMD, Checkstyle, and FindBugs to analyze
    code quality and explores the Sonar code quality dashboard.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章涵盖了静态代码分析、代码指标以及各种开源工具。它配置并使用 PMD、Checkstyle 和 FindBugs 来分析代码质量，并探索 Sonar
    代码质量仪表板。
