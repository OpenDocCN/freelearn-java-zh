<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Database Access and the Future of ORM"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Database Access and the Future of ORM</h1></div></div></div><p>An essential component found in almost any web application involves the storage and retrieval of data in a persistent store. Whether relational or NoSQL based, a database often occupies the most important place since it holds the application data. When a technology stack becomes a legacy and needs to be refactored or ported to a new one, the database is usually the starting point since it holds the domain knowledge.</p><p>In this chapter, we are first going to study how to integrate and reuse persistence frameworks inherited from Java that deal with <span class="strong"><strong>Object Relational Mapping</strong></span> (<span class="strong"><strong>ORM</strong></span>) such as those supporting <span class="strong"><strong>Java Persistence API</strong></span> (<span class="strong"><strong>JPA</strong></span>), for example, Hibernate and EclipseLink. We will then experiment with the default persistence framework available in the <a id="id297" class="indexterm"/>Play Framework, Anorm. Finally, we will introduce and discover a Scala alternative to ORM and a rather novel approach that adds type safety and composition to the more traditional SQL-based queries, the Slick framework. We will experiment with Slick in the context of Play web development. We will also cover the generation of CRUD-like applications out of existing relational databases that can be a boost in productivity when starting out from a legacy database.</p><div class="section" title="Integrating an existing ORM – Hibernate and JPA"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec34"/>Integrating an existing ORM – Hibernate and JPA</h1></div></div></div><p>As defined by Wikipedia:</p><div class="blockquote"><blockquote class="blockquote"><p>"Object-relational mapping (ORM, O/RM, and O/R mapping) in computer software is a programming technique for converting data between incompatible type systems in object-oriented programming languages".</p></blockquote></div><p>The popular adoption of ORM <a id="id298" class="indexterm"/>frameworks in Java such as Hibernate is largely due to the simplicity and diminution of code you need to write to persist and query data.</p><div class="section" title="Making JPA available in Scala"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec43"/>Making JPA available in Scala</h2></div></div></div><p>Although Scala has its own modern <a id="id299" class="indexterm"/>standard for data persistence (that is, Slick, which we will introduce later on), in this section, we will cover a possible integration of <a id="id300" class="indexterm"/>JPA (Java Persistence API, documented at <a class="ulink" href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html">http://docs.oracle.com/javaee/6/tutorial/doc/bnbpz.html</a>) within the Scala world by building an SBT project that <a id="id301" class="indexterm"/>uses JPA-annotated Scala classes to persist data in a relational database. It is derived from an online sample available at <a class="ulink" href="http://www.brainoverload.nl/scala/105/jpa-with-scala">http://www.brainoverload.nl/scala/105/jpa-with-scala</a>, which should be particularly interesting to Java developers since it illustrates how to use the Spring framework both for dependency injection and configuration of beans in the context of a Scala project at the same time. As a reminder, the Spring framework, created by Rod Johnson, came out in 2002 as a way to provide inversion of control, that is, dependency injection increased in popularity to become a full-featured framework now containing many aspects of Java EE 7. More <a id="id302" class="indexterm"/>information about Spring is available at <a class="ulink" href="http://projects.spring.io/spring-framework/">http://projects.spring.io/spring-framework/</a>.</p><p>We are going to connect to the already existing CustomerDB sample database that we have introduced in <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration</em></span>, to show both how to read existing data and create new entities/tables to persist data.</p><p>As we have seen in <a class="link" href="ch03.html" title="Chapter 3. Understanding the Scala Ecosystem">Chapter 3</a>, <span class="emphasis"><em>Understanding the Scala Ecosystem</em></span>, creating a blank Scala SBT project is a matter of opening a command terminal, creating a directory to put the project in, and running SBT as follows:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; mkdir sbtjpasample</strong></span>
<span class="strong"><strong>&gt; cd sbtjpasample</strong></span>
<span class="strong"><strong>&gt; sbt</strong></span>
<span class="strong"><strong>&gt; set name:="sbtjpasample"</strong></span>
<span class="strong"><strong>&gt; session save</strong></span>
</pre></div><p>We can navigate to the <code class="literal">project/</code> folder that SBT created, and add a <code class="literal">plugins.sbt</code> file containing the following one-liner to import the <code class="literal">sbteclipse</code> plugin so that we can work with the project under the Eclipse IDE:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>addSbtPlugin("com.typesafe.sbteclipse" % "sbteclipse-plugin" % "2.4.0")</strong></span>
</pre></div><p>Since we are going to use Hibernate- and Spring-related classes, we need to include such dependencies into our <code class="literal">build.sbt</code> build file (as well as the derby-client driver to connect to the <code class="literal">CustomerDB sample</code> database) so that it looks like the following code snippet:</p><div class="informalexample"><pre class="programlisting">name:="sbtjpasample"

scalaVersion:="2.10.3"

libraryDependencies ++= Seq(
   "junit" % "junit" % "4.11",
   "org.hibernate" % "hibernate-core" % "3.5.6-Final",
   "org.hibernate" % "hibernate-entitymanager" % "3.5.6-Final",
   "org.springframework" % "spring-core" % "4.0.0.RELEASE",
   "org.springframework" % "spring-context" % "4.0.0.RELEASE",
   "org.springframework" % "spring-beans" % "4.0.0.RELEASE",
   "org.springframework" % "spring-tx" % "4.0.0.RELEASE",
   "org.springframework" % "spring-jdbc" % "4.0.0.RELEASE",
   "org.springframework" % "spring-orm" % "4.0.0.RELEASE", 
   "org.slf4j" % "slf4j-simple" % "1.6.4",
   "org.apache.derby" % "derbyclient" % "10.8.1.2",
   "org.scalatest" % "scalatest_2.10" % "2.0.M7"
)</pre></div><p>As a reminder to make these dependencies available in Eclipse, we have to run the <code class="literal">&gt; sbt eclipse</code> command again and refresh our project in the IDE.</p><p>Now, from the root directory of the <a id="id303" class="indexterm"/>project, enter <code class="literal">&gt; sbt eclipse</code> and import the project into the IDE.</p><p>Now let's add a couple of domain entities (under a new package <code class="literal">se.sfjd</code>) that we want to annotate with Java-based JPA annotations. The <code class="literal">Customer</code> entity defined in a <code class="literal">Customer.scala</code> file in the <code class="literal">se.sfjd</code> package will map (at least partially) to the existing <code class="literal">CUSTOMER</code> database table:</p><div class="informalexample"><pre class="programlisting">import javax.persistence._
import scala.reflect.BeanProperty
 
@Entity
@Table(name = "customer")
class Customer(n: String) {
 
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "CUSTOMER_ID")
    @BeanProperty
    var id: Int = _
 
    @BeanProperty
    @Column(name = "NAME")
    var name: String = n
 
    def this() = this (null)
 
    override def toString = id + " = " + name
}</pre></div><p>Notice the underscore (_) representing a default value when declaring <code class="literal">var id: Int = _</code>. The default value will be set according to <a id="id304" class="indexterm"/>the type <code class="literal">T</code> of a variable, as defined by the Scala specification:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">0</code> if <code class="literal">T</code> is <code class="literal">Int</code> or one of its subrange types</li><li class="listitem" style="list-style-type: disc"><code class="literal">0L</code> if <code class="literal">T</code> is <code class="literal">Long</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">0.0f</code> if <code class="literal">T</code> is <code class="literal">Float</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">0.0d</code> if <code class="literal">T</code> is <code class="literal">Double</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">false</code> if <code class="literal">T</code> is <code class="literal">Boolean</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">()</code> if <code class="literal">T</code> is <code class="literal">Unit</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">null</code> for all other types of <code class="literal">T</code></li></ul></div><p>The <code class="literal">Language</code> entity <a id="id305" class="indexterm"/>corresponds to the addition of a new concept we want to persist and therefore requires a new database table, as follows:</p><div class="informalexample"><pre class="programlisting">@Entity
@Table(name = "language")
class Language(l: String) {
 
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "ID")
    @BeanProperty
    var id: Int = _
 
    @BeanProperty
    @Column(name = "NAME")
    var name: String = l
 
    def this() = this (null)
 
    override def toString = id + " = " + name
}</pre></div><p>As we saw in <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration</em></span>, the <code class="literal">@BeanProperty</code> annotation is a way to generate getters and setters conforming to Java, and the <code class="literal">this()</code> method is a no argument constructor needed by Hibernate.</p><p>Moving on, the controller <a id="id306" class="indexterm"/>class or <span class="strong"><strong>DAO</strong></span> (<span class="strong"><strong>Data Access Object</strong></span>) class captures the behavior we want to provide for the <code class="literal">Customer</code> entity such as CRUD functionality in the form of <code class="literal">save</code> and <code class="literal">find</code> methods following an interface, or in this case, a Scala trait:</p><div class="informalexample"><pre class="programlisting">trait CustomerDao {
    def save(customer: Customer): Unit
    def find(id: Int): Option[Customer]
    def getAll: List[Customer]
}</pre></div><p>The implementation of the <code class="literal">CustomerDao</code> class relies on the methods of the JPA entity manager that we as Java developers are <a id="id307" class="indexterm"/>probably familiar with:</p><div class="informalexample"><pre class="programlisting">import org.springframework.beans.factory.annotation._
import org.springframework.stereotype._
import org.springframework.transaction.annotation.{Propagation, Transactional}
import javax.persistence._
import scala.collection.JavaConversions._
 
@Repository("customerDao")
@Transactional(readOnly = false, propagation = Propagation.REQUIRED)
class CustomerDaoImpl extends CustomerDao {
 
    @Autowired
    var entityManager: EntityManager = _
 
    def save(customer: Customer):Unit = customer.id match{
        case 0 =&gt; entityManager.persist(customer)
        case _ =&gt; entityManager.merge(customer)
    }
 
    def find(id: Int): Option[Customer] = {
        Option(entityManager.find(classOf[Customer], id))
    }
 
    def getAll: List[Customer] = {
        entityManager.createQuery("FROM Customer", classOf[Customer]).getResultList.toList
    }
}</pre></div><p>In a similar manner, we can define a <code class="literal">Language</code> trait and its implementation as follows, with the addition of a <a id="id308" class="indexterm"/>
<code class="literal">getByName</code> <a id="id309" class="indexterm"/>method:</p><div class="informalexample"><pre class="programlisting">trait LanguageDao {
    def save(language: Language): Unit
    def find(id: Int): Option[Language]
    def getAll: List[Language]
    def getByName(name : String): List[Language]
}

@Repository("languageDao")
@Transactional(readOnly = false, propagation = Propagation.REQUIRED)
class LanguageDaoImpl extends LanguageDao {
 
  @Autowired
  var entityManager: EntityManager = _
 
  def save(language: Language): Unit = language.id match {
    case 0 =&gt; entityManager.persist(language)
    case _ =&gt; entityManager.merge(language)
  }
 
  def find(id: Int): Option[Language] = {
    Option(entityManager.find(classOf[Language], id))
  }
 
  def getAll: List[Language] = {
    entityManager.createQuery("FROM Language", classOf[Language]).getResultList.toList
  }
 
  def getByName(name : String): List[Language] = {
    entityManager.createQuery("FROM Language WHERE name = :name", classOf[Language]).setParameter("name", name).getResultList.toList
  }
}</pre></div><p>Before we can execute the project, we still have a couple of steps to follow: first we need a test class, we can therefore create a <code class="literal">CustomerTest</code> class following the <code class="literal">ScalaTest</code> syntax, as we have seen earlier in <a class="link" href="ch04.html" title="Chapter 4. Testing Tools">Chapter 4</a>, <span class="emphasis"><em>Testing Tools</em></span>:</p><div class="informalexample"><pre class="programlisting">import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner
import org.scalatest.FunSuite
import org.springframework.context.support.
lassPathXmlApplicationContext

@RunWith(classOf[JUnitRunner])
class CustomerTest extends FunSuite {
  
  val ctx = new ClassPathXmlApplicationContext("application-context.xml")
  
  test("There are 13 Customers in the derby DB") {
    
    val customerDao = ctx.getBean(classOf[CustomerDao])
    val customers = customerDao.getAll
    assert(customers.size === 13)
    println(customerDao
      .find(3)
      .getOrElse("No customer found with id 3")) 
  }
    
  test("Persisting 3 new languages") {
    val languageDao = ctx.getBean(classOf[LanguageDao])
    languageDao.save(new Language("English"))
    languageDao.save(new Language("French"))
    languageDao.save(new Language("Swedish"))
    val languages = languageDao.getAll
    assert(languages.size === 3) 
    assert(languageDao.getByName("French").size ===1) 
  }
}</pre></div><p>Last but not least, we have to <a id="id310" class="indexterm"/>define some configuration, both a <code class="literal">META-INF/persistence.xml</code> file required by JPA that we can put under <code class="literal">src/main/resources/</code> and a Spring <code class="literal">application-context.xml</code> where all beans are wired and the database connection is defined. The <code class="literal">persistence.xml</code> file will look as simple as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;persistence version="2.0"  
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"&gt;
 
    &lt;persistence-unit name="JpaScala" transaction-type="RESOURCE_LOCAL"&gt;
        &lt;provider&gt;org.hibernate.ejb.HibernatePersistence&lt;/provider&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;</pre></div><p>The <code class="literal">application-context.xml</code> file, directly available under <code class="literal">src/main/resources/</code>, is a bit more elaborate and is given as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans 
       
       
        
       xsi:schemaLocation="
            http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
        "&gt;
 
    &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;
 
    &lt;context:component-scan base-package="se.sfjd"/&gt;
 
    &lt;bean id="dataSource"
          class="org.springframework.jdbc.datasource.DriverManagerDataSource"
          p:driverClassName="org.apache.derby.jdbc.ClientDriver" p:url="jdbc:derby://localhost:1527/sample"
          p:username="app" p:password="app"/&gt;
          
    &lt;bean id="entityManagerFactory"
          class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"&gt;
        &lt;property name="persistenceUnitName" value="JpaScala"/&gt;
        &lt;property name="persistenceProviderClass" value="org.hibernate.ejb.HibernatePersistence"/&gt;
        &lt;property name="jpaDialect"&gt;
            &lt;bean class="org.springframework.orm.jpa.vendor.HibernateJpaDialect"/&gt;
        &lt;/property&gt;
 
        &lt;property name="dataSource" ref="dataSource"/&gt;
        &lt;property name="jpaPropertyMap"&gt;
            &lt;map&gt;
                &lt;entry key="hibernate.dialect" value="org.hibernate.dialect.DerbyDialect"/&gt;
                &lt;entry key="hibernate.connection.charSet" value="UTF-8"/&gt;
                &lt;entry key="hibernate.hbm2ddl.auto" value="update"/&gt;
                &lt;entry key="hibernate.show.sql" value="true"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
 
    &lt;bean id="entityManager"
          class="org.springframework.orm.jpa.support.SharedEntityManagerBean"&gt;
        &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
    &lt;/bean&gt;
 
    &lt;bean id="transactionManager" class="org.springframework.orm.jpa.JpaTransactionManager"&gt;
        &lt;property name="entityManagerFactory" ref="entityManagerFactory"/&gt;
        &lt;property name="dataSource" ref="dataSource"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</pre></div><p>Before running the test, we need to make sure the database server is up and running; this was explained in <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration,</em></span> while using the NetBeans IDE.</p><p>Now we can execute the <a id="id311" class="indexterm"/>example either by right-clicking on the <code class="literal">CustomerTest</code> class <a id="id312" class="indexterm"/>and navigating to <span class="strong"><strong>Debug As</strong></span> | <span class="strong"><strong>Scala JUnit Test</strong></span> or from the command prompt by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; sbt test</strong></span>
<span class="strong"><strong>3 = Nano Apple</strong></span>
<span class="strong"><strong>[info] CustomerTest:</strong></span>
<span class="strong"><strong>[info] - There are 13 Customers in the derby DB</strong></span>
<span class="strong"><strong>[info] - Persisting 3 new languages</strong></span>
<span class="strong"><strong>[info] Passed: : Total 2, Failed 0, Errors 0, Passed 2, Skipped 0</strong></span>
<span class="strong"><strong>[success] Total time: 3 s</strong></span>
</pre></div></div></div></div>
<div class="section" title="Dealing with persistence in the Play Framework"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Dealing with persistence in the Play Framework</h1></div></div></div><p>The Play Framework can be <a id="id313" class="indexterm"/>run with any sort of ORM, whether it is Java based such as JPA or Scala specific. There are related-but-separate Java and Scala flavors of the framework. As described in the Play documentation, the Java version uses Ebean as its ORM, whereas the Scala alternative does not use ORM but runs with Anorm, a Scala-ish abstraction layer on top of JDBC that interacts with a database using plain SQL.</p><div class="section" title="A simple example using Anorm"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec44"/>A simple example using Anorm</h2></div></div></div><p>To illustrate the usage of <a id="id314" class="indexterm"/>Anorm, we are going to make a small Play example that connects to the existing <code class="literal">CustomerDB</code> database from the NetBeans distribution that <a id="id315" class="indexterm"/>we have used in the previous section and introduced in <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration</em></span>.</p><p>The most straightforward way to start is to create a default Play Scala project from a terminal window by entering the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play new anormsample</strong></span>
</pre></div><p>Once created and imported into Eclipse (after creating Eclipse-related files once again using the <code class="literal">&gt; play eclipse</code> command; refer to <a class="link" href="ch05.html" title="Chapter 5. Getting Started with the Play Framework">Chapter 5</a>, <span class="emphasis"><em>Getting Started with the Play Framework</em></span>, if you need more details) we can see that the dependency to Anorm is already part of the <code class="literal">built.sbt</code> file. However, we need to add the dependency to the <code class="literal">derby-client</code> database driver to this file to be able to communicate with the database through jdbc. The dependency can be added as follows:</p><div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq(
  jdbc,
  anorm,
  cache,
  <span class="strong"><strong>"org.apache.derby" % "derbyclient" % "10.8.1.2"</strong></span>
)  </pre></div><p>We can now define a <code class="literal">Customer</code> <a id="id316" class="indexterm"/>case class that will represent the <code class="literal">CUSTOMER</code> table from the database and implement some <a id="id317" class="indexterm"/>behaviors in the form of methods defined in its companion object, as follows:</p><div class="informalexample"><pre class="programlisting">package models

import play.api.db._
import play.api.Play.current
import anorm._
import anorm.SqlParser._
import scala.language.postfixOps

case class Customer(id: Pk[Int] = NotAssigned, name: String)

object Customer {
  /**
   * Retrieve a Customer from an id.
   */
  def findById(id: Int): Option[Customer] = {
    DB.withConnection { implicit connection =&gt;
      println("Connection: "+connection)
      val query = SQL("SELECT * from app.customer WHERE customer_id = {custId}").on('custId -&gt; id)
      query.as(Customer.simple.singleOpt)
    }
  }

  /**
   * Parse a Customer from a ResultSet
   */
  val simple = {
    get[Pk[Int]]("customer.customer_id") ~
    get[String]("customer.name") map {
      case id~name =&gt; Customer(id, name)
    }
  }
}</pre></div><p>The Anorm SQL query conforms to a string-based SQL statement where variables are bound to values. Here we bind the <code class="literal">customer_id</code> column to the <code class="literal">id</code> input parameter. Since we want to return an <code class="literal">Option[Customer]</code> to handle the case where the SQL query did not return any result, we <a id="id318" class="indexterm"/>first need to <a id="id319" class="indexterm"/>parse the <code class="literal">ResultSet</code> object to create a <code class="literal">Customer</code> instance and <a id="id320" class="indexterm"/>invoke the <code class="literal">singleOpt</code> method that will make sure we wrap the result into an <code class="literal">Option</code> (which can return <code class="literal">None</code> <a id="id321" class="indexterm"/>instead of a potential error).</p><p>The <code class="literal">Application</code> controller is given as follows:</p><div class="informalexample"><pre class="programlisting">package controllers

import play.api._
import play.api.mvc._
import play.api.db._
import play.api.Play.current
import models._

object Application extends Controller {
  def index = Action {
    val inputId = 2  //  Hardcoded input id for the example
    val result = 
      DB.withConnection { implicit c =&gt;
        Customer.findById(inputId) match {
          case Some(customer) =&gt; s"Found the customer: ${customer.name}"
          case None =&gt; "No customer was found."
      }
    }
    Ok(views.html.index(result))
  }
}</pre></div><p>It simply surrounds the database query with a database connection and does some pattern matching on the <code class="literal">Option[Customer]</code> entity to display different messages whether the queried customer <code class="literal">id</code> is found or not.</p><p>You may have noticed the keyword, <code class="literal">implicit</code>, sometimes while reading the Scala code in general (such as the <code class="literal">implicit c</code> <a id="id322" class="indexterm"/>parameter given in the previous code example). As clearly explained in the Scala documentation:</p><div class="blockquote"><blockquote class="blockquote"><p>"a method with implicit parameters can be applied to arguments just like a normal method. In this case, the implicit label has no effect. However, if such a method misses arguments for its implicit parameters, such arguments will be automatically provided". </p></blockquote></div><p>In our previous case, we could have omitted this implicit parameter since we are not using the database connection <code class="literal">c</code> variable further in the body of our method.</p><p>Running the application with <code class="literal">inputId=2</code> can be replaced by <code class="literal">inputId=3000;</code> for example, to demonstrate the case where no customer is found. To avoid changing anything in the view, we have reused the welcome message location of the default <code class="literal">index.html</code> page; therefore, you will see the result in the browser in the green header at the top of the HTML page.</p><p>This sample only shows a basic <a id="id323" class="indexterm"/>usage of Anorm; it is derived from the much more complete <code class="literal">computer-database</code> <a id="id324" class="indexterm"/>example that is part of the samples of the Play Framework distribution. You can refer to it if you need a deeper knowledge of the Anorm framework.</p></div></div>
<div class="section" title="Replacing ORM"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Replacing ORM</h1></div></div></div><p>As Java developers, we are used to <a id="id325" class="indexterm"/>handling relational database persistence through the use of mature and well-established JPA frameworks such as Hibernate or EclipseLink. Despite the fact that these frameworks are convenient to use and hide a lot of the complexity for retrieving or updating data that is spread over several tables, Object-Relational Mapping suffers from the <span class="strong"><strong>Object-Relational Impedance Mismatch</strong></span> problem; in an object-oriented model, you traverse objects via their relationships, whereas in a relational database, you join the data rows of tables, resulting sometimes in an inefficient and cumbersome retrieval of data. (This is further explained on the Wikipedia page, <a class="ulink" href="http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch">http://en.wikipedia.org/wiki/Object-relational_impedance_mismatch</a>.)</p><p>In contrast, the <code class="literal">Slick</code> framework that is part of the Typesafe stack proposes to solve the persistence of data to relational databases through a Functional Relational Mapping, which strives for a more natural fit. <a id="id326" class="indexterm"/>Some of the additional benefits of Slick include the following two aspects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Conciseness and Type Safety</strong></span>: Instead of running SQL queries by expressing them through strings in Java code, Slick uses plain Scala code to express queries. In JPA, the Criteria API or languages such as <span class="strong"><strong>JPQL</strong></span> (<span class="strong"><strong>Java Persistence </strong></span><a id="id327" class="indexterm"/><span class="strong"><strong>Query Language</strong></span>) or <span class="strong"><strong>HQL</strong></span> <a id="id328" class="indexterm"/>(<span class="strong"><strong>Hibernate Query Language</strong></span>) have long tried to make string-based queries more type checked, but are still difficult to comprehend and produce verbose code. With Slick, queries are written concisely using the power of Scala <code class="literal">for comprehensions</code>. Type safety of SQL queries was introduced a long time ago in the .Net world through the popular LINQ Framework.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Composable and reusable queries</strong></span>: <a id="id329" class="indexterm"/>The functional approach adopted by Slick makes composition a natural <a id="id330" class="indexterm"/>behavior, a feature that lacks when considering plain SQL as an alternative to ORM.</li></ul></div></div>
<div class="section" title="Learning about Slick"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Learning about Slick</h1></div></div></div><p>Let's explore the behavior of the <a id="id331" class="indexterm"/>Slick framework through code examples to see how we can enhance and replace more traditional ORM solutions.</p><p>The first example we can study is part of the <code class="literal">test-patterns-scala</code> activator template project that we have analyzed in <a class="link" href="ch04.html" title="Chapter 4. Testing Tools">Chapter 4</a>, <span class="emphasis"><em>Testing Tools</em></span>. The <code class="literal">scalatest/Test012.scala</code> file found inside the project exhibits a typical usage of Slick as follows:</p><div class="informalexample"><pre class="programlisting">package scalatest

import org.scalatest._
import scala.slick.driver.H2Driver.simple._
import Database.threadLocalSession

object Contacts extends Table[(Long, String)]("CONTACTS") {
  def id = column[Long]("CONTACT_ID", O.PrimaryKey)
  def name = column[String]("CONTACT_NAME")
  def gender = column[String]("GENDER")
  def * = id ~ name
}

class Test12 extends FunSuite {
  val dbUrl = "jdbc:h2:mem:contacts"
  val dbDriver = "org.h2.Driver"
  
  test("Slick, H2, embedded") {
    Database.forURL(dbUrl, driver = dbDriver) withSession {
    Contacts.ddl.create
    Contacts.insertAll(
      (1, "Bob"),
      (2, "Tom"),
      (3, "Salley")
    )
  
    val nameQuery = 
      for( 
        c &lt;- Contacts if c.name like "%o%"
      ) yield c.name 
    val names = nameQuery.list     
    names.foreach(println)
    assert(names === List("Bob","Tom"))
    }
  }
}</pre></div><p>The most interesting part in the code has to do with the SQL query. The immutable variable <code class="literal">names</code> contains the result of a query to the database; instead of expressing the SQL query as a <code class="literal">String</code> or through the <a id="id332" class="indexterm"/>Java Criteria API, pure Scala code is used through a <code class="literal">for comprehension</code>, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_06_05.jpg" alt="Learning about Slick"/></div><p>Unlike string-based SQL queries, any typo or reference to tables or fields that do not exist will be immediately pointed out by the compiler. More complex queries will be very naturally translated into for expressions in a readable manner compared to the verbose and hard-to-read output code resulting from the JPA Criteria API.</p><p>This sample only contains one table, <code class="literal">Contacts</code>, that we define by extending the <code class="literal">scala.slick.driver.H2Driver.simple.Table</code> class. The <code class="literal">CONTACTS</code> database table includes three columns, one primary key <code class="literal">id</code> defined as a <code class="literal">Long</code> datatype, and two other properties of type <code class="literal">String</code>, <code class="literal">name</code>, and <code class="literal">gender</code> respectively. The method <code class="literal">*</code> defined in the <code class="literal">Contacts</code> object specifies a default projection, that is, all the columns (or computed values) we are usually interested in. The expression <code class="literal">id ~ name</code> (using the <code class="literal">~</code> sequence operator) returns a <code class="literal">Projection2[Long,String]</code> which can be thought of as a Tuple2, but for the representation of relations. The default projection of <code class="literal">(Int, String)</code> leads to a <code class="literal">List[(Int, String)]</code> for simple queries.</p><p>Since the datatypes of columns in relational databases are not the same as Scala types, they need to be mapped (similar to the mappings needed when dealing with ORM frameworks or pure JDBC access). <a id="id333" class="indexterm"/>As stated in Slick's documentation, the primitive types supported out of the box are as follows (with a few limitations depending on the database driver used for each database type):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Numeric types</strong></span>: <code class="literal">Byte</code>, <code class="literal">Short</code>, <code class="literal">Int</code>, <code class="literal">Long</code>, <code class="literal">BigDecimal</code>, <code class="literal">Float</code>, <code class="literal">Double</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>LOB types</strong></span>: <code class="literal">java.sql.Blob</code>, <code class="literal">java.sql.Clob</code>, <code class="literal">Array[Byte]</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Date types</strong></span>: <code class="literal">java.sql.Date</code>, <code class="literal">java.sql.Time</code>, <code class="literal">java.sql.Timestamp</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Boolean</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">String</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Unit</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">java.util.UUID</code></li></ul></div><p>Once the domain entity is defined, the next steps are to create the database, insert some test data in it, and then run a query as we would do with any other persistence framework.</p><p>All of the code we run in the <code class="literal">Test12</code> test is surrounded by the following block:</p><div class="informalexample"><pre class="programlisting">Database.forURL(dbUrl, driver = dbDriver) withSession {
  &lt; code accessing the DB...&gt;
}</pre></div><p>The <code class="literal">forURL</code> method <a id="id334" class="indexterm"/>specifies a JDBC database connection, which normally consists of a driver class corresponding to the specific database to use and a connection URL defined by its <code class="literal">host</code>, <code class="literal">port</code>, <code class="literal">database name</code> as well as an optional <code class="literal">username/password</code>. In the example, a local in-memory database (H2) named <code class="literal">contacts</code> is used so that the connection URL is <code class="literal">jdbc:h2:mem:contacts</code>, exactly as we would write it in Java. Note that a Slick <code class="literal">Database</code> instance only encapsulates a "how-to" on how connections are created, the physical connection being created only at the <code class="literal">withSession</code> call.</p><p>The <code class="literal">Contacts.ddl.create</code> statement will create the database schema and the <code class="literal">insertAll</code> method will populate the <code class="literal">Contacts</code> table with three rows each consisting of its primary key <code class="literal">id</code> and <code class="literal">name</code>.</p><p>We can execute this test alone to verify that it runs as expected, by entering the following command in a terminal window in the root directory of the <code class="literal">test-patterns-scala</code> project:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; ./activator</strong></span>
<span class="strong"><strong>&gt; test-only scalatest.Test12</strong></span>
<span class="strong"><strong>Bob</strong></span>
<span class="strong"><strong>Tom</strong></span>
<span class="strong"><strong>[info] Test12:</strong></span>
<span class="strong"><strong>[info] - Slick, H2, embedded (606 milliseconds)</strong></span>
<span class="strong"><strong>[info] ScalaTest</strong></span>
<span class="strong"><strong>[info] Run completed in 768 milliseconds.</strong></span>
<span class="strong"><strong>[info] Total number of tests run: 1</strong></span>
<span class="strong"><strong>[info] Suites: completed 1, aborted 0</strong></span>
<span class="strong"><strong>[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0</strong></span>
<span class="strong"><strong>[info] All tests passed.</strong></span>
<span class="strong"><strong>[info] Passed: Total 1, Failed 0, Errors 0, Passed 1</strong></span>
<span class="strong"><strong>[success] Total time: 1 s, completed Dec 7, 2013 1:43:28 PM</strong></span>
</pre></div><p>Currently, the <code class="literal">test-patterns-scala</code> project includes a dependency to the <code class="literal">slf4j-nop</code> implementation of the SLF4J logging framework that disables any logging. Since it can be useful to visualize the exact SQL statement produced by Scala <code class="literal">for comprehension </code>statements, let's replace <code class="literal">sl4j-nop</code> with a logback implementation. In your <code class="literal">build.sbt</code> build file, replace the line <code class="literal">"org.slf4j" % "slf4j-nop" % "1.6.4"</code> with a reference to logback, for example, <code class="literal">"ch.qos.logback" % "logback-classic" % "0.9.28" % "test"</code>.</p><p>Now, if you rerun the test, you <a id="id335" class="indexterm"/>will probably see much more logging info than you actually want. We can therefore add a <code class="literal">logback.xml</code> file to the project (in the <code class="literal">src/test/resources/</code> folder) as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;configuration&gt;

    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder&gt;
            &lt;pattern&gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;root level="debug"&gt;
        &lt;appender-ref ref="STDOUT" /&gt;
    &lt;/root&gt;

    &lt;logger name="scala.slick.compiler"	level="${log.qcomp:-warn}" /&gt;
    &lt;logger name="scala.slick.compiler.QueryCompiler" level="${log.qcomp.phases:-inherited}" /&gt;
    
…
    &lt;logger name="scala.slick.compiler.CodeGen"                   level="${log.qcomp.codeGen:-inherited}" /&gt;
    &lt;logger name="scala.slick.compiler.InsertCompiler"            level="${log.qcomp.insertCompiler:-inherited}" /&gt;
    &lt;logger name="scala.slick.jdbc.JdbcBackend.statement"         level="${log.session:-info}" /&gt;

    &lt;logger name="scala.slick.ast.Node$"                          level="${log.qcomp.assignTypes:-inherited}" /&gt;
    &lt;logger name="scala.slick.memory.HeapBackend$"                level="${log.heap:-inherited}" /&gt;
    &lt;logger name="scala.slick.memory.QueryInterpreter"            level="${log.interpreter:-inherited}" /&gt;
&lt;/configuration&gt;</pre></div><p>This time if we enable only the <code class="literal">"scala.slick.jdbc.JdbcBackend.statement"</code> logger, the output from the test <a id="id336" class="indexterm"/>will show all the SQL queries, similar to the following output:</p><div class="informalexample"><pre class="programlisting">&gt; test-only scalatest.Test12
19:00:37.470 [ScalaTest-running-Test12] DEBUG scala.slick.session.BaseSession - Preparing statement: create table "CONTACTS" ("CONTACT_ID" BIGINT NOT NULL PRIMARY KEY,"CONTACT_NAME" VARCHAR NOT NULL)
19:00:37.484 [ScalaTest-running-Test12] DEBUG scala.slick.session.BaseSession - Preparing statement: INSERT INTO "CONTACTS" ("CONTACT_ID","CONTACT_NAME") VALUES (?,?)
19:00:37.589 [ScalaTest-running-Test12] DEBUG scala.slick.session.BaseSession - Preparing statement: select x2."CONTACT_NAME" from "CONTACTS" x2 where x2."CONTACT_NAME" like '%o%'
Bob
Tom
[info] Test12:
[info] - Slick, H2, embedded (833 milliseconds)
[info] ScalaTest
[info] Run completed in 952 milliseconds.
[info] Total number of tests run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[info] Passed: Total 1, Failed 0, Errors 0, Passed 1
[success] Total time: 1 s, completed Dec 10, 2013 7:00:37 PM
&gt; </pre></div><p>Finally, to verify whether database schema validation has been enforced, let's try to modify one of the keys of the inserted data so that we have duplicate keys, as shown in the following lines of code:</p><div class="informalexample"><pre class="programlisting">Contacts.insertAll(
      (1, "Bob"),
      (2, "Tom"),
      (2, "Salley")
    )</pre></div><p>If we run the test again, it fails with a message similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>[info] Test12:</strong></span>
<span class="strong"><strong>[info] - Slick, H2, embedded *** FAILED *** (566 milliseconds)</strong></span>
<span class="strong"><strong>[info]   org.h2.jdbc.JdbcBatchUpdateException: Unique index or primary key violation: "PRIMARY_KEY_C ON PUBLIC.CONTACTS(CONTACT_ID)"; SQL statement:</strong></span>
<span class="strong"><strong>[info] INSERT INTO "CONTACTS" ("CONTACT_ID","CONTACT_NAME") VALUES (?,?) [23505-166]…</strong></span>
</pre></div></div>
<div class="section" title="Scaffolding a Play application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Scaffolding a Play application</h1></div></div></div><p>In this section, we are going to further experiment with Slick and Play by automatically creating a full Play application with basic CRUD functionality out of a relational database, including <a id="id337" class="indexterm"/>Models, Views, Controllers, as well as test data and configuration files such as Play routes.</p><p>Any web application that needs to connect to a database generally requires most of the CRUD functionality at least in the backend. Furthermore, being able to generate a default frontend can avoid you having to make one from scratch. In particular, a Play frontend consisting of HTML5 views is highly reusable since most of the display of columns, fields, buttons, and forms can be re-arranged with limited copy/paste in an HTML editor.</p><p>Let's apply this reverse engineering on the sample customer database from the NetBeans distribution that we have already covered in <a class="link" href="ch02.html" title="Chapter 2. Code Integration">Chapter 2</a>, <span class="emphasis"><em>Code Integration</em></span>.</p><p>The generation of the Play app is done in two steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Creation of a regular Play project.</li><li class="listitem">Usage of an external tool named <code class="literal">playcrud</code> that is itself a Play app and will generate all the required MVC and configuration files on top of the new Play project structure.</li></ol></div><p>Having this approach in two steps has a better guarantee that the generated application will follow the latest changes in the Play distribution, in particular with regards to the evolution of the look and feel in Play that comes with every new release.</p><p>To get started with the <code class="literal">playcrud</code> <a id="id338" class="indexterm"/>utility, clone the project from GitHub by entering in a command terminal in a directory of your choice (assuming GIT is installed, visit <a class="ulink" href="http://git-scm.com/">http://git-scm.com/</a> if you don't have it already):</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; git clone https://github.com/ThomasAlexandre/playcrud</strong></span>
</pre></div><p>This should create a directory, <code class="literal">playcrud</code>, with the content of the project being a regular Play application, including the plugin to generate an Eclipse project. We can therefore run the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd playcrud</strong></span>
<span class="strong"><strong>&gt; play eclipse</strong></span>
</pre></div><p>Then, import the project into Eclipse to better visualize what it consists of. The application is made of just one controller found in the <code class="literal">Application.scala</code> file located at <code class="literal">samplecrud\app\controllers</code>, and its corresponding view found in <code class="literal">index.scala.html</code> under <code class="literal">samplecrud\app\views</code>. Only two routes are defined in the <code class="literal">routes</code> file under <code class="literal">samplecrud\conf</code>:</p><div class="informalexample"><pre class="programlisting"># Home page
GET    /    controllers.Application.index

# CRUD action
GET    /crud    controllers.Application.generateAll</pre></div><p>The first route will display a form in the browser where we can enter information about the database from which we want to create a Play <a id="id339" class="indexterm"/>app. The form is fairly straightforward to understand by looking at its template:</p><div class="informalexample"><pre class="programlisting">@(dbForm: Form[(String,String,String,String)])
@import helper._
@main(title = "The 'CRUD generator' application") {
    &lt;h1&gt;Enter Info about your existing database:&lt;/h1&gt;
    @form(action = routes.Application.generateAll, args = 'id -&gt; "dbform") {
      
        @select(
            field = dbForm("driver"), 
            options = options(
                "com.mysql.jdbc.Driver" -&gt; "MySQL",
                "org.postgresql.Driver" -&gt; "PostgreSQL",
                "org.h2.Driver" -&gt; "H2",
                "org.apache.derby.jdbc.ClientDriver" -&gt; "Derby"
            ),
            args = '_label -&gt; "Choose a DB"
        )
        
        @inputText(
            field = dbForm("dburl"),
            args = '_label -&gt; "Database url", 'placeholder -&gt; "jdbc:mysql://localhost:3306/slick"
        )

        @inputText(
            field = dbForm("username"),
            args = '_label -&gt; "DB username", 'size -&gt; 10, 'placeholder -&gt; "root"
        )
        
        @inputText(
            field = dbForm("password"),
            args = '_label -&gt; "DB password", 'size -&gt; 10, 'placeholder -&gt; "root"
        )
        &lt;p class="buttons"&gt;
            &lt;input type="submit" id="submit"&gt;
        &lt;p&gt;
    }
} </pre></div><p>The second is the <code class="literal">generateAll</code> action performed once we submit the form that will create all files needed to execute the newly created Play app.</p><p>To be able to generate all files in the right place, we just need to edit one configuration property called <code class="literal">baseDirectory</code>, currently found in the <code class="literal">Config.scala</code> file in the <code class="literal">utilities/</code> folder. This property specifies the root directory of the Play application we want to generate. Before we edit it, <a id="id340" class="indexterm"/>we can generate a blank Play project that the <code class="literal">baseDirectory</code> variable will refer to:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd ~/projects/internal (or any location of your choice)</strong></span>
<span class="strong"><strong>&gt; play new samplecrud</strong></span>
<span class="strong"><strong>…</strong></span>
<span class="strong"><strong>What is the application name? [samplecrud]</strong></span>
<span class="strong"><strong>&gt; [ENTER]</strong></span>
<span class="strong"><strong>Which template do you want to use for this new application? </strong></span>
<span class="strong"><strong>  1             - Create a simple Scala application</strong></span>
<span class="strong"><strong>  2             - Create a simple Java application</strong></span>
<span class="strong"><strong>&gt; [Press 1]</strong></span>
<span class="strong"><strong>Just to verify we have our blank Play application correctly created we can launch it with:</strong></span>
<span class="strong"><strong>&gt; cd samplecrud</strong></span>
<span class="strong"><strong>&gt; play run</strong></span>
</pre></div><p>Now, open the <code class="literal">http://localhost:9000</code> URL in a web browser.</p><p>Now that we have our <code class="literal">baseDirectory</code> (<code class="literal">~/projects/internal/samplecrud</code>), we can add it to the <code class="literal">Config.scala</code> file. The other properties concerning the database are just default values; we do not need to edit them here since we will instead specify them when we fill out the HTML form while running the <code class="literal">playcrud</code> app.</p><p>In a new terminal window, let's execute the <code class="literal">playcrud</code> app by entering the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; cd &lt;LOCATION_OF_PLAYCRUD_PROJECT_ROOT&gt;</strong></span>
<span class="strong"><strong>&gt; play "run 9020" (or any other port than 9000)</strong></span>
</pre></div><p>Here, we need to choose a different port than <code class="literal">9000</code> as it is already taken by the blank application.</p><p>Now, point your web browser to the <code class="literal">playcrud</code> URL, <code class="literal">http://localhost:9020/</code>. You should get an HTML form where you can edit the properties of the source database to access for CRUD generation, as shown in the following screenshot (this database will only be read from):</p><div class="mediaobject"><img src="graphics/3637OS_06_01.jpg" alt="Scaffolding a Play application"/></div><p>Submitting the form will most likely generate some logging output in the terminal console, and once it is done with the generation, the browser will be redirected to port <code class="literal">9000</code> to display the newly generated CRUD app. Since this is the first time we generate the app, it will fail because the <code class="literal">build.sbt</code> file of the generated app was updated and needs to be reloaded with some new <a id="id341" class="indexterm"/>dependencies.</p><p>To fix that, interrupt the currently running Play app by pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>D</em></span>. Once it has stopped, simply re-launch it:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play run</strong></span>
</pre></div><p>If everything goes well, you should be able to access <code class="literal">http://localhost:9000</code> and see a list of clickable controllers corresponding to the entities that were generated from the database, including <code class="literal">Product</code>, <code class="literal">Manufacturer</code>, and <code class="literal">Purchase Order</code>.</p><p>Let's open one of them, for instance, the Manufacturer view, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_06_02.jpg" alt="Scaffolding a Play application"/></div><p>The resulting screen shows the <code class="literal">READ</code> part of the CRUD functionality by displaying a list of all the manufacturer rows from the database. The paging functionality is set to <code class="literal">3</code> by default, that is why only three out of the 30 available manufacturers are seen at once, but one can navigate to the other pages by clicking on the <span class="strong"><strong>Previous</strong></span> and <span class="strong"><strong>Next</strong></span> buttons. This default page size is editable in each individual controller (look for a <code class="literal">pageSize</code> val declaration), or can be modified <a id="id342" class="indexterm"/>in the controller template before code generation to update all controllers at once. Moreover, the headers of the HTML table are clickable to sort elements according to each specific column.</p><p>Clicking on the <span class="strong"><strong>Add New Manufacturer</strong></span> button will invoke a new screen containing a form used to create a new entry in the database.</p><div class="section" title="Importing test data"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec45"/>Importing test data</h2></div></div></div><p>The generated app <a id="id343" class="indexterm"/>is running with an H2 in-memory database, by default, which is populated at startup with some test data. During generation, we have exported content from the source database into an XML file using the functionality of DBUnit, a JUnit-based framework in Java. DBUnit is useful when there is enough database data involved in your tests that you want to avoid mocking everything by producing XML sample files containing some data extracted from a real database instead. The exported test data is stored in <code class="literal">testdata.xml</code> under <code class="literal">samplecrud\test\</code>. When running the generated application, this file will be loaded by DBUnit in the <code class="literal">onStart</code> method of the <code class="literal">Global.scala</code> after the DB schema has been created.</p><p>To be able to persist the data to a real database and therefore avoid importing the XML file on every restart, we can replace the in-memory data by a real database on disk. For example, we can replace the database driver properties in the <code class="literal">application.conf</code> file under <code class="literal">samplecrud\conf</code> with the following lines:</p><div class="informalexample"><pre class="programlisting">db.default.driver=org.h2.Driver
db.default.url="jdbc:h2:tcp://localhost/~/customerdb"
db.default.user=sa
db.default.password=""</pre></div><p>The new database is built once we have restarted the play app:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play run</strong></span>
</pre></div><p>Accessing the <code class="literal">http://localhost:9000</code> URL in the browser will this time create the database schema on disk and <a id="id344" class="indexterm"/>populate test data as well. Since the database is persisted between restarts, from now on we have to comment out the <code class="literal">ddl.create</code> statement in <code class="literal">Global.scala</code> as well as the lines referring to the DBUnit import of <code class="literal">testdata.xml</code>.</p></div><div class="section" title="Visualizing the database in the H2browser"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec46"/>Visualizing the database in the H2browser</h2></div></div></div><p>A convenient feature of <a id="id345" class="indexterm"/>Play is that you can access the <code class="literal">h2-browser</code> to visualize the database content in your browser <a id="id346" class="indexterm"/>directly from SBT. This is true even if you are using most databases other than H2. Open a terminal window and navigate to the root of the generated project:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>&gt; play</strong></span>
<span class="strong"><strong>&gt; h2-browser</strong></span>
</pre></div><p>Connect to the database by filling out the connection properties as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_06_03.jpg" alt="Visualizing the database in the H2browser"/></div><p>Assuming that clicking on the <span class="strong"><strong>Test Connection</strong></span> button displayed <span class="strong"><strong>Test successful</strong></span> as shown in the previous screenshot, we can <a id="id347" class="indexterm"/>visualize <a id="id348" class="indexterm"/>and send SQL queries to the <code class="literal">customerdb</code> database as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/3637OS_06_04.jpg" alt="Visualizing the database in the H2browser"/></div></div><div class="section" title="Exploring the code behind the app generation"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec47"/>Exploring the code behind the app generation</h2></div></div></div><p>Every table <a id="id349" class="indexterm"/>from the source database leads to the generation of a number of artifacts:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One <code class="literal">model</code>, one <code class="literal">controller</code>, and several <code class="literal">view</code> classes</li><li class="listitem" style="list-style-type: disc">A set of <code class="literal">route</code> entries inserted in the <code class="literal">conf.routes</code> file, as shown in the following code for the <code class="literal">PURCHASE_ORDER</code> table:<div class="informalexample"><pre class="programlisting"># PurchaseOrder
# 
# PurchaseOrder list (look at the default values for pagination parameters)

GET     /purchaseorder               controllers.PurchaseOrderController.list(p:Int ?= 0, s:Int ?= 2, f ?= "")
# Add purchaseorder
GET     /purchaseorder/new           controllers.PurchaseOrderController.create
POST    /purchaseorder               controllers.PurchaseOrderController.save
# Edit existing purchaseorder
GET     /purchaseorder/:pk           controllers.PurchaseOrderController.edit(pk:Int)
POST    /purchaseorder/:pk           controllers.PurchaseOrderController.update(pk:Int)

# Delete purchaseorder
POST    /purchaseorder/:pk/delete    controllers.PurchaseOrderController.delete(pk:Int)</pre></div></li></ul></div><p>Models consist of the domain entities, each being defined in Slick by a combination of a case class representing a row together with a driver specific <code class="literal">slick.driver.H2Driver.simple.Table</code> of rows. We could have avoided the usage of the case class and directly written tuples of the involved columns as we have seen in the earlier <code class="literal">Test12</code> example from the <code class="literal">test-patterns-scala</code> activator template, but encapsulating the columns in a case class is convenient for later use of pattern matching and usage in the views. <a id="id350" class="indexterm"/>The model class representing a <code class="literal">PurchaseOrder</code> entity is generated as follows:</p><div class="informalexample"><pre class="programlisting">package models

case class PurchaseOrderRow(orderNum : Option[Int], customerId : Int, productId : Int, quantity : Option[Int], shippingCost : Option[Int], salesDate : Option[Date], shippingDate : Option[Date], freightCompany : Option[String])

// Definition of the PurchaseOrder table
object PurchaseOrder extends Table[PurchaseOrderRow]("PURCHASE_ORDER") {
 
  def orderNum = column[Int]("ORDER_NUM", O.PrimaryKey) 
  def customerId = column[Int]("CUSTOMER_ID")  
  def productId = column[Int]("PRODUCT_ID")   
  def quantity = column[Option[Int]]("QUANTITY") 
  def shippingCost = column[Option[Int]]("SHIPPING_COST") 
  def salesDate = column[Option[Date]]("SALES_DATE")  
  def shippingDate = column[Option[Date]]("SHIPPING_DATE") 
  def freightCompany = column[Option[String]]("FREIGHT_COMPANY") 
 
  def * = orderNum.? ~ customerId ~ productId ~ quantity ~ shippingCost ~ salesDate ~ shippingDate ~ freightCompany &lt;&gt; (PurchaseOrderRow.apply _, PurchaseOrderRow.unapply _)

  def findAll(filter: String = "%") = {
    for {
      entity &lt;- PurchaseOrder
      // if (entity.name like ("%" + filter))
    } yield entity
  }

  def findByPK(pk: Int) =
     for (
       entity &lt;- PurchaseOrder if entity.orderNum === pk
     ) yield entity
     ...</pre></div><p>The complete code for the <code class="literal">PurchaseOrder</code> entity as well as the definition of the CRUD methods of the corresponding <code class="literal">PurchaseOrderController</code> class is available for download on the Packt Publishing website and can also be reproduced by executing the scaffolding playcrud GitHub project on the <code class="literal">CustomerDB</code> sample database as we have explained in this section.</p><p>Finally, templates to generate <a id="id351" class="indexterm"/>views for a specific entity are gathered under the same directory named <code class="literal">views.&lt;entity_name&gt;/</code> and consist of three files, <code class="literal">list.scala.html</code>, <code class="literal">createForm.scala.html</code>, and <code class="literal">editForm.scala.html</code> for the <code class="literal">READ</code>, <code class="literal">CREATE</code>, and <code class="literal">UPDATE</code> operations, respectively. They embed a mix of plain HTML5 markup together with minimal Scala code to loop over and display elements from the controller queries. Notice in the view the addition of a specific <code class="literal">play.api.mvc.Flash</code> implicit object: this useful feature of Play makes it possible to display some information in the resulting views to inform the user on the outcome of the performed actions. You can see in the controller that we referred to it via the statement <code class="literal">Home.flashing {... }</code>, where we display various information depending on pattern matching on the success or failure of an action.</p></div><div class="section" title="Limitations of the playcrud utility"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec48"/>Limitations of the playcrud utility</h2></div></div></div><p>In the current release <a id="id352" class="indexterm"/>of the experimental <code class="literal">playcrud</code> utility, a <a id="id353" class="indexterm"/>few limitations have been found, which are explained as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">playcrud</code> project does not always work out of the box with all JDBC databases, especially since the mappings of some databases are customized. However, with only few changes, it is flexible enough to adapt to new mappings. Furthermore, it allows the generation of only a partial database by specifying the tables that need to be generated in an external file. To enable this functionality, we only need to add a file in our <code class="literal">playcrud</code> project under <code class="literal">conf/</code>, name it <code class="literal">tables</code>, and write the table names of tables we want to include (one table <a id="id354" class="indexterm"/>name per row in the file, case insensitive). For instance, consider a <code class="literal">tables</code> file that includes the following code:<div class="informalexample"><pre class="programlisting">product
purchaseorder
manufacturer</pre></div><p>This code will create MVC classes and HTML views for these three tables only.</p></li><li class="listitem" style="list-style-type: disc">In case the mapping of a specific database datatype is not handled by <code class="literal">playcrud</code>, you will get a compiler error in the browser window that will most likely refer to the missing datatype. The place in the <code class="literal">playcrud</code> code where mappings are handled is the <code class="literal">utilities/DBUtil.scala</code> class. A later release of <code class="literal">playcrud</code> should make these configurations more flexible per database type and put them in external files, but for now they are embedded in the code.</li><li class="listitem" style="list-style-type: disc">The available code generation is inspired and built upon two already existing samples, one being the sample named <a id="id355" class="indexterm"/><code class="literal">computer-database</code> part of the Play Framework distribution (which exhibits a CRUD app but with Anorm as persistence, a SQL-based persistence framework, which is the default in Play), the other being a sample of usage of Slick done by Typesafe's Slick Team (the <code class="literal">Coffee</code> database with its <code class="literal">Suppliers</code> showing one-to-many relationships). If you wish to generate the code differently, all the templates are found under <code class="literal">views/</code>. Some of them mostly contain static data, such as the generation of <code class="literal">build.sbt</code> based on the <code class="literal">build.scala.txt</code> template.</li><li class="listitem" style="list-style-type: disc">In commercial applications, it is not unusual to encounter database tables that have more than 22 columns. Since we encapsulate these columns into case classes and Scala 2.10 has a restriction that limits the creation of a case class of more than 22 elements, it is not possible at the moment to generate Slick mappings exceeding that size. Hopefully, starting with Scala 2.11, this limitation should be lifted.</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, we have covered several approaches to deal with relational database persistence. We first went through an example of integration between Scala and traditional JPA-based ORM persistence. The example also illustrated the integration between the Spring framework and a Scala codebase. We then introduced Anorm, the default persistence framework available in the Play Framework that relies on direct SQL queries. Because of some limitations of ORM, mainly related to scalability and performance, and limitations as well of plain SQL queries in terms of lack of type safety and lack of composability, we moved towards the adoption of the Slick framework, a unique approach to persistence that targets a more functional way to persist data in relational databases. Finally, we considered the case where we can generate a full Play web app with basic CRUD functionality out of an existing database as a way of rapidly getting started integrating Slick into Play. The future releases of Slick starting with 2.0 enhance support for code generation and strive for even more readable syntax for writing database queries through the usage of Scala macros.</p><p>In the next chapter, we are going to consider how to use Scala when integrating external systems together, in particular through Web Services and REST APIs, supporting data formats such as JSON and XML.</p></div></body></html>