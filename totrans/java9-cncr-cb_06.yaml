- en: Parallel and Reactive Streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating streams from different sources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the elements of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting the elements of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying an action to every element of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the elements of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming the elements of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting the elements of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying conditions in the elements of a stream
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming with reactive streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **stream** in Java is a sequence of elements that can be processed (mapped,
    filtered, transformed, reduced, and collected) in a pipeline of declarative operations
    using **lambda expressions** in a sequential or parallel way. It was introduced
    in Java 8 and was one of the most significant new features of that version, together
    with lambda expressions. They have changed the way you can process big sets of
    elements in Java, optimizing the way the language processes those elements.
  prefs: []
  type: TYPE_NORMAL
- en: Streams have introduced the `Stream`, `DoubleStream`, `IntStream` and `LongStream`
    interfaces, some utility classes such as `Collectors` or `StreamSupport`, some
    functional-like interfaces such as `Collector`, and a lot of methods in different
    classes such as the `stream()` or `parallelStream()` methods in the `Collection`
    interface or the `lines()` method in the `Files` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Through the recipes of this chapter, you will learn how to effectively use
    streams in your application, but before that let''s see the most important characteristics
    of streams:'
  prefs: []
  type: TYPE_NORMAL
- en: A stream is a sequence of data, not a data structure. Elements of data are processed
    by the stream but not stored in it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create streams from different sources, such as collections (lists, arrays
    and so on), files, and strings, or by creating a class that provides the elements
    of the stream.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't access an individual element of the streams. You define the source
    of the stream and the operations you want to apply to its elements. Stream operations
    are defined in a functional way, and you can use lambda expressions in intermediate
    and terminal operations to define the actions you want to execute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can't modify the source of the stream. If, for example, you filter some
    elements of the stream, you are skipping the elements on the stream and not in
    its source.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Streams define two kinds of operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intermediate operations**: These operations always produce a new stream with
    their results. They can be used to transform, filter, and sort the elements of
    the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminal operations**: These operations process all the elements of the stream
    to generate a result or a side-effect. After their execution, the stream can''t
    be used again.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A stream pipeline is formed by zero or more intermediate operations and a final
    operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Intermediate operations can be as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateless**: Processing an element of the stream is independent of the other
    elements. For example, filtering an element based on a condition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateful**: Processing an element of the stream depends on the other elements
    of the stream. For example, sorting the elements of the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Laziness**: Intermediate operations are lazy. They''re not executed until
    the terminal operation begins its execution. Java can avoid the execution of an
    intermediate operation over an element or a set of elements of the stream if it
    detects that it doesn''t affect the final result of the operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stream` can have an infinite number of elements. There are operations such
    as `limit()` or `findFirst()` that can be used to limit the elements used in the
    final computation. As the intermediate operations are lazy, an unbounded stream
    can finish its execution in a finite time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streams can only be used once. As we mentioned before, when the terminal operation
    of a stream is executed, the stream is considered consumed, and it can't be used
    again. If you need to process the same data again to generate different results,
    you have to create a new `Stream` object from the same source. If you try to use
    a consumed stream, you will get an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can process the elements of a stream sequentially or in a parallel way without
    any extra effort. You can specify the mode of execution of a stream more than
    once, but only the last time will be taken into account. You have to be careful
    with the selected mode. Stateful intermediate operations won't use all the possibilities
    of concurrency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 9 has included a new kind of streams-the reactive streams-that allow you
    to communicate information to producers and consumers in an asynchronous way.
    This chapter presents nine recipes that will teach you how to create streams and
    use all their intermediate and terminal operations to process big collections
    of data in a parallel and functional way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating streams from different sources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to create streams from different sources.
    You have different options, as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `parallelStream()` method of the `Collection` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Supplier` interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A predefined set of elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`File` and a directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A random number generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The concatenation of two different streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can create a `Stream` object from other sources (that will be described
    in the *There's more* section), but we think that these are the more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe we''ll implement an example where you will learn how to create
    streams from the sources described earlier. Follow these steps to implement the
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we''ll implement some auxiliary classes that we will use in the example.
    Create a class named `Person` with six attributes of different types: `String`,
    `int`, `double` and `Date`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Create the methods to set and get the values of these attributes. Implement
    the `comparteTo()` method to compare two `Person` objects. Let's consider that
    two persons are the same it they have the same `firstName` and the same `lastName`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a class named `PersonGenerator` to create a random list of `Person`
    objects. Implement a static method named `generatePersonList()` in this class
    , which receives the number of persons you want to generate and returns a `List<Person>`
    object with the number of persons. Here, we include a version of this method,
    but feel free to change it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a class named `MySupplier` and specify that it implements the `Supplier`
    interface parameterized with the `String` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Declare a private `AtomicInteger` attribute named `counter` and initialize
    it in the constructor of the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement the `get()` method defined in the `Supplier` interface. This method
    will return the next element of the stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a class named `Main` and implement the `main()` method in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we''ll create a `Stream` object from a list of elements. Create the
    `PersonGenerator` class to create a list of 10,000 `Person` objects, and use the
    `parallelStream()` method of the `List` object to create the `Stream`. Then, use
    the `count()` method of the `Stream` object to get the number of elements of the
    `Stream`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll create a `Stream` from a generator. Create an object of the `MySupplier`
    class. Then, use the static method `generate()` of the `Stream` class, passing
    the created object as a parameter to create the stream. Finally, use the `parallel()`
    method to convert the stream created to a parallel stream, the `limit()` method
    to get the first ten elements of the stream, and the `forEach()` method to print
    the elements of the stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll create a stream from a predefined list of elements. Use the static
    `of()` method of the `Stream` class to create the `Stream`. This method receives
    a variable list of parameters. In this case, we''ll pass three `String` objects.
    Then, use the `parallel()` method of the stream to convert it to a parallel one
    and the `forEach()` method to print the values in the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a stream to read the lines of a file. First, create a `BufferedReader`
    object to read the file you want to read. Then, use the `lines()` method of the
    `BufferedReader` class to get a stream of `String` objects. Each element of this
    stream will be a line from the file. Finally, use the `parallel()` method to get
    a parallel version of the stream and the `count()` method to get the number of
    elements of the `Stream`. We also have to close the `BufferedReader` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a `Stream` to process the contents of a folder. First, use
    the `list()` method of the `Files` class to get a stream of `Path` objects with
    the contents of the folder. Then, use the `parallel()` method of the `Stream`
    object to convert it to a parallel stream and the `count()` method to count its
    elements. Finally, in this case, we have to use the `close()` method to close
    the Stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The next source we''ll use is an `Array`. First, create an `Array` of strings.
    Then, use the `stream()` method of the `Arrays` class to create a stream from
    the elements of the array. Finally, use the `parallel()` method to convert the
    stream into a parallel one and the `forEach()` method to print the elements of
    the stream to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll create a stream of random double numbers. First, create a `Random`
    object. Then, use the `doubles()` method to create a `DoubleStream` object. We''ll
    pass the number `10` as a parameter to that method, so the stream we''re going
    to create will have ten elements. Finally, use the `parallel()` method to convert
    the stream into a parallel one, the `peek()` method to write each element to the
    console, the `average()` method to calculate the average of the values of the
    stream, and the `getAsDouble()` method to get the value stored in the `Optional`
    object returned by the `average()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll create a stream concatenating two streams. First, we create
    two streams of `String` objects using the `of()` method of the `Stream` class.
    Then, we use the `concat()` method of the `Stream` class to concatenate those
    streams into a unique one. Finally, we use the `parallel()` method of the `Stream`
    class to convert the stream into a parallel one and the `forEach()` method to
    write all the elements to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see in detail all the methods we used in this example to create streams:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we used the `parallelStream()` method of the `List` class. In fact, this
    method is defined in the `Collection` interface, so all the classes that implement
    this interface, such as the `ArrayList`, `LinkedList`, or `TreeSet` classes implement
    that method. You can use the `stream()` method to create a sequential stream or
    the `parallelStream()` method to create a parallel one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, we used an implementation of the `Supplier` interface: the `MySupplier`
    class. The interface provides the `get()` method. This method is called each time
    the stream needs an element to process. You can create a stream with an infinite
    number of elements, so you should use a method that limits the number of elements
    of the stream, such as the `limit()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we used the `of()`method of the `Stream` class. This is a static method
    that receives a variable number of parameters and returns a `Stream` with those
    parameters as elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we used the `lines()` method of the `BufferedStream` class. This method
    returns a stream where each element is a line read from the `BufferedStream`.
    We used this method to read all the lines of a file, but you can use it with other
    kinds of `BufferedReader`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we used the `list()` method of the `Files` class. This method receives
    a `Path` object representing a folder of your system and returns a `Stream` of
    `Path` objects with the elements into that folder. You have to take into account
    that this method is not recursive, so if the folder has one or more subfolders,
    it doesn't process their content. As you will see later in the *There's more*
    section, the `Files` class has other methods to work with streams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we used the `stream()` method of the `Arrays` class that receives an array
    and returns a `Stream` with the elements of the array. If the array is of the
    `double`, `int`, or `long` types, it returns a `DoubleStream`, `IntStream`, or
    `LongStream` object. These are special kinds of streams that allow you to work
    with such number types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we generated a stream with random numbers. We used the `doubles()` method
    of the `Random` class. We passed to it the size of the `Stream` we wanted to obtain,
    but you can also pass to it the minimum and maximum numbers you want to obtain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we used the `concat()` method of the `Stream` class that takes two
    streams and returns one with the elements of both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also used some methods of the `Stream` class. Most of them will be described
    later in more detail, but here we provide a basic introduction to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '`count()`: This method returns the number of elements in the `Stream`. It''s
    a terminal operation and returns a `long` number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit()`: This method receives a number as a parameter. If the stream has
    fewer elements than the number, it returns a stream with all the elements. Otherwise,
    it returns a stream with the number of elements specified in the parameter. It''s
    an intermediate operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEach()`: This method allows you to specify an action that will be applied
    to each of the elements of the `Stream`. We used this terminal operation to write
    some information to the console. We have used a lambda expression with this purpose.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This method is an intermediate operation that allows you to perform
    an action over each of the elements of the stream and returns a stream with the
    same elements. This method is usually used as a debugging tool. Take into account
    that, like all intermediate operations, this is a lazy operation, so it will only
    be executed over those elements that are requested by the terminal operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`average()`: This is a method that is declared in the `IntStream`, `DoubleStream`,
    and `LongStream` streams. It returns an `OptionalDouble` value. The `OptionalDouble`
    class represents a double number that can have a value or not. It won''t generate
    a value for an empty `Stream`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parallel()`: This method converts a sequential `Stream` into a parallel one.
    Most of the streams created in this example are sequential, but we can convert
    them into parallel ones using this method of the `Stream` class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Java API includes other methods to create `Stream` objects. In this section,
    we enumerate some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Files` class provides more methods that create streams:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`find()`: This method returns the files contained in a folder, or in any of
    its subfolders, which meet the criteria specified in a lambda expression.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`walk()`: This method returns a stream of `Path` objects with the contents
    of a folder and all its subfolders.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Stream` class also includes other static methods that allow you to create
    streams:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`iterate()`: This method produces a stream whose elements are generated by
    the application of a unary function to an initial element. The first element of
    the stream is the initial element, the second element, the result of applying
    the function to the initial element, the third, the result of applying the function
    to the second element, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the `String` class has the `chars()` method. This method returns an
    `IntStream` with the values of the characters that forms the `String`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have created a stream, you have to process its elements. All the
    recipes in this chapter give you information about how to go about processing
    the elements of a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the elements of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**MapReduce** is a programming model used to process very large datasets in
    distributed environments using a lot of machines working in a cluster. This programming
    model has the following two operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Map**: This operation filters and transforms the original elements into a
    form more suitable to the reduction operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce**: This operation generates a summary result from all the elements,
    for example, the sum or the average of numeric values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This programming model has been commonly used in the functional programming
    world. In the Java ecosystem, the **Hadoop** project of the **Apache Software
    Foundation** provides an implementation of this model. The `Stream` class implements
    two different reduce operations:'
  prefs: []
  type: TYPE_NORMAL
- en: The pure reduce operation, implemented in the different versions of the `reduce()`
    method that process a stream of elements to obtain a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mutable reduction implemented in the different versions of the `collect()`
    method that process a stream of elements to generate a mutable data structure,
    such as `Collection` or a `StringBuilder`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the different versions of the `reduce()`
    method to generate a result from a stream of values. As you may have already imagined,
    the `reduce()` method is a terminal operation in a `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll create some auxiliary classes that we will use later in the example.
    Review the recipe, *Creating streams from different sources*, and include in this
    example the `Person` and `PersonGenerator` classes used in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a class named `DoubleGenerator`. Implement a method named `generateDoubleList()`
    to generate a list of double numbers. It receives two parameters with the size
    of the list we''ll generate and the highest value in the list. It will generate
    a list of random double numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Implement a method named `generateStreamFromList()`. This method receives a
    `List` of `double` numbers as a parameter and generates a `DoubleStream` stream
    with the elements of the list. For that purpose, we will use the `DoubleStream.Builder`
    class to construct the stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Create a class named `Point` with two double attributes, `x` and `y`, and the
    methods to `get()` and `set()` its value. The code of this class is very simple,
    so it won't be included.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a class named `PointGenerator` with a method named `generatePointList()`.
    This method receives the size of the list you want to generate and returns a list
    of random `Point` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create the `Main` class with the `main()` method. First, we''ll generate
    a `List` of 10,000 double numbers using the `DoubleGenerator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Stream` class and the specialized `DoubleStream`, `IntStream`, and `LongStream`
    classes implement some methods that are specialized reduce operations. In this
    case, we''ll generate a `DoubleStream` using the `DoubleGenerator` class and use
    `count()`, `sum()`, `average()`, `max()` and `min()` to obtain the number of elements,
    the sum of all the elements, the average of all the elements, the maximum number
    in the stream, and the minimum number in the stream. As we can only process the
    elements of a stream once, we have to create a new stream per operation. Take
    into account that these methods are only present in the `DoubleStream`, `IntStream`,
    and `LongStream` classes. The `Stream` class only has the `count()` method. Some
    of these methods return an optional object. Take into account this object could
    not have any value, so you should check before obtaining the value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll use the first version of the `reduce()` method. This method receives
    as parameter an associative `BinaryOperator` that receives two objects of the
    same type and returns an object of that type. When the operation has processed
    all the elements of the `Stream`, it returns an `Optional` object parameterized
    with the same type. For example, we''ll use this version to calculate the sum
    of both the coordinates of a random list of `Point` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll use the second version of the `reduce()` method. It''s similar
    to the previous one, but in this case, in addition to the associative `BinaryOperator`
    object, it receives the identity value for that operator (for example `0` for
    a sum or `1` for a product) and returns an element of the type we''re working
    with. If the stream has no values, the identity value will be returned. In this
    case, we use this version of the `reduce()` method to calculate the total amount
    of money we need to spend in salaries. We use the `map()` method to convert each
    `Person` object in an `int` value (its salary) so our `Stream` object will have
    `int` values when it executes the `reduce()` method. You will get more information
    about the `map()` method in the *Transforming the elements of a stream* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll use the third version of the `reduce()` method. This version
    is used when the type of result of the reduce operation is different from the
    type of stream elements. We have to provide the identity value of the return type,
    an accumulator that implements the `BiFunction` interfaces and will receive an
    object of the return type, an element of the stream to generate a value of the
    return type, and a combiner function that implements the `BinaryOperator` interface
    and receives two objects of the return type to generate an object of that type.
    In this case, we have used this version of the method to calculate the number
    of persons with a salary higher than 50,000 in a list of random persons:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, you learned how to use the different reduce operations provided
    by Java streams. First, we used some specialized reduce operations provided by
    the `DoubleStream`, `IntStream` and `LongStream` classes. These operations allow
    you to count the number of elements of the stream, calculate the sum of all the
    elements of the stream, calculate the average value of the elements of the stream,
    and calculate the highest and lowest value of the elements of the stream. If you
    work with a generic Stream, you will only have the `count()` method to count the
    elements of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we used the three versions of the `reduce()` method provided by the `Stream`
    class. The first one receives only one parameter, a `BinaryOperator`. We specified
    that operator as a lambda expression and you will normally do that, but you can
    also use an object of a class that implements the `BinaryOperator` interface.
    That operator will receive two elements of the stream and will have to generate
    a new element of the same type. For example, we receive two `Point` objects and
    generate a new `Point` object. The operation implemented by that `BinaryOperator`
    has to be associative, that is to say, the following expression must be true:'
  prefs: []
  type: TYPE_NORMAL
- en: '*(a op b) op c = a op (b op c)*'
  prefs: []
  type: TYPE_NORMAL
- en: Here `op` is our `BinaryOperator`.
  prefs: []
  type: TYPE_NORMAL
- en: This version of the `reduce()` method returns an `Optional` object; `Optional`
    because if the stream has no elements, there won't be a result value to return
    and the `Optional` object will be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second version of the `reduce()` method receives an *identity* value and
    a `BinaryOperator`. The `BinaryOperator` has to be associative as in the other
    version of the `reduce()` method. For the *identity* value, it has to be a `true`
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '*identity op a = a op identity = a*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the `reduce()` method returns an element of the same type of elements
    of the stream. If the stream has no elements, the identity value will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: The last version of the `reduce()` method is used when we want to return a value
    of a type different from the elements of the stream. In this case, the method
    has three parameters, an *identity* value, an *accumulator* operator, and a *combiner*
    operator. The *accumulator* operator receives a value of the return type and an
    element of the stream and generates a new object of the return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *combiner* function receives two objects of the return type to calculate
    a new object of the return type. The *identity* value is the *identity* value
    of the return type, and it has to verify the following expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '*combiner (u, accumulator(identity, t)) == accumulator(u, t)*'
  prefs: []
  type: TYPE_NORMAL
- en: Here, *u* is an object of the return type and *t* an element of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of an execution of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented all the parameters of the `reduce()` method as lambda expressions.
    The first two versions of the `reduce()` method receive a `BinaryOperator` and
    the third version receives a `BiFunction` and a `BinaryOperator`. If you want
    to reuse a complex operator, you can implement a class that implements the necessary
    interface and use an object of that class as the parameter to these and to the
    other methods of the `Stream` class.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting the elements of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Java streams allow you to process a sequence of elements in a sequential or
    parallel way. You can create a stream from different data sources, as a `Collection`,
    a `File` or an `Array` and apply to its elements a sequence of operations normally
    defined with lambda expressions. Those operations can be divided into two different
    classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intermediate operations**: These operations return other `Stream` as a result
    and allow you to filter, transform, or sort the elements of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Terminal operations**: These operations return a result after processing
    the elements of the stream'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A stream has a source, zero or more intermediate operations, and a terminal
    operation. The two most important terminal operations are:'
  prefs: []
  type: TYPE_NORMAL
- en: The reduce operation, which allows you to obtain a unique result after processing
    the elements of the stream. This result usually is a summary of the processed
    data. The *Reducing the elements of a stream* recipe explains you how to use reduce
    operations in Java.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collect operation that allows you to generate a data structure with the
    results of processing the elements of the stream. This is also called a mutable
    reduction operation as the result is a mutable data structure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to execute collect operations in Java streams
    with the different versions of the `collect()` method and the auxiliary `Collectors`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's implement some auxiliary classes we will use in the example. Implement
    the `Person` class to store some basic data about a person and the `PersonGenerator`
    class to generate a random list of persons. You can check the *Creating streams
    from different sources* recipe to see the source code of both the classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In that class, override the `toString()` method with the following code, which
    returns the first name and the last name of the person:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a class named `Counter` with two attributes: a `String` attribute
    named `value` and an `int` attribute named `counter`. Generate the methods to
    `get()` and `set()` the values of both attributes. The source code of this class
    is very simple, so it won''t be included.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the `Main` class with the `main()` method. Then, create a random
    `List` of `Person` objects using the `PersonGenerator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The first collect operation we will implement will generate a `Map` where the
    keys will be first name of the person and the values will be a list with all the
    persons with that first name. To implement this, we use the `collect()` method
    of the `Stream` class and the `Collectors.groupingByConcurrent` collector. Then,
    we process all the keys (first names) of the map using the `forEach()` method
    and print in the console the number of persons with that key: As parameter of
    the `groupingByConcurrent()` method we pass a method reference. We can use this
    mechanism in a lambda expression if it only calls to an existing method as in
    this case.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The second collect operation we will implement will concatenate all the names
    of all the persons in the stream. To implement this operation, we use the `toString()`
    method of the `Person` object, the `collect()` method, of the `Stream` class,
    and the `joining()` method of the `Collectors` class that concatenates all the
    elements of the stream separated by the specified char sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'With the next collect operation we''ll implement, we will separate the persons
    on the stream in two groups. The first one will have the persons with a salary
    greater than 50,000 and the second one will have the others. The result of the
    operation will be a `Map` object with a `Boolean` value as the key and a `List`
    of persons as the value. To implement this, we will use the `collect()` method
    of the `Stream` class and the `partitionBy()` method of the `Collectors` class
    that receives as a parameter a `Boolean` expression that allows you two divide
    the elements of the stream in `true` or `false`. Then we use the `forEach()` method
    to write the number of elements in the generated lists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll implement a collect operation that will generate another `Map`.
    In this case, the keys will be the first name of the persons and the value will
    be the last names of the people with the same first name concatenated in one `String`.
    To implement this behavior, we have use the `collect()` method of the `Stream`
    class and the `toConcurrentMap()` method of the `Collectors` class. We pass as
    parameters to that method a lambda expression to obtain the key, a lambda expression
    to obtain the value, and a lambda expression to resolve the situations where the
    key exists in the final `Map`. Then, we use the `forEach()` method to process
    all the keys and write its associated values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Until now, in all the examples of the `collect()` method we have implemented,
    we used the version of that method that receives an implementation of the `Collector`
    interface. But there''s another version of the `collect()` method. With this version
    of the `collect()` method, we will implement a collect operation that generates
    a `List` with the persons who have a salary greater than 50,000\. We pass to the
    `collect()` method an expression to create the `List` (the `List::new` method),
    a lambda expression to process a list and an element of the stream, and an expression
    to process the two lists (the `List::addAll` method):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we'll implement an example that generates a `ConcurrentHashMap` with
    the first names that appears in the list of `People` objects and the number of
    times that each name appears. We will use the first name of the persons as key
    and `Counter` objects as values. The first parameter of the collect method will
    create a new `ConcurrentHashMap` object. The second parameter is an implementation
    of the `BiConsumer` interface that receives as parameters a `ConcurrentHashMap`
    and a `Person`. First, we use the `computeIfPresent()` method of the hash to increment
    the `Counter` of the person if the person exists. Then, we use the `computeIfAbsent()`
    method of the hash to insert a new person name if it doesn't exists. The third
    argument of the `collect()` method is an implementation of the `BiConsumer` interface
    that receives two `ConcurrentHashMap` objects and we use the `merge()` method
    to process all the elements of the second hash and insert them in the first hash
    if they are not present or increment the counters if they are.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the introduction of this recipe, the `collect()` method allows
    you to do a mutable reduction of the elements of a `Stream`. We call it a mutable
    reduction because the final result of the stream will be a mutable data structure,
    such as `Map` or `List`. The `Stream` class of the Java Concurrency API provides
    two versions of the `collect()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one receives only one parameter that is an implementation of the
    `Collector` interface. This interface has seven methods, so you normally won''t
    implement your own collectors. Instead of this, you will use the utility class
    `Collectors`, which has a lot of methods that return ready-to-use `Collector`
    objects for your reduce operations. In our example, we have used the following
    methods of the `Collectors` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`groupingByConcurrent()`: This method returns a `Collector` object that implements
    a group by operating with the elements of `Stream` in a concurrent way, generating
    `Map` as the resultant data structure. It receives as parameter an expression
    to obtain the value of the key used in the map from the element of the stream.
    It generates `Map` where the keys will be of the type returned by the parameter
    expression and the value will be a `List` of elements of the stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joining()`: This method returns `Collector` that concatenates the elements
    of the stream into `String`. You can specify three `CharSequence` objects with
    a separator for the elements, a prefix of the final `String`, and a suffix of
    the final `String`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partitioningBy()`: This method returns `Collector` similar to the first one.
    It receives as parameter a `Boolean` expression with the elements of `Stream`
    and organizes the elements of the stream in two groups: the ones that meet the
    expressions and the ones that don''t. The final result will be `Map` with a `Boolean`
    key and `List` of the type of elements of the stream as value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toConcurrentMap()`: This method returns `Collector` that generates `ConcurrentMap`
    in a concurrent way. It receives three parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression to generate the key from an element of the stream
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression to generate the value from an element of the stream
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression to generate a value from two values when there are two or more
    elements with the same key
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector` has a set of `Characteristics` that define its behavior and can
    be defined or not for a specific collector. For us, the most important is the
    `CONCURRENT` one that indicates if the collector can work in a concurrent way
    or not. In this case, we can''t take advantage of our multicore processor by creating
    only a parallel stream. If we use a collect operation with `Collector`, we have
    to also take into account the value of the `CONCURRENT` characteristic of that
    `Collector`. We will only have a concurrent reduction if the next three conditions
    are true:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Stream` is parallel (we have used `parallelStream()` of the `parallel()`
    methods in the stream)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collector has the `CONCURRENT` characteristic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either the stream is unordered, or the collector has the `UNORDERED` characteristic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, `groupingByConcurrent()` and `toConcurrentMap()` return collectors
    which have the `CONCURRENT` characteristic and the `joining()` and `partitionBy()`
    methods return collectors that don't have such characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s another version of the `collect()` method that can be used
    with parallel streams. This version of the `collect()` method receives the following
    three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: A supplier function that generates a data structure of the type of the final
    result of the collect operation. With parallel streams, this function will be
    called as many times as there are threads executing the operation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accumulator function that receives a data structure and an element of the
    stream and makes the process of the element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combiner function that receives two data structures and generates a unique
    data structure of the same type.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use lambda expressions to implement these functions, but you can also
    implement the `Supplier` interface for the supplier function or the `BiConsumer`
    interface for the accumulator and combiner functions (always parameterized with
    the adequate data types). You can also use method references (`Class::Method`)
    if the input and output parameters are adequate. For example, we have used the
    `List::new` reference as the supplier function and the `List::addAll` method as
    the combiner function. We could use the `List::add` method as the accumulator
    function. There are more methods you can use as parameters to the `collect()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the `groupingByConcurrent()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the output of the `toConcurrentMap()` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Collectors` class has many more methods that return `Collector` objects
    that can be used in the `collect()` method. The following are the most interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '`toList()`: This method returns `Collector` that groups all the elements of
    `Stream` into `List`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toCollection()`: This method returns `Collector` that groups all the elements
    of `Stream` into `Collection`. This method returns as parameter an expression
    that creates `Collection`, which will be used internally by `Collector` and returned
    at the end of its execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`averagingInt()`, `averagingLong()`, and `averagingDouble()`: These methods
    return `Collector` that calculates the average of `int`, `long`, and `double`
    values, respectively. They receive as parameters an expression to convert an element
    of the stream into `int`, `long`, or `double`. The three methods return a double
    value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources* and *Reducing the elements of
    a stream *recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying an action to every element of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to apply an action to all the elements of
    the stream. We will use three methods: two terminal operations, the `forEach()`
    and `forEachOrdered()`, and an intermediate operation, the `peek()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will implement some auxiliary classes we will use in the example.
    Create a class named `Person` with the basic characteristics of a person. Check
    the *Creating streams from different sources* recipe to see the source code of
    this class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we''ll work with methods that depend on the order of the elements of the
    stream, we have to override some methods in the `Person` class. First, we''ll
    override the `compareTo()` method that compares two persons. We''ll create a static
    `Comparator` object using the `Comparator` interface to compare two `Person` objects
    using their first name and last name. Then, we''ll use that comparator in the
    `compareTo()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Then, we override the `equals()` method that determines if two `Person` objects
    are equal. As we made in the `compareTo()` method, we use the `Comparator` static
    object we have created before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we override the `hashCode()` method that calculates a hash value for
    a `Person` object. In Java, equal objects must produce the same hash code, so
    we have to override this method and generate the hash code of a `Person` object
    using the first name and last name attributes and the `hash()` method of the `Objects`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will also use the `PersonGenerator` and `DoubleGenerator`
    classes used in the *Creating streams from different sources* recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the `Main` class with the `main()` method. First, we create a `List`
    of ten random `Person` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll use the `forEach()` method to write the names of all the persons
    of the generated list. The `forEach()` method receives as parameter the expression
    we want to apply to each element. In our case, we use a lambda expression to write
    the information to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you''ll learn how to apply an action to each element in an ordered way.
    First, we create a list of random `Double` numbers using the `DoubleGenerator`
    class. Then, we create a parallel stream, sort the elements of the stream using
    the `sorted()` method, and then use the `forEachOrdered()` method to write the
    numbers to the console in an ordered way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what happens if you sort the elements of the stream but don''t
    use the `forEachOrdered()` method. Repeat the same sentence as before but use
    the `forEach()` method instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll test how the `forEachOrdered()` method works with a stream of
    `Person` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s test the `peek()` method. This method is similar to the `forEach()`
    method, but it''s an intermediate operation. It''s normally used for log purposes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe you learnt how to use three methods to process all the elements
    of a stream and apply an action to them. These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach()`: This is a terminal operation that applies an action to all the
    elements of `Stream` and returns a `void` value. It receives as parameter the
    action to apply to the elements defined as a lambda expression or as an implementation
    of the `Consumer` interface. There''s no guarantee about the order in which the
    action will be applied to the elements of a parallel stream.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachOrdered()`: This is a terminal operation that applies an action to
    all the elements of `Stream` in the order of the stream, if the stream is an ordered
    stream, and returns a void value. You can use this method after the `sorted()`
    method. You first sort the elements of the stream with the `sorted()` method and
    then apply the action in an ordered way using the `forEachOrdered()` method. This
    behavior is guaranteed with parallel streams too, but its performance will be
    worse than the `forEach()` method with unordered streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This is an intermediate operation that returns `Stream` with the
    same elements of the stream that call the method and applies the action specified
    as a parameter to all the elements consumed from the stream. The action applied
    to the elements is specified as a lambda expression or as an implementation of
    the `Consumer` interface. Take into account that, as the intermediate operations
    are lazy, the operation will only be applied to the elements consumed by the stream
    when the terminal operation is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take into account that if you use the sorted method, you have to provide `Comparator`
    that can be applied to the elements you want to sort or the elements of the stream
    must implement the `Comparable` interface. In our case, the `Person` class implements
    that interface and the `compareTo()` method to sort the elements of the stream
    according to their first and last names.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Sorting the elements of a stream* recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the elements of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most commons actions you will apply to a stream will be the filtering
    operation that selects the elements that continue with the processing. In this
    recipe, you will learn the different methods provided by the `Stream` class to
    select the elements of a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class that stores the basic attributes of a person, and
    the `PersonGenerator` class that generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both the classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll implement the `Main` class with the `main()` method. First, create
    a `List` of random `Person` objects using the `PersonGenerator` class. Use the
    `forEach()` method to print the generated elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll eliminate the duplicate objects using the `distinct()` method.
    Use the `forEach()` method to write the elements that pass the filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll test the `distinct()` method with an `Array` of numbers. Create
    an array of numbers repeating some of them. Convert them to a `List` using the
    `asList()` method of the `Arrays` class. Create a parallel stream with the `parallelStream()`
    method, convert the stream into an `IntStream` stream with the `mapToInt()` method,
    use the `distinct()` method to delete the repeated elements, and finally use the
    `forEach()` method to write the final elements to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll get the persons of the random person list with a salary lower than
    3,000 using the filter method and a predicate expressed as a lambda expression
    with that condition. As with the other examples, use the `forEach()` method to
    write the resultant elements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll test the `filter()` method with an `IntStream` getting the numbers
    less than two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll use the `limit()` method to limit the number of elements in the
    stream. For example, create a parallel stream from the random list of persons,
    convert them into a `DoubleStream` with the `mapToDouble()` method, and get the
    first five elements using the `limit()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll use the `skip()` method to ignore a number of elements of the
    stream. Create a parallel stream from the random list of persons, convert them
    into a `DoubleStream` with the `mapToDouble()` method, and ignore the first five
    elements using the `skip()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe we have used four methods to filter the elements in a stream.
    These methods are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`distinct()`: This method returns a stream with the distinct elements of the
    current stream according to the `equals()` method of the elements of the `Stream`
    class. In our case, we have tested this method with `Person` objects and `int`
    numbers. We have implemented the `equals()` and `hashCode()` methods in the `Person`
    class. If we don''t do this, the `equals()` method will only return `true` if
    the two compared objects hold the same reference. Take into account that this
    operation is a stateful operation, so it won''t get a good performance with parallel
    streams (as the Java documentation reflects, ''... under parallel computation,
    some pipelines containing stateful intermediate operations may require multiple
    passes on the data or may need to buffer significant data...'').'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter()`: This method receives a `Predicate` as parameter. This predicate
    can be expressed as a lambda expression that returns a `boolean` value. The `filter()`
    method returns a stream with the elements that make the `Predicate` true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit()`: This method receives an `int` value as a parameter and returns a
    stream with no more than as many number of elements. The performance of this method
    can also be bad with ordered parallel streams, especially when the number of elements
    you want to get is big, because the method will return the first elements of the
    stream and that will imply additional computation. This circumstance doesn''t
    occur with unordered streams because in that case, it doesn''t matter what elements
    are returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip()`: This method returns a stream with the elements of the original stream
    after discarding the first elements. The number of discarded elements is specified
    as the parameter of this method. This method has the same performance problems
    as with the `limit()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stream class also has other two methods that can be used to filter the
    elements of a stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dropWhile()`: This method receives a `Predicate` expression as the parameter.
    It has a different behavior with ordered and unordered streams. With ordered streams,
    the method deletes the first elements that match the predicate from the stream.
    It deletes elements when the elements match the predicate. When it finds an element
    that doesn''t match the predicate, it stops deleting the elements and returns
    the rest of the stream. With unordered streams, its behavior is not deterministic.
    It deletes a subset of elements that match the predicate but is not specified
    what subset of elements it will delete. As with the other methods, it may have
    a bad performance with parallel ordered streams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeWhile()`: This method is equivalent to the previous one, but it takes
    the elements instead of deleting them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream* and
    *Collecting the elements of a stream* recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming the elements of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the most useful intermediate operations you can use with streams are
    those that allow you to transform the elements of the stream. These operations
    receive elements of a class and return the elements of a different class. You
    can even change the type of stream and generate an `IntStream`, `LongStream`,
    or `DoubleStream` from `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the transforming intermediate operations
    provided by the `Stream` class to convert its elements into a different class.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class, which stores the basic attributes of a person, and
    the `PersonGenerator` class, which generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both the classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `BasicPerson`. This class will have a `String` attribute
    named `name` and a `long` attribute named `age`. Create the methods to get and
    set the value of both the attributes. As the source code of this class is very
    simple, it won't be included here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another auxiliary class named `FileGenerator`. This class will have
    a method named `generateFile()` that receives the number of lines in the simulated
    file and returns its content as a `List` of `String`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create the `Main` class with the `main()` method. First, create a list
    of random `Person` objects using the `PersonGenerator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll use the `mapToDouble()` method to convert the stream of `Person`
    objects into `DoubleStream` of double values. Create a parallel stream using the
    `parallelStream()` method and then use the `mapToDouble()` method, passing as
    parameter a lambda expression that receives a `Person` object and returns its
    salary, which is a double number. Then use the `distinct()` method to get the
    unique values and the `forEach()` method to write them to the console. We also
    get the number of different elements written using the `count()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll transform the `Person` objects of the stream into `BasicPerson`
    objects. Create the stream using the `parallelStream()` method and use the `map()`
    method to transform the objects. This method receives as parameter a lambda expression
    that receives a `Person` object, creates a new `BasicPerson` object, and establishes
    the value of its attributes. Then, we write the values of the attributes of the
    `BasicPerson` object using the `forEach()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll learn how to manage the situations where an intermediate operation
    returns `Stream`. In this case, we''ll work with a  `Stream` of streams, but we
    can concatenate all these `Stream` objects into a unique `Stream` using the `flatMap()`
    method. Generate `List<String>` with 100 elements using the `FileGenerator` class.
    Then, create a parallel stream with the `parallelStream()` method. We''ll split
    each line to get its words using the `split()` method, and with the `of()` method
    of the `Stream` class, we convert the resultant `Array` into `Stream`. If we use
    the `map()` method, we are generating a `Stream` of streams, but using the `flatMap()`
    method we''ll get a unique `Stream` of `String` objects with all the words of
    the whole List. Then, we get the words with a length greater than zero with the
    `filter()` method, sort the stream with the `sorted()` method, and collect it
    to `Map` using the `groupingByConcurrent()` method where the keys are the words
    and the values are the number of times each word appears in the stream:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have to implement the `getAge()` method used previously in the
    code. This method receives the date of birth of a `Person` object and returns
    its age:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe you learnt how to convert the elements of the stream using an
    intermediate operation and an expression that makes the conversion between the
    source and the destination types. We used three different methods in our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mapToDouble()`: We used this method to convert `Stream` of objects into `DoubleStream`
    with double numbers as elements. This method receives as parameter a lambda expression
    or an implementation of the `ToDoubleFunction` interface. This expression receives
    an element of `Stream` and has to return a double value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()`: We can use this method when we have to convert the elements of `Stream`
    to a different class. For example, in our case, we convert the `Person` class
    to a `BasicPerson` class. This method receives as parameter a lambda expression
    or an implementation of the `Function` interface. This expression must create
    the new object and initialize its attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMap()`: This method is useful in a more complex situation when you have
    to work with a `Stream` of `Stream` objects and you want to convert them to a
    unique `Stream`. This method receives as parameter a lambda expression or an implementation
    of the `Function` interface as the `map()` function, but in this case, this expression
    has to return a `Stream` object. The `flatMap()` method will automatically concatenate
    all those streams into a unique `Stream`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stream` class provides other methods to transform the elements of a `Stream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`mapToInt()`, `mapToLong()`: These methods are identical to the `mapToDouble()`
    method, but they generate `IntStream` and `LongStream` objects, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMapToDouble()`, `flatMapToInt()`, `flatMapToLong()`: These methods are
    identical to the `flatMap()` method, but they work with `DoubleStream`, `IntStream`,
    and `LongStream`, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Collecting the elements of a stream recipes* in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting the elements of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another typical operation you will want to do with a `Stream` is sorting its
    elements. For example, you may want to sort the elements of the `Stream` by name,
    postal code, or any other numeric value.
  prefs: []
  type: TYPE_NORMAL
- en: With streams, we have other considerations with the so-called encounter order.
    Some streams may have a defined encounter order (it depends on the source of the
    `Stream`). Some operations work with the elements of the stream in its encountered
    ordered, such as `limit()`, `skip()`, and others. This makes that parallel computation
    for this methods doesn't give us good performance. In these cases, you can speed-up
    the execution of these methods by deleting the ordering constraint.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to sort the elements of `Stream` and how
    to delete the ordering constraint in situations where we don't need the encounter
    order of `Stream`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class, which stores the basic attributes of a person, and
    the `PersonGenerator` class, which generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both the classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, implement the `Main` class with the `main()` method. First, we''ll create
    an `Array` of `int` numbers. Then, we''ll create a parallel stream with the `parallelStream()`
    method from this array, use the `sorted()` method to sort the elements of the
    array, and use the `forEachOrdered()` method to write the elements in an ordered
    way. Take into account that this operation won''t use all the power of our multi-core
    processor as it has to write the elements in the specified order:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s try the same principles with a `Stream` of `Person` objects. Create
    a list of 10 random `Person` objects using the `PersonGenerator` class and use
    the same methods, `sorted()` and `forEachOrdered()`, to see how the persons are
    written in an ordered way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we''ll see how to eliminate the encounter order of a data structure
    using the `unordered()` method. First, we''ll create `TreeSet` from our `List`
    of random `Person` objects. We use `TreeSet` because it orders the elements internally.
    Then, we make a loop to repeat the operations ten times and see how there''s a
    difference between the ordered and the unordered operations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we create a stream from `PersonSet` using the `stream()` method, convert
    it to parallel with the `parallel()` method, get the first element with the `limit()`
    method, and return the `Person` object, collecting it to a list and getting the
    first element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we perform the same operation but remove the ordered constraint with the
    `unordered()` method between the `stream()` and `parallel()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are `Stream` objects that may have an encounter order depending on its
    source and the intermediate operations you have applied before. This encounter
    order imposes a restriction about the order in which the elements must be processed
    by certain methods. For example, if you use the `limit()` or `skip()` methods
    in `Stream` with an encounter order, they will get and ignore the first elements
    according to that encounter order. There are other operations, such as the `forEach()`
    method, that don't take into account the encounter order. If you apply the same
    operations to a stream with an encounter order, the result will always be the
    same. If the stream doesn't have an encounter order, the results may vary.
  prefs: []
  type: TYPE_NORMAL
- en: When you work with sequential streams, the encounter order doesn't have any
    impact on the performance of the application, but with parallel streams it can
    affect it greatly. Depending on the operations, it would be necessary to process
    more than once the elements of `Stream` or to store in a buffer a big amount of
    data. In this case, removing the encounter order using the `unordered()` method,
    as we did in this recipe, will significantly increase the performance of the application.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `sorted()` method sorts the elements of the `Stream`.
    If you use this method, the elements of `Stream` must implement the `Comparable`
    interface. Otherwise, you can pass a `Comparator` as a parameter that will be
    used to sort the elements. If you use this method, you are creating an ordered
    stream, so all the things explained before to the streams with an encounter order
    are applicable to the resultant stream.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `forEach()` method doesn't take into account the encounter order
    of the stream. If you want to take this encounter order into account, say, to
    write the elements of the stream order after sorting them, you can use the `forEachOrdered()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can see that when you call the `limit(1)` method in the parallel stream
    generated from `TreeSet`, you always obtain the same result because the Stream
    API respects the encounter order of that structure. But when we include a call
    to the `unordered()` method, the encounter order is not taken into account and
    the result obtained should vary, as in this case.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the `unordered()` method, you're not executing any code that internally
    changes the order of the elements in the data structure. You're only deleting
    a condition that would be taken into account for some methods otherwise. It's
    possible that the results of a stream with the `unordered()` method and the results
    of the same stream without the method are equal. Its use may have consequences
    in possibly giving different processing results for parallel streams. For example,
    if you try our example using a `List` of `Person` objects instead of `personSet` a
    `TreeSet`, you will always obtain the same result in both the cases.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, the main purpose of the `unordered()` method is to delete
    a constraint that limits the performance of parallel streams.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Collecting the elements of a stream* recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying conditions in the elements of a stream
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One interesting option provided by the `Stream` class is the possibility to
    check if the elements of the stream verify a condition or not. This functionality
    is provided by the terminal operations that return a `Boolean` value.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn which methods provide the `Stream` class to check
    conditions in the elements of a stream and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class, which stores the basic attributes of a person, and
    the `PersonGenerator` class, which generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both classes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create the `Main` class with the `main()` method. First, we''ll create
    a `List` of random `Person` objects using the `PersonGenerator` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, calculate the maximum and minimum values of the salary field to verify
    that all our calculations are correct. We use two streams for the calculation,
    the first one with the `map()` and `max()` methods and the second one with the
    `mapToInt()` and `min()` methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll test some conditions. First, let''s verify that all the `Person`
    objects generated have a salary greater than zero with the `allMatch()` method
    and the corresponding lambda expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We repeat the condition to test if all the salaries are greater than 10,000
    and 30,000.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we''ll use the `anyMatch()` method to test if there is someone with a
    salary greater than 50,000 and 100,000:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: To finish this block of tests, we use the `noneMatch()` method to verify that
    there's none with a salary greater than 100,000
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we use the `findAny()` method to get a random element of the stream
    of `Person` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use the `findFirst()` method to get the first element of the stream
    of Person objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we sort the stream by salary using the `sorted()` method, passing
    `Comparator` expressed as a lambda expression, and use the `findFirst()` method
    to obtain, in this case, the `Person` object with the lowest salary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we used three different methods to verify conditions over the
    elements of a Stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '`allMatch()`: This method is a terminal operation that receives as parameter
    an implementation of the `Predicate` interface expressed as a lambda expression
    or as an object that implements it and returns a `Boolean` value. It returns `true`
    if the `Predicate` introduced is true for all the elements of the `Stream` and
    `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anyMatch()`: This method is a terminal operation that receives as parameter
    an implementation of the `Predicate` interface expressed as a lambda expression
    or as an object that implements it and returns a `Boolean` value. It returns `true`
    if the `Predicate` introduced is `true` for at least one of the elements of the
    `Stream` and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noneMatch()`: This method is a terminal operation that receives as parameter
    a `Predicate` expressed as a lambda expression or as an implementation of interface
    and returns a `Boolean` value. It returns `true` if the `Predicate` introduced
    is false for all the elements of the Stream and `false` otherwise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also used two methods to obtain the elements of `Stream`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`findAny()`: This method is a terminal operation that doesn''t receive parameters
    and returns an `Optional` object parameterized with the class of the elements
    of `Stream` with some element of `Stream`. There''s no guarantee about the element
    returned by this method. If `Stream` has no elements, the `Optional` object returned
    will be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findFirst()`: This method is a terminal operation that doesn''t receive parameters
    and returns an `Optional` parameterized with the class of the elements of `Stream`.
    It returns the first element of `Stream` if the stream has a determined encounter
    order or any element if the stream has no encounter order. If `Stream` has no
    elements, the `Optional` returned will be empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we used an interface and a class provided by the Java API. The
    `Predicate` interface is a functional interface that is usually expressed as a
    lambda expression. This expression will receive an element of `Stream` and return
    a `Boolean` value. If you want to implement a class that implements this interface,
    you only have to implement the `test()` method that receives an object of the
    parameterized type and returns a `Boolean` value. The interface defines more methods,
    but they have a default implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The `Optional` class is used when a terminal operation of `Stream` may or may
    not return a value. In this way, Java guarantees that the operation will always
    return a value, the `Optional` object, that may have a value we obtain using the
    `get()` method or may be an empty object, the condition we can check with the
    `isPresent()` method. If you use the `get()` method with an empty `Optional` object,
    a `NoSuchElementException` will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream* and
    *Collecting the elements of a stream* recipes in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming with reactive streams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactive streams** ([http://www.reactive-streams.org/](http://www.reactive-streams.org/))
    define a mechanism to provide asynchronous stream processing with non-blocking
    back pressure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive streams are based on the following three elements:'
  prefs: []
  type: TYPE_NORMAL
- en: A publisher of information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more subscribers of that information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A subscription between the publisher and a consumer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reactive streams specification determines how these classes should interact
    among them, according to the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The publisher will add the subscribers that want to be notified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscriber receives a notification when they're added to a publisher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscribers request one or more elements from the publisher in an asynchronous
    way, that is to say, the subscriber requests the element and continues with the
    execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the publisher has an element to publish, it sends it to all its subscribers
    that have requested an element
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned before, all this communication is asynchronous, so we can take
    advantage of all the power of our multi-core processor.
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 has included three interfaces, the `Flow.Publisher`, the `Flow.Subscriber`,
    and the `Flow.Subscription`, and a utility class, the `SubmissionPublisher` class,
    to allow us to implement reactive stream applications. In this recipe, you will
    learn how to use all these elements to implement a basic reactive stream application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Item` that will represent the items of information sent
    from the publisher to the subscribers. This class has two `String` attributes,
    named `title` and `content`, and the methods to `get()` and `set()` their values.
    Its source code is very simple, so it won't be included here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a class named `Consumer1` and specify that it implements the `Subscriber`
    interface parameterized with the `Item` class. We have to implement four methods.
    First, we implement the `onComplete()` method. It simply writes a message to the
    console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we implement the `onError()` method. It simply writes information about
    the error to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we implement the `onNext()` method. It simply writes information about
    the received item to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we implement the `onSubscribe()` method. It simply writes a message
    to the console and doesn''t request any item using the `request()` method of the
    `Subscription` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, it''s time for the `Consumer2` class. Specify that it also implements
    the `Subscriber` interface parameterized with the `Item` class. In this case,
    we have a private `Subscription` attribute to store the subscription object. The
    `onComplete()` and `onError()` methods are equivalent to the ones of the `Consumer1`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onNext()` method has an additional line to request another element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onSubscribe()` method also has an additional line to request the first
    element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, implement a class called `Consumer3` and specify that it implements the
    `Subscriber` interface parameterized with the `Item` class. The `onComplete()`
    and `onError()` methods are equivalent to those of the previous classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onNext()` method, in this case, writes information about the item to the
    console but doesn''t request any element:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onSubscribe()`, method we request three items:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, implement the `Main` class with the `main()` method. First, create
    three consumers, one of each class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a `SubmissionPublisher` object parameterized with the `Item` class
    and add the three consumers using the `subscribe()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create ten `Item` objects and publish them using the `submit()` method
    of the `SubmissionPublisher` object. Wait a second between each item:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, close the publisher with the `close()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of reactive streams is provide a mechanism to process asynchronous
    stream of data with non-blocking back pressure. We want that the receivers of
    information optimize their resources. As the mechanism is asynchronous, receivers
    don't need to use their resources to look for new elements. They will be called
    when a new element comes in. The non-blocking back pressure allows receivers to
    consume new elements only when the receivers are ready, so they can use a bounded
    queue to store the incoming elements and they won't be saturated by producers
    of new elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reactive streams in Java are based on three interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Flow.Publisher`: This interface has only one method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe()`: This method receives a `Subscriber` object as parameter. The
    publisher should take this subscriber into account when it publishes an Item.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flow.Subscriber`: This interface has four methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete()`: This method will be called when the `Publisher` has finished
    its execution'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError()`: This method will be called when there is an error that must be
    notified to the subscribers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNext()`: This method will be called when the `Publisher` has a new element'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubscribe()`: This method will be called when the publisher has added the
    subscriber with the `subscribe()` method'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flow.Subscription`: This interface has one methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request()`: This method is used by the `Subscriber` to request an element
    from the publisher'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take into account that these are only interfaces and you can implement them
    and use them as you want. The supposed flow is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Someone calls the `subscribe()` method of a `Publisher`, sending it a `Subscriber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Publisher` creates a `Subscription` object and sends it to the `onSubscribe()`
    method of the `Subscriber`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Subscriber` uses the `request()` method of the `Subscription` to request
    elements to the `Publisher`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the publisher has an element to publish, it sends them to all `Subscribers`
    that have requested elements, calling their `onNext()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the publisher ends its execution, it calls the `onComplete()` method of
    the subscribers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java API provides the `SubmissionPublisher` class that implements the Publisher
    interface and implements this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the example and you can see how
    the behavior of the reactive streams is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The three `Subscriber` objects receive their `Subscription`. As `Consumer1`
    doesn't request any `Item`, it won't receive them. `Consumer3` has requested three,
    so you will see in the output of the example that it will receive those three
    `Item` objects. Finally, the `Consumer2` object will receive the ten `Item` objects
    and the notification about the end of execution of the `Publisher`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an additional interface that should be used with reactive streams.
    It's the `Flow.Processor` interface and groups the `Flow.Publisher` and the `Flow.Subscriber`
    interfaces. Its main purpose is to be an element between a publisher and a subscriber
    to transform the elements produced by the first one into a format that can be
    processed by the second one. You can have more than one processors in a chain
    so the output of one of them could be processed by the next one.
  prefs: []
  type: TYPE_NORMAL
- en: Java also defines the `Flow` class that includes the four interfaces explained
    before.
  prefs: []
  type: TYPE_NORMAL
