- en: Parallel and Reactive Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并行和响应式流
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Creating streams from different sources
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不同的源创建流
- en: Reducing the elements of a stream
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归约流中的元素
- en: Collecting the elements of a stream
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集流中的元素
- en: Applying an action to every element of a stream
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对流中的每个元素应用操作
- en: Filtering the elements of a stream
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤流中的元素
- en: Transforming the elements of a stream
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换流中的元素
- en: Sorting the elements of a stream
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排序流中的元素
- en: Verifying conditions in the elements of a stream
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证流中元素的条件
- en: Reactive programming with reactive streams
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用响应式流的响应式编程
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: A **stream** in Java is a sequence of elements that can be processed (mapped,
    filtered, transformed, reduced, and collected) in a pipeline of declarative operations
    using **lambda expressions** in a sequential or parallel way. It was introduced
    in Java 8 and was one of the most significant new features of that version, together
    with lambda expressions. They have changed the way you can process big sets of
    elements in Java, optimizing the way the language processes those elements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Java中的**流**是一系列可以按声明性操作（映射、过滤、转换、归约和收集）处理的元素序列，使用**lambda表达式**以顺序或并行方式。它在Java
    8中引入，是该版本最显著的新特性之一，与lambda表达式一起。它们改变了你在Java中处理大量元素的方式，优化了语言处理这些元素的方式。
- en: Streams have introduced the `Stream`, `DoubleStream`, `IntStream` and `LongStream`
    interfaces, some utility classes such as `Collectors` or `StreamSupport`, some
    functional-like interfaces such as `Collector`, and a lot of methods in different
    classes such as the `stream()` or `parallelStream()` methods in the `Collection`
    interface or the `lines()` method in the `Files` class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 流引入了`Stream`、`DoubleStream`、`IntStream`和`LongStream`接口，一些实用类如`Collectors`或`StreamSupport`，一些类似函数式的接口如`Collector`，以及在不同类中的许多方法，例如`Collection`接口中的`stream()`或`parallelStream()`方法，或者`Files`类中的`lines()`方法。
- en: 'Through the recipes of this chapter, you will learn how to effectively use
    streams in your application, but before that let''s see the most important characteristics
    of streams:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章的食谱，你将学习如何在你的应用程序中有效地使用流，但在那之前，让我们看看流最重要的特性：
- en: A stream is a sequence of data, not a data structure. Elements of data are processed
    by the stream but not stored in it.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流是一系列数据，而不是数据结构。数据元素由流处理，但不存储在其中。
- en: You can create streams from different sources, such as collections (lists, arrays
    and so on), files, and strings, or by creating a class that provides the elements
    of the stream.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以从不同的源创建流，例如集合（列表、数组等）、文件和字符串，或者通过创建一个提供流元素的类。
- en: You can't access an individual element of the streams. You define the source
    of the stream and the operations you want to apply to its elements. Stream operations
    are defined in a functional way, and you can use lambda expressions in intermediate
    and terminal operations to define the actions you want to execute.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能访问流中的单个元素。你定义流的源和想要对其元素应用的操作。流操作以函数式方式定义，你可以在中间和终端操作中使用lambda表达式来定义你想要执行的操作。
- en: You can't modify the source of the stream. If, for example, you filter some
    elements of the stream, you are skipping the elements on the stream and not in
    its source.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你不能修改流的源。例如，如果你过滤了流中的某些元素，你是在跳过流上的元素，而不是其源。
- en: 'Streams define two kinds of operations:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流定义了两种类型的操作：
- en: '**Intermediate operations**: These operations always produce a new stream with
    their results. They can be used to transform, filter, and sort the elements of
    the stream.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间操作**：这些操作总是产生一个包含其结果的新流。它们可以用来转换、过滤和排序流中的元素。'
- en: '**Terminal operations**: These operations process all the elements of the stream
    to generate a result or a side-effect. After their execution, the stream can''t
    be used again.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端操作**：这些操作处理流中的所有元素以生成一个结果或副作用。执行后，流不能再使用。'
- en: A stream pipeline is formed by zero or more intermediate operations and a final
    operation.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流管道由零个或多个中间操作和一个最终操作组成。
- en: 'Intermediate operations can be as follows:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间操作可以是以下几种：
- en: '**Stateless**: Processing an element of the stream is independent of the other
    elements. For example, filtering an element based on a condition.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无状态**：处理流中的元素与其他元素无关。例如，根据条件过滤一个元素。'
- en: '**Stateful**: Processing an element of the stream depends on the other elements
    of the stream. For example, sorting the elements of the stream.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**有状态**：处理流中的元素依赖于流中的其他元素。例如，对流的元素进行排序。'
- en: '**Laziness**: Intermediate operations are lazy. They''re not executed until
    the terminal operation begins its execution. Java can avoid the execution of an
    intermediate operation over an element or a set of elements of the stream if it
    detects that it doesn''t affect the final result of the operation.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**惰性**：中间操作是惰性的。它们不会在终端操作开始执行之前执行。如果Java检测到中间操作不会影响操作的最后结果，它可以避免对流的元素或元素集合执行中间操作。'
- en: '`Stream` can have an infinite number of elements. There are operations such
    as `limit()` or `findFirst()` that can be used to limit the elements used in the
    final computation. As the intermediate operations are lazy, an unbounded stream
    can finish its execution in a finite time.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream`可以有无限数量的元素。有一些操作，如`limit()`或`findFirst()`，可以用来限制在最终计算中使用的元素。由于中间操作是惰性的，无界流可以在有限的时间内完成其执行。'
- en: Streams can only be used once. As we mentioned before, when the terminal operation
    of a stream is executed, the stream is considered consumed, and it can't be used
    again. If you need to process the same data again to generate different results,
    you have to create a new `Stream` object from the same source. If you try to use
    a consumed stream, you will get an exception.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流只能使用一次。正如我们之前提到的，当流的终端操作执行时，流被认为是消耗掉的，不能再使用。如果你需要再次处理相同的数据以生成不同的结果，你必须从相同的源创建一个新的`Stream`对象。如果你尝试使用已消耗的流，你会得到一个异常。
- en: You can process the elements of a stream sequentially or in a parallel way without
    any extra effort. You can specify the mode of execution of a stream more than
    once, but only the last time will be taken into account. You have to be careful
    with the selected mode. Stateful intermediate operations won't use all the possibilities
    of concurrency.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以不费任何额外努力以顺序或并行方式处理流中的元素。你可以多次指定流的执行模式，但只有最后一次将被考虑。你必须小心选择模式。有状态的中间操作不会使用并发的所有可能性。
- en: Java 9 has included a new kind of streams-the reactive streams-that allow you
    to communicate information to producers and consumers in an asynchronous way.
    This chapter presents nine recipes that will teach you how to create streams and
    use all their intermediate and terminal operations to process big collections
    of data in a parallel and functional way.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了一种新的流类型——响应式流，允许你以异步方式与生产者和消费者通信。本章介绍了九种食谱，将教会你如何创建流并使用它们的所有中间和终端操作以并行和函数式的方式处理大量数据集。
- en: Creating streams from different sources
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从不同的源创建流
- en: 'In this recipe, you will learn how to create streams from different sources.
    You have different options, as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，你将学习如何从不同的源创建流。你有不同的选项，如下所示：
- en: The `parallelStream()` method of the `Collection` interface
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Collection`接口的`parallelStream()`方法'
- en: The `Supplier` interface
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Supplier`接口'
- en: A predefined set of elements
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预定义的元素集合
- en: '`File` and a directory'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File`和一个目录'
- en: An array
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个数组
- en: A random number generator
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机数生成器
- en: The concatenation of two different streams
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个不同流的连接
- en: You can create a `Stream` object from other sources (that will be described
    in the *There's more* section), but we think that these are the more useful.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从其他源（将在“更多内容”部分中描述）创建`Stream`对象，但我们认为这些更有用。
- en: Getting ready
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例是使用Eclipse IDE实现的。如果你使用Eclipse或其他IDE，如NetBeans，请打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'In this recipe we''ll implement an example where you will learn how to create
    streams from the sources described earlier. Follow these steps to implement the
    example:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将实现一个示例，你将学习如何从前面描述的源创建流。按照以下步骤实现示例：
- en: 'First, we''ll implement some auxiliary classes that we will use in the example.
    Create a class named `Person` with six attributes of different types: `String`,
    `int`, `double` and `Date`:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现一些辅助类，我们将在示例中使用这些类。创建一个名为`Person`的类，具有六种不同类型的属性：`String`、`int`、`double`和`Date`：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Create the methods to set and get the values of these attributes. Implement
    the `comparteTo()` method to compare two `Person` objects. Let's consider that
    two persons are the same it they have the same `firstName` and the same `lastName`
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建设置和获取这些属性值的`set`和`get`方法。实现`comparteTo()`方法来比较两个`Person`对象。让我们考虑两个人员相同，如果他们有相同的`firstName`和相同的`lastName`：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, create a class named `PersonGenerator` to create a random list of `Person`
    objects. Implement a static method named `generatePersonList()` in this class
    , which receives the number of persons you want to generate and returns a `List<Person>`
    object with the number of persons. Here, we include a version of this method,
    but feel free to change it:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`PersonGenerator`的类来创建一个随机的`Person`对象列表。在这个类中实现一个名为`generatePersonList()`的静态方法，该方法接收要生成的人员的数量，并返回一个包含指定人员数量的`List<Person>`对象。这里包括这个方法的版本，但你可以自由地更改它：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, create a class named `MySupplier` and specify that it implements the `Supplier`
    interface parameterized with the `String` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`MySupplier`的类，并指定它实现了参数化为`String`类的`Supplier`接口：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Declare a private `AtomicInteger` attribute named `counter` and initialize
    it in the constructor of the class:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`counter`的私有`AtomicInteger`属性，并在类的构造函数中初始化它：
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Implement the `get()` method defined in the `Supplier` interface. This method
    will return the next element of the stream:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现定义在`Supplier`接口中的`get()`方法。此方法将返回流的下一个元素：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, create a class named `Main` and implement the `main()` method in it:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`Main`的类并在其中实现`main()`方法：
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, we''ll create a `Stream` object from a list of elements. Create the
    `PersonGenerator` class to create a list of 10,000 `Person` objects, and use the
    `parallelStream()` method of the `List` object to create the `Stream`. Then, use
    the `count()` method of the `Stream` object to get the number of elements of the
    `Stream`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将从元素列表中创建一个`Stream`对象。创建一个名为`PersonGenerator`的类来创建10,000个`Person`对象的列表，并使用`List`对象的`parallelStream()`方法创建`Stream`。然后，使用`Stream`对象的`count()`方法获取流的元素数量：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we''ll create a `Stream` from a generator. Create an object of the `MySupplier`
    class. Then, use the static method `generate()` of the `Stream` class, passing
    the created object as a parameter to create the stream. Finally, use the `parallel()`
    method to convert the stream created to a parallel stream, the `limit()` method
    to get the first ten elements of the stream, and the `forEach()` method to print
    the elements of the stream:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从生成器创建一个`Stream`。创建`MySupplier`类的对象。然后，使用`Stream`类的静态方法`generate()`，将创建的对象作为参数传递以创建流。最后，使用`parallel()`方法将创建的流转换为并行流，使用`limit()`方法获取流的第一个十个元素，并使用`forEach()`方法打印流的元素：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, we''ll create a stream from a predefined list of elements. Use the static
    `of()` method of the `Stream` class to create the `Stream`. This method receives
    a variable list of parameters. In this case, we''ll pass three `String` objects.
    Then, use the `parallel()` method of the stream to convert it to a parallel one
    and the `forEach()` method to print the values in the console:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将从一个预定义的元素列表中创建一个流。使用`Stream`类的静态`of()`方法来创建`Stream`。此方法接收一个可变数量的参数。在这种情况下，我们将传递三个`String`对象。然后，使用流的`parallel()`方法将其转换为并行流，并使用`forEach()`方法在控制台打印值：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we''ll create a stream to read the lines of a file. First, create a `BufferedReader`
    object to read the file you want to read. Then, use the `lines()` method of the
    `BufferedReader` class to get a stream of `String` objects. Each element of this
    stream will be a line from the file. Finally, use the `parallel()` method to get
    a parallel version of the stream and the `count()` method to get the number of
    elements of the `Stream`. We also have to close the `BufferedReader` object:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个流来读取文件的行。首先，创建一个`BufferedReader`对象来读取你想要读取的文件。然后，使用`BufferedReader`类的`lines()`方法获取一个`String`对象的流。此流的每个元素都将是从文件中的行。最后，使用`parallel()`方法获取流的并行版本，并使用`count()`方法获取`Stream`的元素数量。我们还需要关闭`BufferedReader`对象：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we''ll create a `Stream` to process the contents of a folder. First, use
    the `list()` method of the `Files` class to get a stream of `Path` objects with
    the contents of the folder. Then, use the `parallel()` method of the `Stream`
    object to convert it to a parallel stream and the `count()` method to count its
    elements. Finally, in this case, we have to use the `close()` method to close
    the Stream:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个`Stream`来处理文件夹的内容。首先，使用`Files`类的`list()`方法获取包含文件夹内容的`Path`对象流。然后，使用`Stream`对象的`parallel()`方法将其转换为并行流，并使用`count()`方法来计算其元素数量。最后，在这种情况下，我们必须使用`close()`方法来关闭Stream：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The next source we''ll use is an `Array`. First, create an `Array` of strings.
    Then, use the `stream()` method of the `Arrays` class to create a stream from
    the elements of the array. Finally, use the `parallel()` method to convert the
    stream into a parallel one and the `forEach()` method to print the elements of
    the stream to the console:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来要使用的是`Array`。首先，创建一个字符串数组。然后，使用`Arrays`类的`stream()`方法从数组的元素创建一个流。最后，使用`parallel()`方法将流转换为并行流，并使用`forEach()`方法将流中的元素打印到控制台：
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we''ll create a stream of random double numbers. First, create a `Random`
    object. Then, use the `doubles()` method to create a `DoubleStream` object. We''ll
    pass the number `10` as a parameter to that method, so the stream we''re going
    to create will have ten elements. Finally, use the `parallel()` method to convert
    the stream into a parallel one, the `peek()` method to write each element to the
    console, the `average()` method to calculate the average of the values of the
    stream, and the `getAsDouble()` method to get the value stored in the `Optional`
    object returned by the `average()` method:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个随机双精度浮点数流。首先，创建一个`Random`对象。然后，使用`doubles()`方法创建一个`DoubleStream`对象。我们将传递数字`10`作为该方法的参数，因此我们将创建一个包含十个元素的流。最后，使用`parallel()`方法将流转换为并行流，使用`peek()`方法将每个元素写入控制台，使用`average()`方法计算流中值的平均值，并使用`getAsDouble()`方法获取由`average()`方法返回的`Optional`对象中存储的值：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, we''ll create a stream concatenating two streams. First, we create
    two streams of `String` objects using the `of()` method of the `Stream` class.
    Then, we use the `concat()` method of the `Stream` class to concatenate those
    streams into a unique one. Finally, we use the `parallel()` method of the `Stream`
    class to convert the stream into a parallel one and the `forEach()` method to
    write all the elements to the console:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将创建一个连接两个流的流。首先，使用`Stream`类的`of()`方法创建两个`String`对象流。然后，使用`Stream`类的`concat()`方法将那些流连接成一个唯一的流。最后，使用`Stream`类的`parallel()`方法将流转换为并行流，并使用`forEach()`方法将所有元素写入控制台：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Let''s see in detail all the methods we used in this example to create streams:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看在这个例子中我们使用的所有创建流的方法：
- en: First, we used the `parallelStream()` method of the `List` class. In fact, this
    method is defined in the `Collection` interface, so all the classes that implement
    this interface, such as the `ArrayList`, `LinkedList`, or `TreeSet` classes implement
    that method. You can use the `stream()` method to create a sequential stream or
    the `parallelStream()` method to create a parallel one.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们使用了`List`类的`parallelStream()`方法。实际上，这个方法是在`Collection`接口中定义的，所以所有实现这个接口的类，例如`ArrayList`、`LinkedList`或`TreeSet`类，都实现了这个方法。你可以使用`stream()`方法创建一个顺序流，或者使用`parallelStream()`方法创建一个并行流。
- en: 'Then, we used an implementation of the `Supplier` interface: the `MySupplier`
    class. The interface provides the `get()` method. This method is called each time
    the stream needs an element to process. You can create a stream with an infinite
    number of elements, so you should use a method that limits the number of elements
    of the stream, such as the `limit()` method.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用了`Supplier`接口的一个实现：`MySupplier`类。该接口提供了`get()`方法。每次流需要处理一个元素时都会调用这个方法。你可以创建一个包含无限多个元素的流，因此你应该使用一个限制流中元素数量的方法，例如`limit()`方法。
- en: Then, we used the `of()`method of the `Stream` class. This is a static method
    that receives a variable number of parameters and returns a `Stream` with those
    parameters as elements.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用了`Stream`类的`of()`方法。这是一个接收可变数量参数的静态方法，并返回一个包含这些参数作为元素的`Stream`。
- en: Then, we used the `lines()` method of the `BufferedStream` class. This method
    returns a stream where each element is a line read from the `BufferedStream`.
    We used this method to read all the lines of a file, but you can use it with other
    kinds of `BufferedReader`.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用了`BufferedStream`类的`lines()`方法。此方法返回一个流，其中每个元素是从`BufferedStream`中读取的一行。我们使用此方法来读取文件的所有行，但您也可以使用它与其他类型的`BufferedReader`一起使用。
- en: Then, we used the `list()` method of the `Files` class. This method receives
    a `Path` object representing a folder of your system and returns a `Stream` of
    `Path` objects with the elements into that folder. You have to take into account
    that this method is not recursive, so if the folder has one or more subfolders,
    it doesn't process their content. As you will see later in the *There's more*
    section, the `Files` class has other methods to work with streams.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用了`Files`类的`list()`方法。此方法接收一个表示系统文件夹的`Path`对象，并返回一个包含该文件夹中元素的`Path`对象的`Stream`。您必须考虑到此方法不是递归的，因此如果文件夹有一个或多个子文件夹，它不会处理它们的内容。正如您将在后面的*更多内容*部分中看到的那样，`Files`类有其他方法可以用来处理流。
- en: Then, we used the `stream()` method of the `Arrays` class that receives an array
    and returns a `Stream` with the elements of the array. If the array is of the
    `double`, `int`, or `long` types, it returns a `DoubleStream`, `IntStream`, or
    `LongStream` object. These are special kinds of streams that allow you to work
    with such number types.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们使用了`Arrays`类的`stream()`方法，它接收一个数组并返回一个包含数组元素的`Stream`。如果数组是`double`、`int`或`long`类型，它返回一个`DoubleStream`、`IntStream`或`LongStream`对象。这些都是特殊的流类型，允许您处理此类数字类型。
- en: Then, we generated a stream with random numbers. We used the `doubles()` method
    of the `Random` class. We passed to it the size of the `Stream` we wanted to obtain,
    but you can also pass to it the minimum and maximum numbers you want to obtain.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们生成了一个包含随机数的流。我们使用了`Random`类的`doubles()`方法。我们传递给它我们想要获得的`Stream`的大小，但您也可以传递给它您想要获得的最低和最高数字。
- en: Finally, we used the `concat()` method of the `Stream` class that takes two
    streams and returns one with the elements of both.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们使用了`Stream`类的`concat()`方法，它接受两个流并返回一个包含两个流元素的流。
- en: 'We also used some methods of the `Stream` class. Most of them will be described
    later in more detail, but here we provide a basic introduction to them:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还使用了`Stream`类的一些方法。其中大部分将在稍后的详细描述中介绍，但在这里我们提供它们的基本介绍：
- en: '`count()`: This method returns the number of elements in the `Stream`. It''s
    a terminal operation and returns a `long` number.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count()`: 此方法返回`Stream`中的元素数量。这是一个终端操作，并返回一个`long`类型的数字。'
- en: '`limit()`: This method receives a number as a parameter. If the stream has
    fewer elements than the number, it returns a stream with all the elements. Otherwise,
    it returns a stream with the number of elements specified in the parameter. It''s
    an intermediate operation.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limit()`: 此方法接收一个数字作为参数。如果流中的元素少于该数字，它返回一个包含所有元素的流。否则，它返回一个包含指定参数中元素数量的流。这是一个中间操作。'
- en: '`forEach()`: This method allows you to specify an action that will be applied
    to each of the elements of the `Stream`. We used this terminal operation to write
    some information to the console. We have used a lambda expression with this purpose.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach()`: 此方法允许您指定一个将应用于`Stream`中每个元素的行动。我们使用这个终端操作将一些信息写入控制台。我们使用lambda表达式来完成这个目的。'
- en: '`peek()`: This method is an intermediate operation that allows you to perform
    an action over each of the elements of the stream and returns a stream with the
    same elements. This method is usually used as a debugging tool. Take into account
    that, like all intermediate operations, this is a lazy operation, so it will only
    be executed over those elements that are requested by the terminal operation.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`peek()`: 这是一个中间操作，允许您对流的每个元素执行一个操作，并返回一个包含相同元素的流。此方法通常用作调试工具。请注意，像所有中间操作一样，这是一个延迟操作，因此它只会在终端操作请求的元素上执行。'
- en: '`average()`: This is a method that is declared in the `IntStream`, `DoubleStream`,
    and `LongStream` streams. It returns an `OptionalDouble` value. The `OptionalDouble`
    class represents a double number that can have a value or not. It won''t generate
    a value for an empty `Stream`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`average()`: 这是一个在`IntStream`、`DoubleStream`和`LongStream`流中声明的方法。它返回一个`OptionalDouble`值。`OptionalDouble`类表示一个可能具有值或没有值的双精度浮点数。对于空的`Stream`，它不会生成值。'
- en: '`parallel()`: This method converts a sequential `Stream` into a parallel one.
    Most of the streams created in this example are sequential, but we can convert
    them into parallel ones using this method of the `Stream` class.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parallel()`: 此方法将顺序 `Stream` 转换为并行流。本例中创建的大多数流都是顺序的，但我们可以使用 `Stream` 类的此方法将它们转换为并行流。'
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The Java API includes other methods to create `Stream` objects. In this section,
    we enumerate some of them:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Java API 包含其他创建 `Stream` 对象的方法。在本节中，我们列举了一些：
- en: 'The `Files` class provides more methods that create streams:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Files` 类提供了更多创建流的方法：'
- en: '`find()`: This method returns the files contained in a folder, or in any of
    its subfolders, which meet the criteria specified in a lambda expression.'
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`find()`: 此方法返回符合 lambda 表达式中指定条件的文件夹中的文件，或其任何子文件夹中的文件。'
- en: '`walk()`: This method returns a stream of `Path` objects with the contents
    of a folder and all its subfolders.'
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`walk()`: 此方法返回一个包含文件夹及其所有子文件夹内容的 `Path` 对象流。'
- en: 'The `Stream` class also includes other static methods that allow you to create
    streams:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Stream` 类还包括其他静态方法，允许你创建流：'
- en: '`iterate()`: This method produces a stream whose elements are generated by
    the application of a unary function to an initial element. The first element of
    the stream is the initial element, the second element, the result of applying
    the function to the initial element, the third, the result of applying the function
    to the second element, and so on.'
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`iterate()`: 此方法生成一个流，其元素是通过将一元函数应用于初始元素生成的。流的第一个元素是初始元素，第二个元素是应用函数到初始元素的结果，第三个元素是应用函数到第二个元素的结果，依此类推。'
- en: Finally, the `String` class has the `chars()` method. This method returns an
    `IntStream` with the values of the characters that forms the `String`.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，`String` 类有 `chars()` 方法。此方法返回一个包含构成 `String` 的字符值的 `IntStream`。
- en: See also
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Now that you have created a stream, you have to process its elements. All the
    recipes in this chapter give you information about how to go about processing
    the elements of a stream.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了一个流，你必须处理其元素。本章中的所有食谱都为你提供了有关如何处理流元素的信息。
- en: Reducing the elements of a stream
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少流元素
- en: '**MapReduce** is a programming model used to process very large datasets in
    distributed environments using a lot of machines working in a cluster. This programming
    model has the following two operations:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**MapReduce** 是一种编程模型，用于在分布式环境中使用大量在集群中工作的机器处理非常大的数据集。此编程模型具有以下两个操作：'
- en: '**Map**: This operation filters and transforms the original elements into a
    form more suitable to the reduction operation'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Map**: 此操作过滤并转换原始元素，使其更适合减少操作'
- en: '**Reduce**: This operation generates a summary result from all the elements,
    for example, the sum or the average of numeric values'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Reduce**: 此操作从所有元素生成一个汇总结果，例如数值的总和或平均值'
- en: 'This programming model has been commonly used in the functional programming
    world. In the Java ecosystem, the **Hadoop** project of the **Apache Software
    Foundation** provides an implementation of this model. The `Stream` class implements
    two different reduce operations:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编程模型在函数式编程世界中已被广泛使用。在 Java 生态系统中，Apache 软件基金会的 **Hadoop** 项目提供了对此模型的实现。`Stream`
    类实现了两种不同的减少操作：
- en: The pure reduce operation, implemented in the different versions of the `reduce()`
    method that process a stream of elements to obtain a value
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `reduce()` 方法的不同版本中实现的纯减少操作，该操作处理元素流以获取一个值
- en: The mutable reduction implemented in the different versions of the `collect()`
    method that process a stream of elements to generate a mutable data structure,
    such as `Collection` or a `StringBuilder`.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `collect()` 方法的不同版本中实现的可变减少，该操作处理元素流以生成一个可变的数据结构，如 `Collection` 或 `StringBuilder`。
- en: In this recipe, you will learn how to use the different versions of the `reduce()`
    method to generate a result from a stream of values. As you may have already imagined,
    the `reduce()` method is a terminal operation in a `Stream`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，你将学习如何使用 `reduce()` 方法的不同版本从值流生成结果。正如你可能已经想象的那样，`reduce()` 方法是 `Stream`
    中的一个终端操作。
- en: Getting ready
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的示例已使用 Eclipse IDE 实现。如果你使用 Eclipse 或其他 IDE，如 NetBeans，请打开它并创建一个新的 Java 项目。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to implement the example:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: First, we'll create some auxiliary classes that we will use later in the example.
    Review the recipe, *Creating streams from different sources*, and include in this
    example the `Person` and `PersonGenerator` classes used in it.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一些辅助类，我们将在示例的后续部分使用它们。回顾一下 *从不同来源创建流* 的配方，并将此示例中的 `Person` 和 `PersonGenerator`
    类包含在内。
- en: 'Then, create a class named `DoubleGenerator`. Implement a method named `generateDoubleList()`
    to generate a list of double numbers. It receives two parameters with the size
    of the list we''ll generate and the highest value in the list. It will generate
    a list of random double numbers:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为 `DoubleGenerator` 的类。实现一个名为 `generateDoubleList()` 的方法来生成一个双精度浮点数列表。它接收两个参数，分别是我们要生成的列表的大小和列表中的最大值。它将生成一个随机双精度浮点数列表：
- en: '[PRE15]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Implement a method named `generateStreamFromList()`. This method receives a
    `List` of `double` numbers as a parameter and generates a `DoubleStream` stream
    with the elements of the list. For that purpose, we will use the `DoubleStream.Builder`
    class to construct the stream:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个名为 `generateStreamFromList()` 的方法。此方法接收一个 `double` 数字列表作为参数，并生成一个包含列表元素的
    `DoubleStream` 流。为此，我们将使用 `DoubleStream.Builder` 类来构建流：
- en: '[PRE16]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Create a class named `Point` with two double attributes, `x` and `y`, and the
    methods to `get()` and `set()` its value. The code of this class is very simple,
    so it won't be included.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Point` 的类，它有两个双精度属性 `x` 和 `y`，以及获取和设置其值的方法。这个类的代码非常简单，所以不会包含在内。
- en: 'Create a class named `PointGenerator` with a method named `generatePointList()`.
    This method receives the size of the list you want to generate and returns a list
    of random `Point` objects:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `PointGenerator` 的类，其中有一个名为 `generatePointList()` 的方法。此方法接收你想要生成的列表的大小，并返回一个随机
    `Point` 对象的列表：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now create the `Main` class with the `main()` method. First, we''ll generate
    a `List` of 10,000 double numbers using the `DoubleGenerator` class:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个名为 `Main` 的类，其中包含 `main()` 方法。首先，我们将使用 `DoubleGenerator` 类生成一个包含 10,000
    个双精度浮点数的 `List`：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `Stream` class and the specialized `DoubleStream`, `IntStream`, and `LongStream`
    classes implement some methods that are specialized reduce operations. In this
    case, we''ll generate a `DoubleStream` using the `DoubleGenerator` class and use
    `count()`, `sum()`, `average()`, `max()` and `min()` to obtain the number of elements,
    the sum of all the elements, the average of all the elements, the maximum number
    in the stream, and the minimum number in the stream. As we can only process the
    elements of a stream once, we have to create a new stream per operation. Take
    into account that these methods are only present in the `DoubleStream`, `IntStream`,
    and `LongStream` classes. The `Stream` class only has the `count()` method. Some
    of these methods return an optional object. Take into account this object could
    not have any value, so you should check before obtaining the value:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stream` 类以及专门的 `DoubleStream`、`IntStream` 和 `LongStream` 类实现了一些专门化的 reduce
    操作方法。在这种情况下，我们将使用 `DoubleGenerator` 类生成一个 `DoubleStream`，并使用 `count()`、`sum()`、`average()`、`max()`
    和 `min()` 来获取元素数量、所有元素的总和、所有元素的平均值、流中的最大值和最小值。由于我们只能对流的元素进行一次处理，我们必须为每个操作创建一个新的流。请注意，这些方法仅存在于
    `DoubleStream`、`IntStream` 和 `LongStream` 类中。`Stream` 类只有 `count()` 方法。其中一些方法返回一个可选对象。请注意，此对象可能没有任何值，因此在获取值之前应该进行检查：'
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we''ll use the first version of the `reduce()` method. This method receives
    as parameter an associative `BinaryOperator` that receives two objects of the
    same type and returns an object of that type. When the operation has processed
    all the elements of the `Stream`, it returns an `Optional` object parameterized
    with the same type. For example, we''ll use this version to calculate the sum
    of both the coordinates of a random list of `Point` objects:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用 `reduce()` 方法的第一个版本。此方法接收一个参数，即一个关联的 `BinaryOperator`，它接收两个相同类型的对象并返回该类型的对象。当操作处理完
    `Stream` 的所有元素时，它返回一个参数化相同类型的 `Optional` 对象。例如，我们将使用这个版本来计算一个随机 `Point` 对象坐标的总和：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, we''ll use the second version of the `reduce()` method. It''s similar
    to the previous one, but in this case, in addition to the associative `BinaryOperator`
    object, it receives the identity value for that operator (for example `0` for
    a sum or `1` for a product) and returns an element of the type we''re working
    with. If the stream has no values, the identity value will be returned. In this
    case, we use this version of the `reduce()` method to calculate the total amount
    of money we need to spend in salaries. We use the `map()` method to convert each
    `Person` object in an `int` value (its salary) so our `Stream` object will have
    `int` values when it executes the `reduce()` method. You will get more information
    about the `map()` method in the *Transforming the elements of a stream* recipe:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将使用`reduce()`方法的第二个版本。它与上一个版本类似，但在这个版本中，除了关联的`BinaryOperator`对象外，它还接收该操作符的标识值（例如，对于总和是`0`，对于乘积是`1`）并返回我们正在处理的类型的元素。如果流中没有值，则返回标识值。在这种情况下，我们使用这个版本的`reduce()`方法来计算我们需要在工资上花费的总金额。我们使用`map()`方法将每个`Person`对象转换为`int`值（它的工资），这样当执行`reduce()`方法时，我们的`Stream`对象将具有`int`值。你将在*转换流元素*菜谱中了解更多关于`map()`方法的信息：
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we''ll use the third version of the `reduce()` method. This version
    is used when the type of result of the reduce operation is different from the
    type of stream elements. We have to provide the identity value of the return type,
    an accumulator that implements the `BiFunction` interfaces and will receive an
    object of the return type, an element of the stream to generate a value of the
    return type, and a combiner function that implements the `BinaryOperator` interface
    and receives two objects of the return type to generate an object of that type.
    In this case, we have used this version of the method to calculate the number
    of persons with a salary higher than 50,000 in a list of random persons:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将使用`reduce()`方法的第三个版本。这个版本在`reduce`操作的结果类型与流元素类型不同时使用。我们必须提供返回类型的标识值，一个实现`BiFunction`接口的累加器，它将接收一个返回类型的对象，一个流元素以生成一个返回类型的值，以及一个实现`BinaryOperator`接口的合并函数，它接收两个返回类型的对象以生成该类型的对象。在这种情况下，我们使用了这个方法版本来计算一个随机人员列表中工资高于50,000的人数：
- en: '[PRE22]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, you learned how to use the different reduce operations provided
    by Java streams. First, we used some specialized reduce operations provided by
    the `DoubleStream`, `IntStream` and `LongStream` classes. These operations allow
    you to count the number of elements of the stream, calculate the sum of all the
    elements of the stream, calculate the average value of the elements of the stream,
    and calculate the highest and lowest value of the elements of the stream. If you
    work with a generic Stream, you will only have the `count()` method to count the
    elements of the stream.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你学习了如何使用Java流提供的不同`reduce`操作。首先，我们使用了`DoubleStream`、`IntStream`和`LongStream`类提供的某些专用`reduce`操作。这些操作允许你计算流中元素的数量，计算流中所有元素的总和，计算流中元素的平均值，以及计算流中元素的最高和最低值。如果你使用一个泛型`Stream`，你将只有一个`count()`方法来计算流中的元素数量。
- en: 'Then we used the three versions of the `reduce()` method provided by the `Stream`
    class. The first one receives only one parameter, a `BinaryOperator`. We specified
    that operator as a lambda expression and you will normally do that, but you can
    also use an object of a class that implements the `BinaryOperator` interface.
    That operator will receive two elements of the stream and will have to generate
    a new element of the same type. For example, we receive two `Point` objects and
    generate a new `Point` object. The operation implemented by that `BinaryOperator`
    has to be associative, that is to say, the following expression must be true:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用了`Stream`类提供的`reduce()`方法的三个版本。第一个版本只接收一个参数，一个`BinaryOperator`。我们指定这个操作符为一个lambda表达式，你通常会这样做，但你也可以使用实现`BinaryOperator`接口的类的对象。这个操作符将接收流中的两个元素，并必须生成一个相同类型的新的元素。例如，我们接收两个`Point`对象并生成一个新的`Point`对象。该`BinaryOperator`实现的操作必须是结合律的，也就是说，以下表达式必须是正确的：
- en: '*(a op b) op c = a op (b op c)*'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*(a op b) op c = a op (b op c)*'
- en: Here `op` is our `BinaryOperator`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里`op`是我们的`BinaryOperator`。
- en: This version of the `reduce()` method returns an `Optional` object; `Optional`
    because if the stream has no elements, there won't be a result value to return
    and the `Optional` object will be empty.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这个版本的`reduce()`方法返回一个`Optional`对象；`Optional`是因为如果流中没有元素，将没有返回值，`Optional`对象将是空的。
- en: 'The second version of the `reduce()` method receives an *identity* value and
    a `BinaryOperator`. The `BinaryOperator` has to be associative as in the other
    version of the `reduce()` method. For the *identity* value, it has to be a `true`
    expression:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`方法的第二个版本接收一个*单位值*和一个`BinaryOperator`。`BinaryOperator`必须与`reduce()`方法的另一个版本一样具有结合性。对于*单位值*，它必须是一个`true`表达式：'
- en: '*identity op a = a op identity = a*'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '*单位值 op a = a op 单位值 = a*'
- en: In this case, the `reduce()` method returns an element of the same type of elements
    of the stream. If the stream has no elements, the identity value will be returned.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`reduce()`方法返回与流中元素相同类型的元素。如果流中没有元素，将返回单位值。
- en: The last version of the `reduce()` method is used when we want to return a value
    of a type different from the elements of the stream. In this case, the method
    has three parameters, an *identity* value, an *accumulator* operator, and a *combiner*
    operator. The *accumulator* operator receives a value of the return type and an
    element of the stream and generates a new object of the return type.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce()`方法的最后一个版本用于当我们想要返回与流中元素类型不同的值时。在这种情况下，该方法有三个参数，一个*单位值*，一个*累加器操作符*和一个*组合器操作符*。*累加器操作符*接收返回类型的一个值和流中的一个元素，并生成一个新的返回类型对象。'
- en: 'The *combiner* function receives two objects of the return type to calculate
    a new object of the return type. The *identity* value is the *identity* value
    of the return type, and it has to verify the following expression:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合器*函数接收两个返回类型的对象来计算一个新的返回类型对象。*单位值*是返回类型的*单位值*，它必须验证以下表达式：'
- en: '*combiner (u, accumulator(identity, t)) == accumulator(u, t)*'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '*组合器(u, 累加器(单位值, t)) == 累加器(u, t)*'
- en: Here, *u* is an object of the return type and *t* an element of the stream.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，*u*是返回类型的一个对象，*t*是流中的一个元素。
- en: 'The following screenshot shows the output of an execution of the example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了示例执行的输出：
- en: '![](img/00038.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00038.jpeg)'
- en: There's more...
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have implemented all the parameters of the `reduce()` method as lambda expressions.
    The first two versions of the `reduce()` method receive a `BinaryOperator` and
    the third version receives a `BiFunction` and a `BinaryOperator`. If you want
    to reuse a complex operator, you can implement a class that implements the necessary
    interface and use an object of that class as the parameter to these and to the
    other methods of the `Stream` class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将`reduce()`方法的全部参数实现为lambda表达式。`reduce()`方法的前两个版本接收一个`BinaryOperator`，第三个版本接收一个`BiFunction`和一个`BinaryOperator`。如果您想重用复杂的操作符，您可以实现一个实现必要接口的类，并使用该类的对象作为这些方法和`Stream`类其他方法的参数。
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating streams from different sources* recipe in this chapter
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的*从不同源创建流*配方
- en: Collecting the elements of a stream
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集流中的元素
- en: 'Java streams allow you to process a sequence of elements in a sequential or
    parallel way. You can create a stream from different data sources, as a `Collection`,
    a `File` or an `Array` and apply to its elements a sequence of operations normally
    defined with lambda expressions. Those operations can be divided into two different
    classes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: Java流允许您以顺序或并行方式处理一系列元素。您可以从不同的数据源创建流，如`Collection`、`File`或`Array`，并对其元素应用一系列通常用lambda表达式定义的操作。这些操作可以分为两类：
- en: '**Intermediate operations**: These operations return other `Stream` as a result
    and allow you to filter, transform, or sort the elements of the stream'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间操作**：这些操作返回其他`Stream`作为结果，并允许您过滤、转换或排序流中的元素'
- en: '**Terminal operations**: These operations return a result after processing
    the elements of the stream'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**终端操作**：这些操作在处理流中的元素后返回结果'
- en: 'A stream has a source, zero or more intermediate operations, and a terminal
    operation. The two most important terminal operations are:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流有一个源，零个或多个中间操作，和一个终端操作。两个最重要的终端操作是：
- en: The reduce operation, which allows you to obtain a unique result after processing
    the elements of the stream. This result usually is a summary of the processed
    data. The *Reducing the elements of a stream* recipe explains you how to use reduce
    operations in Java.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 归约操作，它允许你在处理流元素后获得一个唯一的结果。这个结果通常是处理数据的摘要。"减少流元素"菜谱解释了如何在Java中使用归约操作。
- en: The collect operation that allows you to generate a data structure with the
    results of processing the elements of the stream. This is also called a mutable
    reduction operation as the result is a mutable data structure.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许你生成一个数据结构的收集操作，该数据结构包含处理流元素的结果。这也被称为可变归约操作，因为结果是可变的数据结构。
- en: In this recipe, we will learn how to execute collect operations in Java streams
    with the different versions of the `collect()` method and the auxiliary `Collectors`
    class.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在Java流中使用不同版本的`collect()`方法和辅助的`Collectors`类来执行收集操作。
- en: Getting ready
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的示例已经使用Eclipse IDE实现。如果你使用Eclipse或其他IDE如NetBeans，打开它并创建一个新的Java项目。
- en: How to do it...
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Follow these steps to implement the example:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤实现示例：
- en: First, let's implement some auxiliary classes we will use in the example. Implement
    the `Person` class to store some basic data about a person and the `PersonGenerator`
    class to generate a random list of persons. You can check the *Creating streams
    from different sources* recipe to see the source code of both the classes.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们实现一些辅助类，我们将在示例中使用。实现`Person`类以存储有关个人的基本数据，以及`PersonGenerator`类以生成随机的人名单。你可以查看*从不同来源创建流*菜谱以查看这两个类的源代码。
- en: 'In that class, override the `toString()` method with the following code, which
    returns the first name and the last name of the person:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个类中，使用以下代码覆盖`toString()`方法，它返回人的名字和姓氏：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, create a class named `Counter` with two attributes: a `String` attribute
    named `value` and an `int` attribute named `counter`. Generate the methods to
    `get()` and `set()` the values of both attributes. The source code of this class
    is very simple, so it won''t be included.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，创建一个名为`Counter`的类，具有两个属性：一个名为`value`的`String`属性和一个名为`counter`的`int`属性。生成获取和设置这两个属性值的方法。这个类的源代码非常简单，所以不会包括在内。
- en: 'Now, create the `Main` class with the `main()` method. Then, create a random
    `List` of `Person` objects using the `PersonGenerator` class:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个带有`main()`方法的`Main`类。然后，使用`PersonGenerator`类创建一个随机的`Person`对象列表：
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The first collect operation we will implement will generate a `Map` where the
    keys will be first name of the person and the values will be a list with all the
    persons with that first name. To implement this, we use the `collect()` method
    of the `Stream` class and the `Collectors.groupingByConcurrent` collector. Then,
    we process all the keys (first names) of the map using the `forEach()` method
    and print in the console the number of persons with that key: As parameter of
    the `groupingByConcurrent()` method we pass a method reference. We can use this
    mechanism in a lambda expression if it only calls to an existing method as in
    this case.'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要实现的第一个收集操作将生成一个`Map`，其中的键将是人的名字，值将是具有该名字的所有人的列表。为了实现这一点，我们使用`Stream`类的`collect()`方法和`Collectors.groupingByConcurrent`收集器。然后，我们使用`forEach()`方法处理映射的所有键（名字），并在控制台打印出具有该键的人数：`groupingByConcurrent()`方法的参数是一个方法引用。如果我们像在这个例子中一样只调用现有方法，我们可以使用这种机制在lambda表达式中使用它。
- en: '[PRE25]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The second collect operation we will implement will concatenate all the names
    of all the persons in the stream. To implement this operation, we use the `toString()`
    method of the `Person` object, the `collect()` method, of the `Stream` class,
    and the `joining()` method of the `Collectors` class that concatenates all the
    elements of the stream separated by the specified char sequence:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要实现的第二个收集操作将连接流中所有人的名字。为了实现这个操作，我们使用`Person`对象的`toString()`方法，`Stream`类的`collect()`方法，以及`Collectors`类的`joining()`方法，该方法将流的所有元素连接起来，并用指定的字符序列分隔：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'With the next collect operation we''ll implement, we will separate the persons
    on the stream in two groups. The first one will have the persons with a salary
    greater than 50,000 and the second one will have the others. The result of the
    operation will be a `Map` object with a `Boolean` value as the key and a `List`
    of persons as the value. To implement this, we will use the `collect()` method
    of the `Stream` class and the `partitionBy()` method of the `Collectors` class
    that receives as a parameter a `Boolean` expression that allows you two divide
    the elements of the stream in `true` or `false`. Then we use the `forEach()` method
    to write the number of elements in the generated lists:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们接下来要实现的下一个收集操作中，我们将把流中的人员分成两组。第一组将包含薪水超过50,000的人员，第二组将包含其他人。操作的结果将是一个以`Boolean`值作为键、人员列表作为值的`Map`对象。为了实现这一点，我们将使用`Stream`类的`collect()`方法和接收作为参数的`Collectors`类的`partitionBy()`方法，该方法接收一个`Boolean`表达式，允许你将流元素分为`true`或`false`。然后我们使用`forEach()`方法来写入生成的列表中的元素数量：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then, we''ll implement a collect operation that will generate another `Map`.
    In this case, the keys will be the first name of the persons and the value will
    be the last names of the people with the same first name concatenated in one `String`.
    To implement this behavior, we have use the `collect()` method of the `Stream`
    class and the `toConcurrentMap()` method of the `Collectors` class. We pass as
    parameters to that method a lambda expression to obtain the key, a lambda expression
    to obtain the value, and a lambda expression to resolve the situations where the
    key exists in the final `Map`. Then, we use the `forEach()` method to process
    all the keys and write its associated values:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将实现一个收集操作，该操作将生成另一个`Map`。在这种情况下，键将是人员的名字，值将是具有相同名字的人的姓氏连接在一个`String`中。为了实现这种行为，我们使用了`Stream`类的`collect()`方法和`Collectors`类的`toConcurrentMap()`方法。我们将lambda表达式作为参数传递给该方法，以获取键，传递lambda表达式以获取值，以及传递lambda表达式以解决键在最终`Map`中存在的情况。然后，我们使用`forEach()`方法处理所有键并写入其关联的值：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Until now, in all the examples of the `collect()` method we have implemented,
    we used the version of that method that receives an implementation of the `Collector`
    interface. But there''s another version of the `collect()` method. With this version
    of the `collect()` method, we will implement a collect operation that generates
    a `List` with the persons who have a salary greater than 50,000\. We pass to the
    `collect()` method an expression to create the `List` (the `List::new` method),
    a lambda expression to process a list and an element of the stream, and an expression
    to process the two lists (the `List::addAll` method):'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，在我们实现的`collect()`方法的所有示例中，我们使用了接收`Collector`接口实现的该方法的版本。但是，还有另一个版本的`collect()`方法。使用这个版本的`collect()`方法，我们将实现一个收集操作，生成一个包含薪水超过50,000的人员的`List`。我们将创建`List`的表达式（`List::new`方法）、处理列表和流元素的lambda表达式，以及处理两个列表的表达式（`List::addAll`方法）传递给`collect()`方法：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Finally, we'll implement an example that generates a `ConcurrentHashMap` with
    the first names that appears in the list of `People` objects and the number of
    times that each name appears. We will use the first name of the persons as key
    and `Counter` objects as values. The first parameter of the collect method will
    create a new `ConcurrentHashMap` object. The second parameter is an implementation
    of the `BiConsumer` interface that receives as parameters a `ConcurrentHashMap`
    and a `Person`. First, we use the `computeIfPresent()` method of the hash to increment
    the `Counter` of the person if the person exists. Then, we use the `computeIfAbsent()`
    method of the hash to insert a new person name if it doesn't exists. The third
    argument of the `collect()` method is an implementation of the `BiConsumer` interface
    that receives two `ConcurrentHashMap` objects and we use the `merge()` method
    to process all the elements of the second hash and insert them in the first hash
    if they are not present or increment the counters if they are.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the introduction of this recipe, the `collect()` method allows
    you to do a mutable reduction of the elements of a `Stream`. We call it a mutable
    reduction because the final result of the stream will be a mutable data structure,
    such as `Map` or `List`. The `Stream` class of the Java Concurrency API provides
    two versions of the `collect()` method.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one receives only one parameter that is an implementation of the
    `Collector` interface. This interface has seven methods, so you normally won''t
    implement your own collectors. Instead of this, you will use the utility class
    `Collectors`, which has a lot of methods that return ready-to-use `Collector`
    objects for your reduce operations. In our example, we have used the following
    methods of the `Collectors` class:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '`groupingByConcurrent()`: This method returns a `Collector` object that implements
    a group by operating with the elements of `Stream` in a concurrent way, generating
    `Map` as the resultant data structure. It receives as parameter an expression
    to obtain the value of the key used in the map from the element of the stream.
    It generates `Map` where the keys will be of the type returned by the parameter
    expression and the value will be a `List` of elements of the stream.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`joining()`: This method returns `Collector` that concatenates the elements
    of the stream into `String`. You can specify three `CharSequence` objects with
    a separator for the elements, a prefix of the final `String`, and a suffix of
    the final `String`.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`partitioningBy()`: This method returns `Collector` similar to the first one.
    It receives as parameter a `Boolean` expression with the elements of `Stream`
    and organizes the elements of the stream in two groups: the ones that meet the
    expressions and the ones that don''t. The final result will be `Map` with a `Boolean`
    key and `List` of the type of elements of the stream as value.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toConcurrentMap()`: This method returns `Collector` that generates `ConcurrentMap`
    in a concurrent way. It receives three parameters:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression to generate the key from an element of the stream
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression to generate the value from an element of the stream
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An expression to generate a value from two values when there are two or more
    elements with the same key
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Collector` has a set of `Characteristics` that define its behavior and can
    be defined or not for a specific collector. For us, the most important is the
    `CONCURRENT` one that indicates if the collector can work in a concurrent way
    or not. In this case, we can''t take advantage of our multicore processor by creating
    only a parallel stream. If we use a collect operation with `Collector`, we have
    to also take into account the value of the `CONCURRENT` characteristic of that
    `Collector`. We will only have a concurrent reduction if the next three conditions
    are true:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: The `Stream` is parallel (we have used `parallelStream()` of the `parallel()`
    methods in the stream)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The collector has the `CONCURRENT` characteristic
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either the stream is unordered, or the collector has the `UNORDERED` characteristic
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our case, `groupingByConcurrent()` and `toConcurrentMap()` return collectors
    which have the `CONCURRENT` characteristic and the `joining()` and `partitionBy()`
    methods return collectors that don't have such characteristics.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s another version of the `collect()` method that can be used
    with parallel streams. This version of the `collect()` method receives the following
    three parameters:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: A supplier function that generates a data structure of the type of the final
    result of the collect operation. With parallel streams, this function will be
    called as many times as there are threads executing the operation.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An accumulator function that receives a data structure and an element of the
    stream and makes the process of the element.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combiner function that receives two data structures and generates a unique
    data structure of the same type.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use lambda expressions to implement these functions, but you can also
    implement the `Supplier` interface for the supplier function or the `BiConsumer`
    interface for the accumulator and combiner functions (always parameterized with
    the adequate data types). You can also use method references (`Class::Method`)
    if the input and output parameters are adequate. For example, we have used the
    `List::new` reference as the supplier function and the `List::addAll` method as
    the combiner function. We could use the `List::add` method as the accumulator
    function. There are more methods you can use as parameters to the `collect()`
    method.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the `groupingByConcurrent()` operation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: 'The following screenshot shows the output of the `toConcurrentMap()` operation:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00040.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: There's more...
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Collectors` class has many more methods that return `Collector` objects
    that can be used in the `collect()` method. The following are the most interesting:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '`toList()`: This method returns `Collector` that groups all the elements of
    `Stream` into `List`.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`toCollection()`: This method returns `Collector` that groups all the elements
    of `Stream` into `Collection`. This method returns as parameter an expression
    that creates `Collection`, which will be used internally by `Collector` and returned
    at the end of its execution.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`averagingInt()`, `averagingLong()`, and `averagingDouble()`: These methods
    return `Collector` that calculates the average of `int`, `long`, and `double`
    values, respectively. They receive as parameters an expression to convert an element
    of the stream into `int`, `long`, or `double`. The three methods return a double
    value.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources* and *Reducing the elements of
    a stream *recipes in this chapter
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying an action to every element of a stream
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, you will learn how to apply an action to all the elements of
    the stream. We will use three methods: two terminal operations, the `forEach()`
    and `forEachOrdered()`, and an intermediate operation, the `peek()` method.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: First, we will implement some auxiliary classes we will use in the example.
    Create a class named `Person` with the basic characteristics of a person. Check
    the *Creating streams from different sources* recipe to see the source code of
    this class.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As we''ll work with methods that depend on the order of the elements of the
    stream, we have to override some methods in the `Person` class. First, we''ll
    override the `compareTo()` method that compares two persons. We''ll create a static
    `Comparator` object using the `Comparator` interface to compare two `Person` objects
    using their first name and last name. Then, we''ll use that comparator in the
    `compareTo()` method:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Then, we override the `equals()` method that determines if two `Person` objects
    are equal. As we made in the `compareTo()` method, we use the `Comparator` static
    object we have created before.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we override the `hashCode()` method that calculates a hash value for
    a `Person` object. In Java, equal objects must produce the same hash code, so
    we have to override this method and generate the hash code of a `Person` object
    using the first name and last name attributes and the `hash()` method of the `Objects`
    class:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In this example, we will also use the `PersonGenerator` and `DoubleGenerator`
    classes used in the *Creating streams from different sources* recipe.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, create the `Main` class with the `main()` method. First, we create a `List`
    of ten random `Person` objects:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, we''ll use the `forEach()` method to write the names of all the persons
    of the generated list. The `forEach()` method receives as parameter the expression
    we want to apply to each element. In our case, we use a lambda expression to write
    the information to the console:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, you''ll learn how to apply an action to each element in an ordered way.
    First, we create a list of random `Double` numbers using the `DoubleGenerator`
    class. Then, we create a parallel stream, sort the elements of the stream using
    the `sorted()` method, and then use the `forEachOrdered()` method to write the
    numbers to the console in an ordered way:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let''s see what happens if you sort the elements of the stream but don''t
    use the `forEachOrdered()` method. Repeat the same sentence as before but use
    the `forEach()` method instead:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Then, we''ll test how the `forEachOrdered()` method works with a stream of
    `Person` objects:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, let''s test the `peek()` method. This method is similar to the `forEach()`
    method, but it''s an intermediate operation. It''s normally used for log purposes:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe you learnt how to use three methods to process all the elements
    of a stream and apply an action to them. These methods are:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '`forEach()`: This is a terminal operation that applies an action to all the
    elements of `Stream` and returns a `void` value. It receives as parameter the
    action to apply to the elements defined as a lambda expression or as an implementation
    of the `Consumer` interface. There''s no guarantee about the order in which the
    action will be applied to the elements of a parallel stream.'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forEachOrdered()`: This is a terminal operation that applies an action to
    all the elements of `Stream` in the order of the stream, if the stream is an ordered
    stream, and returns a void value. You can use this method after the `sorted()`
    method. You first sort the elements of the stream with the `sorted()` method and
    then apply the action in an ordered way using the `forEachOrdered()` method. This
    behavior is guaranteed with parallel streams too, but its performance will be
    worse than the `forEach()` method with unordered streams.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`peek()`: This is an intermediate operation that returns `Stream` with the
    same elements of the stream that call the method and applies the action specified
    as a parameter to all the elements consumed from the stream. The action applied
    to the elements is specified as a lambda expression or as an implementation of
    the `Consumer` interface. Take into account that, as the intermediate operations
    are lazy, the operation will only be applied to the elements consumed by the stream
    when the terminal operation is executed.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Take into account that if you use the sorted method, you have to provide `Comparator`
    that can be applied to the elements you want to sort or the elements of the stream
    must implement the `Comparable` interface. In our case, the `Person` class implements
    that interface and the `compareTo()` method to sort the elements of the stream
    according to their first and last names.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Sorting the elements of a stream* recipes in this chapter
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering the elements of a stream
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most commons actions you will apply to a stream will be the filtering
    operation that selects the elements that continue with the processing. In this
    recipe, you will learn the different methods provided by the `Stream` class to
    select the elements of a stream.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class that stores the basic attributes of a person, and
    the `PersonGenerator` class that generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both the classes.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, we''ll implement the `Main` class with the `main()` method. First, create
    a `List` of random `Person` objects using the `PersonGenerator` class. Use the
    `forEach()` method to print the generated elements:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Then, we''ll eliminate the duplicate objects using the `distinct()` method.
    Use the `forEach()` method to write the elements that pass the filter:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Then, we''ll test the `distinct()` method with an `Array` of numbers. Create
    an array of numbers repeating some of them. Convert them to a `List` using the
    `asList()` method of the `Arrays` class. Create a parallel stream with the `parallelStream()`
    method, convert the stream into an `IntStream` stream with the `mapToInt()` method,
    use the `distinct()` method to delete the repeated elements, and finally use the
    `forEach()` method to write the final elements to the console:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now, we''ll get the persons of the random person list with a salary lower than
    3,000 using the filter method and a predicate expressed as a lambda expression
    with that condition. As with the other examples, use the `forEach()` method to
    write the resultant elements:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Then, we''ll test the `filter()` method with an `IntStream` getting the numbers
    less than two:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now, we''ll use the `limit()` method to limit the number of elements in the
    stream. For example, create a parallel stream from the random list of persons,
    convert them into a `DoubleStream` with the `mapToDouble()` method, and get the
    first five elements using the `limit()` method:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we''ll use the `skip()` method to ignore a number of elements of the
    stream. Create a parallel stream from the random list of persons, convert them
    into a `DoubleStream` with the `mapToDouble()` method, and ignore the first five
    elements using the `skip()` method:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe we have used four methods to filter the elements in a stream.
    These methods are:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`distinct()`: This method returns a stream with the distinct elements of the
    current stream according to the `equals()` method of the elements of the `Stream`
    class. In our case, we have tested this method with `Person` objects and `int`
    numbers. We have implemented the `equals()` and `hashCode()` methods in the `Person`
    class. If we don''t do this, the `equals()` method will only return `true` if
    the two compared objects hold the same reference. Take into account that this
    operation is a stateful operation, so it won''t get a good performance with parallel
    streams (as the Java documentation reflects, ''... under parallel computation,
    some pipelines containing stateful intermediate operations may require multiple
    passes on the data or may need to buffer significant data...'').'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filter()`: This method receives a `Predicate` as parameter. This predicate
    can be expressed as a lambda expression that returns a `boolean` value. The `filter()`
    method returns a stream with the elements that make the `Predicate` true.'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit()`: This method receives an `int` value as a parameter and returns a
    stream with no more than as many number of elements. The performance of this method
    can also be bad with ordered parallel streams, especially when the number of elements
    you want to get is big, because the method will return the first elements of the
    stream and that will imply additional computation. This circumstance doesn''t
    occur with unordered streams because in that case, it doesn''t matter what elements
    are returned.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip()`: This method returns a stream with the elements of the original stream
    after discarding the first elements. The number of discarded elements is specified
    as the parameter of this method. This method has the same performance problems
    as with the `limit()` method.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The stream class also has other two methods that can be used to filter the
    elements of a stream:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: '`dropWhile()`: This method receives a `Predicate` expression as the parameter.
    It has a different behavior with ordered and unordered streams. With ordered streams,
    the method deletes the first elements that match the predicate from the stream.
    It deletes elements when the elements match the predicate. When it finds an element
    that doesn''t match the predicate, it stops deleting the elements and returns
    the rest of the stream. With unordered streams, its behavior is not deterministic.
    It deletes a subset of elements that match the predicate but is not specified
    what subset of elements it will delete. As with the other methods, it may have
    a bad performance with parallel ordered streams.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`takeWhile()`: This method is equivalent to the previous one, but it takes
    the elements instead of deleting them.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream* and
    *Collecting the elements of a stream* recipes in this chapter
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transforming the elements of a stream
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the most useful intermediate operations you can use with streams are
    those that allow you to transform the elements of the stream. These operations
    receive elements of a class and return the elements of a different class. You
    can even change the type of stream and generate an `IntStream`, `LongStream`,
    or `DoubleStream` from `Stream`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to use the transforming intermediate operations
    provided by the `Stream` class to convert its elements into a different class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class, which stores the basic attributes of a person, and
    the `PersonGenerator` class, which generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both the classes.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `BasicPerson`. This class will have a `String` attribute
    named `name` and a `long` attribute named `age`. Create the methods to get and
    set the value of both the attributes. As the source code of this class is very
    simple, it won't be included here.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create another auxiliary class named `FileGenerator`. This class will have
    a method named `generateFile()` that receives the number of lines in the simulated
    file and returns its content as a `List` of `String`:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Then, create the `Main` class with the `main()` method. First, create a list
    of random `Person` objects using the `PersonGenerator` class:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then, we''ll use the `mapToDouble()` method to convert the stream of `Person`
    objects into `DoubleStream` of double values. Create a parallel stream using the
    `parallelStream()` method and then use the `mapToDouble()` method, passing as
    parameter a lambda expression that receives a `Person` object and returns its
    salary, which is a double number. Then use the `distinct()` method to get the
    unique values and the `forEach()` method to write them to the console. We also
    get the number of different elements written using the `count()` method:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we''ll transform the `Person` objects of the stream into `BasicPerson`
    objects. Create the stream using the `parallelStream()` method and use the `map()`
    method to transform the objects. This method receives as parameter a lambda expression
    that receives a `Person` object, creates a new `BasicPerson` object, and establishes
    the value of its attributes. Then, we write the values of the attributes of the
    `BasicPerson` object using the `forEach()` method:'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Finally, we''ll learn how to manage the situations where an intermediate operation
    returns `Stream`. In this case, we''ll work with a  `Stream` of streams, but we
    can concatenate all these `Stream` objects into a unique `Stream` using the `flatMap()`
    method. Generate `List<String>` with 100 elements using the `FileGenerator` class.
    Then, create a parallel stream with the `parallelStream()` method. We''ll split
    each line to get its words using the `split()` method, and with the `of()` method
    of the `Stream` class, we convert the resultant `Array` into `Stream`. If we use
    the `map()` method, we are generating a `Stream` of streams, but using the `flatMap()`
    method we''ll get a unique `Stream` of `String` objects with all the words of
    the whole List. Then, we get the words with a length greater than zero with the
    `filter()` method, sort the stream with the `sorted()` method, and collect it
    to `Map` using the `groupingByConcurrent()` method where the keys are the words
    and the values are the number of times each word appears in the stream:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Finally, we have to implement the `getAge()` method used previously in the
    code. This method receives the date of birth of a `Person` object and returns
    its age:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: How it works...
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe you learnt how to convert the elements of the stream using an
    intermediate operation and an expression that makes the conversion between the
    source and the destination types. We used three different methods in our example:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '`mapToDouble()`: We used this method to convert `Stream` of objects into `DoubleStream`
    with double numbers as elements. This method receives as parameter a lambda expression
    or an implementation of the `ToDoubleFunction` interface. This expression receives
    an element of `Stream` and has to return a double value.'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map()`: We can use this method when we have to convert the elements of `Stream`
    to a different class. For example, in our case, we convert the `Person` class
    to a `BasicPerson` class. This method receives as parameter a lambda expression
    or an implementation of the `Function` interface. This expression must create
    the new object and initialize its attributes.'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMap()`: This method is useful in a more complex situation when you have
    to work with a `Stream` of `Stream` objects and you want to convert them to a
    unique `Stream`. This method receives as parameter a lambda expression or an implementation
    of the `Function` interface as the `map()` function, but in this case, this expression
    has to return a `Stream` object. The `flatMap()` method will automatically concatenate
    all those streams into a unique `Stream`.'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Stream` class provides other methods to transform the elements of a `Stream`:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '`mapToInt()`, `mapToLong()`: These methods are identical to the `mapToDouble()`
    method, but they generate `IntStream` and `LongStream` objects, respectively.'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`flatMapToDouble()`, `flatMapToInt()`, `flatMapToLong()`: These methods are
    identical to the `flatMap()` method, but they work with `DoubleStream`, `IntStream`,
    and `LongStream`, respectively.'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  id: totrans-311
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Collecting the elements of a stream recipes* in this chapter
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorting the elements of a stream
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another typical operation you will want to do with a `Stream` is sorting its
    elements. For example, you may want to sort the elements of the `Stream` by name,
    postal code, or any other numeric value.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: With streams, we have other considerations with the so-called encounter order.
    Some streams may have a defined encounter order (it depends on the source of the
    `Stream`). Some operations work with the elements of the stream in its encountered
    ordered, such as `limit()`, `skip()`, and others. This makes that parallel computation
    for this methods doesn't give us good performance. In these cases, you can speed-up
    the execution of these methods by deleting the ordering constraint.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn how to sort the elements of `Stream` and how
    to delete the ordering constraint in situations where we don't need the encounter
    order of `Stream`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class, which stores the basic attributes of a person, and
    the `PersonGenerator` class, which generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both the classes.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, implement the `Main` class with the `main()` method. First, we''ll create
    an `Array` of `int` numbers. Then, we''ll create a parallel stream with the `parallelStream()`
    method from this array, use the `sorted()` method to sort the elements of the
    array, and use the `forEachOrdered()` method to write the elements in an ordered
    way. Take into account that this operation won''t use all the power of our multi-core
    processor as it has to write the elements in the specified order:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now, let''s try the same principles with a `Stream` of `Person` objects. Create
    a list of 10 random `Person` objects using the `PersonGenerator` class and use
    the same methods, `sorted()` and `forEachOrdered()`, to see how the persons are
    written in an ordered way:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, we''ll see how to eliminate the encounter order of a data structure
    using the `unordered()` method. First, we''ll create `TreeSet` from our `List`
    of random `Person` objects. We use `TreeSet` because it orders the elements internally.
    Then, we make a loop to repeat the operations ten times and see how there''s a
    difference between the ordered and the unordered operations:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Then, we create a stream from `PersonSet` using the `stream()` method, convert
    it to parallel with the `parallel()` method, get the first element with the `limit()`
    method, and return the `Person` object, collecting it to a list and getting the
    first element:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, we perform the same operation but remove the ordered constraint with the
    `unordered()` method between the `stream()` and `parallel()` methods:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: How it works...
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are `Stream` objects that may have an encounter order depending on its
    source and the intermediate operations you have applied before. This encounter
    order imposes a restriction about the order in which the elements must be processed
    by certain methods. For example, if you use the `limit()` or `skip()` methods
    in `Stream` with an encounter order, they will get and ignore the first elements
    according to that encounter order. There are other operations, such as the `forEach()`
    method, that don't take into account the encounter order. If you apply the same
    operations to a stream with an encounter order, the result will always be the
    same. If the stream doesn't have an encounter order, the results may vary.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: When you work with sequential streams, the encounter order doesn't have any
    impact on the performance of the application, but with parallel streams it can
    affect it greatly. Depending on the operations, it would be necessary to process
    more than once the elements of `Stream` or to store in a buffer a big amount of
    data. In this case, removing the encounter order using the `unordered()` method,
    as we did in this recipe, will significantly increase the performance of the application.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `sorted()` method sorts the elements of the `Stream`.
    If you use this method, the elements of `Stream` must implement the `Comparable`
    interface. Otherwise, you can pass a `Comparator` as a parameter that will be
    used to sort the elements. If you use this method, you are creating an ordered
    stream, so all the things explained before to the streams with an encounter order
    are applicable to the resultant stream.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `forEach()` method doesn't take into account the encounter order
    of the stream. If you want to take this encounter order into account, say, to
    write the elements of the stream order after sorting them, you can use the `forEachOrdered()`
    method.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows part of the output of the example:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
- en: You can see that when you call the `limit(1)` method in the parallel stream
    generated from `TreeSet`, you always obtain the same result because the Stream
    API respects the encounter order of that structure. But when we include a call
    to the `unordered()` method, the encounter order is not taken into account and
    the result obtained should vary, as in this case.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you use the `unordered()` method, you're not executing any code that internally
    changes the order of the elements in the data structure. You're only deleting
    a condition that would be taken into account for some methods otherwise. It's
    possible that the results of a stream with the `unordered()` method and the results
    of the same stream without the method are equal. Its use may have consequences
    in possibly giving different processing results for parallel streams. For example,
    if you try our example using a `List` of `Person` objects instead of `personSet` a
    `TreeSet`, you will always obtain the same result in both the cases.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned before, the main purpose of the `unordered()` method is to delete
    a constraint that limits the performance of parallel streams.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream*
    and *Collecting the elements of a stream* recipes in this chapter
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verifying conditions in the elements of a stream
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One interesting option provided by the `Stream` class is the possibility to
    check if the elements of the stream verify a condition or not. This functionality
    is provided by the terminal operations that return a `Boolean` value.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will learn which methods provide the `Stream` class to check
    conditions in the elements of a stream and how to use them.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll implement some auxiliary classes we will use in the example. First,
    implement the `Person` class, which stores the basic attributes of a person, and
    the `PersonGenerator` class, which generates a `List` of random `Person` objects.
    Please, check the recipe *Apply an action to all the elements of a stream* to
    see the source code of both classes.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create the `Main` class with the `main()` method. First, we''ll create
    a `List` of random `Person` objects using the `PersonGenerator` class:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Then, calculate the maximum and minimum values of the salary field to verify
    that all our calculations are correct. We use two streams for the calculation,
    the first one with the `map()` and `max()` methods and the second one with the
    `mapToInt()` and `min()` methods:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now, we''ll test some conditions. First, let''s verify that all the `Person`
    objects generated have a salary greater than zero with the `allMatch()` method
    and the corresponding lambda expression:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: We repeat the condition to test if all the salaries are greater than 10,000
    and 30,000.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we''ll use the `anyMatch()` method to test if there is someone with a
    salary greater than 50,000 and 100,000:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To finish this block of tests, we use the `noneMatch()` method to verify that
    there's none with a salary greater than 100,000
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After that, we use the `findAny()` method to get a random element of the stream
    of `Person` objects:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Then, we use the `findFirst()` method to get the first element of the stream
    of Person objects:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Finally, we sort the stream by salary using the `sorted()` method, passing
    `Comparator` expressed as a lambda expression, and use the `findFirst()` method
    to obtain, in this case, the `Person` object with the lowest salary:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: How it works...
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we used three different methods to verify conditions over the
    elements of a Stream:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '`allMatch()`: This method is a terminal operation that receives as parameter
    an implementation of the `Predicate` interface expressed as a lambda expression
    or as an object that implements it and returns a `Boolean` value. It returns `true`
    if the `Predicate` introduced is true for all the elements of the `Stream` and
    `false` otherwise.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anyMatch()`: This method is a terminal operation that receives as parameter
    an implementation of the `Predicate` interface expressed as a lambda expression
    or as an object that implements it and returns a `Boolean` value. It returns `true`
    if the `Predicate` introduced is `true` for at least one of the elements of the
    `Stream` and `false` otherwise.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noneMatch()`: This method is a terminal operation that receives as parameter
    a `Predicate` expressed as a lambda expression or as an implementation of interface
    and returns a `Boolean` value. It returns `true` if the `Predicate` introduced
    is false for all the elements of the Stream and `false` otherwise.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also used two methods to obtain the elements of `Stream`:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '`findAny()`: This method is a terminal operation that doesn''t receive parameters
    and returns an `Optional` object parameterized with the class of the elements
    of `Stream` with some element of `Stream`. There''s no guarantee about the element
    returned by this method. If `Stream` has no elements, the `Optional` object returned
    will be empty.'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findFirst()`: This method is a terminal operation that doesn''t receive parameters
    and returns an `Optional` parameterized with the class of the elements of `Stream`.
    It returns the first element of `Stream` if the stream has a determined encounter
    order or any element if the stream has no encounter order. If `Stream` has no
    elements, the `Optional` returned will be empty.'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-379
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe we used an interface and a class provided by the Java API. The
    `Predicate` interface is a functional interface that is usually expressed as a
    lambda expression. This expression will receive an element of `Stream` and return
    a `Boolean` value. If you want to implement a class that implements this interface,
    you only have to implement the `test()` method that receives an object of the
    parameterized type and returns a `Boolean` value. The interface defines more methods,
    but they have a default implementation.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: The `Optional` class is used when a terminal operation of `Stream` may or may
    not return a value. In this way, Java guarantees that the operation will always
    return a value, the `Optional` object, that may have a value we obtain using the
    `get()` method or may be an empty object, the condition we can check with the
    `isPresent()` method. If you use the `get()` method with an empty `Optional` object,
    a `NoSuchElementException` will be thrown.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The *Creating streams from different sources*, *Reducing the elements of a stream* and
    *Collecting the elements of a stream* recipes in this chapter
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reactive programming with reactive streams
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Reactive streams** ([http://www.reactive-streams.org/](http://www.reactive-streams.org/))
    define a mechanism to provide asynchronous stream processing with non-blocking
    back pressure.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: 'Reactive streams are based on the following three elements:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: A publisher of information
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more subscribers of that information
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A subscription between the publisher and a consumer
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The reactive streams specification determines how these classes should interact
    among them, according to the following rules:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: The publisher will add the subscribers that want to be notified
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscriber receives a notification when they're added to a publisher
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The subscribers request one or more elements from the publisher in an asynchronous
    way, that is to say, the subscriber requests the element and continues with the
    execution
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the publisher has an element to publish, it sends it to all its subscribers
    that have requested an element
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned before, all this communication is asynchronous, so we can take
    advantage of all the power of our multi-core processor.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: Java 9 has included three interfaces, the `Flow.Publisher`, the `Flow.Subscriber`,
    and the `Flow.Subscription`, and a utility class, the `SubmissionPublisher` class,
    to allow us to implement reactive stream applications. In this recipe, you will
    learn how to use all these elements to implement a basic reactive stream application.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example of this recipe has been implemented using the Eclipse IDE. If you
    use Eclipse or other IDE such as NetBeans, open it and create a new Java project.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Follow these steps to implement the example:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Create a class named `Item` that will represent the items of information sent
    from the publisher to the subscribers. This class has two `String` attributes,
    named `title` and `content`, and the methods to `get()` and `set()` their values.
    Its source code is very simple, so it won't be included here.
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, create a class named `Consumer1` and specify that it implements the `Subscriber`
    interface parameterized with the `Item` class. We have to implement four methods.
    First, we implement the `onComplete()` method. It simply writes a message to the
    console:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then, we implement the `onError()` method. It simply writes information about
    the error to the console:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Then, we implement the `onNext()` method. It simply writes information about
    the received item to the console:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'And finally, we implement the `onSubscribe()` method. It simply writes a message
    to the console and doesn''t request any item using the `request()` method of the
    `Subscription` object:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Now, it''s time for the `Consumer2` class. Specify that it also implements
    the `Subscriber` interface parameterized with the `Item` class. In this case,
    we have a private `Subscription` attribute to store the subscription object. The
    `onComplete()` and `onError()` methods are equivalent to the ones of the `Consumer1`
    class:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `onNext()` method has an additional line to request another element:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The `onSubscribe()` method also has an additional line to request the first
    element:'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Now, implement a class called `Consumer3` and specify that it implements the
    `Subscriber` interface parameterized with the `Item` class. The `onComplete()`
    and `onError()` methods are equivalent to those of the previous classes:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `onNext()` method, in this case, writes information about the item to the
    console but doesn''t request any element:'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the `onSubscribe()`, method we request three items:'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Finally, implement the `Main` class with the `main()` method. First, create
    three consumers, one of each class:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Now, create a `SubmissionPublisher` object parameterized with the `Item` class
    and add the three consumers using the `subscribe()` method:'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Now, create ten `Item` objects and publish them using the `submit()` method
    of the `SubmissionPublisher` object. Wait a second between each item:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Finally, close the publisher with the `close()` method:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: How it works...
  id: totrans-432
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The main goal of reactive streams is provide a mechanism to process asynchronous
    stream of data with non-blocking back pressure. We want that the receivers of
    information optimize their resources. As the mechanism is asynchronous, receivers
    don't need to use their resources to look for new elements. They will be called
    when a new element comes in. The non-blocking back pressure allows receivers to
    consume new elements only when the receivers are ready, so they can use a bounded
    queue to store the incoming elements and they won't be saturated by producers
    of new elements.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: 'The reactive streams in Java are based on three interfaces:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '`Flow.Publisher`: This interface has only one method:'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscribe()`: This method receives a `Subscriber` object as parameter. The
    publisher should take this subscriber into account when it publishes an Item.'
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flow.Subscriber`: This interface has four methods:'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onComplete()`: This method will be called when the `Publisher` has finished
    its execution'
  id: totrans-438
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onError()`: This method will be called when there is an error that must be
    notified to the subscribers'
  id: totrans-439
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onNext()`: This method will be called when the `Publisher` has a new element'
  id: totrans-440
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onSubscribe()`: This method will be called when the publisher has added the
    subscriber with the `subscribe()` method'
  id: totrans-441
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Flow.Subscription`: This interface has one methods:'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`request()`: This method is used by the `Subscriber` to request an element
    from the publisher'
  id: totrans-443
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take into account that these are only interfaces and you can implement them
    and use them as you want. The supposed flow is as follows:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: Someone calls the `subscribe()` method of a `Publisher`, sending it a `Subscriber`.
  id: totrans-445
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Publisher` creates a `Subscription` object and sends it to the `onSubscribe()`
    method of the `Subscriber`.
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Subscriber` uses the `request()` method of the `Subscription` to request
    elements to the `Publisher`.
  id: totrans-447
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the publisher has an element to publish, it sends them to all `Subscribers`
    that have requested elements, calling their `onNext()` method.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the publisher ends its execution, it calls the `onComplete()` method of
    the subscribers.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Java API provides the `SubmissionPublisher` class that implements the Publisher
    interface and implements this behavior.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the output of the example and you can see how
    the behavior of the reactive streams is as expected:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00042.jpeg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
- en: The three `Subscriber` objects receive their `Subscription`. As `Consumer1`
    doesn't request any `Item`, it won't receive them. `Consumer3` has requested three,
    so you will see in the output of the example that it will receive those three
    `Item` objects. Finally, the `Consumer2` object will receive the ten `Item` objects
    and the notification about the end of execution of the `Publisher`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  id: totrans-454
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an additional interface that should be used with reactive streams.
    It's the `Flow.Processor` interface and groups the `Flow.Publisher` and the `Flow.Subscriber`
    interfaces. Its main purpose is to be an element between a publisher and a subscriber
    to transform the elements produced by the first one into a format that can be
    processed by the second one. You can have more than one processors in a chain
    so the output of one of them could be processed by the next one.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: Java also defines the `Flow` class that includes the four interfaces explained
    before.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
