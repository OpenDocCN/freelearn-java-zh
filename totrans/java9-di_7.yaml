- en: IoC Patterns and Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you have reached this chapter, you should know what **Dependency Injection**
    (**DI**) is, why it's so important, how it's projected in recent versions of Java,
    and how to implement it with popular frameworks, such as Spring and Google Guice,
    with various scopes.
  prefs: []
  type: TYPE_NORMAL
- en: It's said that knowing something is not enough until it's applied with best
    methodologies and practices. Knowledge is power only when it's implemented in
    the right manner. An improper approach may create a big mess.
  prefs: []
  type: TYPE_NORMAL
- en: The software industry is moving toward modularity. The concepts of DI and **Inversion
    of Control** (**IoC**) containers were created due to this, and this is why they
    are so popular today. Still, many developers don't know how to utilize DI to its
    full potential.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the real strength of DI by learning the right
    patterns and best practices to apply the expertise we gained in DI in previous
    chapters. This chapter is not meant to do anything new; instead, we will learn
    how to do things in the right manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Various patterns to achieve IoC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Injection using the setter method versus constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circular dependency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices and anti-patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Various patterns to achieve IoC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s recall what the  **Dependency Inversion Principle** (**DIP**) states:
    high-level modules should not depend upon low-level modules; both should depend
    upon abstraction. This is a fundamental requirement for making any application
    modular and adjustable.'
  prefs: []
  type: TYPE_NORMAL
- en: While designing any system, we should make sure that high-level classes do not
    instantiate low-level classes; instead, they should rely on abstraction (the interface
    or abstract class) rather than depending on other concrete classes directly. The
    DIP does not specify how this happens, so a technique is required to separate
    the low-level modules from the high-level modules. IoC provides this technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various patterns to achieve IoC, including inverting the object creation
    process from your class to some other class and reducing the coupling between
    modules or classes. Let''s discuss these patterns, focusing more on how they decouple
    the modules and achieve separation of concerns:'
  prefs: []
  type: TYPE_NORMAL
- en: The factory method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The service locator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template method pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these patterns encapsulate a specific responsibility, which makes the
    system modular.
  prefs: []
  type: TYPE_NORMAL
- en: The factory method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The factory method pattern concerns defining an interface (or abstract class)
    method for creating dependency objects. This method is called a factory method. The
    class (or interface) that holds the factory method will be considered an abstract
    creator. The actual object creation process does not happen in the factory method
    directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concrete creators (which implement the factory method) will decide which
    dependent class to instantiate. In short, the dependent object is decided at runtime. This
    process has been described in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00052.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The factory pattern''s implementation is a four-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the product (the abstract product type).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating the concrete product.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defining the factory method – a creator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating concrete creators (concrete subclasses).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's understand these steps by using an example. Suppose you are developing
    an application for a message service provider. Initially, the company provides
    an SMS service for cellular devices. So, the first version of your application
    code is handling message distribution with SMS only, assuming that the bulk of
    code is written in the `SMS` class.
  prefs: []
  type: TYPE_NORMAL
- en: Gradually, the service becomes popular and you want to add other bulk message
    services, such as email, WhatsApp, and other social media message services. This
    requires code changes because you have added all the code to the `SMS` class.
    This change in code is required for every new messaging service that is introduced
    into the system in future.
  prefs: []
  type: TYPE_NORMAL
- en: 'The factory method pattern suggests that the solution to this problem will
    be inverting the object creation process from the client code (with a new operator)
    to a specific method: the factory method. The factory method defines a common
    interface that returns an abstract product type. A concrete product''s creation
    is done in the child classes, which implement the factory method. The objects
    returned from the factory method are referred to as **Product** in the preceding
    diagram. First, let''s define an abstract product type and its concrete implementation
    for the preceding example.'
  prefs: []
  type: TYPE_NORMAL
- en: Defining the product (abstract type) and its concrete implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our case, the **MessageApp** interface represents an abstract product type.
    The implementation of each messaging app would reside in their respective concrete
    classes, which are concrete product types, such as **SMSMessage**, **EmailMessage**,
    and **WhatsAppMessage**. This relationship is described with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00053.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The product (abstract type) and all of the concrete product classes should
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Defining the factory method (creator interface) and its concrete implementation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to create a class and define the factory method that returns
    the abstract product type (**MessageApp**, in our case). This class is considered
    an abstract creator. The factory method would be in the form of either an interface
    or the abstract method. All concrete creators must implement this factory method.
    The following diagram describes the complete relationship between these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.gif)'
  prefs: []
  type: TYPE_IMG
- en: Here, **MessagingService** is the creator, while **EmailServices**, **SMSServices**,
    and **WhatsAppServices** are concrete creators. Each concrete creator produces
    the respective concrete product type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The factory method and its concrete implementation classes should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding case, we have used an abstract class, but you can also use
    an interface for the factory method (abstract creator). If you are planning to
    provide any common methods, you can choose an abstract class, or else an interface
    would be an appropriate choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the factory class that provided the specific implementation looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This class returns the concrete implementation based on a specific `enum` type.
    The following code snippet depicts how client code can use the factory method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is described with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.gif)'
  prefs: []
  type: TYPE_IMG
- en: With the factory method pattern, you can make the product creation process abstracted
    from the client class. This way, the factory method pattern removes the dependency
    of the concrete product classes from the rest of the system. Additionally, the
    factory method delegates the actual object creation process to concrete creators.
    As long as the client code knows the type, the factory class will supply the dependency
    object of that type. This way, the factory method allows client code to depend
    on abstraction rather than concrete implementation. This is how IoC is achieved
    through the factory method pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The service locator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service locator pattern entails removing dependencies from the client object
    by introducing a mediator. The client object will talk to the mediator to get
    a desired dependency. We will call this mediator the service locator, or just
    the locator.
  prefs: []
  type: TYPE_NORMAL
- en: The service locator involves the process of obtaining services with the abstract
    layer. Ideally, the locator should hold all the services (dependencies) and provide
    them with a single interface. It is a kind of central repository to find a service,
    usually by a string or interface type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service locator describes how to register and locate the service rather
    than telling us how to instantiate it. It lets the application register the concrete
    implementation for the given contract. You can add services either programmatically
    or through configuration. The implementation of the service locator is described
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.gif)'
  prefs: []
  type: TYPE_IMG
- en: This is a very simple form of the service locator pattern. **ModuleA** is dependent
    on **ServiceB** and **ServiceC**, which are provided by the **Service Locator**.
    However, you can make the **Service Locator** more abstract so that it can handle
    any type of service. Let's understand how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is always a good idea to expose any service with an interface. We will take
    an example of two such service interfaces and their implementations in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to get compression and encryption services from the service locator.
    We will write the `ServiceLocator` class, which is a singleton, and allows us
    to register these services. Once this is done, the client can get the services
    by the type of service interface. The `ServiceLocator` class will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It is not mandatory to use the interface for registering the services, but it
    is good practice. In future, if any new service of the same interface is introduced
    or a completely new set of services of a brand new interface is introduced, they
    can be easily accommodated without affecting the client code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, with an interface, client code is more generic and you can change the
    implementation just by changing the key, making the system more flexible and loosely
    coupled. Finally, the service locator is used in client code, as you can see in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The service locator decouples the classes from their dependencies. The direct
    benefit of this arrangement is that the dependency can be replaced with little
    or (ideally) no code change. This way, the service locator pattern inverts the
    flow of control from the client code to the locator component. This is how IoC
    is implemented.
  prefs: []
  type: TYPE_NORMAL
- en: In the service locator pattern, you need to make sure that all services are
    readily available before your objects start consuming it.
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, it looks like the factory method pattern and service locator
    pattern work similarly. However, there are a few differences, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Construction cost:** If the class instantiation process inside the factory
    method is very expensive (in terms of resource consumption), then creating a new
    object in the factory method will result in performance issues. In short, the
    cost of construction in the factory method may impact overall system performance.
    In the service locator pattern, all of the dependency objects are created (ideally)
    during the application startup. The client can get the dependency service from
    a pre-instantiated registry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Existing versus new objects:** Sometimes, you need same object every time. In
    the factory method pattern, we are returning a new instance every time, while
    the service locator pattern returns an existing instance of the dependency service
    to the caller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ownership:** Since the factory class returns a fresh new instance to the
    caller, the ownership lies with the caller class, whereas the service locator locates
    and returns an existing instance of the service, and so the ownership of the returned
    objects would be with the service locator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template method pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The template method pattern involves defining the common structure of an algorithm,
    and then allowing subclasses to change or redefine some portion of the algorithm
    without changing the complete structure. In other words, the template method pattern
    defines a function in a set of operations, allowing subclasses to redefine a few
    steps without altering the complete structure.
  prefs: []
  type: TYPE_NORMAL
- en: In this pattern, the base class declares the generic procedure with placeholders
    and lets subclasses provide the specific implementations of those placeholders
    while keeping the overall structure unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand the template method pattern with an example. Suppose you
    are writing a program to take row data, validate it, format it, and insert it
    into a database. Initially, the row data is provided in a CSV file, so you have
    created a class called `ProcessCSVData`. This class contains the logic for the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading the CSV file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Formatting data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inserting the data into the database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A year later, a few more formats of raw data are introduced, such as HTML, XML,
    text, and Excel. For each of these formats, if you a create separate class, you
    will end up having lots of similar code. It is obvious that each of these classes
    is quite different in file formats, while their other logic of data validation,
    formation, and insertion into the database is identical among them.
  prefs: []
  type: TYPE_NORMAL
- en: Think about the client code where these classes are used. You need to provide
    lots of `if...else` conditions to choose a specific implementation. This is not
    a good design. To achieve reusability, it is essential to get rid of code duplication
    and make the algorithm structure unbroken. If all of these classes are sharing
    a common base class, this problem can be solved by using polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the template method pattern, you need to identify which steps of
    the algorithm are common and which are variants or customizable in nature. The
    common steps should be implemented in the base class, while the variant steps
    should be placed in the base class with either the default implementation or no
    implementation at all. The variant steps will be considered as placeholder or
    extension points that must be supplied by a concrete-derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, reading data from a file is the only varying step, so we will
    keep it in the base class with default (or no) implementation in the method. This
    is considered as a template method. All concrete subclasses must provide implementations
    of this template method (reading the file from the respective formats). Other
    steps, such as validating, formatting, and inserting into the database, are common
    or invariant, so keep them in the base class as is. This implementation is described
    by the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following code snippet represents this implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation''s subclasses should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the client code that uses the template method should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used just two subclasses in client code. Similarly, you can use the
    remaining two subclasses. You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The template method pattern allows the framework to define invariant pieces
    of the program and to specify the hook or placeholder for all possible customization
    options. This way, the framework becomes the center point of the product, while
    the customization is considered as an additional capability or add-on on top of
    the core functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The customization written for each of the template methods will get common functionalities
    from a generic framework or component. In other words, each client's customization
    receives the flow of control from the generic framework. The inverted control
    mechanism has been affectionately named the Hollywood Principle – "do not call
    us, we will call you". This is how IoC is achieved through the template method
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The strategy pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The strategy pattern defines a set of algorithms, encapsulates each of them,
    and makes them interchangeable at runtime. This pattern lets the implementation
    vary independently from the clients that use it. In short, you can change the
    output of a class by changing the algorithm at runtime. The strategy pattern focuses
    on creating an interface with different implementations that follows the same
    behavioral contract.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand this pattern with an example. Suppose you are developing an
    application to upload documents into the cloud. Initially, you have been provided
    with a Google Drive upload. You probably wrote the `GoogleDriveCloud` class and
    put all of the logic in that.
  prefs: []
  type: TYPE_NORMAL
- en: At a later stage, you decided to support uploading documents on a few more cloud
    platforms, such as Dropbox, OneDrive, and Amazon S3\. At this moment in time,
    you write separate classes for each of them, such as `DropboxCloud`, `OneDriveCloud`,
    and `AmazoneS3Cloud`.
  prefs: []
  type: TYPE_NORMAL
- en: All of these classes are used to upload documents onto the respective cloud.
    When you use them in your code, you will probably write the code to choose a specific
    implementation based on some condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding case, the `CloudUpload` class is tightly coupled with each
    of the cloud implementations, which is not a good design. You can think about
    the problems when you try to accommodate more cloud support in future. Every new
    implementation requires a change to the `CloudUpload` class. This is a clear violation
    of the open-closes principle: which talks about **open for extension but closed
    for modification**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This situation can be mitigated with the strategy pattern. The pattern involves
    defining a set of related algorithms (implementations of various cloud platforms)
    and encapsulating them in classes that are separate from the host class (`CloudUpload`).
    The solution is described with the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The implementation of the preceding diagram will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We have declared an interface called `Cloud`, which will be implemented by
    each concrete class. The  `CloudUpload` class represents a `Context` class. It
    holds the reference to `Cloud`, which is supplied through a constructor which
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In this design, each cloud implementation class has the logic of uploading a
    document to that particular cloud only, obeying the **single responsibility**
    principle. The `CloudUpload` class does not have a direct reference to any concrete
    class, but a reference of type `Cloud`, which holds the actual implementation.
    In this case, we are following this principle: **program to an interface, not
    implementation**.
  prefs: []
  type: TYPE_NORMAL
- en: 'After applying the strategy pattern, you may now upload the document by creating
    an object of the `CloudUpload` class and passing the appropriate implementation
    in the constructor, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In case of additional cloud implementation support in future, there is no change
    to the `CloudUpload` class. Unit testing becomes straightforward and easy. The
    `CloudUpload` class simply knows what to do with the strategy classes (the `Cloud`
    implementation) instead of putting conditional blocks to choose a specific implementation.
  prefs: []
  type: TYPE_NORMAL
- en: This way, the strategy pattern helps us to achieve pluggable behavior. The logic
    of choosing the `Cloud` implementation is now shifted from the `CloudUpload` class.
    This is how IoC is achieved with the help of the strategy pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Almost all IoC containers allow you to choose either code or file-based (XML)
    configuration for declaring dependencies. Although they serve the same purpose,
    you might feel confused as to which option is best for the given scenario.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, file-based (mainly XML) configuration is appropriate for the applications
    that need deployment to multiple environments. On the other hand, there are specific
    scenarios where code-based configuration is chosen over file-based configuration.
    Identifying the difference between these two will help you choose which one is
    right for you.
  prefs: []
  type: TYPE_NORMAL
- en: File-based (XML) versus code-based configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The benefit of XML-based configuration is that you can alter dependencies without
    recompiling, building, and deploying the application code. This sounds useful
    in a situation where you need to swap the dependencies of the same type. But again,
    is this really what you are looking for? In other words, if you do not have the
    requirements for changing the implementation of dependencies on the fly at runtime,
    then file-based configuration is not that useful.
  prefs: []
  type: TYPE_NORMAL
- en: On the downside, file-based configuration is generally more difficult to read
    and analyze, especially when it becomes large and clumsy. XML-based configuration
    does not warn you about any errors at compile time. Such errors can only be picked
    up at runtime, and they are quite tricky and time-consuming to fix. On the other
    hand, code-based configuration supports compile-time error checking. This means
    that if the build is successful, you are done and will not get any surprises at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Injection using the setter method versus the constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two straightforward options of DI – setter- or constructor-based DI.
    Both of these methods perform the same operation—injecting dependencies—but at
    different times of the object's lifespan. One happens during object instantiation,
    while the other happens on calling the setter method explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A very obvious dilemma comes into the picture when you implement DI with these
    two options. Understanding the difference is important because it reflects the
    basic problem of the object-oriented programming context: do we initiate the field
    variable with the constructor argument or through the setter method?'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Passing dependencies with a constructor is more clear in terms of describing
    what is required to create an object. You may write multiple versions of constructors,
    each taking a different combination of dependency objects, if that is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside initializing fields with the constructor, you can hide them by not
    providing a setter method. The advantage of this arrangement is that you can make
    sure the dependencies being set through the constructor will be available for
    the lifespan of an object. This is important, because if you do not want a particular
    dependency to be changed with the birth of an object, then initializing it with
    the constructor and not providing a setter will make it immutable. A constructor-based
    DI will decide the DI order while loading the context.
  prefs: []
  type: TYPE_NORMAL
- en: Passing the dependencies through the constructor will manage the order of the
    object creation graph and will eventually reduce the risk of circular dependency.
    Conversely, for constructor-based DI, Spring does not allow you to create a proxy
    with the **Code Generation Library** (**CGLIB**). You need to use either an interface-based
    proxy or a no-argument constructor.
  prefs: []
  type: TYPE_NORMAL
- en: You should choose the approach of passing dependencies into a constructor as
    your default preference. Ideally, all active/mandatory dependencies must be passed
    through a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Setter-based DI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The basic idea behind setter-based DI is that once the object is created (mainly
    with no argument constructors), a setter can be called to supply the dependencies
    to form an object graph, or just to supply the mock object for testing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Constructor-based DI is appropriate if there are only a couple of constructor
    parameters. If there are lots of constructor parameters, it will look messy. Even
    multiple versions of a constructor will not help much. In this case, you should
    rely on setter-based DI.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, all optional or conditional dependencies should be supplied through
    setter-based DI. The drawback to this approach is that you should make sure the
    setter methods are called before a client object starts using it. Another risk
    in using the setter method is that the dependency being altered at a later part
    of execution will result in an unexpected or ambiguous result, which is sometimes
    hard to trace. Also, if configuration is not done properly with the setter approach,
    you may end up with a circular dependency, which you could face at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A circular or cyclic dependency is a situation where two or more independent
    modules or components rely on each other to function properly. This is referred
    to as mutual recursion. Circular dependency generally occurs in a modular framework
    while defining a dependency between modules or components.
  prefs: []
  type: TYPE_NORMAL
- en: The term circular dependency is very common across domain models where a set
    of objects are associated with each other. Circular dependencies between classes are not
    necessarily harmful. In fact, in particular situations, they are appropriate.
    Take an example of an application where you are dealing with domain objects such
    as a student and a course. You probably need a `Student` class that gets courses
    a student has enrolled in, and a `Course` class that gets a list of students enrolled
    on that course. It is clear that the `Student` and the `Course` classes are interdependent,
    but if circular dependency is required in this case, then taking a chance to remove
    it may introduce some other problems.
  prefs: []
  type: TYPE_NORMAL
- en: In a software design context, circular dependency between software components
    or modules produces a negative effect and is hence considered a bad practice.
    This is probably a design issue. Generally, a software design with a poorly managed
    dependency is harder to maintain than one with a clear and layered module structure.
    While designing the system in a modular fashion, you need to keep in mind the
    problems that occur, especially due to circular dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Problems of circular dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Circular dependency can create many redundant effects in software programs.
    The very first among them in terms of design is the tight coupling between mutually
    dependent modules, which results in reusing an individual module becoming more
    difficult or impossible. In general, there are several reasons why you should
    avoid circular references between objects. It creates the following problems:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No dependency hierarchy and no reusability:** Generally, we quantify the
    code with the layer it is at; for example, high level, low level, and so on. Every
    layer should only set a dependency (if any) on the layers below it. Normally,
    when you define dependency between modules, a dependency graph or hierarchy will
    be created, but in the case of a circular dependency situation, this will be eradicated.
    This means that there is no dependency hierarchy. For example, say you have the
    following dependency hierarchy:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Module A depends on module B
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Module B depends on module C
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Assume that, at present, module C has no dependencies
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on this arrangement, we can identify module A as the top level, module
    B as somewhere in the middle level, and module C as the lower level of the hierarchy.
    Let's say that, after some time, we need to make module C dependent on module
    A (for whatever reason).
  prefs: []
  type: TYPE_NORMAL
- en: When this happens, there is no more differentiation between the high, middle,
    and low levels, which means that there is no longer a hierarchy. All modules are
    at the same level. Also, since they are in a circular dependency, they are no
    longer independent. This situation forms a single giant virtual module, which
    is divided into interdependent pieces. You cannot use any of them independently.
  prefs: []
  type: TYPE_NORMAL
- en: '**Changing replication:** Circular dependency creates a ripple effect of changes.
    For example, if any change happens in one module, this may impact other modules,
    which results in undesirable effects on the overall software architecture, such
    as compilation errors, and logical program errors. Due to its nature, circular
    dependency may create other unpredictable issues, such as endless recursion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Readability and maintainability:** Code that has a circular reference is
    naturally harder to understand and read than code that doesn''t have a circular
    reference. Such code is intrinsically delicate and easy to breach. Ensuring that
    your code is free from circular dependencies will make the code easy to work with
    and make the code be able to accommodate changes with ease, resulting in easy
    maintenance. From a unit testing point of view, code that has a circular dependency
    is more difficult to test since it can''t be isolated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Causes and solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have already seen, circular dependency mostly occurs as a result of bad
    design/coding practice. In large software application development, the coders
    may deviate from the context and produce a circular reference.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this, you can take the help of various tools to find unwanted circular
    dependencies. This should be an ongoing activity and be applied from the beginning
    of the development cycle. For example, Eclipse has a plugin called Java Dependency
    Viewer, which will help to see the dependency between classes and Java packages.
  prefs: []
  type: TYPE_NORMAL
- en: Issues of circular dependency can be addressed by following certain patterns
    and principles, which are discussed in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand how circular dependency can be eliminated by applying the
    single responsibility principle. Let''s assume you are following three modules
    in a system:'
  prefs: []
  type: TYPE_NORMAL
- en: Salary module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Employee module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HR module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Salary module** generates salary and sends it over email. Generating
    salary depends upon the **Employee module**. To get a few details, such as the
    appraisal process, and reward points the **Employee module** depends upon the
    HR module. At this moment, the dependency hierarchy will be as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00059.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'At some point in time, let''s say you need email functionality in the **HR
    module**. Since email functionality is present in the **Salary module**, you decide
    to give dependency of the **Salary module** to the **HR module**. At this moment,
    the dependency graph looks like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00060.gif)'
  prefs: []
  type: TYPE_IMG
- en: This situation forms a circular dependency. To avoid this, you need to follow
    the single responsibility principle. This principle states that a module or class
    should hold responsibility of a single part of the functionality. That module
    or class should take total ownership of that functionality and must be encapsulated
    entirely. All services provided by the module must not deviate from the main functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the Salary module not only generates salary, but sends emails,
    too. This is a violation of the single responsibility principle. When a single
    module performs more than one responsibility, there''s a chance of poor dependency
    management, which may result in either:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code duplication:** You may write similar and common functionalities in multiple
    modules. For example, in this case, you may write an email sending functionality
    in the HR module to avoid circular dependency, but will end up with code duplication,
    which raises maintenance problems later on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Circular dependency:** As we have seen in the preceding case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You need to write a separate module called the Utility module and put the email
    sending functionality in that. After you have refactored this code, both the **HR
    module** and the **Salary module** are now dependent on the Utility module. This
    is how circular dependency can be removed: by following the single responsibility
    principle.'
  prefs: []
  type: TYPE_NORMAL
- en: Deferring the setting of a dependency from constructor to setter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s understand how solves circular dependency by providing a dependency
    from the constructor to the setter method. There is a special case where due to
    circular dependency, you can''t even create the object of the domain model. For
    example, say you are developing an application for a `tyre` manufacturer; who
    uses these tyres for cars. Based on the car''s max speed, you need to set the
    min rim size of the `tyre`. For this, you have created the `Car` and `Tyre` classes,
    as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the `Car` and `Tyre` classes are dependent on each another.
    The dependency is passed through the constructor, hence why it is a circular dependency.
    You can''t create an object for either of them. To handle this situation, you
    need to defer setting the dependency from the constructor to the setter in each
    case. We decided to make this change in the `Car` class, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency (of `Tyre`) is moved from the constructor to the setter method.
    In the `Tyre` class, you need to set a reference of the current class (`Tyre`)
    into the `Car` object, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything is settled now. You can create an object of type `Car` first, then
    create an object of type `Tyre` so that you can pass the reference of the `car`
    object to it. The client code will be as in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Relocation of classes and packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the possible reasons for circular dependency is a chain of dependencies
    starting from some classes in a Java package. Let's say that `com.packt.util` traverses
    with a different package and reaches some other class in the same package, `com.packt.util`.
    This is a package arrangement issue that can be solved by moving the classes and
    restructuring the packages. You can perform such refactoring activities with modern
    IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: Circular dependency in the Spring framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s explore how circular dependency occurs in the Spring framework and how
    to deal with it. Spring provides an IoC container that loads all the beans and
    tries to create objects in a specific order so that they work properly. For example,
    say we have three beans with the following dependency hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Employee` bean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`HRService` bean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CommonUtilService` bean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Employee` bean depends on the `HRService` bean, which depends on the `CommonUtilService`
    bean.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, `CommonUtilService` is considered a low-level bean, while the
    Employee bean is considered a high-level bean. Spring will first create an object
    for all low-level beans so that it creates the `CommonUtilService` bean, then
    it will create the `HRService` bean (and inject the object of the `CommonUtilService` bean
    into it), and then it will create an object of the `Employee` bean (and inject
    the object of the `HRService` bean into it).
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to make the `CommonUtilService`bean dependent on the `Employee`.This
    is circular dependency. Furthermore, all dependencies are set through a constructor.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of circular dependency, the difference between high and low-level
    modules disappears. This means that Spring will be in a dilemma of which bean
    should be instantiated first, since they depend on each other. As a result, Spring
    will raise a `BeanCurrentlyInCreationException` error.
  prefs: []
  type: TYPE_NORMAL
- en: This will only happen in the case of constructor injection. If dependencies
    are set through the setter method, this problem will not occur, even if beans
    are interdependent. This is because at the time of context loading, no dependencies
    are present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the code for this and see how Spring detects circular dependency.
    The code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The Java config and client code will be as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'On running this code, you will get a `BeanCurrentlyInCreationException` error
    for all the beans, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To avoid this situation, you need to redesign the preceding structure. In a
    few circumstances, it's not possible to change the structure, maybe due to design
    limitations of the legacy code. In this case, Spring provides some solutions,
    as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Using setter/field injection over constructor injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is probably the most easy and straightforward option. In circular dependency,
    if constructor injection creates a circular reference, you can defer the DI in
    the setter method. This allows Spring to load a bean context without any issues.
    The updated code would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: All dependencies are set in the setter method with the `@Autowired` annotation.
    Spring will create instances of all three beans first and will then set them with
    the setter method.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the `@Autowired` annotation on fields of the bean is equivalent to setter
    injection. If you annotate the fields of the class with the `@Autowired` annotation,
    Spring will not complain about circular dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Using the @Lazy annotation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another workaround is to use the `@Lazy` annotation. This annotation will instruct
    Spring to load the bean only when it is used, instead of at the time of context
    loading. Spring will create a proxy of the bean during context loading and will
    pass it into another object. The updated code will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The constructor dependencies are set through the `@Lazy` annotation. This code
    will run without any issue. The actual dependency is injected only when it''s
    being called. To demonstrate this, the  `displayEmployeeName` method is created
    in the `Employee` bean, which we will call with the dependency reference from
    the `CommonUtilService` bean, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `showEmployeeNameFromDependency` method is called, it will internally
    call the `displayEmployeeName` method on the employee reference in `CommonUtilService`.
    When this happens, Spring will actually inject the dependency. You will get the
    following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Best practices and anti-patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have talked about using IoC containers to achieve DI, but one of
    the most common mistakes is to use IoC containers without doing real DI. This
    may sound strange, but it is a fact. Such mistakes are possible in the absence
    of having a proper understanding of underlying concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, DI implementation should only reference the IoC container during the
    time of the application's startup. If a developer wraps the IoC container itself
    and passes it into other component to reduce any dependency, this is not a good
    design. Let's understand this issue with an example.
  prefs: []
  type: TYPE_NORMAL
- en: What to inject – the container itself or just dependencies?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The situation of injecting container occurs when you try to wrap the container
    itself either in a singleton class or a public static method to provide the dependency
    to other components or modules, as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is equivalent to the service locator pattern. In this code, the `ServiceManager` class
    holds the reference of the container. It will return the dependency (services)
    through its static method. The  `EmployeeService ` class uses the `ServiceManager` to
    get its dependencies (`HRService` and `AccountService`). At first glance, this
    looks perfectly fine as we don't want the `EmployeeService` to be tightly coupled
    with `HRService` and `AccountService`.
  prefs: []
  type: TYPE_NORMAL
- en: Though we removed the coupling of dependencies in the preceding code, this is
    not what we mean by DI.  The fundamental mistake in the preceding case is that
    instead of providing the dependency, we are relying on other classes to supply
    it. In reality, we are removing the dependency of one entity, but adding another.
    This is one of the classic examples of using an IoC container very badly and without
    implementing DI properly.
  prefs: []
  type: TYPE_NORMAL
- en: The `ServiceManager` class is a singleton class that supplies the dependencies
    with its static method. Instead of injecting `HRService` and `AccountService` into `EmployeeService`,
    we are relying on `SerivceManager` to provide the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: You might argue that the preceding approach will replace multiple dependencies
    with a single class, and will effectively reduce the dependency. However, the
    benefits of DI are not 100% achieved. The design issue of being tightly dependent
    on `ServiceManager`  is unseen until any change happens in that class. For example,
    if you change the configuration of either the `HRManager` or `AccoutService` class,
    you need to change the code of `ServiceManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Another side effect of this scenario is that things are not clear from a unit
    testing point of view. The benefit of DI is that just by looking at the constructor
    of the class, you should know what things are dependent on it so that you can
    inject the mock object very easily while doing unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: The scenario in this case is the opposite. Ideally, the caller should supply
    the dependency, but in our case, the caller doesn't provide anything, while the
    component (`EmployeeService`) is getting the dependencies by using its own singleton
    class. The constructor of the `EmployeeService` class will be empty and you probably
    won't determine its dependency until you refer to its source code thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding design is more of a service locator implementation. However,
    there are a few other limitations of the service locator, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation: ** The services added into the registry are ultimately black boxes
    to the caller or client class. This results in a less reliable system as it would
    be difficult to identify and rectify the errors that occur in the dependency services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concurrency: ** The service locator has a unique registry of services, which
    may cause a performance bottleneck if it is accessed by concurrent components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency resolution:** For the client code, the registry provided by the
    service locator is kind of a black box, and this may cause issues at runtime,
    for example, if dependencies are not yet registered, or there are any dependency-specific
    issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintainability:** In the service locator, since the code of the service
    implementation is isolated from clients, it is unclear when the new changes will
    break this functionality at runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testability:** The service locator stores all of the services in the registry,
    which makes unit testing a bit harder since all of the tests may rely on the registry
    to set various mock service classes explicitly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our goal is to make the client code 100% decoupled from its dependencies or
    any class who supplies the dependencies. In the preceding case, we want to break
    the coupling between `EmployeeService` and its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve the preceding design and rewrite the `EmployeeSerice` class,
    as in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, the `EmployeeService` class does not depend on the `HRService` and `AccountService` classes.
    This is what we wanted to achieve. Your business code should not know anything
    about its dependencies. It is the IoC container's job to provide them. This code
    is now more readable and easy to understand. The dependencies can be predicated
    just by looking at the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to instantiate `EmployeeService`, you just need to pass the object
    of the `HRService` and `AccountService` classes. While doing unit testing, you
    can just pass the mock objects and test the integration between these services.
    The process becomes very simple now. This is the correct implementation and meaning
    of DI.
  prefs: []
  type: TYPE_NORMAL
- en: Excessive injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every design pattern solves specific design problems, but any single pattern
    is not necessarily appropriate for every case that you come across. A pattern
    or methodology you are applying should be chosen because it is the right choice
    for the given problem, not just because you know it and wish to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection is a pattern (and not a framework), so you need to consider
    the right scenario to implement it. There are chances that may make DI become
    redundant. It is not necessary to inject everything in your code. If you do so,
    the purpose of making the code decoupled is not achieved properly; instead, the
    dependency graph becomes ineffectual.
  prefs: []
  type: TYPE_NORMAL
- en: Evidently, DI produces great flexibility in terms of code maintenance, executing
    unit testing in a more meaningful and useful way to achieve modularity. However,
    you should utilize its flexibility only when you really need to. The intention
    of DI is to diminish coupling instead of wrapping and supplying every single dependency,
    which is not a wise decision.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's say that you need a `Calendar` object to perform various
    calendar-related operations. The traditional way is by using a static method -
    `getInstance` of the `Calendar` class, for example, `Calendar.getInstance()` .
    It is a kind of static factory within the `Calendar` class, which creates the
    object.
  prefs: []
  type: TYPE_NORMAL
- en: If you try to pass the `Calendar` object with DI, you will not achieve anything
    new. All of the methods in which the `Calendar` object is passed through (an entire
    call chain – from where it is injected to where it is used) will have additional
    arguments. This ultimately adds the burden of passing the `Calendar` object to
    the programmer. Also, the `Calendar` object is not injected with an abstraction,
    so the argument is of the `Calendar` type rather than any abstract or interface. This
    means that there is no clear benefit of changing the implementation because we
    are passing the dependency with the concrete type rather than the abstract type
    (because that is not possible for the `Calendar` class in Java).
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, any Java, third library, or custom class that simply provides static
    functionality that can be common across all components or modules should be used
    either statically (class reference) or in a single instance mechanism (if an instance
    is required) instead of injecting them into classes.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is using `Logger` in Java. A typical way of getting a logger
    instance is to call the `getLogger` static method of the `Logger` class and pass
    the class which you want to provide the logging feature of. In this case, passing
    the `Logger` object with DI would be overkill.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, but injecting such a library with DI would result in reducing
    the availability of functionalities available only to those components that take
    the dependencies either through a constructor, the method, or property injection.
    Also, there is almost no chance of providing any meaningful abstraction that can
    be easily applied to any such libraries. This will keep you from getting any meaningful
    flexibility over the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Choose DI patterns when you need to supply dependencies with different configurations
    of dependencies or when you want to back different implementations of the same
    dependency. If it is not required to mix up your dependencies or to supply different
    implementations, then DI is not an appropriate solution.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving IoC in the absence of a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are well aware that DI is meant to provide the dependencies to components
    through either a constructor, the setter method, or properties to make them separate
    from dependency services. The conventional understanding is that this can only
    be possible by using IoC containers. However, this is not true for all cases.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, IoC containers should be used for configuring and resolving a comparatively
    large set of dependencies in complex applications. If you are dealing with a simple
    application that has just a few components and dependencies, it is sensible not
    to use containers. Instead, you can wire dependencies manually.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in the case of any legacy system where the integration of a container
    is difficult, you can opt for supplying dependencies manually. You can implement
    various patterns, such as the factory method, service locator, strategy, or template
    method patterns, to manage the dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a few important points about the best practices and patterns
    for managing dependencies in this chapter. Though it is proven that DI brings
    greater flexibility and modularity in the code by decoupling the client code from
    its dependencies, there are a few things that we should follow to get the best
    out of it.
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, we learned about patterns other than DI that help us to implement
    IoC. You can definitely use them in your code to decouple modules where the use
    of IoC containers is not possible. For example, in a legacy code where managing
    dependencies is not possible through an IoC container, these patterns are useful
    to achieve IoC.
  prefs: []
  type: TYPE_NORMAL
- en: We became familiar with various configuration options and learned how to choose
    the right one. We also saw the injection styles used in wiring the dependencies.
    When working with dependency management, one very obvious problem that occurs
    is circular reference, which causes circular dependency. We have observed what
    problems circular dependencies create, what the cause of them is, and how to avoid
    them in coding.
  prefs: []
  type: TYPE_NORMAL
- en: At the end, we dived into best practices, patterns, and anti-patterns that you
    should follow while using DI. If we know how to do something, it does not mean
    that it is applicable all the time. The same is applicable to DI. It is a pattern,
    and hence it should be used in the right manner to solve specific problems. It
    may not be suitable for all conditions.
  prefs: []
  type: TYPE_NORMAL
- en: We are taking a pause here. We hope you enjoyed the journey of learning about
    DI throughout the book. We tried to convey the fundamentals as simply as possible.
  prefs: []
  type: TYPE_NORMAL
