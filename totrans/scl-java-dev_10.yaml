- en: Chapter 10. Scala Goodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have covered a number of technologies and toolkits in the previous chapters
    that, when combined together, offer a great opportunity to build modern and scalable-reactive
    web applications in Scala. Scala now celebrates 10 years of existence with an
    active community and large corporations supporting it, leading to a perpetual
    exploration of innovative ideas touching the language and the ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'We propose, in this last chapter, to touch upon a few areas where we have found
    some exciting ongoing projects or technologies and where we feel that Scala can
    provide elegant solutions to be both productive and fun. We will cover some of
    the following aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: NoSQL database access through MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing DSLs and in particular, a glimpse at Parser Combinators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scala.js—compiling Scala to JavaScript on the client side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the volume of information to process and store has drastically increased
    in the past few years, many IT shops have been looking for alternatives to traditional
    relational databases to store and query data. The **not only SQL** (**NoSQL**)
    database movement has gained popularity as a way to trade consistency and structure
    of the data for more efficient or flexible data storage. MongoDB ([www.mongodb.org](http://www.mongodb.org))
    is a database product designed to store documents in formats, such as JSON, and
    with no strict database schema. Along with the Java driver built to access and
    query a MongoDB database, we are going to discover how the Casbah Scala toolkit
    ([https://github.com/mongodb/casbah](https://github.com/mongodb/casbah)) can be
    used to conveniently access and query such a database through a DSL.
  prefs: []
  type: TYPE_NORMAL
- en: Entering Casbah
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The only requirement to start experimenting with Casbah is to add its `.jar`
    library dependency to an SBT or Play project. In a new directory on your disk,
    type `> play new ch10samples` from a terminal window and add the Casbah dependency
    to the `build.sbt` file in the root directory of the project. This dependency
    is added by adding the following code (note that the given version of Casbah was
    the latest available at the time of writing this chapter, but should soon be available
    as the final version 2.7.0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using an SBT project instead of Play, you may also add a default
    SLF4J logging implementation, as shown in the following code snippet, as otherwise
    the default used is a no-operation implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, starting an REPL can be done either by entering the `> play` command
    followed by a `> console` command or just `> play console`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After some imports, we connect to the MongoDB database on port `27017` using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These statements have, so far, been executed without a direct contact with
    the database. From now on, we need to make sure we have a running instance of
    the MongoDB process before we retrieve any content. Start the `mongod` daemon
    if it is not running yet (download instructions can be found at [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)),
    then enter the following command to fetch the names of the stored collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We obviously get an empty set as a result, as we haven''t stored any document
    yet. Let''s create a couple of entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The created items have yet to be added to the database, using the `insert`
    command as shown in the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Retrieving the elements of the `coll` collection can be done using the `find`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that a primary key for each document has been created as we did not
    provide any while inserting the document into the collection. You may as well
    retrieve a single document if you know exactly the object you are looking for
    and provide it as an argument. For this, the `findOne` method is available, passing
    a new `SearchedCountry MongoDBObject` as expressed in the following command lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As there might not always be a matching element, the `findOne` method returns
    `Option`, which in the previous case resulted in `Some(value)`, in contrast to
    the following empty result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting elements is performed with the `remove` method, which can be used
    in a manner similar to the `findOne` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, updating a document can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can see here that the primary key "530fd91d03645ab9c17d9012" is still the
    one we had when we initially inserted the `sales` document into the database,
    showing that the `update` operation was not a removal and then inserting a brand
    new element.
  prefs: []
  type: TYPE_NORMAL
- en: Updating multiple documents at once is also supported and we refer to the documentation
    available at [http://mongodb.github.io/casbah/guide/index.html](http://mongodb.github.io/casbah/guide/index.html)
    for further operations.
  prefs: []
  type: TYPE_NORMAL
- en: Applying MapReduce transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among the great features of document-oriented databases such as MongoDB, there
    is the possibility to run the MapReduce functions. **MapReduce** is an approach
    where you break up a query or task into smaller chunks of work, and then aggregate
    the results of those chunks. To illustrate how a document-based approach can sometimes
    be useful in contrast with a traditional relational database, let''s take a small
    example of financial consolidation. In such a domain, aggregating and calculating
    sales figures globally for a large corporation may involve working with a number
    of orthogonal dimensions. For instance, sales figures can be gathered from each
    subsidiary that each has its own geographic location, time intervals, own currency,
    and specific categories, following some tree-based structures in each dimension
    as depicted in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying MapReduce transformations](img/3637OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The geographic location might be a decisive factor when it comes to the currency
    used, and conversion should be done to sum figures consistently. To that extent,
    the currency used to produce global reports usually follows the root of the company
    ownership tree. A company tree structure is given in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying MapReduce transformations](img/3637OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, various sales categories might define yet another hierarchy, as
    shown on the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying MapReduce transformations](img/3637OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Such reported sales figures may either be very detailed or already accumulated,
    therefore, reported at various levels of the hierarchies. As large corporations
    are usually made of smaller groups with various degrees of ownership that are
    furthermore changing regularly, the consolidation job requires to aggregate and
    compute data according to all these parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'As for a number of data warehousing solutions expressed in relational databases,
    the heart of the domain model can be a huge table containing facts referring to
    the various dimensions expressed in the previous figure. For instance, some sample
    input data for this example can consist in the following list of sales figures
    (that is, amounts) as XML rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying MapReduce transformations](img/3637OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following construct shows how to represent a tree structure in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is an example of a JSON document that contains sales figures
    by geographic location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: By storing documents coming from various subsidiaries of a large corporation,
    such as JSON, we can consolidate the figures through MapReduce transformations
    already supported by the database. Moreover, Casbah takes advantage of the aggregation
    framework ([http://mongodb.github.io/casbah/guide/aggregation.html](http://mongodb.github.io/casbah/guide/aggregation.html))
    of MongoDB to be able to aggregate values without having to use MapReduce
  prefs: []
  type: TYPE_NORMAL
- en: To conclude with MongoDB, we will just mention the ReactiveMongo project ([www.reactivemongo.org](http://www.reactivemongo.org))
    that figures a reactive asynchronous and non-blocking driver for MongoDB. As it
    uses the Iteratee pattern that we covered in [Chapter 9](ch09.html "Chapter 9. Building
    Reactive Web Applications"), *Building Reactive Web Applications*, combining it
    with a stream-friendly framework, such as Play, can result in a number of interesting
    and scalable demos, as listed on their website.
  prefs: []
  type: TYPE_NORMAL
- en: Scratching the surface of Big Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Among the recent achievements and trends towards better analysis of data and
    services lies the Big Data movement. In particular, the Hadoop framework has established
    some kind of ad hoc standard "for the distributed processing of large datasets
    across clusters of computers using simple programming models". In addition to
    a distributed file system called HDFS optimized for high throughput to access
    data, Hadoop offers MapReduce facilities for processing large datasets in parallel.
    As setting up and running Hadoop is not always considered a simple task, some
    other frameworks have been developed on top of Hadoop as a means to simplify the
    definition of Hadoop jobs. In Java, the Cascading framework is a layer on top
    of Hadoop that provides a convenient API to facilitate creation of MapReduce jobs.
    In Scala, the Scalding framework has been developed to further enhance the cascading
    API by utilizing the concise and expressive Scala syntax, as we can observe by
    taking a look at the `activator-scalding` Typesafe activator template. The sample
    code provided with this template illustrates a word counting application, that
    is, the `hello-world` project of Hadoop MapReduce jobs.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder on MapReduce jobs, consider reading the original paper from Google,
    available at [http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf](http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf)
  prefs: []
  type: TYPE_NORMAL
- en: 'We can express the job of counting words with the following two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting lines from a file into individual words and creating a key-value pair
    for each word, where key is the word of the `String` type and value is the constant
    `1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By grouping the elements having the same key (grouping the same words) into
    a list and reducing the list by summing the values, we obtain our goal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you run the `> activator ui` command in a terminal window, as we already
    did a number of times in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala
    Ecosystem"), *Understanding the Scala Ecosystem*, and create the `activator-scalding`
    template project, you can verify how concise the word count in scalding is specified.
    Do not forget to run the `> activator eclipse` command to be able to import the
    project into the Eclipse IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Most of the code is indeed comments, which means that the whole algorithm is
    very close to the description one would do in pseudo code.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in Big Data, Scala definitely fits a niche and a number
    of projects and frameworks handling huge streams of data and Hadoop-like jobs
    are already pushing the limits. Among them, we can mention Spark ([http://spark.apache.org](http://spark.apache.org))
    as well as Twitter's open-source projects SummingBird ([https://github.com/twitter/summingbird](https://github.com/twitter/summingbird))
    and Algebird ([https://github.com/twitter/algebird](https://github.com/twitter/algebird)).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing DSLs in Scala
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Domain specific language** (**DSL**) is usually useful to simplify the interaction
    with a system by being applied to a small particular domain. They can be targeted
    to programmers by providing a simplified API to communicate with a system; or
    they may concern the so-called "business users" who may understand a domain well
    enough to create some scripts but are not programmers and could have difficulty
    dealing with a general-purpose programming language. There are, in general, two
    types of DSLs:'
  prefs: []
  type: TYPE_NORMAL
- en: Internal DSLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External DSLs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing internal DSLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Internal DSLs use a host language (for instance, Scala) and the simplified usage
    is obtained by adding some syntactic sugar, through tricks and special constructs
    of the language. The book *DSLs in Action* by Debasish Ghosh illustrates the construction
    of Scala internal DSLs using features of the language such as infix notation and
    implicit conversions.
  prefs: []
  type: TYPE_NORMAL
- en: 'He has given the following DSL usage example that represents an executable
    program expressed in clear English: `200 discount bonds IBM for_client NOMURA
    on NYSE at 72.ccy(USD)`. Many transformations happen under the hood, but the business
    user is given a very clean syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Such DSLs have the advantage that you are confident that you can express anything
    with them as the host language is of generic purpose (such as Scala). This means
    that sometimes you may be constrained to use a less clean syntax but you know
    you have the full power of the Scala compiler under your hands. Therefore, you
    will always succeed in producing a DSL script or program that implements the logic
    you want.
  prefs: []
  type: TYPE_NORMAL
- en: However, the full power of the compiler may also be something that you would
    like to avoid in many cases where you want to give your business user the possibility
    to only perform a few specific actions. For this purpose, you may implement external
    DSLs instead. There are a number of additional concerns including constrained
    syntax (for example, you can't avoid parentheses in some cases) and convoluted
    error messages.
  prefs: []
  type: TYPE_NORMAL
- en: Tackling external DSLs through parser combinators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An external DSL represents a domain language where the syntax is completely
    up to you. This means you can express things exactly the way you want to and can
    constrain your business users to only use specific words or meanings. This flexibility
    comes with a price of much more work to implement it as you need to define a grammar
    (typically **Backus–Naur Form** (**BNF**)), that is, define all the rules that
    apply to parse a meaning or script successfully. In Java, the task to write an
    external DSL can be cumbersome and it usually involves the ANTLR external framework.
  prefs: []
  type: TYPE_NORMAL
- en: In Scala, parser combinators are a notion very close to the definition of BNF
    grammars and can provide very concise and elegant code when writing external DSLs.
  prefs: []
  type: TYPE_NORMAL
- en: Once you get acquainted with a few particular operators to deal with the definition
    of the grammar, you will discover that writing an external DSL is fairly straightforward
    if your language is not too complex. A good source of information to learn all
    the symbols and operators involved in parser combinators is available at [http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/](http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following experimental code illustrates a small DSL in the domain of finance
    consolidation where specific money accounts are manipulated as part of predefined
    formulae. The main method given at the end of the following snippet reflects a
    formula; for instance, you may parse the formula (`3*#ACCOUNT1#`) to construct
    an object-oriented structure that will be able to compute the result of multiplying
    the content of a given account by three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The objects that will result from the parsing of a formula are defined as **case
    classes**. Hence, continuing with the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute this parser combinator code into Eclipse by simply right-clicking
    on the `FormulaCalculator` class and navigating to **Run As** | **Scala Application**,
    we should obtain the following output in the Eclipse console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This output shows that the three formulae were parsed correctly and converted
    into classes. The final evaluation is left out from this exercise but could be
    set up with some actual transactions defined on the two accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Scala.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Where Java is a compelling choice to run server-side code due to its robust
    JVM that can be run anywhere, JavaScript is increasingly becoming the dominant
    choice on the client side due to its flexibility and light runtime-embedded environment
    as well as its growing set of tools already available in the browsers. Despite
    its popularity, JavaScript being a dynamic language does not offer the type of
    safety that languages such as Java or Scala provide. The experimental but fast-growing
    Scala.js initiative aims at compiling Scala to JavaScript and in my view offers
    a really good alternative for those who want to benefit from the power of the
    Scala type system all the way to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a project demonstrating the usage of Scala.js can be done in a couple
    of minutes and is explained in the sample "getting started" project available
    at [https://github.com/sjrd/scala-js-example-app](https://github.com/sjrd/scala-js-example-app).
  prefs: []
  type: TYPE_NORMAL
- en: 'The example consists of a small HTML page containing a `playground <div>` element
    as illustrated in the following HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The `div` element will be dynamically populated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The tiny snippet of code written in Scala and compiled to Javascript to achieve
    this is given in the following `main` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once we have the access to the DOM of the HTML page through the `js.Dynamic.global`
    object, this simple Scala `main` method constructs a new paragraph node and adds
    it to the existing `"playground"` node.
  prefs: []
  type: TYPE_NORMAL
- en: The additional `square` method is used to illustrate a unit test written against
    the Jasmine JavaScript test framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'The execution of the `main` method is triggered by the one line added to the
    `js/startup.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The generated code produced by default by Scala.js can be quite big because
    of dependencies to Scala libraries. Scala.js offers an optimization through Google's
    closure compiler that reduces the size and optimizes the JavaScript code execution
    when targeted for production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the next step now? Well, we can refer interested readers to a couple
    of more projects that we find interesting with regard to this book:'
  prefs: []
  type: TYPE_NORMAL
- en: A project called `play-with-scalajs-example` and available at [https://github.com/vmunier/play-with-scalajs-example](https://github.com/vmunier/play-with-scalajs-example)
    deals with a simple integration sample of Scala.js and the Play Framework that
    we have covered in the previous chapters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A very interesting and more advanced usage of Scala.js is `TodoMVC` and this
    is a part of the `workbench-example-app` project available at [https://github.com/lihaoyi/workbench-example-app/](https://github.com/lihaoyi/workbench-example-app/).
    It demonstrates a sample web app for making To Do Lists, a reference app specified
    to compare different implementations done in various languages, but has the innovative
    approach of being reactive in addition to being written in Scala compiled to JavaScript.
    A direct link to the resulting reactive web app is available at [http://lihaoyi.github.io/workbench-example-app/todo.html](http://lihaoyi.github.io/workbench-example-app/todo.html)
    and is rendered in a browser, as shown in the following screenshot:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Introducing Scala.js](img/3637OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There are already a number of projects around Scala.js listed on its home page
    at [http://www.scala-js.org/](http://www.scala-js.org/). As Scala.js is maturing
    quickly, many more projects should be soon available.
  prefs: []
  type: TYPE_NORMAL
- en: Final tips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following sections enlist a few final tips and tricks that you might find
    handy while working with the REPL.
  prefs: []
  type: TYPE_NORMAL
- en: Copying and pasting in the REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As a reminder, this feature introduced in [Chapter 8](ch08.html "Chapter 8. Essential
    Properties of Modern Applications – Asynchrony and Concurrency"), *Essential Properties
    of Modern Applications – Asynchrony and Concurrency*, makes it easy to execute
    a full code snippet at once in the REPL. For instance, the following lines of
    command illustrate how the copy and paste feature in REPL helps the easy execution
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Timing code execution in the REPL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The REPL has been a very helpful tool throughout this book to discover and experiment
    with the various features of Scala. Together with the Scala worksheets introduced
    in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"), *Understanding
    the Scala Ecosystem*, they enhance our productivity by providing continuous feedback
    and make our development, therefore, more agile. Sometimes, it is convenient to
    measure the time it takes to execute statements or code snippets in the REPL.
    This is why we have given one way of achieving this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define a `help` function called `using` that takes two parameters,
    first a `param` argument of the type `A` and second, a function argument `f` that
    transforms the type of an argument from `A` into `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What `using` does is to invoke the `f(param)` function, wrapping it into a
    `try {} finally{}` block. As the idea behind this function is to apply it on an
    I/O resource such as `FileWriter` or `PrintWriter`, we want to guarantee that
    we can close the resource no matter what. This is why you can see a `param.close`
    call in the `finally` block. That means the `param` argument cannot just be of
    any type `A`; it must have the additional requirement to have a `close` method.
    This is exactly what is declared at the beginning of the definition of the generic
    `using` method (that is, `[A <: {def close(): Unit}, B]`); the `param` argument
    should be a subtype of `A` that contains a method with the given signature.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, dealing with generic types is out of the scope of this book, and
    you don't need to really understand the previous definition to benefit from the
    `using` function. The example illustrates, however, how powerful the use of generic
    types in Scala can be. The type system of Scala is extremely powerful and the
    compiler will help you very much when writing generic code, unlike the use of
    generics in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now include the `using` function into an `appendToFile` function that
    will be responsible for logging the evaluation of the code we write in the REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the following `timeAndLogged` function is declared to wrap a body
    snippet entered in the REPL with both the logging and timing functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Until Scala 2.10.0, you could use the `:wrap` method of the REPL power mode
    (accessible from the REPL via the `> :power` command) to be able to execute all
    the console statements without further involvement of the `timedAndLogged` function.
    The `:wrap` feature has recently been removed from the Scala release, so you will
    have to explicitly wrap the code that you want timing or logging for in the `timedAndLogged`
    method and therefore, do not need to involve the power mode of the REPL for that.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, you can execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `/tmp/repl.log` file we specified in the `timedAndLogged` function should,
    of course, contain the logged result, that is, `2014`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we now reach the end of this book, we would like to emphasize some key aspects
    on the numerous topics and concepts we have approached during this journey with
    Scala.
  prefs: []
  type: TYPE_NORMAL
- en: The concise and expressive syntax of the Scala language should make your code
    not only more readable but also more maintainable for yourself and other developers.
    You don't have to give up any of the libraries of the very large and mature Java
    ecosystem as all the APIs can be reused directly within Scala. Moreover, you benefit
    from many additional great Scala-specific libraries. Our recommendation is to
    take a piece of Java code from a domain you understand well, maybe because you
    wrote it in the first place one or several times before. Then, try to convert
    it to Scala code and refactor it to get rid of the boilerplate and to make it
    in a more functional style.
  prefs: []
  type: TYPE_NORMAL
- en: The Play Framework is not just another web framework; it breaks the conventional
    approach of long-cycle development following servlet and EJB containers where
    each redeploy can take a significant time. Moreover, it is built on top of rock
    solid and scalable technologies such as Akka, which should make you feel confident
    for future heavy loads and constraining availability requirements. Finally, our
    personal experience with it has been very enjoyable as the Scala compiler behind
    it has, most of the time, given very clear feedback on what the problems are when
    mistakes are made, all the way to the templates and routes specifications. As
    both Play and Akka are exposing Java APIs as well, they can make your transition
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: We believe the future of web development is reactive, dealing with large streams
    of data, as it is already happening in many areas such as social media sites involving
    content distribution and real-time financial/analytics services.
  prefs: []
  type: TYPE_NORMAL
- en: We have only scratched the surface of what is possible to do with Scala. As
    you go along and dive more deeply into individual technologies, you will discover
    new features and endless possibilities. Our recommendation is to take one step
    at a time looking for achievable goals. For instance, first get used to the Scala
    collections, especially as they can help you to better master Java lambdas and
    functional programming, then write code with pattern matching, traits, for comprehensions,
    then move to more advanced topics such as implicits, generics and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as inspiration, there is already a tremendous number of open source
    projects done with Scala, many books on the individual subjects we have covered,
    many forums contributed by a very active Scala community, as well as several years
    of extremely useful online videos coming from user groups and international conferences
    such as Scaladays ([www.scaladays.org](http://www.scaladays.org)), Scala eXchange
    ([www.skillsmatter.com/conferences/1948-scala-exchange-2014](http://www.skillsmatter.com/conferences/1948-scala-exchange-2014)),
    NEScala ([www.nescala.org](http://www.nescala.org)), Jfokus ([www.jfokus.se](http://www.jfokus.se)),
    Scala.io ([www.scala.io](http://www.scala.io)), flatMap ([www.flatmap.no](http://www.flatmap.no)),
    Ping ([www.ping-conf.com](http://www.ping-conf.com)), and Scalapeño ([www.scalapeno.underscore.co.il](http://www.scalapeno.underscore.co.il)),
    to only name a few. A whole calendar site of Scala events is available at [http://www.scala2014.org](http://www.scala2014.org).
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, I hope you enjoyed the book enough to continue exploring
    Scala, writing awesome code, and having fun as much as we did!
  prefs: []
  type: TYPE_NORMAL
