- en: Chapter 10. Scala Goodies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. Scala小技巧
- en: We have covered a number of technologies and toolkits in the previous chapters
    that, when combined together, offer a great opportunity to build modern and scalable-reactive
    web applications in Scala. Scala now celebrates 10 years of existence with an
    active community and large corporations supporting it, leading to a perpetual
    exploration of innovative ideas touching the language and the ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经介绍了一些技术和工具包，当它们结合在一起时，为在Scala中构建现代和可扩展的响应式Web应用提供了极大的机会。Scala现在庆祝了10年的存在，拥有活跃的社区和大型企业的支持，这导致了不断探索触及语言和生态系统的创新思想。
- en: 'We propose, in this last chapter, to touch upon a few areas where we have found
    some exciting ongoing projects or technologies and where we feel that Scala can
    provide elegant solutions to be both productive and fun. We will cover some of
    the following aspects:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一章中，我们提出探讨一些我们发现了一些令人兴奋的正在进行中的项目或技术领域，以及我们认为Scala可以提供优雅的解决方案，既高效又有趣。我们将涵盖以下方面：
- en: NoSQL database access through MongoDB
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过MongoDB进行NoSQL数据库访问
- en: Introducing DSLs and in particular, a glimpse at Parser Combinators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍领域特定语言（DSLs）以及特别是一瞥解析组合器
- en: Scala.js—compiling Scala to JavaScript on the client side
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala.js—在客户端将Scala编译成JavaScript
- en: Exploring MongoDB
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索MongoDB
- en: As the volume of information to process and store has drastically increased
    in the past few years, many IT shops have been looking for alternatives to traditional
    relational databases to store and query data. The **not only SQL** (**NoSQL**)
    database movement has gained popularity as a way to trade consistency and structure
    of the data for more efficient or flexible data storage. MongoDB ([www.mongodb.org](http://www.mongodb.org))
    is a database product designed to store documents in formats, such as JSON, and
    with no strict database schema. Along with the Java driver built to access and
    query a MongoDB database, we are going to discover how the Casbah Scala toolkit
    ([https://github.com/mongodb/casbah](https://github.com/mongodb/casbah)) can be
    used to conveniently access and query such a database through a DSL.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随着过去几年需要处理和存储的信息量急剧增加，许多IT企业一直在寻找替代传统关系型数据库来存储和查询数据的方法。**不仅SQL**（**NoSQL**）数据库运动作为一种以更高效或更灵活的数据存储为代价来交换数据一致性和结构的方式而受到欢迎。MongoDB（[www.mongodb.org](http://www.mongodb.org)）是一种数据库产品，旨在以JSON等格式存储文档，并且没有严格的数据库模式。除了构建用于访问和查询MongoDB数据库的Java驱动程序外，我们还将发现如何使用Casbah
    Scala工具包（[https://github.com/mongodb/casbah](https://github.com/mongodb/casbah)）通过DSL方便地访问和查询此类数据库。
- en: Entering Casbah
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进入Casbah
- en: 'The only requirement to start experimenting with Casbah is to add its `.jar`
    library dependency to an SBT or Play project. In a new directory on your disk,
    type `> play new ch10samples` from a terminal window and add the Casbah dependency
    to the `build.sbt` file in the root directory of the project. This dependency
    is added by adding the following code (note that the given version of Casbah was
    the latest available at the time of writing this chapter, but should soon be available
    as the final version 2.7.0):'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用Casbah进行实验，唯一的要求是将它的`.jar`库依赖项添加到SBT或Play项目中。在你的磁盘上的一个新目录中，从终端窗口输入`> play
    new ch10samples`，并将Casbah依赖项添加到项目根目录下的`build.sbt`文件中。此依赖项通过添加以下代码添加（注意，在编写此章节时，所提供的Casbah版本是当时可用的最新版本，但很快将可用为最终版本2.7.0）：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you are using an SBT project instead of Play, you may also add a default
    SLF4J logging implementation, as shown in the following code snippet, as otherwise
    the default used is a no-operation implementation:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用SBT项目而不是Play，你也可以添加默认的SLF4J日志实现，如下面的代码片段所示，否则默认使用的是无操作实现：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As usual, starting an REPL can be done either by entering the `> play` command
    followed by a `> console` command or just `> play console`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如同往常，启动REPL可以通过输入`> play`命令后跟`> console`命令或直接`> play console`来完成：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After some imports, we connect to the MongoDB database on port `27017` using
    the following code:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行一些导入之后，我们使用以下代码连接到端口`27017`上的MongoDB数据库：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These statements have, so far, been executed without a direct contact with
    the database. From now on, we need to make sure we have a running instance of
    the MongoDB process before we retrieve any content. Start the `mongod` daemon
    if it is not running yet (download instructions can be found at [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)),
    then enter the following command to fetch the names of the stored collections:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，这些语句都是在没有直接接触数据库的情况下执行的。从现在开始，在检索任何内容之前，我们需要确保有一个运行的MongoDB进程。如果尚未运行，请启动`mongod`守护进程（下载说明可在[https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)找到），然后输入以下命令以获取存储的集合名称：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We obviously get an empty set as a result, as we haven''t stored any document
    yet. Let''s create a couple of entries:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们显然得到了一个空集作为结果，因为我们还没有存储任何文档。让我们创建几个条目：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The created items have yet to be added to the database, using the `insert`
    command as shown in the following commands:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的项目尚未添加到数据库中，使用以下命令中的`insert`命令：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Retrieving the elements of the `coll` collection can be done using the `find`
    method:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`find`方法检索`coll`集合的元素：
- en: '[PRE7]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that a primary key for each document has been created as we did not
    provide any while inserting the document into the collection. You may as well
    retrieve a single document if you know exactly the object you are looking for
    and provide it as an argument. For this, the `findOne` method is available, passing
    a new `SearchedCountry MongoDBObject` as expressed in the following command lines:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们在将文档插入集合时没有提供任何主键，每个文档都创建了一个主键。如果你确切知道你要找的对象，并提供给它作为参数，你也可以检索单个文档。为此，可以使用`findOne`方法，如下面的命令行所示：
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As there might not always be a matching element, the `findOne` method returns
    `Option`, which in the previous case resulted in `Some(value)`, in contrast to
    the following empty result:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于可能并不总是存在匹配的元素，`findOne`方法返回`Option`，在前一个例子中结果是`Some(value)`，与以下空结果形成对比：
- en: '[PRE9]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Deleting elements is performed with the `remove` method, which can be used
    in a manner similar to the `findOne` method:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 删除元素是通过`remove`方法完成的，它可以像`findOne`方法一样使用：
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, updating a document can be done as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，更新文档可以按照以下方式完成：
- en: '[PRE11]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can see here that the primary key "530fd91d03645ab9c17d9012" is still the
    one we had when we initially inserted the `sales` document into the database,
    showing that the `update` operation was not a removal and then inserting a brand
    new element.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，主键"530fd91d03645ab9c17d9012"仍然是我们在最初将`sales`文档插入数据库时拥有的，这表明`update`操作不是删除然后插入一个全新的元素。
- en: Updating multiple documents at once is also supported and we refer to the documentation
    available at [http://mongodb.github.io/casbah/guide/index.html](http://mongodb.github.io/casbah/guide/index.html)
    for further operations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 同时更新多个文档也是支持的，我们参考[http://mongodb.github.io/casbah/guide/index.html](http://mongodb.github.io/casbah/guide/index.html)中的文档以获取更多操作信息。
- en: Applying MapReduce transformations
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用MapReduce转换
- en: 'Among the great features of document-oriented databases such as MongoDB, there
    is the possibility to run the MapReduce functions. **MapReduce** is an approach
    where you break up a query or task into smaller chunks of work, and then aggregate
    the results of those chunks. To illustrate how a document-based approach can sometimes
    be useful in contrast with a traditional relational database, let''s take a small
    example of financial consolidation. In such a domain, aggregating and calculating
    sales figures globally for a large corporation may involve working with a number
    of orthogonal dimensions. For instance, sales figures can be gathered from each
    subsidiary that each has its own geographic location, time intervals, own currency,
    and specific categories, following some tree-based structures in each dimension
    as depicted in the following figure:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在MongoDB等文档型数据库的众多优秀特性中，还有运行MapReduce函数的可能性。**MapReduce**是一种方法，其中将查询或任务分解成更小的作业块，然后汇总这些块的结果。为了说明基于文档的方法有时与传统的关系型数据库相比可能更有用，让我们以一个小型的财务合并为例。在这个领域，为一个大公司全球范围内汇总和计算销售额可能需要处理多个正交维度。例如，销售额可以从每个子公司收集，每个子公司都有自己的地理位置、时间间隔、货币和特定类别，每个维度都遵循一些如图所示的树状结构：
- en: '![Applying MapReduce transformations](img/3637OS_10_06.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![应用MapReduce转换](img/3637OS_10_06.jpg)'
- en: 'The geographic location might be a decisive factor when it comes to the currency
    used, and conversion should be done to sum figures consistently. To that extent,
    the currency used to produce global reports usually follows the root of the company
    ownership tree. A company tree structure is given in the following figure:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 地理位置可能是使用货币的决定性因素，并且应该进行转换以确保数值的一致性。在这方面，用于生成全球报告的货币通常遵循公司所有权树的根。以下是一个公司树结构的示例：
- en: '![Applying MapReduce transformations](img/3637OS_10_07.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![应用MapReduce转换](img/3637OS_10_07.jpg)'
- en: 'Similarly, various sales categories might define yet another hierarchy, as
    shown on the following figure:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，各种销售类别可能定义另一个层次结构，如下一个图所示：
- en: '![Applying MapReduce transformations](img/3637OS_10_08.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![应用MapReduce转换](img/3637OS_10_08.jpg)'
- en: Such reported sales figures may either be very detailed or already accumulated,
    therefore, reported at various levels of the hierarchies. As large corporations
    are usually made of smaller groups with various degrees of ownership that are
    furthermore changing regularly, the consolidation job requires to aggregate and
    compute data according to all these parameters.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 报告的销售数据可能非常详细或已经累积，因此在不同层次的结构中报告。由于大型公司通常由各种所有权的较小群体组成，这些群体的所有权程度也在不断变化，因此整合工作需要根据所有这些参数聚合和计算数据。
- en: 'As for a number of data warehousing solutions expressed in relational databases,
    the heart of the domain model can be a huge table containing facts referring to
    the various dimensions expressed in the previous figure. For instance, some sample
    input data for this example can consist in the following list of sales figures
    (that is, amounts) as XML rows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多以关系数据库表示的数据仓库解决方案，领域模型的核心可以是一个包含事实的大表，这些事实指的是前一个图中表示的各个维度。例如，本例的一些示例输入数据可以由以下销售数据（即金额）列表组成，作为XML行：
- en: '![Applying MapReduce transformations](img/3637OS_10_04.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![应用MapReduce转换](img/3637OS_10_04.jpg)'
- en: 'The following construct shows how to represent a tree structure in JSON:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下结构展示了如何在JSON中表示树结构：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following is an example of a JSON document that contains sales figures
    by geographic location:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个包含按地理位置划分的销售数据的JSON文档示例：
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By storing documents coming from various subsidiaries of a large corporation,
    such as JSON, we can consolidate the figures through MapReduce transformations
    already supported by the database. Moreover, Casbah takes advantage of the aggregation
    framework ([http://mongodb.github.io/casbah/guide/aggregation.html](http://mongodb.github.io/casbah/guide/aggregation.html))
    of MongoDB to be able to aggregate values without having to use MapReduce
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通过存储来自大型公司各个子公司的文档，例如JSON，我们可以通过数据库已经支持的MapReduce转换来整合数据。此外，Casbah利用MongoDB的聚合框架([http://mongodb.github.io/casbah/guide/aggregation.html](http://mongodb.github.io/casbah/guide/aggregation.html))，以便能够在不使用MapReduce的情况下聚合值。
- en: To conclude with MongoDB, we will just mention the ReactiveMongo project ([www.reactivemongo.org](http://www.reactivemongo.org))
    that figures a reactive asynchronous and non-blocking driver for MongoDB. As it
    uses the Iteratee pattern that we covered in [Chapter 9](ch09.html "Chapter 9. Building
    Reactive Web Applications"), *Building Reactive Web Applications*, combining it
    with a stream-friendly framework, such as Play, can result in a number of interesting
    and scalable demos, as listed on their website.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以MongoDB为例，我们只需提及ReactiveMongo项目([www.reactivemongo.org](http://www.reactivemongo.org))，该项目是一个MongoDB的响应式异步非阻塞驱动程序。由于它使用了我们在第9章中介绍的Iteratee模式，即《构建响应式Web应用》，结合一个流友好框架，如Play，可以产生许多有趣且可扩展的演示，如它们网站上所列。
- en: Scratching the surface of Big Data
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索大数据的表面
- en: Among the recent achievements and trends towards better analysis of data and
    services lies the Big Data movement. In particular, the Hadoop framework has established
    some kind of ad hoc standard "for the distributed processing of large datasets
    across clusters of computers using simple programming models". In addition to
    a distributed file system called HDFS optimized for high throughput to access
    data, Hadoop offers MapReduce facilities for processing large datasets in parallel.
    As setting up and running Hadoop is not always considered a simple task, some
    other frameworks have been developed on top of Hadoop as a means to simplify the
    definition of Hadoop jobs. In Java, the Cascading framework is a layer on top
    of Hadoop that provides a convenient API to facilitate creation of MapReduce jobs.
    In Scala, the Scalding framework has been developed to further enhance the cascading
    API by utilizing the concise and expressive Scala syntax, as we can observe by
    taking a look at the `activator-scalding` Typesafe activator template. The sample
    code provided with this template illustrates a word counting application, that
    is, the `hello-world` project of Hadoop MapReduce jobs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在最近的数据和服务分析成就和趋势中，大数据运动占据了一席之地。特别是，Hadoop框架建立了一种某种临时的标准“用于在计算机集群中使用简单的编程模型跨集群分布式处理大型数据集”。除了用于高吞吐量访问数据的优化分布式文件系统HDFS之外，Hadoop还提供了MapReduce功能，用于并行处理大型数据集。由于设置和运行Hadoop并不总是被认为是一项简单任务，因此已经开发了一些其他框架，作为在Hadoop之上简化Hadoop作业定义的手段。在Java中，Cascading框架是在Hadoop之上的一层，它提供了一个方便的API，以促进MapReduce作业的创建。在Scala中，Scalding框架已经开发出来，通过利用简洁和表达性强的Scala语法来进一步增强Cascading
    API，正如我们可以通过查看`activator-scalding` Typesafe activator模板所观察到的。该模板提供的示例代码演示了一个单词计数应用程序，即Hadoop
    MapReduce作业的“hello-world”项目。
- en: As a reminder on MapReduce jobs, consider reading the original paper from Google,
    available at [http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf](http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 作为MapReduce工作的提醒，可以考虑阅读Google的原始论文，可在[http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf](http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf)找到。
- en: 'We can express the job of counting words with the following two steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下两个步骤来表示计数单词的工作：
- en: Splitting lines from a file into individual words and creating a key-value pair
    for each word, where key is the word of the `String` type and value is the constant
    `1`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件中的行拆分为单个单词，并为每个单词创建一个键值对，其中键是`String`类型的单词，值是常数`1`
- en: By grouping the elements having the same key (grouping the same words) into
    a list and reducing the list by summing the values, we obtain our goal
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将具有相同键（即相同的单词）的元素分组到列表中，并通过求和值来减少列表，我们达到了我们的目标
- en: 'If you run the `> activator ui` command in a terminal window, as we already
    did a number of times in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala
    Ecosystem"), *Understanding the Scala Ecosystem*, and create the `activator-scalding`
    template project, you can verify how concise the word count in scalding is specified.
    Do not forget to run the `> activator eclipse` command to be able to import the
    project into the Eclipse IDE:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个终端窗口中运行`> activator ui`命令，就像我们在[第3章](ch03.html "第3章。理解Scala生态系统")中已经多次做的那样，创建`activator-scalding`模板项目，你可以验证scalding中单词计数指定的简洁性。不要忘记运行`>
    activator eclipse`命令以便将项目导入到Eclipse IDE中：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Most of the code is indeed comments, which means that the whole algorithm is
    very close to the description one would do in pseudo code.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分代码确实是注释，这意味着整个算法非常接近人们会用伪代码做的描述。
- en: If you are interested in Big Data, Scala definitely fits a niche and a number
    of projects and frameworks handling huge streams of data and Hadoop-like jobs
    are already pushing the limits. Among them, we can mention Spark ([http://spark.apache.org](http://spark.apache.org))
    as well as Twitter's open-source projects SummingBird ([https://github.com/twitter/summingbird](https://github.com/twitter/summingbird))
    and Algebird ([https://github.com/twitter/algebird](https://github.com/twitter/algebird)).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对大数据感兴趣，Scala无疑填补了一个空白，并且已经有一些项目和框架正在处理大量数据流和类似Hadoop的工作，正在推动极限。其中，我们可以提到Spark
    ([http://spark.apache.org](http://spark.apache.org)) 以及Twitter的开源项目SummingBird
    ([https://github.com/twitter/summingbird](https://github.com/twitter/summingbird))
    和Algebird ([https://github.com/twitter/algebird](https://github.com/twitter/algebird))。
- en: Introducing DSLs in Scala
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Scala中介绍DSLs
- en: '**Domain specific language** (**DSL**) is usually useful to simplify the interaction
    with a system by being applied to a small particular domain. They can be targeted
    to programmers by providing a simplified API to communicate with a system; or
    they may concern the so-called "business users" who may understand a domain well
    enough to create some scripts but are not programmers and could have difficulty
    dealing with a general-purpose programming language. There are, in general, two
    types of DSLs:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**领域特定语言**（DSL）通常通过应用于一个小而特定的领域来简化与系统的交互。它们可以通过提供简化的API与系统通信来针对程序员；或者它们可能涉及所谓的“业务用户”，这些用户可能对领域有足够的了解以创建一些脚本，但他们不是程序员，可能难以处理通用编程语言。一般来说，存在两种类型的领域特定语言：'
- en: Internal DSLs
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内部领域特定语言
- en: External DSLs
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部领域特定语言（DSL）
- en: Observing internal DSLs
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 观察内部领域特定语言（DSL）
- en: Internal DSLs use a host language (for instance, Scala) and the simplified usage
    is obtained by adding some syntactic sugar, through tricks and special constructs
    of the language. The book *DSLs in Action* by Debasish Ghosh illustrates the construction
    of Scala internal DSLs using features of the language such as infix notation and
    implicit conversions.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 内部领域特定语言使用宿主语言（例如，Scala），通过添加一些语法糖、技巧和语言的特殊结构来获得简化的使用方式。Debasish Ghosh所著的《DSLs
    in Action》一书通过使用语言的特征（如中缀表示法和隐式转换）说明了Scala内部领域特定语言的构建。
- en: 'He has given the following DSL usage example that represents an executable
    program expressed in clear English: `200 discount bonds IBM for_client NOMURA
    on NYSE at 72.ccy(USD)`. Many transformations happen under the hood, but the business
    user is given a very clean syntax.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 他给出了以下领域特定语言使用示例，表示用清晰英语表达的可执行程序：`200 discount bonds IBM for_client NOMURA on
    NYSE at 72.ccy(USD)`。幕后发生了许多转换，但业务用户得到了一个非常干净的语法。
- en: Such DSLs have the advantage that you are confident that you can express anything
    with them as the host language is of generic purpose (such as Scala). This means
    that sometimes you may be constrained to use a less clean syntax but you know
    you have the full power of the Scala compiler under your hands. Therefore, you
    will always succeed in producing a DSL script or program that implements the logic
    you want.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种领域特定语言的优势在于，由于宿主语言是通用目的的（例如Scala），你可以确信你可以用它们表达任何事物。这意味着有时你可能被迫使用不太干净的语法，但你清楚你手头有Scala编译器的全部功能。因此，你将始终成功产生一个实现你想要逻辑的领域特定语言脚本或程序。
- en: However, the full power of the compiler may also be something that you would
    like to avoid in many cases where you want to give your business user the possibility
    to only perform a few specific actions. For this purpose, you may implement external
    DSLs instead. There are a number of additional concerns including constrained
    syntax (for example, you can't avoid parentheses in some cases) and convoluted
    error messages.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，编译器的全部功能也可能是在许多情况下你想要避免的，在这些情况下，你希望给你的业务用户提供仅执行少数特定操作的可能性。为此，你可以实现外部领域特定语言。这包括许多额外的关注点，包括受限的语法（例如，在某些情况下你无法避免括号）和复杂的错误信息。
- en: Tackling external DSLs through parser combinators
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过解析组合器处理外部领域特定语言
- en: An external DSL represents a domain language where the syntax is completely
    up to you. This means you can express things exactly the way you want to and can
    constrain your business users to only use specific words or meanings. This flexibility
    comes with a price of much more work to implement it as you need to define a grammar
    (typically **Backus–Naur Form** (**BNF**)), that is, define all the rules that
    apply to parse a meaning or script successfully. In Java, the task to write an
    external DSL can be cumbersome and it usually involves the ANTLR external framework.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 外部领域特定语言代表了一种语法完全由你决定的领域语言。这意味着你可以按照自己的意愿精确地表达事物，并且可以限制你的业务用户只能使用特定的单词或含义。这种灵活性伴随着需要付出更多的工作来实现它，因为你需要定义一个语法（通常是**巴科斯-诺尔范式**（BNF）），即定义所有成功解析意义或脚本的规则。在Java中，编写外部领域特定语言的任务可能很繁琐，通常涉及到ANTLR外部框架。
- en: In Scala, parser combinators are a notion very close to the definition of BNF
    grammars and can provide very concise and elegant code when writing external DSLs.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在Scala中，解析组合器是一个与BNF语法定义非常接近的概念，并且在编写外部领域特定语言时可以提供非常简洁和优雅的代码。
- en: Once you get acquainted with a few particular operators to deal with the definition
    of the grammar, you will discover that writing an external DSL is fairly straightforward
    if your language is not too complex. A good source of information to learn all
    the symbols and operators involved in parser combinators is available at [http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/](http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你熟悉了处理语法定义的一些特定运算符，你就会发现，如果你的语言不是太复杂，编写外部领域特定语言（DSL）相当直接。关于涉及解析器组合器的所有符号和运算符的详细信息，可以在[http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/](http://bitwalker.github.io/blog/2013/08/10/learn-by-example-scala-parser-combinators/)找到。
- en: 'The following experimental code illustrates a small DSL in the domain of finance
    consolidation where specific money accounts are manipulated as part of predefined
    formulae. The main method given at the end of the following snippet reflects a
    formula; for instance, you may parse the formula (`3*#ACCOUNT1#`) to construct
    an object-oriented structure that will be able to compute the result of multiplying
    the content of a given account by three:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下实验性代码演示了在财务合并领域的一个小型领域特定语言（DSL），其中特定的货币账户作为预定义公式的部分被操作。以下代码片段末尾给出的主方法反映了一个公式；例如，你可能将公式（`3*#ACCOUNT1#`）解析为一个面向对象的结构，该结构能够计算给定账户内容乘以三的结果：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The objects that will result from the parsing of a formula are defined as **case
    classes**. Hence, continuing with the code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 从公式解析中产生的对象被定义为**案例类**。因此，继续编写代码：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we execute this parser combinator code into Eclipse by simply right-clicking
    on the `FormulaCalculator` class and navigating to **Run As** | **Scala Application**,
    we should obtain the following output in the Eclipse console:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们通过在`FormulaCalculator`类上右键单击并将鼠标移动到**运行方式** | **Scala应用程序**来执行这个解析器组合器代码，我们应该在Eclipse控制台中获得以下输出：
- en: '[PRE17]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This output shows that the three formulae were parsed correctly and converted
    into classes. The final evaluation is left out from this exercise but could be
    set up with some actual transactions defined on the two accounts.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出表明，三个公式已正确解析并转换为类。最终的评估在这个练习中被省略，但可以通过在两个账户上定义一些实际交易来设置。
- en: Introducing Scala.js
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Scala.js
- en: Where Java is a compelling choice to run server-side code due to its robust
    JVM that can be run anywhere, JavaScript is increasingly becoming the dominant
    choice on the client side due to its flexibility and light runtime-embedded environment
    as well as its growing set of tools already available in the browsers. Despite
    its popularity, JavaScript being a dynamic language does not offer the type of
    safety that languages such as Java or Scala provide. The experimental but fast-growing
    Scala.js initiative aims at compiling Scala to JavaScript and in my view offers
    a really good alternative for those who want to benefit from the power of the
    Scala type system all the way to the browser.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Java拥有强大的JVM，可以在任何地方运行服务器端代码，因此Java成为了一个引人注目的选择。而JavaScript由于其灵活性、轻量级的运行时嵌入环境以及浏览器中已经可用的工具集日益增长，正逐渐成为客户端的主导选择。尽管JavaScript非常流行，但作为一个动态语言，它并不提供像Java或Scala这样的语言所提供的类型安全。实验性的但快速增长的Scala.js项目旨在将Scala编译成JavaScript，在我看来，对于那些想要从Scala类型系统的强大功能中受益的人来说，这是一个非常好的替代方案。
- en: Setting up a project demonstrating the usage of Scala.js can be done in a couple
    of minutes and is explained in the sample "getting started" project available
    at [https://github.com/sjrd/scala-js-example-app](https://github.com/sjrd/scala-js-example-app).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个展示Scala.js使用的项目只需几分钟，并在可用的示例“入门”项目中进行了说明，该项目的网址为[https://github.com/sjrd/scala-js-example-app](https://github.com/sjrd/scala-js-example-app)。
- en: 'The example consists of a small HTML page containing a `playground <div>` element
    as illustrated in the following HTML code:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 示例包括一个包含一个`playground <div>`元素的简单HTML页面，如下面的HTML代码所示：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `div` element will be dynamically populated as:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`div`元素将被动态填充为：'
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The tiny snippet of code written in Scala and compiled to Javascript to achieve
    this is given in the following `main` method:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的Scala代码片段（编译成JavaScript）在下面的`main`方法中给出：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once we have the access to the DOM of the HTML page through the `js.Dynamic.global`
    object, this simple Scala `main` method constructs a new paragraph node and adds
    it to the existing `"playground"` node.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过`js.Dynamic.global`对象获得了HTML页面的DOM访问权限，这个简单的Scala `main`方法就构建了一个新的段落节点并将其添加到现有的`"playground"`节点中。
- en: The additional `square` method is used to illustrate a unit test written against
    the Jasmine JavaScript test framework.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 额外的 `square` 方法被用来展示针对 Jasmine JavaScript 测试框架编写的单元测试。
- en: 'The execution of the `main` method is triggered by the one line added to the
    `js/startup.js` file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`main` 方法的执行是由添加到 `js/startup.js` 文件中的一行触发的：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The generated code produced by default by Scala.js can be quite big because
    of dependencies to Scala libraries. Scala.js offers an optimization through Google's
    closure compiler that reduces the size and optimizes the JavaScript code execution
    when targeted for production environments.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Scala.js 默认生成的代码可能相当大，因为依赖于 Scala 库。Scala.js 通过 Google 的 closure compiler 提供了一种优化方法，可以减小大小并优化针对生产环境的目标
    JavaScript 代码执行。
- en: 'What is the next step now? Well, we can refer interested readers to a couple
    of more projects that we find interesting with regard to this book:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下一步是什么？嗯，我们可以将感兴趣的读者推荐给一些我们认为与这本书相关的更多有趣项目：
- en: A project called `play-with-scalajs-example` and available at [https://github.com/vmunier/play-with-scalajs-example](https://github.com/vmunier/play-with-scalajs-example)
    deals with a simple integration sample of Scala.js and the Play Framework that
    we have covered in the previous chapters.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为 `play-with-scalajs-example` 的项目，可在 [https://github.com/vmunier/play-with-scalajs-example](https://github.com/vmunier/play-with-scalajs-example)
    找到，它处理了 Scala.js 和 Play 框架的简单集成示例，我们在前面的章节中已经介绍过。
- en: 'A very interesting and more advanced usage of Scala.js is `TodoMVC` and this
    is a part of the `workbench-example-app` project available at [https://github.com/lihaoyi/workbench-example-app/](https://github.com/lihaoyi/workbench-example-app/).
    It demonstrates a sample web app for making To Do Lists, a reference app specified
    to compare different implementations done in various languages, but has the innovative
    approach of being reactive in addition to being written in Scala compiled to JavaScript.
    A direct link to the resulting reactive web app is available at [http://lihaoyi.github.io/workbench-example-app/todo.html](http://lihaoyi.github.io/workbench-example-app/todo.html)
    and is rendered in a browser, as shown in the following screenshot:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Scala.js 的一个非常有趣且更高级的使用是 `TodoMVC`，这是 `workbench-example-app` 项目的一部分，可在 [https://github.com/lihaoyi/workbench-example-app/](https://github.com/lihaoyi/workbench-example-app/)
    找到。它演示了一个用于创建待办事项列表的示例网络应用，这是一个指定用于比较在不同语言中完成的不同实现的参考应用，但它采用了创新的方法，即除了用 Scala
    编译成 JavaScript 外，还具有响应式特性。到结果响应式网络应用的直接链接可在 [http://lihaoyi.github.io/workbench-example-app/todo.html](http://lihaoyi.github.io/workbench-example-app/todo.html)
    找到，并在浏览器中渲染，如下面的截图所示：
- en: '![Introducing Scala.js](img/3637OS_10_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![介绍 Scala.js](img/3637OS_10_05.jpg)'
- en: There are already a number of projects around Scala.js listed on its home page
    at [http://www.scala-js.org/](http://www.scala-js.org/). As Scala.js is maturing
    quickly, many more projects should be soon available.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Scala.js 的主页 [http://www.scala-js.org/](http://www.scala-js.org/) 上已经列出了许多关于
    Scala.js 的项目。由于 Scala.js 正在迅速成熟，应该很快会有更多项目可用。
- en: Final tips
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最后的提示
- en: The following sections enlist a few final tips and tricks that you might find
    handy while working with the REPL.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节列出了几个你可能在使用 REPL 时觉得有用的最终提示和技巧。
- en: Copying and pasting in the REPL
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 REPL 中复制和粘贴
- en: 'As a reminder, this feature introduced in [Chapter 8](ch08.html "Chapter 8. Essential
    Properties of Modern Applications – Asynchrony and Concurrency"), *Essential Properties
    of Modern Applications – Asynchrony and Concurrency*, makes it easy to execute
    a full code snippet at once in the REPL. For instance, the following lines of
    command illustrate how the copy and paste feature in REPL helps the easy execution
    of code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这个特性是在 [第 8 章](ch08.html "第 8 章. 现代应用程序的基本属性 – 异步和并发") 中引入的，*现代应用程序的基本属性
    – 异步和并发*，它使得在 REPL 中一次性执行整个代码片段变得容易。例如，以下命令行说明了 REPL 中的复制粘贴功能如何帮助轻松执行代码：
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Timing code execution in the REPL
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 REPL 中计时代码执行
- en: The REPL has been a very helpful tool throughout this book to discover and experiment
    with the various features of Scala. Together with the Scala worksheets introduced
    in [Chapter 3](ch03.html "Chapter 3. Understanding the Scala Ecosystem"), *Understanding
    the Scala Ecosystem*, they enhance our productivity by providing continuous feedback
    and make our development, therefore, more agile. Sometimes, it is convenient to
    measure the time it takes to execute statements or code snippets in the REPL.
    This is why we have given one way of achieving this.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，REPL一直是一个非常有用的工具，用于发现和实验Scala的各种功能。与第3章中介绍的Scala工作表[理解Scala生态系统](ch03.html
    "第3章。理解Scala生态系统")一起，它们通过提供持续反馈来提高我们的生产力，从而使我们的开发更加敏捷。有时，测量REPL中执行语句或代码片段所需的时间是很方便的。这就是我们提供实现这一目标的一种方法的原因。
- en: 'First, we define a `help` function called `using` that takes two parameters,
    first a `param` argument of the type `A` and second, a function argument `f` that
    transforms the type of an argument from `A` into `B`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个名为`using`的`help`函数，它接受两个参数，第一个是类型为`A`的`param`参数，第二个是函数参数`f`，它将参数的类型从`A`转换为`B`：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What `using` does is to invoke the `f(param)` function, wrapping it into a
    `try {} finally{}` block. As the idea behind this function is to apply it on an
    I/O resource such as `FileWriter` or `PrintWriter`, we want to guarantee that
    we can close the resource no matter what. This is why you can see a `param.close`
    call in the `finally` block. That means the `param` argument cannot just be of
    any type `A`; it must have the additional requirement to have a `close` method.
    This is exactly what is declared at the beginning of the definition of the generic
    `using` method (that is, `[A <: {def close(): Unit}, B]`); the `param` argument
    should be a subtype of `A` that contains a method with the given signature.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`using`的作用是调用`f(param)`函数，将其包裹在`try {} finally{}`块中。由于这个函数背后的想法是在I/O资源（如`FileWriter`或`PrintWriter`）上应用它，我们想要保证无论发生什么情况都能关闭资源。这就是为什么你在`finally`块中看到`param.close`调用。这意味着`param`参数不能只是任何类型`A`；它必须具有额外的要求，即有一个`close`方法。这正是泛型`using`方法定义开始处所声明的（即`[A
    <: {def close(): Unit}, B]`）；`param`参数应该是`A`的子类型，它包含一个具有给定签名的函数。'
- en: In general, dealing with generic types is out of the scope of this book, and
    you don't need to really understand the previous definition to benefit from the
    `using` function. The example illustrates, however, how powerful the use of generic
    types in Scala can be. The type system of Scala is extremely powerful and the
    compiler will help you very much when writing generic code, unlike the use of
    generics in Java.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，处理泛型类型超出了本书的范围，你不需要真正理解前面的定义就能从`using`函数中受益。然而，这个例子说明了在Scala中使用泛型类型可以多么强大。Scala的类型系统非常强大，编译器在编写泛型代码时会给你很大的帮助，这与Java中泛型的使用不同。
- en: 'Let''s now include the `using` function into an `appendToFile` function that
    will be responsible for logging the evaluation of the code we write in the REPL:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将`using`函数包含到一个`appendToFile`函数中，该函数将负责记录我们在REPL中编写的代码的评估：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, the following `timeAndLogged` function is declared to wrap a body
    snippet entered in the REPL with both the logging and timing functionalities:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下`timeAndLogged`函数被声明为将REPL中输入的代码片段包裹在日志记录和计时功能中：
- en: '[PRE25]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Until Scala 2.10.0, you could use the `:wrap` method of the REPL power mode
    (accessible from the REPL via the `> :power` command) to be able to execute all
    the console statements without further involvement of the `timedAndLogged` function.
    The `:wrap` feature has recently been removed from the Scala release, so you will
    have to explicitly wrap the code that you want timing or logging for in the `timedAndLogged`
    method and therefore, do not need to involve the power mode of the REPL for that.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 直到Scala 2.10.0，你可以使用REPL强大模式的`:wrap`方法（通过REPL中的`> :power`命令访问）来执行所有控制台语句，而无需进一步涉及`timedAndLogged`函数。`:wrap`功能最近已被从Scala版本中移除，因此你将不得不显式地将你想要计时或记录的代码包裹在`timedAndLogged`方法中，因此，你不需要涉及REPL的强大模式。
- en: 'For instance, you can execute the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以执行以下命令：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `/tmp/repl.log` file we specified in the `timedAndLogged` function should,
    of course, contain the logged result, that is, `2014`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`timedAndLogged`函数中指定的`/tmp/repl.log`文件当然应该包含已记录的结果，即`2014`。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As we now reach the end of this book, we would like to emphasize some key aspects
    on the numerous topics and concepts we have approached during this journey with
    Scala.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经到达这本书的结尾，我们想强调在Scala之旅中我们接触到的许多主题和概念的关键方面。
- en: The concise and expressive syntax of the Scala language should make your code
    not only more readable but also more maintainable for yourself and other developers.
    You don't have to give up any of the libraries of the very large and mature Java
    ecosystem as all the APIs can be reused directly within Scala. Moreover, you benefit
    from many additional great Scala-specific libraries. Our recommendation is to
    take a piece of Java code from a domain you understand well, maybe because you
    wrote it in the first place one or several times before. Then, try to convert
    it to Scala code and refactor it to get rid of the boilerplate and to make it
    in a more functional style.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Scala语言的简洁和表达性语法应该使你的代码不仅更易于阅读，而且对你和其他开发者来说也更易于维护。你不必放弃Java生态系统中非常庞大和成熟的任何库，因为所有API都可以在Scala中直接重用。此外，你还可以从许多额外的优秀Scala特定库中受益。我们的建议是从你非常熟悉的领域取一段Java代码，也许是因为你最初就编写过它一两次。然后，尝试将其转换为Scala代码，并重构它以去除样板代码，使其更具函数式风格。
- en: The Play Framework is not just another web framework; it breaks the conventional
    approach of long-cycle development following servlet and EJB containers where
    each redeploy can take a significant time. Moreover, it is built on top of rock
    solid and scalable technologies such as Akka, which should make you feel confident
    for future heavy loads and constraining availability requirements. Finally, our
    personal experience with it has been very enjoyable as the Scala compiler behind
    it has, most of the time, given very clear feedback on what the problems are when
    mistakes are made, all the way to the templates and routes specifications. As
    both Play and Akka are exposing Java APIs as well, they can make your transition
    easier.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Play框架不仅仅是一个Web框架；它打破了遵循servlet和EJB容器的传统长周期开发方法，每次重新部署都可能花费大量时间。此外，它建立在坚固和可扩展的技术之上，如Akka，这应该让你对未来高负载和约束可用性要求感到自信。最后，我们使用它的个人经验非常愉快，因为背后的Scala编译器在出错时，大多数情况下都能给出非常清晰的反馈，从模板和路由规范到问题所在。由于Play和Akka都公开了Java
    API，它们可以使你的过渡更容易。
- en: We believe the future of web development is reactive, dealing with large streams
    of data, as it is already happening in many areas such as social media sites involving
    content distribution and real-time financial/analytics services.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相信，网络开发的未来是响应式的，处理大量数据流，正如它已经在许多领域发生，例如涉及内容分发和实时金融/分析服务的社交媒体网站。
- en: We have only scratched the surface of what is possible to do with Scala. As
    you go along and dive more deeply into individual technologies, you will discover
    new features and endless possibilities. Our recommendation is to take one step
    at a time looking for achievable goals. For instance, first get used to the Scala
    collections, especially as they can help you to better master Java lambdas and
    functional programming, then write code with pattern matching, traits, for comprehensions,
    then move to more advanced topics such as implicits, generics and so on.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是触及了Scala所能做到的一小部分。随着你深入探索个别技术，你会发现新的特性和无限的可能性。我们的建议是一步一步地寻找可实现的目标。例如，首先熟悉Scala集合，特别是它们可以帮助你更好地掌握Java的lambda表达式和函数式编程，然后使用模式匹配、特质、for推导式编写代码，然后转向更高级的主题，如隐式类型、泛型等。
- en: Finally, as inspiration, there is already a tremendous number of open source
    projects done with Scala, many books on the individual subjects we have covered,
    many forums contributed by a very active Scala community, as well as several years
    of extremely useful online videos coming from user groups and international conferences
    such as Scaladays ([www.scaladays.org](http://www.scaladays.org)), Scala eXchange
    ([www.skillsmatter.com/conferences/1948-scala-exchange-2014](http://www.skillsmatter.com/conferences/1948-scala-exchange-2014)),
    NEScala ([www.nescala.org](http://www.nescala.org)), Jfokus ([www.jfokus.se](http://www.jfokus.se)),
    Scala.io ([www.scala.io](http://www.scala.io)), flatMap ([www.flatmap.no](http://www.flatmap.no)),
    Ping ([www.ping-conf.com](http://www.ping-conf.com)), and Scalapeño ([www.scalapeno.underscore.co.il](http://www.scalapeno.underscore.co.il)),
    to only name a few. A whole calendar site of Scala events is available at [http://www.scala2014.org](http://www.scala2014.org).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，作为灵感，已经有大量的开源项目是用Scala完成的，关于我们涵盖的各个主题的许多书籍，许多由非常活跃的Scala社区贡献的论坛，以及来自用户组和国际会议（如Scaladays
    [www.scaladays.org](http://www.scaladays.org)）、Scala eXchange [www.skillsmatter.com/conferences/1948-scala-exchange-2014](http://www.skillsmatter.com/conferences/1948-scala-exchange-2014)、NEScala
    [www.nescala.org](http://www.nescala.org)、Jfokus [www.jfokus.se](http://www.jfokus.se)、Scala.io
    [www.scala.io](http://www.scala.io)、flatMap [www.flatmap.no](http://www.flatmap.no)、Ping
    [www.ping-conf.com](http://www.ping-conf.com) 和 Scalapeño [www.scalapeno.underscore.co.il](http://www.scalapeno.underscore.co.il)
    等会议的数年极有价值的在线视频，仅举几个例子。Scala活动的整个日历网站可在 [http://www.scala2014.org](http://www.scala2014.org)
    查找。
- en: With that in mind, I hope you enjoyed the book enough to continue exploring
    Scala, writing awesome code, and having fun as much as we did!
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我希望你们对这本书的喜爱足以继续探索Scala，编写出色的代码，并像我们一样享受乐趣！
