<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Working with Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Working with Data</h1></div></div></div><p>The MVC approach talks about the model, view, and controller. We have seen views and controllers in detail in the previous chapters and neglected models to quite an extent. Models are an important part of MVC; the changes made to a model are reflected in the views and controllers using them.</p><p>Web applications are incomplete without data transactions. This chapter is about designing models and handling DB transactions in Play.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Models</li><li class="listitem" style="list-style-type: disc">JDBC</li><li class="listitem" style="list-style-type: disc">Anorm</li><li class="listitem" style="list-style-type: disc">Slick</li><li class="listitem" style="list-style-type: disc">ReactiveMongo</li><li class="listitem" style="list-style-type: disc">A Cache API</li></ul></div><div class="section" title="Introducing models"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Introducing models</h1></div></div></div><p>A <span class="strong"><strong>model</strong></span> is a domain <a id="id172" class="indexterm"/>object, which maps to database entities. For example, a social networking application has users. The users can register, update their profile, add friends, post links, and so on. Here, the user is a domain object and each user will have corresponding entries in the database. Therefore, we could define a user model in the following way:</p><div class="informalexample"><pre class="programlisting">case class User(id: Long,
                loginId: String,
                name: Option[String],
                dob: Option[Long])
object User { def register (loginId: String,...) = {…}
...
}</pre></div><p>Earlier, we defined a model without using a database:</p><div class="informalexample"><pre class="programlisting">case class Task(id: Int, name: String)

object Task {

  private var taskList: List[Task] = List()

  def all: List[Task] = {
    taskList
  }

  def add(taskName: String) = {
    val lastId: Int = if (!taskList.isEmpty) taskList.last.id else 0
    taskList = taskList ++ List(Task(lastId + 1, taskName))
  }

  def delete(taskId: Int) = {
    taskList = taskList.filterNot(task =&gt; task.id == taskId)
  }
}  </pre></div><p>The task list example had <a id="id173" class="indexterm"/>a <code class="literal">Task</code> model but it was not bound to a database, keeping things simpler. At the end of this chapter, we will be able to back it up with a database.</p></div></div>
<div class="section" title="JDBC"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec35"/>JDBC</h1></div></div></div><p>Accessing the DB using <span class="strong"><strong>Java Database Connectivity</strong></span> (<span class="strong"><strong>JDBC</strong></span>) is common in applications using relational DBs. Play provides a plugin to <a id="id174" class="indexterm"/>manage the JDBC connection pool. The plugin internally uses <a id="id175" class="indexterm"/>BoneCP (<a class="ulink" href="http://jolbox.com/">http://jolbox.com/</a>), a fast <span class="strong"><strong>Java Database Connection pool</strong></span> (<span class="strong"><strong>JDBC pool</strong></span>) <a id="id176" class="indexterm"/>library.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>To use the plugin, a dependency in the build file should be added:</p><div class="informalexample"><pre class="programlisting">val appDependencies = Seq(jdbc)</pre></div><p>The plugin supports H2, SQLite, PostgreSQL, MySQL, and SQL. Play is bundled with an H2 database driver, but to use any of the other databases we should add a dependency on its corresponding driver:</p><div class="informalexample"><pre class="programlisting">val appDependencies = Seq( jdbc,
"mysql" % "mysql-connector-java" % "5.1.18",...)</pre></div></div></div><p>The plugin exposes the <a id="id177" class="indexterm"/>following methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">getConnection</code>: It accepts the name of the database it should get the connection for and whether any statement executed using this connection should commit automatically or not. If a name is not provided, it fetches the connection for database with the default name.</li><li class="listitem" style="list-style-type: disc"><code class="literal">withConnection</code>: It accepts a block of code that should be executed using a JDBC connection. Once the block is executed, the connection is released. Alternatively, it accepts the name of the database.</li><li class="listitem" style="list-style-type: disc"><code class="literal">withTransaction</code>: It accepts a block of code that should be executed using a JDBC transaction. Once the block is executed, the connection and all its created statements are released.</li></ul></div><p>How does the plugin know the details of the database? The details of the database can be set in <code class="literal">conf/application.</code>
<code class="literal">conf</code>:</p><div class="informalexample"><pre class="programlisting">db.default.driver=com.mysql.jdbc.Driver
db.default.url="jdbc:mysql://localhost:3306/app"
db.default.user="changeme"
db.default.password="changeme"</pre></div><p>The first part, <code class="literal">db</code>, is a set of properties, which are used by the DBPlugin. The second part is the name of the database, <code class="literal">default</code> in the example, and the last part is the name of the property.</p><p>For MySQL and PostgreSQL, we could include the user and password in the URL:</p><div class="informalexample"><pre class="programlisting">db.default.url="mysql://user:password@localhost:3306/app"
db.default.url="postgres://user:password@localhost:5432/app"</pre></div><p>For additional <a id="id178" class="indexterm"/>JDBC configurations, refer to <a class="ulink" href="https://www.playframework.com/documentation/2.3.x/SettingsJDBC">https://www.playframework.com/documentation/2.3.x/SettingsJDBC</a>.</p><p>Now that we've enabled and configured the the JDBC plugin, we can connect to a SQL-like database and execute queries:</p><div class="informalexample"><pre class="programlisting">def fetchDBUser = Action { 
    var result = "DB User:" 
    val conn = DB.getConnection() 
    <span class="strong"><strong>try{ </strong></span>
<span class="strong"><strong>      val rs = conn.createStatement().executeQuery("SELECT USER()") </strong></span>
<span class="strong"><strong>      while (rs.next()) { </strong></span>
<span class="strong"><strong>        result += rs.getString(1) </strong></span>
<span class="strong"><strong>      } </strong></span>
<span class="strong"><strong>    } finally { </strong></span>
<span class="strong"><strong>      conn.close() </strong></span>
<span class="strong"><strong>    } </strong></span>
    Ok(result) 
  }</pre></div><p>Alternatively, we can <a id="id179" class="indexterm"/>use the <code class="literal">DB.withConnection</code> helper, which manages the DB connection:</p><div class="informalexample"><pre class="programlisting">def fetchDBUser = Action { 
    var result = "DB User:" 
    <span class="strong"><strong>DB.withConnection { conn =&gt; </strong></span>
<span class="strong"><strong>      val rs = conn.createStatement().executeQuery("SELECT USER()") </strong></span>
<span class="strong"><strong>      while (rs.next()) { </strong></span>
<span class="strong"><strong>        result += rs.getString(1) </strong></span>
<span class="strong"><strong>      } </strong></span>
<span class="strong"><strong>    } </strong></span>
    Ok(result) 
  }</pre></div></div>
<div class="section" title="Anorm"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Anorm</h1></div></div></div><p>
<span class="strong"><strong>Anorm</strong></span> is a <a id="id180" class="indexterm"/>module in Play that supports interactions with the database using a plain SQL.</p><p>Anorm exposes methods to query the SQL database and parse the result as Scala objects, built in as well as custom.</p><p>The objective behind <a id="id181" class="indexterm"/>Anorm as stated on the Play website (<a class="ulink" href="https://www.playframework.com/documentation/2.3.x/ScalaAnorm">https://www.playframework.com/documentation/2.3.x/ScalaAnorm</a>) is:</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Using JDBC is a pain, but we provide a better API</strong></span>
</p><p><span class="emphasis"><em>We agree that using the JDBC API directly is tedious, particularly in Java. You have to deal with checked exceptions everywhere and iterate over and over around the ResultSet to transform this raw dataset into your own data structure.</em></span></p><p><span class="emphasis"><em>We provide a simpler API for JDBC; using Scala you don't need to bother with exceptions, and transforming data is really easy with a functional language. In fact, the goal of the Play Scala SQL access layer is to provide several APIs to effectively transform JDBC data into other Scala structures.</em></span></p><p>
<span class="strong"><strong>You don't need another DSL to access relational databases</strong></span>
</p><p><span class="emphasis"><em>SQL is already the best DSL for accessing relational databases. We don't need to invent something new. Moreover the SQL syntax and features can differ from one database vendor to another.</em></span></p><p><span class="emphasis"><em>If you try to abstract this point with another proprietary SQL like DSL you will have to deal with several dialects dedicated for each vendor (like Hibernate ones), and limit yourself by not using a particular database's interesting features.</em></span></p><p><span class="emphasis"><em>Play will sometimes provide you with pre-filled SQL statements, but the idea is not to hide the fact that we use SQL under the hood. Play just saves typing a bunch of characters for trivial queries, and you can always fall back to plain old SQL.</em></span></p><p>
<span class="strong"><strong>A typesafe DSL to generate SQL is a mistake</strong></span>
</p><p><span class="emphasis"><em>Some argue that a type safe DSL is better since all your queries are checked by the compiler. Unfortunately the compiler checks your queries based on a meta-model definition that you often write yourself by mapping your data structure to the database schema.</em></span></p><p><span class="emphasis"><em>There are no guarantees that this meta-model is correct. Even if the compiler says that your code and your queries are correctly typed, it can still miserably fail at runtime because of a mismatch in your actual database definition.</em></span></p><p>
<span class="strong"><strong>Take control of your SQL code</strong></span>
</p><p><span class="emphasis"><em>Object Relational Mapping works well for trivial cases, but when you have to deal with complex schemas or existing databases, you will spend most of your time fighting with your ORM to make it generate the SQL queries you want.</em></span></p><p><span class="emphasis"><em>Writing SQL queries yourself can be tedious for a simple 'Hello World' application, but for any real-life application, you will eventually save time and simplify your code by taking full control of your SQL code.</em></span></p></blockquote></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>When developing <a id="id182" class="indexterm"/>an application using Anorm, its dependency should be specified explicitly, since it is a separate module in Play (starting from Play 2.1):</p><div class="informalexample"><pre class="programlisting">val appDependencies = Seq(
      jdbc,
      anorm
)</pre></div></div></div><p>Let's picture our user model in MySQL. The table can be defined as follows:</p><div class="informalexample"><pre class="programlisting">CREATE TABLE `user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `login_id` varchar(45) NOT NULL,
  `password` varchar(50) NOT NULL,
  `name` varchar(45) DEFAULT NULL,
  `dob` bigint(20) DEFAULT NULL,
  `is_active` tinyint(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`),
  UNIQUE KEY `login_id_UNIQUE` (`login_id`),
  UNIQUE KEY `id_UNIQUE` (`id`)
) ENGINE=InnoDB</pre></div><p>Now let's look at the different <a id="id183" class="indexterm"/>queries we will make in this table. The queries will be as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Insert</code>: This query includes adding a new user</li><li class="listitem" style="list-style-type: disc"><code class="literal">Update</code>: This query includes updating the profile, password, and so on</li><li class="listitem" style="list-style-type: disc"><code class="literal">Select</code>: This query includes fetching one or more user's details, based on particular criteria</li></ul></div><p>Assume that when a user requests to delete his account from our application, we do not delete the user from the database, but instead mark the user's status as inactive. Therefore, we will not use any delete queries.</p><p>Using Anorm, we could have the <code class="literal">userId</code> autogenerated as follows:</p><div class="informalexample"><pre class="programlisting">DB.withConnection {
  implicit connection =&gt;
  val userId  = <span class="strong"><strong>SQL"""INSERT INTO user(login_id,password,name,</strong></span>
<span class="strong"><strong>  dob) VALUES($loginId,$password,$name,$dob)""".executeInsert()</strong></span>
userId
}</pre></div><p>Here, <code class="literal">loginId</code>, <code class="literal">password</code>, <code class="literal">name</code>, and <code class="literal">dob</code> are variables that are replaced in the query at runtime. Anorm builds only <code class="literal">java.sql.PreparedStatements</code>, which prevents SQL injection.</p><p>The SQL method returns an object of the <code class="literal">SimpleSql</code> type and is defined as follows:</p><div class="informalexample"><pre class="programlisting">implicit class SqlStringInterpolation(val sc: StringContext) extends AnyVal {
  def SQL(args: ParameterValue*) = prepare(args)

  private def prepare(params: Seq[ParameterValue]) = {
    // Generates the string query with "%s" for each parameter placeholder
    val sql = sc.parts.mkString("%s")

    val (ns, ps): (List[String], Map[String, ParameterValue]) =
        namedParams(params)

      SimpleSql(SqlQuery(sql, ns), ps,
        defaultParser = RowParser(row =&gt; Success(row)))
    }
  }</pre></div><p>
<code class="literal">SimpleSql</code> is used to represent a query in an intermediate format. Its constructor is as follows:</p><div class="informalexample"><pre class="programlisting">case class SimpleSql[T](sql: SqlQuery, params: Map[String, ParameterValue], defaultParser: RowParser[T]) extends Sql { … }</pre></div><p>The <code class="literal">executeInsert</code> method fetches <code class="literal">PreparedStatement</code> from the <code class="literal">SimpleSql</code> object using its <code class="literal">getFilledStatement</code> method. Then the <code class="literal">getGeneratedKeys()</code> method of <code class="literal">PreparedStatement</code> is executed.</p><p>The <code class="literal">getGeneratedKeys</code> method results in an autogenerated key, created as a result of executing the statement <a id="id184" class="indexterm"/>in which it is called. If no key is created, it returns an empty object.</p><p>Now let's use Anorm to update a user's password:</p><div class="informalexample"><pre class="programlisting">DB.withConnection {
    implicit connection =&gt;
SQL"""UPDATE user SET password=$password WHERE id = $userId""".executeUpdate()
}</pre></div><p>The <code class="literal">executeUpdate</code> method works similar to <code class="literal">executeInsert</code>. The difference is that it calls the <code class="literal">executeUpdate</code> method of the <code class="literal">PreparedStatement</code>, instead of <code class="literal">getGeneratedKeys</code>.</p><p>The <code class="literal">executeUpdate</code> <a id="id185" class="indexterm"/>method returns a count of affected rows for the <span class="strong"><strong>Data Manipulation Language</strong></span> (<span class="strong"><strong>DML</strong></span>) statements. If the SQL statement is <a id="id186" class="indexterm"/>of the other types, such as <span class="strong"><strong>Data Definition Language</strong></span> (<span class="strong"><strong>DDL</strong></span>), it returns <code class="literal">0</code>.</p><p>Now let's try to <a id="id187" class="indexterm"/>fetch the details of all registered users. If we want the resulting rows to be parsed as user objects, we should define a parser. The parser for a user will be as follows:</p><div class="informalexample"><pre class="programlisting">def userRow:RowParser[User] = {
    get[Long]("id") ~
      get[String]("login_id") ~
      get[Option[String]]("name") map {
      case id ~ login_id ~ name  =&gt;  User(id, login_id, name)
    }
  }</pre></div><p>In most queries, we will not need the password and date of birth, so we can exclude them from the user <code class="literal">RowParser</code> default.</p><p>A query using this parser can be shown in this way:</p><div class="informalexample"><pre class="programlisting">DB.withConnection {
  implicit connection =&gt;
  val query = "SELECT id,login_id,name FROM user"
  SQL(query).as(userRow.*)
}</pre></div><p>The <code class="literal">.*</code> symbol indicates that the result should have one or more rows similar to its common interpretation in regular expressions. Similarly, the <code class="literal">.+</code> symbol can be used when we expect the result to consist of zero or more rows.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip03"/>Tip</h3><p>If you're using an older version of Scala where string interpolations are not supported, the queries would be written in this way:</p><div class="informalexample"><pre class="programlisting">DB.withConnection {
  implicit connection =&gt;
val insertQuery  = """INSERT INTO user(login_id,password,name,
  |dob) VALUES({loginId},{password},{name},{dob})""".stripMargin
val userId = SQL(insertQuery).on(
  'loginId -&gt; loginId,
  'password -&gt; password,
  'name -&gt; name,
  'dob -&gt; dob).executeInsert()
userId
}</pre></div><p>The <code class="literal">on</code> method updates the query with the parameter map passed to it. It is defined for <code class="literal">SimpleSql</code> in the following way:</p><div class="informalexample"><pre class="programlisting"> def on(args: NamedParameter*): SimpleSql[T] =
    copy(params = this.params ++ args.map(_.tupled))</pre></div></div></div><p>Please refer to the Play <a id="id188" class="indexterm"/>documentation (<a class="ulink" href="http://www.playframework.com/documentation/2.3.x/ScalaAnorm">http://www.playframework.com/documentation/2.3.x/ScalaAnorm</a>) and the Anorm API <a id="id189" class="indexterm"/>documentation (<a class="ulink" href="http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package">http://www.playframework.com/documentation/2.3.x/api/scala/index.html#anorm.package</a>) for more use casess and details.</p></div>
<div class="section" title="Slick"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Slick</h1></div></div></div><p>According to <a id="id190" class="indexterm"/>Slick's website (<a class="ulink" href="http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick">http://slick.typesafe.com/doc/2.1.0/introduction.html#what-is-slick</a>):</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Slick is Typesafe's modern database query and access library for Scala. It allows you to work with stored data almost as if you were using Scala collections while at the same time giving you full control over when a database access happens and which data is transferred. You can also use SQL directly.</em></span></p><p><span class="emphasis"><em>When using Scala instead of raw SQL for your queries you benefit from compile-time safety and compositionality. Slick can generate queries for different backend databases including your own, using its extensible query compiler.</em></span></p></blockquote></div><p>We can use Slick in our <a id="id191" class="indexterm"/>Play application through the play-slick plugin. The plugin provides some additional features for the use of Slick in a Play application. According to <a class="ulink" href="https://github.com/playframework/">https://github.com/playframework/</a>, play-slick consists of three features:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A wrapper DB object that uses the datasources defined in the Play config files, and pulls them from a connection pool. It is there so it is possible to use Slick sessions in the same fashion as you would Anorm JDBC connections. There are some smart caching and load balancing that make your connections to your DB perform better.</li><li class="listitem" style="list-style-type: disc">A DDL plugin that reads Slick tables and automatically creates schema updates on reload. This is useful in particular for demos and to get started.</li><li class="listitem" style="list-style-type: disc">A wrapper to use play Enumeratees together with Slick </li></ul></div><p>To use it, we need to add the following library dependency in the build file:</p><div class="informalexample"><pre class="programlisting">"com.typesafe.play" %% "play-slick" % "0.8.1"
Let's see how we can define user operations using Slick.</pre></div><p>First, we need to define the schema in Scala. This can be done by mapping the required tables to case classes. For our user table, the schema can be defined as:</p><div class="informalexample"><pre class="programlisting">case class SlickUser(id: Long, loginId: String, name: String) 

class SlickUserTable(tag: Tag) extends Table[SlickUser](tag, "user") { 
  def id = column[Long]("id", O.PrimaryKey, O.AutoInc) 

  def loginId = column[String]("login_id") 

  def name = column[String]("name") 

  def dob = column[Long]("dob") 

  def password = column[String]("password") 

  def * = (id, loginId, name) &lt;&gt;(SlickUser.tupled, SlickUser.unapply) 
}</pre></div><p>
<code class="literal">Table</code> is a Slick trait and <a id="id192" class="indexterm"/>its columns are specified through the <code class="literal">column</code> method. The following types are supported for a column:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Numeric types</strong></span>: These include <code class="literal">Byte</code>, <code class="literal">Short</code>, <code class="literal">Int</code>, <code class="literal">Long</code>, <code class="literal">BigDecimal</code>, <code class="literal">Float</code>, and <code class="literal">Double</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Date types</strong></span>: These include <code class="literal">java.sql.Date</code>, <code class="literal">java.sql.Time</code>, and <code class="literal">java.sql.Timestamp</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>UUID type:</strong></span><code class="literal"> This includes java.util.UUID</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>LOB types</strong></span>: These include <code class="literal">java.sql.Blob</code>, <code class="literal">java.sql.Clob</code>, and <code class="literal">Array[Byte]</code></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Other types</strong></span>: These include <code class="literal">Boolean</code>, <code class="literal">String</code>, and <code class="literal">Unit</code></li></ul></div><p>The <code class="literal">column</code> method accepts column constraints, such as <code class="literal">PrimaryKey</code>, <code class="literal">Default</code>, <code class="literal">AutoInc</code>, <code class="literal">NotNull</code>, and <code class="literal">Nullable</code>.</p><p>The <code class="literal">*</code> method is mandatory for every table and is similar to <code class="literal">RowParser</code>.</p><p>Now we can define a <code class="literal">TableQuery</code> Slick using this and use it to query a database. There are simple methods available for performing equivalent DB operations. We can define the methods in the Anorm object using the play-slick wrapper along with the Slick API:</p><div class="informalexample"><pre class="programlisting">object SlickUserHelper { 
  val users = TableQuery[SlickUserTable] 

  def add(loginId: String, 
          password: String, 
          name: String = "anonymous", 
          dateOfBirth: DateTime): Long = { 

    play.api.db.slick.DB.withSession { implicit session =&gt; 
      users.map(p =&gt; (p.loginId, p.name, p.dob, p.password)) 
        .returning(users.map(_.id)) 
        .insert((loginId, name, dateOfBirth.getMillis, password)) 
    } 
  } 

  def updatePassword(userId: Long, 
                   password: String) = { 

    play.api.db.slick.DB.withSession { implicit session =&gt; 
      users.filter(_.id === userId) 
        .map(u =&gt; u.password) 
        .update(password) 
    } 
  } 
 
  def getAll: Seq[SlickUser] = { 
    play.api.db.slick.DB.withSession { implicit session =&gt; 
      users.run 
    } 
  } 
}</pre></div><p>The <code class="literal">run</code> method is <a id="id193" class="indexterm"/>equivalent to calling <code class="literal">SELECT *</code>.</p><p>For more details on this, refer to the Slick (<a class="ulink" href="http://slick.typesafe.com/doc/2.1.0/">http://slick.typesafe.com/doc/2.1.0/</a>) and the play-slick documentation (<a class="ulink" href="https://github.com/playframework/play-slick">https://github.com/playframework/play-slick</a>).</p></div>
<div class="section" title="ReactiveMongo"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>ReactiveMongo</h1></div></div></div><p>A lot of applications these <a id="id194" class="indexterm"/>days use a NoSQL database as a result of unstructured data, write scalability, and so on. MongoDB is one such database. According to its website (<a class="ulink" href="http://docs.mongodb.org/manual/core/introduction/">http://docs.mongodb.org/manual/core/introduction/</a>):</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>MongoDB is an open source document database that provides high performance, high availability, and automatic scaling.</em></span></p><p>Key features of MongoDB are:</p><p>High performance</p><p>High availability (automatic failover, data redundancy)</p><p>Automatic scaling (horizontal scalability)</p></blockquote></div><a id="id195" class="indexterm"/><p>ReactiveMongo is a Scala <a id="id196" class="indexterm"/>driver for MongoDB that supports non-blocking and asynchronous I/O operations. There is a plugin for the Play Framework called Play-ReactiveMongo. It is not a Play plugin but it's supported and maintained by the team of ReactiveMongo.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>This section requires prior knowledge of MongoDB, so please refer to <a class="ulink" href="https://www.mongodb.org/">https://www.mongodb.org/</a>.</p></div></div><p>To use it, we need to do the following:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Include it as a dependency in the build file:<div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq(
  <span class="strong"><strong>"org.reactivemongo" %% "play2-reactivemongo" % "0.10.5.0.akka23"</strong></span>
)</pre></div></li><li class="listitem">Include the plugin in <code class="literal">conf/play.plugins</code>:<div class="informalexample"><pre class="programlisting">1100:play.modules.reactivemongo.ReactiveMongoPlugin</pre></div></li><li class="listitem">Add the MongoDB <a id="id197" class="indexterm"/>server details in <code class="literal">conf/application.conf</code>:<div class="informalexample"><pre class="programlisting">mongodb.servers = ["localhost:27017"]
mongodb.db = "your_db_name"
mongodb.credentials.username = "user"
mongodb.credentials.password = "pwd"</pre></div><p>Alternatively, use the following:</p><div class="informalexample"><pre class="programlisting">mongodb.uri = "mongodb://user:password@localhost:27017/your_db_name"</pre></div></li></ol></div><p>Let's see usage of the plugin with a sample application. We may come across an instance in our application where we allow users to monitor activities on their devices in the form of heat sensors, smoke detectors, and so on.</p><p>Before using the device with our application installed on it, the device should be registered with this application. Each device has <code class="literal">ownerId</code>, <code class="literal">deviceId</code>, its configuration, and product information. So, let's assume that, on registration, we get a JSON in this format:</p><div class="informalexample"><pre class="programlisting">{
"deviceId" : "aghd",
"ownerId" : "someUser@someMail.com"
"config" : { "sensitivity" : 4, …},
"info" : {"brand" : "superBrand","os" : "xyz","version" : "2.4", …}
}</pre></div><p>Once a device is registered, the owner can update the configuration or agree to update the product's software. Updating software is handled by the device company, and we only need to update the details in our application.</p><p>The queries to the database will be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Insert</code>: This query includes registering a device</li><li class="listitem" style="list-style-type: disc"><code class="literal">Update</code>: This query includes updating device configuration or information</li><li class="listitem" style="list-style-type: disc"><code class="literal">Delete</code>: This query occurs when a device is unregistered</li><li class="listitem" style="list-style-type: disc"><code class="literal">Select</code>: This query occurs when an owner wishes to view the details of the device<p>Using Reactive Mongo, the device registration will be:</p><div class="informalexample"><pre class="programlisting">def registerDevice(deviceId: String, 
                    ownerId: String, 
              deviceDetails: JsObject): Future[LastError] = { 
 
    var newDevice = Json.obj("deviceId" -&gt; deviceId, "ownerId" -&gt; ownerId.trim) 
    val config = (deviceDetails \ "configuration").asOpt[JsObject] 
    val metadata = (deviceDetails \ "metadata").asOpt[JsObject] 
    if (!config.isDefined) 
      newDevice = newDevice ++ Json.obj("configuration" -&gt; Json.parse("{}")) 
    if (!metadata.isDefined) 
      newDevice = newDevice ++ Json.obj("metadata" -&gt; Json.parse("{}")) 

    collection.insert[JsValue](newDevice) 
  }</pre></div></li></ul></div><p>In this snippet, we've built a <a id="id198" class="indexterm"/>JSON object from the available device details and inserted it in <code class="literal">devices</code>. Here, the collection is defined as follows:</p><div class="informalexample"><pre class="programlisting">def db = ReactiveMongoPlugin.db

def collection = db.collection("devices")</pre></div><p>The insert command accepts the data and its type:</p><div class="informalexample"><pre class="programlisting">The db operations for fetching a device or removing it are simple,def fetchDevice(deviceId: String): Future[Option[JsObject]] = { 
    val findDevice = Json.obj("deviceId" -&gt; deviceId) 
    collection.find(findDevice).one[JsObject] 
  } 

  def removeDeviceById(deviceId: String): Future[LastError] = { 
    val removeDoc = Json.obj("deviceId" -&gt; deviceId) 
    collection.remove[JsValue](removeDoc) 
  }</pre></div><p>This leaves us with just the update query. An update is triggered for a single property of configuration or information, that is, the request has just one field and its new value is this:</p><div class="informalexample"><pre class="programlisting">{ "sensitivity": 4.5}</pre></div><p>Now, a query to update this would be:</p><div class="informalexample"><pre class="programlisting">    def updateConfiguration(deviceId: String, 
                     ownerId: String, 
                updatedField: JsObject) = { 
    val property = updatedField.keys.head 
    val propertyValue = updatedField.values.head 
    val toUpdate = Json.obj(s"configuration.$property" -&gt; propertyValue) 
    val setData = Json.obj("$set" -&gt; toUpdate) 
    val documentToUpdate = Json.obj("deviceId" -&gt; deviceId, "ownerId" -&gt; ownerId) 
    collection.update[JsValue, JsValue](documentToUpdate, setData) 
  }</pre></div><p>When we wish to update a field <a id="id199" class="indexterm"/>for a given document in MongoDB, we should add the updated data to the <code class="literal">$set</code> field in the query. For example, an equivalent MongoDB query would be as follows:</p><div class="informalexample"><pre class="programlisting">db.devices.update(
   { deviceId: "aghd" ,"ownerId" : "someUser@someMail.com"},
   { $set: { "configuration.sensitivity": 4.5 } }
)</pre></div></div>
<div class="section" title="The Cache API"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>The Cache API</h1></div></div></div><p>Caching in a web <a id="id200" class="indexterm"/>application is the process of storing dynamically generated items, whether these are data objects, pages, or parts of a page, in memory at the initial time they are requested. This can later be reused if subsequent requests for the same data are made, thereby reducing response time and enhancing user experience. One can cache or store these items on the web server or other software in the request stream, such as the proxy server or browser.</p><p>Play has a minimal cache API, which uses EHCache. As stated on its website (<a class="ulink" href="http://ehcache.org/">http://ehcache.org/</a>):</p><div class="blockquote"><blockquote class="blockquote"><p>
<span class="strong"><strong>Ehcache</strong></span> <span class="emphasis"><em>is an open source, standards-based cache for boosting performance, offloading your database, and simplifying scalability. It's the most widely-used Java-based cache because it's robust, proven, and full-featured. Ehcache scales from in-process, with one or more nodes, all the way to mixed in-process/out-of-process configurations with terabyte-sized caches.</em></span></p></blockquote></div><a id="id201" class="indexterm"/><p>It provides caching for presentation layers as well as application-specific objects. It is easy to use, maintain, and extend.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>To use the default cache API within a Play application, we should declare it as a dependency as follows:</p><div class="informalexample"><pre class="programlisting">libraryDependencies ++= Seq(cache)</pre></div></div></div><p>Using the default cache API is similar to using a mutable <code class="literal">Map[String, Any]</code>:</p><div class="informalexample"><pre class="programlisting">Cache.set("userSession", session)

val maybeSession: Option[UserSession] = Cache.getAs[UserSession]("userSession")

Cache.remove("userSession")</pre></div><p>This API is made available <a id="id202" class="indexterm"/>through <code class="literal">EHCachePlugin</code>. The plugin is responsible for creating an instance of EHCache CacheManager with an available configuration on starting the application, and shutting it down when the application is stopped. We will discuss Play plugins in detail in <a class="link" href="ch13.html" title="Chapter 13. Writing Play Plugins">Chapter 13</a>, <span class="emphasis"><em>Writing Play Plugins</em></span>. Basically, <code class="literal">EHCachePlugin</code> handles all the boilerplate required to use EHCache in an application and <code class="literal">EhCacheImpl</code> provides the methods to do so, such as <code class="literal">get</code>, <code class="literal">set</code>, and <code class="literal">remove</code>. It is defined as follows:</p><div class="informalexample"><pre class="programlisting">class EhCacheImpl(private val cache: Ehcache) extends CacheAPI {

  def set(key: String, value: Any, expiration: Int) {
    val element = new Element(key, value)
    if (expiration == 0) element.setEternal(true)
    element.setTimeToLive(expiration)
    cache.put(element)
  }

  def get(key: String): Option[Any] = {
    Option(cache.get(key)).map(_.getObjectValue)
  }

  def remove(key: String) {
    cache.remove(key)
  }
}</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>By default, the plugin looks for <code class="literal">ehcache.xml</code> in the <code class="literal">conf</code> directory and, if the file does not exist, the default configuration provided by the <code class="literal">ehcache-default.xml</code> framework is loaded.</p><p>It is also possible to specify the location of the <code class="literal">ehcache</code> configuration when starting the application using the <code class="literal">ehcache.configResource</code> argument.</p></div></div><p>The Cache API also simplifies <a id="id203" class="indexterm"/>handling a cache for results from requests on both the client and server side of the application. Adding <code class="literal">EXPIRES</code> and <code class="literal">etag</code> headers can be used to manipulate the client-side cache, while on the server side the results are cached so that its corresponding action is not computed for each call.</p><p>For example, we can cache the result of the request used to fetch details of inactive users:</p><div class="informalexample"><pre class="programlisting">def getInactiveUsers = Cached("inactiveUsers") {
  Action {
    val users = User.getAllInactive
    Ok(Json.toJson(users))
  }
}</pre></div><p>However, what if we want this to get updated every hour? We just need to specify the duration explicitly:</p><div class="informalexample"><pre class="programlisting">def getInactiveUsers = Cached("inactiveUsers").default(3600) {
  Action {
    val users = User.getAllInactive
    Ok(Json.toJson(users))
  }
}</pre></div><p>All of this is handled by the <code class="literal">Cached</code> case class and its companion object. The case class is defined as follows:</p><div class="informalexample"><pre class="programlisting">case class Cached(key: RequestHeader =&gt; String, caching: PartialFunction[ResponseHeader, Duration]) { … }</pre></div><p>The companion object provides commonly required methods to generate cached instances, such as cache action based on its status, and so on.</p><p>The <code class="literal">apply</code> method in cached calls the <code class="literal">build</code> method, which is defined as follows:</p><div class="informalexample"><pre class="programlisting">def build(action: EssentialAction)(implicit app: Application) = EssentialAction { request =&gt;
    val resultKey = key(request)
    val etagKey = s"$resultKey-etag"

    // Has the client a version of the resource as fresh as the last one we served?
    val notModified = for {
      requestEtag &lt;- request.headers.get(IF_NONE_MATCH)
      etag &lt;- Cache.getAs[String](etagKey)
      if requestEtag == "*" || etag == requestEtag
    } yield Done[Array[Byte], Result](NotModified)

    notModified.orElse {
      // Otherwise try to serve the resource from the cache, if it has not yet expired
      Cache.getAs[Result](resultKey).map(Done[Array[Byte], Result](_))
    }.getOrElse {
      // The resource was not in the cache, we have to run the underlying action
      val iterateeResult = action(request)

      // Add cache information to the response, so clients can cache its content
      iterateeResult.map(handleResult(_, etagKey, resultKey, app))
    }
  }</pre></div><p>It simply checks if the result was modified or not. If it hasn't been, it tries to get the result from the <code class="literal">Cache</code>. If the result does not <a id="id204" class="indexterm"/>exist in the cache, it fetches it from the action and adds it to the <code class="literal">Cache</code> using the <code class="literal">handleResult</code> method. The <code class="literal">handleResult</code> method is defined as follows:</p><div class="informalexample"><pre class="programlisting">private def handleResult(result: Result, etagKey: String, resultKey: String, app: Application): Result = {
  cachingWithEternity.andThen { duration =&gt;
    // Format expiration date according to http standard
    val expirationDate = http.dateFormat.print(System.currentTimeMillis() + duration.toMillis)
      // Generate a fresh ETAG for it
      val etag = expirationDate // Use the expiration date as ETAG

      val resultWithHeaders = result.withHeaders(ETAG -&gt; etag, EXPIRES -&gt; expirationDate)

      // Cache the new ETAG of the resource
      Cache.set(etagKey, etag, duration)(app)
      // Cache the new Result of the resource
      Cache.set(resultKey, resultWithHeaders, duration)(app)

      resultWithHeaders
    }.applyOrElse(result.header, (_: ResponseHeader) =&gt; result)
  }</pre></div><p>If a duration is specified, it returns that else it returns the default duration of one year.</p><p>The <code class="literal">handleResult</code> method <a id="id205" class="indexterm"/>simply takes the result, adds <code class="literal">etag</code>, expires headers, and then adds the result with the given key to <code class="literal">Cache</code>.</p></div>
<div class="section" title="Troubleshooting"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Troubleshooting</h1></div></div></div><p>The following <a id="id206" class="indexterm"/>section covers some common scenarios:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Anorm throws an error at the <code class="literal">SqlMappingError</code> runtime (too many rows when you're expecting a single one), even though the query resulted in expected behavior. It is an insert query using "on duplicate key update".<p>This can happen when such a query is being executed using <code class="literal">executeInsert</code>. The <code class="literal">executeInsert</code> method should be used when we need to return an autogenerated key. If we are updating some fields through a duplicate key, it means that we do not actually need the key. We could use <code class="literal">executeUpdate</code> to add a check if one row has been updated. For example, we may want to update the wishlist table, which tracks what a user has wished for:</p><div class="informalexample"><pre class="programlisting">DB.withConnection {
        implicit connection =&gt; {

  val updatedRows = SQL"""INSERT INTO wish_list (user_id, product_id, liked_at) VALUES ($userId,$productId,$likedAt)
    ON DUPLICATE KEY UPDATE liked_at=$likedAt, is_deleted=false """.executeUpdate()

  updatedRows == 1
  }
}</pre></div></li><li class="listitem" style="list-style-type: disc">Can we use multiple databases for a single application?<p>Yes, it is possible to use a different database of the same as well as a different kind. If an application requires this, we can use two or more different relational or NoSQL databases or a combination of both. For example, the application may store its user data in SQL (as we already know the format of the user data) and the information about THE user's devices in MongoDB (since the devices are from different vendors, the format of their data can change).</p></li><li class="listitem" style="list-style-type: disc">Anorm does not throw a compilation error when a query has an incorrect syntax. Is there a configuration to enable this?<p>It has been developed with the aim of using SQL queries in the code without any hassle. The developers are expected to pass correct queries to Anorm <a id="id207" class="indexterm"/>methods. To ensure that such errors do not occur at runtime, developers can execute the query locally and use it in the code if it succeeds. Alternatively, there are some third-party plugins that provide a typesafe DSL and can be used instead of Anorm if they meet the requirement, such as play-slick or <a id="id208" class="indexterm"/>scalikejdbc-play-support (<a class="ulink" href="https://github.com/scalikejdbc/scalikejdbc-play-support">https://github.com/scalikejdbc/scalikejdbc-play-support</a>)</p></li><li class="listitem" style="list-style-type: disc">Is it possible to use another caching mechanism?<p>Yes, it is possible to extend support for any other cache, such as OSCache, SwarmCache, MemCached, and so on, or a custom one by writing a plugin similar to EHCachePlugin. Some of the popular caching mechanisms already have Play plugins developed by individuals and/or other organizations. For example, play2-memcached (<a class="ulink" href="https://github.com/mumoshu/play2-memcached">https://github.com/mumoshu/play2-memcached</a>) and Redis plugin (<a class="ulink" href="https://github.com/typesafehub/play-plugins/tree/master/redis">https://github.com/typesafehub/play-plugins/tree/master/redis</a>).</p></li></ul></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we saw different ways of persisting application data in an application built using the Play Framework. In doing so, we have seen two contrasting approaches: one using a relational DB and the other using a NoSQL DB. To persist in a relational DB, we looked at how the Anorm module and the JDBC plugin work. To use a NoSQL database (MongoDB) for our application's backend, we used the Play plugin for ReactiveMongo. In addition to this, we saw how the Play Cache API can be used and how it works.</p><p>In the next chapter, we will be learning all about handling data streams in Play.</p></div></body></html>