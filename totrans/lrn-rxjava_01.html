<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Thinking Reactively</h1>
                </header>
            
            <article>
                
<p>It is assumed you are fairly comfortable with Java and know how to use classes, interfaces, methods, properties, variables, static/nonstatic scopes, and collections. If you have not done concurrency or multithreading, that is okay. RxJava makes these advanced topics much more accessible.</p>
<p>Have your favorite Java development environment ready, whether it is Intellij IDEA, Eclipse, NetBeans, or any other environment of your choosing. I will be using Intellij IDEA, although it should not matter or impact the examples in this book. I recommend that you have a build automation system as well such as Gradle or Maven, which we will walk through shortly.</p>
<p>Before we dive deep into RxJava, we will cover some core topics first:</p>
<ul>
<li>A brief history of Reactive Extensions and RxJava</li>
<li>Thinking reactively</li>
<li>Leveraging RxJava</li>
<li>Setting up your first RxJava project</li>
<li>Building your first reactive applications</li>
<li>Differences between RxJava 1.0 and RxJava 2.0</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A brief history of ReactiveX and RxJava</h1>
                </header>
            
            <article>
                
<p>As developers, we tend to train ourselves to think in counter-intuitive ways. Modeling our world with code has never been short of challenges. It was not long ago that object-oriented programming was seen as the silver bullet to solve this problem. Making blueprints of what we interact with in real life was a revolutionary idea, and this core concept of classes and objects still impacts how we code today. However, business and user demands continued to grow in complexity. As 2010 approached, it became clear that object-oriented programming only solved part of the problem.<br/>
<br/>
Classes and objects do a great job of representing an entity with properties and methods, but they become messy when they need to interact with each other in increasingly complex (and often unplanned) ways. Decoupling patterns and paradigms emerged, but this yielded an unwanted side effect of growing amounts of boilerplate code. In response to these problems, functional programming began to make a comeback, not to replace object-oriented programming, but rather to complement it and fill this void. Reactive programming, a functional event-driven programming approach, began to receive special attention.<br/>
A couple of reactive frameworks emerged ultimately, including <strong>Akka</strong> and <strong>Sodium</strong>. But at Microsoft, a computer scientist named Erik Meijer created a reactive programming framework for .NET called <strong>Reactive Extensions</strong>. In a matter of years, Reactive Extensions (also called <strong>ReactiveX</strong> or <strong>Rx</strong><em>)</em> was ported to several languages and platforms, including JavaScript, Python, C++, Swift, and Java, of course. ReactiveX quickly emerged as a cross-language standard to bring reactive programming into the industry.<br/>
<br/>
RxJava, the ReactiveX port for Java, was created in large part by Ben Christensen from Netflix and David Karnok. RxJava 1.0 was released in November 2014, followed by RxJava 2.0 in November 2016. RxJava is the backbone to other ReactiveX JVM ports, such as <strong>RxScala</strong>, <strong>RxKotlin</strong>, and <strong>RxGroovy</strong>. It has become a core technology for Android development and has also found its way into Java backend development. Many RxJava adapter libraries, such as <strong>RxAndroid</strong> (<a href="https://github.com/ReactiveX/RxAndroid" target="_blank">https://github.com/ReactiveX/RxAndroid</a>), <strong>RxJava-JDBC</strong> (<a href="https://github.com/davidmoten/rxjava-jdbc" target="_blank">https://github.com/davidmoten/rxjava-jdbc</a>), <strong>RxNetty</strong> (<a href="https://github.com/ReactiveX/RxNetty" target="_blank">https://github.com/ReactiveX/RxNetty</a>), and  <strong>RxJavaFX</strong> (<a href="https://github.com/ReactiveX/RxJavaFX" target="_blank">https://github.com/ReactiveX/RxJavaFX</a>) adapted several Java frameworks to become reactive and work with RxJava out of the box.<br/>
This all shows that RxJava is more than a library. It is part of a greater ReactiveX ecosystem that represents an entire approach to programming. The fundamental idea of ReactiveX is that <em>events are data and data are events</em>. This is a powerful concept that we will explore later in this chapter, but first, let's step back and look at the world through the reactive lens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Thinking reactively</h1>
                </header>
            
            <article>
                
<p>Suspend everything you know about Java (and programming in general) for a moment, and let's make some observations about our world. These may sound like obvious statements, but as developers, we can easily overlook them. Bring your attention to the fact that everything is in motion. Traffic, weather, people, conversations, financial transactions, and so on are all moving. Technically, even something stationary as a rock is in motion due to the earth's rotation and orbit. When you consider the possibility that everything can be modeled as in motion, you may find it a bit overwhelming as a developer.<br/>
 <br/>
Another observation to note is that these different events are happening concurrently. Multiple activities are happening at the same time. Sometimes, they act independently, but other times, they can converge at some point to interact. For instance, a car can drive with no impact on a person jogging. They are two separate streams of events. However, they may converge at some point and the car will stop when it encounters the jogger.<br/>
 <br/>
If this is how our world works, why do we not model our code this way?. Why do we not model code as multiple concurrent streams of events or data happening at the same time? It is not uncommon for developers to spend more time managing the states of objects and doing it in an imperative and sequential manner. You may structure your code to execute <strong>Process 1</strong>, <strong>Process 2</strong>, and then <strong>Process 3</strong>, which depends on Process 1 and Process 2. Why not kick-off Process 1 and Process 2 simultaneously, and then the completion of these two events immediately kicks-off Process 3? Of course, you can use callbacks and Java concurrency tools, but RxJava makes this much easier and safer to express.<br/>
 <br/>
Let's make one last observation. A book or music CD is static. A book is an unchanging sequence of words and a CD is a collection of tracks. There is nothing dynamic about them. However, when we read a book, we are reading each word one at a time. Those words are effectively put in motion as a stream being consumed by our eyes. It is no different with a music CD track, where each track is put in motion as sound waves and your ears are consuming each track. Static items can, in fact, be put in motion too. This is an abstract but powerful idea because we made each of these static items a series of events. When we level the playing field between data and events by treating them both the same, we unleash the power of functional programming and unlock abilities you previously might have thought impractical. The fundamental idea behind reactive programming is that <em>events are data and data are events</em>. This may seem abstract, but it really does not take long to grasp when you consider our real-world examples. The runner and car both have properties and states, but they are also in motion. The book and CD are put in motion when they are consumed. Merging the event and data to become one allows the code to feel organic and representative of the world we are modeling.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why should I learn RxJava?</h1>
                </header>
            
            <article>
                
<p> ReactiveX and RxJava paints a broad stroke against many problems programmers face daily, allowing you to express business logic and spend less time engineering code. Have you ever struggled with concurrency, event handling, obsolete data states, and exception recovery? What about making your code more maintainable, reusable, and evolvable so it can keep up with your business? It might be presumptuous to call reactive programming a <strong>silver bullet</strong> to these problems, but it certainly is a progressive leap in addressing them.<br/>
<br/>
There is also growing user demand to make applications real time and responsive. Reactive programming allows you to quickly analyse and work with live data sources such as Twitter feeds or stock prices. It can also cancel and redirect work, scale with concurrency, and cope with rapidly emitting data. Composing events and data as streams that can be mixed, merged, filtered, split, and transformed opens up radically effective ways to compose and evolve code.<br/>
<br/>
In summary, reactive programming makes many hard tasks easy, enabling you to add value in ways you might have thought impractical earlier. If you have a process written reactively and you discover that you need to run part of it on a different thread, you can implement this change in a matter of seconds. If you find network connectivity issues crashing your application intermittently, you can gracefully use reactive recovery strategies that wait and try again. If you need to inject an operation in the middle of your process, it is as simple as inserting a new operator. Reactive programming is broken up into modular chain links that can be added or removed, which can help overcome all the aforementioned problems quickly. In essence, RxJava allows applications to be tactical and evolvable while maintaining stability in production.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What we will learn in this book?</h1>
                </header>
            
            <article>
                
<p> As stated earlier, RxJava is the ReactiveX port for Java. In this book, we will focus primarily on RxJava 2.0, but I will call out significant differences in RxJava 1.0. We will place priority on learning to think reactively and leverage the practical features of RxJava. Starting with a high-level understanding, we will gradually move deeper into how RxJava works. Along the way, we will learn about reactive patterns and tricks to solve common problems programmers encounter.<br/>
 <br/>
 In <a href="7fea3844-94e9-442e-9d54-239d146a8250.xhtml" target="_blank">Chapter 2</a>, <em>The Observable and Subscribers,</em> <a href="de58a40c-f55f-442f-b12e-7c022e08644e.xhtml" target="_blank">Chapter 3</a><em>, Basic Operators,</em> and <a href="d19b22f4-bb94-4f52-99ab-d03b962d4d16.xhtml" target="_blank">Chapter 4</a>, <em>Combining Observables,</em> we will cover core Rx concepts with <kbd>Observable</kbd>, <kbd>Observer</kbd>, and <kbd>Operator</kbd>. These are the three core entities that make up RxJava applications. You will start writing reactive programs immediately and have a solid knowledge foundation to build on for the rest of the book.<br/>
 <br/>
<a href="4d0b16d7-cc3c-4c9c-8666-7f80c96bd779.xhtml" target="_blank">Chapter 5</a>, <em>Multicasting, Replaying, and Caching</em>, and <a href="4f59db87-4b1d-47e6-95e3-ae0a43193c5f.xhtml" target="_blank">Chapter 6</a>, <em>Concurrency and Parallelization</em>, will explore more of the nuances of RxJava and how to effectively leverage concurrency.</p>
<p>In <a href="964f5943-b955-49f7-b53e-801754d06c3c.xhtml">Chapter 7</a>, <em>Switching, Throttling, Windowing, and Buffering</em> and <a href="14efb9e9-14a6-41ba-86cb-20b5674dce8e.xhtml">Chapter 8</a>, <em>Flowables and Backpressure,</em> we will learn about the different ways to cope with reactive streams that produce data/events faster than they can be consumed.</p>
<p>Finally, <a href="3108e794-df20-4efd-8a71-b4da8e3ae036.xhtml">Chapter 9</a>, <em>Transformers and Custom Operators</em>, <a href="ec80132f-c411-4cc1-87b2-7a8ebba089b8.xhtml">Chapter 10</a>, <em>Testing and Debugging</em>, <a href="4d8d0f1a-6015-4c42-82db-cb7f966e9f7c.xhtml">Chapter 11</a>, <em>RxJava on Android</em>, and <a href="42947483-7be8-4693-a7e4-2527ad9f180b.xhtml">Chapter 12</a>, <em>Using RxJava with Kotlin New,</em> will touch on several miscellaneous (but essential) topics including custom operators as well as how to use RxJava with testing frameworks, Android, and the Kotlin language.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Setting up</h1>
                </header>
            
            <article>
                
<p>There are two co-existing versions of RxJava currently: 1.0 and 2.0. We will go through some of the major differences later and discuss which version you should use.</p>
<p>RxJava 2.0 is a fairly lightweight library and comes just above 2 <strong>Megabytes</strong> (<strong>MBs</strong>) in size. This makes it practical for Android and other projects that require a low dependency overhead. RxJava 2.0 has only one dependency, called <strong>Reactive Streams</strong> ( <a href="http://www.reactive-streams.org/" target="_blank">http://www.reactive-streams.org/</a>), which is a core library (made by the creators of RxJava) that sets a standard for asynchronous stream implementations, one of which is RxJava 2.0.</p>
<p>It may be used in other libraries beyond RxJava and is a critical effort in the standardization of reactive programming on the Java platform. Note that RxJava 1.0 does not have any dependencies, including Reactive Streams, which was realized after 1.0.</p>
<p> If you are starting a project from scratch, try to use RxJava 2.0. This is the version we will cover in this book, but I will call out significant differences in 1.0. While RxJava 1.0 will be supported for a good while due to countless projects using it, innovation will likely only continue onward in RxJava 2.0. RxJava 1.0 will only get maintenance and bug fixes.</p>
<p>Both RxJava 1.0 and 2.0 run on Java 1.6+. In this book, we will use Java 8, and it is recommended that you use a minimum of Java 8 so you can use lambdas out of the box. For Android, there are ways to leverage lambdas in earlier Java versions that will be addressed later. But weighing the fact that Android Nougat uses Java 8 and Java 8 has been out since 2014, hopefully, you will not have to do any workarounds to leverage lambdas.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Navigating the Central Repository</h1>
                </header>
            
            <article>
                
<p>To bring in RxJava as a dependency, you have a few options. The best place to start is to go to <span class="packt_screen">The Central Repository</span> (search <a href="http://search.maven.org/" target="_blank">http://search.maven.org/</a>) and search for <kbd>rxjav</kbd>. You should see RxJava 2.0 and RxJava 1.0 as separate repositories at the top of the search results, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="276" width="560" class="image-border" src="assets/4c4839c1-0f03-433d-820e-ad6e10f1188e.jpeg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Searching for RxJava in the Central Repository (RxJava 2.0 and 1.0 are highlighted)</div>
<p>At the time of writing, RxJava 2.0.2 is the latest version for RxJava 2.0 and RxJava 1.2.3 is the latest for RxJava 1.0. You can download the latest JAR file for either by clicking the JAR links in the far right under the <span class="packt_screen">Download</span> column. You can then configure your project to use the JAR file.</p>
<p>However, you might want to consider using Gradle or Maven to automatically import these libraries into your project. This way, you can easily share and store your code project (through GIT or other version control systems) without having to download and configure RxJava manually into it each time. To view the latest configurations for Maven, Gradle, and several other build automation systems, click on the version number for either of the repositories, as highlighted in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><em><img class="image-border" src="assets/f79c7693-cd05-4ebc-82c7-b3c75f9c0ebd.jpeg"/></em></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Click the version number under the <em>Latest Version</em> column to view the configurations for Maven, Gradle, and other major build automation systems</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Gradle</h1>
                </header>
            
            <article>
                
<p>There are several automated build systems available, but the two most mainstream options are Gradle and Maven. Gradle is somewhat a successor to Maven and is especially the go-to build automation solution for Android development. If you are not familiar with Gradle and would like to learn how to use it, check out the Gradle <span class="packt_screen">Getting Started</span> guide <a href="https://gradle.org/getting-started-gradle-java/"/>(<a href="https://gradle.org/getting-started-gradle-java/" target="_blank">https://gradle.org/getting-started-gradle-java/</a>).</p>
<p>There are also several decent books that cover Gradle in varying degrees of depth, which you can find at <a href="https://gradle.org/books/">https://gradle.org/books/</a>. The following screenshot displays the <span class="packt_screen">The Central Repository</span> page showing how to set up RxJava 2.0.2 for Gradle:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/79a6c5b2-4cdc-445e-a053-44f5e6a71999.jpeg"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">You can find the latest Gradle configuration code and copy it into your Gradle script</div>
<p>In your <kbd>build.gradle</kbd> script, ensure that you have declared <kbd>mavenCentral()</kbd> as one of your repositories. Type in or paste that dependency line <kbd>compile 'io.reactivex.rxjava2:rxjava:x.y.z'</kbd>, where <kbd>x.y.z</kbd> is the version number you want to use, as shown in the following code snippet:</p>
<pre style="padding-left: 60px"><span>apply </span><span>plugin</span>: <span>'java'<br/></span><span><br/></span><span>sourceCompatibility </span><span>= </span><span>1.8</span><span><br/></span><span><br/></span><span>repositories </span><span>{<br/></span><span>      </span><span>mavenCentral</span><span>()<br/></span><span>}<br/></span><span><br/></span><span>dependencies </span><span>{<br/></span><span>      </span><span>compile </span><span>'io.reactivex.rxjava2:rxjava:x.y.z'<br/></span><span>}<br/></span></pre>
<p>Build your Gradle project and you should be good to go! You will then have RxJava and its types available for use in your project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Maven</h1>
                </header>
            
            <article>
                
<p>You also have the option to use Maven, and you can view the appropriate configuration in <span class="packt_screen">The Central Repository</span> by selecting the <span class="packt_screen">Apache Maven </span>configuration information, as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/32185d73-dc73-4380-b6e2-e4f0b2cadd0f.jpeg"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Select and then copy the <em>Apache Maven</em> configuration</div>
<p>You can then copy and paste the <kbd>&lt;dependency&gt;</kbd> block containing the RxJava configuration and paste it inside a  <kbd>&lt;dependencies&gt;</kbd>block in your <kbd>pom.xml</kbd> file. Rebuild your project, and you should now have RxJava set up as a dependency. The <kbd>x.y.z</kbd> version number corresponds to the desired RxJava version that you want to use:</p>
<pre style="padding-left: 60px"><span>&lt;</span><span>project</span><span>&gt;<br/></span><span>  &lt;</span><span>modelVersion</span><span>&gt;</span>4.0.0<span>&lt;/</span><span>modelVersion</span><span>&gt;<br/></span><span>    &lt;</span><span>groupId</span><span>&gt;</span>org.nield<span>&lt;/</span><span>groupId</span><span>&gt;<br/></span><span>    &lt;</span><span>artifactId</span><span>&gt;</span>mavenrxtest<span>&lt;/</span><span>artifactId</span><span>&gt;<br/></span><span>    &lt;</span><span>version</span><span>&gt;</span>1.0<span>&lt;/</span><span>version</span><span>&gt;<br/></span><span>  &lt;</span><span>dependencies</span><span>&gt;<br/></span><span>    &lt;</span><span>dependency</span><span>&gt;<br/></span><span>     &lt;</span><span>groupId</span><span>&gt;</span>io.reactivex.rxjava2<span>&lt;/</span><span>groupId</span><span>&gt;<br/></span><span>     &lt;</span><span>artifactId</span><span>&gt;</span>rxjava<span>&lt;/</span><span>artifactId</span><span>&gt;<br/></span><span>     &lt;</span><span>version</span><span>&gt;</span>x.y.z<span>&lt;/</span><span>version</span><span>&gt;<br/></span><span>    &lt;/</span><span>dependency</span><span>&gt;<br/></span><span>  &lt;/</span><span>dependencies</span><span>&gt;<br/></span><span>&lt;/</span><span>project</span><span>&gt;<br/></span></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A quick exposure to RxJava</h1>
                </header>
            
            <article>
                
<p> Before we dive deep into the reactive world of RxJava, here is a quick exposure to get your feet wet first. In ReactiveX, the core type you will work with is the <kbd>Observable</kbd>. We will be learning more about the <kbd>Observable</kbd> throughout the rest of this book. But essentially, an <kbd>Observable</kbd> pushes things. A given <strong><kbd>Observable&lt;T&gt;</kbd></strong>pushes things of type <kbd>T</kbd> through a series of operators until it arrives at an <kbd>Observer</kbd> that consumes the items.<br/>
<br/>
For instance, create a new <kbd>Launcher.java</kbd> file in your project and put in the following code:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>myStrings </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>"Epsilon"</span><span>);<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>In our <kbd>main()</kbd> method,  we have an <kbd>Observable&lt;String&gt;</kbd> that will push five string objects. An <kbd>Observable</kbd> can push data or events from virtually any source, whether it is a database query or live Twitter feeds. In this case, we are quickly creating an <kbd>Observable</kbd> using <kbd>Observable.just()</kbd>, which will emit a fixed set of items.</p>
<div class="packt_infobox">In RxJava 2.0, most types you will use are contained in the <kbd>io.reactivex</kbd> package. In RxJava 1.0, the types are contained in the <kbd>rx</kbd> package.</div>
<p>However, running this <kbd>main()</kbd> method is not going to do anything other than declare <kbd>Observable&lt;String&gt;</kbd>. To make this <kbd>Observable</kbd> actually push these five strings (which are called emissions), we need an <kbd>Observer</kbd> to subscribe to it and receive the items. We can quickly create and connect an <kbd>Observer</kbd> by passing a lambda expression that specifies what to do with each string it receives:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>)  {<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>String</span><span>&gt; </span><span>myStrings </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>just</span><span>(</span><span>"Alpha"</span><span>, </span><span>"Beta"</span><span>, </span><span>"Gamma"</span><span>, </span><span>"Delta"</span><span>, <br/></span><span>"Epsilon"</span><span>);<br/></span><span><br/></span><span>        </span><span>myStrings</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s</span><span>));<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p> When we run this code, we should get the following output:</p>
<pre style="padding-left: 30px">    Alpha <br/>    Beta <br/>    Gamma <br/>    Delta <br/>    Epsilon</pre>
<p>What happened here is that our <kbd>Observable&lt;String&gt;</kbd> pushed each string object one at a time to our <kbd>Observer</kbd>, which we shorthanded using the lambda expression <kbd>s -&gt; System.out.println(s)</kbd>. We pass each string through the parameter <kbd>s</kbd> (which I arbitrarily named) and instructed it to print each one. Lambdas are essentially mini functions that allow us to quickly pass instructions on what action to take with each incoming item. Everything to the left of the arrow <kbd>-&gt;</kbd> are arguments (which in this case is a string we named <kbd>s</kbd>), and everything to the right is the action (which is <kbd>System.out.println(s)</kbd>).<br/>
 <br/>
If you are unfamiliar with lambda expressions, turn to <em>Appendix,</em> to learn more about how they work. If you want to invest extra time in understanding lambda expressions, I highly recommend that you read at least the first few chapters of <em>Java 8 Lambdas</em> (O'Reilly) (<a href="http://shop.oreilly.com/product/0636920030713.do" target="_blank">http://shop.oreilly.com/product/0636920030713.do</a>) by Richard Warburton. Lambda expressions are a critical topic in modern programming and have become especially relevant to Java developers since their adoption in Java 8. We will be using lambdas constantly in this book, so definitely take some time getting comfortable with them.</p>
<p> We can also use several operators between <kbd>Observable</kbd> and <kbd>Observer</kbd> to transform each pushed item or manipulate them in some way. Each operator returns a new <kbd>Observable</kbd> derived-off the previous one but reflects that transformation. For example, we can use <kbd>map()</kbd> to turn each string emission into its <kbd>length()</kbd>, and each length integer will then be pushed to <kbd>Observer</kbd> , as shown in the following code snippet:</p>
<pre style="padding-left: 60px">import io.reactivex.Observable;<br/><br/>public class Launcher {<br/> public static void main(String[] args) {<br/>  <br/>   Observable&lt;String&gt; myStrings =<br/>     Observable.just("Alpha", "Beta", "Gamma", "Delta",<br/>      "Epsilon");<br/>  <br/>     myStrings.map(s -&gt; s.length()).subscribe(s -&gt; <br/>     System.out.println(s));<br/>  }<br/>}</pre>
<p>When we run this code, we should get the following output:</p>
<pre style="padding-left: 30px">    5<br/>    4<br/>    5<br/>    5<br/>    7</pre>
<p>If you have used Java 8 Streams or Kotlin sequences, you might be wondering how <kbd>Observable</kbd> is any different. The key difference is that <kbd>Observable</kbd> pushes the items while Streams and sequences pull the items. This may seem subtle, but the impact of a push-based iteration is far more powerful than a pull-based one. As we saw earlier, you can push not only data, but also events. For instance, <kbd>Observable.interval()</kbd> will push a consecutive <kbd>Long</kbd> at each specified time interval, as shown in the following code snippet. This <kbd>Long</kbd> emission is not only data, but also an event! Let's take a look:</p>
<pre style="padding-left: 60px"><span>import </span><span>io.reactivex.</span><span>Observable</span><span>;<br/></span><span>import </span><span>java.util.concurrent.</span><span>TimeUnit</span><span>;<br/></span><span><br/></span><span>public class </span><span>Launcher </span><span>{<br/></span><span>      </span><span>public static void </span><span>main</span><span>(</span><span>String</span><span>[] </span><span>args</span><span>) {<br/></span><span>        </span><span>Observable</span><span>&lt;</span><span>Long</span><span>&gt; </span><span>secondIntervals </span><span>=<br/></span><span>          </span><span>Observable</span><span>.</span><span>interval</span><span>(</span><span>1</span><span>, </span><span>TimeUnit</span><span>.</span><span>SECONDS</span><span>);<br/></span><span><br/></span><span>        </span><span>secondIntervals</span><span>.</span><span>subscribe</span><span>(</span><span>s </span>-&gt; <span>System</span><span>.</span><span>out</span><span>.</span><span>println</span><span>(</span><span>s</span><span>));<br/></span><span>        <br/></span><span>        </span><span>/* Hold main thread for 5 seconds<br/></span><span>        so Observable above has chance to fire */<br/></span><span>        </span><span>sleep</span><span>(</span><span>5000</span><span>);<br/></span><span>      }<br/></span><span><br/></span><span>      </span><span>public static void </span><span>sleep</span><span>(</span><span>long </span><span>millis</span><span>) {<br/></span><span>        </span><span>try </span><span>{<br/></span><span>          </span><span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>millis</span><span>);<br/></span><span>        } </span><span>catch </span><span>(</span><span>InterruptedException </span><span>e</span><span>) {<br/></span><span>          </span><span>e</span><span>.</span><span>printStackTrace</span><span>();<br/></span><span>        }<br/></span><span>      }<br/></span><span>}<br/></span></pre>
<p>When we run this code, we should get the following output:</p>
<pre style="padding-left: 60px"><strong><br/></strong><span>0 <br/></span><span>1 <br/></span><span>2 <br/></span><span>3 <br/></span><span>4 </span></pre>
<p>When you run the preceding code, you will see that a consecutive emission fires every second. This application will run for about five seconds before it quits, and you will likely see emissions <kbd>0</kbd> to <kbd>4</kbd> fired, each separated by a just a second's gap. This simple idea that data is a series of events over time will unlock new possibilities in how we tackle programming.</p>
<p>On a side note, we will get more into concurrency later, but we had to create a <strong><kbd>sleep()</kbd></strong> method because this <kbd>Observable</kbd> fires emissions on a computation thread when subscribed to. The main thread used to launch our application is not going to wait on this <kbd>Observable</kbd> since it fires on a computation thread, not the main thread. Therefore, we use <kbd>sleep()</kbd> to pause the main thread for 5000 milliseconds and then allow it to reach the end of the <kbd>main()</kbd> method (which will cause the application to terminate). This gives <kbd>Observable.interval()</kbd> a chance to fire for a five second window before the application quits.</p>
<p>Throughout this book, we will uncover many mysteries about <kbd>Observable</kbd> and the powerful abstractions it takes care of for us. If you've conceptually understood what is going on here so far, congrats! You are already becoming familiar with how reactive code works. To emphasize again, emissions are pushed one at a time all the way to <kbd>Observer</kbd>. Emissions represent both data and an event, which can be emitted over time. Of course, beyond <kbd>map()</kbd>, there are hundreds of operators in RxJava, and we will learn about the key ones in this book. Learning which operators to use for a situation and how to combine them is the key to mastering RxJava. In the next chapter, we will cover <kbd>Observable</kbd> and <kbd>Observer</kbd> much more comprehensively. We will also demystify events and data being represented in <kbd>Observable</kbd> a bit more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">RxJava 1.0 versus RxJava 2.0 - which one do I use?</h1>
                </header>
            
            <article>
                
<p>As stated earlier, you are encouraged to use RxJava 2.0 if you can. It will continue to grow and receive new features, while RxJava 1.0 will be maintained for bug fixes. However, there are other considerations that may lead you to use RxJava 1.0.</p>
<p>If you inherit a project that is already using RxJava 1.0, you will likely continue using that until it becomes feasible to refactor to 2.0. You can also check out David Akarnokd's <em>RxJava2Interop</em> project (<a href="https://github.com/akarnokd/RxJava2Interop" target="_blank">https://github.com/akarnokd/RxJava2Interop</a>), which converts Rx types from RxJava 1.0 to RxJava 2.0 and vice versa. After you finish this book, you may consider using this library to leverage RxJava 2.0 even if you have the RxJava 1.0 legacy code.</p>
<p>In RxJava, there are several libraries to make several Java APIs reactive and plug into RxJava seamlessly. Just to name a few, these libraries include RxJava-JDBC, RxAndroid, RxJava-Extras, RxNetty, and RxJavaFX. At the time of writing this, only RxAndroid and RxJavaFX have been fully ported to RxJava 2.0 (although many other libraries are following). By the time you are reading this, all major RxJava extension libraries will hopefully be ported to RxJava 2.0.</p>
<p>You will also want to prefer RxJava 2.0 because it was built on much of the hindsight and wisdom gained from RxJava 1.0. It has better performance, simpler APIs, a cleaner approach to backpressure, and a bit more safety when hacking together your own operators.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">When to use RxJava</h1>
                </header>
            
            <article>
                
<p>A common question ReactiveX newcomers ask is what circumstances warrant a reactive approach? Do we always want to use RxJava? As someone who has been living and breathing reactive programming for a while, I have learned that there are two answers to this question:</p>
<p>The first answer is when you first start out: <em>yes!</em> You always want to take a reactive approach. The only way to truly become a master of reactive programming is to build reactive applications from the ground up. Think of everything as <kbd>Observable</kbd> and always model your program in terms of data and event flows. When you do this, you will leverage everything reactive programming has to offer and see the quality of your applications go up significantly.</p>
<p>The second answer is that when you become experienced in RxJava, you will find cases where RxJava may not be appropriate. There will occasionally be times where a reactive approach may not be optimal, but usually, this exception applies to only part of your code. Your entire project itself should be reactive. There may be parts that are not reactive and for good reason. These exceptions only stand out to a trained Rx veteran who sees that returning <kbd>List&lt;String&gt;</kbd> is perhaps better than returning <kbd>Observable&lt;String&gt;</kbd>.<br/>
<br/>
Rx greenhorns should not worry about when something should be reactive versus something not reactive. Over time, they will start to see cases where the benefits of Rx are marginalized, and this is something that only comes with experience.</p>
<p>So for now, no compromises. Go reactive all the way!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p> In this chapter, we learned how to look at the world in a reactive way. As a developer, you may have to retrain yourself from a traditional imperative mindset and develop a reactive one. Especially if you have done imperative, object-oriented programming for a long time, this can be challenging. But the return on investment will be significant as your applications will become more maintainable, scalable, and evolvable. You will also have faster turn around and more legible code.</p>
<p>We also covered how to configure a RxJava project using Gradle or Maven and what decisions should drive whether you should choose RxJava 2.0 versus RxJava 1.0. We also got a brief introduction to reactive code and how <kbd>Observable</kbd> works through push-based iteration.<br/>
 <br/>
By the time you finish this book, you will hopefully find reactive programming intuitive and easy to reason with. I hope you find that RxJava not only makes you more productive, but also helps you take on tasks you hesitated to do earlier. So let's get started!</p>
<p> </p>


            </article>

            
        </section>
    </body></html>