<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;JavaServer Faces"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. JavaServer Faces</h1></div></div></div><p>In this chapter, we will cover <span class="strong"><strong>JavaServer Faces</strong></span> (<span class="strong"><strong>JSF</strong></span>), the standard component framework of the Java EE platform. Java EE 7 includes JSF 2.2, the latest version of JSF. JSF relies a lot on convention over configuration. If we follow JSF conventions, then we don't need to write a lot of configuration. In most cases, we don't need to write any configuration at all. This fact, combined with the fact that <code class="literal">web.xml</code> has been optional since Java EE 6, means that in many cases, we can write complete web applications without having to write a single line of XML configuration.</p><div class="section" title="Introduction to JSF"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Introduction to JSF</h1></div></div></div><p>JSF 2.0 introduced a number<a id="id88" class="indexterm"/> of enhancements to make JSF application development easier. In the following few sections, we will explain some of these features.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Readers unfamiliar with the earlier versions of JSF may not understand the following few sections completely. Don't worry, everything will be perfectly clear by the end of this chapter.</p></div></div><div class="section" title="Facelets"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Facelets</h2></div></div></div><p>One notable difference between the modern versions of JSF and the earlier versions is that Facelets is now the preferred view technology. The earlier versions of JSF used JSP as their default view technology. Since<a id="id89" class="indexterm"/> JSP technology predates JSF, sometimes using JSP with JSF felt unnatural or created problems. For example, the lifecycle of JSPs is different from the lifecycle of JSFs; this mismatch introduced some problems for JSF 1.x application developers.</p><p>JSF was designed from the beginning to support multiple view technologies. To take advantage of this capability, Jacob Hookom wrote a view technology specifically for JSF. He named his view technology <span class="strong"><strong>Facelets</strong></span>. Facelets<a id="id90" class="indexterm"/> was so successful that it became a de facto standard for JSF. The JSF expert group recognized Facelets' popularity and made it the official view technology for<a id="id91" class="indexterm"/> JSF in Version 2.0 of the <a id="id92" class="indexterm"/>JSF specification.</p></div><div class="section" title="Optional faces-config.xml"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Optional faces-config.xml</h2></div></div></div><p>Legacy J2EE applications suffered what some would have considered being excessive XML configuration.</p><p>Java EE 5 <a id="id93" class="indexterm"/>took some measures to reduce the XML configuration considerably. Java EE 6 reduced the required configuration even further, making the <code class="literal">faces-config.xml</code> JSF configuration file optional in<a id="id94" class="indexterm"/> JSF 2.0.</p><p>In JSF 2.0 and newer, JSF managed beans can be configured via the <code class="literal">@ManagedBean</code> annotation, obviating the need to <a id="id95" class="indexterm"/>configure them in <code class="literal">faces-config.xml</code>. Java EE 6 introduced the <span class="strong"><strong>Contexts and Dependency Injection</strong></span> (<span class="strong"><strong>CDI</strong></span>) API, which <a id="id96" class="indexterm"/>provides an alternative way to implement the functionality that was typically implemented with JSF managed beans. As of JSF 2.2, CDI named beans are preferred over JSF managed beans.</p><p>Additionally, there is a convention for JSF navigation. If the value of the <code class="literal">action</code> attribute of a JSF 2 command link or command button matches the name of a facelet (minus the XHTML extension), then<a id="id97" class="indexterm"/> by convention, the application will navigate to the facelet that matches the action name. This convention allows us to avoid having to configure an application's navigation in <code class="literal">faces-config.xml</code>.</p><p>For many modern JSF applications, <code class="literal">faces-config.xml</code> is completely unnecessary as long as the established JSF conventions are followed.</p><div class="section" title="Standard resource locations"><div class="titlepage"><div><div><h3 class="title"><a id="ch02lvl3sec10"/>Standard resource locations</h3></div></div></div><p>JSF 2.0 introduced standard resource locations. <a id="id98" class="indexterm"/>Resources are the artifacts that a page or JSF component needs to render properly, such as CSS style sheets, JavaScript files, and images.</p><p>In JSF 2.0 and newer, resources can be <a id="id99" class="indexterm"/>placed in a subdirectory under a folder called <code class="literal">resources</code> either at the root of the WAR file or under <code class="literal">META-INF</code>. By <a id="id100" class="indexterm"/>convention, JSF components know that they can retrieve resources from one of these two locations.</p><p>In order to avoid cluttering the resources directory, resources are typically placed in a subdirectory. This subdirectory is referred to from the <code class="literal">library</code> attribute of JSF components.</p><p>For example, we could place a CSS style sheet called <code class="literal">styles.css</code> under <code class="literal">/resources/css/</code>.</p><p>In our JSF pages, we can retrieve this CSS file using the <code class="literal">&lt;h:outputStylesheet&gt;</code> tag as follows:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputStylesheet library="css"  name="styles.css"/&gt;</pre></div><p>The value of the <code class="literal">library</code> attribute must match the subdirectory where our style sheet is located.</p><p>Similarly, we can have a<a id="id101" class="indexterm"/> JavaScript file, <code class="literal">somescript.js</code>, under <code class="literal">/resources/scripts/</code> and we can access<a id="id102" class="indexterm"/> it using the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:outputScript library="scripts" name="somescript.js"/&gt;</pre></div><p>We can have an image, <code class="literal">logo.png</code>, under <code class="literal">/resources/images/</code> and we can access this resource with the following code:</p><div class="informalexample"><pre class="programlisting">&lt;h:graphicImage library="images" name="logo.png"/&gt;</pre></div><p>Note that in each case, the value of the <code class="literal">library</code> attribute matches the corresponding subdirectory name under the <code class="literal">resources</code> directory and the value of the <code class="literal">name</code> attribute matches the resource's filename.</p></div></div></div></div>
<div class="section" title="Developing our first JSF application"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Developing our first JSF application</h1></div></div></div><p>To illustrate basic JSF concepts, we <a id="id103" class="indexterm"/>will develop a simple application consisting of two Facelets pages and a single CDI named bean.</p><div class="section" title="Facelets"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Facelets</h2></div></div></div><p>As we mentioned in this chapter's<a id="id104" class="indexterm"/> introduction, the default view technology for JSF 2 is Facelets. Facelets need to be written using standard XML. <a id="id105" class="indexterm"/>The most popular way of developing Facelets pages is to use XHTML in conjunction with JSF-specific XML namespaces. The following example shows how a typical Facelets page looks:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
<span class="strong"><strong>      </strong></span>
<span class="strong"><strong>      &gt;</strong></span>
<span class="strong"><strong>    &lt;h:head&gt;</strong></span>
        &lt;title&gt;Enter Customer Data&lt;/title&gt;
<span class="strong"><strong>    &lt;/h:head&gt;</strong></span>
<span class="strong"><strong>    &lt;h:body&gt;</strong></span>
<span class="strong"><strong>        &lt;h:outputStylesheet library="css" name="styles.css"/&gt;</strong></span>
<span class="strong"><strong>        &lt;h:form id="customerForm"&gt;</strong></span>
<span class="strong"><strong>            &lt;h:messages&gt;&lt;/h:messages&gt;</strong></span>
<span class="strong"><strong>            &lt;h:panelGrid columns="2"</strong></span>
<span class="strong"><strong>                         columnClasses="rightAlign,leftAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;h:outputLabel for="firstName" value="First </strong></span>
<span class="strong"><strong>                                    Name:"&gt;</strong></span>
<span class="strong"><strong>                &lt;/h:outputLabel&gt;</strong></span>
<span class="strong"><strong>                &lt;h:inputText id="firstName"</strong></span>
<span class="strong"><strong>                             label="First Name"</strong></span>
<span class="strong"><strong>                             value="#{customer.firstName}"</strong></span>
<span class="strong"><strong>                             required="true"&gt;</strong></span>
<span class="strong"><strong>                    &lt;f:validateLength minimum="2" maximum="30"&gt;</strong></span>
<span class="strong"><strong>                    &lt;/f:validateLength&gt;</strong></span>
<span class="strong"><strong>                &lt;/h:inputText&gt;</strong></span>
<span class="strong"><strong>                &lt;h:outputLabel for="lastName" value="Last Name:"&gt;</strong></span>
<span class="strong"><strong>                &lt;/h:outputLabel&gt;</strong></span>
<span class="strong"><strong>                &lt;h:inputText id="lastName"</strong></span>
<span class="strong"><strong>                             label="Last Name"</strong></span>
<span class="strong"><strong>                             value="#{customer.lastName}"</strong></span>
<span class="strong"><strong>                             required="true"&gt;</strong></span>
<span class="strong"><strong>                    &lt;f:validateLength minimum="2" maximum="30"&gt;</strong></span>
<span class="strong"><strong>                    &lt;/f:validateLength&gt;</strong></span>
<span class="strong"><strong>                &lt;/h:inputText&gt;</strong></span>
<span class="strong"><strong>                &lt;h:outputLabel for="email" value="Email:"&gt;</strong></span>
<span class="strong"><strong>                &lt;/h:outputLabel&gt;</strong></span>
<span class="strong"><strong>                &lt;h:inputText id="email" </strong></span>
<span class="strong"><strong>                             label="Email" </strong></span>
<span class="strong"><strong>                             value="#{customer.email}"&gt;</strong></span>
<span class="strong"><strong>                    &lt;f:validateLength minimum="3" maximum="30"&gt;</strong></span>
<span class="strong"><strong>                    &lt;/f:validateLength&gt;</strong></span>
<span class="strong"><strong>                &lt;/h:inputText&gt;</strong></span>
<span class="strong"><strong>                &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt;</strong></span>
<span class="strong"><strong>                &lt;h:commandButton action="confirmation" </strong></span>
<span class="strong"><strong>                                         value="Save"&gt;</strong></span>
<span class="strong"><strong>                &lt;/h:commandButton&gt;</strong></span>
<span class="strong"><strong>            &lt;/h:panelGrid&gt;</strong></span>
<span class="strong"><strong>        &lt;/h:form&gt;</strong></span>
<span class="strong"><strong>    &lt;/h:body&gt;</strong></span>
&lt;/html&gt;</pre></div><p>The following screenshot illustrates how<a id="id106" class="indexterm"/> our example <a id="id107" class="indexterm"/>page is rendered in the browser:</p><div class="mediaobject"><img src="graphics/6886EN_02_01.jpg" alt="Facelets"/></div><p>The preceding screenshot, of course, was taken after entering some data in every text field; originally, each text field was blank.</p><p>Pretty much any Facelets JSF page<a id="id108" class="indexterm"/> will include the two namespaces illustrated in the example. The first namespace (<code class="literal"/>) is for the tags that render HTML components; by convention, the prefix <code class="literal">h</code> (for HTML) is used when using this tag library.</p><p>The second namespace (<code class="literal"/>) is the core JSF tag library; by convention, the prefix <code class="literal">f</code> (for faces) is used when using this tag library.</p><p>The first JSF-specific tags we see in our example are the <code class="literal">&lt;h:head&gt;</code> and the <code class="literal">&lt;h:body&gt;</code> tags. These tags are analogous to the standard HTML <code class="literal">&lt;head&gt;</code> and <code class="literal">&lt;body&gt;</code> tags and are rendered as such when the page is displayed in the browser.</p><p>The <code class="literal">&lt;h:outputStylesheet&gt;</code> tag <a id="id109" class="indexterm"/>is used to load a CSS style sheet from a well-known location. (JSF standardizes the locations of resources such as CSS style sheets and JavaScript files; this will be discussed in detail later in the chapter.) The value of the <code class="literal">library</code> attribute must correspond to the directory where the CSS file resides (this directory must be under a <code class="literal">resources</code> directory). The <code class="literal">name</code> attribute must correspond to the name of the CSS style sheet we wish to load.</p><p>The next tag that we see is the <a id="id110" class="indexterm"/>
<code class="literal">&lt;h:form&gt;</code> tag. This tag generates an HTML form when the page is rendered. As can be seen in the example, there is no need to specify an <code class="literal">action</code> or a <code class="literal">method</code> attribute for this tag; as a matter of fact, there is neither an <code class="literal">action</code> attribute nor a <code class="literal">method</code> attribute for this tag. The <code class="literal">action</code> attribute for the rendered HTML form will be generated automatically, and the <code class="literal">method</code> attribute will always be <code class="literal">"post".</code> The <code class="literal">id</code> attribute of <code class="literal">&lt;h:form&gt;</code> is optional; however, it is a good idea to always add it since it makes debugging JSF applications easier.</p><p>The next tag we see is the <code class="literal">&lt;h:messages&gt;</code> tag. As its name implies, this tag is used to display any messages. As we will see shortly, JSF can automatically generate validation messages. These will be displayed inside this tag. Additionally, arbitrary messages can be added programmatically via the <code class="literal">addMessage()</code> method<a id="id111" class="indexterm"/> defined in <code class="literal">javax.faces.context.FacesContext</code>.</p><p>The next JSF tag we see is <code class="literal">&lt;h:panelGrid&gt;</code>. <a id="id112" class="indexterm"/>This tag is roughly equivalent to<a id="id113" class="indexterm"/> an HTML table, but it works a bit differently. Instead of declaring rows and columns, the <code class="literal">&lt;h:panelGrid&gt;</code> tag has a <code class="literal">columns</code> attribute; the value of this attribute indicates the number of columns in the table rendered by this tag. As we place components inside this tag, they will be placed in a row until the number of columns defined in the <code class="literal">columns</code> attribute is reached, and then the next <a id="id114" class="indexterm"/>component will be placed in the next row. In the example, the value of the <code class="literal">columns</code> attribute is two. Therefore, the first two tags will be placed in the first row, the next two will be placed in the second row, and so forth.</p><p>Another interesting attribute of <code class="literal">&lt;h:panelGrid&gt;</code> is the <code class="literal">columnClasses</code> attribute. This attribute assigns a CSS class to each column in the rendered table. In the example, two CSS classes (separated by a comma) are used as the value for this attribute. This has the effect of assigning the first CSS class to the first column and the second one to the second column. Had there been three or more columns, the third one would have gotten the first CSS class, the fourth one would have gotten the second one, and so on, alternating between the first one and the second one. To clarify how this works, the next code snippet illustrates a portion of the source of the HTML markup generated by our example page:</p><div class="informalexample"><pre class="programlisting">&lt;table&gt;
    &lt;tbody&gt;
        &lt;tr&gt;
<span class="strong"><strong>            &lt;td class="rightAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;label for="customerForm:firstName"&gt;</strong></span>
<span class="strong"><strong>                    First Name:</strong></span>
<span class="strong"><strong>                &lt;/label&gt;</strong></span>
<span class="strong"><strong>            &lt;/td&gt;</strong></span>
<span class="strong"><strong>            &lt;td class="leftAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;input id="customerForm:firstName" type="text"</strong></span>
<span class="strong"><strong>                    name="customerForm:firstName" /&gt;</strong></span>
<span class="strong"><strong>            &lt;/td&gt;</strong></span>
        &lt;/tr&gt;
        &lt;tr&gt;
<span class="strong"><strong>            &lt;td class="rightAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;label for="customerForm:lastName"&gt;</strong></span>
<span class="strong"><strong>                    Last Name:</strong></span>
<span class="strong"><strong>                &lt;/label&gt;</strong></span>
<span class="strong"><strong>            &lt;/td&gt;</strong></span>
<span class="strong"><strong>            &lt;td class="leftAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;input id="customerForm:lastName" type="text"</strong></span>
<span class="strong"><strong>                            name="customerForm:lastName" /&gt;</strong></span>
<span class="strong"><strong>            &lt;/td&gt;</strong></span>
        &lt;/tr&gt;
        &lt;tr&gt;
<span class="strong"><strong>            &lt;td class="rightAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;label for="customerForm:lastName"&gt;</strong></span>
<span class="strong"><strong>                    Email:</strong></span>
<span class="strong"><strong>                &lt;/label&gt;</strong></span>
<span class="strong"><strong>            &lt;/td&gt;</strong></span>
<span class="strong"><strong>            &lt;td class="leftAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;input id="customerForm:email" type="text"</strong></span>
<span class="strong"><strong>                            name="customerForm:email" /&gt;</strong></span>
<span class="strong"><strong>            &lt;/td&gt;</strong></span>
        &lt;/tr&gt;
        &lt;tr&gt;
<span class="strong"><strong>            &lt;td class="rightAlign"&gt;&lt;/td&gt;</strong></span>
<span class="strong"><strong>            &lt;td class="leftAlign"&gt;</strong></span>
<span class="strong"><strong>                &lt;input type="submit" name="customerForm:j_idt12"</strong></span>
<span class="strong"><strong>                   value="Save" /&gt;</strong></span>
<span class="strong"><strong>            &lt;/td&gt;</strong></span>
        &lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;</pre></div><p>Note how each <code class="literal">&lt;td&gt;</code> tag has an alternating CSS tag of "<code class="literal">rightAlign</code>" or "<code class="literal">leftAlign</code>". We achieved this by assigning the value "<code class="literal">rightAlign,leftAlign</code>" to the <code class="literal">columnClasses</code> attribute of <code class="literal">&lt;h:panelGrid&gt;</code>. The CSS classes we have used in our example are defined in the<a id="id115" class="indexterm"/> CSS style sheet we loaded via the <code class="literal">&lt;h:outputStylesheet&gt;</code> tag we discussed earlier. The IDs of the generated markup are a combination of the ID we gave to the <code class="literal">&lt;h:form&gt;</code> component plus the ID <a id="id116" class="indexterm"/>of each individual component. We didn't assign an ID to the <code class="literal">&lt;h:commandButton&gt;</code> component near the end of the page, so the JSF runtime assigned one automatically.</p><p>At this point in the example, we start adding components inside <code class="literal">&lt;h:panelGrid&gt;</code>. These components will be rendered inside the table rendered by <code class="literal">&lt;h:panelGrid&gt;</code>. As we have mentioned before, the number of columns in the rendered table is defined by the columns attribute of <code class="literal">&lt;h:panelGrid&gt;</code>. Therefore, we don't need to worry about columns (or rows); we have to just start adding components, and they will be inserted in the right place.</p><p>The next tag we see is the <code class="literal">&lt;h:outputLabel&gt;</code> tag.<a id="id117" class="indexterm"/> This tag renders an HTML <code class="literal">label</code> element. Labels are associated with other components via the <code class="literal">for</code> attribute, whose value must match the ID of the component that the label is for.</p><p>Next, we see the <code class="literal">&lt;h:inputText&gt;</code> tag. This tag generates a text field in the rendered page; its <code class="literal">label</code> attribute is used<a id="id118" class="indexterm"/> for any validation messages. It lets the user know which field the message refers to.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip06"/>Tip</h3><p>Although it is not required for the value of the <code class="literal">label</code> attribute of <code class="literal">&lt;h:inputText&gt;</code> to match the label displayed on the page, it is highly recommended to use this value. In case of an<a id="id119" class="indexterm"/> error, this will let the user know exactly which field the message is referring to.</p></div></div><p>Of particular interest is the tag's <code class="literal">value</code> attribute. What we see as the value for this attribute is a <span class="strong"><strong>value-binding expression</strong></span>.<a id="id120" class="indexterm"/> This means that this value is tied to a property of one of the application's named beans. In the example, this particular text field is tied to a property called <code class="literal">firstName</code> in a named bean called <code class="literal">customer</code>. When a user enters a value for this text field and submits the form, the corresponding property in the named bean is updated with this value. The tag's <code class="literal">required</code> attribute is optional, and valid values for it are <code class="literal">true</code> and <code class="literal">false</code>. If this attribute is set to <code class="literal">true</code>, the container will not let the user submit the form until the user enters some data in the text field. If the user attempts to submit the form without entering a required value, the page will be reloaded and an error message will be displayed inside the <code class="literal">&lt;h:messages&gt;</code> tag. The following screenshot shows the error message:</p><div class="mediaobject"><img src="graphics/6886EN_02_02.jpg" alt="Facelets"/></div><p>The preceding screenshot illustrates the default error message shown when the user attempts to save the form in the example without entering a value for the customer's first name. The first part of the<a id="id121" class="indexterm"/> message (<span class="strong"><strong>First Name</strong></span>) is taken from the value of the <code class="literal">label</code> attribute of the corresponding <code class="literal">&lt;h:inputTextField&gt;</code> tag. You can customize the text as well as the style of the message (font, color, and so on). We will cover how to do this later in this chapter.</p></div><div class="section" title="Project stages"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Project stages</h2></div></div></div><p>Having an <code class="literal">&lt;h:messages&gt;</code> tag on every JSF page is a good idea; without it, the user might not see the validation messages and will have no idea why the form submission is not going through. By default, JSF validation messages do not generate any output in the GlassFish log. A common mistake new JSF developers make is that they fail to add an <code class="literal">&lt;h:messages&gt;</code> tag to their pages. Without the<a id="id122" class="indexterm"/> tag, if the validation fails, then the navigation seems to fail for no reason. (The same page is rendered if the navigation fails, and without an <code class="literal">&lt;h:messages&gt;</code> tag, no error messages are displayed in the browser.)</p><p>To avoid the situation described in the previous paragraph, JSF 2.0 introduced the concept of <span class="strong"><strong>project stages</strong></span>.</p><p>The following project stages are defined in JSF 2:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Production<a id="id123" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">Development<a id="id124" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">UnitTest<a id="id125" class="indexterm"/></li><li class="listitem" style="list-style-type: disc">SystemTest<a id="id126" class="indexterm"/></li></ul></div><p>We can define the project stage as an initialization parameter to the faces servlet in the <code class="literal">web.xml</code> file or as a custom JNDI resource. Since <code class="literal">web.xml</code> is now optional and altering it makes it relatively easy to use the wrong project stage if we forget to modify it when we move our code from one environment to another, the preferred way of setting the project stage is through a custom JNDI resource.</p><p>With GlassFish, we can do this by logging in to the web console, navigating to <span class="strong"><strong>JNDI</strong></span> | <span class="strong"><strong>Custom Resources</strong></span>, and then clicking on the <span class="strong"><strong>New...</strong></span> button. The page that appears looks as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_02_03.jpg" alt="Project stages"/></div><p>In the resulting page, we need to<a id="id127" class="indexterm"/> enter the following information:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><tbody><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>JNDI Name</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">javax.faces.PROJECT_STAGE</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<span class="strong"><strong>Resource Type</strong></span>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">java.lang.String</code>
</p>
</td></tr></tbody></table></div><p>After you enter the preceding two values, the <span class="strong"><strong>Factory Class</strong></span> field will be automatically populated with the value <code class="literal">org.glassfish.resources.custom.factory.PrimitivesAndStringFactory</code>.</p><p>After entering the values, we need to add a new property with a name of the stage and a value corresponding to the project stage we wish to use.</p><p>Setting the project stage allows us to perform some logic only if we are running the program in a specific stage. For instance, in one of our named beans, we could have code that looks as follows:</p><div class="informalexample"><pre class="programlisting">    FacesContext facesContext =
        FacesContext.getCurrentInstance();
    Application application = facesContext.getApplication();

    if (application.getProjectStage().equals(
        ProjectStage.Production)) {
      //do production stuff
    } else if (application.getProjectStage().equals(
        ProjectStage.Development)) {
      //do development stuff
    } else if (application.getProjectStage().equals(
        ProjectStage.UnitTest)) {
      //do unit test stuff
    } else if (application.getProjectStage().equals(
        ProjectStage.SystemTest)) {
      //do system test stuff
    }</pre></div><p>As we can see, project stages allow us to modify our code's behavior for different environments. More importantly,<a id="id128" class="indexterm"/> setting the project stage allows the JSF engine to behave a bit differently based on the project stage setting. Relevant to our discussion, setting the project stage to Development results in additional logging statements in the application server log. Therefore, if we forget to add an <code class="literal">&lt;h:messages&gt;</code> tag to our page—our project stage is Development—and validation fails, a validation error will be displayed on the page even if we omit the <code class="literal">&lt;h:messages&gt;</code> component. The following screenshot shows the validation error message:</p><div class="mediaobject"><img src="graphics/6886EN_02_04.jpg" alt="Project stages"/></div><p>In the default Production stage, this error message is not displayed on the page, leaving us confused as to why our page navigation doesn't seem to work.</p></div><div class="section" title="Validation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Validation</h2></div></div></div><p>JSF provides built-in input <a id="id129" class="indexterm"/>validation capabilities.</p><p>In the previous section's example, note that each <code class="literal">&lt;h:inputField&gt;</code> tag has a nested <code class="literal">&lt;f:validateLength&gt;</code> tag. As its name implies, this tag validates that the entered value for the text field is between a minimum and maximum length. The minimum and maximum values are defined by the tag's <code class="literal">minimum</code> and <code class="literal">maximum</code> attributes. <code class="literal">&lt;f:validateLength&gt;</code> is one<a id="id130" class="indexterm"/> of the standard validators included in JSF. Just like with the <code class="literal">required</code> attribute of <code class="literal">&lt;h:inputText&gt;</code>, JSF will automatically display a default error message when a user attempts to submit a form with a value that does not validate.</p><div class="mediaobject"><img src="graphics/6886EN_02_05.jpg" alt="Validation"/></div><p>Again, the default message and style can be overridden; we will cover how to do this later in this chapter in the <span class="emphasis"><em>Customizing JSF's default messages</em></span> section.</p><p>In addition to <code class="literal">&lt;f:validateLength&gt;</code>, JSF includes<a id="id131" class="indexterm"/> other standard validators, which are listed in the following table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Validation tag</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;f:validateBean&gt;</code><a id="id132" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Bean validation allows us to validate named bean values using annotations in our named beans without having to add validators to our JSF tags. These tags allow us to fine-tune Bean Validation if necessary.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;f:validateDoubleRange&gt;</code><a id="id133" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This tag validates that the input is a valid <code class="literal">Double</code> value between the two values specified by the tag's <code class="literal">minimum</code> and <code class="literal">maximum</code> attributes, inclusive.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;f:validateLength&gt;</code><a id="id134" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This tag validates that the input's length is between the values specified by the tag's <code class="literal">minimum</code> and <code class="literal">maximum</code> values, inclusive.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;f:validateLongRange&gt;</code><a id="id135" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This tag validates that the input is a valid <code class="literal">Long</code> value between the values specified by the tag's <code class="literal">minimum</code> and <code class="literal">maximum</code> attributes, inclusive.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;f:validateRegex&gt;</code><a id="id136" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This tag validates that the input matches a regular expression pattern specified in the tag's <code class="literal">pattern</code> attribute.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">&lt;f:validateRequired&gt;</code><a id="id137" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>This tag validates that the input is not empty. This tag is equivalent to setting the <code class="literal">required</code> attribute to <code class="literal">true</code> in the parent input field.</p>
</td></tr></tbody></table></div><p>Note that in the description for <code class="literal">&lt;f:validateBean&gt;</code>, we briefly mentioned Bean Validation. The Bean Validation JSR aims to standardize JavaBean validation. JavaBeans are used across several other API's that, up until recently, had to implement their own validation logic. JSF 2.0 adopted the Bean<a id="id138" class="indexterm"/> Validation standard to help validate named bean properties.</p><p>If we wish to take advantage of Bean Validation, all we need to do is annotate the desired field with the appropriate Bean Validation annotation, without having to explicitly use a JSF validator.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>For the complete list of Bean Validation annotations, refer to the <code class="literal">javax.validation.constraints</code> package in the Java EE 7 API at <a class="ulink" href="http://docs.oracle.com/javaee/7/api/">http://docs.oracle.com/javaee/7/api/</a>.</p></div></div></div><div class="section" title="Grouping components"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Grouping components</h2></div></div></div><p>
<code class="literal">&lt;h:panelGroup&gt;</code> is the next new tag in the example. Typically, <code class="literal">&lt;h:panelGroup&gt;</code> is used to group several<a id="id139" class="indexterm"/> components together so that they occupy a single cell in a <code class="literal">&lt;h:panelGrid&gt;</code> tag. This can be accomplished by adding components inside <code class="literal">&lt;h:panelGroup&gt;</code> and adding <code class="literal">&lt;h:panelGroup&gt;</code> to <code class="literal">&lt;h:panelGrid&gt;</code>. As <a id="id140" class="indexterm"/>can be seen in the example, this particular instance of <code class="literal">&lt;h:panelGroup&gt;</code> has no child components. In this particular case, the purpose of <code class="literal">&lt;h:panelGroup&gt;</code> is to have an "empty" cell and have the next component, <code class="literal">&lt;h:commandButton&gt;</code>, align with all other input fields in the form.</p></div><div class="section" title="Form submission"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Form submission</h2></div></div></div><p>
<code class="literal">&lt;h:commandButton&gt;</code> renders an HTML submit button in the browser. Just like with standard HTML, its purpose is to <a id="id141" class="indexterm"/>submit the form. Its <code class="literal">value</code> attribute simply sets the button's label. This tag's <code class="literal">action</code> attribute is used for navigation. The next page shown is based on the value of this attribute. The <code class="literal">action</code> attribute can have a <code class="literal">String</code> constant or a <span class="strong"><strong>method binding</strong></span><a id="id142" class="indexterm"/>
<span class="strong"><strong> expression</strong></span>, meaning that it can point to a method in a named bean that returns a <code class="literal">String</code> value.</p><p>If the base name of a page in our application matches the value of the <code class="literal">action</code> attribute of an <code class="literal">&lt;h:commandButton&gt;</code> tag,<a id="id143" class="indexterm"/> then we navigate to this page when clicking on the button. This JSF feature frees us from having to define navigation rules, as we used to do in the older versions of JSF. In our example, <a id="id144" class="indexterm"/>our confirmation page is called <code class="literal">confirmation.xhtml</code>; therefore, by convention, this page will be shown when the button is clicked since the value of its <code class="literal">action</code> attribute ("<code class="literal">confirmation</code>") matches the base name of the page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>Even though the label for the button reads <span class="strong"><strong>Save</strong></span>, in our simple example clicking on the button won't actually save any data.</p></div></div></div><div class="section" title="Named beans"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>Named beans</h2></div></div></div><p>There are two types of JavaBeans that can interact with JSF pages: JSF managed beans and CDI named beans. JSF managed beans <a id="id145" class="indexterm"/>have been around since the first version of the JSF specification and can be used only in a JSF context. CDI named beans were introduced in Java EE 6 and can interoperate with other Java EE APIs such as Enterprise JavaBeans. For these reasons, CDI named beans are preferred over JSF managed beans.</p><p>To make a Java class a CDI named bean, all we need to do is make sure that the class has a public, no-argument constructor (one is created implicitly if there are no other constructors declared, which is the case in our example), and add the<a id="id146" class="indexterm"/> <code class="literal">@Named</code> annotation at the class level. The following code snippet is the managed bean for our example:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jsf;
import javax.enterprise.context.RequestScoped;
import javax.inject.Named;

<span class="strong"><strong>@Named</strong></span>
@RequestScoped
public class Customer {

  private String firstName;
  private String lastName;
  private String email;

  public String getEmail() {
    return email;
  }

  public void setEmail(String email) {
    this.email = email;
  }

  public String getFirstName() {
    return firstName;
  }

  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }

  public String getLastName() {
    return lastName;
  }

  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
}</pre></div><p>The <code class="literal">@Named</code> class annotation<a id="id147" class="indexterm"/> designates this bean as a CDI named bean. This annotation has an optional <code class="literal">value</code> attribute that we can use to give our bean a logical name to use in our JSF pages. However, by convention, <a id="id148" class="indexterm"/>the value of this attribute is the same as the class name (<code class="literal">Customer</code>, in our case) with its first character switched to lowercase. In our example, we retain this default behavior; therefore, we access our bean's properties via the <code class="literal">customer</code> logical name. Notice the <code class="literal">value</code> attribute of any of the input fields in our example page to see this logical name in action.</p><p>Notice that other than the <code class="literal">@Named</code> and <code class="literal">@RequestScoped</code> annotations<a id="id149" class="indexterm"/>, there is nothing special about this bean. It is a standard JavaBean with private properties and corresponding getter and setter methods. The <code class="literal">@RequestScoped</code> annotation<a id="id150" class="indexterm"/> specifies that the bean should live through a single request.</p><p>Named beans always have a scope. A <a id="id151" class="indexterm"/>named bean scope defines the lifespan of the bean, and it is defined by a class-level annotation. The following table lists all valid named bean scopes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Named bean scope annotation</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ApplicationScoped</code><a id="id152" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The same instance <a id="id153" class="indexterm"/>of the application scoped named beans are available to all of our application's clients. If one client modifies the value of an application scoped managed bean, the change is reflected across all clients.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@SessionScoped</code><a id="id154" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>An instance of each session scoped named bean is assigned to each of our application's clients. A<a id="id155" class="indexterm"/> session scoped named bean can be used to hold client-specific data across requests.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@RequestScoped</code><a id="id156" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Request scoped named<a id="id157" class="indexterm"/> beans only live through a single request.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@Dependent</code><a id="id158" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Dependent scoped<a id="id159" class="indexterm"/> named beans <a id="id160" class="indexterm"/>are assigned the same scope as the bean they are injected into. This is the default scope if none is specified.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">@ConversationScoped</code><a id="id161" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>The conversation scope can span<a id="id162" class="indexterm"/> multiple requests and is typically shorter than the session scope.</p>
</td></tr></tbody></table></div></div><div class="section" title="Navigation"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec26"/>Navigation</h2></div></div></div><p>As can be seen on our input page, when we click on the <span class="strong"><strong>Save</strong></span> button in the <code class="literal">customer_data_entry.xhtml</code> page, our application will navigate to a page called <code class="literal">confirmation.xhtml</code>. This happens <a id="id163" class="indexterm"/>because we are taking advantage of the JSF's convention over configuration feature, in which if the value of the <code class="literal">action</code> attribute of a command button or link matches the base name of another page, then the navigation takes us to this page.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>
<span class="strong"><strong>Does the same page reload when you click on a button or link that should navigate to another page?</strong></span>
</p><p>When JSF does not recognize the value of the <code class="literal">action</code> attribute of a command button or command link, it will, by default, navigate to the same page that was displayed in the browser when the user clicked on a button or link that was meant to navigate to another page.</p><p>If navigation does not seem to be working properly, chances are there is a typo in the value of this attribute. Remember that by convention, JSF will look for a page whose base name matches the value of the <code class="literal">action</code> attribute of a command button or link.</p></div></div><p>The source for <code class="literal">confirmation.xhtml</code> looks as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;Customer Data Entered&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:panelGrid columns="2" columnClasses="rightAlign,leftAlign"&gt;
      &lt;h:outputText value="First Name:"&gt;&lt;/h:outputText&gt;
      &lt;h:outputText value="#{customer.firstName}"&gt;&lt;/h:outputText&gt;
      &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt;
      &lt;h:outputText value="#{customer.lastName}"&gt;&lt;/h:outputText&gt;
      &lt;h:outputText value="Email:"&gt;&lt;/h:outputText&gt;
      &lt;h:outputText value="#{customer.email}"&gt;&lt;/h:outputText&gt;
    &lt;/h:panelGrid&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>The <code class="literal">&lt;h:outputText&gt;</code> tag<a id="id164" class="indexterm"/> is the only tag on this page that we haven't covered before. This tag simply displays the value of its <code class="literal">value</code> attribute to the rendered page; its <code class="literal">value</code> attribute can be a simple string or a value <a id="id165" class="indexterm"/>binding expression. Since the value binding expressions in our <code class="literal">&lt;h:outputText&gt;</code> tags are the same expressions that were used in the previous page for the <code class="literal">&lt;h:inputText&gt;</code> tags, their values will correspond to the data that the user entered.</p><div class="mediaobject"><img src="graphics/6886EN_02_06.jpg" alt="Navigation"/></div><p>In traditional (that is, non-JSF) Java web applications, we defined URL patterns to be processed by specific servlets. Specifically for JSF, the suffixes <code class="literal">.jsf</code> or <code class="literal">.faces</code> were commonly used; another commonly used URL mapping for JSF was the <code class="literal">/faces</code> prefix. By default, GlassFish automatically adds the <code class="literal">/faces</code> prefix to the faces servlet; therefore, we don't have to specify any URL mappings at all. If, for any reason, we need to specify a different mapping, then we need to add a <code class="literal">web.xml</code> configuration file to our application. However, the default will suffice in most cases.</p><p>The URL we used for the pages in our application was the name of our Facelets page, prefixed by <code class="literal">/faces</code>. This takes advantage of the default URL mapping.</p></div></div>
<div class="section" title="Custom data validation"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Custom data validation</h1></div></div></div><p>In addition to providing<a id="id166" class="indexterm"/> standard validators, JSF allows us to create custom validators. This can be done in two ways: by creating a custom validator class or by adding validation methods to our named beans.</p><div class="section" title="Creating custom validators"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec27"/>Creating custom validators</h2></div></div></div><p>In addition to the standard <a id="id167" class="indexterm"/>validators, JSF allows us to create custom validators by creating a Java class that implements the <code class="literal">javax.faces.validator.Validator</code> interface.</p><p>The following class implements<a id="id168" class="indexterm"/> an e-mail validator, which we will use to validate the e-mail text input field in our customer data entry screen.</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jsfcustomval;

import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.component.html.HtmlInputText;
import javax.faces.context.FacesContext;
import javax.faces.validator.FacesValidator;
import javax.faces.validator.Validator;
import javax.faces.validator.ValidatorException;
import org.apache.commons.lang.StringUtils;

<span class="strong"><strong>@FacesValidator(value = "emailValidator")</strong></span>
public class EmailValidator implements Validator {

  @Override
<span class="strong"><strong>  public void validate(FacesContext facesContext,</strong></span>
<span class="strong"><strong>      UIComponent uiComponent,</strong></span>
<span class="strong"><strong>      Object value) throws ValidatorException {</strong></span>
    org.apache.commons.validator.EmailValidator emailValidator =
        org.apache.commons.validator.EmailValidator.getInstance();
    HtmlInputText htmlInputText = (HtmlInputText) uiComponent;

    String email = (String) value;

    if (!StringUtils.isEmpty(email)) {
      if (!emailValidator.isValid(email)) {
        FacesMessage facesMessage = new 
            FacesMessage(htmlInputText.
            getLabel()
            + ": email format is not valid");
        throw new ValidatorException(facesMessage);
      }
    }
  }
}</pre></div><p>The <code class="literal">@FacesValidator</code> annotation<a id="id169" class="indexterm"/> registers our class as a JSF custom validator class. The value of its <code class="literal">value</code> attribute is the logical name that JSF pages can use for reference.</p><p>As can be seen in the example, the only method we need to implement when implementing the <code class="literal">Validator</code> interface is a method called <code class="literal">validate()</code>. This method takes three parameters: an instance of <code class="literal">javax.faces.context.FacesContext</code>, an instance of <code class="literal">javax.faces.component.UIComponent</code>, and an object. Typically, application developers only need to be concerned with the last two. The second parameter is the component whose data we are validating, and the third parameter is the actual value. In the example, we cast <code class="literal">uiComponent</code> to <code class="literal">javax.faces.component.html.HtmlInputText</code>; in this way, we get access to its <code class="literal">getLabel()</code> method<a id="id170" class="indexterm"/>, which we can use as part of the error message.</p><p>If the entered value is not in a <a id="id171" class="indexterm"/>valid e-mail address format, a new instance of <code class="literal">javax.faces.application.FacesMessage</code> is created, passing the error message to be displayed in the browser as its constructor parameter. We then throw a new exception as <code class="literal">javax.faces.validator.ValidatorException</code>. The error message is then displayed in the browser.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>
<span class="strong"><strong>Apache Commons Validator</strong></span>
</p><p>Our custom JSF validator uses the Apache Commons Validator<a id="id172" class="indexterm"/> to do the actual validation. This library includes many common validations such as dates, credit card numbers, ISBN numbers, and e-mails. When implementing a custom validator, it is worth investigating if this library already has a validator that we can use.</p></div></div><p>In order to use our validator in our page, we need to use the <code class="literal">&lt;f:validator&gt;</code> JSF tag. The following Facelets page is a modified version of the customer data entry screen. This version uses the <code class="literal">&lt;f:validator&gt;</code> tag <a id="id173" class="indexterm"/>to validate e-mails.</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;Enter Customer Data&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet library="css" name="styles.css"/&gt;
    &lt;h:form&gt;
      &lt;h:messages&gt;&lt;/h:messages&gt;
      &lt;h:panelGrid columns="2"
                   columnClasses="rightAlign,leftAlign"&gt;
        &lt;h:outputText value="First Name:"&gt;
        &lt;/h:outputText&gt;
        &lt;h:inputText label="First Name"
                     value="#{customer.firstName}"
                     required="true"&gt;
          &lt;f:validateLength minimum="2" maximum="30"&gt;
          &lt;/f:validateLength&gt;
        &lt;/h:inputText&gt;
        &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt;
        &lt;h:inputText label="Last Name"
                     value="#{customer.lastName}"
                     required="true"&gt;
          &lt;f:validateLength minimum="2" maximum="30"&gt;
          &lt;/f:validateLength&gt;
        &lt;/h:inputText&gt;
        &lt;h:outputText value="Email:"&gt;
        &lt;/h:outputText&gt;
<span class="strong"><strong>        &lt;h:inputText label="Email" value="#{customer.email}"&gt;          </strong></span>
<span class="strong"><strong>          &lt;f:validator validatorId="emailValidator" /&gt;</strong></span>
<span class="strong"><strong>        &lt;/h:inputText&gt;</strong></span>
        &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt;
        &lt;h:commandButton action="confirmation" value="Save"&gt;
        &lt;/h:commandButton&gt;
      &lt;/h:panelGrid&gt;
    &lt;/h:form&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Notice that the value of the <code class="literal">validatorId</code> attribute of <code class="literal">&lt;f:validator&gt;</code> matches the <code class="literal">value</code> attribute of the <code class="literal">@FacesValidator</code> annotation in our custom validator.</p><p>After writing our custom validator <a id="id174" class="indexterm"/>and modifying our page to take advantage of it, we can see our validator in action as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_02_07.jpg" alt="Creating custom validators"/></div></div><div class="section" title="Validator methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec28"/>Validator methods</h2></div></div></div><p>Another way we can implement custom validation is by adding validation methods to one or more of the <a id="id175" class="indexterm"/>application's named beans. The following Java class illustrates the use of validator methods for JSF validation:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jsfcustomval;

import javax.enterprise.context.RequestScoped;
import javax.faces.application.FacesMessage;
import javax.faces.component.UIComponent;
import javax.faces.component.html.HtmlInputText;
import javax.faces.context.FacesContext;
import javax.faces.validator.ValidatorException;
import javax.inject.Named;

import org.apache.commons.lang.StringUtils;

@Named
@RequestScoped
public class AlphaValidator {

<span class="strong"><strong>  public void validateAlpha(FacesContext facesContext,</strong></span>
<span class="strong"><strong>      UIComponent uiComponent,</strong></span>
<span class="strong"><strong>      Object value) throws ValidatorException {</strong></span>
    if (!StringUtils.isAlphaSpace((String) value)) {
      HtmlInputText htmlInputText = (HtmlInputText) uiComponent;
      FacesMessage facesMessage = new FacesMessage(htmlInputText.
          getLabel()
          + ": only alphabetic characters are allowed.");
      throw new ValidatorException(facesMessage);
    }
  }
}</pre></div><p>In this example, the class contains only the validator method. We can give our validator method any name we want; <a id="id176" class="indexterm"/>however, its return value must be void, and it must take the three parameters illustrated in the example, in that order. In other words, except for the method name, the signature of a validator method must be identical to the signature of the <code class="literal">validate()</code> method defined in the <code class="literal">javax.faces.validator.Validator</code> interface.</p><p>As we can see, the body of our validator method is nearly identical to the body of our custom validator's <code class="literal">validate()</code> method<a id="id177" class="indexterm"/>. We check the value entered by the user to make sure that it contains only alphabetic characters and/or spaces. If it does not, then we throw <code class="literal">ValidatorException</code>, passing an instance of <code class="literal">FacesMessage</code> containing an appropriate <code class="literal">String</code> error message.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>
<span class="strong"><strong>StringUtils</strong></span>
</p><p>In the example, we used <code class="literal">org.apache.commons.lang.StringUtils</code> to perform the actual validation logic. In addition to the method used in the example, this class contains several methods to verify whether a string is numeric or alphanumeric. This class, part of the Apache <code class="literal">commons-lang</code> library, is very useful when writing custom validators.</p></div></div><p>Since every validator method must be in a named bean, we need to make sure that the class containing our validator method is annotated with the <code class="literal">@Named</code> annotation, as illustrated in our example.</p><p>The last thing we need to do in order to use our validator method is to bind it to our component via the tag's <code class="literal">validator</code> attribute. The code to do so is as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;Enter Customer Data&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet library="css" name="styles.css"/&gt;
    &lt;h:form&gt;
      &lt;h:messages&gt;&lt;/h:messages&gt;
      &lt;h:panelGrid columns="2"
                   columnClasses="rightAlign,leftAlign"&gt;
        &lt;h:outputText value="First Name:"&gt;
        &lt;/h:outputText&gt;
<span class="strong"><strong>        &lt;h:inputText label="First Name"</strong></span>
<span class="strong"><strong>                     value="#{customer.firstName}"</strong></span>
<span class="strong"><strong>                     required="true"</strong></span>
<span class="strong"><strong>                     validator="#{alphaValidator.validateAlpha}"&gt;</strong></span>
          &lt;f:validateLength minimum="2" maximum="30"&gt;
          &lt;/f:validateLength&gt;
<span class="strong"><strong>        &lt;/h:inputText&gt;</strong></span>
        &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt;
<span class="strong"><strong>        &lt;h:inputText label="Last Name"</strong></span>
<span class="strong"><strong>                     value="#{customer.lastName}"</strong></span>
<span class="strong"><strong>                     required="true"</strong></span>
<span class="strong"><strong>                     validator="#{alphaValidator.validateAlpha}"&gt;</strong></span>
          &lt;f:validateLength minimum="2" maximum="30"&gt;
          &lt;/f:validateLength&gt;
<span class="strong"><strong>        &lt;/h:inputText&gt;</strong></span>
        &lt;h:outputText value="Email:"&gt;
        &lt;/h:outputText&gt;
        &lt;h:inputText label="Email" value="#{customer.email}"&gt;
          &lt;f:validateLength minimum="3" maximum="30"&gt;
          &lt;/f:validateLength&gt;
          &lt;f:validator validatorId="emailValidator" /&gt;
        &lt;/h:inputText&gt;
        &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt;
        &lt;h:commandButton action="confirmation" value="Save"&gt;
        &lt;/h:commandButton&gt;
      &lt;/h:panelGrid&gt;
    &lt;/h:form&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>Since neither the first name nor the last name fields would accept anything other than alphabetic characters or spaces, we<a id="id178" class="indexterm"/> added our custom validator method to both of these fields.</p><p>Notice that the value of the <code class="literal">validator</code> attribute of the <code class="literal">&lt;h:inputText&gt;</code> tag is a JSF expression language expression that uses the default name for the bean containing our validation method. <code class="literal">alphaValidator</code> is the name of our bean, and <code class="literal">validateAlpha</code> is the name of our validator method.</p><p>After modifying our page to use our custom validator, we can now see it in action as follows:</p><div class="mediaobject"><img src="graphics/6886EN_02_08.jpg" alt="Validator methods"/></div><p>Note how for the <span class="strong"><strong>First Name</strong></span> field both our custom validator message and the standard length validator were executed.</p><p>The advantage of implementing validator methods is that you do not need the overhead of creating a whole class just for a single validator method. (Our example does just that, but in many cases, validator methods <a id="id179" class="indexterm"/>are added to an existing named bean containing other methods.) The disadvantage of validator methods is that each component can only be validated by a single validator method. When using validator classes, several <code class="literal">&lt;f:validator&gt;</code> tags<a id="id180" class="indexterm"/> can be nested inside the tag to be validated; therefore, multiple validations, both custom and standard, can be done to the field.</p></div></div>
<div class="section" title="Customizing JSF's default messages"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Customizing JSF's default messages</h1></div></div></div><p>As we mentioned earlier, it is possible to customize the style (font, color, text, and so on) of JSF default validation <a id="id181" class="indexterm"/>messages. Additionally, it is possible to modify the text <a id="id182" class="indexterm"/>of the default JSF validation messages. In the following sections, we will explain how to modify error message formatting and text.</p><div class="section" title="Customizing message styles"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec29"/>Customizing message styles</h2></div></div></div><p>Customizing message styles can be done via <span class="strong"><strong>Cascading Style Sheets</strong></span> (<span class="strong"><strong>CSS</strong></span>). This<a id="id183" class="indexterm"/> can be accomplished using the <code class="literal">&lt;h:message&gt;</code> style or the <code class="literal">styleClass</code> attributes. The <code class="literal">style</code> attribute is used when we want to declare the CSS style inline. The <code class="literal">styleClass</code> attribute is used when we want to use a <a id="id184" class="indexterm"/>predefined style in a CSS style sheet or inside a <code class="literal">&lt;style&gt;</code> tag in our page.</p><p>The following markup illustrates the use of the <code class="literal">styleClass</code> attribute<a id="id185" class="indexterm"/> to alter the style of error messages. It is a modified version of the input page that we saw in the previous section.</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;Enter Customer Data&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h:outputStylesheet library="css" name="styles.css" /&gt;
    &lt;h:form&gt;
<span class="strong"><strong>      &lt;h:messages styleClass="errorMsg"&gt;&lt;/h:messages&gt;</strong></span>
      &lt;h:panelGrid columns="2"
                   columnClasses="rightAlign,leftAlign"&gt;
        &lt;h:outputText value="First Name:"&gt;
        &lt;/h:outputText&gt;
        &lt;h:inputText label="First Name"
                     value="#{customer.firstName}"
                     required="true" 
                     validator="#{alphaValidator.validateAlpha}"&gt;
          &lt;f:validateLength minimum="2" maximum="30"&gt;
          &lt;/f:validateLength&gt;
        &lt;/h:inputText&gt;
        &lt;h:outputText value="Last Name:"&gt;&lt;/h:outputText&gt;
        &lt;h:inputText label="Last Name"
                     value="#{customer.lastName}"
                     required="true"
                     validator="#{alphaValidator.validateAlpha}"&gt;
          &lt;f:validateLength minimum="2" maximum="30"&gt;
          &lt;/f:validateLength&gt;
        &lt;/h:inputText&gt;
        &lt;h:outputText value="Email:"&gt;
        &lt;/h:outputText&gt;
        &lt;h:inputText label="Email" value="#{customer.email}"&gt;
          &lt;f:validator validatorId="emailValidator" /&gt;
        &lt;/h:inputText&gt;
        &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt;
        &lt;h:commandButton action="confirmation" value="Save"&gt;
        &lt;/h:commandButton&gt;
      &lt;/h:panelGrid&gt;
    &lt;/h:form&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>The only difference between this page and the previous one is the use of the <code class="literal">styleClass</code> attribute of the <code class="literal">&lt;h:messages&gt; </code>tag. As mentioned earlier, the value of the <code class="literal">styleClass</code> attribute must match the name of a <a id="id186" class="indexterm"/>CSS style defined in a cascading style sheet that our page can access.</p><p>In our case, we defined a CSS style in <code class="literal">style.css</code> for messages as follows:</p><div class="informalexample"><pre class="programlisting">.errorMsg {
  color: red;
}</pre></div><p>We then used this style as the value of the <code class="literal">styleClass</code> attribute<a id="id187" class="indexterm"/> of our<a id="id188" class="indexterm"/> <code class="literal">&lt;h:messages&gt;</code> tag.</p><p>The following screenshot illustrates how the validation error messages look after we have implemented this change:</p><div class="mediaobject"><img src="graphics/6886EN_02_09.jpg" alt="Customizing message styles"/></div><p>In this particular case, we just set the color of the error message text to red, but we are only limited by CSS capabilities in <a id="id189" class="indexterm"/>setting the style of the error messages.</p></div><div class="section" title="Customizing message text"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec30"/>Customizing message text</h2></div></div></div><p>Sometimes it is desirable to override JSF's default validation errors. Default validation errors are defined in a resource<a id="id190" class="indexterm"/> bundle called <code class="literal">Messages.properties</code>. This file can be found inside the <code class="literal">javax.faces.jar</code> file under <code class="literal">[glassfish installation directory]/glassfish/modules</code>. It can be found under the <code class="literal">javax/faces</code> folder inside the JAR file. The file contains several messages, but we are only interested in validation errors at this point. The default validation error messages are defined as follows:</p><div class="informalexample"><pre class="programlisting">javax.faces.validator.DoubleRangeValidator.MAXIMUM={1}: Validation 
    Error: Value is greater than allowable maximum of "{0}"
javax.faces.validator.DoubleRangeValidator.MINIMUM={1}: Validation 
    Error: Value is less than allowable minimum of ''{0}''
javax.faces.validator.DoubleRangeValidator.NOT_IN_RANGE={2}: 
    Validation Error: Specified attribute is not between the 
    expected values of {0} and {1}.
javax.faces.validator.DoubleRangeValidator.TYPE={0}: Validation 
    Error: Value is not of the correct type
javax.faces.validator.LengthValidator.MAXIMUM={1}: Validation 
    Error: Value is greater than allowable maximum of ''{0}''
javax.faces.validator.LengthValidator.MINIMUM={1}: Validation 
    Error: Value is less than allowable minimum of ''{0}''
javax.faces.validator.LongRangeValidator.MAXIMUM={1}: Validation 
    Error: Value is greater than allowable maximum of ''{0}''
javax.faces.validator.LongRangeValidator.MINIMUM={1}: Validation 
    Error: Value is less than allowable minimum of ''{0}''
javax.faces.validator.LongRangeValidator.NOT_IN_RANGE={2}: 
    Validation Error: Specified attribute is not between the 
    expected values of {0} and {1}.
javax.faces.validator.LongRangeValidator.TYPE={0}: Validation 
    Error: Value is not of the correct type.
javax.faces.validator.NOT_IN_RANGE=Validation Error: Specified 
    attribute is not between the expected values of {0} and {1}.
javax.faces.validator.RegexValidator.PATTERN_NOT_SET=Regex pattern 
    must be set.
javax.faces.validator.RegexValidator.PATTERN_NOT_SET_detail=Regex 
    pattern must be set to non-empty value.
javax.faces.validator.RegexValidator.NOT_MATCHED=Regex Pattern not 
    matched
javax.faces.validator.RegexValidator.NOT_MATCHED_detail=Regex 
    pattern of ''{0}'' not matched
javax.faces.validator.RegexValidator.MATCH_EXCEPTION=Error in 
    regular expression.
javax.faces.validator.RegexValidator.MATCH_EXCEPTION_detail=Error 
    in regular expression, ''{0}''
javax.faces.validator.BeanValidator.MESSAGE={0}</pre></div><p>In order to override the default error messages, we need to create our own resource bundle using the same keys used in the default one, but altering the values to suit our needs. The following is a very simple <a id="id191" class="indexterm"/>customized resource bundle for our application:</p><div class="informalexample"><pre class="programlisting">javax.faces.validator.LengthValidator.MINIMUM={1}: minimum allowed 
    length is ''{0}''</pre></div><p>In this resource bundle, we override the error message for when the value entered for a field validated by the <code class="literal">&lt;f:validateLength&gt;</code> tag<a id="id192" class="indexterm"/> is less than the allowed minimum. In order to let our application know that we have a custom resource bundle for message properties, we need to modify the application's <code class="literal">faces-config.xml</code> file as follows:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8'?&gt;
&lt;faces-config version="2.0"
      
      
      xsi:schemaLocation="http://java.sun.com/xml/ns/javaee
      http://java.sun.com/xml/ns/javaee/web-facesconfig_2_0.xsd"&gt;
<span class="strong"><strong>  &lt;application&gt;</strong></span>
<span class="strong"><strong>    &lt;message-bundle&gt;net.ensode.Messages&lt;/message-bundle&gt;</strong></span>
<span class="strong"><strong>  &lt;/application&gt;</strong></span>
&lt;/faces-config&gt;</pre></div><p>As we can see, the only thing we need to do to the application's <code class="literal">faces-config.xml</code> file is to add a <code class="literal">&lt;message-bundle&gt;</code> element<a id="id193" class="indexterm"/> indicating the name and location of the resource bundle containing our custom messages.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note12"/>Note</h3><p>A custom error message text definition is one of the few cases in which we still need to define a <code class="literal">faces-config.xml</code> file for modern JSF applications. However, note how simple our <code class="literal">faces-config.xml</code> file is; it is a far cry from a typical <code class="literal">faces-config.xml</code> file for JSF 1.x, which typically contains named bean definitions, navigation rules, JSF validator definitions, and so on.</p></div></div><p>After adding our custom message resource bundle and modifying the application's <code class="literal">faces-config.xml</code> file, we can see our custom validation message in action, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_02_10.jpg" alt="Customizing message text"/></div><p>As can be seen in the screenshot, if we haven't overridden a validation message, the default will still be displayed. In our resource bundle, we only overrode the minimum length validation error message; therefore, our custom error message is shown for the <span class="strong"><strong>First Name</strong></span> text field. Since we didn't override the error messages for the other standard JSF validators, the default error<a id="id194" class="indexterm"/> message is shown for each one of them. The e-mail validator is the custom validator we developed previously in this chapter. Since it is a custom validator, its error message is not affected.</p></div></div>
<div class="section" title="Ajax-enabling JSF applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Ajax-enabling JSF applications</h1></div></div></div><p>Early versions of JSF did not include native Ajax support. Custom JSF library vendors were forced to implement Ajax in their own way. Unfortunately, this state of events introduced<a id="id195" class="indexterm"/> incompatibilities between JSF component libraries. JSF 2.0 standardized Ajax support by introducing the <code class="literal">&lt;f:ajax&gt;</code> tag.<a id="id196" class="indexterm"/>
</p><p>The following page illustrates the typical usage of the <code class="literal">&lt;f:ajax&gt;</code> tag:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      &gt;
  &lt;h:head&gt;
    &lt;title&gt;JSF Ajax Demo&lt;/title&gt;
  &lt;/h:head&gt;
  &lt;h:body&gt;
    &lt;h2&gt;JSF Ajax Demo&lt;/h2&gt;
    &lt;h:form&gt;
      &lt;h:messages/&gt;
      &lt;h:panelGrid columns="2"&gt;

        &lt;h:outputText value="Echo input:"/&gt;
<span class="strong"><strong>        &lt;h:inputText id="textInput" value="#{controller.text}"&gt;</strong></span>
<span class="strong"><strong>          &lt;f:ajax render="textVal" event="keyup"/&gt;</strong></span>
<span class="strong"><strong>        &lt;/h:inputText&gt;</strong></span>

        &lt;h:outputText value="Echo output:"/&gt;
        &lt;h:outputText id="textVal" value="#{controller.text}"/&gt;
      &lt;/h:panelGrid&gt;
      &lt;hr/&gt;
      &lt;h:panelGrid columns="2"&gt;
        &lt;h:panelGroup/&gt;
        &lt;h:panelGroup/&gt;
        &lt;h:outputText value="First Operand:"/&gt;
        &lt;h:inputText id="first" value="#{controller.firstOperand}" 
                         size="3"/&gt;
        &lt;h:outputText value="Second Operand:"/&gt;
        &lt;h:inputText id="second" 
                         value="#{controller.secondOperand}" 
                         size="3"/&gt;
        &lt;h:outputText value="Total:"/&gt;
        &lt;h:outputText id="sum" value="#{controller.total}"/&gt;
<span class="strong"><strong>        &lt;h:commandButton </strong></span>
<span class="strong"><strong>            actionListener="#{controller.calculateTotal}"</strong></span>
<span class="strong"><strong>                            value="Calculate Sum"&gt;</strong></span>
<span class="strong"><strong>          &lt;f:ajax execute="first second" render="sum"/&gt;</strong></span>
<span class="strong"><strong>        &lt;/h:commandButton&gt;</strong></span>
      &lt;/h:panelGrid&gt;
    &lt;/h:form&gt;
  &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>After deploying our application, our <a id="id197" class="indexterm"/>page renders as illustrated in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_02_11.jpg" alt="Ajax-enabling JSF applications"/></div><p>This example page illustrates two uses of the <code class="literal">&lt;f:ajax&gt;</code> tag. At the top of the page, we have used this tag for implementing a typical Ajax Echo example, in which we have an <code class="literal">&lt;h:outputText&gt;</code> component<a id="id198" class="indexterm"/> updating itself with the value of an input text component. Any time a character is entered into the input field, the value of the <code class="literal">&lt;h:outputText&gt;</code> component is automatically updated.</p><p>To implement the functionality described in the previous paragraph, we put an <code class="literal">&lt;f:ajax&gt;</code> tag inside an <code class="literal">&lt;h:inputText&gt;</code> tag. The value of the <code class="literal">render</code> attribute of the <code class="literal">&lt;f:ajax&gt;</code> tag must correspond to the ID of a component we wish to update after the Ajax request finishes. In our example, we wish to update the <code class="literal">&lt;h:outputText&gt;</code> component with an ID of "<code class="literal">textVal</code>"; therefore, we will use <a id="id199" class="indexterm"/>this value for the <code class="literal">render</code> attribute of our <code class="literal">&lt;f:ajax&gt;</code> tag.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note13"/>Note</h3><p>In some cases, we may need to render more than one JSF component after an Ajax event finishes; in order to accommodate this, we can add several IDs as the value of the <code class="literal">render</code> attribute, and we simply need to separate them by spaces.</p></div></div><p>The other <code class="literal">&lt;f:ajax&gt;</code> attribute <a id="id200" class="indexterm"/>we used in this instance is the <code class="literal">event</code> attribute. This attribute indicates the JavaScript event that triggers the Ajax event. In this particular case, we need to trigger the event any time a key is released while a user is typing into the input field; therefore, the appropriate event to use is <code class="literal">keyup</code>.</p><p>The following table lists <a id="id201" class="indexterm"/>all supported JavaScript events:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Event</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blur</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The component <a id="id202" class="indexterm"/>loses focus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">change</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The component loses focus, <a id="id203" class="indexterm"/>and its value is modified.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">click</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The component is<a id="id204" class="indexterm"/> clicked on.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dblclick</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The component is <a id="id205" class="indexterm"/>double-clicked on.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">focus</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The component<a id="id206" class="indexterm"/> gains focus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">keydown</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A key is depressed <a id="id207" class="indexterm"/>while the component has focus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">keypress</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A key is pressed <a id="id208" class="indexterm"/>or held down while the component has focus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">keyup</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A key is released while<a id="id209" class="indexterm"/> the component has focus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mousedown</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The mouse button<a id="id210" class="indexterm"/> is depressed while the component has focus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mousemove</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The mouse pointer is moved<a id="id211" class="indexterm"/> over the component.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mouseout</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The mouse <a id="id212" class="indexterm"/>pointer leaves the component.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mouseover</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The mouse pointer is placed<a id="id213" class="indexterm"/> over the component.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">mouseup</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The mouse<a id="id214" class="indexterm"/> button is released while the component has focus.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">select</code>
</p>
</td><td style="text-align: left" valign="top">
<p>The component's<a id="id215" class="indexterm"/> text is selected.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">valueChange</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Equivalent to <code class="literal">change</code>; the <a id="id216" class="indexterm"/>component loses focus and its value has been modified.</p>
</td></tr></tbody></table></div><p>We use the <code class="literal">&lt;f:ajax&gt;</code> tag<a id="id217" class="indexterm"/> once again farther down in the page to Ajax-enable a command button component. In this instance, we want to recalculate a value based on the value of two input components. In order to have the values on the server updated with the latest user input, we used the <code class="literal">execute</code> attribute of <code class="literal">&lt;f:ajax&gt;</code>; this attribute takes a space-separated list of component IDs to use as<a id="id218" class="indexterm"/> input. We then use the <code class="literal">render</code> attribute just as before to specify which components need to be re-rendered after the Ajax request finishes.</p><p>Notice that we used the <code class="literal">actionListener</code> attribute<a id="id219" class="indexterm"/> of <code class="literal">&lt;h:commandButton&gt;</code>. This attribute is typically used when we don't need to navigate to another page after clicking on the button. The value for this attribute is an action listener method we wrote in one of our named beans. Action listener methods must return void and take an instance of <code class="literal">javax.faces.event.ActionEvent</code> as their sole parameter.</p><p>The named bean for our application looks as follows:</p><div class="informalexample"><pre class="programlisting">package net.ensode.glassfishbook.jsfajax;

import javax.faces.event.ActionEvent;
import javax.faces.view.ViewScoped;
import javax.inject.Named;

@Named
@ViewScoped
public class Controller {

  private String text;
  private int firstOperand;
  private int secondOperand;
  private int total;
  
  public Controller() {
  }

<span class="strong"><strong>  public void calculateTotal(ActionEvent actionEvent) {</strong></span>
<span class="strong"><strong>    total = firstOperand + secondOperand;</strong></span>
<span class="strong"><strong>  }</strong></span>

  public String getText() {
    return text;
  }

  public void setText(String text) {
    this.text = text;
  }

  public int getFirstOperand() {
    return firstOperand;
  }

  public void setFirstOperand(int firstOperand) {
    this.firstOperand = firstOperand;
  }

  public int getSecondOperand() {
    return secondOperand;
  }

  public void setSecondOperand(int secondOperand) {
    this.secondOperand = secondOperand;
  }

  public int getTotal() {
    return total;
  }

  public void setTotal(int total) {
    this.total = total;
  }
}</pre></div><p>Notice that we didn't have to do anything special in our named bean to enable Ajax in our application. It is all controlled by<a id="id220" class="indexterm"/> the <code class="literal">&lt;f:ajax&gt;</code> tag on the page.</p><p>As we can see from this example, Ajax-enabling JSF applications is very simple. We simply need to use a single tag to Ajax-enable our page, without having to write a single line of JavaScript, JSON, or XML.</p></div>
<div class="section" title="JSF 2.2 HTML5 support"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>JSF 2.2 HTML5 support</h1></div></div></div><p>HTML 5 is the latest version of the HTML specification. It includes several improvements over the previous version of HTML. JSF 2.2 includes several updates to make JSF pages work nicely with HTML5.</p><div class="section" title="The HTML5-friendly markup"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec31"/>The HTML5-friendly markup</h2></div></div></div><p>Through the use of pass-through elements, we can develop our pages using HTML 5 tags and also treat them as JSF components. <a id="id221" class="indexterm"/>To do this, we need to specify at least one of the <code class="literal">element</code> attributes using the <code class="literal">http://xmlns.jcp.org/jsf</code> namespace. The following example demonstrates this approach in action:</p><div class="informalexample"><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html 
<span class="strong"><strong>      &gt;      </strong></span>
<span class="strong"><strong>    &lt;head jsf:id="head"&gt;</strong></span>
        &lt;title&gt;JSF Page with HTML5 Markup&lt;/title&gt;
<span class="strong"><strong>        &lt;link jsf:library="css" jsf:name="styles.css" </strong></span>
<span class="strong"><strong>            rel="stylesheet" </strong></span>
<span class="strong"><strong>            type="text/css" </strong></span>
<span class="strong"><strong>            href="resources/css/styles.css"/&gt;</strong></span>
    &lt;/head&gt;
<span class="strong"><strong>    &lt;body jsf:id="body"&gt;</strong></span>
<span class="strong"><strong>        &lt;form jsf:prependId="false"&gt;</strong></span>
            &lt;table style="border-spacing: 0; border-collapse: 
                collapse"&gt;
                &lt;tr&gt;
                    &lt;td class="rightAlign"&gt;
<span class="strong"><strong>                      &lt;label jsf:for="firstName"&gt;First </strong></span>
<span class="strong"><strong>                          Name&lt;/label&gt;</strong></span>
                    &lt;/td&gt;
                    &lt;td class="leftAlign"&gt;
<span class="strong"><strong>                      &lt;input type="text" jsf:id="firstName"</strong></span>
<span class="strong"><strong>                           jsf:value="#{customer.firstName}"/&gt;</strong></span>
                       &lt;/td&gt;
                &lt;/tr&gt;
                 &lt;tr&gt;
                    &lt;td class="rightAlign"&gt;
<span class="strong"><strong>                      &lt;label jsf:for="lastName"&gt;Last Name&lt;/label&gt;</strong></span>
                    &lt;/td&gt;
                    &lt;td class="leftAlign"&gt;
<span class="strong"><strong>                      &lt;input type="text" jsf:id="lastName"</strong></span>
<span class="strong"><strong>                                  jsf:value="#{customer.lastName}"/&gt;</strong></span>
                    &lt;/td&gt;
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td class="rightAlign"&gt;
<span class="strong"><strong>                      &lt;label jsf:for="email"&gt;Email </strong></span>
<span class="strong"><strong>                          Address&lt;/label&gt;</strong></span>
                    &lt;/td&gt;
                    &lt;td class="leftAlign"&gt;
<span class="strong"><strong>                      &lt;input type="email" jsf:id="email"</strong></span>
<span class="strong"><strong>                                  jsf:value="#{customer.email}"/&gt;&lt;/td&gt;</strong></span>
                &lt;/tr&gt;
                &lt;tr&gt;
                    &lt;td&gt;&lt;/td&gt;
                  &lt;td&gt;
<span class="strong"><strong>                    &lt;input type="submit" </strong></span>
<span class="strong"><strong>                        jsf:action="confirmation"</strong></span>
<span class="strong"><strong>                                value="Submit"/&gt;</strong></span>
                  &lt;/td&gt;
                &lt;/tr&gt;
            &lt;/table&gt;
        &lt;/form&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p>The first thing we should notice about this example is the XML namespace prefixed by <code class="literal">jsf</code> near the top of the page. This namespace allows us to add JSF-specific attributes to HTML 5 pages. When the JSF runtime encounters attributes prefixed by <code class="literal">jsf</code> in any of the tags on the page, it automatically<a id="id222" class="indexterm"/> converts the HTML5 tag to the equivalent JSF component. JSF-specific tags are the same as in regular JSF pages, except that they are prefixed with <code class="literal">jsf</code>. Therefore, at this point, they should be self-explanatory and will not be discussed in detail. Our example will render and behave just like the first example in this chapter.</p><p>The technique described in this section is useful if you have experienced HTML web designers in your team who prefer to have full control over the look of the page. The pages are developed using standard HTML5 with JSF-specific attributes so that the JSF runtime can manage user input.</p><p>If your team consists primarily of Java developers with limited CSS/HTML knowledge, then it is preferable to develop the web pages for your web application using JSF components. HTML 5 introduced several new attributes that didn't exist in the previous versions of HTML. For this reason, JSF 2.2 introduces the ability to add arbitrary attributes to JSF components. This JSF/HTML5 integration technique is discussed in the next section.</p></div><div class="section" title="Pass-through elements"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec32"/>Pass-through elements</h2></div></div></div><p>JSF 2.2 allows the definition of any arbitrary attributes (not processed by the JSF engine). These attributes are simply<a id="id223" class="indexterm"/> rendered as is on the generated HTML displayed in the browser. The following example is a<a id="id224" class="indexterm"/> new version of an earlier example in this chapter, which has been modified to take advantage of the <a id="id225" class="indexterm"/>HTML5 pass-through <a id="id226" class="indexterm"/>elements:</p><div class="informalexample"><pre class="programlisting">&lt;?xml version='1.0' encoding='UTF-8' ?&gt;
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html 
      
      
<span class="strong"><strong>      &gt;</strong></span>
    &lt;h:head&gt;
        &lt;title&gt;Enter Customer Data&lt;/title&gt;
    &lt;/h:head&gt;
    &lt;h:body&gt;
        &lt;h:outputStylesheet library="css" name="styles.css"/&gt;
        &lt;h:form id="customerForm"&gt;
            &lt;h:messages/&gt;
            &lt;h:panelGrid columns="2"
                         columnClasses="rightAlign,leftAlign"&gt;
                &lt;h:outputLabel for="firstName" value="First Name:"&gt;
                &lt;/h:outputLabel&gt;
                &lt;h:inputText id="firstName"
                             label="First Name"
                             value="#{customer.firstName}"
                             required="true"
<span class="strong"><strong>                             p:placeholder="First Name"&gt;</strong></span>
                    &lt;f:validateLength minimum="2" maximum="30"&gt;
                    &lt;/f:validateLength&gt;
                &lt;/h:inputText&gt;
                &lt;h:outputLabel for="lastName" value="Last Name:"&gt;
                &lt;/h:outputLabel&gt;
                &lt;h:inputText id="lastName"
                             label="Last Name"
                             value="#{customer.lastName}"
                             required="true"
<span class="strong"><strong>                             p:placeholder="Last Name"&gt;</strong></span>
                    &lt;f:validateLength minimum="2" maximum="30"&gt;
                    &lt;/f:validateLength&gt;
                &lt;/h:inputText&gt;
                &lt;h:outputLabel for="email" value="Email:"&gt;
                &lt;/h:outputLabel&gt;
                &lt;h:inputText id="email" 
                             label="Email" 
                             value="#{customer.email}"
<span class="strong"><strong>                             p:placeholder="Email Address"&gt;</strong></span>
                    &lt;f:validateLength minimum="3" maximum="30"&gt;
                    &lt;/f:validateLength&gt;
                &lt;/h:inputText&gt;
                &lt;h:panelGroup&gt;&lt;/h:panelGroup&gt;
                &lt;h:commandButton action="confirmation" value="Save"&gt;
                &lt;/h:commandButton&gt;
            &lt;/h:panelGrid&gt;
        &lt;/h:form&gt;
    &lt;/h:body&gt;
&lt;/html&gt;</pre></div><p>The first thing we should notice about this example is the addition of the <code class="literal">id227" class="indexterm"/&gt;by the defined prefix for the namespace at the top of the application (<code class="literal">p</code>, in our case). The placeholder HTML<a id="id228" class="indexterm"/> attribute simply adds some placeholder text to the input fields, which is automatically deleted once the user starts typing in the input field (this technique was commonly implemented "by hand" using JavaScript before HTML5).</code></p><p>The following screenshot shows our updated page in action:</p><div class="mediaobject"><img src="graphics/6886EN_02_12.jpg" alt="Pass-through elements"/></div></div></div>
<div class="section" title="JSF 2.2 Faces Flows"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>JSF 2.2 Faces Flows</h1></div></div></div><p>Faces Flows is a new JSF 2.2 feature that defines a scope that can span several pages. Flow scoped beans are created <a id="id229" class="indexterm"/>when the user enters a flow (a set of web pages) and are destroyed when the user leaves the flow.</p><p>Faces Flows adopts the convention over configuration principle of JSF. The following conventions are typically used when developing applications employing Faces Flows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">All pages in the flow must be placed in <a id="id230" class="indexterm"/>a directory with a name that defines the name of the flow</li><li class="listitem" style="list-style-type: disc">An XML configuration file named after the directory name and suffixed with <code class="literal">-flow</code> must exist inside the directory that contains the pages in the flow (the file may be empty, but it must exist)</li><li class="listitem" style="list-style-type: disc">The first page in the flow must be named after the directory name that contains the flow</li><li class="listitem" style="list-style-type: disc">The last page in the flow must not be located inside the directory containing the flow and must be named after the directory name and suffixed with <code class="literal">-return</code></li></ul></div><p>The following screenshot illustrates these conventions:</p><div class="mediaobject"><img src="graphics/6886EN_02_13.jpg" alt="JSF 2.2 Faces Flows"/></div><p>In this example, we define a flow named <code class="literal">customerinfo</code>; by convention, these files are inside a directory named <code class="literal">customerinfo</code>, and the first page of the flow is named <code class="literal">customerinfo.xhtml</code><a id="id231" class="indexterm"/> (there are no restrictions on the names of other pages in the flow). When we exit the flow, we navigate to <code class="literal">customerinfo-return.xhtml</code>, which follows the naming convention and takes us out of the flow.</p><p>The markup for the pages doesn't illustrate anything we haven't seen before, so we will not show it. All example code is available as part of this book's code download bundle.</p><p>All the pages in our example store data in a named bean called <code class="literal">Customer</code>, which has a scope of flow.</p><div class="informalexample"><pre class="programlisting">@Named
<span class="strong"><strong>@FlowScoped("customerinfo")</strong></span>
public class Customer implements Serializable {
   //class body omitted
}</pre></div><p>The <code class="literal">@FlowScoped</code> annotation<a id="id232" class="indexterm"/> has<a id="id233" class="indexterm"/> a <code class="literal">value</code> attribute that must match the name of the flow that the bean is meant to work with (<code class="literal">customerinfo</code> in this example).</p><p>This example creates a wizard-style set of pages in which data for a user is entered across several pages in the flow.</p><p>On the first page, we enter information about the name.</p><div class="mediaobject"><img src="graphics/6886EN_02_14.jpg" alt="JSF 2.2 Faces Flows"/></div><p>On the second page, we enter address information as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_02_15.jpg" alt="JSF 2.2 Faces Flows"/></div><p>On the next page,<a id="id234" class="indexterm"/> we enter phone number information as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_02_16.jpg" alt="JSF 2.2 Faces Flows"/></div><p>Finally, we display a confirmation page<a id="id235" class="indexterm"/> as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/6886EN_02_17.jpg" alt="JSF 2.2 Faces Flows"/></div><p>If the user verifies that the information<a id="id236" class="indexterm"/> is correct, we navigate outside the flow to <code class="literal">customerinfo-return.xhtml</code>; otherwise, we go back to the first page in the flow to allow the user to make any necessary corrections.</p></div>
<div class="section" title="Additional JSF component libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Additional JSF component libraries</h1></div></div></div><p>In addition to the standard JSF component libraries, there are a number of third-party JSF tag libraries available. The following table lists some of the most popular ones:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Tag library</p>
</th><th style="text-align: left" valign="bottom">
<p>Distributor</p>
</th><th style="text-align: left" valign="bottom">
<p>License</p>
</th><th style="text-align: left" valign="bottom">
<p>URL</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>ICEfaces<a id="id237" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>ICEsoft<a id="id238" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>MPL 1.1</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.icefaces.org">http://www.icefaces.org</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>RichFaces<a id="id239" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Red Hat/JBoss</p>
</td><td style="text-align: left" valign="top">
<p>LGPL<a id="id240" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.jboss.org/richfaces">http://www.jboss.org/richfaces</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Primefaces<a id="id241" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>Prime Technology</p>
</td><td style="text-align: left" valign="top">
<p>Apache 2.0<a id="id242" class="indexterm"/>
</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="http://www.primefaces.org">http://www.primefaces.org</a>
</p>
</td></tr></tbody></table></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Summary</h1></div></div></div><p>In this chapter, we covered how to develop web-based applications using JavaServer Faces, the standard component framework for the Java EE platform. We covered how to write a simple application by creating pages using Facelets as the view technology and CDI named beans. We also covered how to validate user input by using JSF's standard validators and by creating our own custom validators or by writing validator methods. Additionally, we covered how to customize standard JSF error messages, both the message text and the message style (font, color, and so on). Also, we covered how to develop Ajax-enabled JSF pages as well as how to integrate JSF and HTML5.</p><p>In the next chapter, we will cover how to interact with relational databases via the Java Persistence API.</p></div></body></html>